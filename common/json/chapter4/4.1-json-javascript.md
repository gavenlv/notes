# 4.1 JSON与JavaScript

## JavaScript中的JSON原生支持

JSON源自JavaScript，因此JavaScript原生支持JSON的解析和生成。在ECMAScript 5（ES5）中，JSON被正式纳入JavaScript标准，提供了全局的`JSON`对象，包含两个核心方法：`JSON.parse()`和`JSON.stringify()`。

## JSON.parse() - 解析JSON字符串

`JSON.parse()`方法用于将JSON字符串转换为JavaScript对象。

### 基本用法

```javascript
// JSON字符串
const jsonString = `{
  "name": "张三",
  "age": 30,
  "isActive": true,
  "courses": ["数学", "物理", "化学"],
  "address": {
    "street": "人民路123号",
    "city": "北京",
    "zipCode": "100000"
  }
}`;

// 解析为JavaScript对象
const user = JSON.parse(jsonString);

console.log(user.name);        // 输出：张三
console.log(user.age);         // 输出：30
console.log(user.isActive);    // 输出：true
console.log(user.courses[0]);  // 输出：数学
console.log(user.address.city); // 输出：北京
```

### 错误处理

如果JSON字符串格式不正确，`JSON.parse()`会抛出`SyntaxError`异常。因此，最好使用`try-catch`块进行错误处理。

```javascript
const invalidJsonString = `{
  "name": "张三",
  "age": 30,  // 尾随逗号
}`;

try {
  const user = JSON.parse(invalidJsonString);
  console.log(user);
} catch (error) {
  console.error("解析JSON时出错:", error.message);
  // 输出：解析JSON时出错: Unexpected token } in JSON at position ...
}
```

### 带回调函数的parse

`JSON.parse()`还接受第二个参数，是一个回调函数，可以在解析过程中对值进行转换。

```javascript
const jsonString = `{
  "name": "张三",
  "birthDate": "1990-01-15",
  "lastLogin": "2023-07-15T08:30:00Z"
}`;

const user = JSON.parse(jsonString, (key, value) => {
  // 将日期字符串转换为Date对象
  if (key === "birthDate" || key === "lastLogin") {
    return new Date(value);
  }
  return value;
});

console.log(user.birthDate instanceof Date);  // 输出：true
console.log(user.lastLogin instanceof Date);  // 输出：true
```

## JSON.stringify() - 生成JSON字符串

`JSON.stringify()`方法用于将JavaScript对象转换为JSON字符串。

### 基本用法

```javascript
// JavaScript对象
const user = {
  name: "张三",
  age: 30,
  isActive: true,
  courses: ["数学", "物理", "化学"],
  address: {
    street: "人民路123号",
    city: "北京",
    zipCode: "100000"
  }
};

// 转换为JSON字符串
const jsonString = JSON.stringify(user);
console.log(jsonString);
// 输出：{"name":"张三","age":30,"isActive":true,"courses":["数学","物理","化学"],"address":{"street":"人民路123号","city":"北京","zipCode":"100000"}}
```

### 格式化输出

`JSON.stringify()`可以接受第二个参数（缩进空格数）来格式化输出，提高可读性。

```javascript
const user = {
  name: "张三",
  age: 30,
  courses: ["数学", "物理", "化学"]
};

// 使用2个空格缩进
const prettyJson = JSON.stringify(user, null, 2);
console.log(prettyJson);

// 输出格式化的JSON：
// {
//   "name": "张三",
//   "age": 30,
//   "courses": [
//     "数学",
//     "物理",
//     "化学"
//   ]
// }
```

### 过滤属性

`JSON.stringify()`的第二个参数也可以是一个数组或函数，用于过滤或转换属性。

```javascript
const user = {
  name: "张三",
  age: 30,
  password: "secret123",  // 不希望在JSON中包含密码
  isAdmin: false,
  lastLogin: new Date()
};

// 使用数组指定要包含的属性
const filteredJson = JSON.stringify(user, ["name", "age", "isAdmin"]);
console.log(filteredJson);
// 输出：{"name":"张三","age":30,"isAdmin":false}

// 使用函数过滤和转换属性
const transformedJson = JSON.stringify(user, (key, value) => {
  // 不包含密码属性
  if (key === "password") {
    return undefined;
  }
  
  // 将日期转换为ISO字符串
  if (value instanceof Date) {
    return value.toISOString();
  }
  
  return value;
}, 2);

console.log(transformedJson);
// 输出：
// {
//   "name": "张三",
//   "age": 30,
//   "isAdmin": false,
//   "lastLogin": "2023-07-15T08:30:00.000Z"
// }
```

## JavaScript与JSON数据类型映射

理解JavaScript与JSON之间的数据类型映射对于正确处理数据至关重要。

| JavaScript类型 | JSON类型 | 说明 |
|---------------|----------|------|
| 对象(Object) | 对象 | 普通对象转换为JSON对象 |
| 数组(Array) | 数组 | JavaScript数组转换为JSON数组 |
| 字符串(String) | 字符串 | 直接映射 |
| 数字(Number) | 数字 | 有限制的映射（NaN和Infinity转为null） |
| 布尔值(Boolean) | 布尔值 | 直接映射 |
| null | null | 直接映射 |
| undefined | 不支持 | 转换时会被忽略或转换为null |
| 函数(Function) | 不支持 | 转换时会被忽略 |
| Symbol | 不支持 | 转换时会被忽略 |
| Date | 字符串 | 默认转换为ISO字符串 |
| RegExp | 对象 | 转换为空对象{} |

### 特殊情况处理

```javascript
const specialData = {
  name: "张三",
  age: NaN,           // NaN
  score: Infinity,     // Infinity
  email: undefined,    // undefined
  bio: function() {    // 函数
    return "一个简单的简介";
  },
  id: Symbol("user"), // Symbol
  created: new Date() // Date对象
};

console.log(JSON.stringify(specialData, null, 2));
// 输出：
// {
//   "name": "张三",
//   "age": null,
//   "score": null,
//   "created": "2023-07-15T08:30:00.000Z"
// }
```

## 在JavaScript中处理JSON的最佳实践

### 1. 错误处理

始终使用`try-catch`块处理JSON解析错误：

```javascript
function safeJsonParse(jsonString, defaultValue = null) {
  try {
    return JSON.parse(jsonString);
  } catch (error) {
    console.error("JSON解析错误:", error.message);
    return defaultValue;
  }
}

const invalidJson = '{"name": "张三", "age": 30,}';  // 有语法错误
const user = safeJsonParse(invalidJson, {});
console.log(user);  // 输出：{}
```

### 2. 深度拷贝

利用JSON实现对象的深度拷贝（注意：这种方法有局限性）：

```javascript
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

const original = {
  name: "张三",
  courses: ["数学", "物理"],
  address: {
    city: "北京"
  }
};

const copy = deepClone(original);

// 修改原始对象
original.courses.push("化学");
original.address.city = "上海";

console.log(original);
// 输出：{ name: '张三', courses: [ '数学', '物理', '化学' ], address: { city: '上海' } }

console.log(copy);
// 输出：{ name: '张三', courses: [ '数学', '物理' ], address: { city: '北京' } }
```

**局限性**：
- 不能处理函数、Symbol、undefined
- 会丢失原型链
- 会忽略不可枚举属性
- Date对象会被转换为字符串
- 循环引用会抛出错误

### 3. 处理大型JSON

处理大型JSON时，考虑使用流式处理或分块处理：

```javascript
// 分块处理大型数组
function processLargeJsonInChunks(jsonString, chunkSize, processor) {
  const data = JSON.parse(jsonString);
  
  if (Array.isArray(data)) {
    for (let i = 0; i < data.length; i += chunkSize) {
      const chunk = data.slice(i, i + chunkSize);
      processor(chunk);
    }
  } else {
    processor(data);
  }
}

// 使用示例
const largeArray = JSON.stringify(Array.from({ length: 10000 }, (_, i) => ({ id: i, name: `项${i}` })));

processLargeJsonInChunks(largeArray, 1000, (chunk) => {
  console.log(`处理${chunk.length}个项目，第一个项目ID: ${chunk[0].id}`);
});
```

### 4. 自定义JSON序列化

为复杂对象定义自定义序列化和反序列化方法：

```javascript
class User {
  constructor(id, name, birthDate) {
    this.id = id;
    this.name = name;
    this.birthDate = birthDate;
  }
  
  // 自定义序列化方法
  toJSON() {
    return {
      id: this.id,
      name: this.name,
      birthDate: this.birthDate.toISOString().split('T')[0]  // 只保留日期部分
    };
  }
  
  // 自定义反序列化方法（静态方法）
  static fromJSON(json) {
    const data = typeof json === 'string' ? JSON.parse(json) : json;
    return new User(
      data.id,
      data.name,
      new Date(data.birthDate)
    );
  }
}

// 创建用户实例
const user = new User("user_001", "张三", new Date("1990-01-15"));

// 序列化
const jsonUser = JSON.stringify(user);
console.log(jsonUser);
// 输出：{"id":"user_001","name":"张三","birthDate":"1990-01-15"}

// 反序列化
const restoredUser = User.fromJSON(jsonUser);
console.log(restoredUser instanceof User);  // 输出：true
console.log(restoredUser.birthDate instanceof Date);  // 输出：true
```

## 实际应用场景

### 1. Web API通信

使用JavaScript与Web API通信时，JSON是默认的数据交换格式：

```javascript
// 使用fetch API获取JSON数据
async function fetchUserData(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`);
    
    if (!response.ok) {
      throw new Error(`HTTP错误: ${response.status}`);
    }
    
    const userData = await response.json();  // 自动解析JSON
    console.log("用户数据:", userData);
    return userData;
  } catch (error) {
    console.error("获取用户数据失败:", error.message);
    return null;
  }
}

// 发送JSON数据
async function updateUserProfile(userId, profileData) {
  try {
    const response = await fetch(`/api/users/${userId}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(profileData)  // 转换为JSON字符串
    });
    
    if (!response.ok) {
      throw new Error(`HTTP错误: ${response.status}`);
    }
    
    const updatedUser = await response.json();
    console.log("更新后的用户数据:", updatedUser);
    return updatedUser;
  } catch (error) {
    console.error("更新用户资料失败:", error.message);
    return null;
  }
}

// 使用示例
fetchUserData("user_001")
  .then(user => {
    if (user) {
      return updateUserProfile(user.id, { name: "张三", age: 31 });
    }
  });
```

### 2. 本地存储

使用localStorage存储JSON数据：

```javascript
// 保存数据到本地存储
function saveToLocalStorage(key, data) {
  try {
    const jsonString = JSON.stringify(data);
    localStorage.setItem(key, jsonString);
    console.log(`数据已保存到本地存储: ${key}`);
  } catch (error) {
    console.error("保存到本地存储失败:", error.message);
  }
}

// 从本地存储读取数据
function loadFromLocalStorage(key, defaultValue = null) {
  try {
    const jsonString = localStorage.getItem(key);
    if (jsonString === null) {
      return defaultValue;
    }
    return JSON.parse(jsonString);
  } catch (error) {
    console.error("从本地存储读取失败:", error.message);
    return defaultValue;
  }
}

// 使用示例
const settings = {
  theme: "dark",
  language: "zh-CN",
  notifications: true,
  fontSize: 16
};

saveToLocalStorage("appSettings", settings);

const loadedSettings = loadFromLocalStorage("appSettings", {
  theme: "light",
  language: "en",
  notifications: false,
  fontSize: 14
});

console.log("加载的设置:", loadedSettings);
```

### 3. 配置管理

使用JSON管理应用程序配置：

```javascript
// 默认配置
const defaultConfig = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  retryAttempts: 3,
  features: {
    darkMode: true,
    betaFeatures: false
  },
  logging: {
    level: "info",
    console: true,
    file: false
  }
};

// 加载配置文件
async function loadConfig(configPath = "/config.json") {
  try {
    const response = await fetch(configPath);
    const serverConfig = await response.json();
    
    // 合并默认配置和服务器配置
    const finalConfig = mergeConfigs(defaultConfig, serverConfig);
    return finalConfig;
  } catch (error) {
    console.warn("加载配置文件失败，使用默认配置:", error.message);
    return defaultConfig;
  }
}

// 深度合并配置
function mergeConfigs(defaultConfig, customConfig) {
  const result = { ...defaultConfig };
  
  for (const key in customConfig) {
    if (customConfig[key] && typeof customConfig[key] === 'object' && !Array.isArray(customConfig[key])) {
      result[key] = mergeConfigs(result[key] || {}, customConfig[key]);
    } else {
      result[key] = customConfig[key];
    }
  }
  
  return result;
}

// 使用配置
loadConfig().then(config => {
  console.log("最终配置:", config);
  // 应用配置
  applyConfig(config);
});

function applyConfig(config) {
  // 应用API URL
  console.log(`使用API地址: ${config.apiUrl}`);
  
  // 应用功能开关
  if (config.features.darkMode) {
    document.body.classList.add('dark-theme');
  }
  
  // 应用日志设置
  if (config.logging.console) {
    console.log("控制台日志已启用");
  }
}
```

## 实验环节：JavaScript与JSON实践

### 实验1：创建学生管理系统

使用JavaScript和JSON创建一个简单的学生管理系统，包含以下功能：

1. 添加学生（包含姓名、年龄、成绩等信息）
2. 查询学生（按姓名或ID）
3. 更新学生信息
4. 删除学生
5. 计算平均成绩
6. 将数据保存到localStorage

### 实验2：JSON数据转换器

创建一个JSON数据转换器，实现以下功能：

1. 将扁平化的JSON转换为嵌套结构
2. 将嵌套的JSON转换为扁平化结构
3. 按特定字段排序JSON数组
4. 过滤JSON数组中的数据
5. 聚合JSON数组中的数据

### 实验3：API数据处理

模拟从API获取JSON数据并进行处理：

1. 创建模拟API响应数据
2. 处理分页数据
3. 处理错误响应
4. 数据缓存和更新
5. 请求重试机制

## 小结

本节我们深入探讨了JSON与JavaScript的集成：

1. **JavaScript中的JSON原生支持**：
   - `JSON.parse()`：将JSON字符串转换为JavaScript对象
   - `JSON.stringify()`：将JavaScript对象转换为JSON字符串
   - 错误处理和回调函数

2. **JavaScript与JSON数据类型映射**：
   - 各种JavaScript类型与JSON类型的对应关系
   - 特殊情况的处理（NaN、Infinity、undefined等）

3. **JavaScript中处理JSON的最佳实践**：
   - 错误处理
   - 深度拷贝
   - 处理大型JSON
   - 自定义序列化和反序列化

4. **实际应用场景**：
   - Web API通信
   - 本地存储
   - 配置管理

JavaScript与JSON的紧密集成使得JSON成为Web开发中最常用的数据交换格式。在下一节中，我们将探讨JSON与Python的集成，了解如何在Python环境中使用JSON。

## 代码示例

请查看`code/chapter4/json-javascript`目录，其中包含了：

1. `parse_examples.js` - JSON解析示例
2. `stringify_examples.js` - JSON生成示例
3. `error_handling.js` - JSON错误处理示例
4. `deep_clone.js` - 使用JSON实现深度拷贝
5. `custom_serialization.js` - 自定义序列化示例
6. `api_communication.js` - Web API通信示例
7. `local_storage.js` - 本地存储示例
8. `config_management.js` - 配置管理示例
9. `student_management.js` - 学生管理系统示例
10. `json_transformer.js` - JSON数据转换器示例