# 6.3 错误处理与调试

## JSON错误处理概述

在处理JSON数据时，错误是不可避免的。常见的JSON错误包括语法错误、类型错误、结构错误等。本节将探讨如何有效地处理这些错误，以及调试JSON问题的技巧。

## JSON解析错误

### 1. 常见语法错误

JSON解析错误是最常见的JSON错误类型：

```json
// 错误1：使用单引号
{
  'name': '张三',  // 错误：JSON要求使用双引号
  'age': 30
}

// 错误2：尾随逗号
{
  "name": "张三",
  "age": 30,  // 错误：最后一个属性后不能有逗号
}

// 错误3：未引用的键
{
  name: "张三",  // 错误：键必须用双引号包围
  "age": 30
}

// 错误4：注释
{
  "name": "张三",
  "age": 30,
  // "active": true  // 错误：JSON不支持注释
}

// 错误5：未定义值
{
  "name": "张三",
  "age": undefined  // 错误：JSON不支持undefined
}
```

### 2. 解析错误处理

在JavaScript中处理JSON解析错误：

```javascript
// 基本错误处理
function safeJsonParse(jsonString, defaultValue = null) {
  try {
    return JSON.parse(jsonString);
  } catch (error) {
    console.error('JSON解析失败:', error.message);
    return defaultValue;
  }
}

// 详细错误处理
function detailedJsonParse(jsonString, defaultValue = null) {
  try {
    return JSON.parse(jsonString);
  } catch (error) {
    const errorDetails = {
      message: error.message,
      raw: jsonString,
      lineNumber: extractLineNumber(error.message),
      characterPosition: extractCharacterPosition(error.message),
      possibleCauses: identifyPossibleCauses(error.message, jsonString)
    };
    
    console.error('JSON解析失败详情:', errorDetails);
    return defaultValue;
  }
}

// 提取错误行号
function extractLineNumber(errorMessage) {
  const lineMatch = errorMessage.match(/line (\d+)/i);
  return lineMatch ? parseInt(lineMatch[1]) : null;
}

// 提取错误字符位置
function extractCharacterPosition(errorMessage) {
  const positionMatch = errorMessage.match(/position (\d+)/i);
  return positionMatch ? parseInt(positionMatch[1]) : null;
}

// 识别可能的原因
function identifyPossibleCauses(errorMessage, jsonString) {
  const causes = [];
  
  if (errorMessage.includes('Unexpected token')) {
    if (errorMessage.includes("'") || errorMessage.includes("'")) {
      causes.push('使用了单引号而非双引号');
    }
    if (errorMessage.includes('undefined')) {
      causes.push('包含undefined值');
    }
    if (errorMessage.includes('comment')) {
      causes.push('包含注释');
    }
  }
  
  if (errorMessage.includes('Expected property name or')) {
    causes.push('键名未正确引用');
  }
  
  if (errorMessage.includes('Expecting ',' or '}')) {
    causes.push('可能有多余的逗号');
  }
  
  return causes;
}

// 使用示例
const invalidJson = '{ "name": "张三", "age": 30, }';
const result = detailedJsonParse(invalidJson, {});
console.log('解析结果:', result);
```

### 3. JSON修复工具

自动修复常见的JSON错误：

```javascript
// JSON自动修复工具
const JsonRepairer = {
  // 修复常见的JSON错误
  repair: function(jsonString) {
    let repaired = jsonString;
    
    // 1. 移除注释
    repaired = this.removeComments(repaired);
    
    // 2. 修复单引号
    repaired = this.fixQuotes(repaired);
    
    // 3. 修复未引用的键
    repaired = this.fixUnquotedKeys(repaired);
    
    // 4. 移除尾随逗号
    repaired = this.removeTrailingCommas(repaired);
    
    // 5. 替换undefined
    repaired = this.replaceUndefined(repaired);
    
    return repaired;
  },
  
  // 移除注释
  removeComments: function(jsonString) {
    // 移除单行注释
    let result = jsonString.replace(/\/\/.*$/gm, '');
    
    // 移除多行注释
    result = result.replace(/\/\*[\s\S]*?\*\//g, '');
    
    return result;
  },
  
  // 修复引号
  fixQuotes: function(jsonString) {
    // 将单引号替换为双引号（小心处理字符串内的单引号）
    let result = jsonString;
    
    // 简化处理：直接替换单引号为双引号
    result = result.replace(/'/g, '"');
    
    return result;
  },
  
  // 修复未引用的键
  fixUnquotedKeys: function(jsonString) {
    // 匹配未引用的键名
    return jsonString.replace(/(\w+):/g, '"$1":');
  },
  
  // 移除尾随逗号
  removeTrailingCommas: function(jsonString) {
    // 移除对象中的尾随逗号
    let result = jsonString.replace(/,(\s*[}\]])/g, '$1');
    
    // 移除数组中的尾随逗号
    result = result.replace(/,(\s*\])/g, '$1');
    
    return result;
  },
  
  // 替换undefined
  replaceUndefined: function(jsonString) {
    return jsonString.replace(/\bundefined\b/g, 'null');
  },
  
  // 尝试解析修复后的JSON
  tryParseAndRepair: function(jsonString, maxAttempts = 3) {
    let lastError = null;
    let currentJson = jsonString;
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        return JSON.parse(currentJson);
      } catch (error) {
        lastError = error;
        currentJson = this.repair(currentJson);
        
        if (attempt < maxAttempts) {
          console.log(`尝试修复 (第${attempt}次)...`);
        }
      }
    }
    
    console.error(`无法修复JSON，经过${maxAttempts}次尝试`);
    console.error('最后错误:', lastError.message);
    return null;
  }
};

// 使用示例
const brokenJson = `{
  // 用户信息
  name: '张三',  // 使用单引号
  age: 30,       // 尾随逗号
  hobbies: undefined,  // undefined值
}`;

const repairedJson = JsonRepairer.tryParseAndRepair(brokenJson);
console.log('修复后的JSON:', repairedJson);
```

## JSON类型错误

### 1. 类型不匹配

JSON解析后的JavaScript类型可能与预期不符：

```javascript
// 类型不匹配示例
const jsonData = {
  "age": "30",        // 字符串而非数字
  "isActive": "true",  // 字符串而非布尔值
  "score": "null",     // 字符串而非null
  "count": "",         // 空字符串而非数字
  "config": "[]",      // 字符串而非数组
  "data": "{}"         // 字符串而非对象
};

// 类型转换工具
const TypeConverter = {
  // 转换为数字
  toNumber: function(value, defaultValue = 0) {
    if (value === null || value === undefined || value === '') {
      return defaultValue;
    }
    
    const num = Number(value);
    return isNaN(num) ? defaultValue : num;
  },
  
  // 转换为布尔值
  toBoolean: function(value, defaultValue = false) {
    if (value === null || value === undefined) {
      return defaultValue;
    }
    
    if (typeof value === 'boolean') {
      return value;
    }
    
    if (typeof value === 'string') {
      return value.toLowerCase() === 'true';
    }
    
    return Boolean(value);
  },
  
  // 转换为数组
  toArray: function(value, defaultValue = []) {
    if (value === null || value === undefined) {
      return defaultValue;
    }
    
    if (Array.isArray(value)) {
      return value;
    }
    
    if (typeof value === 'string') {
      try {
        return JSON.parse(value);
      } catch (e) {
        return defaultValue;
      }
    }
    
    return defaultValue;
  },
  
  // 转换为对象
  toObject: function(value, defaultValue = {}) {
    if (value === null || value === undefined) {
      return defaultValue;
    }
    
    if (typeof value === 'object' && !Array.isArray(value)) {
      return value;
    }
    
    if (typeof value === 'string') {
      try {
        return JSON.parse(value);
      } catch (e) {
        return defaultValue;
      }
    }
    
    return defaultValue;
  },
  
  // 批量类型转换
  convertTypes: function(obj, typeSchema) {
    const result = {};
    
    for (const [key, type] of Object.entries(typeSchema)) {
      if (key in obj) {
        switch (type) {
          case 'number':
            result[key] = this.toNumber(obj[key]);
            break;
          case 'boolean':
            result[key] = this.toBoolean(obj[key]);
            break;
          case 'array':
            result[key] = this.toArray(obj[key]);
            break;
          case 'object':
            result[key] = this.toObject(obj[key]);
            break;
          default:
            result[key] = obj[key];
        }
      } else {
        result[key] = obj[key];  // 保留原始值
      }
    }
    
    return result;
  }
};

// 使用示例
const typeSchema = {
  age: 'number',
  isActive: 'boolean',
  score: 'number',
  count: 'number',
  config: 'array',
  data: 'object'
};

const convertedData = TypeConverter.convertTypes(jsonData, typeSchema);
console.log('类型转换后的数据:', convertedData);
```

### 2. 类型验证

验证JSON数据的类型结构：

```javascript
// 类型验证工具
const TypeValidator = {
  // 验证类型
  validateType: function(value, expectedType) {
    switch (expectedType) {
      case 'string':
        return typeof value === 'string';
      case 'number':
        return typeof value === 'number' && !isNaN(value);
      case 'boolean':
        return typeof value === 'boolean';
      case 'object':
        return typeof value === 'object' && value !== null && !Array.isArray(value);
      case 'array':
        return Array.isArray(value);
      case 'null':
        return value === null;
      case 'undefined':
        return value === undefined;
      default:
        return true;  // 未知类型，通过验证
    }
  },
  
  // 验证嵌套结构
  validateStructure: function(data, schema, path = '') {
    const errors = [];
    
    // 检查必需字段
    if (schema.required) {
      for (const field of schema.required) {
        if (!(field in data)) {
          errors.push({
            path: path ? `${path}.${field}` : field,
            error: `缺少必需字段: ${field}`
          });
        }
      }
    }
    
    // 检查字段类型
    if (schema.properties) {
      for (const [field, fieldSchema] of Object.entries(schema.properties)) {
        if (field in data) {
          const fieldPath = path ? `${path}.${field}` : field;
          const value = data[field];
          
          // 检查类型
          if (!this.validateType(value, fieldSchema.type)) {
            errors.push({
              path: fieldPath,
              error: `类型不匹配: 期望 ${fieldSchema.type}，实际 ${typeof value}`
            });
          }
          
          // 递归验证嵌套对象
          if (fieldSchema.properties && typeof value === 'object') {
            errors.push(...this.validateStructure(value, fieldSchema, fieldPath));
          }
          
          // 验证数组元素
          if (fieldSchema.items && Array.isArray(value)) {
            value.forEach((item, index) => {
              if (!this.validateType(item, fieldSchema.items)) {
                errors.push({
                  path: `${fieldPath}[${index}]`,
                  error: `数组元素类型不匹配: 期望 ${fieldSchema.items}，实际 ${typeof item}`
                });
              }
              
              // 递归验证数组中的对象
              if (fieldSchema.itemsProperties && typeof item === 'object') {
                errors.push(...this.validateStructure(item, fieldSchema.itemsProperties, `${fieldPath}[${index}]`));
              }
            });
          }
        }
      }
    }
    
    return errors;
  },
  
  // 自动修复类型
  autoFixTypes: function(data, schema) {
    const result = JSON.parse(JSON.stringify(data));  // 深拷贝
    
    if (schema.properties) {
      for (const [field, fieldSchema] of Object.entries(schema.properties)) {
        if (field in result) {
          const value = result[field];
          
          // 修复数字类型
          if (fieldSchema.type === 'number') {
            result[field] = TypeConverter.toNumber(value);
          }
          
          // 修复布尔类型
          else if (fieldSchema.type === 'boolean') {
            result[field] = TypeConverter.toBoolean(value);
          }
          
          // 修复数组类型
          else if (fieldSchema.type === 'array') {
            result[field] = TypeConverter.toArray(value);
          }
          
          // 修复对象类型
          else if (fieldSchema.type === 'object') {
            result[field] = TypeConverter.toObject(value);
          }
          
          // 递归修复嵌套对象
          if (fieldSchema.properties && typeof result[field] === 'object') {
            result[field] = this.autoFixTypes(result[field], fieldSchema);
          }
        }
      }
    }
    
    return result;
  }
};

// 使用示例
const userSchema = {
  required: ['id', 'name', 'email'],
  properties: {
    id: { type: 'string' },
    name: { type: 'string' },
    email: { type: 'string' },
    age: { type: 'number' },
    isActive: { type: 'boolean' },
    hobbies: { type: 'array' },
    profile: {
      type: 'object',
      properties: {
        bio: { type: 'string' }
      }
    }
  }
};

const userData = {
  id: "user_001",
  name: "张三",
  // email: "zhangsan@example.com",  // 缺少必需字段
  age: "30",  // 类型错误
  isActive: "true",  // 类型错误
  hobbies: "阅读,运动",  // 类型错误
  profile: '{"bio": "开发工程师"}'  // 类型错误
};

// 验证数据结构
const validationErrors = TypeValidator.validateStructure(userData, userSchema);
if (validationErrors.length > 0) {
  console.error('数据结构验证错误:');
  validationErrors.forEach(error => {
    console.error(`- ${error.path}: ${error.error}`);
  });
}

// 自动修复类型
const fixedData = TypeValidator.autoFixTypes(userData, userSchema);
console.log('自动修复后的数据:', fixedData);
```

## JSON结构错误

### 1. 缺失字段处理

处理JSON中缺失的字段：

```javascript
// 缺失字段处理工具
const MissingFieldHandler = {
  // 使用默认值填充缺失字段
  fillMissingFields: function(data, schema) {
    const result = JSON.parse(JSON.stringify(data));  // 深拷贝
    
    // 处理顶层缺失字段
    if (schema.properties) {
      for (const [field, fieldSchema] of Object.entries(schema.properties)) {
        if (!(field in result)) {
          result[field] = fieldSchema.default !== undefined ? fieldSchema.default : null;
        }
      }
    }
    
    return result;
  },
  
  // 使用工厂函数生成默认值
  fillMissingFieldsWithFactories: function(data, schema) {
    const result = JSON.parse(JSON.stringify(data));  // 深拷贝
    
    if (schema.properties) {
      for (const [field, fieldSchema] of Object.entries(schema.properties)) {
        if (!(field in result) && fieldSchema.defaultFactory) {
          result[field] = fieldSchema.defaultFactory();
        }
      }
    }
    
    return result;
  },
  
  // 使用计算值填充缺失字段
  fillMissingFieldsWithComputed: function(data, schema) {
    const result = JSON.parse(JSON.stringify(data));  // 深拷贝
    
    if (schema.properties) {
      for (const [field, fieldSchema] of Object.entries(schema.properties)) {
        if (!(field in result) && fieldSchema.compute) {
          result[field] = fieldSchema.compute(result);
        }
      }
    }
    
    return result;
  },
  
  // 合并多个数据源填充缺失字段
  fillFromMultipleSources: function(target, sources) {
    const result = JSON.parse(JSON.stringify(target));  // 深拷贝
    
    for (const source of sources) {
      if (source) {
        for (const [key, value] of Object.entries(source)) {
          if (!(key in result)) {
            result[key] = value;
          }
        }
      }
    }
    
    return result;
  }
};

// 使用示例
const userSchema = {
  properties: {
    id: { type: 'string' },
    name: { type: 'string' },
    email: { type: 'string' },
    age: { 
      type: 'number',
      default: 0
    },
    isActive: { 
      type: 'boolean',
      default: true
    },
    createdAt: {
      type: 'string',
      defaultFactory: () => new Date().toISOString()
    },
    fullName: {
      type: 'string',
      compute: (data) => data.name || '未知用户'
    }
  }
};

const partialUserData = {
  id: "user_001",
  name: "张三"
};

// 使用默认值填充
const filledUser1 = MissingFieldHandler.fillMissingFields(partialUserData, userSchema);
console.log('使用默认值填充:', filledUser1);

// 使用工厂函数和计算值填充
const filledUser2 = MissingFieldHandler.fillMissingFieldsWithComputed(
  MissingFieldHandler.fillMissingFieldsWithFactories(partialUserData, userSchema),
  userSchema
);
console.log('使用工厂函数和计算值填充:', filledUser2);

// 从多个数据源填充
const primaryData = { id: "user_001", name: "张三" };
const secondaryData = { email: "zhangsan@example.com", age: 30 };
const tertiaryData = { isActive: false };

const mergedUser = MissingFieldHandler.fillFromMultipleSources(
  primaryData, [secondaryData, tertiaryData]
);
console.log('多源合并:', mergedUser);
```

### 2. 额外字段处理

处理JSON中的额外字段：

```javascript
// 额外字段处理工具
const ExtraFieldHandler = {
  // 移除额外字段
  removeExtraFields: function(data, schema) {
    const result = {};
    
    if (schema.properties) {
      for (const field of Object.keys(schema.properties)) {
        if (field in data) {
          result[field] = data[field];
        }
      }
    }
    
    return result;
  },
  
  // 提取额外字段
  extractExtraFields: function(data, schema) {
    const allowedFields = new Set();
    const extraFields = {};
    
    if (schema.properties) {
      for (const field of Object.keys(schema.properties)) {
        allowedFields.add(field);
      }
    }
    
    for (const [field, value] of Object.entries(data)) {
      if (!allowedFields.has(field)) {
        extraFields[field] = value;
      }
    }
    
    return extraFields;
  },
  
  // 分离标准字段和额外字段
  separateFields: function(data, schema) {
    return {
      standard: this.removeExtraFields(data, schema),
      extra: this.extractExtraFields(data, schema)
    };
  },
  
  // 将额外字段存储在特定属性中
  storeExtraFields: function(data, schema, extraFieldKey = '_extra') {
    const { standard, extra } = this.separateFields(data, schema);
    
    if (Object.keys(extra).length > 0) {
      standard[extraFieldKey] = extra;
    }
    
    return standard;
  },
  
  // 从特定属性中恢复额外字段
  restoreExtraFields: function(data, extraFieldKey = '_extra') {
    const result = JSON.parse(JSON.stringify(data));  // 深拷贝
    
    if (extraFieldKey in result) {
      const extraFields = result[extraFieldKey];
      delete result[extraFieldKey];
      
      for (const [field, value] of Object.entries(extraFields)) {
        result[field] = value;
      }
    }
    
    return result;
  }
};

// 使用示例
const userSchema = {
  properties: {
    id: { type: 'string' },
    name: { type: 'string' },
    email: { type: 'string' },
    age: { type: 'number' }
  }
};

const userDataWithExtras = {
  id: "user_001",
  name: "张三",
  email: "zhangsan@example.com",
  age: 30,
  // 额外字段
  department: "研发部",
  position: "前端工程师",
  startDate: "2020-01-15",
  skills: ["JavaScript", "React"]
};

// 移除额外字段
const standardUser = ExtraFieldHandler.removeExtraFields(userDataWithExtras, userSchema);
console.log('标准字段:', standardUser);

// 提取额外字段
const extraFields = ExtraFieldHandler.extractExtraFields(userDataWithExtras, userSchema);
console.log('额外字段:', extraFields);

// 分离标准字段和额外字段
const separated = ExtraFieldHandler.separateFields(userDataWithExtras, userSchema);
console.log('分离结果:', separated);

// 存储额外字段
const storedExtra = ExtraFieldHandler.storeExtraFields(userDataWithExtras, userSchema);
console.log('存储额外字段:', storedExtra);

// 恢复额外字段
const restored = ExtraFieldHandler.restoreExtraFields(storedExtra);
console.log('恢复额外字段:', restored);
```

## JSON调试技巧

### 1. 可视化调试

可视化JSON结构以帮助调试：

```javascript
// JSON可视化调试工具
const JsonVisualizer = {
  // 格式化JSON为可读字符串
  prettyPrint: function(obj, indent = 2) {
    return JSON.stringify(obj, null, indent);
  },
  
  // 创建JSON树结构视图
  createTreeView: function(obj, maxDepth = 5) {
    let result = '';
    
    function traverse(node, depth = 0) {
      if (depth > maxDepth) {
        result += `${'  '.repeat(depth)}[已达到最大深度]\n`;
        return;
      }
      
      const indent = '  '.repeat(depth);
      
      if (typeof node === 'object' && node !== null) {
        if (Array.isArray(node)) {
          result += `${indent}[Array (${node.length} items)]\n`;
          
          if (node.length <= 5) {
            node.forEach((item, index) => {
              result += `${indent}[${index}]: `;
              
              if (typeof item === 'object' && item !== null) {
                result += '\n';
                traverse(item, depth + 1);
              } else {
                result += `${item} (${typeof item})\n`;
              }
            });
          } else {
            result += `${indent}  [只显示前5项]\n`;
            for (let i = 0; i < 5 && i < node.length; i++) {
              result += `${indent}[${i}]: `;
              
              if (typeof node[i] === 'object' && node[i] !== null) {
                result += '\n';
                traverse(node[i], depth + 1);
              } else {
                result += `${node[i]} (${typeof node[i]})\n`;
              }
            }
          }
        } else {
          const keys = Object.keys(node);
          result += `${indent}{Object (${keys.length} keys)}\n`;
          
          keys.forEach(key => {
            result += `${indent}${key}: `;
            
            if (typeof node[key] === 'object' && node[key] !== null) {
              result += '\n';
              traverse(node[key], depth + 1);
            } else {
              result += `${node[key]} (${typeof node[key]})\n`;
            }
          });
        }
      } else {
        result += `${indent}${node} (${typeof node})\n`;
      }
    }
    
    traverse(obj);
    return result;
  },
  
  // 分析JSON结构
  analyzeStructure: function(obj, path = '') {
    const analysis = {
      paths: [],
      types: {},
      maxDepth: 0,
      totalNodes: 0,
      leafNodes: 0
    };
    
    function traverse(node, currentPath = '', depth = 0) {
      analysis.totalNodes++;
      analysis.maxDepth = Math.max(analysis.maxDepth, depth);
      
      // 记录路径和类型
      if (currentPath) {
        analysis.paths.push({
          path: currentPath,
          type: typeof node,
          isLeaf: typeof node !== 'object' || node === null
        });
      }
      
      // 统计类型
      const nodeType = typeof node;
      analysis.types[nodeType] = (analysis.types[nodeType] || 0) + 1;
      
      if (typeof node !== 'object' || node === null) {
        analysis.leafNodes++;
        return;
      }
      
      if (Array.isArray(node)) {
        node.forEach((item, index) => {
          traverse(item, `${currentPath}[${index}]`, depth + 1);
        });
      } else {
        for (const [key, value] of Object.entries(node)) {
          traverse(value, currentPath ? `${currentPath}.${key}` : key, depth + 1);
        }
      }
    }
    
    traverse(obj, path);
    return analysis;
  },
  
  // 比较两个JSON对象
  compareObjects: function(obj1, obj2) {
    const comparison = {
      identical: true,
      added: [],
      removed: [],
      modified: [],
      unchanged: []
    };
    
    function findPaths(obj, prefix = '') {
      const paths = [];
      
      if (typeof obj !== 'object' || obj === null) {
        return [{ path: prefix, value: obj }];
      }
      
      if (Array.isArray(obj)) {
        obj.forEach((item, index) => {
          paths.push(...findPaths(item, prefix ? `${prefix}[${index}]` : `[${index}]`));
        });
      } else {
        for (const [key, value] of Object.entries(obj)) {
          paths.push(...findPaths(value, prefix ? `${prefix}.${key}` : key));
        }
      }
      
      return paths;
    }
    
    const paths1 = findPaths(obj1);
    const paths2 = findPaths(obj2);
    
    const paths1Map = new Map(paths1.map(p => [p.path, p.value]));
    const paths2Map = new Map(paths2.map(p => [p.path, p.value]));
    
    // 检查添加的字段
    for (const [path, value] of paths2Map) {
      if (!paths1Map.has(path)) {
        comparison.added.push({ path, value });
        comparison.identical = false;
      }
    }
    
    // 检查删除的字段
    for (const [path, value] of paths1Map) {
      if (!paths2Map.has(path)) {
        comparison.removed.push({ path, value });
        comparison.identical = false;
      }
    }
    
    // 检查修改的字段
    for (const [path, value] of paths1Map) {
      if (paths2Map.has(path)) {
        const newValue = paths2Map.get(path);
        
        if (JSON.stringify(value) !== JSON.stringify(newValue)) {
          comparison.modified.push({
            path,
            oldValue: value,
            newValue
          });
          comparison.identical = false;
        } else {
          comparison.unchanged.push({ path, value });
        }
      }
    }
    
    return comparison;
  }
};

// 使用示例
const complexData = {
  users: [
    {
      id: "user_001",
      name: "张三",
      profile: {
        age: 30,
        skills: ["JavaScript", "React"]
      }
    },
    {
      id: "user_002",
      name: "李四",
      profile: {
        age: 28,
        skills: ["Python", "Django"]
      }
    }
  ],
  meta: {
    count: 2,
    page: 1
  }
};

// 格式化打印
console.log('格式化JSON:');
console.log(JsonVisualizer.prettyPrint(complexData));

// 创建树视图
console.log('\n树结构视图:');
console.log(JsonVisualizer.createTreeView(complexData));

// 分析结构
const analysis = JsonVisualizer.analyzeStructure(complexData);
console.log('\n结构分析:');
console.log(`总节点数: ${analysis.totalNodes}`);
console.log(`叶节点数: ${analysis.leafNodes}`);
console.log(`最大深度: ${analysis.maxDepth}`);
console.log('类型分布:', analysis.types);

// 比较两个对象
const data1 = { a: 1, b: { c: 2, d: 3 } };
const data2 = { a: 1, b: { c: 2, e: 4 }, f: 5 };

const comparison = JsonVisualizer.compareObjects(data1, data2);
console.log('\n对象比较:');
console.log(`是否相同: ${comparison.identical}`);
console.log('添加的字段:', comparison.added);
console.log('删除的字段:', comparison.removed);
console.log('修改的字段:', comparison.modified);
```

## 实验环节：JSON错误处理与调试实践

### 实验1：构建JSON错误诊断工具

创建一个JSON错误诊断工具，能够：

1. 检测常见JSON错误
2. 提供详细的错误信息
3. 建议修复方案
4. 自动修复简单错误
5. 生成错误报告

### 实验2：JSON调试可视化系统

构建一个JSON调试可视化系统，包含：

1. JSON树结构可视化
2. 路径高亮
3. 类型颜色编码
4. 值预览和编辑
5. 结构分析报告

### 实验3：JSON测试框架

创建一个JSON测试框架，实现：

1. JSON结构验证
2. 类型验证测试
3. 边界条件测试
4. 性能测试
5. 错误恢复测试

## 小结

本节我们深入探讨了JSON错误处理与调试：

1. **JSON解析错误**：
   - 常见语法错误（单引号、尾随逗号、未引用键等）
   - 解析错误处理
   - JSON修复工具

2. **JSON类型错误**：
   - 类型不匹配问题
   - 类型转换工具
   - 类型验证

3. **JSON结构错误**：
   - 缺失字段处理
   - 额外字段处理

4. **JSON调试技巧**：
   - 可视化调试
   - 结构分析
   - 对象比较

通过掌握这些错误处理和调试技巧，您可以更有效地处理JSON数据中的各种问题，提高应用程序的健壮性和可靠性。

## 代码示例

请查看`code/chapter6/error-handling`目录，其中包含了：

1. `json_parser.js` - JSON解析错误处理
2. `json_repairer.js` - JSON自动修复工具
3. `type_converter.js` - 类型转换工具
4. `type_validator.js` - 类型验证工具
5. `missing_fields_handler.js` - 缺失字段处理
6. `extra_fields_handler.js` - 额外字段处理
7. `json_visualizer.js` - JSON可视化调试工具
8. `json_debugger.js` - JSON调试辅助工具
9. `error_diagnostic_tool.js` - JSON错误诊断工具
10. `json_test_framework.js` - JSON测试框架
11. `visualization_system.js` - JSON可视化系统