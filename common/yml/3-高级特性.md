# 第3章：YAML高级特性

## 3.1 锚点与别名

YAML的锚点（Anchor）和别名（Alias）机制允许我们在文档中定义一次数据，然后在多个地方引用它，类似于编程语言中的变量。

### 3.1.1 基本锚点和别名

使用`&`定义锚点，使用`*`引用别名：

```yaml
# 基本锚点和别名示例
defaults: &defaults
  timeout: 30
  retries: 3
  log_level: info

production:
  <<: *defaults
  host: prod.example.com
  port: 443

staging:
  <<: *defaults
  host: staging.example.com
  port: 8443
```

### 3.1.2 覆盖锚点值

可以在引用锚点后覆盖特定值：

```yaml
# 覆盖锚点值示例
base_config: &base_config
  timeout: 30
  retries: 3
  log_level: info

development:
  <<: *base_config
  log_level: debug  # 覆盖基础配置中的log_level
  host: dev.example.com
```

### 3.1.3 嵌套锚点

锚点可以嵌套在其他结构中：

```yaml
# 嵌套锚点示例
database: &database
  host: localhost
  port: 5432
  user: admin

services:
  web:
    database: *database
    port: 8080
  api:
    database: *database
    port: 8081
```

### 3.1.4 多个锚点

可以定义多个锚点并根据需要引用：

```yaml
# 多个锚点示例
http_config: &http_config
  protocol: http
  timeout: 30

https_config: &https_config
  protocol: https
  timeout: 60
  verify_ssl: true

services:
  web:
    <<: *http_config
    port: 80
  secure_web:
    <<: *https_config
    port: 443
  api:
    <<: *http_config
    port: 8080
  secure_api:
    <<: *https_config
    port: 8443
```

## 3.2 合并键

合并键（Merge Key，`<<:`）允许将一个或多个映射合并到当前映射中。

### 3.2.1 单个映射合并

```yaml
# 单个映射合并示例
base: &base
  name: John
  age: 30

person:
  <<: *base
  occupation: Developer
```

### 3.2.2 多个映射合并

```yaml
# 多个映射合并示例
personal_info: &personal_info
  name: Jane
  age: 25

contact_info: &contact_info
  email: jane@example.com
  phone: 555-1234

full_profile:
  <<: *personal_info
  <<: *contact_info
  occupation: Designer
```

### 3.2.3 合并顺序与覆盖

当合并多个映射时，后面的映射会覆盖前面的映射：

```yaml
# 合并顺序与覆盖示例
first: &first
  key1: value1
  key2: value2

second: &second
  key2: new_value2  # 会覆盖first中的key2
  key3: value3

merged:
  <<: *first
  <<: *second
  key4: value4
# 结果: key1=value1, key2=new_value2, key3=value3, key4=value4
```

## 3.3 标签与类型系统

YAML提供了丰富的标签系统，用于指定和自定义数据类型。

### 3.3.1 全局标签

```yaml
# 全局标签示例
string_value: !!str 123
integer_value: !!int "456"
float_value: !!float "3.14"
boolean_value: !!bool "true"
null_value: !!null "null"
timestamp_value: !!timestamp "2023-05-15T14:30:00Z"
binary_value: !!binary R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5OTk6enp56enmleECcgggoBADs=
```

### 3.3.2 自定义类型

```yaml
# 自定义类型示例
person: !person
  name: John Doe
  age: 30
  email: john@example.com

address: !address
  street: 123 Main St
  city: Anytown
  zip: 12345
```

### 3.3.3 本地标签

```yaml
# 本地标签示例
!!python/object:__main__.Person
name: John Doe
age: 30
```

## 3.4 多文档流

YAML支持在单个文件中包含多个文档，使用`---`分隔文档，使用`...`结束文档。

### 3.4.1 基本多文档

```yaml
# 基本多文档示例
---
# 文档1
name: John
age: 30
...
---
# 文档2
name: Jane
age: 25
...
```

### 3.4.2 多文档处理

```python
# Python处理多文档YAML
import yaml

with open('multi_document.yml', 'r') as file:
    documents = list(yaml.safe_load_all(file))
    for doc in documents:
        print(doc)
```

## 3.5 高级字符串处理

### 3.5.1 块标量详细控制

```yaml
# 块标量详细控制
literal_block: |
  This is a literal block
  It preserves all line breaks
  And indentation

folded_block: >
  This is a folded block
  It converts line breaks to spaces
  Creating a single paragraph

# 带缩进的块标量
indented_literal: |2
  This block has 2 spaces of indentation
  All lines are indented by at least 2 spaces
  Relative indentation is preserved

# 带缩进的折叠标量
indented_folded: >2
  This folded block has 2 spaces of indentation
  Line breaks are converted to spaces
  But the overall indentation is preserved
```

### 3.5.2 字符串中的特殊字符

```yaml
# 字符串中的特殊字符
escaped_chars: "This contains a \"quote\" and a \\ backslash"
unicode_chars: "Unicode: 中文测试"
newlines: "Line 1\nLine 2"
tabs: "Column1\tColumn2"
```

## 3.6 条件与循环

虽然YAML本身不支持编程逻辑，但可以通过一些技巧实现类似条件与循环的效果。

### 3.6.1 使用锚点模拟条件

```yaml
# 使用锚点模拟条件
default_config: &default_config
  timeout: 30
  retries: 3

development_config: &development_config
  <<: *default_config
  debug: true
  log_level: debug

production_config: &production_config
  <<: *default_config
  debug: false
  log_level: info

# 根据环境选择配置
environment: development
config: 
  <<: *development_config
```

### 3.6.2 使用序列模拟循环

```yaml
# 使用序列模拟循环
servers:
  - &server_template
    cpu: 2
    memory: 4GB
    disk: 20GB
  - <<: *server_template
    name: web-1
    ip: 192.168.1.10
  - <<: *server_template
    name: web-2
    ip: 192.168.1.11
  - <<: *server_template
    name: web-3
    ip: 192.168.1.12
```

## 3.7 模式验证与Schema

### 3.7.1 YAML Schema

YAML Schema用于验证YAML文档的结构和内容：

```yaml
# YAML Schema示例
type: object
properties:
  name:
    type: string
  age:
    type: integer
    minimum: 0
    maximum: 150
  email:
    type: string
    format: email
required:
  - name
  - age
```

### 3.7.2 使用PyKwalify验证

```python
# 使用PyKwalify验证YAML
from pykwalify.core import Core
from pykwalify.errors import SchemaError

# 定义schema
schema = {
    "type": "map",
    "mapping": {
        "name": {"type": "str", "required": True},
        "age": {"type": "int", "required": True},
        "email": {"type": "str", "required": False}
    }
}

# 验证YAML数据
data = {
    "name": "John",
    "age": 30,
    "email": "john@example.com"
}

c = Core(source_data=data, schema_data=schema)
try:
    c.validate()
    print("验证成功")
except SchemaError as e:
    print(f"验证失败: {e}")
```

## 3.8 安全考虑

### 3.8.1 安全加载YAML

```python
# 安全加载YAML
import yaml

# 不安全：可能执行任意Python代码
# data = yaml.load(yaml_string)

# 安全：只加载基本YAML标签
data = yaml.safe_load(yaml_string)

# 更安全：加载所有YAML标签但不执行Python对象
data = yaml.safe_load_all(yaml_string)
```

### 3.8.2 避免代码注入

```yaml
# 危险：可能执行任意代码
!!python/object/apply:os.system ["echo 'Hello, World!'"]

# 安全：只使用基本数据类型
name: John
age: 30
```

## 3.9 实验与验证

### 实验1：锚点与别名

```yaml
# anchors_and_aliases.yml
# 锚点与别名示例
---
# 基本锚点和别名
defaults: &defaults
  timeout: 30
  retries: 3
  log_level: info

production:
  <<: *defaults
  host: prod.example.com
  port: 443

staging:
  <<: *defaults
  host: staging.example.com
  port: 8443
  log_level: debug  # 覆盖默认值

# 嵌套锚点
database: &database
  host: localhost
  port: 5432
  user: admin
  password: secret

services:
  web:
    database: *database
    port: 8080
  api:
    database: *database
    port: 8081
    timeout: 60  # 覆盖默认值
```

### 实验2：多文档流

```yaml
# multi_document.yml
# 多文档流示例
---
# 文档1：用户信息
name: John Doe
age: 30
email: john@example.com
...
---
# 文档2：用户设置
theme: dark
notifications: true
language: en-US
...
---
# 文档3：用户权限
permissions:
  - read
  - write
  - delete
roles:
  - admin
  - editor
...
```

### 实验3：高级字符串处理

```yaml
# advanced_strings.yml
# 高级字符串处理示例
---
# 块标量
literal_block: |
  This is a literal block
  It preserves all line breaks
  And indentation exactly as written

folded_block: >
  This is a folded block
  It converts line breaks to spaces
  Creating a single paragraph

# 带缩进的块标量
indented_literal: |2
  This block has 2 spaces of indentation
  All lines are indented by at least 2 spaces
  Relative indentation is preserved

# 带缩进的折叠标量
indented_folded: >2
  This folded block has 2 spaces of indentation
  Line breaks are converted to spaces
  But the overall indentation is preserved

# 特殊字符
escaped_chars: "This contains a \"quote\" and a \\ backslash"
unicode_chars: "Unicode: 中文测试"
newlines: "Line 1\nLine 2"
tabs: "Column1\tColumn2"
```

### 实验4：自定义类型

```yaml
# custom_types.yml
# 自定义类型示例
---
# 自定义类型定义
person: !person
  name: John Doe
  age: 30
  email: john@example.com

address: !address
  street: 123 Main St
  city: Anytown
  zip: 12345

# 复杂自定义类型
company: !company
  name: Tech Corp
  founded: 2010
  employees: 150
  address: !address
    street: 456 Business Ave
    city: San Francisco
    zip: 94105
  ceo: !person
    name: Jane Smith
    age: 45
    email: jane@techcorp.com
```

## 3.10 实验验证代码

```python
# advanced_features.py
import yaml
import json

def test_anchors_and_aliases():
    """测试锚点与别名"""
    print("=== 锚点与别名测试 ===")
    with open('anchors_and_aliases.yml', 'r', encoding='utf-8') as file:
        data = yaml.safe_load(file)
        print("生产环境配置:")
        print(json.dumps(data['production'], indent=2))
        print("\nAPI服务配置:")
        print(json.dumps(data['services']['api'], indent=2))

def test_multi_document():
    """测试多文档流"""
    print("\n=== 多文档流测试 ===")
    with open('multi_document.yml', 'r', encoding='utf-8') as file:
        documents = list(yaml.safe_load_all(file))
        for i, doc in enumerate(documents, 1):
            print(f"\n文档 {i}:")
            print(json.dumps(doc, indent=2, ensure_ascii=False))

def test_advanced_strings():
    """测试高级字符串处理"""
    print("\n=== 高级字符串处理测试 ===")
    with open('advanced_strings.yml', 'r', encoding='utf-8') as file:
        data = yaml.safe_load(file)
        
        print("字面量块:")
        print(repr(data['literal_block']))
        print("\n折叠块:")
        print(repr(data['folded_block']))
        print("\n缩进字面量块:")
        print(repr(data['indented_literal']))
        print("\n缩进折叠块:")
        print(repr(data['indented_folded']))
        print("\n特殊字符:")
        print(f"转义字符: {data['escaped_chars']}")
        print(f"Unicode字符: {data['unicode_chars']}")
        print(f"换行符: {repr(data['newlines'])}")
        print(f"制表符: {repr(data['tabs'])}")

def test_custom_types():
    """测试自定义类型"""
    print("\n=== 自定义类型测试 ===")
    with open('custom_types.yml', 'r', encoding='utf-8') as file:
        data = yaml.safe_load(file)
        print("人物信息:")
        print(json.dumps(data['person'], indent=2, ensure_ascii=False))
        print("\n地址信息:")
        print(json.dumps(data['address'], indent=2, ensure_ascii=False))
        print("\n公司信息:")
        print(json.dumps(data['company'], indent=2, ensure_ascii=False))

def test_yaml_merge():
    """测试YAML合并"""
    print("\n=== YAML合并测试 ===")
    yaml_content = """
base: &base
  key1: value1
  key2: value2

override: &override
  key2: new_value2
  key3: value3

merged:
  <<: *base
  <<: *override
  key4: value4
"""
    data = yaml.safe_load(yaml_content)
    print("合并结果:")
    print(json.dumps(data['merged'], indent=2))

def test_security():
    """测试YAML安全性"""
    print("\n=== YAML安全性测试 ===")
    
    # 安全加载
    safe_yaml = "name: John\nage: 30"
    safe_data = yaml.safe_load(safe_yaml)
    print(f"安全加载: {safe_data}")
    
    # 不安全加载（仅作演示，实际应用中避免使用）
    try:
        # 这里只是演示，实际不要加载不可信的YAML
        unsafe_yaml = "name: !!python/object/apply:os.system ['echo Hello']"
        # unsafe_data = yaml.load(unsafe_yaml)  # 不安全，可能执行代码
        print("不安全加载示例已跳过，以避免执行潜在危险代码")
    except Exception as e:
        print(f"不安全加载失败: {e}")

# 运行所有测试
test_anchors_and_aliases()
test_multi_document()
test_advanced_strings()
test_custom_types()
test_yaml_merge()
test_security()
```

## 3.11 高级特性深度解析

### 3.11.1 锚点与别名的语法机制

锚点与别名是YAML中强大的数据重用机制，其语法规则和解析机制需要深入理解：

**语法规则详解：**
- 锚点定义：使用`&锚点名`在任意YAML节点前定义锚点
- 别名引用：使用`*锚点名`引用已定义的锚点
- 作用域：锚点在整个文档中有效，包括多文档流
- 解析顺序：YAML解析器按文档顺序解析，必须先定义后引用

**复杂锚点示例：**
```yaml
# 复杂锚点嵌套
base_config: &base
  database: &db
    host: localhost
    port: 5432
  cache: &cache
    redis_host: 127.0.0.1
    redis_port: 6379

production:
  database: *db
  cache: *cache
  environment: production
  # 可以覆盖锚点中的特定值
  database:
    <<: *db
    host: prod-db.example.com
```

### 3.11.2 合并键的复杂场景处理

合并键`<<:`提供了强大的映射合并能力，但在复杂场景中需要特别注意：

**合并冲突处理：**
- 键冲突：后合并的映射会覆盖先合并的映射中的同名键
- 深度合并：YAML 1.1标准只支持浅层合并，不递归合并嵌套映射
- 合并顺序：从左到右依次合并，后面的映射优先级更高

**复杂合并示例：**
```yaml
# 复杂合并场景
base: &base
  common:
    timeout: 30
    retries: 3
  database:
    host: localhost
    port: 5432

override: &override
  common:
    timeout: 60  # 覆盖base中的timeout
  database:
    port: 5433   # 覆盖base中的port

config:
  <<: *base
  <<: *override
  # 手动处理深度合并冲突
  common:
    <<: *base.common
    <<: *override.common
    # 最终结果：timeout=60, retries=3
```

### 3.11.3 标签系统的类型安全机制

YAML标签系统提供了强大的类型安全机制，但需要正确使用：

**类型安全最佳实践：**
- 使用标准标签：优先使用`!!str`、`!!int`等标准标签
- 避免自定义标签：除非有明确的类型系统支持
- 验证标签：在使用前验证标签的兼容性和安全性

**类型安全示例：**
```yaml
# 类型安全配置
strict_config:
  name: !!str "John Doe"      # 明确指定字符串类型
  age: !!int "30"             # 明确指定整数类型
  salary: !!float "50000.50"  # 明确指定浮点数类型
  active: !!bool "true"        # 明确指定布尔类型
  # 避免使用危险的自定义标签
  # dangerous: !!python/object/apply:os.system ["rm -rf /"]
```

### 3.11.4 多文档流的解析机制

多文档流是YAML的重要特性，其解析机制需要深入理解：

**文档分隔符规则：**
- `---`：文档开始分隔符，可选但推荐使用
- `...`：文档结束分隔符，可选但推荐使用
- 解析顺序：按文档顺序依次解析每个独立文档

**多文档流处理示例：**
```yaml
# 多文档流处理策略
---
# 配置文档
config:
  version: "1.0"
  environment: development
...
---
# 数据文档
data:
  users:
    - name: "John"
      age: 30
    - name: "Jane"
      age: 25
...
---
# 元数据文档
metadata:
  created: "2023-05-15"
  author: "System"
...
```

### 3.11.5 高级字符串处理的语法细节

YAML的字符串处理非常灵活，但需要掌握其语法细节：

**块标量控制字符：**
- `|`：字面量块，保留所有换行和缩进
- `>`：折叠块，将换行转换为空格
- `|+`：保留末尾换行
- `|-`：去除末尾换行
- `|1`、`|2`等：指定缩进级别

**字符串处理示例：**
```yaml
# 精确控制字符串格式
precise_strings:
  literal_preserve: |+
    This preserves
    all line breaks
    and trailing newlines
    
  literal_strip: |-
    This strips
    trailing newlines
    
  folded_indent: >2
    This folded block
    has 2-space indentation
    and converts line breaks
    to spaces
  
  # 精确控制缩进
  indented_literal: |4
        This block requires
        exactly 4 spaces
        of indentation
```

### 3.11.6 安全解析与验证机制

YAML的安全解析至关重要，需要建立完整的验证机制：

**安全解析策略：**
- 使用`safe_load`而非`load`避免代码执行
- 验证输入来源，避免加载不可信YAML
- 使用Schema验证文档结构
- 限制解析深度和大小，防止DoS攻击

**安全验证示例：**
```python
# 安全YAML解析器
import yaml
from yaml.constructor import SafeConstructor

class SecureYAMLLoader(yaml.SafeLoader):
    """安全YAML加载器"""
    
    def __init__(self, stream):
        super().__init__(stream)
        # 限制解析深度
        self.max_depth = 10
        # 限制节点数量
        self.max_nodes = 1000
        self.node_count = 0
    
    def construct_mapping(self, node, deep=False):
        """重写映射构造方法，添加安全限制"""
        if deep and self.max_depth is not None:
            if deep > self.max_depth:
                raise yaml.constructor.ConstructorError(
                    "解析深度超过限制"
                )
        
        self.node_count += 1
        if self.node_count > self.max_nodes:
            raise yaml.constructor.ConstructorError(
                "节点数量超过限制"
            )
        
        return super().construct_mapping(node, deep)

def secure_yaml_load(stream):
    """安全加载YAML"""
    return yaml.load(stream, Loader=SecureYAMLLoader)
```

### 3.11.7 性能优化与最佳实践

在使用YAML高级特性时，性能优化同样重要：

**性能优化策略：**
- 避免过度使用锚点，减少解析复杂度
- 合理使用合并键，避免深层嵌套
- 对于大型配置，考虑使用多文档流分段加载
- 缓存解析结果，避免重复解析

**性能优化示例：**
```yaml
# 性能优化的YAML结构
# 避免：过度嵌套的锚点
# bad_example: &base
#   level1: &l1
#     level2: &l2
#       level3: value

# 推荐：扁平化结构
efficient_config:
  # 使用独立的锚点
  database_settings: &db
    host: localhost
    port: 5432
  
  cache_settings: &cache
    host: 127.0.0.1
    port: 6379
  
  # 简单的合并
  production:
    <<: *db
    <<: *cache
    environment: production
```

## 3.12 总结与进阶

本章深入解析了YAML的高级特性语法机制：

### 核心知识点回顾
1. **锚点与别名语法机制**：深入理解定义、引用规则和作用域
2. **合并键复杂场景处理**：掌握冲突解决和深度合并策略
3. **标签系统类型安全**：确保类型安全和避免危险标签
4. **多文档流解析机制**：理解文档分隔符和解析顺序
5. **高级字符串处理语法**：精确控制字符串格式和缩进
6. **安全解析与验证机制**：建立完整的安全防护体系
7. **性能优化策略**：优化YAML解析和处理的性能

### 实践应用建议
- 在复杂配置场景中合理使用锚点和合并键
- 建立类型安全机制，避免运行时错误
- 实施安全解析策略，防止代码注入攻击
- 优化YAML结构，提高解析效率

### 进阶学习方向
- 研究YAML 1.2标准的新特性
- 学习YAML Schema验证技术
- 探索YAML在不同编程语言中的实现差异
- 了解YAML在微服务和云原生架构中的应用

掌握这些高级特性的语法解析，将使您能够更加专业和安全地使用YAML，在各种复杂场景中游刃有余。