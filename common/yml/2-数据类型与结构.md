# 第2章：YAML数据类型与结构

## 2.1 YAML数据类型概述

YAML支持多种数据类型，可以分为三大类：
- **标量（Scalars）**：单个值，如字符串、数字、布尔值等
- **序列（Sequences）**：有序的值列表，类似于数组
- **映射（Mappings）**：键值对集合，类似于对象或字典

本章将详细介绍这些数据类型及其用法。

## 2.2 标量类型

### 2.2.1 字符串

字符串是YAML中最常用的数据类型，可以用多种方式表示：

#### 单行字符串

```yaml
# 简单字符串（不需要引号）
name: John Doe

# 包含特殊字符的字符串（需要引号）
password: "p@ssw0rd!"
path: "C:\\Program Files\\App"

# 包含空格的字符串（建议使用引号）
greeting: "Hello, World!"
```

#### 多行字符串

YAML提供了两种多行字符串表示方式：块标量（|）和折叠标量（>）。

```yaml
# 块标量（|）：保留换行符
address: |
  123 Main Street
  Anytown, USA 12345

# 折叠标量（>）：将换行符转换为空格
description: >
  This is a long description
  that spans multiple lines
  but is treated as a single
  paragraph in the output.
```

#### 字符串中的特殊字符

```yaml
# 转义字符
escaped: "This contains a \"quote\" and a \\ backslash"

# Unicode字符
unicode: "Hello, 世界!"

# 空字符串
empty: ""

# null值（大小写不敏感）
null_value: null
another_null: Null
yet_another_null: NULL
```

### 2.2.2 数字

YAML支持多种数字格式：

```yaml
# 整数
integer: 42
negative_integer: -17
octal: 0o755  # 八进制
hexadecimal: 0xFF  # 十六进制

# 浮点数
float: 3.14
negative_float: -2.71
scientific: 1.23e-4  # 科学计数法

# 特殊值
infinity: .inf  # 正无穷
negative_infinity: -.inf  # 负无穷
not_a_number: .NaN  # 非数字
```

### 2.2.3 布尔值

YAML支持多种布尔值表示方式：

```yaml
# 常见的布尔值表示
true_value: true
false_value: false

# 其他表示方式（不推荐，但支持）
yes: true
no: false
on: true
off: false

# 注意：这些会被解析为字符串，不是布尔值
string_true: "true"
string_false: "false"
```

### 2.2.4 日期和时间

YAML支持ISO 8601格式的日期和时间：

```yaml
# 日期
date: 2023-05-15

# 时间
time: 14:30:00

# 日期和时间
datetime: 2023-05-15T14:30:00

# 带时区的日期时间
datetime_with_timezone: 2023-05-15T14:30:00+08:00

# 日期范围
date_range: 2023-05-01/2023-05-31
```

## 2.3 序列（列表/数组）

序列是有序的值集合，使用连字符（-）表示每个元素：

### 2.3.1 基本序列

```yaml
# 简单序列
fruits:
  - apple
  - banana
  - orange

# 内联序列（类似JSON数组）
vegetables: [carrot, broccoli, spinach]

# 混合类型序列
mixed_list:
  - "string"
  - 42
  - true
  - null
```

### 2.3.2 嵌套序列

```yaml
# 嵌套序列
nested_sequences:
  - - item1
    - item2
  - - item3
    - item4
    - item5

# 序列中的映射
sequence_of_mappings:
  - name: John
    age: 30
  - name: Jane
    age: 25
```

### 2.3.3 多行序列

```yaml
# 多行序列
long_sequence:
  - first item
  - second item
  - third item
  - fourth item
  - fifth item
```

## 2.4 映射（对象/字典）

映射是键值对的集合，使用冒号（:）分隔键和值：

### 2.4.1 基本映射

```yaml
# 简单映射
person:
  name: John Doe
  age: 30
  city: New York

# 内联映射（类似JSON对象）
inline_mapping: {name: Jane, age: 25, city: Boston}
```

### 2.4.2 嵌套映射

```yaml
# 嵌套映射
company:
  name: Tech Corp
  address:
    street: 123 Business Ave
    city: San Francisco
    state: CA
    zip: 94105
  contact:
    phone: 555-1234
    email: info@techcorp.com
```

### 2.4.3 复杂结构

```yaml
# 映射中的序列
person_with_hobbies:
  name: John
  age: 30
  hobbies:
    - reading
    - swimming
    - programming

# 序列中的映射
people:
  - name: John
    age: 30
    city: New York
  - name: Jane
    age: 25
    city: Boston
```

## 2.5 高级数据类型

### 2.5.1 集合

YAML支持集合（set）类型，使用`!!set`标签：

```yaml
# 集合（无序、唯一元素）
set_example: !!set
  ? apple
  ? banana
  ? orange
```

### 2.5.2 有序映射

YAML支持有序映射，使用`!!omap`标签：

```yaml
# 有序映射（保持键的顺序）
ordered_map: !!omap
  - name: John
  - age: 30
  - city: New York
```

### 2.5.3 二进制数据

YAML支持二进制数据，使用`!!binary`标签：

```yaml
# 二进制数据（Base64编码）
binary_data: !!binary R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5OTk6enp56enmleECcgggoBADs=
```

## 2.6 类型转换与强制

### 2.6.1 显式类型指定

可以使用双感叹号（!!）显式指定数据类型：

```yaml
# 显式指定字符串类型
string_number: !!str 123

# 显式指定整数类型
integer_string: !!int "456"

# 显式指定浮点数类型
float_string: !!float "3.14"

# 显式指定布尔值类型
boolean_string: !!bool "true"
```

### 2.6.2 自定义类型

YAML支持自定义类型：

```yaml
# 自定义类型示例
custom_date: !!custom/date 2023-05-15
custom_object: !!custom/object
  property1: value1
  property2: value2
```

## 2.7 数据类型验证

### 2.7.1 使用PyYAML验证类型

```python
import yaml
from typing import Dict, List, Any

def validate_yaml_types(yaml_content: str) -> Dict[str, Any]:
    """验证YAML内容的数据类型"""
    try:
        data = yaml.safe_load(yaml_content)
        
        # 检查数据类型
        if isinstance(data, dict):
            print("顶级数据类型: 映射 (字典)")
            for key, value in data.items():
                print(f"  {key}: {type(value).__name__}")
        elif isinstance(data, list):
            print("顶级数据类型: 序列 (列表)")
            for i, item in enumerate(data):
                print(f"  [{i}]: {type(item).__name__}")
        else:
            print(f"顶级数据类型: {type(data).__name__}")
        
        return data
    except yaml.YAMLError as e:
        print(f"YAML解析错误: {e}")
        return None

# 示例YAML内容
yaml_content = """
name: John Doe
age: 30
married: true
children:
  - Alice
  - Bob
address:
  street: 123 Main St
  city: Anytown
"""

validate_yaml_types(yaml_content)
```

## 2.8 实验与验证

### 实验1：创建包含各种数据类型的YAML文件

```yaml
# data_types.yml
# 包含各种数据类型的YAML示例
---
# 标量类型
string_value: "Hello, World!"
integer_value: 42
float_value: 3.14
boolean_value: true
date_value: 2023-05-15
null_value: null

# 序列类型
simple_list:
  - item1
  - item2
  - item3

mixed_list:
  - "string"
  - 123
  - true
  - null

nested_list:
  - - nested_item1
    - nested_item2
  - - nested_item3
    - nested_item4

# 映射类型
simple_mapping:
  key1: value1
  key2: value2
  key3: value3

nested_mapping:
  outer_key1:
    inner_key1: inner_value1
    inner_key2: inner_value2
  outer_key2:
    inner_key3: inner_value3
    inner_key4: inner_value4

# 复杂结构
complex_structure:
  users:
    - name: John
      age: 30
      hobbies:
        - reading
        - swimming
    - name: Jane
      age: 25
      hobbies:
        - painting
        - dancing
  settings:
    theme: dark
    notifications: true
    language: en-US
```

### 实验2：验证数据类型

```python
# validate_data_types.py
import yaml
import json

def analyze_yaml_structure(data, prefix=""):
    """分析YAML数据结构"""
    if isinstance(data, dict):
        print(f"{prefix}映射 (字典) - {len(data)} 个键:")
        for key, value in data.items():
            print(f"{prefix}  {key}: ", end="")
            analyze_yaml_structure(value, prefix + "  ")
    elif isinstance(data, list):
        print(f"{prefix}序列 (列表) - {len(data)} 个元素:")
        for i, item in enumerate(data):
            print(f"{prefix}  [{i}]: ", end="")
            analyze_yaml_structure(item, prefix + "  ")
    elif isinstance(data, str):
        print(f"字符串: '{data}'")
    elif isinstance(data, int):
        print(f"整数: {data}")
    elif isinstance(data, float):
        print(f"浮点数: {data}")
    elif isinstance(data, bool):
        print(f"布尔值: {data}")
    elif data is None:
        print("null值")
    else:
        print(f"未知类型: {type(data).__name__}")

# 读取并分析YAML文件
with open('data_types.yml', 'r', encoding='utf-8') as file:
    data = yaml.safe_load(file)

print("YAML数据结构分析:")
analyze_yaml_structure(data)

# 转换为JSON以查看结构
json_str = json.dumps(data, ensure_ascii=False, indent=2)
print("\n等效的JSON表示:")
print(json_str)
```

## 2.9 常见问题与解决方案

### 2.9.1 数字被解析为字符串

```yaml
# 问题：数字被解析为字符串
zip_code: "12345"  # 字符串
phone: "555-1234"  # 字符串

# 解决方案：使用显式类型指定
zip_code: !!str 12345  # 明确指定为字符串
phone: !!str 555-1234  # 明确指定为字符串
```

### 2.9.2 布尔值被解析为字符串

```yaml
# 问题：布尔值被解析为字符串
is_active: "true"  # 字符串，不是布尔值

# 解决方案：不使用引号
is_active: true  # 布尔值
```

### 2.9.3 日期被解析为字符串

```yaml
# 问题：日期被解析为字符串
event_date: "2023-05-15"  # 字符串

# 解决方案：不使用引号
event_date: 2023-05-15  # 日期类型
```

## 2.10 数据类型深度解析

### 2.10.1 类型推断机制详解

YAML解析器具有强大的类型推断能力，但有时需要明确指定类型以避免歧义：

#### 自动类型推断规则

```yaml
# 字符串推断（默认）
name: John Doe           # 字符串
version: "1.0.0"         # 字符串

# 数字推断
age: 30                  # 整数
price: 19.99             # 浮点数
population: 1_000_000    # 支持下划线分隔

# 布尔值推断
active: true             # 布尔值
disabled: false          # 布尔值

# 日期时间推断
event_date: 2023-05-15   # 日期
start_time: 14:30:00     # 时间
created_at: 2023-05-15T14:30:00Z  # 带时区的日期时间
```

#### 类型推断边界情况

```yaml
# 边界情况1：数字开头的字符串
product_code: "123ABC"   # 必须使用引号
zip_code: "90210"        # 邮政编码通常作为字符串

# 边界情况2：科学计数法
scientific: 1.23e4       # 浮点数
scientific_string: "1.23e4"  # 字符串

# 边界情况3：特殊值
infinity: .inf           # 正无穷（特殊浮点数）
not_a_number: .NaN       # 非数字（特殊浮点数）
```

### 2.10.2 复杂嵌套结构处理

#### 深度嵌套结构的最佳实践

```yaml
# 深度嵌套示例（不推荐）
application:
  database:
    connection:
      pool:
        max_size: 20
        min_size: 5
        timeout: 30
    replication:
      master:
        host: master.db.example.com
        port: 5432
      slaves:
        - host: slave1.db.example.com
          port: 5432
        - host: slave2.db.example.com
          port: 5432

# 改进方案：模块化设计
# database.yml
database:
  connection_pool:
    max_size: 20
    min_size: 5
    timeout: 30
  replication:
    master: master.db.example.com:5432
    slaves:
      - slave1.db.example.com:5432
      - slave2.db.example.com:5432
```

#### 复杂结构的验证策略

```python
# complex_structure_validation.py
import yaml
from typing import Dict, List, Any, Optional
from dataclasses import dataclass

@dataclass
class DatabaseConfig:
    host: str
    port: int
    username: str
    password: str
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'DatabaseConfig':
        return cls(
            host=data['host'],
            port=data['port'],
            username=data['username'],
            password=data['password']
        )

@dataclass
class AppConfig:
    name: str
    version: str
    database: DatabaseConfig
    features: List[str]
    
    @classmethod
    def from_yaml(cls, yaml_content: str) -> 'AppConfig':
        data = yaml.safe_load(yaml_content)
        return cls(
            name=data['name'],
            version=data['version'],
            database=DatabaseConfig.from_dict(data['database']),
            features=data.get('features', [])
        )

# 使用示例
yaml_config = """
name: MyApplication
version: 1.0.0
database:
  host: localhost
  port: 5432
  username: admin
  password: secret123
features:
  - authentication
  - authorization
  - logging
"""

app_config = AppConfig.from_yaml(yaml_config)
print(f"应用名称: {app_config.name}")
print(f"数据库主机: {app_config.database.host}")
```

### 2.10.3 类型转换高级技巧

#### 自定义类型转换器

```python
# custom_type_converter.py
import yaml
from datetime import datetime, date
from decimal import Decimal

class CustomYAMLConstructor:
    """自定义YAML类型构造器"""
    
    @staticmethod
    def decimal_constructor(loader, node):
        """将字符串转换为Decimal类型"""
        value = loader.construct_scalar(node)
        return Decimal(value)
    
    @staticmethod
    def date_constructor(loader, node):
        """将字符串转换为date类型"""
        value = loader.construct_scalar(node)
        return datetime.strptime(value, '%Y-%m-%d').date()
    
    @staticmethod
    def register_constructors():
        """注册自定义构造器"""
        yaml.add_constructor('!decimal', CustomYAMLConstructor.decimal_constructor)
        yaml.add_constructor('!date', CustomYAMLConstructor.date_constructor)

# 注册自定义构造器
CustomYAMLConstructor.register_constructors()

# 使用自定义类型
yaml_content = """
price: !decimal "19.99"
event_date: !date "2023-05-15"
"""

data = yaml.load(yaml_content, Loader=yaml.FullLoader)
print(f"价格类型: {type(data['price']).__name__}")  # Decimal
print(f"日期类型: {type(data['event_date']).__name__}")  # date
```

#### 类型转换错误处理

```python
# type_conversion_error_handling.py
import yaml
from typing import Any, Optional

def safe_yaml_load(content: str, default: Any = None) -> Optional[Any]:
    """安全的YAML加载函数"""
    try:
        return yaml.safe_load(content)
    except yaml.YAMLError as e:
        print(f"YAML解析错误: {e}")
        return default
    except Exception as e:
        print(f"其他错误: {e}")
        return default

def validate_numeric_value(value: Any, expected_type: type) -> bool:
    """验证数值类型"""
    try:
        if expected_type == int:
            return isinstance(value, int) or (isinstance(value, str) and value.isdigit())
        elif expected_type == float:
            return isinstance(value, (int, float)) or (isinstance(value, str) and value.replace('.', '', 1).isdigit())
        return isinstance(value, expected_type)
    except (ValueError, TypeError):
        return False

# 测试示例
test_cases = [
    ("age: 30", int, True),
    ("age: '30'", int, True),  # 字符串数字可以转换
    ("age: thirty", int, False),  # 非数字字符串
    ("price: 19.99", float, True),
    ("price: '19.99'", float, True),
    ("price: 19,99", float, False),  # 逗号分隔符
]

for yaml_content, expected_type, should_pass in test_cases:
    data = safe_yaml_load(yaml_content)
    if data:
        key = list(data.keys())[0]
        value = data[key]
        is_valid = validate_numeric_value(value, expected_type)
        print(f"{yaml_content} -> 验证{'通过' if is_valid == should_pass else '失败'}")
```

## 2.11 性能优化与最佳实践

### 2.11.1 YAML文件性能优化

#### 减少嵌套深度

```yaml
# 性能较差的深度嵌套
app:
  config:
    database:
      connection:
        pool:
          settings:
            max_connections: 100
            timeout: 30

# 性能优化的扁平结构
app_config:
  db_max_connections: 100
  db_timeout: 30
  db_host: localhost
  db_port: 5432
```

#### 使用内联结构

```yaml
# 块状结构（可读性好，但解析稍慢）
users:
  - name: John
    age: 30
    city: New York
  - name: Jane
    age: 25
    city: Boston

# 内联结构（解析更快）
users: [{name: John, age: 30, city: New York}, {name: Jane, age: 25, city: Boston}]
```

### 2.11.2 内存使用优化

#### 流式处理大型YAML文件

```python
# stream_yaml_processing.py
import yaml
from typing import Iterator, Dict, Any

def stream_yaml_documents(file_path: str) -> Iterator[Dict[str, Any]]:
    """流式处理YAML文档，减少内存使用"""
    with open(file_path, 'r', encoding='utf-8') as file:
        for document in yaml.load_all(file, Loader=yaml.SafeLoader):
            yield document

def process_large_yaml(file_path: str):
    """处理大型YAML文件"""
    total_records = 0
    
    for i, document in enumerate(stream_yaml_documents(file_path)):
        print(f"处理第 {i+1} 个文档")
        
        # 逐个处理文档内容，避免一次性加载到内存
        if 'users' in document:
            for user in document['users']:
                total_records += 1
                # 处理每个用户记录
                process_user_record(user)
    
    print(f"总共处理了 {total_records} 条记录")

def process_user_record(user: Dict[str, Any]):
    """处理单个用户记录"""
    # 模拟处理逻辑
    pass

# 使用示例
# process_large_yaml('large_dataset.yml')
```

### 2.11.3 数据类型选择策略

#### 根据使用场景选择合适的数据类型

```yaml
# 配置场景：使用映射和序列
application:
  name: "MyApp"
  version: "1.0.0"
  features:
    - "authentication"
    - "authorization"
    - "logging"

# 数据交换场景：使用简单结构
data_export:
  format: "JSON"
  compression: "gzip"
  include_metadata: true

# 模板场景：使用复杂嵌套
template:
  metadata:
    author: "John Doe"
    created: "2023-05-15"
  content:
    sections:
      - type: "header"
        text: "Welcome"
      - type: "body"
        paragraphs:
          - "First paragraph"
          - "Second paragraph"
```

## 2.12 跨语言兼容性

### 2.12.1 不同语言的YAML解析差异

#### Python vs JavaScript vs Java

```yaml
# 通用YAML结构（跨语言兼容）
universal_config:
  # 基本类型（所有语言都支持）
  string_value: "Hello"
  number_value: 42
  boolean_value: true
  null_value: null
  
  # 序列（所有语言都支持）
  simple_list:
    - "item1"
    - "item2"
    - "item3"
  
  # 映射（所有语言都支持）
  simple_map:
    key1: "value1"
    key2: "value2"

# 需要注意的差异
potential_issues:
  # Python: datetime对象，其他语言：字符串
  date_value: 2023-05-15
  
  # Python: 支持，JavaScript: 可能需要特殊处理
  binary_data: !!binary "SGVsbG8="
  
  # 自定义类型（语言特定）
  custom_type: !!python/object:__main__.MyClass
    property: value
```

#### 跨语言兼容性最佳实践

```python
# cross_language_compatibility.py
import yaml
import json

def create_cross_language_yaml():
    """创建跨语言兼容的YAML配置"""
    
    # 使用基本数据类型
    config = {
        'application': {
            'name': 'MyApp',
            'version': '1.0.0',
            'settings': {
                'debug': False,
                'log_level': 'INFO',
                'max_connections': 100
            }
        },
        'features': ['auth', 'api', 'ui'],
        'metadata': {
            'created': '2023-05-15',  # 作为字符串，避免日期类型差异
            'author': 'John Doe'
        }
    }
    
    # 转换为YAML
    yaml_content = yaml.dump(config, default_flow_style=False, allow_unicode=True)
    
    # 同时生成JSON用于验证
    json_content = json.dumps(config, indent=2, ensure_ascii=False)
    
    return yaml_content, json_content

yaml_output, json_output = create_cross_language_yaml()
print("YAML输出:")
print(yaml_output)
print("\n等效的JSON输出:")
print(json_output)
```

## 2.13 总结与进阶

### 2.13.1 本章核心知识点总结

1. **数据类型体系**：标量、序列、映射三大基础类型
2. **类型推断机制**：自动识别字符串、数字、布尔值等
3. **复杂结构处理**：嵌套序列、映射的组合使用
4. **高级数据类型**：集合、有序映射、二进制数据
5. **类型转换技巧**：显式类型指定和自定义转换器
6. **性能优化策略**：减少嵌套、使用内联结构、流式处理
7. **跨语言兼容性**：确保配置在不同编程语言间的可移植性

### 2.13.2 实践应用建议

#### 配置管理场景
- **使用映射结构**组织层次化配置
- **利用序列类型**管理列表项
- **保持配置简洁**，避免过度嵌套

#### 数据序列化场景
- **选择合适的数据类型**表示业务对象
- **考虑跨语言兼容性**
- **使用验证机制**确保数据完整性

#### 模板生成场景
- **利用YAML的结构化特性**定义模板
- **结合锚点和别名**实现模板复用
- **使用条件逻辑**实现动态模板

### 2.13.3 下一步学习方向

掌握数据类型和结构后，可以深入学习：
- **第3章**：YAML高级特性（锚点、别名、合并键等）
- **第4章**：YAML实战应用案例
- **性能调优**：大型YAML文件的优化处理
- **工具集成**：YAML与各种开发工具的深度集成

通过系统学习和实践，您将能够熟练运用YAML处理各种复杂的数据结构和配置需求。