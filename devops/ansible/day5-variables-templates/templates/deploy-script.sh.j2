#!/bin/bash

# Deployment Script for {{ app_config.name }}
# Generated by Ansible on {{ ansible_date_time.iso8601 }}
# Environment: {{ app_config.environment }}
# Version: {{ app_config.version }}

set -euo pipefail

# Configuration
APP_NAME="{{ app_config.name }}"
APP_VERSION="{{ app_config.version }}"
ENVIRONMENT="{{ app_config.environment }}"
DEPLOY_USER="{{ deployment_user }}"
APP_DIR="{{ app_directory }}"
BACKUP_DIR="{{ backup_directory }}"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Logging functions
log() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')] [INFO]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] [WARN]${NC} $1"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] [ERROR]${NC} $1" >&2
}

success() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] [SUCCESS]${NC} $1"
}

step() {
    echo -e "${PURPLE}[$(date +'%Y-%m-%d %H:%M:%S')] [STEP]${NC} $1"
}

debug() {
    if [[ "${DEBUG:-false}" == "true" ]]; then
        echo -e "${CYAN}[$(date +'%Y-%m-%d %H:%M:%S')] [DEBUG]${NC} $1"
    fi
}

# Error handling
cleanup_on_error() {
    error "Deployment failed. Starting cleanup..."
    
    # Restore previous version if exists
    if [[ -d "${APP_DIR}.backup.${TIMESTAMP}" ]]; then
        warn "Restoring previous version..."
        rm -rf "${APP_DIR}" || true
        mv "${APP_DIR}.backup.${TIMESTAMP}" "${APP_DIR}" || true
        success "Previous version restored"
    fi
    
    # Restart services
    systemctl restart nginx || warn "Failed to restart nginx"
    {% if app_config.environment == 'production' %}
    systemctl restart {{ app_config.name | lower }} || warn "Failed to restart application service"
    {% endif %}
    
    exit 1
}

# Set error trap
trap cleanup_on_error ERR

# Check if running as correct user
check_user() {
    if [[ "$(whoami)" != "$DEPLOY_USER" ]]; then
        error "This script must be run as user: $DEPLOY_USER"
        error "Current user: $(whoami)"
        exit 1
    fi
}

# Check system requirements
check_requirements() {
    step "Checking system requirements..."
    
    local requirements_met=true
    
    # Check disk space (require at least 1GB free)
    local available_space=$(df "${APP_DIR%/*}" | awk 'NR==2 {print $4}')
    local required_space=1048576  # 1GB in KB
    
    if [[ $available_space -lt $required_space ]]; then
        error "Insufficient disk space. Required: 1GB, Available: $(($available_space/1024))MB"
        requirements_met=false
    fi
    
    # Check required commands
    local required_commands=("curl" "tar" "rsync" "systemctl")
    {% if app_config.environment != 'development' %}
    required_commands+=("docker" "docker-compose")
    {% endif %}
    
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            error "Required command not found: $cmd"
            requirements_met=false
        fi
    done
    
    # Check system load
    local load_avg=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | sed 's/,//')
    local cpu_cores={{ ansible_processor_vcpus }}
    local load_threshold=$(echo "$cpu_cores * 2" | bc)
    
    if (( $(echo "$load_avg > $load_threshold" | bc -l) )); then
        warn "High system load detected: $load_avg (threshold: $load_threshold)"
        warn "Consider running deployment during low load period"
    fi
    
    if [[ "$requirements_met" != "true" ]]; then
        error "System requirements not met. Aborting deployment."
        exit 1
    fi
    
    success "System requirements check passed"
}

# Create backup of current deployment
create_backup() {
    step "Creating backup of current deployment..."
    
    if [[ -d "$APP_DIR" ]]; then
        # Create application backup
        cp -r "$APP_DIR" "${APP_DIR}.backup.${TIMESTAMP}"
        success "Application backup created: ${APP_DIR}.backup.${TIMESTAMP}"
        
        # Create database backup
        {% set db_servers = servers | selectattr('role', 'equalto', 'database') | list %}
        {% if db_servers %}
        mysqldump \
            --host={{ db_servers[0].ip }} \
            --user={{ app_config.name | lower }}_user \
            --password={{ app_config.name | lower }}_password_{{ app_config.environment }} \
            --single-transaction \
            --routines \
            --triggers \
            {{ app_config.name | lower }}_{{ app_config.environment }} \
            | gzip > "${BACKUP_DIR}/database_backup_${TIMESTAMP}.sql.gz"
        {% else %}
        docker exec {{ app_config.name | lower }}_mysql mysqldump \
            --user=root \
            --password={{ app_config.name | lower }}_root_{{ app_config.environment }} \
            --single-transaction \
            --routines \
            --triggers \
            {{ app_config.name | lower }}_{{ app_config.environment }} \
            | gzip > "${BACKUP_DIR}/database_backup_${TIMESTAMP}.sql.gz"
        {% endif %}
        success "Database backup created: ${BACKUP_DIR}/database_backup_${TIMESTAMP}.sql.gz"
        
        # Create configuration backup
        tar -czf "${BACKUP_DIR}/config_backup_${TIMESTAMP}.tar.gz" \
            /etc/nginx/sites-available/{{ app_config.name | lower }}* \
            {% if app_config.environment == 'production' %}
            /etc/systemd/system/{{ app_config.name | lower }}.service \
            {% endif %}
            2>/dev/null || warn "Some configuration files might not exist"
        success "Configuration backup created"
    else
        log "No existing deployment found to backup"
    fi
}

# Download and prepare new version
prepare_deployment() {
    step "Preparing new deployment..."
    
    # Create temporary directory
    local temp_dir="/tmp/{{ app_config.name | lower }}_deploy_${TIMESTAMP}"
    mkdir -p "$temp_dir"
    
    {% if app_config.environment == 'production' %}
    # Download release artifact
    log "Downloading {{ app_config.name }} v{{ app_config.version }}..."
    curl -L -o "${temp_dir}/{{ app_config.name | lower }}-{{ app_config.version }}.tar.gz" \
        "https://releases.company.com/{{ app_config.name | lower }}/{{ app_config.version }}/{{ app_config.name | lower }}-{{ app_config.version }}.tar.gz"
    
    # Verify checksum
    curl -L -o "${temp_dir}/{{ app_config.name | lower }}-{{ app_config.version }}.sha256" \
        "https://releases.company.com/{{ app_config.name | lower }}/{{ app_config.version }}/{{ app_config.name | lower }}-{{ app_config.version }}.sha256"
    
    cd "$temp_dir"
    if sha256sum -c "{{ app_config.name | lower }}-{{ app_config.version }}.sha256"; then
        success "Checksum verification passed"
    else
        error "Checksum verification failed"
        exit 1
    fi
    
    # Extract archive
    tar -xzf "{{ app_config.name | lower }}-{{ app_config.version }}.tar.gz"
    {% else %}
    # For non-production, use local build
    log "Building application for {{ app_config.environment }}..."
    
    # Clone or update repository
    if [[ -d "${temp_dir}/src" ]]; then
        cd "${temp_dir}/src"
        git pull origin {{ app_config.environment }}
    else
        git clone -b {{ app_config.environment }} \
            https://github.com/company/{{ app_config.name | lower }}.git \
            "${temp_dir}/src"
        cd "${temp_dir}/src"
    fi
    
    # Build application
    {% if app_config.environment == 'development' %}
    # Development build
    npm install
    npm run build:dev
    {% else %}
    # Staging build
    npm install --production
    npm run build:staging
    {% endif %}
    {% endif %}
    
    # Prepare application directory
    mkdir -p "$APP_DIR"
    
    # Copy files
    {% if app_config.environment == 'production' %}
    rsync -av --exclude='.git' "${temp_dir}/{{ app_config.name | lower }}-{{ app_config.version }}/" "$APP_DIR/"
    {% else %}
    rsync -av --exclude='.git' --exclude='node_modules' "${temp_dir}/src/" "$APP_DIR/"
    {% endif %}
    
    # Set permissions
    chown -R "$DEPLOY_USER:$DEPLOY_USER" "$APP_DIR"
    find "$APP_DIR" -type f -exec chmod 644 {} \;
    find "$APP_DIR" -type d -exec chmod 755 {} \;
    find "$APP_DIR/bin" -type f -exec chmod +x {} \; 2>/dev/null || true
    
    # Cleanup temp directory
    rm -rf "$temp_dir"
    
    success "Application files prepared"
}

# Update configuration files
update_configuration() {
    step "Updating configuration files..."
    
    # Generate application configuration
    cat > "${APP_DIR}/config/{{ app_config.environment }}.yml" << 'EOF'
# Application configuration for {{ app_config.environment }}
# Generated during deployment on {{ ansible_date_time.iso8601 }}

application:
  name: {{ app_config.name }}
  version: {{ app_config.version }}
  environment: {{ app_config.environment }}
  
server:
  {% if app_config.environment == 'production' %}
  port: 8080
  workers: {{ ansible_processor_vcpus * 2 }}
  {% elif app_config.environment == 'staging' %}
  port: 8081
  workers: {{ ansible_processor_vcpus }}
  {% else %}
  port: 3000
  workers: 1
  {% endif %}
  
database:
  {% set db_servers = servers | selectattr('role', 'equalto', 'database') | list %}
  host: {% if db_servers %}"{{ db_servers[0].ip }}"{% else %}"localhost"{% endif %}
  
  port: 3306
  name: "{{ app_config.name | lower }}_{{ app_config.environment }}"
  user: "{{ app_config.name | lower }}_user"
  password: "{{ app_config.name | lower }}_password_{{ app_config.environment }}"

cache:
  {% set api_servers = servers | selectattr('role', 'equalto', 'api') | list %}
  {% if api_servers %}
  enabled: true
  host: "{{ api_servers[0].ip }}"
  {% else %}
  enabled: false
  host: "localhost"
  {% endif %}
  port: 6379
  db: {{ 0 if app_config.environment == 'production' else 1 }}

logging:
  level: {% if app_config.environment == 'production' %}"WARNING"{% elif app_config.environment == 'staging' %}"INFO"{% else %}"DEBUG"{% endif %}
  
  file: "/var/log/{{ app_config.name | lower }}/application.log"
EOF
    
    # Create environment file
    cat > "${APP_DIR}/.env" << EOF
NODE_ENV={{ app_config.environment }}
APP_NAME={{ app_config.name }}
APP_VERSION={{ app_config.version }}
DEPLOYMENT_TIME=${TIMESTAMP}
EOF
    
    success "Configuration files updated"
}

# Manage database migrations
run_migrations() {
    step "Running database migrations..."
    
    {% if app_config.environment == 'development' %}
    # Development: run migrations directly
    cd "$APP_DIR"
    npm run migrate
    {% else %}
    # Production/Staging: use Docker
    {% set db_servers = servers | selectattr('role', 'equalto', 'database') | list %}
    {% if db_servers %}
    # External database
    mysql \
        --host={{ db_servers[0].ip }} \
        --user={{ app_config.name | lower }}_user \
        --password={{ app_config.name | lower }}_password_{{ app_config.environment }} \
        {{ app_config.name | lower }}_{{ app_config.environment }} \
        < "${APP_DIR}/database/migrations/migrate.sql" || warn "Migration script not found or failed"
    {% else %}
    # Docker database
    if docker ps | grep -q {{ app_config.name | lower }}_mysql; then
        docker exec {{ app_config.name | lower }}_mysql mysql \
            --user=root \
            --password={{ app_config.name | lower }}_root_{{ app_config.environment }} \
            {{ app_config.name | lower }}_{{ app_config.environment }} \
            -e "SELECT 'Database migration placeholder - implement actual migrations'"
    fi
    {% endif %}
    {% endif %}
    
    success "Database migrations completed"
}

# Update and restart services
update_services() {
    step "Updating and restarting services..."
    
    {% if app_config.environment != 'development' %}
    # Update Docker containers
    if [[ -f "${APP_DIR}/docker-compose.yml" ]]; then
        cd "$APP_DIR"
        
        # Pull latest images
        docker-compose pull
        
        # Restart services with zero downtime
        docker-compose up -d --no-deps app
        
        # Wait for health check
        log "Waiting for application to be healthy..."
        local retry_count=0
        local max_retries=30
        
        while [[ $retry_count -lt $max_retries ]]; do
            if curl -f http://localhost:{% if app_config.environment == 'production' %}8080{% elif app_config.environment == 'staging' %}8081{% else %}3000{% endif %}/health &>/dev/null; then
                success "Application is healthy"
                break
            fi
            
            sleep 2
            ((retry_count++))
            debug "Health check attempt $retry_count/$max_retries"
        done
        
        if [[ $retry_count -eq $max_retries ]]; then
            error "Application failed to start properly"
            exit 1
        fi
        
        # Update other services
        docker-compose up -d
    fi
    {% endif %}
    
    {% if app_config.environment == 'production' %}
    # Update systemd service
    systemctl daemon-reload
    systemctl restart {{ app_config.name | lower }}
    systemctl enable {{ app_config.name | lower }}
    
    # Wait for service to be active
    local retry_count=0
    while [[ $retry_count -lt 10 ]]; do
        if systemctl is-active --quiet {{ app_config.name | lower }}; then
            success "Service {{ app_config.name | lower }} is active"
            break
        fi
        sleep 2
        ((retry_count++))
    done
    {% endif %}
    
    # Restart nginx
    systemctl restart nginx
    systemctl reload nginx
    
    success "Services updated and restarted"
}

# Run post-deployment tasks
post_deployment() {
    step "Running post-deployment tasks..."
    
    # Clear application cache
    {% if app_config.environment != 'development' %}
    {% set api_servers = servers | selectattr('role', 'equalto', 'api') | list %}
    {% if api_servers %}
    redis-cli -h {{ api_servers[0].ip }} -p 6379 FLUSHDB || warn "Failed to clear Redis cache"
    {% else %}
    docker exec {{ app_config.name | lower }}_redis redis-cli FLUSHDB || warn "Failed to clear Redis cache"
    {% endif %}
    {% endif %}
    
    # Warm up cache
    log "Warming up application cache..."
    curl -s http://localhost:{% if app_config.environment == 'production' %}8080{% elif app_config.environment == 'staging' %}8081{% else %}3000{% endif %}/warmup &>/dev/null || warn "Cache warmup failed"
    
    # Update file permissions
    find "$APP_DIR" -name "*.log" -exec chmod 666 {} \; 2>/dev/null || true
    
    # Clean old backups (keep last 5)
    find "$BACKUP_DIR" -name "*backup*" -type f -mtime +7 -delete 2>/dev/null || true
    
    # Clean old Docker images
    {% if app_config.environment != 'development' %}
    docker image prune -f &>/dev/null || true
    {% endif %}
    
    # Send deployment notification
    {% if users | selectattr('role', 'equalto', 'admin') | list %}
    {% for admin in users | selectattr('role', 'equalto', 'admin') | list %}
    {% if app_config.environment == 'production' %}
    echo "{{ app_config.name }} v{{ app_config.version }} has been successfully deployed to {{ app_config.environment }} at $(date)" | \
        mail -s "[DEPLOYMENT] {{ app_config.name }} {{ app_config.environment }}" {{ admin.email }} || warn "Failed to send notification email"
    {% endif %}
    {% endfor %}
    {% endif %}
    
    success "Post-deployment tasks completed"
}

# Verify deployment
verify_deployment() {
    step "Verifying deployment..."
    
    local verification_failed=false
    
    # Check application version
    local deployed_version
    {% if app_config.environment == 'development' %}
    deployed_version=$(curl -s http://localhost:3000/version | jq -r '.version' 2>/dev/null || echo "unknown")
    {% else %}
    deployed_version=$(curl -s http://localhost:{% if app_config.environment == 'production' %}8080{% else %}8081{% endif %}/version | jq -r '.version' 2>/dev/null || echo "unknown")
    {% endif %}
    
    if [[ "$deployed_version" == "{{ app_config.version }}" ]]; then
        success "Version verification passed: $deployed_version"
    else
        error "Version mismatch. Expected: {{ app_config.version }}, Got: $deployed_version"
        verification_failed=true
    fi
    
    # Check service status
    {% if app_config.environment == 'production' %}
    if systemctl is-active --quiet {{ app_config.name | lower }}; then
        success "Service {{ app_config.name | lower }} is running"
    else
        error "Service {{ app_config.name | lower }} is not running"
        verification_failed=true
    fi
    {% endif %}
    
    if systemctl is-active --quiet nginx; then
        success "Nginx is running"
    else
        error "Nginx is not running"
        verification_failed=true
    fi
    
    # Check HTTP response
    {% for website in websites %}
    local http_code=$(curl -s -o /dev/null -w "%{http_code}" http://{{ website.domain }}/health 2>/dev/null || echo "000")
    if [[ "$http_code" == "200" ]]; then
        success "HTTP health check passed for {{ website.domain }}"
    else
        error "HTTP health check failed for {{ website.domain }} (status: $http_code)"
        verification_failed=true
    fi
    {% endfor %}
    
    # Check database connectivity
    {% set db_servers = servers | selectattr('role', 'equalto', 'database') | list %}
    {% if db_servers %}
    if mysql --host={{ db_servers[0].ip }} --user={{ app_config.name | lower }}_user --password={{ app_config.name | lower }}_password_{{ app_config.environment }} -e "SELECT 1" {{ app_config.name | lower }}_{{ app_config.environment }} &>/dev/null; then
        success "Database connectivity check passed"
    else
        error "Database connectivity check failed"
        verification_failed=true
    fi
    {% endif %}
    
    if [[ "$verification_failed" == "true" ]]; then
        error "Deployment verification failed"
        exit 1
    fi
    
    success "Deployment verification completed successfully"
}

# Generate deployment report
generate_report() {
    step "Generating deployment report..."
    
    local report_file="${BACKUP_DIR}/deployment_report_${TIMESTAMP}.txt"
    
    cat > "$report_file" << EOF
# Deployment Report
Application: {{ app_config.name }}
Version: {{ app_config.version }}
Environment: {{ app_config.environment }}
Deployed by: $DEPLOY_USER
Deployment time: $(date)
Hostname: $(hostname)

## Deployment Details
- Backup created: ${BACKUP_DIR}/database_backup_${TIMESTAMP}.sql.gz
- Previous version backed up: ${APP_DIR}.backup.${TIMESTAMP}
- Configuration updated: ${APP_DIR}/config/{{ app_config.environment }}.yml
- Services restarted: nginx{% if app_config.environment == 'production' %}, {{ app_config.name | lower }}{% endif %}

## System Information
- OS: $(lsb_release -d | cut -f2)
- Kernel: $(uname -r)
- CPU cores: {{ ansible_processor_vcpus }}
- Memory: {{ ansible_memtotal_mb }}MB
- Disk usage: $(df -h ${APP_DIR%/*} | awk 'NR==2 {print $5}')
- Load average: $(uptime | awk -F'load average:' '{print $2}')

## Application Status
- Version: $(curl -s http://localhost:{% if app_config.environment == 'production' %}8080{% elif app_config.environment == 'staging' %}8081{% else %}3000{% endif %}/version 2>/dev/null | jq -r '.version' || echo 'unknown')
- Health status: $(curl -s http://localhost:{% if app_config.environment == 'production' %}8080{% elif app_config.environment == 'staging' %}8081{% else %}3000{% endif %}/health 2>/dev/null || echo 'unhealthy')
- Start time: $(curl -s http://localhost:{% if app_config.environment == 'production' %}8080{% elif app_config.environment == 'staging' %}8081{% else %}3000{% endif %}/status 2>/dev/null | jq -r '.start_time' || echo 'unknown')

## Next Steps
1. Monitor application logs: tail -f /var/log/{{ app_config.name | lower }}/application.log
2. Monitor system metrics: htop
3. Check error logs: tail -f /var/log/nginx/error.log
4. Verify functionality with smoke tests
5. Monitor performance for next 30 minutes

Deployment completed successfully! ðŸŽ‰
EOF
    
    success "Deployment report generated: $report_file"
    
    # Display summary
    echo
    echo "================================================"
    echo "ðŸŽ‰ DEPLOYMENT COMPLETED SUCCESSFULLY! ðŸŽ‰"
    echo "================================================"
    echo "Application: {{ app_config.name }} v{{ app_config.version }}"
    echo "Environment: {{ app_config.environment }}"
    echo "Deployed at: $(date)"
    echo "Report: $report_file"
    echo "================================================"
}

# Display usage information
usage() {
    echo "Usage: $0 [OPTIONS]"
    echo
    echo "Options:"
    echo "  -h, --help          Show this help message"
    echo "  -v, --version       Show script version"
    echo "  -d, --debug         Enable debug mode"
    echo "  --dry-run          Perform a dry run without making changes"
    echo "  --skip-backup      Skip backup creation (not recommended)"
    echo "  --skip-migrations  Skip database migrations"
    echo "  --skip-tests       Skip verification tests"
    echo
    echo "Environment: {{ app_config.environment }}"
    echo "Target directory: {{ app_directory }}"
    echo "Deploy user: {{ deployment_user }}"
}

# Parse command line arguments
SKIP_BACKUP=false
SKIP_MIGRATIONS=false
SKIP_TESTS=false
DRY_RUN=false
DEBUG=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            exit 0
            ;;
        -v|--version)
            echo "Deployment script v1.0 for {{ app_config.name }}"
            exit 0
            ;;
        -d|--debug)
            DEBUG=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --skip-backup)
            SKIP_BACKUP=true
            shift
            ;;
        --skip-migrations)
            SKIP_MIGRATIONS=true
            shift
            ;;
        --skip-tests)
            SKIP_TESTS=true
            shift
            ;;
        *)
            error "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

# Main deployment process
main() {
    echo "========================================"
    echo "ðŸš€ Starting deployment of {{ app_config.name }}"
    echo "========================================"
    echo "Version: {{ app_config.version }}"
    echo "Environment: {{ app_config.environment }}"
    echo "Target: {{ app_directory }}"
    echo "User: {{ deployment_user }}"
    echo "Time: $(date)"
    echo "========================================"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        warn "DRY RUN MODE - No changes will be made"
    fi
    
    # Pre-deployment checks
    check_user
    check_requirements
    
    if [[ "$DRY_RUN" == "false" ]]; then
        # Create backup
        if [[ "$SKIP_BACKUP" == "false" ]]; then
            create_backup
        else
            warn "Skipping backup creation"
        fi
        
        # Deploy application
        prepare_deployment
        update_configuration
        
        # Database migrations
        if [[ "$SKIP_MIGRATIONS" == "false" ]]; then
            run_migrations
        else
            warn "Skipping database migrations"
        fi
        
        # Update services
        update_services
        
        # Post-deployment tasks
        post_deployment
        
        # Verification
        if [[ "$SKIP_TESTS" == "false" ]]; then
            verify_deployment
        else
            warn "Skipping deployment verification"
        fi
        
        # Generate report
        generate_report
    else
        log "Dry run completed successfully"
    fi
}

# Run main function
main "$@" 