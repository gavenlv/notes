# 第6章：Skaffold高级特性详解

## 6.1 高级配置模式

### 6.1.1 配置继承和覆盖

Skaffold支持配置继承机制，允许重用和扩展基础配置。

```yaml
# base.yaml - 基础配置
apiVersion: skaffold/v4beta1
kind: Config
metadata:
  name: base-config

build:
  artifacts:
    - image: my-registry/base-app
      context: .
      docker:
        dockerfile: Dockerfile

deploy:
  kubectl:
    manifests:
      - k8s/base/*.yaml
```

```yaml
# skaffold.yaml - 继承并扩展基础配置
apiVersion: skaffold/v4beta1
kind: Config

# 导入基础配置
imports:
  - path: base.yaml

# 覆盖和扩展配置
metadata:
  name: extended-app

build:
  artifacts:
    - image: my-registry/extended-app
      context: .
      docker:
        dockerfile: Dockerfile
        buildArgs:
          FEATURE_FLAG: "advanced"

deploy:
  kubectl:
    manifests:
      - k8s/extended/*.yaml
```

### 6.1.2 条件配置

基于环境变量或条件的动态配置。

```yaml
# skaffold.yaml - 条件配置
apiVersion: skaffold/v4beta1
kind: Config

build:
  artifacts:
    - image: my-registry/conditional-app
      context: .
      docker:
        dockerfile: Dockerfile
        # 基于环境变量的条件构建
        buildArgs:
          BUILD_OPTIMIZATION: ${BUILD_OPTIMIZATION:-standard}

# 基于条件的部署配置
{{if eq .BUILD_OPTIMIZATION "production"}}
deploy:
  kubectl:
    manifests:
      - k8s/production/*.yaml
{{else}}
deploy:
  kubectl:
    manifests:
      - k8s/development/*.yaml
{{end}}
```

## 6.2 多模块项目支持

### 6.2.1 模块化项目结构

大型项目通常包含多个独立模块，Skaffold支持模块化管理。

```yaml
# skaffold.yaml - 多模块配置
apiVersion: skaffold/v4beta1
kind: Config

# 项目模块定义
modules:
  - name: frontend
    path: frontend
    # 模块特定配置
    build:
      artifacts:
        - image: my-registry/frontend
          context: frontend
          docker:
            dockerfile: Dockerfile
    deploy:
      kubectl:
        manifests:
          - frontend/k8s/*.yaml

  - name: backend
    path: backend
    build:
      artifacts:
        - image: my-registry/backend
          context: backend
          docker:
            dockerfile: Dockerfile
    deploy:
      kubectl:
        manifests:
          - backend/k8s/*.yaml

  - name: database
    path: database
    build:
      artifacts:
        - image: my-registry/database
          context: database
          docker:
            dockerfile: Dockerfile
    deploy:
      kubectl:
        manifests:
          - database/k8s/*.yaml

# 全局配置
build:
  # 并行构建所有模块
  concurrency: 0

deploy:
  # 顺序部署，确保依赖关系
  kubectl:
    manifests:
      - database/k8s/*.yaml
      - backend/k8s/*.yaml
      - frontend/k8s/*.yaml
```

### 6.2.2 模块依赖管理

```yaml
# 模块依赖配置
modules:
  - name: database
    path: database
    # 数据库模块

  - name: backend
    path: backend
    dependsOn:
      - database
    # 后端依赖数据库

  - name: frontend
    path: frontend
    dependsOn:
      - backend
    # 前端依赖后端

# 自定义部署顺序
deploy:
  kubectl:
    manifests:
      - database/k8s/*.yaml
    # 等待数据库就绪
    wait:
      for:
        condition=ready: pod/database-pod
    
    - backend/k8s/*.yaml
    # 等待后端就绪
    wait:
      for:
        condition=ready: pod/backend-pod
    
    - frontend/k8s/*.yaml
```

## 6.3 自定义构建器

### 6.3.1 自定义构建脚本

当标准构建器无法满足需求时，可以使用自定义构建脚本。

```yaml
# skaffold.yaml - 自定义构建器
build:
  artifacts:
    - image: my-registry/custom-built-app
      context: .
      # 使用自定义构建器
      custom:
        buildCommand: ["./scripts/custom-build.sh"]
        dependencies:
          paths:
            - src/**/*.go
            - go.mod
            - go.sum
          command: go mod download
        # 构建参数
        buildArgs:
          BUILD_TYPE: "production"
          OPTIMIZATION: "high"
```

### 6.3.2 自定义构建脚本示例

```bash
#!/bin/bash
# scripts/custom-build.sh

set -e

echo "开始自定义构建过程..."

# 环境变量
BUILD_TYPE=${BUILD_TYPE:-standard}
OPTIMIZATION=${OPTIMIZATION:-normal}
IMAGE_NAME=${IMAGE_NAME:-my-app}

# 构建准备
if [ ! -f "go.mod" ]; then
    echo "错误：go.mod文件不存在"
    exit 1
fi

# 下载依赖
echo "下载Go依赖..."
go mod download

# 根据构建类型选择参数
case "$BUILD_TYPE" in
    "production")
        BUILD_FLAGS="-ldflags='-w -s'"
        OPTIMIZATION_FLAGS="-gcflags='all=-N -l'"
        ;;
    "development")
        BUILD_FLAGS=""
        OPTIMIZATION_FLAGS=""
        ;;
    *)
        BUILD_FLAGS=""
        OPTIMIZATION_FLAGS=""
        ;;
esac

# 编译应用
echo "编译应用..."
CGO_ENABLED=0 go build $BUILD_FLAGS $OPTIMIZATION_FLAGS -o /app/my-app ./src

# 创建Docker镜像
echo "构建Docker镜像..."
docker build -t $IMAGE_NAME .

echo "自定义构建完成"
```

## 6.4 高级部署策略

### 6.4.1 蓝绿部署

```yaml
# skaffold.yaml - 蓝绿部署配置
deploy:
  kubectl:
    manifests:
      - k8s/blue-deployment.yaml
      - k8s/green-deployment.yaml
      - k8s/service.yaml

# 蓝绿部署脚本
hooks:
  predeploy:
    - command: ["sh", "-c", "echo '开始蓝绿部署...'"]
  postdeploy:
    - command: ["./scripts/blue-green-deploy.sh"]
      # 部署后切换到新版本
```

### 6.4.2 金丝雀发布

```yaml
# skaffold.yaml - 金丝雀发布配置
deploy:
  kubectl:
    manifests:
      - k8s/canary-deployment.yaml
      - k8s/stable-deployment.yaml
      - k8s/service.yaml

# 金丝雀发布策略
profiles:
  - name: canary
    patches:
      - op: replace
        path: /deploy/kubectl/manifests/0
        value: k8s/canary-deployment.yaml
      # 仅部署10%流量到金丝雀版本
      - op: add
        path: /deploy/kubectl/flags
        value:
          global:
            - --selector=version=canary
            - --replicas=1
```

### 6.4.3 滚动更新优化

```yaml
# deployment.yaml - 滚动更新优化
apiVersion: apps/v1
kind: Deployment
metadata:
  name: optimized-app
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 0
  template:
    spec:
      containers:
      - name: app
        image: my-registry/optimized-app
        # 健康检查配置
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 1
```

## 6.5 性能优化

### 6.5.1 构建缓存优化

```yaml
# skaffold.yaml - 构建缓存优化
build:
  artifacts:
    - image: my-registry/cached-app
      context: .
      docker:
        dockerfile: Dockerfile
        # 缓存配置
        cacheFrom:
          - my-registry/cached-app:latest
          - my-registry/cached-app:{{.BUILDKIT_CACHE_TAG}}
        cacheTo:
          - type: registry
            params:
              mode: max
              ref: my-registry/cached-app:latest
  # 构建器配置
  local:
    useBuildkit: true
    # 并发构建
    concurrency: 4
    # 缓存配置
    cache:
      use: true
      import:
        - type: registry
          ref: my-registry/build-cache:latest
      export:
        - type: registry
          ref: my-registry/build-cache:latest
```

### 6.5.2 镜像分层优化

```dockerfile
# Dockerfile - 镜像分层优化
FROM golang:1.19-alpine as builder

# 单独层：依赖下载
COPY go.mod go.sum ./
RUN go mod download

# 单独层：源码复制
COPY . .

# 单独层：构建
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o /app/my-app .

# 最终镜像
FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/

# 仅复制构建结果
COPY --from=builder /app/my-app .

CMD ["./my-app"]
```

### 6.5.3 增量构建优化

```yaml
# skaffold.yaml - 增量构建配置
build:
  artifacts:
    - image: my-registry/incremental-app
      context: .
      docker:
        dockerfile: Dockerfile
        # 增量构建配置
        target: development
      # 文件监视配置
      sync:
        manual:
          - src: "src/**/*.go"
            dest: "/app/src"
          - src: "config/**/*.yaml"
            dest: "/app/config"
```

## 6.6 安全加固

### 6.6.1 镜像安全扫描

```yaml
# skaffold.yaml - 安全扫描集成
test:
  - name: security-scan
    image: my-registry/secure-app
    commands:
      - command: trivy image --severity HIGH,CRITICAL my-registry/secure-app:latest
        dir: .
        # 安全扫描失败则停止部署
        onFailure: stop
      - command: grype my-registry/secure-app:latest
        dir: .
        # 软件成分分析
      - command: checkov --directory . --framework kubernetes
        dir: .
        # 基础设施安全扫描
```

### 6.6.2 安全上下文配置

```yaml
# deployment.yaml - 安全上下文配置
apiVersion: apps/v1
kind: Deployment
metadata:
  name: secure-app
spec:
  template:
    spec:
      # Pod安全上下文
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
        seccompProfile:
          type: RuntimeDefault
      containers:
      - name: app
        image: my-registry/secure-app
        # 容器安全上下文
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
              - ALL
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 1000
```

### 6.6.3 网络策略配置

```yaml
# network-policy.yaml - 网络策略
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: app-network-policy
spec:
  podSelector:
    matchLabels:
      app: secure-app
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
        - podSelector:
            matchLabels:
              role: frontend
      ports:
        - protocol: TCP
          port: 8080
  egress:
    - to:
        - podSelector:
            matchLabels:
              role: database
      ports:
        - protocol: TCP
          port: 5432
```

## 6.7 监控和日志

### 6.7.1 应用监控配置

```yaml
# deployment.yaml - 监控配置
apiVersion: apps/v1
kind: Deployment
metadata:
  name: monitored-app
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "8080"
    prometheus.io/path: "/metrics"
spec:
  template:
    metadata:
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      containers:
      - name: app
        image: my-registry/monitored-app
        ports:
        - containerPort: 8080
          name: metrics
        # 资源监控
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
```

### 6.7.2 结构化日志配置

```yaml
# configmap.yaml - 日志配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-logging-config
data:
  logging.yaml: |
    development:
      level: debug
      format: json
      outputPaths:
        - stdout
      errorOutputPaths:
        - stderr
    production:
      level: info
      format: json
      outputPaths:
        - /var/log/app.log
        - stdout
      errorOutputPaths:
        - stderr
```

## 6.8 自定义hook和扩展

### 6.8.1 生命周期hook

```yaml
# skaffold.yaml - 自定义hook
hooks:
  # 构建前hook
  prebuild:
    - command: ["sh", "-c", "echo '开始构建准备...'"]
    - command: ["./scripts/pre-build.sh"]
      # 环境变量传递
      env:
        - BUILD_ENV=production
        - GIT_COMMIT=${GIT_COMMIT}
  
  # 构建后hook
  postbuild:
    - command: ["sh", "-c", "echo '构建完成，开始测试...'"]
    - command: ["./scripts/run-tests.sh"]
  
  # 部署前hook
  predeploy:
    - command: ["kubectl", "get", "nodes"]
      # 检查集群状态
    - command: ["./scripts/check-dependencies.sh"]
  
  # 部署后hook
  postdeploy:
    - command: ["./scripts/wait-for-ready.sh"]
      # 等待应用就绪
      timeout: 5m
    - command: ["./scripts/run-smoke-tests.sh"]
      # 冒烟测试
```

### 6.8.2 自定义扩展

```yaml
# skaffold.yaml - 自定义扩展
apiVersion: skaffold/v4beta1
kind: Config

# 自定义构建器
build:
  artifacts:
    - image: my-registry/custom-app
      context: .
      custom:
        buildCommand: ["./scripts/custom-build.sh"]
        # 自定义参数
        buildArgs:
          CUSTOM_BUILD_FLAG: "enabled"

# 自定义部署器
deploy:
  custom:
    - name: my-custom-deployer
      commandPath: "./scripts/custom-deploy.sh"
      # 参数传递
      config:
        namespace: my-namespace
        timeout: 10m
```

## 6.9 实战：企业级Skaffold配置

### 6.9.1 完整的企业级配置

```yaml
# enterprise-skaffold.yaml
apiVersion: skaffold/v4beta1
kind: Config
metadata:
  name: enterprise-app

# 多环境配置
imports:
  - path: base-config.yaml

# 模块化项目结构
modules:
  - name: api-gateway
    path: services/api-gateway
    dependsOn: []
  
  - name: user-service
    path: services/user-service
    dependsOn: ["api-gateway"]
  
  - name: product-service
    path: services/product-service
    dependsOn: ["api-gateway"]
  
  - name: frontend
    path: frontend
    dependsOn: ["api-gateway", "user-service", "product-service"]

# 高级构建配置
build:
  artifacts:
    - image: ${REGISTRY}/api-gateway
      context: services/api-gateway
      docker:
        dockerfile: Dockerfile
        buildArgs:
          BUILD_ENV: ${ENVIRONMENT}
          VERSION: ${VERSION}
      sync:
        auto: {}
  
  # 构建优化
  local:
    useBuildkit: true
    concurrency: 0
    cache:
      use: true
      import:
        - type: registry
          ref: ${REGISTRY}/build-cache:latest

# 高级部署配置
deploy:
  kubectl:
    manifests:
      - infrastructure/**/*.yaml
      - services/**/*.yaml
    # 部署优化
    flags:
      global:
        - --server-side
        - --force-conflicts
    wait:
      enabled: true
      for:
        condition=ready: pod/api-gateway
        condition=available: deployment/user-service

# 完整测试流水线
test:
  - name: security-scan
    commands:
      - command: trivy image --severity HIGH,CRITICAL ${REGISTRY}/api-gateway:latest
  
  - name: integration-tests
    dependencies:
      command: ./scripts/setup-test-environment.sh
    commands:
      - command: ./scripts/run-integration-tests.sh

# 生命周期hook
hooks:
  prebuild:
    - command: ["./scripts/check-dependencies.sh"]
  
  postdeploy:
    - command: ["./scripts/run-smoke-tests.sh"]
      timeout: 10m

# 环境配置
profiles:
  - name: dev
    patches:
      - op: replace
        path: /build/artifacts/0/docker/buildArgs/BUILD_ENV
        value: "development"
  
  - name: prod
    patches:
      - op: replace
        path: /build/artifacts/0/docker/buildArgs/BUILD_ENV
        value: "production"
      - op: add
        path: /test
        value:
          - name: production-sanity
            commands:
              - command: ./scripts/production-sanity-check.sh
```

## 6.10 本章总结

本章深入探讨了Skaffold的高级特性，包括：
- 高级配置模式和模块化项目支持
- 自定义构建器和部署策略
- 性能优化和安全加固
- 监控、日志和自定义扩展

通过本章的学习，您应该能够：
✅ 设计和实现复杂的企业级Skaffold配置
✅ 优化构建和部署性能
✅ 实施安全最佳实践
✅ 扩展Skaffold功能以满足特定需求

下一章将探讨Skaffold与CI/CD的集成。