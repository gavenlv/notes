# 第4章：非关系型数据建模

## 4.1 非关系型数据库概述

非关系型数据库（NoSQL，Not Only SQL）是一类不遵循传统关系型数据库范式的数据库系统。它们是为了解决大规模数据存储、高并发访问、灵活的数据结构等问题而设计的。

### 4.1.1 非关系型数据库的兴起背景

随着互联网和移动应用的快速发展，传统关系型数据库在处理以下场景时遇到了挑战：

- **大规模数据**：需要存储和处理TB级甚至PB级的数据
- **高并发访问**：每秒数万甚至数十万的请求量
- **灵活的数据结构**：数据模式经常变化或难以预先定义
- **分布式部署**：需要在多个节点上水平扩展
- **低成本存储**：需要经济高效的存储解决方案

### 4.1.2 非关系型数据库的特点

- **灵活的数据模型**：不遵循固定的表结构，支持半结构化和非结构化数据
- **水平可扩展性**：可以通过添加节点来扩展存储容量和处理能力
- **高性能**：针对特定场景优化，如高读写吞吐量
- **分布式架构**：天然支持分布式部署和数据复制
- **容错性**：通过数据复制和冗余机制提供高可用性

### 4.1.3 非关系型数据库的分类

根据数据模型的不同，非关系型数据库可以分为以下几类：

| 类型 | 主要特点 | 代表产品 | 适用场景 |
|------|----------|----------|----------|
| 文档型 | 以文档为单位存储，类似JSON或XML格式 | MongoDB, CouchDB | 内容管理系统、博客平台、电子商务 |
| 键值型 | 简单的键值对存储，类似哈希表 | Redis, Riak, Memcached | 缓存、会话管理、实时分析 |
| 列族型 | 按列族存储数据，适合宽表和聚合查询 | HBase, Cassandra | 日志分析、时间序列数据、大数据处理 |
| 图形型 | 以节点和边的形式存储数据，适合处理关系 | Neo4j, OrientDB | 社交网络、推荐系统、知识图谱 |
| 时间序列 | 专门存储和处理时间戳数据 | InfluxDB, TimescaleDB | IoT数据、监控数据、金融交易记录 |
| 搜索引擎 | 针对全文搜索优化的数据库 | Elasticsearch, Solr | 日志搜索、全文检索、数据分析 |

## 4.2 文档型数据库建模

文档型数据库以文档为基本存储单位，文档通常使用JSON、BSON或XML格式。MongoDB是最流行的文档型数据库之一。

### 4.2.1 核心概念

- **文档（Document）**：数据库的基本存储单位，类似关系型数据库的行
- **集合（Collection）**：文档的集合，类似关系型数据库的表
- **字段（Field）**：文档中的键值对，类似关系型数据库的列
- **嵌套文档（Embedded Document）**：文档内部的子文档
- **数组（Array）**：文档中的数组类型字段

### 4.2.2 数据建模原则

1. **面向应用设计**：根据应用的查询需求设计数据模型
2. **嵌入与引用平衡**：决定何时嵌入数据，何时引用数据
3. **避免过度规范化**：适当冗余数据以提高查询性能
4. **考虑查询模式**：优先优化最频繁的查询
5. **索引策略**：为常用查询字段创建索引

### 4.2.3 嵌入与引用的选择

| 考虑因素 | 嵌入 | 引用 |
|----------|------|------|
| 关系类型 | 一对一、一对多（少量子文档） | 一对多（大量子文档）、多对多 |
| 数据访问频率 | 经常一起访问 | 独立访问 |
| 数据一致性 | 强一致性要求 | 最终一致性可接受 |
| 文档大小 | 小到中等 | 大文档 |
| 更新频率 | 一起更新 | 独立更新 |

### 4.2.4 MongoDB建模示例

#### 电商系统数据模型

```json
// 用户文档
{
  "_id": ObjectId("609c8e6b6b7d4f0017a1b2c3"),
  "username": "john_doe",
  "email": "john.doe@example.com",
  "password": "hashed_password",
  "profile": {
    "firstName": "John",
    "lastName": "Doe",
    "address": {
      "street": "123 Main St",
      "city": "New York",
      "state": "NY",
      "zip": "10001",
      "country": "USA"
    },
    "phone": "123-456-7890"
  },
  "createdAt": ISODate("2023-05-12T10:30:00Z"),
  "updatedAt": ISODate("2023-05-12T10:30:00Z")
}

// 产品文档
{
  "_id": ObjectId("609c8e6b6b7d4f0017a1b2c4"),
  "name": "Dell XPS 13",
  "description": "13-inch laptop with 11th Gen Intel Core processor",
  "price": 999.99,
  "category": "Electronics",
  "subcategory": "Laptops",
  "brand": "Dell",
  "specs": {
    "processor": "Intel Core i7-1165G7",
    "ram": "16GB",
    "storage": "512GB SSD",
    "display": "13.4-inch FHD+"
  },
  "stock": 50,
  "images": [
    "https://example.com/images/xps13-1.jpg",
    "https://example.com/images/xps13-2.jpg"
  ],
  "tags": ["laptop", "dell", "ultrabook"],
  "createdAt": ISODate("2023-05-12T10:30:00Z"),
  "updatedAt": ISODate("2023-05-12T10:30:00Z")
}

// 订单文档（嵌入订单项）
{
  "_id": ObjectId("609c8e6b6b7d4f0017a1b2c5"),
  "userId": ObjectId("609c8e6b6b7d4f0017a1b2c3"),
  "orderDate": ISODate("2023-05-15T14:45:00Z"),
  "status": "shipped",
  "shippingAddress": {
    "street": "123 Main St",
    "city": "New York",
    "state": "NY",
    "zip": "10001",
    "country": "USA"
  },
  "items": [
    {
      "productId": ObjectId("609c8e6b6b7d4f0017a1b2c4"),
      "name": "Dell XPS 13",
      "price": 999.99,
      "quantity": 1
    },
    {
      "productId": ObjectId("609c8e6b6b7d4f0017a1b2c6"),
      "name": "Wireless Mouse",
      "price": 29.99,
      "quantity": 2
    }
  ],
  "totalAmount": 1059.97,
  "paymentMethod": "credit_card",
  "paymentStatus": "completed",
  "trackingNumber": "1Z999AA10123456784",
  "createdAt": ISODate("2023-05-15T14:45:00Z"),
  "updatedAt": ISODate("2023-05-16T09:30:00Z")
}
```

## 4.3 键值型数据库建模

键值型数据库是最简单的非关系型数据库，它以键值对的形式存储数据，类似哈希表。Redis是最流行的键值型数据库之一。

### 4.3.1 核心概念

- **键（Key）**：唯一标识符，通常是字符串
- **值（Value）**：与键关联的数据，可以是字符串、列表、集合、哈希等
- **过期时间（TTL）**：键的生存时间，过期后自动删除
- **数据结构**：支持多种数据结构，如字符串、列表、集合、有序集合、哈希等

### 4.3.2 数据建模原则

1. **键命名规范**：使用有意义的键名，如`user:123:name`
2. **数据结构选择**：根据业务需求选择合适的数据结构
3. **过期策略**：合理设置键的过期时间
4. **内存优化**：考虑数据压缩和内存使用效率
5. **分片策略**：对于大规模数据，考虑使用分片

### 4.3.3 Redis数据结构及应用场景

| 数据结构 | 特点 | 应用场景 |
|----------|------|----------|
| 字符串（String） | 简单的键值对 | 缓存、计数器、会话存储 |
| 列表（List） | 有序的字符串列表 | 消息队列、最近访问记录 |
| 集合（Set） | 无序的唯一字符串集合 | 标签、好友关系 |
| 有序集合（Sorted Set） | 带分数的有序集合 | 排行榜、优先级队列 |
| 哈希（Hash） | 字段和值的映射 | 对象存储、用户属性 |
| 位图（Bitmap） | 位操作 | 用户签到、状态标记 |
| 超日志（HyperLogLog） | 基数统计 | 独立访客统计 |
| 地理位置（Geo） | 地理位置数据 | 附近的人、位置搜索 |

### 4.3.4 Redis建模示例

#### 社交应用数据模型

```redis
# 用户信息（哈希）
HSET user:1001 name "John Doe" email "john.doe@example.com" age 30
HSET user:1002 name "Jane Smith" email "jane.smith@example.com" age 28

# 用户关注关系（集合）
SADD following:1001 1002 1003 1004
SADD followers:1002 1001 1005

# 用户帖子（列表）
LPUSH posts:1001 "Post content 1" "Post content 2"
LPUSH posts:1002 "Post content A" "Post content B"

# 帖子点赞（有序集合，按时间排序）
ZADD post:likes:2001 1621000000 1001 1621000100 1002

# 实时排行榜（有序集合，按分数排序）
ZADD leaderboard:weekly 1500 1001 1200 1002 900 1003

# 用户在线状态（字符串，带过期时间）
SET user:online:1001 "true" EX 3600
SET user:online:1002 "true" EX 3600

# 计数器（字符串，自增）
INCR page:views:home
INCR page:views:profile
```

## 4.4 列族型数据库建模

列族型数据库以列族为基本存储单位，适合处理大规模的结构化数据。HBase和Cassandra是常见的列族型数据库。

### 4.4.1 核心概念

- **行（Row）**：由行键唯一标识的一组数据
- **列族（Column Family）**：相关列的集合
- **列限定符（Column Qualifier）**：列族内的具体列
- **单元格（Cell）**：行键、列族、列限定符和时间戳唯一确定的一个值
- **时间戳（Timestamp）**：用于版本控制

### 4.4.2 数据建模原则

1. **行键设计**：行键是唯一的，应根据查询模式设计
2. **列族划分**：将经常一起访问的列放在同一个列族
3. **避免宽行**：单个行的数据不应过大
4. **时间戳管理**：合理设置版本数量
5. **数据压缩**：使用适当的压缩算法

### 4.4.3 Cassandra建模示例

#### 物联网数据模型

```cql
-- 创建键空间
CREATE KEYSPACE iot WITH replication = {
  'class': 'SimpleStrategy',
  'replication_factor': 3
};

-- 使用键空间
USE iot;

-- 创建传感器数据表
CREATE TABLE sensor_data (
  device_id UUID,
  sensor_type TEXT,
  timestamp TIMESTAMP,
  value DOUBLE,
  PRIMARY KEY ((device_id, sensor_type), timestamp)
) WITH CLUSTERING ORDER BY (timestamp DESC);

-- 创建设备信息表
CREATE TABLE device_info (
  device_id UUID PRIMARY KEY,
  device_name TEXT,
  location TEXT,
  status TEXT,
  last_seen TIMESTAMP
);

-- 插入数据
INSERT INTO device_info (device_id, device_name, location, status, last_seen)
VALUES (uuid(), 'Temperature Sensor 1', 'Building A, Floor 1', 'active', toTimestamp(now()));

INSERT INTO sensor_data (device_id, sensor_type, timestamp, value)
VALUES (device_id_value, 'temperature', toTimestamp(now()), 22.5);

-- 查询数据
SELECT * FROM sensor_data 
WHERE device_id = device_id_value AND sensor_type = 'temperature'
ORDER BY timestamp DESC LIMIT 10;
```

## 4.5 图形型数据库建模

图形型数据库以节点和边的形式存储数据，适合处理实体之间的复杂关系。Neo4j是最流行的图形型数据库之一。

### 4.5.1 核心概念

- **节点（Node）**：表示实体，如人、地点、事物
- **关系（Relationship）**：表示节点之间的连接，如朋友、工作、居住
- **属性（Property）**：节点或关系的属性，如姓名、年龄、日期
- **标签（Label）**：节点的分类，如Person、Company
- **方向（Direction）**：关系的方向，如A→B表示A指向B

### 4.5.2 数据建模原则

1. **实体识别**：识别业务中的主要实体
2. **关系定义**：定义实体之间的关系
3. **属性设计**：为节点和关系添加适当的属性
4. **索引策略**：为常用查询的属性创建索引
5. **查询优化**：避免深度过大的图遍历

### 4.5.3 Neo4j建模示例

#### 社交网络数据模型

```cypher
-- 创建节点
CREATE (john:Person {name: 'John Doe', age: 30, city: 'New York'})
CREATE (jane:Person {name: 'Jane Smith', age: 28, city: 'London'})
CREATE (bob:Person {name: 'Bob Johnson', age: 35, city: 'Paris'})
CREATE (alice:Person {name: 'Alice Williams', age: 25, city: 'New York'})

CREATE (neo4j:Company {name: 'Neo4j', industry: 'Software'})
CREATE (oracle:Company {name: 'Oracle', industry: 'Software'})

CREATE (graphdb:Technology {name: 'Graph Database', category: 'Database'})
CREATE (sql:Technology {name: 'SQL', category: 'Database'})

-- 创建关系
CREATE (john)-[:FRIENDS_WITH]->(jane)
CREATE (john)-[:FRIENDS_WITH]->(bob)
CREATE (jane)-[:FRIENDS_WITH]->(alice)
CREATE (bob)-[:FRIENDS_WITH]->(alice)

CREATE (john)-[:WORKS_AT {position: 'Developer', since: 2020}]->(neo4j)
CREATE (jane)-[:WORKS_AT {position: 'Manager', since: 2019}]->(oracle)
CREATE (bob)-[:WORKS_AT {position: 'Architect', since: 2018}]->(neo4j)

CREATE (john)-[:INTERESTED_IN]->(graphdb)
CREATE (jane)-[:INTERESTED_IN]->(sql)
CREATE (bob)-[:INTERESTED_IN]->(graphdb)
CREATE (alice)-[:INTERESTED_IN]->(graphdb)
CREATE (alice)-[:INTERESTED_IN]->(sql)

-- 查询示例
-- 查找John的所有朋友
MATCH (john:Person {name: 'John Doe'})-[:FRIENDS_WITH]->(friend)
RETURN friend.name, friend.city

-- 查找对图形数据库感兴趣的人及其工作公司
MATCH (person:Person)-[:INTERESTED_IN]->(:Technology {name: 'Graph Database'})-[:WORKS_AT]->(company)
RETURN person.name, company.name, company.industry

-- 查找John的朋友的朋友
MATCH (john:Person {name: 'John Doe'})-[:FRIENDS_WITH]->()-[:FRIENDS_WITH]->(friend_of_friend)
RETURN DISTINCT friend_of_friend.name
```

## 4.6 时间序列数据库建模

时间序列数据库专门用于存储和处理带有时间戳的数据，如监控数据、IoT数据、金融交易记录等。InfluxDB是流行的时间序列数据库之一。

### 4.6.1 核心概念

- **测量（Measurement）**：类似关系型数据库的表
- **标签（Tag）**：索引的键值对，用于过滤数据
- **字段（Field）**：存储实际测量值，非索引
- **时间戳（Timestamp）**：数据点的时间
- **数据点（Point）**：测量、标签、字段和时间戳的组合

### 4.6.2 数据建模原则

1. **标签设计**：将常用作过滤条件的字段设为标签
2. **字段选择**：将实际测量值设为字段
3. **测量命名**：使用有意义的测量名称
4. **数据保留策略**：根据业务需求设置数据保留时间
5. **数据降采样**：对历史数据进行降采样以节省存储空间

### 4.6.3 InfluxDB建模示例

#### 服务器监控数据模型

```influxql
-- 创建数据库
CREATE DATABASE monitoring;

-- 使用数据库
USE monitoring;

-- 插入数据点
INSERT INTO monitoring
measurement cpu,
host=server01,region=us-east,
usage_user=90.5,usage_system=5.7,usage_idle=3.8

INSERT INTO monitoring
measurement memory,
host=server01,region=us-east,
used=8500,free=1500,total=10000

INSERT INTO monitoring
measurement disk,
host=server01,region=us-east,device=/dev/sda1,
used=4000,free=1000,total=5000

-- 查询示例
-- 查询过去24小时内server01的CPU使用率
SELECT usage_user, usage_system FROM cpu WHERE host = 'server01' AND time > now() - 24h;

-- 查询所有服务器的内存使用情况
SELECT mean(used) FROM memory GROUP BY host;

-- 创建数据保留策略
CREATE RETENTION POLICY "30d" ON "monitoring" DURATION 30d REPLICATION 1 DEFAULT;

-- 创建连续查询（降采样）
CREATE CONTINUOUS QUERY "cpu_hourly" ON "monitoring"
BEGIN
  SELECT mean(usage_user) AS usage_user, mean(usage_system) AS usage_system
  INTO "30d".:MEASUREMENT
  FROM cpu
  GROUP BY time(1h), *
END;
```

## 4.7 非关系型数据建模最佳实践

### 4.7.1 通用最佳实践

1. **了解业务需求**：深入理解业务需求和查询模式
2. **选择合适的数据库类型**：根据数据特点和访问模式选择合适的非关系型数据库
3. **数据模型迭代**：随着业务发展不断优化数据模型
4. **数据一致性**：根据业务需求选择合适的一致性级别
5. **性能优化**：合理设计索引、分区和缓存策略
6. **数据备份与恢复**：定期备份数据，确保数据安全

### 4.7.2 文档型数据库最佳实践

- **避免文档过大**：单个文档大小不宜超过16MB（MongoDB限制）
- **合理使用索引**：为常用查询字段创建索引
- **考虑查询性能**：避免复杂的聚合查询
- **数据分片**：对大规模数据集进行分片

### 4.7.3 键值型数据库最佳实践

- **键命名规范**：使用统一的键命名格式
- **合理设置过期时间**：避免内存浪费
- **选择合适的数据结构**：根据业务需求选择数据结构
- **考虑数据持久化**：根据需要选择适当的持久化策略

### 4.7.4 列族型数据库最佳实践

- **行键设计**：行键应均匀分布，避免热点问题
- **列族划分**：将经常一起访问的列放在同一列族
- **避免宽行**：单个行的数据不应过大
- **批量操作**：使用批量操作提高性能

### 4.7.5 图形型数据库最佳实践

- **节点和关系设计**：保持节点和关系的简洁性
- **索引策略**：为常用查询的属性创建索引
- **避免深度遍历**：限制图遍历的深度
- **使用参数化查询**：提高查询性能和安全性

### 4.7.6 时间序列数据库最佳实践

- **标签设计**：将常用过滤条件设为标签
- **数据保留策略**：根据业务需求设置数据保留时间
- **数据降采样**：对历史数据进行降采样
- **批量写入**：使用批量写入提高性能

## 4.8 关系型与非关系型数据建模比较

| 特性 | 关系型数据库 | 非关系型数据库 |
|------|--------------|----------------|
| 数据模型 | 表格结构，固定模式 | 灵活结构（文档、键值、列族、图形等） |
| 扩展性 | 垂直扩展 | 水平扩展 |
| 一致性 | ACID | 通常为BASE（最终一致性） |
| 查询语言 | SQL | 各数据库有自己的查询语言 |
| 事务支持 | 完整的事务支持 | 有限的事务支持或不支持 |
| 数据完整性 | 强完整性约束 | 弱完整性约束或无约束 |
| 适用场景 | 结构化数据，复杂查询，强一致性要求 | 半结构化/非结构化数据，高并发，大数据量 |

## 4.9 混合数据建模策略

在实际应用中，常常需要结合使用关系型和非关系型数据库，这称为混合数据建模策略。

### 4.9.1 混合建模的优势

- **充分利用各自优势**：关系型数据库用于结构化数据和复杂查询，非关系型数据库用于灵活数据和高并发访问
- **优化性能**：将不同类型的数据存储在最适合的数据库中
- **提高扩展性**：通过非关系型数据库实现水平扩展

### 4.9.2 混合建模示例

1. **电商系统**：
   - 关系型数据库：存储用户账户、订单、支付等核心交易数据
   - MongoDB：存储产品目录、用户评论等半结构化数据
   - Redis：缓存热门产品、会话管理
   - Elasticsearch：实现产品搜索功能

2. **社交网络**：
   - 关系型数据库：存储用户基本信息
   - Neo4j：存储用户关系、社交图谱
   - Redis：实时消息、在线状态
   - Cassandra：存储用户活动日志

## 4.10 总结

非关系型数据建模是现代数据架构中的重要组成部分，它为处理大规模、高并发、灵活结构的数据提供了有效的解决方案。

不同类型的非关系型数据库（文档型、键值型、列族型、图形型、时间序列）各有特点和适用场景，需要根据业务需求选择合适的数据库类型。

在进行非关系型数据建模时，需要遵循相应的设计原则和最佳实践，如面向应用设计、嵌入与引用平衡、合理的索引策略等。

在实际应用中，常常需要结合使用关系型和非关系型数据库，以充分利用各自的优势，构建高性能、可扩展的数据架构。

在下一章中，我们将探讨数据仓库建模的概念和实践。