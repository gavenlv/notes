# 前端开发核心知识体系

## 1. HTML5 核心知识

### 语义化标签及其应用场景
语义化标签是指能够清晰描述其自身目的和内容的HTML标签，有助于提高代码可读性、SEO优化和无障碍访问。
- `<header>`: 页面或区域的头部，通常包含导航、标题等
- `<nav>`: 导航链接区域
- `<main>`: 页面的主要内容区域
- `<section>`: 文档中的主题分组
- `<article>`: 独立的、完整的内容块（如博客文章、评论）
- `<footer>`: 页面或区域的底部，通常包含版权信息、联系方式等

**应用场景示例**:
```html
<header>
  <h1>网站标题</h1>
  <nav>
    <ul>
      <li><a href="#home">首页</a></li>
      <li><a href="#about">关于我们</a></li>
    </ul>
  </nav>
</header>
<main>
  <section>
    <h2>新闻资讯</h2>
    <article>
      <h3>最新技术动态</h3>
      <p>...</p>
    </article>
  </section>
</main>
<footer>
  <p>© 2023 网站名称. 保留所有权利.</p>
</footer>
```

### HTML5 新特性
- **Canvas**: 用于绘制图形、动画、游戏等，通过JavaScript进行控制
- **SVG**: 矢量图形格式，适用于图标、图表等需要缩放不失真的场景
- **Web Storage**: 本地存储解决方案，包括localStorage（持久化存储）和sessionStorage（会话级存储）
- **Web Workers**: 允许在后台线程中运行JavaScript代码，避免阻塞主线程
- **Geolocation**: 提供地理位置信息API，可用于基于位置的服务

### 表单增强
- **新输入类型**: `email`, `tel`, `url`, `number`, `range`, `date`等，提供更好的输入体验和验证
- **表单验证**: HTML5内置验证（如`required`, `pattern`, `min`, `max`等属性）和约束验证API
- **表单API**: `FormData`, `autocomplete`等功能，增强表单处理能力

### 无障碍访问
- **ARIA属性**: 用于增强无障碍性，如`aria-label`, `aria-hidden`, `aria-expanded`等
- **键盘导航**: 确保所有交互元素可通过键盘访问
- **屏幕阅读器兼容性**: 遵循WCAG标准，确保内容对辅助技术友好

### HTML5 安全特性
- **内容安全策略(CSP)**: 防止XSS攻击，通过HTTP头部或meta标签配置
- **XSS防护**: 使用`textContent`代替`innerHTML`，对用户输入进行转义和验证

## 2. CSS3 核心知识

### 盒模型
- **标准盒模型**: 元素宽度 = content宽度 + padding + border
- **IE盒模型**: 元素宽度 = width（包含content、padding和border）
- 通过`box-sizing`属性控制: `content-box`(标准)和`border-box`(IE)

### 选择器优先级与权重计算
- 优先级从高到低: !important > 内联样式 > ID选择器 > 类选择器/属性选择器/伪类 > 元素选择器/伪元素
- 权重计算: 内联样式(1000) > ID选择器(100) > 类/属性/伪类(10) > 元素/伪元素(1)
- 当权重相同时，后定义的样式会覆盖先定义的样式

### 布局技术
- **Flexbox**: 一维布局模型，适用于行或列的布局
- **Grid**: 二维布局模型，同时控制行和列
- **Positioning**: 包括static, relative, absolute, fixed, sticky等定位方式
- **Float**: 早期布局技术，现在主要用于文字环绕图片等场景

### 响应式设计
- **媒体查询**: 使用`@media`规则根据设备特性应用不同样式
- **视口单位**: `vw`, `vh`, `vmin`, `vmax`等，相对于视口大小
- **响应式图像**: 使用`srcset`和`sizes`属性提供不同分辨率的图像

### CSS 预处理器
- **Sass/SCSS**: 支持变量、嵌套、混合、继承等特性
- **Less**: 类似Sass，但使用JavaScript实现
- **最佳实践**: 合理组织代码结构，使用变量管理颜色和尺寸，避免过度嵌套

### CSS 动画与过渡
- **transform**: 用于元素的平移、旋转、缩放和倾斜
- **transition**: 用于定义元素状态变化的过渡效果
- **animation**: 用于创建复杂的动画效果，支持关键帧

### CSS 架构
- **BEM**: 块(Block)、元素(Element)、修饰符(Modifier)的命名规范
- **OOCSS**: 面向对象的CSS，强调分离结构和样式
- **ITCSS**: 倒三角形CSS，按特定顺序组织样式
- **SMACSS**: 可扩展和模块化的CSS架构

### CSS 性能优化技巧
- 减少选择器复杂性
- 避免使用昂贵的属性（如`box-shadow`, `border-radius`）
- 使用CSS变量代替重复值
- 利用GPU加速（transform和opacity）

## 3. JavaScript 核心知识

### 变量作用域与闭包
- **作用域**: 变量可访问的范围，包括全局作用域、函数作用域和块级作用域（ES6+）
- **闭包**: 函数可以访问其词法作用域之外的变量，即使函数在其定义作用域之外执行
- **应用场景**: 模块化、私有变量、函数柯里化

### 原型链与继承机制
- **原型链**: JavaScript对象通过`__proto__`属性连接形成的链状结构
- **继承**: 通过原型链实现，ES6引入`class`语法糖，但本质仍是基于原型
- **实现方式**: 原型链继承、构造函数继承、组合继承、寄生组合继承

### 异步编程
- **回调函数**: 早期异步编程方式，容易导致回调地狱
- **Promise**: 解决回调地狱问题，提供链式调用
- **async/await**: Promise的语法糖，使异步代码更接近同步代码的写法

### 事件循环机制
- **调用栈**: 执行同步代码
- **微任务队列**: 处理Promise、queueMicrotask等
- **宏任务队列**: 处理setTimeout、setInterval、I/O等
- **执行顺序**: 先清空调用栈，再执行所有微任务，然后执行一个宏任务，如此循环

### 数据类型与类型转换
- **基本类型**: number, string, boolean, null, undefined, symbol, bigint
- **引用类型**: object, array, function等
- **类型转换**: 隐式转换（如`1 + '2'`）和显式转换（如`Number('123')`）

### 函数式编程概念
- **纯函数**: 相同输入总是产生相同输出，无副作用
- **高阶函数**: 接受函数作为参数或返回函数的函数
- **函数组合**: 将多个函数组合成一个函数
- **柯里化**: 将接受多个参数的函数转换为接受单一参数的函数序列

### 正则表达式
- **元字符**: `.`, `*`, `+`, `?`, `^`, `$`, `[]`, `()`等
- **修饰符**: `g`(全局匹配), `i`(忽略大小写), `m`(多行匹配)
- **常用方法**: `test()`, `exec()`, `match()`, `replace()`

### Error 处理机制
- **内置错误类型**: Error, SyntaxError, ReferenceError, TypeError等
- **异常捕获**: try-catch-finally语句
- **自定义错误**: 继承Error类创建自定义错误类型
- **错误传递**: 在异步代码中正确传递和处理错误

## 4. 前端工程化

### 构建工具
- **Webpack**: 模块化打包工具，支持代码分割、按需加载
- **Vite**: 基于ESM的构建工具，开发环境启动速度快
- **Rollup**: 专注于JavaScript库打包的工具

### 包管理器
- **npm**: Node.js默认包管理器
- **yarn**: 由Facebook开发的包管理器，速度更快
- **pnpm**: 采用内容寻址存储，节省磁盘空间

### 模块化开发
- **CommonJS**: Node.js的模块化规范，使用`require`和`module.exports`
- **ES Modules**: ES6引入的模块化规范，使用`import`和`export`
- **模块解析**: 确定模块依赖关系的过程

### 代码规范与格式化
- **ESLint**: 静态代码分析工具，检查代码错误和风格问题
- **Prettier**: 代码格式化工具，保持一致的代码风格
- **配置方式**: 项目级配置、共享配置、编辑器集成

### 版本控制
- **Git**: 分布式版本控制系统
- **高级技巧**: 分支管理、变基、 cherry-pick、rebase等
- **工作流**: Git Flow, GitHub Flow, GitLab Flow等

### CI/CD 流程与自动化部署
- **CI(持续集成)**: 频繁将代码集成到主分支，通过自动化测试
- **CD(持续部署/交付)**: 自动将通过测试的代码部署到生产环境
- **工具**: GitHub Actions, Jenkins, GitLab CI等

## 5. 前端框架与库

### 主流框架的核心原理与对比
- **React**: 基于组件化和虚拟DOM，使用单向数据流
- **Vue**: 渐进式框架，易于上手，提供响应式数据绑定
- **Angular**: 完整的MVC框架，提供依赖注入、模块化等特性
- **对比**: 性能、学习曲线、生态系统、适用场景

### 状态管理
- **Redux**: 基于Flux架构，使用单一状态树和不可变数据
- **Vuex/Pinia**: Vue的状态管理库，提供集中式状态管理
- **状态管理模式**: 全局状态vs局部状态，服务器状态vs客户端状态

### 路由管理
- **React Router**: React的路由库，支持声明式路由
- **Vue Router**: Vue的官方路由库，与Vue深度集成
- **路由模式**: 哈希模式(Hash)和历史模式(History)
- **路由守卫**: 导航前后的钩子函数，用于权限控制等

### UI组件库
- **Ant Design**: 企业级UI设计系统，组件丰富
- **Element UI/Plus**: 基于Vue的UI组件库
- **Material UI**: 基于Material Design的React组件库
- **选择考量**: 设计风格、性能、维护性、社区支持

### 服务端渲染
- **Next.js**: React的服务端渲染框架，支持静态生成和增量静态生成
- **Nuxt.js**: Vue的服务端渲染框架
- **优势**: 改善SEO，提高首屏加载速度
- **挑战**: 服务端与客户端代码兼容，数据获取策略

## 6. 性能优化

### 网页加载性能优化
- **资源压缩**: 压缩HTML, CSS, JavaScript, 图片等
- **懒加载**: 延迟加载非关键资源，如图片、视频
- **CDN**: 使用内容分发网络，减少网络延迟
- **资源预加载**: 使用`preload`, `prefetch`等提示浏览器预加载资源

### 运行时性能优化
- **DOM操作优化**: 减少DOM操作次数，使用文档碎片
- **事件委托**: 将事件监听器添加到父元素，利用事件冒泡
- **防抖与节流**: 优化频繁触发的事件处理函数
- **内存管理**: 避免内存泄漏，及时清理事件监听器

### 渲染性能优化
- **重排与重绘**: 减少DOM树的重排和重绘
- **CSS优化**: 避免使用昂贵的CSS选择器，减少CSS规则数量
- **Web Workers**: 将计算密集型任务移至后台线程
- **虚拟列表**: 用于渲染大量数据的高效技术

### 性能监控与分析工具
- **Lighthouse**: Google开发的网页性能分析工具
- **Chrome DevTools**: 包含性能面板、网络面板等调试工具
- **Web Vitals**: Google提出的用户体验核心指标
- **性能预算**: 设定性能指标阈值，确保网站性能达标

## 7. 浏览器原理

### 浏览器渲染流程
- **解析HTML**: 生成DOM树
- **解析CSS**: 生成CSSOM树
- **构建渲染树**: 结合DOM和CSSOM
- **布局**: 计算元素位置和大小
- **绘制**: 将渲染树绘制到屏幕上
- **合成**: 将绘制的图层合成为最终图像

### 浏览器安全机制
- **同源策略**: 限制不同源之间的交互
- **CORS**: 跨域资源共享，允许不同源之间的安全通信
- **XSS防护**: 浏览器内置的XSS过滤机制
- **安全头部**: 如X-XSS-Protection, X-Frame-Options等

### 存储机制
- **Cookie**: 小型文本文件，用于存储会话信息，受域限制
- **LocalStorage**: 持久化存储，容量约5MB
- **SessionStorage**: 会话级存储，关闭标签页后清除
- **IndexedDB**: 浏览器端数据库，适用于存储大量结构化数据

### 缓存机制
- **强缓存**: 基于Expires或Cache-Control头部，无需请求服务器
- **协商缓存**: 基于Last-Modified/If-Modified-Since或ETag/If-None-Match，需要服务器确认
- **缓存策略**: 合理设置缓存过期时间，使用版本控制

## 8. 网络基础

### HTTP/HTTPS 协议详解
- **HTTP**: 超文本传输协议，无状态，基于请求-响应模式
- **HTTPS**: HTTP + SSL/TLS，提供加密传输
- **HTTP方法**: GET, POST, PUT, DELETE, PATCH等
- **HTTP状态码**: 1xx(信息), 2xx(成功), 3xx(重定向), 4xx(客户端错误), 5xx(服务器错误)
- **HTTP/2**: 二进制传输、多路复用、服务器推送等特性
- **HTTP/3**: 基于QUIC协议，进一步优化性能

### RESTful API 设计原则
- **资源导向**: 使用URL表示资源
- **HTTP方法语义**: 使用合适的HTTP方法表示操作
- **状态无关**: 服务器不保存客户端状态
- **响应格式**: 通常使用JSON
- **版本控制**: 如/api/v1/resources

### WebSocket 原理与应用
- **全双工通信**: 允许客户端和服务器双向通信
- **握手过程**: 通过HTTP请求升级为WebSocket连接
- **应用场景**: 实时聊天、实时数据更新、多人游戏等
- **优势**: 减少HTTP请求开销，低延迟

### 跨域解决方案
- **CORS**: 服务器设置Access-Control-Allow-*头部
- **JSONP**: 利用script标签不受同源策略限制的特性
- **代理服务器**: 开发环境使用代理，生产环境使用反向代理
- **PostMessage**: 跨窗口通信API
- **Websocket**: 不受同源策略限制

## 9. 前端安全

### XSS (跨站脚本攻击) 防护
- **类型**: 反射型、存储型、DOM型
- **防护措施**: 输入验证、输出转义、使用CSP、避免使用eval和innerHTML
- **React/Vue安全措施**: React的JSX自动转义，Vue的v-text和v-html区别

### CSRF (跨站请求伪造) 防护
- **原理**: 利用用户已认证的身份执行未授权操作
- **防护措施**: CSRF Token、SameSite Cookie、双重提交防护、Origin/Referer检查

### 点击劫持防护
- **原理**: 欺骗用户点击看似正常的元素，实际点击的是隐藏的恶意元素
- **防护措施**: X-Frame-Options头部、frame-busting代码、Content-Security-Policy

### 数据加密与传输安全
- **HTTPS**: 确保传输过程加密
- **密码存储**: 使用bcrypt、Argon2等算法加密存储密码
- **敏感数据处理**: 避免在客户端存储敏感数据，如密码、API密钥
- **安全通信**: 使用加密算法保护客户端与服务器之间的通信

## 10. 设计模式

### 创建型模式
- **工厂模式**: 封装对象创建逻辑，提供统一的创建接口
- **单例模式**: 确保类只有一个实例，并提供全局访问点
- **构建器模式**: 分步创建复杂对象，分离对象的构建和表示

### 结构型模式
- **适配器模式**: 将一个类的接口转换成客户端期望的另一个接口
- **装饰器模式**: 动态地给对象添加额外的职责
- **代理模式**: 控制对原始对象的访问，添加额外功能

### 行为型模式
- **观察者模式**: 定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖它的对象都会收到通知
- **发布-订阅模式**: 观察者模式的变体，通过事件通道实现解耦
- **策略模式**: 定义一系列算法，将它们封装起来，并使它们可以互相替换

### 前端常用设计模式应用场景
- **单例模式**: 应用于全局状态管理、模态框等
- **观察者模式/发布-订阅模式**: 应用于事件系统、状态管理
- **策略模式**: 应用于表单验证、动画效果切换
- **装饰器模式**: 应用于组件增强、日志记录