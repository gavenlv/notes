# 9.6 Cucumber高级主题

## 引言

在掌握了Cucumber的基础知识和最佳实践后，本章将探讨一些高级主题，这些主题将帮助您更深入地利用Cucumber的强大功能，解决复杂场景下的测试挑战，并构建更加健壮和可维护的测试框架。我们将讨论高级测试模式、性能优化、大规模测试管理以及Cucumber在不同领域的创新应用。

## 高级测试模式

### 1. 测试数据工厂模式

#### 工厂模式实现

测试数据工厂模式提供了一种创建和管理测试数据的结构化方法，使测试数据更加可控、可维护和可复用。

```java
// 基础工厂接口
public interface TestDataFactory<T> {
    T create();
    T createWithDefaults();
    T createWithCustomizations(Consumer<T> customizer);
    List<T> createMultiple(int count);
    List<T> createMultipleWithCustomizations(int count, Consumer<T> customizer);
}

// 用户数据工厂实现
public class UserDataFactory implements TestDataFactory<User> {
    
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    
    public UserDataFactory(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }
    
    @Override
    public User create() {
        return createWithCustomizations(user -> {});
    }
    
    @Override
    public User createWithDefaults() {
        return User.builder()
            .username("default_user")
            .email("default@example.com")
            .password(passwordEncoder.encode("password123"))
            .firstName("Default")
            .lastName("User")
            .status(UserStatus.ACTIVE)
            .role(UserRole.USER)
            .build();
    }
    
    @Override
    public User createWithCustomizations(Consumer<User> customizer) {
        User user = User.builder()
            .username(generateUniqueUsername())
            .email(generateUniqueEmail())
            .password(passwordEncoder.encode("password123"))
            .firstName("Test")
            .lastName("User")
            .status(UserStatus.ACTIVE)
            .role(UserRole.USER)
            .build();
            
        customizer.accept(user);
        return userRepository.save(user);
    }
    
    @Override
    public List<User> createMultiple(int count) {
        return createMultipleWithCustomizations(count, user -> {});
    }
    
    @Override
    public List<User> createMultipleWithCustomizations(int count, Consumer<User> customizer) {
        List<User> users = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            User user = User.builder()
                .username(generateUniqueUsername())
                .email(generateUniqueEmail())
                .password(passwordEncoder.encode("password123"))
                .firstName("Test")
                .lastName("User" + i)
                .status(UserStatus.ACTIVE)
                .role(UserRole.USER)
                .build();
                
            customizer.accept(user);
            users.add(userRepository.save(user));
        }
        return users;
    }
    
    private String generateUniqueUsername() {
        return "test_user_" + System.currentTimeMillis();
    }
    
    private String generateUniqueEmail() {
        return "test_" + System.currentTimeMillis() + "@example.com";
    }
    
    // 预定义的工厂方法
    public User createAdminUser() {
        return createWithCustomizations(user -> {
            user.setRole(UserRole.ADMIN);
            user.setUsername("admin_" + System.currentTimeMillis());
        });
    }
    
    public User createInactiveUser() {
        return createWithCustomizations(user -> {
            user.setStatus(UserStatus.INACTIVE);
            user.setUsername("inactive_" + System.currentTimeMillis());
        });
    }
    
    public User createLockedUser() {
        return createWithCustomizations(user -> {
            user.setStatus(UserStatus.LOCKED);
            user.setUsername("locked_" + System.currentTimeMillis());
        });
    }
}
```

#### 复杂对象构建

对于复杂对象，可以使用Builder模式结合工厂方法：

```java
// 复杂订单对象构建器
public class OrderBuilder {
    private String orderNumber;
    private User customer;
    private List<OrderItem> items = new ArrayList<>();
    private BigDecimal totalAmount = BigDecimal.ZERO;
    private OrderStatus status = OrderStatus.PENDING;
    private LocalDateTime orderDate;
    private ShippingAddress shippingAddress;
    private PaymentMethod paymentMethod;
    
    public OrderBuilder withOrderNumber(String orderNumber) {
        this.orderNumber = orderNumber;
        return this;
    }
    
    public OrderBuilder withCustomer(User customer) {
        this.customer = customer;
        return this;
    }
    
    public OrderBuilder withItems(List<OrderItem> items) {
        this.items = new ArrayList<>(items);
        this.totalAmount = calculateTotalAmount(items);
        return this;
    }
    
    public OrderBuilder addItem(OrderItem item) {
        this.items.add(item);
        this.totalAmount = this.totalAmount.add(item.getTotalPrice());
        return this;
    }
    
    public OrderBuilder withStatus(OrderStatus status) {
        this.status = status;
        return this;
    }
    
    public OrderBuilder withShippingAddress(ShippingAddress address) {
        this.shippingAddress = address;
        return this;
    }
    
    public OrderBuilder withPaymentMethod(PaymentMethod paymentMethod) {
        this.paymentMethod = paymentMethod;
        return this;
    }
    
    public OrderBuilder withOrderDate(LocalDateTime orderDate) {
        this.orderDate = orderDate;
        return this;
    }
    
    public Order build() {
        validateOrder();
        
        if (orderDate == null) {
            orderDate = LocalDateTime.now();
        }
        
        return new Order(orderNumber, customer, items, totalAmount, status, 
                         orderDate, shippingAddress, paymentMethod);
    }
    
    private void validateOrder() {
        if (orderNumber == null || orderNumber.isEmpty()) {
            throw new IllegalStateException("Order number is required");
        }
        
        if (customer == null) {
            throw new IllegalStateException("Customer is required");
        }
        
        if (items.isEmpty()) {
            throw new IllegalStateException("Order must have at least one item");
        }
    }
    
    private BigDecimal calculateTotalAmount(List<OrderItem> items) {
        return items.stream()
            .map(OrderItem::getTotalPrice)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
    
    // 静态工厂方法
    public static OrderBuilder anOrder() {
        return new OrderBuilder();
    }
    
    public static OrderBuilder aCompletedOrder() {
        return new OrderBuilder()
            .withStatus(OrderStatus.COMPLETED)
            .withOrderDate(LocalDateTime.now().minusDays(1));
    }
    
    public static OrderBuilder aPendingOrder() {
        return new OrderBuilder()
            .withStatus(OrderStatus.PENDING)
            .withOrderDate(LocalDateTime.now());
    }
}

// 订单数据工厂
public class OrderDataFactory implements TestDataFactory<Order> {
    
    private final OrderRepository orderRepository;
    private final UserDataFactory userDataFactory;
    private final ProductDataFactory productDataFactory;
    
    public OrderDataFactory(OrderRepository orderRepository, 
                           UserDataFactory userDataFactory,
                           ProductDataFactory productDataFactory) {
        this.orderRepository = orderRepository;
        this.userDataFactory = userDataFactory;
        this.productDataFactory = productDataFactory;
    }
    
    @Override
    public Order create() {
        return createWithCustomizations(order -> {});
    }
    
    @Override
    public Order createWithDefaults() {
        User customer = userDataFactory.create();
        Product product = productDataFactory.create();
        
        OrderItem item = new OrderItem(product, 1, product.getPrice());
        
        return OrderBuilder.anOrder()
            .withOrderNumber(generateOrderNumber())
            .withCustomer(customer)
            .addItem(item)
            .withShippingAddress(createDefaultShippingAddress(customer))
            .withPaymentMethod(PaymentMethod.CREDIT_CARD)
            .build();
    }
    
    @Override
    public Order createWithCustomizations(Consumer<Order> customizer) {
        Order order = createWithDefaults();
        customizer.accept(order);
        return orderRepository.save(order);
    }
    
    @Override
    public List<Order> createMultiple(int count) {
        return createMultipleWithCustomizations(count, order -> {});
    }
    
    @Override
    public List<Order> createMultipleWithCustomizations(int count, Consumer<Order> customizer) {
        List<Order> orders = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            Order order = createWithDefaults();
            customizer.accept(order);
            orders.add(orderRepository.save(order));
        }
        return orders;
    }
    
    // 预定义的工厂方法
    public Order createCompletedOrder() {
        return createWithCustomizations(order -> {
            order.setStatus(OrderStatus.COMPLETED);
            order.setOrderDate(LocalDateTime.now().minusDays(1));
        });
    }
    
    public Order createCancelledOrder() {
        return createWithCustomizations(order -> {
            order.setStatus(OrderStatus.CANCELLED);
            order.setOrderDate(LocalDateTime.now().minusDays(2));
        });
    }
    
    public Order createOrderWithMultipleItems(int itemCount) {
        User customer = userDataFactory.create();
        List<Product> products = productDataFactory.createMultiple(itemCount);
        
        OrderBuilder builder = OrderBuilder.anOrder()
            .withOrderNumber(generateOrderNumber())
            .withCustomer(customer)
            .withShippingAddress(createDefaultShippingAddress(customer))
            .withPaymentMethod(PaymentMethod.CREDIT_CARD);
            
        for (Product product : products) {
            builder.addItem(new OrderItem(product, 1, product.getPrice()));
        }
        
        return orderRepository.save(builder.build());
    }
    
    private String generateOrderNumber() {
        return "ORD-" + System.currentTimeMillis();
    }
    
    private ShippingAddress createDefaultShippingAddress(User user) {
        return new ShippingAddress(
            "123 Main St",
            "Anytown",
            "CA",
            "12345",
            "USA"
        );
    }
}
```

### 2. 页面对象模式增强

#### 高级页面对象

增强的页面对象模式提供更强大的UI交互抽象和更灵活的元素定位策略：

```java
// 基础页面对象
public abstract class BasePage {
    protected final WebDriver driver;
    protected final WebDriverWait wait;
    protected final JavascriptExecutor jsExecutor;
    
    public BasePage(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        this.jsExecutor = (JavascriptExecutor) driver;
        PageFactory.initElements(driver, this);
    }
    
    // 等待元素可见
    protected WebElement waitForVisibility(By locator) {
        return wait.until(ExpectedConditions.visibilityOfElementLocated(locator));
    }
    
    // 等待元素可点击
    protected WebElement waitForClickability(By locator) {
        return wait.until(ExpectedConditions.elementToBeClickable(locator));
    }
    
    // 等待元素存在
    protected WebElement waitForPresence(By locator) {
        return wait.until(ExpectedConditions.presenceOfElementLocated(locator));
    }
    
    // 等待元素消失
    protected boolean waitForInvisibility(By locator) {
        return wait.until(ExpectedConditions.invisibilityOfElementLocated(locator));
    }
    
    // 滚动到元素
    protected void scrollToElement(WebElement element) {
        jsExecutor.executeScript("arguments[0].scrollIntoView(true);", element);
    }
    
    // 滚动到页面顶部
    protected void scrollToTop() {
        jsExecutor.executeScript("window.scrollTo(0, 0);");
    }
    
    // 滚动到页面底部
    protected void scrollToBottom() {
        jsExecutor.executeScript("window.scrollTo(0, document.body.scrollHeight);");
    }
    
    // 检查元素是否存在
    protected boolean isElementPresent(By locator) {
        try {
            driver.findElement(locator);
            return true;
        } catch (NoSuchElementException e) {
            return false;
        }
    }
    
    // 检查元素是否可见
    protected boolean isElementVisible(By locator) {
        try {
            return driver.findElement(locator).isDisplayed();
        } catch (NoSuchElementException e) {
            return false;
        }
    }
    
    // 等待页面加载完成
    public void waitForPageLoad() {
        wait.until(webDriver -> 
            jsExecutor.executeScript("return document.readyState").equals("complete"));
    }
    
    // 获取当前页面URL
    public String getCurrentUrl() {
        return driver.getCurrentUrl();
    }
    
    // 刷新页面
    public void refresh() {
        driver.navigate().refresh();
    }
    
    // 抽象方法，子类必须实现
    public abstract boolean isAt();
}

// 高级页面对象
public class AdvancedBasePage extends BasePage {
    protected final Actions actions;
    protected final TestContext testContext;
    
    public AdvancedBasePage(WebDriver driver, TestContext testContext) {
        super(driver);
        this.testContext = testContext;
        this.actions = new Actions(driver);
    }
    
    // 鼠标悬停
    protected void hoverOver(WebElement element) {
        actions.moveToElement(element).perform();
    }
    
    // 双击元素
    protected void doubleClick(WebElement element) {
        actions.doubleClick(element).perform();
    }
    
    // 右键点击元素
    protected void rightClick(WebElement element) {
        actions.contextClick(element).perform();
    }
    
    // 拖拽元素
    protected void dragAndDrop(WebElement source, WebElement target) {
        actions.dragAndDrop(source, target).perform();
    }
    
    // 按键操作
    protected void pressKey(Keys key) {
        actions.sendKeys(key).perform();
    }
    
    // 组合按键操作
    protected void pressKeys(Keys... keys) {
        actions.sendKeys(keys).perform();
    }
    
    // 等待元素属性值
    protected boolean waitForAttributeValue(By locator, String attribute, String value) {
        return wait.until(webDriver -> {
            WebElement element = webDriver.findElement(locator);
            return value.equals(element.getAttribute(attribute));
        });
    }
    
    // 等待元素文本包含
    protected boolean waitForTextContains(By locator, String text) {
        return wait.until(webDriver -> {
            WebElement element = webDriver.findElement(locator);
            return element.getText().contains(text);
        });
    }
    
    // 等待元素文本等于
    protected boolean waitForTextEquals(By locator, String text) {
        return wait.until(webDriver -> {
            WebElement element = webDriver.findElement(locator);
            return text.equals(element.getText());
        });
    }
    
    // 切换到iframe
    protected void switchToIframe(By iframeLocator) {
        WebElement iframe = waitForVisibility(iframeLocator);
        driver.switchTo().frame(iframe);
    }
    
    // 切换回主文档
    protected void switchToDefaultContent() {
        driver.switchTo().defaultContent();
    }
    
    // 切换到新窗口
    protected void switchToNewWindow() {
        String originalWindow = driver.getWindowHandle();
        wait.until(numberOfWindowsToBe(2));
        
        for (String windowHandle : driver.getWindowHandles()) {
            if (!originalWindow.contentEquals(windowHandle)) {
                driver.switchTo().window(windowHandle);
                break;
            }
        }
    }
    
    // 关闭当前窗口并切换回原窗口
    protected void closeCurrentWindowAndSwitchBack() {
        String originalWindow = driver.getWindowHandle();
        driver.close();
        driver.switchTo().window(originalWindow);
    }
    
    // 等待窗口数量
    protected ExpectedCondition<Boolean> numberOfWindowsToBe(int numberOfWindows) {
        return driver -> driver.getWindowHandles().size() == numberOfWindows;
    }
    
    // 截取屏幕截图
    public byte[] takeScreenshot() {
        return ((TakesScreenshot) driver).getScreenshotAs(OutputType.BYTES);
    }
    
    // 高亮元素（用于调试）
    protected void highlightElement(WebElement element) {
        String originalStyle = element.getAttribute("style");
        jsExecutor.executeScript(
            "arguments[0].setAttribute('style', arguments[1]);", 
            element, "border: 2px solid red; background-color: yellow;"
        );
        
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        jsExecutor.executeScript(
            "arguments[0].setAttribute('style', arguments[1]);", 
            element, originalStyle
        );
    }
}

// 登录页面的高级实现
public class AdvancedLoginPage extends AdvancedBasePage {
    
    // 页面元素
    @FindBy(id = "username")
    private WebElement usernameField;
    
    @FindBy(id = "password")
    private WebElement passwordField;
    
    @FindBy(id = "login-button")
    private WebElement loginButton;
    
    @FindBy(id = "error-message")
    private WebElement errorMessage;
    
    @FindBy(id = "forgot-password-link")
    private WebElement forgotPasswordLink;
    
    @FindBy(id = "remember-me-checkbox")
    private WebElement rememberMeCheckbox;
    
    @FindBy(id = "login-form")
    private WebElement loginForm;
    
    // 页面URL
    private static final String PAGE_URL = "/login";
    
    public AdvancedLoginPage(WebDriver driver, TestContext testContext) {
        super(driver, testContext);
    }
    
    // 导航到登录页面
    public void navigateTo() {
        driver.get(getBaseUrl() + PAGE_URL);
        waitForPageLoad();
    }
    
    // 输入用户名
    public void enterUsername(String username) {
        waitForVisibility(By.id("username")).clear();
        usernameField.sendKeys(username);
        testContext.setLastEnteredUsername(username);
    }
    
    // 输入密码
    public void enterPassword(String password) {
        waitForVisibility(By.id("password")).clear();
        passwordField.sendKeys(password);
    }
    
    // 点击登录按钮
    public void clickLoginButton() {
        waitForClickability(By.id("login-button")).click();
    }
    
    // 登录操作
    public DashboardPage login(String username, String password) {
        enterUsername(username);
        enterPassword(password);
        clickLoginButton();
        return new DashboardPage(driver, testContext);
    }
    
    // 点击忘记密码链接
    public ForgotPasswordPage clickForgotPasswordLink() {
        waitForClickability(By.id("forgot-password-link")).click();
        return new ForgotPasswordPage(driver, testContext);
    }
    
    // 切换记住我复选框
    public void toggleRememberMe() {
        waitForClickability(By.id("remember-me-checkbox")).click();
    }
    
    // 获取错误消息
    public String getErrorMessage() {
        return waitForVisibility(By.id("error-message")).getText();
    }
    
    // 检查错误消息是否显示
    public boolean isErrorMessageDisplayed() {
        return isElementVisible(By.id("error-message"));
    }
    
    // 检查登录按钮是否可用
    public boolean isLoginButtonEnabled() {
        return waitForVisibility(By.id("login-button")).isEnabled();
    }
    
    // 使用键盘操作登录
    public DashboardPage loginWithKeyboard(String username, String password) {
        enterUsername(username);
        pressKey(Keys.TAB); // 切换到密码字段
        enterPassword(password);
        pressKey(Keys.ENTER); // 按回车键登录
        return new DashboardPage(driver, testContext);
    }
    
    // 验证登录表单是否可见
    public boolean isLoginFormVisible() {
        return isElementVisible(By.id("login-form"));
    }
    
    // 验证页面标题
    public boolean hasCorrectTitle() {
        return driver.getTitle().equals("Login - My Application");
    }
    
    // 验证页面URL
    public boolean hasCorrectUrl() {
        return driver.getCurrentUrl().contains(PAGE_URL);
    }
    
    // 实现基类的抽象方法
    @Override
    public boolean isAt() {
        return isLoginFormVisible() && hasCorrectTitle() && hasCorrectUrl();
    }
    
    // 获取基础URL
    private String getBaseUrl() {
        return testContext.getBaseUrl();
    }
}
```

### 3. 测试上下文管理

#### 测试上下文实现

测试上下文提供了一种在测试步骤之间共享数据和状态的结构化方式：

```java
// 测试上下文接口
public interface TestContext {
    void set(String key, Object value);
    <T> T get(String key, Class<T> type);
    <T> T get(String key, Class<T> type, T defaultValue);
    boolean contains(String key);
    void remove(String key);
    void clear();
    Map<String, Object> getAll();
}

// 基础测试上下文实现
public class BasicTestContext implements TestContext {
    
    private final Map<String, Object> data = new ConcurrentHashMap<>();
    
    @Override
    public void set(String key, Object value) {
        data.put(key, value);
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public <T> T get(String key, Class<T> type) {
        Object value = data.get(key);
        if (value == null) {
            return null;
        }
        
        if (!type.isInstance(value)) {
            throw new ClassCastException("Value for key '" + key + "' is not of type " + type.getName());
        }
        
        return (T) value;
    }
    
    @Override
    public <T> T get(String key, Class<T> type, T defaultValue) {
        T value = get(key, type);
        return value != null ? value : defaultValue;
    }
    
    @Override
    public boolean contains(String key) {
        return data.containsKey(key);
    }
    
    @Override
    public void remove(String key) {
        data.remove(key);
    }
    
    @Override
    public void clear() {
        data.clear();
    }
    
    @Override
    public Map<String, Object> getAll() {
        return new HashMap<>(data);
    }
}

// 增强的测试上下文实现
public class EnhancedTestContext implements TestContext {
    
    private final Map<String, Object> data = new ConcurrentHashMap<>();
    private final Map<String, Object> scenarioData = new ConcurrentHashMap<>();
    private final Map<String, Object> featureData = new ConcurrentHashMap<>();
    private final List<CleanupTask> cleanupTasks = new ArrayList<>();
    
    // 设置场景级数据
    public void setScenarioData(String key, Object value) {
        scenarioData.put(key, value);
    }
    
    // 获取场景级数据
    @SuppressWarnings("unchecked")
    public <T> T getScenarioData(String key, Class<T> type) {
        Object value = scenarioData.get(key);
        if (value == null) {
            return null;
        }
        
        if (!type.isInstance(value)) {
            throw new ClassCastException("Value for key '" + key + "' is not of type " + type.getName());
        }
        
        return (T) value;
    }
    
    // 设置特性级数据
    public void setFeatureData(String key, Object value) {
        featureData.put(key, value);
    }
    
    // 获取特性级数据
    @SuppressWarnings("unchecked")
    public <T> T getFeatureData(String key, Class<T> type) {
        Object value = featureData.get(key);
        if (value == null) {
            return null;
        }
        
        if (!type.isInstance(value)) {
            throw new ClassCastException("Value for key '" + key + "' is not of type " + type.getName());
        }
        
        return (T) value;
    }
    
    // 添加清理任务
    public void addCleanupTask(CleanupTask task) {
        cleanupTasks.add(task);
    }
    
    // 执行所有清理任务
    public void executeCleanupTasks() {
        for (CleanupTask task : cleanupTasks) {
            try {
                task.cleanup();
            } catch (Exception e) {
                // 记录错误但继续执行其他清理任务
                System.err.println("Error executing cleanup task: " + e.getMessage());
            }
        }
        cleanupTasks.clear();
    }
    
    // 清理场景数据
    public void clearScenarioData() {
        scenarioData.clear();
    }
    
    // 清理特性数据
    public void clearFeatureData() {
        featureData.clear();
    }
    
    // 实现TestContext接口方法
    @Override
    public void set(String key, Object value) {
        data.put(key, value);
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public <T> T get(String key, Class<T> type) {
        Object value = data.get(key);
        if (value == null) {
            return null;
        }
        
        if (!type.isInstance(value)) {
            throw new ClassCastException("Value for key '" + key + "' is not of type " + type.getName());
        }
        
        return (T) value;
    }
    
    @Override
    public <T> T get(String key, Class<T> type, T defaultValue) {
        T value = get(key, type);
        return value != null ? value : defaultValue;
    }
    
    @Override
    public boolean contains(String key) {
        return data.containsKey(key);
    }
    
    @Override
    public void remove(String key) {
        data.remove(key);
    }
    
    @Override
    public void clear() {
        data.clear();
        scenarioData.clear();
        featureData.clear();
        cleanupTasks.clear();
    }
    
    @Override
    public Map<String, Object> getAll() {
        Map<String, Object> allData = new HashMap<>();
        allData.putAll(data);
        allData.putAll(scenarioData);
        allData.putAll(featureData);
        return allData;
    }
    
    // 清理任务接口
    public interface CleanupTask {
        void cleanup();
    }
}

// 特定领域的测试上下文
public class DomainTestContext extends EnhancedTestContext {
    
    // 用户相关方法
    public void setCurrentUser(User user) {
        set("currentUser", user);
        addCleanupTask(() -> {
            if (user.getId() != null) {
                // 清理用户数据
                userService.deleteUser(user.getId());
            }
        });
    }
    
    public User getCurrentUser() {
        return get("currentUser", User.class);
    }
    
    public void setLastEnteredUsername(String username) {
        set("lastEnteredUsername", username);
    }
    
    public String getLastEnteredUsername() {
        return get("lastEnteredUsername", String.class, "");
    }
    
    // 产品相关方法
    public void setCurrentProduct(Product product) {
        set("currentProduct", product);
        addCleanupTask(() -> {
            if (product.getId() != null) {
                // 清理产品数据
                productService.deleteProduct(product.getId());
            }
        });
    }
    
    public Product getCurrentProduct() {
        return get("currentProduct", Product.class);
    }
    
    // 订单相关方法
    public void setCurrentOrder(Order order) {
        set("currentOrder", order);
        addCleanupTask(() -> {
            if (order.getId() != null) {
                // 清理订单数据
                orderService.deleteOrder(order.getId());
            }
        });
    }
    
    public Order getCurrentOrder() {
        return get("currentOrder", Order.class);
    }
    
    // 系统配置方法
    public void setBaseUrl(String baseUrl) {
        set("baseUrl", baseUrl);
    }
    
    public String getBaseUrl() {
        return get("baseUrl", String.class, "http://localhost:8080");
    }
    
    public void setBrowser(String browser) {
        set("browser", browser);
    }
    
    public String getBrowser() {
        return get("browser", String.class, "chrome");
    }
    
    // 测试数据方法
    public void setCreatedUsers(List<User> users) {
        set("createdUsers", users);
        addCleanupTask(() -> {
            for (User user : users) {
                if (user.getId() != null) {
                    userService.deleteUser(user.getId());
                }
            }
        });
    }
    
    @SuppressWarnings("unchecked")
    public List<User> getCreatedUsers() {
        return get("createdUsers", List.class, new ArrayList<>());
    }
    
    public void addCreatedUser(User user) {
        List<User> users = getCreatedUsers();
        users.add(user);
        setCreatedUsers(users);
    }
    
    // 测试结果方法
    public void setTestResult(TestResult testResult) {
        set("testResult", testResult);
    }
    
    public TestResult getTestResult() {
        return get("testResult", TestResult.class);
    }
    
    public void addTestStepResult(TestStepResult stepResult) {
        List<TestStepResult> stepResults = getTestStepResults();
        stepResults.add(stepResult);
        set("testStepResults", stepResults);
    }
    
    @SuppressWarnings("unchecked")
    public List<TestStepResult> getTestStepResults() {
        return get("testStepResults", List.class, new ArrayList<>());
    }
}
```

## 性能优化

### 1. 并行测试执行

#### 线程安全测试上下文

为了支持并行测试执行，测试上下文必须是线程安全的：

```java
// 线程安全的测试上下文
public class ThreadSafeTestContext implements TestContext {
    
    private final ThreadLocal<Map<String, Object>> threadLocalData = ThreadLocal.withInitial(HashMap::new);
    
    @Override
    public void set(String key, Object value) {
        threadLocalData.get().put(key, value);
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public <T> T get(String key, Class<T> type) {
        Object value = threadLocalData.get().get(key);
        if (value == null) {
            return null;
        }
        
        if (!type.isInstance(value)) {
            throw new ClassCastException("Value for key '" + key + "' is not of type " + type.getName());
        }
        
        return (T) value;
    }
    
    @Override
    public <T> T get(String key, Class<T> type, T defaultValue) {
        T value = get(key, type);
        return value != null ? value : defaultValue;
    }
    
    @Override
    public boolean contains(String key) {
        return threadLocalData.get().containsKey(key);
    }
    
    @Override
    public void remove(String key) {
        threadLocalData.get().remove(key);
    }
    
    @Override
    public void clear() {
        threadLocalData.get().clear();
    }
    
    @Override
    public Map<String, Object> getAll() {
        return new HashMap<>(threadLocalData.get());
    }
    
    // 清理线程本地数据
    public void cleanup() {
        threadLocalData.remove();
    }
}
```

#### 并行执行配置

```java
// 并行测试运行器
public class ParallelCucumberRunner extends AbstractTestNGCucumberTests {
    
    @Override
    @DataProvider(parallel = true)
    public Object[][] scenarios() {
        return super.scenarios();
    }
}

// CucumberOptions配置
@CucumberOptions(
    features = "src/test/resources/features",
    glue = "com.example.steps",
    plugin = {"pretty", "html:target/cucumber-report", "json:target/cucumber.json"},
    monochrome = true,
    tags = "not @skip"
)
public class ParallelTestRunner extends ParallelCucumberRunner {
    // 继承所有配置，只启用并行执行
}

// Maven Surefire插件配置
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>3.0.0-M7</version>
    <configuration>
        <parallel>methods</parallel>
        <threadCount>4</threadCount>
        <perCoreThreadCount>true</perCoreThreadCount>
        <useUnlimitedThreads>false</useUnlimitedThreads>
    </configuration>
</plugin>
```

### 2. 测试分片

#### 基于场景的分片

```java
// 测试分片器
public class TestShard {
    
    private final int shardIndex;
    private final int totalShards;
    
    public TestShard(int shardIndex, int totalShards) {
        this.shardIndex = shardIndex;
        this.totalShards = totalShards;
    }
    
    public boolean shouldRun(Scenario scenario) {
        String scenarioName = scenario.getName();
        int hash = scenarioName.hashCode();
        int shard = Math.abs(hash) % totalShards;
        return shard == shardIndex;
    }
    
    public boolean shouldRun(Pickle pickle) {
        String pickleName = pickle.getName();
        int hash = pickleName.hashCode();
        int shard = Math.abs(hash) % totalShards;
        return shard == shardIndex;
    }
    
    public String getTagExpression() {
        return String.format("not @skip and (%s)", generateShardTagExpression());
    }
    
    private String generateShardTagExpression() {
        // 这里可以根据需要实现更复杂的分片逻辑
        // 例如基于特性文件名、场景名称等
        return "true"; // 简化实现，实际应该根据分片逻辑生成
    }
}

// 分片运行器
public class ShardedTestRunner {
    
    private final TestShard shard;
    
    public ShardedTestRunner(int shardIndex, int totalShards) {
        this.shard = new TestShard(shardIndex, totalShards);
    }
    
    public void run() {
        // 获取环境变量中的分片信息
        String shardIndexStr = System.getProperty("cucumber.shard.index");
        String totalShardsStr = System.getProperty("cucumber.shard.total");
        
        int shardIndex = Integer.parseInt(shardIndexStr);
        int totalShards = Integer.parseInt(totalShardsStr);
        
        TestShard shard = new TestShard(shardIndex, totalShards);
        
        // 创建自定义的事件监听器来过滤场景
        EventListener eventListener = new ShardingEventListener(shard);
        
        // 运行Cucumber
        JUnitOptions junitOptions = new JUnitOptionsBuilder()
            .addPlugin("pretty")
            .addPlugin("html:target/cucumber-report-" + shardIndex)
            .addPlugin("json:target/cucumber-" + shardIndex + ".json")
            .addTagExpression(shard.getTagExpression())
            .build();
            
        Main.run(new String[]{
            "--glue", "com.example.steps",
            "--plugin", junitOptions.buildPluginString(),
            "--tags", shard.getTagExpression(),
            "src/test/resources/features"
        }, new ClassLoaderResourceLoader(), new Runtime.Builder()
            .withEventBus(new TimeServiceEventBus(TimeService.SYSTEM))
            .withBackendSupplier(new ThreadLocalBackendSupplier())
            .withAdditionalPlugins(eventListener)
            .build());
    }
    
    // 分片事件监听器
    private static class ShardingEventListener implements EventListener {
        
        private final TestShard shard;
        
        public ShardingEventListener(TestShard shard) {
            this.shard = shard;
        }
        
        @Override
        public void setEventPublisher(EventPublisher publisher) {
            publisher.registerHandlerFor(TestCaseStarted.class, this::handleTestCaseStarted);
        }
        
        private void handleTestCaseStarted(TestCaseStarted event) {
            if (!shard.shouldRun(event.getTestCase())) {
                // 跳过不属于当前分片的测试用例
                throw new SkipException("Test case does not belong to this shard");
            }
        }
    }
}
```

### 3. 测试缓存

#### 测试结果缓存

```java
// 测试结果缓存
public class TestResultCache {
    
    private final Map<String, CachedTestResult> cache = new ConcurrentHashMap<>();
    private final Duration cacheExpiry;
    
    public TestResultCache(Duration cacheExpiry) {
        this.cacheExpiry = cacheExpiry;
    }
    
    public Optional<CachedTestResult> get(String testKey) {
        CachedTestResult result = cache.get(testKey);
        if (result == null) {
            return Optional.empty();
        }
        
        if (result.isExpired()) {
            cache.remove(testKey);
            return Optional.empty();
        }
        
        return Optional.of(result);
    }
    
    public void put(String testKey, TestResult testResult) {
        CachedTestResult cachedResult = new CachedTestResult(testResult, Instant.now().plus(cacheExpiry));
        cache.put(testKey, cachedResult);
    }
    
    public void clear() {
        cache.clear();
    }
    
    public void cleanupExpired() {
        cache.entrySet().removeIf(entry -> entry.getValue().isExpired());
    }
    
    // 缓存的测试结果
    public static class CachedTestResult {
        private final TestResult testResult;
        private final Instant expiryTime;
        
        public CachedTestResult(TestResult testResult, Instant expiryTime) {
            this.testResult = testResult;
            this.expiryTime = expiryTime;
        }
        
        public TestResult getTestResult() {
            return testResult;
        }
        
        public boolean isExpired() {
            return Instant.now().isAfter(expiryTime);
        }
    }
}

// 缓存测试步骤定义
public class CachedStepDefinitions {
    
    private final TestResultCache cache;
    
    public CachedStepDefinitions(TestResultCache cache) {
        this.cache = cache;
    }
    
    @Given("系统中有产品{string}，价格为{double}")
    public void systemHasProductWithPrice(String productName, double price) {
        String testKey = "product_" + productName + "_" + price;
        
        Optional<TestResultCache.CachedTestResult> cachedResult = cache.get(testKey);
        if (cachedResult.isPresent()) {
            // 使用缓存的结果
            TestContext context = cachedResult.get().getTestResult().getContext();
            context.set("currentProduct", context.get("currentProduct", Product.class));
            return;
        }
        
        // 执行实际测试步骤
        Product product = Product.builder()
            .name(productName)
            .price(BigDecimal.valueOf(price))
            .description("Test product: " + productName)
            .build();
            
        Product savedProduct = productService.saveProduct(product);
        testContext.setCurrentProduct(savedProduct);
        
        // 缓存结果
        TestResult testResult = new TestResult();
        testResult.setContext(testContext);
        cache.put(testKey, testResult);
    }
}
```

## 大规模测试管理

### 1. 测试套件组织

#### 分层测试套件

```java
// 测试套件类型
public enum TestSuiteType {
    SMOKE,      // 冒烟测试
    REGRESSION, // 回归测试
    INTEGRATION, // 集成测试
    E2E,        // 端到端测试
    PERFORMANCE, // 性能测试
    SECURITY    // 安全测试
}

// 测试套件定义
public class TestSuite {
    
    private final String name;
    private final TestSuiteType type;
    private final List<String> featurePaths;
    private final String tagExpression;
    private final int priority;
    private final Duration timeout;
    
    public TestSuite(String name, TestSuiteType type, List<String> featurePaths, 
                     String tagExpression, int priority, Duration timeout) {
        this.name = name;
        this.type = type;
        this.featurePaths = new ArrayList<>(featurePaths);
        this.tagExpression = tagExpression;
        this.priority = priority;
        this.timeout = timeout;
    }
    
    // Getters
    public String getName() { return name; }
    public TestSuiteType getType() { return type; }
    public List<String> getFeaturePaths() { return new ArrayList<>(featurePaths); }
    public String getTagExpression() { return tagExpression; }
    public int getPriority() { return priority; }
    public Duration getTimeout() { return timeout; }
    
    // Builder模式
    public static class Builder {
        private String name;
        private TestSuiteType type;
        private List<String> featurePaths = new ArrayList<>();
        private String tagExpression = "";
        private int priority = 0;
        private Duration timeout = Duration.ofMinutes(30);
        
        public Builder name(String name) {
            this.name = name;
            return this;
        }
        
        public Builder type(TestSuiteType type) {
            this.type = type;
            return this;
        }
        
        public Builder featurePath(String featurePath) {
            this.featurePaths.add(featurePath);
            return this;
        }
        
        public Builder featurePaths(List<String> featurePaths) {
            this.featurePaths = new ArrayList<>(featurePaths);
            return this;
        }
        
        public Builder tagExpression(String tagExpression) {
            this.tagExpression = tagExpression;
            return this;
        }
        
        public Builder priority(int priority) {
            this.priority = priority;
            return this;
        }
        
        public Builder timeout(Duration timeout) {
            this.timeout = timeout;
            return this;
        }
        
        public TestSuite build() {
            return new TestSuite(name, type, featurePaths, tagExpression, priority, timeout);
        }
    }
}

// 测试套件管理器
public class TestSuiteManager {
    
    private final Map<String, TestSuite> testSuites = new HashMap<>();
    
    public void registerTestSuite(TestSuite testSuite) {
        testSuites.put(testSuite.getName(), testSuite);
    }
    
    public TestSuite getTestSuite(String name) {
        return testSuites.get(name);
    }
    
    public List<TestSuite> getTestSuitesByType(TestSuiteType type) {
        return testSuites.values().stream()
            .filter(suite -> suite.getType() == type)
            .sorted(Comparator.comparingInt(TestSuite::getPriority))
            .collect(Collectors.toList());
    }
    
    public List<TestSuite> getAllTestSuites() {
        return testSuites.values().stream()
            .sorted(Comparator.comparingInt(TestSuite::getPriority))
            .collect(Collectors.toList());
    }
    
    public void runTestSuite(String name) {
        TestSuite testSuite = getTestSuite(name);
        if (testSuite == null) {
            throw new IllegalArgumentException("Test suite not found: " + name);
        }
        
        runTestSuite(testSuite);
    }
    
    public void runTestSuitesByType(TestSuiteType type) {
        List<TestSuite> suites = getTestSuitesByType(type);
        for (TestSuite suite : suites) {
            runTestSuite(suite);
        }
    }
    
    private void runTestSuite(TestSuite testSuite) {
        System.out.println("Running test suite: " + testSuite.getName());
        
        // 构建Cucumber选项
        String[] options = buildCucumberOptions(testSuite);
        
        // 运行测试
        byte exitCode = Main.run(options, new ClassLoaderResourceLoader(), new Runtime.Builder()
            .withEventBus(new TimeServiceEventBus(TimeService.SYSTEM))
            .withBackendSupplier(new ThreadLocalBackendSupplier())
            .build());
            
        if (exitCode != 0) {
            throw new RuntimeException("Test suite failed: " + testSuite.getName());
        }
    }
    
    private String[] buildCucumberOptions(TestSuite testSuite) {
        List<String> options = new ArrayList<>();
        
        // 添加特性路径
        for (String featurePath : testSuite.getFeaturePaths()) {
            options.add(featurePath);
        }
        
        // 添加粘合代码路径
        options.add("--glue");
        options.add("com.example.steps");
        
        // 添加插件
        options.add("--plugin");
        options.add("pretty");
        
        options.add("--plugin");
        options.add("html:target/cucumber-report-" + testSuite.getName());
        
        options.add("--plugin");
        options.add("json:target/cucumber-" + testSuite.getName() + ".json");
        
        // 添加标签表达式
        if (!testSuite.getTagExpression().isEmpty()) {
            options.add("--tags");
            options.add(testSuite.getTagExpression());
        }
        
        // 添加其他选项
        options.add("--monochrome");
        
        return options.toArray(new String[0]);
    }
}

// 预定义的测试套件
public class PredefinedTestSuites {
    
    public static List<TestSuite> createAllTestSuites() {
        List<TestSuite> suites = new ArrayList<>();
        
        // 冒烟测试套件
        suites.add(new TestSuite.Builder()
            .name("smoke-tests")
            .type(TestSuiteType.SMOKE)
            .featurePath("src/test/resources/features/smoke")
            .tagExpression("@smoke and not @skip")
            .priority(1)
            .timeout(Duration.ofMinutes(10))
            .build());
            
        // 回归测试套件
        suites.add(new TestSuite.Builder()
            .name("regression-tests")
            .type(TestSuiteType.REGRESSION)
            .featurePath("src/test/resources/features/regression")
            .tagExpression("@regression and not @skip")
            .priority(2)
            .timeout(Duration.ofHours(2))
            .build());
            
        // 集成测试套件
        suites.add(new TestSuite.Builder()
            .name("integration-tests")
            .type(TestSuiteType.INTEGRATION)
            .featurePath("src/test/resources/features/integration")
            .tagExpression("@integration and not @skip")
            .priority(3)
            .timeout(Duration.ofMinutes(45))
            .build());
            
        // 端到端测试套件
        suites.add(new TestSuite.Builder()
            .name("e2e-tests")
            .type(TestSuiteType.E2E)
            .featurePath("src/test/resources/features/e2e")
            .tagExpression("@e2e and not @skip")
            .priority(4)
            .timeout(Duration.ofHours(3))
            .build());
            
        return suites;
    }
}
```

### 2. 测试环境管理

#### 多环境配置

```java
// 测试环境类型
public enum TestEnvironment {
    LOCAL,
    DEV,
    QA,
    STAGING,
    PRODUCTION
}

// 环境配置
public class EnvironmentConfig {
    
    private final TestEnvironment environment;
    private final String baseUrl;
    private final String apiUrl;
    private final String dbUrl;
    private final String dbUsername;
    private final String dbPassword;
    private final Map<String, String> additionalProperties;
    
    public EnvironmentConfig(TestEnvironment environment, String baseUrl, String apiUrl, 
                           String dbUrl, String dbUsername, String dbPassword,
                           Map<String, String> additionalProperties) {
        this.environment = environment;
        this.baseUrl = baseUrl;
        this.apiUrl = apiUrl;
        this.dbUrl = dbUrl;
        this.dbUsername = dbUsername;
        this.dbPassword = dbPassword;
        this.additionalProperties = new HashMap<>(additionalProperties);
    }
    
    // Getters
    public TestEnvironment getEnvironment() { return environment; }
    public String getBaseUrl() { return baseUrl; }
    public String getApiUrl() { return apiUrl; }
    public String getDbUrl() { return dbUrl; }
    public String getDbUsername() { return dbUsername; }
    public String getDbPassword() { return dbPassword; }
    public Map<String, String> getAdditionalProperties() { return new HashMap<>(additionalProperties); }
    
    public String getProperty(String key) {
        return additionalProperties.get(key);
    }
    
    public String getProperty(String key, String defaultValue) {
        return additionalProperties.getOrDefault(key, defaultValue);
    }
}

// 环境配置管理器
public class EnvironmentConfigManager {
    
    private final Map<TestEnvironment, EnvironmentConfig> configs = new HashMap<>();
    
    public EnvironmentConfigManager() {
        initializeConfigs();
    }
    
    private void initializeConfigs() {
        // 本地环境配置
        Map<String, String> localProps = new HashMap<>();
        localProps.put("browser", "chrome");
        localProps.put("headless", "false");
        localProps.put("timeout", "10");
        
        configs.put(TestEnvironment.LOCAL, new EnvironmentConfig(
            TestEnvironment.LOCAL,
            "http://localhost:3000",
            "http://localhost:8080/api",
            "jdbc:h2:mem:testdb",
            "sa",
            "",
            localProps
        ));
        
        // 开发环境配置
        Map<String, String> devProps = new HashMap<>();
        devProps.put("browser", "chrome");
        devProps.put("headless", "true");
        devProps.put("timeout", "15");
        
        configs.put(TestEnvironment.DEV, new EnvironmentConfig(
            TestEnvironment.DEV,
            "https://dev.example.com",
            "https://dev-api.example.com",
            "jdbc:postgresql://dev-db.example.com:5432/devdb",
            "devuser",
            "devpass",
            devProps
        ));
        
        // QA环境配置
        Map<String, String> qaProps = new HashMap<>();
        qaProps.put("browser", "chrome");
        qaProps.put("headless", "true");
        qaProps.put("timeout", "20");
        
        configs.put(TestEnvironment.QA, new EnvironmentConfig(
            TestEnvironment.QA,
            "https://qa.example.com",
            "https://qa-api.example.com",
            "jdbc:postgresql://qa-db.example.com:5432/qadb",
            "qauser",
            "qapass",
            qaProps
        ));
        
        // 预发布环境配置
        Map<String, String> stagingProps = new HashMap<>();
        stagingProps.put("browser", "chrome");
        stagingProps.put("headless", "true");
        stagingProps.put("timeout", "30");
        
        configs.put(TestEnvironment.STAGING, new EnvironmentConfig(
            TestEnvironment.STAGING,
            "https://staging.example.com",
            "https://staging-api.example.com",
            "jdbc:postgresql://staging-db.example.com:5432/stagingdb",
            "staginguser",
            "stagingpass",
            stagingProps
        ));
    }
    
    public EnvironmentConfig getConfig(TestEnvironment environment) {
        EnvironmentConfig config = configs.get(environment);
        if (config == null) {
            throw new IllegalArgumentException("No configuration found for environment: " + environment);
        }
        return config;
    }
    
    public EnvironmentConfig getCurrentConfig() {
        String envName = System.getProperty("test.environment", "local");
        TestEnvironment environment = TestEnvironment.valueOf(envName.toUpperCase());
        return getConfig(environment);
    }
}
```

## 创新应用

### 1. AI辅助测试

#### 智能测试生成

```java
// AI测试生成器
public class AITestGenerator {
    
    private final OpenAIClient openAIClient;
    private final FeatureParser featureParser;
    
    public AITestGenerator(OpenAIClient openAIClient, FeatureParser featureParser) {
        this.openAIClient = openAIClient;
        this.featureParser = featureParser;
    }
    
    public List<String> generateTestScenarios(String userStory) {
        String prompt = buildPrompt(userStory);
        
        String response = openAIClient.complete(prompt);
        
        return parseScenariosFromResponse(response);
    }
    
    private String buildPrompt(String userStory) {
        return String.format(
            "Given the following user story, generate comprehensive test scenarios using Gherkin syntax:\n\n" +
            "User Story: %s\n\n" +
            "Generate test scenarios that cover:\n" +
            "1. Happy path scenarios\n" +
            "2. Edge cases and boundary conditions\n" +
            "3. Error handling scenarios\n" +
            "4. Security considerations\n\n" +
            "Use the following format for each scenario:\n" +
            "Scenario: [Scenario Name]\n" +
            "Given [Precondition]\n" +
            "When [Action]\n" +
            "Then [Expected Result]\n\n" +
            "Ensure scenarios are specific, testable, and follow BDD best practices.",
            userStory
        );
    }
    
    private List<String> parseScenariosFromResponse(String response) {
        // 解析AI响应，提取场景
        // 这里简化实现，实际应该使用更复杂的解析逻辑
        List<String> scenarios = new ArrayList<>();
        
        String[] lines = response.split("\n");
        StringBuilder currentScenario = new StringBuilder();
        boolean inScenario = false;
        
        for (String line : lines) {
            line = line.trim();
            
            if (line.startsWith("Scenario:")) {
                if (inScenario && currentScenario.length() > 0) {
                    scenarios.add(currentScenario.toString());
                }
                currentScenario = new StringBuilder();
                currentScenario.append(line).append("\n");
                inScenario = true;
            } else if (inScenario) {
                currentScenario.append(line).append("\n");
                
                if (line.isEmpty() && currentScenario.length() > 0) {
                    // 空行可能表示场景结束
                    scenarios.add(currentScenario.toString());
                    currentScenario = new StringBuilder();
                    inScenario = false;
                }
            }
        }
        
        // 添加最后一个场景
        if (inScenario && currentScenario.length() > 0) {
            scenarios.add(currentScenario.toString());
        }
        
        return scenarios;
    }
    
    public String generateStepDefinitionCode(String stepText, String language) {
        String prompt = buildStepDefinitionPrompt(stepText, language);
        
        String response = openAIClient.complete(prompt);
        
        return extractCodeFromResponse(response);
    }
    
    private String buildStepDefinitionPrompt(String stepText, String language) {
        return String.format(
            "Generate a step definition method for the following Gherkin step in %s:\n\n" +
            "Step: %s\n\n" +
            "The step definition should:\n" +
            "1. Use the appropriate annotation for the language\n" +
            "2. Extract parameters from the step text\n" +
            "3. Include clear implementation comments\n" +
            "4. Follow best practices for the language\n" +
            "5. Include error handling where appropriate\n\n" +
            "Provide only the method implementation, without additional explanation.",
            language, stepText
        );
    }
    
    private String extractCodeFromResponse(String response) {
        // 从AI响应中提取代码块
        // 这里简化实现，实际应该使用正则表达式或其他方法
        if (response.contains("```")) {
            int start = response.indexOf("```") + 3;
            int end = response.indexOf("```", start);
            
            if (end > start) {
                return response.substring(start, end).trim();
            }
        }
        
        return response.trim();
    }
}

// AI辅助的步骤定义生成
public class AIStepDefinitionGenerator {
    
    private final AITestGenerator aiTestGenerator;
    private final String language;
    
    public AIStepDefinitionGenerator(AITestGenerator aiTestGenerator, String language) {
        this.aiTestGenerator = aiTestGenerator;
        this.language = language;
    }
    
    public void generateMissingStepDefinitions(String featureFilePath) {
        Feature feature = featureParser.parse(featureFilePath);
        
        for (ScenarioDefinition scenarioDefinition : feature.getScenarioDefinitions()) {
            if (scenarioDefinition instanceof Scenario) {
                Scenario scenario = (Scenario) scenarioDefinition;
                generateMissingStepDefinitionsForScenario(scenario);
            } else if (scenarioDefinition instanceof ScenarioOutline) {
                ScenarioOutline scenarioOutline = (ScenarioOutline) scenarioDefinition;
                generateMissingStepDefinitionsForScenarioOutline(scenarioOutline);
            }
        }
    }
    
    private void generateMissingStepDefinitionsForScenario(Scenario scenario) {
        for (Step step : scenario.getSteps()) {
            if (isStepDefinitionMissing(step)) {
                generateStepDefinition(step);
            }
        }
    }
    
    private void generateMissingStepDefinitionsForScenarioOutline(ScenarioOutline scenarioOutline) {
        for (Step step : scenarioOutline.getSteps()) {
            if (isStepDefinitionMissing(step)) {
                generateStepDefinition(step);
            }
        }
    }
    
    private boolean isStepDefinitionMissing(Step step) {
        // 检查步骤定义是否存在
        // 这里简化实现，实际应该检查步骤定义注册表
        return true;
    }
    
    private void generateStepDefinition(Step step) {
        String stepText = step.getText();
        String code = aiTestGenerator.generateStepDefinitionCode(stepText, language);
        
        System.out.println("Generated step definition for: " + stepText);
        System.out.println(code);
        
        // 将生成的代码写入文件
        writeStepDefinitionToFile(code);
    }
    
    private void writeStepDefinitionToFile(String code) {
        // 实现将生成的代码写入文件的逻辑
        // 这里简化实现
        System.out.println("Writing step definition to file...");
    }
}
```

### 2. 可视化测试报告

#### 交互式报告生成

```java
// 交互式报告生成器
public class InteractiveReportGenerator {
    
    private final TestExecutionData executionData;
    private final ReportTemplateEngine templateEngine;
    
    public InteractiveReportGenerator(TestExecutionData executionData, ReportTemplateEngine templateEngine) {
        this.executionData = executionData;
        this.templateEngine = templateEngine;
    }
    
    public void generateReport(String outputPath) {
        Map<String, Object> model = createReportModel();
        
        String html = templateEngine.render("interactive-report", model);
        
        try {
            Files.write(Paths.get(outputPath), html.getBytes(StandardCharsets.UTF_8));
        } catch (IOException e) {
            throw new RuntimeException("Failed to write report file", e);
        }
    }
    
    private Map<String, Object> createReportModel() {
        Map<String, Object> model = new HashMap<>();
        
        model.put("executionData", executionData);
        model.put("summaryData", createSummaryData());
        model.put("chartData", createChartData());
        model.put("timelineData", createTimelineData());
        model.put("featureData", createFeatureData());
        model.put("tagData", createTagData());
        
        return model;
    }
    
    private Map<String, Object> createSummaryData() {
        Map<String, Object> summary = new HashMap<>();
        
        int totalTests = executionData.getTotalTests();
        int passedTests = executionData.getPassedTests();
        int failedTests = executionData.getFailedTests();
        int skippedTests = executionData.getSkippedTests();
        int pendingTests = executionData.getPendingTests();
        
        summary.put("total", totalTests);
        summary.put("passed", passedTests);
        summary.put("failed", failedTests);
        summary.put("skipped", skippedTests);
        summary.put("pending", pendingTests);
        summary.put("passRate", totalTests > 0 ? (passedTests * 100.0) / totalTests : 0.0);
        summary.put("failRate", totalTests > 0 ? (failedTests * 100.0) / totalTests : 0.0);
        summary.put("duration", executionData.getTotalDuration());
        summary.put("timestamp", executionData.getExecutionTime());
        
        return summary;
    }
    
    private Map<String, Object> createChartData() {
        Map<String, Object> chartData = new HashMap<>();
        
        // 饼图数据
        Map<String, Integer> pieData = new HashMap<>();
        pieData.put("Passed", executionData.getPassedTests());
        pieData.put("Failed", executionData.getFailedTests());
        pieData.put("Skipped", executionData.getSkippedTests());
        pieData.put("Pending", executionData.getPendingTests());
        chartData.put("pie", pieData);
        
        // 趋势图数据
        List<Map<String, Object>> trendData = createTrendData();
        chartData.put("trend", trendData);
        
        return chartData;
    }
    
    private List<Map<String, Object>> createTrendData() {
        // 从历史数据创建趋势图数据
        // 这里简化实现，实际应该从数据库或其他存储中获取历史数据
        List<Map<String, Object>> trendData = new ArrayList<>();
        
        // 模拟历史数据
        for (int i = 6; i >= 0; i--) {
            LocalDate date = LocalDate.now().minusDays(i);
            Map<String, Object> dataPoint = new HashMap<>();
            
            dataPoint.put("date", date.toString());
            dataPoint.put("passed", 80 + (int)(Math.random() * 20));
            dataPoint.put("failed", (int)(Math.random() * 10));
            dataPoint.put("total", 100);
            
            trendData.add(dataPoint);
        }
        
        return trendData;
    }
    
    private Map<String, Object> createTimelineData() {
        Map<String, Object> timelineData = new HashMap<>();
        
        List<Map<String, Object>> events = new ArrayList<>();
        
        for (TestExecution execution : executionData.getExecutions()) {
            Map<String, Object> event = new HashMap<>();
            
            event.put("timestamp", execution.getStartTime().toString());
            event.put("feature", execution.getFeatureName());
            event.put("scenario", execution.getScenarioName());
            event.put("status", execution.getStatus().name());
            event.put("duration", execution.getDuration());
            
            events.add(event);
        }
        
        timelineData.put("events", events);
        
        return timelineData;
    }
    
    private Map<String, Object> createFeatureData() {
        Map<String, Object> featureData = new HashMap<>();
        
        List<Map<String, Object>> features = new ArrayList<>();
        
        for (FeatureExecution featureExecution : executionData.getFeatureExecutions()) {
            Map<String, Object> feature = new HashMap<>();
            
            feature.put("name", featureExecution.getFeatureName());
            feature.put("path", featureExecution.getFeaturePath());
            feature.put("description", featureExecution.getDescription());
            feature.put("totalTests", featureExecution.getTotalTests());
            feature.put("passedTests", featureExecution.getPassedTests());
            feature.put("failedTests", featureExecution.getFailedTests());
            feature.put("skippedTests", featureExecution.getSkippedTests());
            feature.put("pendingTests", featureExecution.getPendingTests());
            feature.put("duration", featureExecution.getDuration());
            feature.put("status", featureExecution.getStatus().name());
            
            features.add(feature);
        }
        
        // 按状态排序
        features.sort((a, b) -> {
            String statusA = (String) a.get("status");
            String statusB = (String) b.get("status");
            
            // 失败的排在前面
            if ("FAILED".equals(statusA) && !"FAILED".equals(statusB)) {
                return -1;
            } else if (!"FAILED".equals(statusA) && "FAILED".equals(statusB)) {
                return 1;
            }
            
            // 然后按名称排序
            return ((String) a.get("name")).compareTo((String) b.get("name"));
        });
        
        featureData.put("features", features);
        
        return featureData;
    }
    
    private Map<String, Object> createTagData() {
        Map<String, Object> tagData = new HashMap<>();
        
        List<Map<String, Object>> tags = new ArrayList<>();
        
        for (TagExecution tagExecution : executionData.getTagExecutions()) {
            Map<String, Object> tag = new HashMap<>();
            
            tag.put("name", tagExecution.getTagName());
            tag.put("totalTests", tagExecution.getTotalTests());
            tag.put("passedTests", tagExecution.getPassedTests());
            tag.put("failedTests", tagExecution.getFailedTests());
            tag.put("skippedTests", tagExecution.getSkippedTests());
            tag.put("pendingTests", tagExecution.getPendingTests());
            tag.put("duration", tagExecution.getDuration());
            tag.put("status", tagExecution.getStatus().name());
            
            tags.add(tag);
        }
        
        // 按测试数量排序
        tags.sort((a, b) -> {
            Integer countA = (Integer) a.get("totalTests");
            Integer countB = (Integer) b.get("totalTests");
            return countB.compareTo(countA);
        });
        
        tagData.put("tags", tags);
        
        return tagData;
    }
}
```

## 总结

本章介绍了Cucumber的高级主题，包括高级测试模式、性能优化、大规模测试管理和创新应用。这些主题帮助您更深入地利用Cucumber的强大功能，解决复杂场景下的测试挑战。

通过掌握这些高级主题，您可以：

1. **构建更强大的测试框架**：使用测试数据工厂、增强的页面对象模式和测试上下文管理
2. **提高测试执行效率**：通过并行测试、测试分片和测试缓存优化性能
3. **管理大规模测试**：使用测试套件组织和环境管理
4. **探索创新应用**：利用AI辅助测试和可视化报告

这些高级技术和模式将帮助您构建更加健壮、可维护和高效的测试框架，满足复杂项目的需求。随着技术的不断发展，Cucumber生态系统也在不断演进，持续学习和探索新的技术和方法将使您能够更好地应对未来的测试挑战。