# 6.2 高级数据表处理

## 引言

在BDD测试中，数据表是一种强大的工具，用于表示结构化数据和复杂场景。在基础章节中，我们已经学习了数据表的基本用法，本章将深入探讨高级数据表处理技术，包括嵌套数据表、数据转换、验证和复杂数据结构处理等。

## 数据表基础回顾

在深入高级主题之前，让我们简要回顾一下数据表的基础知识：

```gherkin
Scenario: 使用数据表创建多个产品
  Given 用户在产品管理页面
  When 用户创建以下产品:
    | 产品名称 | 品牌   | 价格   | 类别 |
    | iPhone 14 | Apple  | 999.00 | 手机 |
    | Galaxy S23 | Samsung | 899.00 | 手机 |
  Then 系统应该显示成功消息
  And 产品列表应该包含新创建的产品
```

## 嵌套数据表

### 什么是嵌套数据表

嵌套数据表是指数据表中的某个单元格包含另一个数据表。这种结构对于表示复杂的数据关系非常有用，例如产品与配件、订单与订单项等。

### 嵌套数据表语法

Cucumber支持使用DocString表示嵌套数据表：

```gherkin
Scenario: 创建包含配件的产品
  Given 用户在产品管理页面
  When 用户创建以下产品:
    | 产品名称 | 品牌   | 价格   | 类别 | 配件列表 |
    | iPhone 14 | Apple  | 999.00 | 手机 | """
      | 配件名称 | 价格   | 数量 |
      | 充电器   | 29.00  | 1    |
      | 手机壳   | 19.00  | 1    |
      | 耳机     | 99.00  | 1    |
      """ |
    | Galaxy S23 | Samsung | 899.00 | 手机 | """
      | 配件名称 | 价格   | 数量 |
      | 充电器   | 25.00  | 1    |
      | 手机壳   | 15.00  | 1    |
      """ |
  Then 系统应该显示成功消息
  And 产品列表应该包含新创建的产品及其配件
```

### 嵌套数据表处理

在步骤定义中，我们需要特殊处理嵌套数据表：

```java
import io.cucumber.java.en.*;
import io.cucumber.datatable.DataTable;
import java.util.List;
import java.util.Map;

public class ProductSteps {
    
    @When("用户创建以下产品:")
    public void userCreatesProducts(DataTable productTable) {
        List<Map<String, String>> products = productTable.asMaps();
        
        for (Map<String, String> product : products) {
            String productName = product.get("产品名称");
            String brand = product.get("品牌");
            double price = Double.parseDouble(product.get("价格"));
            String category = product.get("类别");
            String accessoriesTable = product.get("配件列表");
            
            // 解析嵌套的配件数据表
            DataTable accessoriesDataTable = DataTable.create(accessoriesTable);
            List<Map<String, String>> accessories = accessoriesDataTable.asMaps();
            
            // 创建产品和配件
            createProductWithAccessories(productName, brand, price, category, accessories);
        }
    }
    
    private void createProductWithAccessories(String productName, String brand, 
                                            double price, String category, 
                                            List<Map<String, String>> accessories) {
        // 实现创建产品和配件的逻辑
        // ...
    }
}
```

## 数据转换器

### 什么是数据转换器

数据转换器是一种将数据表中的原始值转换为特定类型对象的机制。通过自定义数据转换器，我们可以简化步骤定义中的数据转换逻辑，提高代码的可读性和可维护性。

### 创建自定义数据转换器

我们可以通过实现`TypeRegistryConfigurer`接口来注册自定义数据转换器：

```java
import io.cucumber.java.TypeRegistryConfigurer;
import io.cucumber.cucumberexpressions.ParameterType;
import io.cucumber.datatable.DataTable;
import io.cucumber.datatable.DataTableType;
import io.cucumber.datatable.TableEntryTransformer;
import java.util.Locale;
import java.util.Map;

public class DataTypeRegistryConfigurer implements TypeRegistryConfigurer {
    
    @Override
    public Locale locale() {
        return Locale.ENGLISH;
    }
    
    @Override
    public void configureTypeRegistry(io.cucumber.core.api.TypeRegistry typeRegistry) {
        // 注册产品类型转换器
        typeRegistry.defineDataTableType(new DataTableType(Product.class, new TableEntryTransformer<Product>() {
            @Override
            public Product transform(Map<String, String> entry) {
                String name = entry.get("产品名称");
                String brand = entry.get("品牌");
                double price = Double.parseDouble(entry.get("价格"));
                String category = entry.get("类别");
                
                return new Product(name, brand, price, category);
            }
        }));
        
        // 注册配件类型转换器
        typeRegistry.defineDataTableType(new DataTableType(Accessory.class, new TableEntryTransformer<Accessory>() {
            @Override
            public Accessory transform(Map<String, String> entry) {
                String name = entry.get("配件名称");
                double price = Double.parseDouble(entry.get("价格"));
                int quantity = Integer.parseInt(entry.get("数量"));
                
                return new Accessory(name, price, quantity);
            }
        }));
        
        // 注册产品与配件组合类型转换器
        typeRegistry.defineDataTableType(new DataTableType(ProductWithAccessories.class, new TableEntryTransformer<ProductWithAccessories>() {
            @Override
            public ProductWithAccessories transform(Map<String, String> entry) {
                String productName = entry.get("产品名称");
                String brand = entry.get("品牌");
                double price = Double.parseDouble(entry.get("价格"));
                String category = entry.get("类别");
                String accessoriesTable = entry.get("配件列表");
                
                // 解析嵌套的配件数据表
                DataTable accessoriesDataTable = DataTable.create(accessoriesTable);
                List<Accessory> accessories = accessoriesDataTable.asList(Accessory.class);
                
                Product product = new Product(productName, brand, price, category);
                return new ProductWithAccessories(product, accessories);
            }
        }));
    }
}
```

### 使用自定义数据转换器

使用自定义数据转换器后，步骤定义变得更加简洁：

```java
import io.cucumber.java.en.*;
import java.util.List;

public class ProductSteps {
    
    @When("用户创建以下产品:")
    public void userCreatesProducts(List<Product> products) {
        for (Product product : products) {
            productService.createProduct(product);
        }
    }
    
    @When("用户创建以下产品及其配件:")
    public void userCreatesProductsWithAccessories(List<ProductWithAccessories> productsWithAccessories) {
        for (ProductWithAccessories productWithAccessories : productsWithAccessories) {
            productService.createProductWithAccessories(
                productWithAccessories.getProduct(), 
                productWithAccessories.getAccessories()
            );
        }
    }
}
```

## 数据验证

### 数据表验证策略

在测试中，我们经常需要验证系统返回的数据是否符合预期。数据表提供了一种直观的方式来表达预期结果。

### 基本验证

```gherkin
Scenario: 验证产品列表
  Given 系统包含以下产品:
    | 产品名称 | 品牌   | 价格   | 类别 |
    | iPhone 14 | Apple  | 999.00 | 手机 |
    | Galaxy S23 | Samsung | 899.00 | 手机 |
  When 用户查询产品列表
  Then 系统应该返回以下产品:
    | 产品名称 | 品牌   | 价格   | 类别 |
    | iPhone 14 | Apple  | 999.00 | 手机 |
    | Galaxy S23 | Samsung | 899.00 | 手机 |
```

### 部分字段验证

有时我们只需要验证部分字段，而不是整个对象：

```gherkin
Scenario: 验证产品基本信息
  Given 系统包含多个产品
  When 用户查询产品列表
  Then 系统应该返回以下产品的基本信息:
    | 产品名称 | 品牌   |
    | iPhone 14 | Apple  |
    | Galaxy S23 | Samsung |
```

### 动态验证

有时我们需要验证动态生成的数据，例如ID、时间戳等：

```gherkin
Scenario: 验证创建的产品
  Given 用户在产品管理页面
  When 用户创建产品 "iPhone 14"
  Then 系统应该返回以下产品信息:
    | 字段     | 验证方式     |
    | 产品名称 | 等于 "iPhone 14" |
    | 品牌     | 等于 "Apple"     |
    | 价格     | 等于 999.00     |
    | 类别     | 等于 "手机"      |
    | ID       | 不为空          |
    | 创建时间 | 不为空          |
```

### 验证步骤实现

```java
import io.cucumber.java.en.*;
import io.cucumber.datatable.DataTable;
import java.util.List;
import java.util.Map;
import static org.junit.jupiter.api.Assertions.*;

public class ProductVerificationSteps {
    
    @Then("系统应该返回以下产品:")
    public void systemShouldReturnProducts(List<Product> expectedProducts) {
        List<Product> actualProducts = productService.getProducts();
        
        assertEquals(expectedProducts.size(), actualProducts.size(), "产品数量不匹配");
        
        for (int i = 0; i < expectedProducts.size(); i++) {
            Product expected = expectedProducts.get(i);
            Product actual = actualProducts.get(i);
            
            assertEquals(expected.getName(), actual.getName(), "产品名称不匹配");
            assertEquals(expected.getBrand(), actual.getBrand(), "品牌不匹配");
            assertEquals(expected.getPrice(), actual.getPrice(), 0.01, "价格不匹配");
            assertEquals(expected.getCategory(), actual.getCategory(), "类别不匹配");
        }
    }
    
    @Then("系统应该返回以下产品的基本信息:")
    public void systemShouldReturnBasicProductInfo(DataTable expectedTable) {
        List<Map<String, String>> expectedProducts = expectedTable.asMaps();
        List<Product> actualProducts = productService.getProducts();
        
        assertEquals(expectedProducts.size(), actualProducts.size(), "产品数量不匹配");
        
        for (int i = 0; i < expectedProducts.size(); i++) {
            Map<String, String> expected = expectedProducts.get(i);
            Product actual = actualProducts.get(i);
            
            assertEquals(expected.get("产品名称"), actual.getName(), "产品名称不匹配");
            assertEquals(expected.get("品牌"), actual.getBrand(), "品牌不匹配");
        }
    }
    
    @Then("系统应该返回以下产品信息:")
    public void systemShouldReturnProductInfo(DataTable verificationTable) {
        Product actualProduct = productService.getLastCreatedProduct();
        List<Map<String, String>> verifications = verificationTable.asMaps();
        
        for (Map<String, String> verification : verifications) {
            String field = verification.get("字段");
            String verificationMethod = verification.get("验证方式");
            
            switch (field) {
                case "产品名称":
                    verifyField(actualProduct.getName(), verificationMethod);
                    break;
                case "品牌":
                    verifyField(actualProduct.getBrand(), verificationMethod);
                    break;
                case "价格":
                    verifyField(actualProduct.getPrice().toString(), verificationMethod);
                    break;
                case "类别":
                    verifyField(actualProduct.getCategory(), verificationMethod);
                    break;
                case "ID":
                    verifyField(actualProduct.getId(), verificationMethod);
                    break;
                case "创建时间":
                    verifyField(actualProduct.getCreatedAt(), verificationMethod);
                    break;
            }
        }
    }
    
    private void verifyField(Object actualValue, String verificationMethod) {
        if (verificationMethod.startsWith("等于 ")) {
            String expectedValue = verificationMethod.substring(3).replace("\"", "");
            assertEquals(expectedValue, actualValue.toString());
        } else if (verificationMethod.equals("不为空")) {
            assertNotNull(actualValue);
        } else if (verificationMethod.startsWith("大于 ")) {
            double threshold = Double.parseDouble(verificationMethod.substring(3));
            assertTrue(Double.parseDouble(actualValue.toString()) > threshold);
        }
        // 可以添加更多验证方法
    }
}
```

## 复杂数据结构处理

### 处理JSON/XML数据

有时我们需要处理JSON或XML格式的复杂数据结构：

```gherkin
Scenario: 处理JSON产品数据
  Given 用户在产品管理页面
  When 用户上传以下JSON产品数据:
    """
    {
      "products": [
        {
          "name": "iPhone 14",
          "brand": "Apple",
          "price": 999.00,
          "category": "手机",
          "specifications": {
            "screen": "6.1英寸",
            "storage": "128GB",
            "camera": "12MP"
          },
          "accessories": [
            {
              "name": "充电器",
              "price": 29.00,
              "quantity": 1
            },
            {
              "name": "手机壳",
              "price": 19.00,
              "quantity": 1
            }
          ]
        }
      ]
    }
    """
  Then 系统应该成功导入产品
  And 产品列表应该包含 "iPhone 14"
```

### 处理JSON/XML数据的步骤定义

```java
import io.cucumber.java.en.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.Map;

public class JsonProductSteps {
    
    private final ObjectMapper objectMapper = new ObjectMapper();
    
    @When("用户上传以下JSON产品数据:")
    public void userUploadsJsonProductData(String jsonContent) throws Exception {
        // 解析JSON数据
        Map<String, Object> jsonData = objectMapper.readValue(jsonContent, Map.class);
        List<Map<String, Object>> products = (List<Map<String, Object>>) jsonData.get("products");
        
        // 处理每个产品
        for (Map<String, Object> productData : products) {
            String name = (String) productData.get("name");
            String brand = (String) productData.get("brand");
            double price = (Double) productData.get("price");
            String category = (String) productData.get("category");
            
            // 处理规格
            Map<String, Object> specifications = (Map<String, Object>) productData.get("specifications");
            String screen = (String) specifications.get("screen");
            String storage = (String) specifications.get("storage");
            String camera = (String) specifications.get("camera");
            
            // 处理配件
            List<Map<String, Object>> accessories = (List<Map<String, Object>>) productData.get("accessories");
            
            // 创建产品
            Product product = new Product(name, brand, price, category);
            product.setSpecifications(new ProductSpecifications(screen, storage, camera));
            
            // 添加配件
            for (Map<String, Object> accessoryData : accessories) {
                String accessoryName = (String) accessoryData.get("name");
                double accessoryPrice = (Double) accessoryData.get("price");
                int quantity = (Integer) accessoryData.get("quantity");
                
                Accessory accessory = new Accessory(accessoryName, accessoryPrice, quantity);
                product.addAccessory(accessory);
            }
            
            // 保存产品
            productService.createProduct(product);
        }
    }
}
```

## 数据表最佳实践

### 1. 保持数据表简洁

**原则**：数据表应该专注于表达测试所需的关键数据，避免包含不必要的字段。

**示例**：

```gherkin
# 好的做法：只包含关键数据
Given 系统包含以下产品:
  | 产品名称 | 品牌   | 价格   |
  | iPhone 14 | Apple  | 999.00 |
  | Galaxy S23 | Samsung | 899.00 |

# 不好的做法：包含过多不必要的数据
Given 系统包含以下产品:
  | 产品名称 | 品牌   | 价格   | 类别 | 描述 | 创建时间 | 更新时间 | 创建者 | 状态 | 标签 | 重量 | 尺寸 | 颜色 | 材质 | 保修期 | 产地 | 库存 | 销量 | 评分 | 评论数 |
  | iPhone 14 | Apple  | 999.00 | 手机 | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... |
```

### 2. 使用有意义的列名

**原则**：使用清晰、描述性的列名，避免使用缩写或模糊的名称。

**示例**：

```gherkin
# 好的做法：使用描述性列名
Given 系统包含以下产品:
  | 产品名称 | 品牌   | 价格   | 库存数量 |
  | iPhone 14 | Apple  | 999.00 | 50      |

# 不好的做法：使用模糊的列名
Given 系统包含以下产品:
  | name | brand | price | qty |
  | iPhone 14 | Apple  | 999.00 | 50 |
```

### 3. 保持数据表一致性

**原则**：在整个项目中保持数据表结构的一致性，使用相同的列名和顺序。

### 4. 合理使用嵌套数据表

**原则**：只在真正需要表示复杂关系时使用嵌套数据表，避免过度嵌套导致可读性下降。

### 5. 使用数据转换器简化代码

**原则**：对于复杂的数据结构，使用自定义数据转换器简化步骤定义代码。

## 总结

高级数据表处理是Cucumber中的一个强大功能，它使我们能够处理复杂的测试数据和场景。通过掌握嵌套数据表、数据转换器、数据验证和复杂数据结构处理等技术，我们可以创建更加灵活和强大的BDD测试。

在实际项目中，应该根据具体需求选择合适的数据表处理技术，并遵循最佳实践，确保测试的可读性和可维护性。通过合理使用高级数据表处理技术，我们可以显著提高测试效率和质量。