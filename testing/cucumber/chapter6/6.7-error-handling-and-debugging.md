# 6.7 错误处理与调试

## 引言

在BDD测试开发过程中，错误处理和调试是不可避免的环节。本章将深入探讨Cucumber测试中的错误处理机制、调试技巧、常见问题解决方案以及最佳实践，帮助您快速定位和解决问题，提高测试开发的效率和质量。

## 错误处理机制

### 异常处理策略

#### 步骤定义中的异常处理

```java
import io.cucumber.java.en.*;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;
import java.util.Map;

public class ProductSearchSteps {
    
    @Autowired
    private ProductService productService;
    
    private List<Product> searchResults;
    private Exception lastException;
    
    @Given("系统包含产品")
    public void systemContainsProducts(io.cucumber.datatable.DataTable productTable) {
        try {
            List<Product> products = productTable.asMaps().stream()
                .map(this::createProductFromRow)
                .collect(Collectors.toList());
            
            productService.saveAllProducts(products);
        } catch (DataAccessException e) {
            // 处理数据库访问异常
            lastException = e;
            throw new RuntimeException("Failed to save products: " + e.getMessage(), e);
        } catch (Exception e) {
            // 处理其他异常
            lastException = e;
            throw new RuntimeException("Unexpected error while saving products: " + e.getMessage(), e);
        }
    }
    
    @When("用户搜索产品 {string}")
    public void userSearchesForProduct(String searchTerm) {
        try {
            searchResults = productService.searchProducts(searchTerm);
        } catch (SearchServiceException e) {
            // 处理搜索服务异常
            lastException = e;
            // 可以选择记录异常而不中断测试
            System.err.println("Search service error: " + e.getMessage());
        } catch (Exception e) {
            // 处理其他异常
            lastException = e;
            throw new RuntimeException("Failed to search products: " + e.getMessage(), e);
        }
    }
    
    @Then("系统应该返回 {int} 个结果")
    public void systemShouldReturnResults(int expectedCount) {
        if (lastException != null) {
            // 如果有异常，可以根据情况处理
            throw new AssertionError("Search failed with exception: " + lastException.getMessage(), lastException);
        }
        
        assertEquals("Search result count mismatch", expectedCount, searchResults.size());
    }
    
    @Then("系统应该显示错误消息 {string}")
    public void systemShouldShowErrorMessage(String expectedMessage) {
        assertNotNull("An exception should have been thrown", lastException);
        assertTrue("Error message should contain expected text", 
                  lastException.getMessage().contains(expectedMessage));
    }
    
    private Product createProductFromRow(Map<String, String> row) {
        Product product = new Product();
        product.setName(row.get("名称"));
        product.setPrice(Double.parseDouble(row.get("价格")));
        product.setCategory(row.get("类别"));
        return product;
    }
}
```

#### 使用自定义异常

```java
// 自定义业务异常
public class ProductNotFoundException extends RuntimeException {
    public ProductNotFoundException(String message) {
        super(message);
    }
    
    public ProductNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}

public class InvalidProductDataException extends RuntimeException {
    public InvalidProductDataException(String message) {
        super(message);
    }
    
    public InvalidProductDataException(String message, Throwable cause) {
        super(message, cause);
    }
}

// 在步骤定义中使用自定义异常
public class ProductManagementSteps {
    
    @Autowired
    private ProductService productService;
    
    private Product currentProduct;
    private Exception lastException;
    
    @When("用户创建产品，名称为 {string}，价格为 {double}")
    public void userCreatesProductWithNameAndPrice(String name, double price) {
        try {
            // 验证产品数据
            if (name == null || name.trim().isEmpty()) {
                throw new InvalidProductDataException("Product name cannot be empty");
            }
            
            if (price <= 0) {
                throw new InvalidProductDataException("Product price must be positive");
            }
            
            // 创建产品
            Product product = new Product();
            product.setName(name);
            product.setPrice(price);
            
            currentProduct = productService.saveProduct(product);
        } catch (InvalidProductDataException e) {
            lastException = e;
            // 不重新抛出，允许测试继续验证错误处理
        } catch (Exception e) {
            lastException = e;
            throw new RuntimeException("Unexpected error creating product: " + e.getMessage(), e);
        }
    }
    
    @When("用户查找产品 {string}")
    public void userLooksForProduct(String productName) {
        try {
            currentProduct = productService.findByName(productName);
            
            if (currentProduct == null) {
                throw new ProductNotFoundException("Product not found: " + productName);
            }
        } catch (ProductNotFoundException e) {
            lastException = e;
            // 不重新抛出，允许测试继续验证错误处理
        } catch (Exception e) {
            lastException = e;
            throw new RuntimeException("Unexpected error finding product: " + e.getMessage(), e);
        }
    }
    
    @Then("产品应该成功创建")
    public void productShouldBeSuccessfullyCreated() {
        assertNull("No exception should have been thrown", lastException);
        assertNotNull("Product should have been created", currentProduct);
        assertNotNull("Product should have an ID", currentProduct.getId());
    }
    
    @Then("系统应该显示产品数据无效错误")
    public void systemShouldShowInvalidProductDataError() {
        assertNotNull("An exception should have been thrown", lastException);
        assertTrue("Should be InvalidProductDataException", 
                  lastException instanceof InvalidProductDataException);
    }
    
    @Then("系统应该显示产品未找到错误")
    public void systemShouldShowProductNotFoundError() {
        assertNotNull("An exception should have been thrown", lastException);
        assertTrue("Should be ProductNotFoundException", 
                  lastException instanceof ProductNotFoundException);
    }
}
```

### Hooks中的错误处理

#### Before和After Hook中的错误处理

```java
import io.cucumber.java.*;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;

public class WebTestHooks {
    
    private static WebDriver driver;
    
    @Before(order = 1)
    public void setupWebDriver() {
        try {
            // 设置Chrome选项
            ChromeOptions options = new ChromeOptions();
            options.addArguments("--headless"); // 无头模式，提高测试速度
            options.addArguments("--disable-gpu");
            options.addArguments("--no-sandbox");
            options.addArguments("--disable-dev-shm-usage");
            
            // 创建WebDriver实例
            driver = new ChromeDriver(options);
            
            // 设置隐式等待
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
            
            // 将WebDriver存储在Scenario上下文中
            ScenarioContext.setContext("driver", driver);
        } catch (Exception e) {
            // 记录错误但不中断测试
            System.err.println("Failed to initialize WebDriver: " + e.getMessage());
            // 可以尝试使用备用浏览器或标记测试为跳过
        }
    }
    
    @Before(order = 2)
    public void setupTestData(Scenario scenario) {
        try {
            // 初始化测试数据
            TestDataInitializer.initializeTestData();
            
            // 记录测试开始
            System.out.println("Starting scenario: " + scenario.getName());
        } catch (Exception e) {
            // 记录错误但不中断测试
            System.err.println("Failed to initialize test data: " + e.getMessage());
        }
    }
    
    @After(order = 1)
    public void takeScreenshotOnFailure(Scenario scenario) {
        try {
            if (scenario.isFailed()) {
                WebDriver driver = (WebDriver) ScenarioContext.getContext("driver");
                if (driver != null) {
                    // 截取失败时的屏幕截图
                    byte[] screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.BYTES);
                    scenario.attach(screenshot, "image/png", "Failure Screenshot");
                }
            }
        } catch (Exception e) {
            // 记录错误但不中断测试
            System.err.println("Failed to take screenshot: " + e.getMessage());
        }
    }
    
    @After(order = 2)
    public void cleanupTestData() {
        try {
            // 清理测试数据
            TestDataCleanup.cleanupTestData();
        } catch (Exception e) {
            // 记录错误但不中断测试
            System.err.println("Failed to cleanup test data: " + e.getMessage());
        }
    }
    
    @After(order = 3)
    public void closeWebDriver() {
        try {
            WebDriver driver = (WebDriver) ScenarioContext.getContext("driver");
            if (driver != null) {
                driver.quit();
            }
        } catch (Exception e) {
            // 记录错误但不中断测试
            System.err.println("Failed to close WebDriver: " + e.getMessage());
        }
    }
}
```

#### BeforeAll和AfterAll Hook中的错误处理

```java
import io.cucumber.java.*;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.containers.GenericContainer;

public class GlobalHooks {
    
    private static PostgreSQLContainer<?> postgresContainer;
    private static GenericContainer<?> redisContainer;
    
    @BeforeAll
    public static void setupGlobalTestEnvironment() {
        try {
            // 启动PostgreSQL容器
            postgresContainer = new PostgreSQLContainer<>("postgres:13")
                    .withDatabaseName("testdb")
                    .withUsername("test")
                    .withPassword("test");
            postgresContainer.start();
            
            // 启动Redis容器
            redisContainer = new GenericContainer<>("redis:6-alpine")
                    .withExposedPorts(6379);
            redisContainer.start();
            
            // 配置系统属性
            System.setProperty("spring.datasource.url", postgresContainer.getJdbcUrl());
            System.setProperty("spring.datasource.username", postgresContainer.getUsername());
            System.setProperty("spring.datasource.password", postgresContainer.getPassword());
            System.setProperty("spring.redis.host", redisContainer.getHost());
            System.setProperty("spring.redis.port", redisContainer.getMappedPort(6379).toString());
            
            System.out.println("Global test environment setup completed");
        } catch (Exception e) {
            System.err.println("Failed to setup global test environment: " + e.getMessage());
            // 可以选择终止测试或使用备用配置
            throw new RuntimeException("Global test environment setup failed", e);
        }
    }
    
    @AfterAll
    public static void cleanupGlobalTestEnvironment() {
        try {
            // 停止容器
            if (postgresContainer != null && postgresContainer.isRunning()) {
                postgresContainer.stop();
            }
            
            if (redisContainer != null && redisContainer.isRunning()) {
                redisContainer.stop();
            }
            
            System.out.println("Global test environment cleanup completed");
        } catch (Exception e) {
            System.err.println("Failed to cleanup global test environment: " + e.getMessage());
            // 记录错误但不中断测试
        }
    }
}
```

## 调试技巧

### 使用日志调试

#### 配置日志级别

```properties
# logback-test.xml
<configuration>
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- Cucumber日志配置 -->
    <logger name="io.cucumber" level="DEBUG"/>
    
    <!-- 应用程序日志配置 -->
    <logger name="com.example.gherkin" level="DEBUG"/>
    
    <!-- Spring日志配置 -->
    <logger name="org.springframework" level="INFO"/>
    
    <!-- 数据库日志配置 -->
    <logger name="org.hibernate.SQL" level="DEBUG"/>
    <logger name="org.hibernate.type.descriptor.sql" level="TRACE"/>
    
    <root level="WARN">
        <appender-ref ref="STDOUT" />
    </root>
</configuration>
```

#### 在步骤定义中添加日志

```java
import io.cucumber.java.en.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;

public class ProductSearchSteps {
    
    private static final Logger logger = LoggerFactory.getLogger(ProductSearchSteps.class);
    
    @Autowired
    private ProductService productService;
    
    private List<Product> searchResults;
    
    @Given("系统包含产品")
    public void systemContainsProducts(io.cucumber.datatable.DataTable productTable) {
        logger.debug("Setting up products from data table");
        
        List<Product> products = productTable.asMaps().stream()
            .map(this::createProductFromRow)
            .collect(Collectors.toList());
        
        logger.debug("Saving {} products to database", products.size());
        productService.saveAllProducts(products);
        
        logger.info("Successfully saved {} products", products.size());
    }
    
    @When("用户搜索产品 {string}")
    public void userSearchesForProduct(String searchTerm) {
        logger.debug("Searching for products with term: {}", searchTerm);
        
        searchResults = productService.searchProducts(searchTerm);
        
        logger.debug("Found {} products matching term: {}", searchResults.size(), searchTerm);
    }
    
    @Then("系统应该返回 {int} 个结果")
    public void systemShouldReturnResults(int expectedCount) {
        logger.debug("Asserting search results count. Expected: {}, Actual: {}", 
                    expectedCount, searchResults.size());
        
        assertEquals("Search result count mismatch", expectedCount, searchResults.size());
        
        logger.info("Search results count assertion passed");
    }
    
    private Product createProductFromRow(Map<String, String> row) {
        logger.trace("Creating product from row: {}", row);
        
        Product product = new Product();
        product.setName(row.get("名称"));
        product.setPrice(Double.parseDouble(row.get("价格")));
        product.setCategory(row.get("类别"));
        
        logger.trace("Created product: {}", product);
        return product;
    }
}
```

### 使用断点调试

#### 配置IDE调试

```java
// 在步骤定义中添加断点
public class ProductManagementSteps {
    
    @Autowired
    private ProductService productService;
    
    @When("用户创建产品，名称为 {string}，价格为 {double}")
    public void userCreatesProductWithNameAndPrice(String name, double price) {
        // 在这里设置断点，调试产品创建过程
        Product product = new Product();
        product.setName(name);
        product.setPrice(price);
        
        // 在这里设置断点，检查产品对象
        currentProduct = productService.saveProduct(product);
    }
    
    @Then("产品应该成功创建")
    public void productShouldBeSuccessfullyCreated() {
        // 在这里设置断点，验证产品创建结果
        assertNotNull("Product should have been created", currentProduct);
        assertNotNull("Product should have an ID", currentProduct.getId());
    }
}
```

#### 使用远程调试

```xml
<!-- 在Maven Surefire插件中配置远程调试 -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>3.0.0-M5</version>
    <configuration>
        <systemPropertyVariables>
            <spring.profiles.active>test</spring.profiles.active>
        </systemPropertyVariables>
        <argLine>-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005</argLine>
    </configuration>
</plugin>
```

### 使用自定义调试插件

#### 创建调试插件

```java
import io.cucumber.plugin.ConcurrentEventListener;
import io.cucumber.plugin.EventListener;
import io.cucumber.plugin.event.*;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.HashMap;
import java.util.Map;

public class DebugPlugin implements ConcurrentEventListener {
    
    private final Map<String, Long> stepStartTimes = new HashMap<>();
    
    @Override
    public void setEventPublisher(EventPublisher publisher) {
        publisher.registerHandlerFor(TestCaseStarted.class, this::handleTestCaseStarted);
        publisher.registerHandlerFor(TestCaseFinished.class, this::handleTestCaseFinished);
        publisher.registerHandlerFor(TestStepStarted.class, this::handleTestStepStarted);
        publisher.registerHandlerFor(TestStepFinished.class, this::handleTestStepFinished);
        publisher.registerHandlerFor(EmbedEvent.class, this::handleEmbedEvent);
    }
    
    private void handleTestCaseStarted(TestCaseStarted event) {
        System.out.println("\n=== 开始测试用例 ===");
        System.out.println("测试用例: " + event.getTestCase().getName());
        System.out.println("特性文件: " + event.getTestCase().getUri());
        System.out.println("行号: " + event.getTestCase().getLine());
    }
    
    private void handleTestCaseFinished(TestCaseFinished event) {
        System.out.println("\n=== 结束测试用例 ===");
        System.out.println("测试用例: " + event.getTestCase().getName());
        System.out.println("结果: " + event.getResult().getStatus());
        System.out.println("错误: " + event.getResult().getError());
        
        if (event.getResult().isFailed()) {
            System.out.println("\n=== 错误详情 ===");
            printStackTrace(event.getResult().getError());
        }
    }
    
    private void handleTestStepStarted(TestStepStarted event) {
        if (event.getTestStep() instanceof PickleStepTestStep) {
            PickleStepTestStep pickleStep = (PickleStepTestStep) event.getTestStep();
            String stepText = pickleStep.getStep().getText();
            System.out.println("\n步骤开始: " + stepText);
            
            // 记录步骤开始时间
            stepStartTimes.put(stepText, System.currentTimeMillis());
        }
    }
    
    private void handleTestStepFinished(TestStepFinished event) {
        if (event.getTestStep() instanceof PickleStepTestStep) {
            PickleStepTestStep pickleStep = (PickleStepTestStep) event.getTestStep();
            String stepText = pickleStep.getStep().getText();
            
            // 计算步骤执行时间
            Long startTime = stepStartTimes.get(stepText);
            long duration = startTime != null ? System.currentTimeMillis() - startTime : 0;
            
            System.out.println("步骤结束: " + stepText);
            System.out.println("结果: " + event.getResult().getStatus());
            System.out.println("执行时间: " + duration + "ms");
            
            if (event.getResult().isFailed()) {
                System.out.println("错误: " + event.getResult().getError());
                printStackTrace(event.getResult().getError());
            }
        }
    }
    
    private void handleEmbedEvent(EmbedEvent event) {
        System.out.println("嵌入数据: " + event.getName() + " (" + event.getMimeType() + ")");
    }
    
    private void printStackTrace(Throwable throwable) {
        if (throwable != null) {
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            throwable.printStackTrace(pw);
            System.out.println(sw.toString());
        }
    }
}
```

#### 配置调试插件

```java
import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(
    features = {"src/test/resources/features"},
    glue = {"com.example.gherkin.stepdefinitions"},
    plugin = {
        "pretty",
        "json:target/cucumber-reports/cucumber.json",
        "html:target/cucumber-reports/cucumber-html",
        "com.example.gherkin.plugin.DebugPlugin"  // 自定义调试插件
    },
    monochrome = true
)
public class DebugCucumberTestRunner {
}
```

## 常见问题与解决方案

### 步骤定义匹配问题

#### 模糊匹配问题

**问题描述**：多个步骤定义匹配同一个Gherkin步骤。

**解决方案**：
1. 使用更具体的正则表达式
2. 使用参数类型区分
3. 使用优先级标记

```java
// 问题：两个步骤定义可能匹配同一个步骤
@Given("用户登录系统")
public void userLogsIn() {
    // 实现
}

@Given("用户登录系统，使用用户名 {string} 和密码 {string}")
public void userLogsInWithCredentials(String username, String password) {
    // 实现
}

// 解决方案：使用更具体的正则表达式
@Given("^用户登录系统$")  // 精确匹配
public void userLogsIn() {
    // 实现
}

@Given("^用户登录系统，使用用户名 (.+) 和密码 (.+)$")  // 带参数的匹配
public void userLogsInWithCredentials(String username, String password) {
    // 实现
}
```

#### 参数类型转换问题

**问题描述**：参数类型转换失败。

**解决方案**：
1. 使用自定义参数类型
2. 添加参数验证
3. 提供默认值

```java
// 问题：参数类型转换可能失败
@When("用户购买 {int} 个产品")
public void userBuysProducts(int quantity) {
    // 如果Gherkin中提供的不是有效整数，会抛出异常
}

// 解决方案：使用自定义参数类型
public class QuantityType implements TypeRegistryConfigurer {
    @Override
    public Locale locale() {
        return Locale.ENGLISH;
    }

    @Override
    public void configureTypeRegistry(TypeRegistry typeRegistry) {
        typeRegistry.defineParameterType(new ParameterType<>(
            "quantity",  // 参数类型名称
            "(\\d+)(?:个|件|件商品)?",  // 正则表达式
            Integer.class,  // 目标类型
            (String s) -> {
                try {
                    return Integer.parseInt(s);
                } catch (NumberFormatException e) {
                    throw new IllegalArgumentException("Invalid quantity: " + s, e);
                }
            },
            false  // 不用于匿名参数
        ));
    }
}

// 使用自定义参数类型
@When("用户购买 {quantity} 个产品")
public void userBuysProducts(Integer quantity) {
    // 参数已经过验证和转换
}
```

### 数据表处理问题

#### 数据表格式问题

**问题描述**：数据表格式不正确导致解析失败。

**解决方案**：
1. 检查数据表缩进
2. 确保列名一致
3. 验证数据类型

```gherkin
# 错误的数据表格式
Scenario: 测试产品搜索
  Given 系统包含产品
    | 名称 | 价格 | 类别 |
  | iPhone 14 | 999.00 | 手机 |
  | Galaxy S23 | 899.00 | 手机 |

# 正确的数据表格式
Scenario: 测试产品搜索
  Given 系统包含产品
    | 名称       | 价格    | 类别 |
    | iPhone 14  | 999.00  | 手机 |
    | Galaxy S23 | 899.00  | 手机 |
```

#### 数据表转换问题

**问题描述**：数据表转换为对象失败。

**解决方案**：
1. 使用数据表转换器
2. 添加数据验证
3. 提供默认值

```java
// 问题：直接转换可能失败
@Given("系统包含产品")
public void systemContainsProducts(io.cucumber.datatable.DataTable productTable) {
    List<Product> products = productTable.asList(Product.class);  // 可能失败
}

// 解决方案：使用数据表转换器
public class ProductDataTableTransformer extends DataTableTypeEntry {
    public ProductDataTableTransformer() {
        super("product", Product.class, (DataTable table) -> {
            Map<String, String> row = table.asMaps().get(0);
            Product product = new Product();
            product.setName(row.get("名称"));
            
            try {
                product.setPrice(Double.parseDouble(row.get("价格")));
            } catch (NumberFormatException e) {
                product.setPrice(0.0);  // 提供默认值
            }
            
            product.setCategory(row.getOrDefault("类别", "默认类别"));
            return product;
        });
    }
}

// 在步骤定义中使用转换器
@Given("系统包含产品")
public void systemContainsProducts(List<Product> products) {
    productService.saveAllProducts(products);
}
```

### 测试环境问题

#### 测试数据隔离问题

**问题描述**：测试之间相互影响。

**解决方案**：
1. 使用@Before和@After清理数据
2. 使用事务回滚
3. 使用独立测试数据库

```java
// 解决方案：使用事务回滚
@SpringBootTest
@Transactional
public class TransactionalProductSteps {
    
    @Autowired
    private ProductService productService;
    
    @Given("系统包含产品")
    public void systemContainsProducts(io.cucumber.datatable.DataTable productTable) {
        List<Product> products = productTable.asMaps().stream()
            .map(this::createProductFromRow)
            .collect(Collectors.toList());
        
        productService.saveAllProducts(products);
    }
    
    @When("用户搜索产品 {string}")
    public void userSearchesForProduct(String searchTerm) {
        searchResults = productService.searchProducts(searchTerm);
    }
    
    // 测试结束后，事务会自动回滚，清理测试数据
}
```

#### 外部依赖问题

**问题描述**：外部服务不可用导致测试失败。

**解决方案**：
1. 使用模拟服务
2. 使用测试容器
3. 使用条件测试

```java
// 解决方案：使用WireMock模拟外部服务
import com.github.tomakehurst.wiremock.client.WireMock;
import com.github.tomakehurst.wiremock.junit5.WireMockTest;

@WireMockTest(httpPort = 8080)
public class ExternalServiceSteps {
    
    @Given("外部产品服务可用")
    public void externalProductServiceIsAvailable() {
        stubFor(get(urlEqualTo("/api/products"))
            .willReturn(aResponse()
                .withStatus(200)
                .withHeader("Content-Type", "application/json")
                .withBody("[{\"id\":1,\"name\":\"iPhone 14\",\"price\":999.00}]")));
    }
    
    @When("从外部服务获取产品")
    public void getProductsFromExternalService() {
        // 调用外部服务
    }
}
```

## 高级调试技术

### 使用条件断点

```java
// 在步骤定义中添加条件断点
public class ConditionalDebuggingSteps {
    
    @When("用户搜索产品 {string}")
    public void userSearchesForProduct(String searchTerm) {
        // 设置条件断点：searchTerm.equals("iPhone")
        // 这样只有在搜索"iPhone"时才会触发断点
        searchResults = productService.searchProducts(searchTerm);
    }
    
    @Then("系统应该返回 {int} 个结果")
    public void systemShouldReturnResults(int expectedCount) {
        // 设置条件断点：expectedCount > 5
        // 这样只有在预期结果大于5时才会触发断点
        assertEquals("Search result count mismatch", expectedCount, searchResults.size());
    }
}
```

### 使用表达式求值

```java
// 在步骤定义中添加表达式求值
public class ExpressionEvaluationSteps {
    
    @When("用户执行表达式 {string}")
    public void userExecutesExpression(String expression) {
        // 在断点处使用表达式求值
        // 例如：productService.searchProducts("iPhone").size()
        // 可以实时查看表达式结果
        Object result = evaluateExpression(expression);
        // ...
    }
    
    private Object evaluateExpression(String expression) {
        // 实现表达式求值逻辑
        return null;
    }
}
```

### 使用远程调试

```java
// 配置远程调试端口
public class RemoteDebuggingSteps {
    
    @When("用户执行远程调试步骤")
    public void userExecutesRemoteDebuggingStep() {
        // 启动远程调试
        // 使用IDE连接到远程调试端口
        // 可以远程调试测试执行过程
        // ...
    }
}
```

## 错误处理与调试最佳实践

### 1. 结构化错误处理

**原则**：使用结构化的方式处理错误，避免异常吞没。

**指导**：
- 使用自定义异常类型
- 记录详细的错误信息
- 提供有意义的错误消息

### 2. 合理使用日志

**原则**：使用适当的日志级别，记录关键信息。

**指导**：
- 使用DEBUG级别记录详细信息
- 使用INFO级别记录关键操作
- 使用ERROR级别记录错误信息

### 3. 使用断点调试

**原则**：使用断点调试复杂逻辑，快速定位问题。

**指导**：
- 在关键步骤设置断点
- 使用条件断点过滤不相关的情况
- 使用表达式求值检查变量值

### 4. 使用模拟和存根

**原则**：使用模拟和存根隔离外部依赖，提高测试稳定性。

**指导**：
- 使用WireMock模拟REST服务
- 使用Testcontainers模拟数据库
- 使用Mockito模拟业务逻辑

### 5. 编写可调试的测试

**原则**：编写易于调试的测试，提高问题定位效率。

**指导**：
- 使用描述性的步骤名称
- 添加断言消息
- 分离设置、执行和验证逻辑

## 总结

错误处理和调试是BDD测试开发中的重要环节。通过掌握错误处理机制、调试技巧和常见问题的解决方案，我们可以快速定位和解决问题，提高测试开发的效率和质量。

在实际项目中，应该建立完善的错误处理和调试体系，包括结构化的错误处理、合理的日志记录、有效的断点调试和模拟外部依赖等。通过遵循最佳实践，我们可以创建更加健壮、可靠的BDD测试体系，支持高质量的软件开发。