# 6.6 性能优化技巧

## 引言

随着BDD测试规模的扩大，测试执行时间可能成为开发流程中的瓶颈。本章将深入探讨Cucumber测试的性能优化技巧，包括测试并行化、资源管理、缓存策略、测试数据优化以及测试环境配置等方面，帮助您提高测试执行效率，缩短反馈周期。

## 测试并行化

### Cucumber并行执行基础

Cucumber支持多种并行执行策略，可以显著提高测试执行速度。

#### 配置并行执行

使用Maven Surefire插件配置并行执行：

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>3.0.0-M5</version>
    <configuration>
        <parallel>methods</parallel>
        <threadCount>4</threadCount>
        <perCoreThreadCount>true</perCoreThreadCount>
        <useUnlimitedThreads>false</useUnlimitedThreads>
    </configuration>
</plugin>
```

使用Maven Failsafe插件配置并行执行：

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-failsafe-plugin</artifactId>
    <version>3.0.0-M5</version>
    <configuration>
        <parallel>classes</parallel>
        <threadCount>4</threadCount>
        <includes>
            <include>**/*IT.java</include>
        </includes>
    </configuration>
    <executions>
        <execution>
            <goals>
                <goal>integration-test</goal>
                <goal>verify</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

### 并行执行策略

#### 特性级别并行

```java
import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(
    features = {"src/test/resources/features"},
    glue = {"com.example.gherkin.stepdefinitions"},
    plugin = {
        "pretty",
        "json:target/cucumber-reports/cucumber.json",
        "html:target/cucumber-reports/cucumber-html"
    },
    // 启用特性级别并行
    parallel = true
)
public class ParallelCucumberTestRunner {
}
```

#### 场景级别并行

```java
import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(
    features = {"src/test/resources/features"},
    glue = {"com.example.gherkin.stepdefinitions"},
    plugin = {
        "pretty",
        "json:target/cucumber-reports/cucumber.json",
        "html:target/cucumber-reports/cucumber-html"
    },
    // 启用场景级别并行
    parallel = true,
    // 场景级别并行需要确保线程安全
    monochrome = true
)
public class ParallelScenarioTestRunner {
}
```

### 线程安全考虑

#### 共享资源管理

```java
import io.cucumber.java.en.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

public class ThreadSafeSteps {
    
    // 使用线程安全的集合
    private static final ConcurrentHashMap<String, Object> sharedData = new ConcurrentHashMap<>();
    
    // 使用原子计数器
    private static final AtomicInteger counter = new AtomicInteger(0);
    
    // 使用ThreadLocal存储线程特定数据
    private static final ThreadLocal<String> threadLocalData = new ThreadLocal<>();
    
    @Given("初始化共享资源")
    public void initializeSharedResource() {
        // 线程安全的操作
        int id = counter.incrementAndGet();
        threadLocalData.set("Thread-" + Thread.currentThread().getId() + "-ID-" + id);
    }
    
    @When("访问共享资源")
    public void accessSharedResource() {
        String threadId = threadLocalData.get();
        sharedData.put(threadId, "Some value");
    }
    
    @Then("共享资源应该正确初始化")
    public void sharedResourceShouldBeInitialized() {
        String threadId = threadLocalData.get();
        assertNotNull("Thread local data should not be null", threadId);
        assertTrue("Shared data should contain thread ID", sharedData.containsKey(threadId));
    }
    
    @After
    public void cleanup() {
        // 清理ThreadLocal数据，防止内存泄漏
        threadLocalData.remove();
    }
}
```

#### 数据库连接管理

```java
import io.cucumber.java.en.*;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.concurrent.ConcurrentHashMap;

public class DatabaseSteps {
    
    // 使用ConcurrentHashMap存储每个线程的数据库连接
    private static final ConcurrentHashMap<Long, Connection> connections = new ConcurrentHashMap<>();
    
    private Connection getConnection() throws SQLException {
        long threadId = Thread.currentThread().getId();
        
        // 如果当前线程没有连接，则创建新连接
        return connections.computeIfAbsent(threadId, id -> {
            try {
                return DriverManager.getConnection("jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1", "sa", "");
            } catch (SQLException e) {
                throw new RuntimeException("Failed to create database connection", e);
            }
        });
    }
    
    @Given("数据库已初始化")
    public void databaseIsInitialized() throws SQLException {
        Connection conn = getConnection();
        // 初始化数据库结构
        try (var stmt = conn.createStatement()) {
            stmt.execute("CREATE TABLE IF NOT EXISTS products (id INT PRIMARY KEY, name VARCHAR(255), price DECIMAL(10,2))");
        }
    }
    
    @When("插入产品数据")
    public void insertProductData(io.cucumber.datatable.DataTable productTable) throws SQLException {
        Connection conn = getConnection();
        
        try (var stmt = conn.prepareStatement("INSERT INTO products (id, name, price) VALUES (?, ?, ?)")) {
            for (Map<String, String> product : productTable.asMaps()) {
                stmt.setInt(1, Integer.parseInt(product.get("id")));
                stmt.setString(2, product.get("name"));
                stmt.setDouble(3, Double.parseDouble(product.get("price")));
                stmt.addBatch();
            }
            stmt.executeBatch();
        }
    }
    
    @After
    public void cleanupDatabase() {
        long threadId = Thread.currentThread().getId();
        Connection conn = connections.get(threadId);
        
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException e) {
                // 记录错误但不中断测试
                System.err.println("Failed to close database connection: " + e.getMessage());
            } finally {
                connections.remove(threadId);
            }
        }
    }
}
```

## 资源管理

### 测试数据管理

#### 使用内存数据库

```java
import io.cucumber.java.en.*;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.beans.factory.annotation.Autowired;
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.Statement;

@SpringBootTest
@ActiveProfiles("test")
public class InMemoryDatabaseSteps {
    
    @Autowired
    private DataSource dataSource;
    
    @Before("@use-in-memory-db")
    public void setupInMemoryDatabase() throws Exception {
        try (Connection conn = dataSource.getConnection();
             Statement stmt = conn.createStatement()) {
            
            // 创建表结构
            stmt.execute("CREATE TABLE products (id INT PRIMARY KEY, name VARCHAR(255), price DECIMAL(10,2))");
            stmt.execute("CREATE TABLE orders (id INT PRIMARY KEY, customer_id INT, total_amount DECIMAL(10,2))");
            
            // 插入测试数据
            stmt.execute("INSERT INTO products (id, name, price) VALUES (1, 'iPhone 14', 999.00)");
            stmt.execute("INSERT INTO products (id, name, price) VALUES (2, 'Galaxy S23', 899.00)");
        }
    }
    
    @After("@use-in-memory-db")
    public void cleanupInMemoryDatabase() throws Exception {
        try (Connection conn = dataSource.getConnection();
             Statement stmt = conn.createStatement()) {
            
            // 清理数据
            stmt.execute("DROP TABLE IF EXISTS orders");
            stmt.execute("DROP TABLE IF EXISTS products");
        }
    }
}
```

#### 使用测试数据工厂

```java
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

public class TestDataFactory {
    
    private static final AtomicInteger idCounter = new AtomicInteger(1);
    
    public static Product createProduct(String name, double price) {
        Product product = new Product();
        product.setId(idCounter.getAndIncrement());
        product.setName(name);
        product.setPrice(price);
        product.setCategory("默认类别");
        return product;
    }
    
    public static Product createProductWithCategory(String name, double price, String category) {
        Product product = createProduct(name, price);
        product.setCategory(category);
        return product;
    }
    
    public static Order createOrder(int customerId, Map<Product, Integer> items) {
        Order order = new Order();
        order.setId(idCounter.getAndIncrement());
        order.setCustomerId(customerId);
        order.setItems(new HashMap<>(items));
        order.calculateTotal();
        return order;
    }
    
    public static User createUser(String username, String email) {
        User user = new User();
        user.setId(idCounter.getAndIncrement());
        user.setUsername(username);
        user.setEmail(email);
        user.setActive(true);
        return user;
    }
}
```

### 外部服务模拟

#### 使用WireMock模拟REST服务

```java
import com.github.tomakehurst.wiremock.client.WireMock;
import com.github.tomakehurst.wiremock.junit5.WireMockTest;
import io.cucumber.java.en.*;
import io.cucumber.java.Before;
import io.cucumber.java.After;
import static com.github.tomakehurst.wiremock.client.WireMock.*;

@WireMockTest(httpPort = 8080)
public class ExternalServiceSteps {
    
    @Before
    public void setup() {
        // 配置WireMock
        configureFor("localhost", 8080);
    }
    
    @Given("外部产品服务已启动")
    public void externalProductServiceIsStarted() {
        stubFor(get(urlEqualTo("/api/products"))
            .willReturn(aResponse()
                .withStatus(200)
                .withHeader("Content-Type", "application/json")
                .withBody("[{\"id\":1,\"name\":\"iPhone 14\",\"price\":999.00},{\"id\":2,\"name\":\"Galaxy S23\",\"price\":899.00}]")));
        
        stubFor(get(urlPathEqualTo("/api/products/1"))
            .willReturn(aResponse()
                .withStatus(200)
                .withHeader("Content-Type", "application/json")
                .withBody("{\"id\":1,\"name\":\"iPhone 14\",\"price\":999.00,\"category\":\"手机\"}")));
        
        stubFor(post(urlEqualTo("/api/products"))
            .willReturn(aResponse()
                .withStatus(201)
                .withHeader("Content-Type", "application/json")
                .withBody("{\"id\":3,\"name\":\"新产品\",\"price\":0.00}")));
    }
    
    @When("从外部服务获取产品列表")
    public void getProductListFromExternalService() {
        // 实现从外部服务获取产品列表的逻辑
    }
    
    @Then("应该返回产品列表")
    public void shouldReturnProductList() {
        // 验证请求是否被正确处理
        verify(getRequestedFor(urlEqualTo("/api/products")));
    }
    
    @After
    public void cleanup() {
        // 清理WireMock配置
        WireMock.reset();
    }
}
```

#### 使用Testcontainers模拟数据库

```java
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import io.cucumber.java.en.*;
import io.cucumber.java.BeforeAll;
import io.cucumber.java.AfterAll;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

@Testcontainers
public class DatabaseContainerSteps {
    
    @Container
    private static final PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:13")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");
    
    private static Connection connection;
    
    @BeforeAll
    public static void setupDatabase() throws Exception {
        // 启动PostgreSQL容器
        postgres.start();
        
        // 建立数据库连接
        connection = DriverManager.getConnection(
            postgres.getJdbcUrl(),
            postgres.getUsername(),
            postgres.getPassword()
        );
        
        // 初始化数据库结构
        try (Statement stmt = connection.createStatement()) {
            stmt.execute("CREATE TABLE products (id INT PRIMARY KEY, name VARCHAR(255), price DECIMAL(10,2))");
        }
    }
    
    @Given("数据库包含产品数据")
    public void databaseContainsProductData(io.cucumber.datatable.DataTable productTable) throws Exception {
        try (Statement stmt = connection.createStatement()) {
            for (Map<String, String> product : productTable.asMaps()) {
                stmt.execute(String.format(
                    "INSERT INTO products (id, name, price) VALUES (%s, '%s', %s)",
                    product.get("id"),
                    product.get("name"),
                    product.get("price")
                ));
            }
        }
    }
    
    @When("查询产品 {string}")
    public void queryProduct(String productName) throws Exception {
        try (Statement stmt = connection.createStatement();
             var rs = stmt.executeQuery("SELECT * FROM products WHERE name = '" + productName + "'")) {
            
            if (rs.next()) {
                // 处理查询结果
            }
        }
    }
    
    @AfterAll
    public static void cleanupDatabase() throws Exception {
        if (connection != null) {
            connection.close();
        }
        
        postgres.stop();
    }
}
```

## 缓存策略

### 测试数据缓存

#### 使用Caffeine缓存

```java
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import io.cucumber.java.en.*;
import java.util.concurrent.TimeUnit;

public class CachedDataSteps {
    
    // 创建产品缓存
    private static final Cache<String, Product> productCache = Caffeine.newBuilder()
            .maximumSize(100)
            .expireAfterWrite(10, TimeUnit.MINUTES)
            .build();
    
    // 创建用户缓存
    private static final Cache<String, User> userCache = Caffeine.newBuilder()
            .maximumSize(100)
            .expireAfterWrite(10, TimeUnit.MINUTES)
            .build();
    
    @Given("缓存中包含产品 {string}")
    public void cacheContainsProduct(String productName) {
        Product product = createProduct(productName);
        productCache.put(productName, product);
    }
    
    @When("从缓存获取产品 {string}")
    public void getProductFromCache(String productName) {
        Product product = productCache.getIfPresent(productName);
        assertNotNull("Product should be in cache", product);
    }
    
    @Then("产品 {string} 应该在缓存中")
    public void productShouldBeInCache(String productName) {
        Product product = productCache.getIfPresent(productName);
        assertNotNull("Product should be in cache", product);
        assertEquals(productName, product.getName());
    }
    
    private Product createProduct(String name) {
        Product product = new Product();
        product.setName(name);
        product.setPrice(999.00);
        product.setCategory("默认类别");
        return product;
    }
}
```

#### 使用Spring Cache

```java
import org.springframework.cache.annotation.Cacheable;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.stereotype.Service;
import io.cucumber.java.en.*;

@Service
public class CachedProductService {
    
    @Cacheable(value = "products", key = "#name")
    public Product getProductByName(String name) {
        // 模拟从数据库获取产品
        return fetchProductFromDatabase(name);
    }
    
    @CachePut(value = "products", key = "#product.name")
    public Product updateProduct(Product product) {
        // 模拟更新数据库中的产品
        updateProductInDatabase(product);
        return product;
    }
    
    @CacheEvict(value = "products", key = "#name")
    public void deleteProduct(String name) {
        // 模拟从数据库删除产品
        deleteProductFromDatabase(name);
    }
    
    private Product fetchProductFromDatabase(String name) {
        // 模拟数据库查询
        Product product = new Product();
        product.setName(name);
        product.setPrice(999.00);
        product.setCategory("默认类别");
        return product;
    }
    
    private void updateProductInDatabase(Product product) {
        // 模拟数据库更新
    }
    
    private void deleteProductFromDatabase(String name) {
        // 模拟数据库删除
    }
}

public class CacheSteps {
    
    @Autowired
    private CachedProductService productService;
    
    @Autowired
    private CacheManager cacheManager;
    
    @Given("产品服务已配置缓存")
    public void productServiceIsConfiguredWithCache() {
        assertNotNull("Cache manager should be available", cacheManager);
        assertNotNull("Products cache should be available", cacheManager.getCache("products"));
    }
    
    @When("第一次获取产品 {string}")
    public void getProductFirstTime(String productName) {
        Product product = productService.getProductByName(productName);
        assertNotNull("Product should not be null", product);
    }
    
    @And("第二次获取产品 {string}")
    public void getProductSecondTime(String productName) {
        Product product = productService.getProductByName(productName);
        assertNotNull("Product should not be null", product);
    }
    
    @Then("产品 {string} 应该从缓存获取")
    public void productShouldBeRetrievedFromCache(String productName) {
        Cache productsCache = cacheManager.getCache("products");
        assertNotNull("Products cache should not be null", productsCache);
        assertNotNull("Product should be in cache", productsCache.get(productName));
    }
    
    @When("更新产品 {string} 的价格")
    public void updateProductPrice(String productName) {
        Product product = productService.getProductByName(productName);
        product.setPrice(899.00);
        productService.updateProduct(product);
    }
    
    @Then("缓存中的产品 {string} 应该被更新")
    public void productInCacheShouldBeUpdated(String productName) {
        Cache productsCache = cacheManager.getCache("products");
        Product cachedProduct = productsCache.get(productName, Product.class);
        assertEquals("Product price should be updated", 899.00, cachedProduct.getPrice(), 0.01);
    }
}
```

## 测试数据优化

### 使用轻量级测试数据

#### 最小化测试数据

```gherkin
# 好的做法：使用最小化的测试数据
Scenario: 验证产品搜索功能
  Given 系统包含产品 "iPhone 14"，价格为 999.00
  When 用户搜索 "iPhone"
  Then 系统应该返回 "iPhone 14"

# 不好的做法：使用过多的测试数据
Scenario: 验证产品搜索功能
  Given 系统包含以下产品:
    | 产品名称 | 品牌   | 价格   | 类别 | 描述 | 重量 | 尺寸 | 颜色 | 材质 | 保修期 | 产地 | 库存 | 销量 | 评分 | 评论数 |
    | iPhone 14 | Apple  | 999.00 | 手机 | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... |
    | Galaxy S23 | Samsung | 899.00 | 手机 | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... |
    | ...更多产品... |
  When 用户搜索 "iPhone"
  Then 系统应该返回 "iPhone 14"
```

#### 使用数据构建器模式

```java
public class ProductBuilder {
    private String name = "默认产品";
    private String brand = "默认品牌";
    private double price = 0.00;
    private String category = "默认类别";
    private String description = "默认描述";
    
    public ProductBuilder withName(String name) {
        this.name = name;
        return this;
    }
    
    public ProductBuilder withBrand(String brand) {
        this.brand = brand;
        return this;
    }
    
    public ProductBuilder withPrice(double price) {
        this.price = price;
        return this;
    }
    
    public ProductBuilder withCategory(String category) {
        this.category = category;
        return this;
    }
    
    public ProductBuilder withDescription(String description) {
        this.description = description;
        return this;
    }
    
    public Product build() {
        Product product = new Product();
        product.setName(name);
        product.setBrand(brand);
        product.setPrice(price);
        product.setCategory(category);
        product.setDescription(description);
        return product;
    }
}

public class ProductTestSteps {
    
    @Given("系统包含产品 {string}")
    public void systemContainsProduct(String productName) {
        Product product = new ProductBuilder()
            .withName(productName)
            .withPrice(999.00)
            .withCategory("手机")
            .build();
        
        productService.saveProduct(product);
    }
    
    @Given("系统包含产品 {string}，价格为 {double}")
    public void systemContainsProductWithPrice(String productName, double price) {
        Product product = new ProductBuilder()
            .withName(productName)
            .withPrice(price)
            .withCategory("手机")
            .build();
        
        productService.saveProduct(product);
    }
    
    @Given("系统包含产品 {string}，品牌为 {string}，价格为 {double}，类别为 {string}")
    public void systemContainsProductWithDetails(String productName, String brand, double price, String category) {
        Product product = new ProductBuilder()
            .withName(productName)
            .withBrand(brand)
            .withPrice(price)
            .withCategory(category)
            .build();
        
        productService.saveProduct(product);
    }
}
```

### 使用测试数据模板

#### 创建可重用的测试数据模板

```java
import java.util.HashMap;
import java.util.Map;

public class TestDataTemplates {
    
    public static Map<String, Object> getBasicProductTemplate() {
        Map<String, Object> template = new HashMap<>();
        template.put("name", "默认产品");
        template.put("brand", "默认品牌");
        template.put("price", 0.00);
        template.put("category", "默认类别");
        template.put("description", "默认描述");
        return template;
    }
    
    public static Map<String, Object> getIPhoneTemplate() {
        Map<String, Object> template = getBasicProductTemplate();
        template.put("name", "iPhone 14");
        template.put("brand", "Apple");
        template.put("price", 999.00);
        template.put("category", "手机");
        template.put("description", "最新款iPhone");
        return template;
    }
    
    public static Map<String, Object> getGalaxyTemplate() {
        Map<String, Object> template = getBasicProductTemplate();
        template.put("name", "Galaxy S23");
        template.put("brand", "Samsung");
        template.put("price", 899.00);
        template.put("category", "手机");
        template.put("description", "最新款Galaxy");
        return template;
    }
    
    public static Map<String, Object> getUserTemplate() {
        Map<String, Object> template = new HashMap<>();
        template.put("username", "默认用户");
        template.put("email", "default@example.com");
        template.put("password", "password");
        template.put("active", true);
        return template;
    }
    
    public static Map<String, Object> getAdminUserTemplate() {
        Map<String, Object> template = getUserTemplate();
        template.put("username", "admin");
        template.put("email", "admin@example.com");
        template.put("role", "ADMIN");
        return template;
    }
}

public class TemplateBasedSteps {
    
    @Given("系统包含iPhone产品")
    public void systemContainsIPhoneProduct() {
        Map<String, Object> productData = TestDataTemplates.getIPhoneTemplate();
        Product product = createProductFromTemplate(productData);
        productService.saveProduct(product);
    }
    
    @Given("系统包含Galaxy产品")
    public void systemContainsGalaxyProduct() {
        Map<String, Object> productData = TestDataTemplates.getGalaxyTemplate();
        Product product = createProductFromTemplate(productData);
        productService.saveProduct(product);
    }
    
    @Given("系统包含管理员用户")
    public void systemContainsAdminUser() {
        Map<String, Object> userData = TestDataTemplates.getAdminUserTemplate();
        User user = createUserFromTemplate(userData);
        userService.saveUser(user);
    }
    
    private Product createProductFromTemplate(Map<String, Object> template) {
        Product product = new Product();
        product.setName((String) template.get("name"));
        product.setBrand((String) template.get("brand"));
        product.setPrice((Double) template.get("price"));
        product.setCategory((String) template.get("category"));
        product.setDescription((String) template.get("description"));
        return product;
    }
    
    private User createUserFromTemplate(Map<String, Object> template) {
        User user = new User();
        user.setUsername((String) template.get("username"));
        user.setEmail((String) template.get("email"));
        user.setPassword((String) template.get("password"));
        user.setActive((Boolean) template.get("active"));
        if (template.containsKey("role")) {
            user.setRole((String) template.get("role"));
        }
        return user;
    }
}
```

## 测试环境配置

### 使用测试配置文件

#### 创建测试专用配置

```properties
# application-test.properties
# 数据库配置
spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1
spring.datasource.username=sa
spring.datasource.password=
spring.datasource.driver-class-name=org.h2.Driver

# JPA配置
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=false

# 日志配置
logging.level.root=WARN
logging.level.com.example.gherkin=INFO

# 缓存配置
spring.cache.type=simple
spring.cache.cache-names=products,users

# 外部服务配置
external.product-service.url=http://localhost:8080/api
external.order-service.url=http://localhost:8081/api
```

```java
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import io.cucumber.java.en.*;

@SpringBootTest
@ActiveProfiles("test")
public class TestEnvironmentSteps {
    
    @Autowired
    private Environment environment;
    
    @Given("测试环境已配置")
    public void testEnvironmentIsConfigured() {
        String[] activeProfiles = environment.getActiveProfiles();
        assertTrue("Test profile should be active", 
                  java.util.Arrays.asList(activeProfiles).contains("test"));
        
        String dataSourceUrl = environment.getProperty("spring.datasource.url");
        assertTrue("Data source should be H2 in-memory database", 
                  dataSourceUrl.contains("jdbc:h2:mem"));
    }
    
    @When("执行测试")
    public void executeTest() {
        // 测试逻辑
    }
    
    @Then("测试应该成功完成")
    public void testShouldCompleteSuccessfully() {
        // 验证测试结果
    }
}
```

### 使用测试容器

#### 配置测试容器

```java
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.containers.wait.strategy.Wait;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import io.cucumber.java.en.*;

@SpringBootTest
@ActiveProfiles("test")
@Testcontainers
public class TestContainerSteps {
    
    @Container
    private static final PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:13")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test")
            .waitingFor(Wait.forListeningPort());
    
    @Container
    private static final GenericContainer<?> redis = new GenericContainer<>("redis:6-alpine")
            .withExposedPorts(6379)
            .waitingFor(Wait.forListeningPort());
    
    @Given("测试容器已启动")
    public void testContainersAreStarted() {
        assertTrue("PostgreSQL container should be running", postgres.isRunning());
        assertTrue("Redis container should be running", redis.isRunning());
    }
    
    @When("连接到测试数据库")
    public void connectToTestDatabase() {
        // 测试数据库连接
        String jdbcUrl = postgres.getJdbcUrl();
        String username = postgres.getUsername();
        String password = postgres.getPassword();
        
        // 使用连接信息建立数据库连接
        // ...
    }
    
    @Then("应该能够执行数据库操作")
    public void shouldBeAbleToExecuteDatabaseOperations() {
        // 验证数据库操作
    }
}
```

## 性能监控

### 测试执行时间监控

#### 使用自定义插件监控测试性能

```java
import io.cucumber.plugin.ConcurrentEventListener;
import io.cucumber.plugin.event.EventPublisher;
import io.cucumber.plugin.event.TestCaseStarted;
import io.cucumber.plugin.event.TestCaseFinished;
import io.cucumber.plugin.event.TestRunFinished;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class PerformanceMonitoringPlugin implements ConcurrentEventListener {
    
    private final List<TestExecution> testExecutions = new ArrayList<>();
    private Instant testRunStartTime;
    
    @Override
    public void setEventPublisher(EventPublisher publisher) {
        publisher.registerHandlerFor(TestCaseStarted.class, this::handleTestCaseStarted);
        publisher.registerHandlerFor(TestCaseFinished.class, this::handleTestCaseFinished);
        publisher.registerHandlerFor(TestRunFinished.class, this::handleTestRunFinished);
    }
    
    private void handleTestCaseStarted(TestCaseStarted event) {
        TestExecution execution = new TestExecution();
        execution.setTestCase(event.getTestCase());
        execution.setStartTime(event.getInstant());
        testExecutions.add(execution);
    }
    
    private void handleTestCaseFinished(TestCaseFinished event) {
        TestExecution execution = findExecution(event.getTestCase());
        if (execution != null) {
            execution.setEndTime(event.getInstant());
            execution.setResult(event.getResult());
        }
    }
    
    private void handleTestRunFinished(TestRunFinished event) {
        generatePerformanceReport();
    }
    
    private TestExecution findExecution(TestCase testCase) {
        return testExecutions.stream()
                .filter(execution -> execution.getTestCase().equals(testCase))
                .findFirst()
                .orElse(null);
    }
    
    private void generatePerformanceReport() {
        // 计算总执行时间
        Duration totalDuration = Duration.between(
            testExecutions.get(0).getStartTime(),
            testExecutions.get(testExecutions.size() - 1).getEndTime()
        );
        
        // 按执行时间排序
        List<TestExecution> sortedByDuration = testExecutions.stream()
                .sorted((e1, e2) -> Long.compare(e2.getDuration(), e1.getDuration()))
                .collect(Collectors.toList());
        
        // 计算平均执行时间
        double avgDuration = testExecutions.stream()
                .mapToLong(TestExecution::getDuration)
                .average()
                .orElse(0.0);
        
        // 找出最慢的10个测试
        List<TestExecution> slowestTests = sortedByDuration.subList(0, Math.min(10, sortedByDuration.size()));
        
        // 按特性分组统计
        Map<String, List<TestExecution>> testsByFeature = testExecutions.stream()
                .collect(Collectors.groupingBy(execution -> 
                    execution.getTestCase().getUri().toString()));
        
        // 打印性能报告
        System.out.println("\n=== 测试性能报告 ===");
        System.out.println("总执行时间: " + totalDuration.toMillis() + "ms");
        System.out.println("平均执行时间: " + String.format("%.2f", avgDuration) + "ms");
        System.out.println("总测试数: " + testExecutions.size());
        
        System.out.println("\n最慢的10个测试:");
        for (int i = 0; i < slowestTests.size(); i++) {
            TestExecution execution = slowestTests.get(i);
            System.out.println((i + 1) + ". " + execution.getTestCase().getName() + 
                              " - " + execution.getDuration() + "ms");
        }
        
        System.out.println("\n按特性分组的执行时间:");
        for (Map.Entry<String, List<TestExecution>> entry : testsByFeature.entrySet()) {
            String feature = entry.getKey();
            List<TestExecution> tests = entry.getValue();
            long featureDuration = tests.stream().mapToLong(TestExecution::getDuration).sum();
            System.out.println(feature + ": " + featureDuration + "ms (" + tests.size() + " 个测试)");
        }
    }
    
    private static class TestExecution {
        private TestCase testCase;
        private Instant startTime;
        private Instant endTime;
        private Result result;
        
        public long getDuration() {
            return Duration.between(startTime, endTime).toMillis();
        }
        
        // Getter和Setter方法
        public TestCase getTestCase() { return testCase; }
        public void setTestCase(TestCase testCase) { this.testCase = testCase; }
        public Instant getStartTime() { return startTime; }
        public void setStartTime(Instant startTime) { this.startTime = startTime; }
        public Instant getEndTime() { return endTime; }
        public void setEndTime(Instant endTime) { this.endTime = endTime; }
        public Result getResult() { return result; }
        public void setResult(Result result) { this.result = result; }
    }
}
```

## 性能优化最佳实践

### 1. 合理使用并行执行

**原则**：根据测试特性和资源情况选择合适的并行策略。

**指导**：
- **特性级别并行**：适合特性之间相互独立的测试
- **场景级别并行**：适合场景之间相互独立的测试
- **注意线程安全**：确保共享资源和步骤定义的线程安全性

### 2. 优化测试数据

**原则**：使用最小化、轻量级的测试数据，避免不必要的复杂性。

**指导**：
- 只包含测试所需的关键数据
- 使用数据构建器模式创建测试对象
- 使用测试数据模板提高复用性

### 3. 使用模拟和存根

**原则**：使用模拟和存根替代真实的外部依赖，提高测试执行速度。

**指导**：
- 使用WireMock模拟REST服务
- 使用Testcontainers模拟数据库
- 使用内存数据库替代真实数据库

### 4. 合理使用缓存

**原则**：对频繁访问的数据使用缓存，减少重复计算和查询。

**指导**：
- 使用Caffeine缓存测试数据
- 使用Spring Cache缓存服务调用结果
- 注意缓存的失效和更新策略

### 5. 监控测试性能

**原则**：定期监控测试执行性能，识别性能瓶颈。

**指导**：
- 使用自定义插件监控测试执行时间
- 识别最慢的测试用例
- 按特性分组分析测试性能

### 6. 优化测试环境

**原则**：使用轻量级、快速启动的测试环境。

**指导**：
- 使用内存数据库
- 使用嵌入式服务器
- 优化Spring Boot测试配置

## 总结

Cucumber测试的性能优化是一个持续的过程，需要从多个方面入手，包括测试并行化、资源管理、缓存策略、测试数据优化和测试环境配置等。通过合理应用这些优化技巧，我们可以显著提高测试执行速度，缩短反馈周期，提高开发效率。

在实际项目中，应该根据具体情况选择合适的优化策略，并定期监控和评估测试性能，持续改进测试效率。通过掌握性能优化技巧，我们可以创建更加高效、可靠的BDD测试体系，支持快速迭代的开发流程。