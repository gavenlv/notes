# 6.4 依赖注入与测试上下文

## 引言

在复杂的BDD测试场景中，步骤定义类之间经常需要共享数据和状态。依赖注入(Dependency Injection, DI)和测试上下文(Test Context)是解决这一问题的两种主要方法。本章将深入探讨如何在Cucumber中有效地使用依赖注入和测试上下文，以创建更加灵活和可维护的测试。

## 依赖注入基础

### 什么是依赖注入

依赖注入是一种设计模式，它允许我们将对象的依赖关系从对象本身分离出来，由外部容器负责创建和注入这些依赖。在测试中，依赖注入可以帮助我们管理步骤定义类之间的共享服务和状态。

### Cucumber中的依赖注入选项

Cucumber支持多种依赖注入框架，包括：
- Spring Framework
- PicoContainer
- Guice
- Weld (CDI)

### 配置依赖注入

#### 使用Spring依赖注入

首先，添加必要的依赖：

```xml
<dependency>
    <groupId>io.cucumber</groupId>
    <artifactId>cucumber-spring</artifactId>
    <version>${cucumber.version}</version>
    <scope>test</scope>
</dependency>
```

创建Spring配置类：

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class TestConfiguration {
    
    @Bean
    public ProductService productService() {
        return new MockProductService();
    }
    
    @Bean
    public ShoppingCartService shoppingCartService() {
        return new MockShoppingCartService();
    }
    
    @Bean
    public TestContext testContext() {
        return new TestContext();
    }
}
```

创建步骤定义类并注入依赖：

```java
import io.cucumber.java.en.*;
import io.cucumber.spring.CucumberContextConfiguration;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@CucumberContextConfiguration
@SpringBootTest(classes = TestConfiguration.class)
public class ProductSteps {
    
    @Autowired
    private ProductService productService;
    
    @Autowired
    private TestContext testContext;
    
    @Given("系统包含以下产品:")
    public void systemContainsProducts(io.cucumber.datatable.DataTable productTable) {
        // 使用注入的ProductService
        List<Product> products = productTable.asList(Product.class);
        products.forEach(productService::saveProduct);
        
        // 将产品列表存储到测试上下文
        testContext.set("products", products);
    }
    
    @When("用户搜索产品 {string}")
    public void userSearchesForProduct(String productName) {
        Product product = productService.findByName(productName);
        testContext.set("searchResult", product);
    }
    
    @Then("系统应该显示产品 {string}")
    public void systemShouldDisplayProduct(String expectedProductName) {
        Product searchResult = testContext.get("searchResult", Product.class);
        assertEquals(expectedProductName, searchResult.getName());
    }
}
```

#### 使用PicoContainer依赖注入

添加PicoContainer依赖：

```xml
<dependency>
    <groupId>io.cucumber</groupId>
    <artifactId>cucumber-picocontainer</artifactId>
    <version>${cucumber.version}</version>
    <scope>test</scope>
</dependency>
```

创建共享服务类：

```java
public class SharedServices {
    private final ProductService productService;
    private final ShoppingCartService shoppingCartService;
    private final TestContext testContext;
    
    public SharedServices() {
        this.productService = new MockProductService();
        this.shoppingCartService = new MockShoppingCartService();
        this.testContext = new TestContext();
    }
    
    public ProductService getProductService() {
        return productService;
    }
    
    public ShoppingCartService getShoppingCartService() {
        return shoppingCartService;
    }
    
    public TestContext getTestContext() {
        return testContext;
    }
}
```

在步骤定义类中使用共享服务：

```java
import io.cucumber.java.en.*;
import javax.inject.Inject;

public class ProductSteps {
    
    @Inject
    private SharedServices sharedServices;
    
    @Given("系统包含以下产品:")
    public void systemContainsProducts(io.cucumber.datatable.DataTable productTable) {
        List<Product> products = productTable.asList(Product.class);
        products.forEach(sharedServices.getProductService()::saveProduct);
        sharedServices.getTestContext().set("products", products);
    }
    
    @When("用户搜索产品 {string}")
    public void userSearchesForProduct(String productName) {
        Product product = sharedServices.getProductService().findByName(productName);
        sharedServices.getTestContext().set("searchResult", product);
    }
    
    @Then("系统应该显示产品 {string}")
    public void systemShouldDisplayProduct(String expectedProductName) {
        Product searchResult = sharedServices.getTestContext().get("searchResult", Product.class);
        assertEquals(expectedProductName, searchResult.getName());
    }
}
```

## 测试上下文

### 什么是测试上下文

测试上下文是一个用于在步骤定义类之间共享数据和状态的机制。它提供了一个中央存储库，用于存储和检索测试执行期间的数据。

### 实现测试上下文

#### 基本测试上下文实现

```java
import java.util.HashMap;
import java.util.Map;

public class TestContext {
    private final Map<String, Object> data = new HashMap<>();
    
    public void set(String key, Object value) {
        data.put(key, value);
    }
    
    public <T> T get(String key, Class<T> type) {
        Object value = data.get(key);
        if (value == null) {
            return null;
        }
        return type.cast(value);
    }
    
    public Object get(String key) {
        return data.get(key);
    }
    
    public boolean contains(String key) {
        return data.containsKey(key);
    }
    
    public void remove(String key) {
        data.remove(key);
    }
    
    public void clear() {
        data.clear();
    }
    
    public Map<String, Object> getAll() {
        return new HashMap<>(data);
    }
}
```

#### 类型安全的测试上下文

```java
import java.util.HashMap;
import java.util.Map;
import java.util.function.Supplier;

public class TypeSafeTestContext {
    private final Map<Class<?>, Map<String, Object>> data = new HashMap<>();
    
    public <T> void set(Class<T> type, String key, T value) {
        data.computeIfAbsent(type, k -> new HashMap<>()).put(key, value);
    }
    
    public <T> T get(Class<T> type, String key) {
        Map<String, Object> typeMap = data.get(type);
        if (typeMap == null) {
            return null;
        }
        return type.cast(typeMap.get(key));
    }
    
    public <T> T getOrDefault(Class<T> type, String key, T defaultValue) {
        T value = get(type, key);
        return value != null ? value : defaultValue;
    }
    
    public <T> T getOrCreate(Class<T> type, String key, Supplier<T> supplier) {
        T value = get(type, key);
        if (value == null) {
            value = supplier.get();
            set(type, key, value);
        }
        return value;
    }
    
    public <T> boolean contains(Class<T> type, String key) {
        Map<String, Object> typeMap = data.get(type);
        return typeMap != null && typeMap.containsKey(key);
    }
    
    public <T> void remove(Class<T> type, String key) {
        Map<String, Object> typeMap = data.get(type);
        if (typeMap != null) {
            typeMap.remove(key);
        }
    }
    
    public void clear() {
        data.clear();
    }
}
```

### 使用测试上下文

#### 在步骤定义中使用测试上下文

```java
import io.cucumber.java.en.*;
import org.springframework.beans.factory.annotation.Autowired;

public class ProductSteps {
    
    @Autowired
    private TestContext testContext;
    
    @Autowired
    private ProductService productService;
    
    @Given("系统包含以下产品:")
    public void systemContainsProducts(io.cucumber.datatable.DataTable productTable) {
        List<Product> products = productTable.asList(Product.class);
        products.forEach(productService::saveProduct);
        testContext.set("products", products);
    }
    
    @When("用户搜索产品 {string}")
    public void userSearchesForProduct(String productName) {
        Product product = productService.findByName(productName);
        testContext.set("searchResult", product);
    }
    
    @Then("系统应该显示产品 {string}")
    public void systemShouldDisplayProduct(String expectedProductName) {
        Product searchResult = testContext.get("searchResult", Product.class);
        assertEquals(expectedProductName, searchResult.getName());
    }
}
```

```java
import io.cucumber.java.en.*;
import org.springframework.beans.factory.annotation.Autowired;

public class ShoppingCartSteps {
    
    @Autowired
    private TestContext testContext;
    
    @Autowired
    private ShoppingCartService shoppingCartService;
    
    @When("用户将搜索结果添加到购物车")
    public void userAddsSearchResultToCart() {
        Product searchResult = testContext.get("searchResult", Product.class);
        shoppingCartService.addProduct(searchResult);
        testContext.set("cartItems", shoppingCartService.getItems());
    }
    
    @Then("购物车应该包含 {int} 个商品")
    public void cartShouldContainItems(int expectedCount) {
        List<CartItem> cartItems = testContext.get("cartItems", List.class);
        assertEquals(expectedCount, cartItems.size());
    }
}
```

#### 使用类型安全的测试上下文

```java
import io.cucumber.java.en.*;
import org.springframework.beans.factory.annotation.Autowired;

public class ProductSteps {
    
    @Autowired
    private TypeSafeTestContext testContext;
    
    @Autowired
    private ProductService productService;
    
    @Given("系统包含以下产品:")
    public void systemContainsProducts(io.cucumber.datatable.DataTable productTable) {
        List<Product> products = productTable.asList(Product.class);
        products.forEach(productService::saveProduct);
        testContext.set(Product.class, "products", products);
    }
    
    @When("用户搜索产品 {string}")
    public void userSearchesForProduct(String productName) {
        Product product = productService.findByName(productName);
        testContext.set(Product.class, "searchResult", product);
    }
    
    @Then("系统应该显示产品 {string}")
    public void systemShouldDisplayProduct(String expectedProductName) {
        Product searchResult = testContext.get(Product.class, "searchResult");
        assertEquals(expectedProductName, searchResult.getName());
    }
}
```

## 高级依赖注入模式

### 使用工厂模式

```java
public class ServiceFactory {
    private final Map<Class<?>, Object> services = new HashMap<>();
    
    public <T> void register(Class<T> type, T service) {
        services.put(type, service);
    }
    
    @SuppressWarnings("unchecked")
    public <T> T get(Class<T> type) {
        Object service = services.get(type);
        if (service == null) {
            throw new IllegalArgumentException("未注册的服务类型: " + type.getName());
        }
        return (T) service;
    }
    
    public <T> T getOrCreate(Class<T> type, Supplier<T> supplier) {
        T service = get(type);
        if (service == null) {
            service = supplier.get();
            register(type, service);
        }
        return service;
    }
}
```

### 使用作用域管理

```java
public enum Scope {
    SCENARIO, // 场景级别，每个场景结束后清理
    FEATURE,  // 特性级别，每个特性结束后清理
    GLOBAL    // 全局级别，整个测试运行期间保持
}

public class ScopedServiceFactory {
    private final Map<Scope, Map<Class<?>, Object>> scopedServices = new HashMap<>();
    
    public ScopedServiceFactory() {
        for (Scope scope : Scope.values()) {
            scopedServices.put(scope, new HashMap<>());
        }
    }
    
    public <T> void register(Scope scope, Class<T> type, T service) {
        scopedServices.get(scope).put(type, service);
    }
    
    @SuppressWarnings("unchecked")
    public <T> T get(Class<T> type) {
        // 按作用域优先级查找服务
        for (Scope scope : Scope.values()) {
            Object service = scopedServices.get(scope).get(type);
            if (service != null) {
                return (T) service;
            }
        }
        throw new IllegalArgumentException("未注册的服务类型: " + type.getName());
    }
    
    public void clear(Scope scope) {
        scopedServices.get(scope).clear();
    }
}
```

## 测试上下文最佳实践

### 1. 使用描述性键名

**原则**：使用清晰、描述性的键名，避免使用模糊或缩写的名称。

**示例**：

```java
// 好的做法：使用描述性键名
testContext.set("searchedProduct", product);
testContext.set("userShoppingCart", cart);
testContext.set("lastOrder", order);

// 不好的做法：使用模糊的键名
testContext.set("p1", product);
testContext.set("c", cart);
testContext.set("o", order);
```

### 2. 使用类型安全的上下文

**原则**：优先使用类型安全的测试上下文，避免类型转换错误。

**示例**：

```java
// 好的做法：使用类型安全的上下文
typeSafeTestContext.set(Product.class, "searchResult", product);
Product product = typeSafeTestContext.get(Product.class, "searchResult");

// 不好的做法：使用非类型安全的上下文
testContext.set("searchResult", product);
Product product = testContext.get("searchResult", Product.class); // 需要显式类型转换
```

### 3. 限制上下文数据量

**原则**：只在测试上下文中存储必要的数据，避免存储大量或冗余数据。

### 4. 定期清理上下文

**原则**：在适当的时机（如场景结束后）清理测试上下文，避免内存泄漏和数据污染。

```java
import io.cucumber.java.After;

public class ContextCleanupHooks {
    
    @Autowired
    private TestContext testContext;
    
    @After
    public void cleanupContext() {
        testContext.clear();
    }
}
```

### 5. 使用常量定义键名

**原则**：使用常量定义常用的键名，避免拼写错误。

```java
public class ContextKeys {
    public static final String SEARCH_RESULT = "searchResult";
    public static final String SHOPPING_CART = "shoppingCart";
    public static final String CURRENT_USER = "currentUser";
    public static final String LAST_ORDER = "lastOrder";
}

// 使用常量
testContext.set(ContextKeys.SEARCH_RESULT, product);
Product product = testContext.get(ContextKeys.SEARCH_RESULT, Product.class);
```

## 依赖注入与测试上下文的结合

### 创建集成的依赖注入和上下文管理

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class TestConfiguration {
    
    @Bean
    public ProductService productService() {
        return new MockProductService();
    }
    
    @Bean
    public ShoppingCartService shoppingCartService() {
        return new MockShoppingCartService();
    }
    
    @Bean
    public TestContext testContext() {
        return new TestContext();
    }
    
    @Bean
    public TestContextManager testContextManager(TestContext testContext) {
        return new TestContextManager(testContext);
    }
}

public class TestContextManager {
    private final TestContext testContext;
    
    public TestContextManager(TestContext testContext) {
        this.testContext = testContext;
    }
    
    public void setCurrentUser(User user) {
        testContext.set("currentUser", user);
    }
    
    public User getCurrentUser() {
        return testContext.get("currentUser", User.class);
    }
    
    public void setCurrentProduct(Product product) {
        testContext.set("currentProduct", product);
    }
    
    public Product getCurrentProduct() {
        return testContext.get("currentProduct", Product.class);
    }
    
    public void setCurrentShoppingCart(ShoppingCart cart) {
        testContext.set("currentShoppingCart", cart);
    }
    
    public ShoppingCart getCurrentShoppingCart() {
        return testContext.get("currentShoppingCart", ShoppingCart.class);
    }
}
```

### 在步骤定义中使用集成的管理器

```java
import io.cucumber.java.en.*;
import org.springframework.beans.factory.annotation.Autowired;

public class UserSteps {
    
    @Autowired
    private TestContextManager contextManager;
    
    @Autowired
    private UserService userService;
    
    @Given("用户 {string} 已登录")
    public void userIsLoggedIn(String username) {
        User user = userService.findByUsername(username);
        contextManager.setCurrentUser(user);
    }
}
```

```java
import io.cucumber.java.en.*;
import org.springframework.beans.factory.annotation.Autowired;

public class ProductSteps {
    
    @Autowired
    private TestContextManager contextManager;
    
    @Autowired
    private ProductService productService;
    
    @When("用户查看产品 {string}")
    public void userViewsProduct(String productName) {
        Product product = productService.findByName(productName);
        contextManager.setCurrentProduct(product);
    }
}
```

```java
import io.cucumber.java.en.*;
import org.springframework.beans.factory.annotation.Autowired;

public class ShoppingCartSteps {
    
    @Autowired
    private TestContextManager contextManager;
    
    @Autowired
    private ShoppingCartService shoppingCartService;
    
    @When("用户将当前产品添加到购物车")
    public void userAddsCurrentProductToCart() {
        User currentUser = contextManager.getCurrentUser();
        Product currentProduct = contextManager.getCurrentProduct();
        
        ShoppingCart cart = shoppingCartService.getUserCart(currentUser);
        cart.addProduct(currentProduct);
        
        contextManager.setCurrentShoppingCart(cart);
    }
}
```

## 总结

依赖注入和测试上下文是Cucumber中管理步骤定义类之间共享数据和状态的重要机制。通过合理使用这些技术，我们可以创建更加灵活、可维护和可扩展的BDD测试。

在实际项目中，应该根据具体需求选择合适的依赖注入框架和测试上下文实现方式，并遵循最佳实践，确保测试的质量和可维护性。通过掌握依赖注入和测试上下文的使用，我们可以有效地管理复杂的测试场景，提高测试的可靠性和可读性。