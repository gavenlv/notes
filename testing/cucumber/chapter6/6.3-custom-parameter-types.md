# 6.3 自定义参数类型

## 引言

在Cucumber中，参数类型(Parameter Types)是一种强大的机制，允许我们将步骤中的文本参数转换为特定的Java对象。通过自定义参数类型，我们可以简化步骤定义，提高代码的可读性和可维护性，并使测试更加贴近业务语言。

## 参数类型基础

### 内置参数类型

Cucumber提供了一些内置的参数类型，可以直接在步骤定义中使用：

- `int`、`long`、`double`、`float`：数值类型
- `String`：字符串类型
- `boolean`：布尔类型
- `LocalDate`、`LocalTime`、`LocalDateTime`：日期时间类型

### 基本使用

```gherkin
Scenario: 添加产品到购物车
  Given 用户登录系统
  When 用户添加 "iPhone 14" 产品到购物车，数量为 2
  Then 购物车应该包含 2 个 "iPhone 14" 产品
```

```java
import io.cucumber.java.en.*;

public class ShoppingCartSteps {
    
    @When("用户添加 {string} 产品到购物车，数量为 {int}")
    public void userAddsProductToCart(String productName, int quantity) {
        cartService.addProduct(productName, quantity);
    }
    
    @Then("购物车应该包含 {int} 个 {string} 产品")
    public void cartShouldContainProducts(int quantity, String productName) {
        assertEquals(quantity, cartService.getProductQuantity(productName));
    }
}
```

## 创建自定义参数类型

### 基本语法

自定义参数类型通过`@ParameterType`注解定义：

```java
import io.cucumber.java.en.*;
import io.cucumber.java.ParameterType;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

public class CustomParameterTypes {
    
    @ParameterType("([0-9]{4})-([0-9]{2})-([0-9]{2})")
    public LocalDate isoDate(String year, String month, String day) {
        return LocalDate.of(
            Integer.parseInt(year),
            Integer.parseInt(month),
            Integer.parseInt(day)
        );
    }
    
    @ParameterType("iPhone (\\d+)")
    public Product iphoneModel(String model) {
        return new Product("iPhone " + model, "Apple", 999.00, "手机");
    }
    
    @ParameterType("(\\d+(?:\\.\\d+)?)\\s*(USD|CNY|EUR)")
    public Price price(String amount, String currency) {
        return new Price(Double.parseDouble(amount), currency);
    }
}
```

### 使用自定义参数类型

```gherkin
Scenario: 使用自定义参数类型
  Given 产品 "iPhone 14" 于 2023-09-15 发布
  And 产品价格为 999.99 USD
  When 用户购买产品
  Then 系统应该记录购买日期为 2023-09-15
  And 交易金额应该为 999.99 USD
```

```java
import io.cucumber.java.en.*;

public class PurchaseSteps {
    
    @Given("产品 {iphoneModel} 于 {isoDate} 发布")
    public void productIsReleasedOnDate(Product product, LocalDate releaseDate) {
        product.setReleaseDate(releaseDate);
        productService.saveProduct(product);
    }
    
    @And("产品价格为 {price}")
    public void productPriceIs(Price price) {
        currentProduct.setPrice(price);
    }
    
    @Then("系统应该记录购买日期为 {isoDate}")
    public void systemShouldRecordPurchaseDate(LocalDate expectedDate) {
        assertEquals(expectedDate, purchaseService.getPurchaseDate());
    }
    
    @And("交易金额应该为 {price}")
    public void transactionAmountShouldBe(Price expectedPrice) {
        assertEquals(expectedPrice, purchaseService.getTransactionAmount());
    }
}
```

## 高级参数类型

### 使用正则表达式组

正则表达式组允许我们从匹配的文本中提取多个部分：

```java
@ParameterType("([A-Z]{2})(\\d{4})")
public ProductCode productCode(String prefix, String number) {
    return new ProductCode(prefix, Integer.parseInt(number));
}

@ParameterType("(\\d{1,2})\\s*(January|February|March|April|May|June|July|August|September|October|November|December)\\s*(\\d{4})")
public LocalDate fullDate(String day, String month, String year) {
    Month monthEnum = Month.valueOf(month.toUpperCase());
    return LocalDate.of(
        Integer.parseInt(year),
        monthEnum,
        Integer.parseInt(day)
    );
}
```

### 使用可选参数

```java
@ParameterType("iPhone (\\d+)(?:\\s*(Pro|Max|Mini|Plus))?")
public Product iphoneModel(String model, String variant) {
    String fullName = "iPhone " + model;
    if (variant != null) {
        fullName += " " + variant;
    }
    return new Product(fullName, "Apple", 999.00, "手机");
}
```

### 使用枚举参数

```java
public enum ProductCategory {
    ELECTRONICS("电子产品"),
    CLOTHING("服装"),
    FOOD("食品"),
    BOOKS("图书");
    
    private final String displayName;
    
    ProductCategory(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
    
    @Override
    public String toString() {
        return displayName;
    }
}

@ParameterType("电子产品|服装|食品|图书")
public ProductCategory productCategory(String categoryName) {
    for (ProductCategory category : ProductCategory.values()) {
        if (category.getDisplayName().equals(categoryName)) {
            return category;
        }
    }
    throw new IllegalArgumentException("未知的产品类别: " + categoryName);
}
```

## 参数类型注册

### 使用TypeRegistryConfigurer

推荐的方式是实现`TypeRegistryConfigurer`接口来注册自定义参数类型：

```java
import io.cucumber.java.TypeRegistryConfigurer;
import io.cucumber.cucumberexpressions.ParameterType;
import java.util.Locale;

public class ParameterTypeRegistryConfigurer implements TypeRegistryConfigurer {
    
    @Override
    public Locale locale() {
        return Locale.CHINESE;
    }
    
    @Override
    public void configureTypeRegistry(io.cucumber.core.api.TypeRegistry typeRegistry) {
        // 注册产品代码参数类型
        typeRegistry.defineParameterType(new ParameterType<>(
            "productCode", // 名称
            "([A-Z]{2})(\\d{4})", // 正则表达式
            ProductCode.class, // 目标类型
            (String prefix, String number) -> new ProductCode(prefix, Integer.parseInt(number)), // 转换器
            false, // 是否用于匿名参数
            false // // 是否优先于内置类型
        ));
        
        // 注册价格参数类型
        typeRegistry.defineParameterType(new ParameterType<>(
            "price",
            "(\\d+(?:\\.\\d+)?)\\s*(USD|CNY|EUR)",
            Price.class,
            (String amount, String currency) -> new Price(Double.parseDouble(amount), currency),
            false,
            false
        ));
        
        // 注册产品类别参数类型
        typeRegistry.defineParameterType(new ParameterType<>(
            "productCategory",
            "电子产品|服装|食品|图书",
            ProductCategory.class,
            ProductCategory::fromDisplayName,
            false,
            false
        ));
    }
}
```

### 使用@ParameterType注解

也可以直接在步骤定义类中使用`@ParameterType`注解：

```java
import io.cucumber.java.en.*;
import io.cucumber.java.ParameterType;

public class ShoppingSteps {
    
    @ParameterType("([A-Z]{2})(\\d{4})")
    public ProductCode productCode(String prefix, String number) {
        return new ProductCode(prefix, Integer.parseInt(number));
    }
    
    @When("用户搜索产品代码为 {productCode} 的产品")
    public void userSearchesForProductByCode(ProductCode productCode) {
        searchService.searchByCode(productCode);
    }
}
```

## 复杂参数类型

### 自定义对象参数

```java
public class Product {
    private final String name;
    private final String brand;
    private final double price;
    private final String category;
    
    // 构造函数、getter和setter方法
}

@ParameterType("([^,]+),\\s*([^,]+),\\s*([^,]+),\\s*([^,]+)")
public Product product(String name, String brand, String price, String category) {
    return new Product(name.trim(), brand.trim(), Double.parseDouble(price.trim()), category.trim());
}
```

### 集合参数

```java
@ParameterType("([^,]+(?:,\\s*[^,]+)*)")
public List<String> productList(String items) {
    return Arrays.stream(items.split(","))
                 .map(String::trim)
                 .collect(Collectors.toList());
}
```

### 嵌套对象参数

```java
public class ProductSpecification {
    private final String color;
    private final String size;
    private final String material;
    
    // 构造函数、getter和setter方法
}

@ParameterType("([^:]+):\\s*([^;]+);\\s*([^:]+):\\s*([^;]+);\\s*([^:]+):\\s*([^;]+)")
public ProductSpecification productSpec(String colorKey, String colorValue, 
                                       String sizeKey, String sizeValue, 
                                       String materialKey, String materialValue) {
    return new ProductSpecification(colorValue.trim(), sizeValue.trim(), materialValue.trim());
}
```

## 参数类型最佳实践

### 1. 命名约定

**原则**：使用描述性名称，清晰表达参数类型的用途。

**示例**：

```java
// 好的做法：使用描述性名称
@ParameterType("iPhone (\\d+)")
public Product iphoneModel(String model) { ... }

@ParameterType("(\\d+(?:\\.\\d+)?)\\s*(USD|CNY|EUR)")
public Price price(String amount, String currency) { ... }

// 不好的做法：使用模糊的名称
@ParameterType("iPhone (\\d+)")
public Product type1(String model) { ... }

@ParameterType("(\\d+(?:\\.\\d+)?)\\s*(USD|CNY|EUR)")
public Price type2(String amount, String currency) { ... }
```

### 2. 正则表达式优化

**原则**：编写精确但不过于复杂的正则表达式，避免贪婪匹配和回溯。

**示例**：

```java
// 好的做法：使用非贪婪匹配和明确的字符类
@ParameterType("iPhone (\\d+)(?:\\s*(Pro|Max|Mini|Plus))?")
public Product iphoneModel(String model, String variant) { ... }

// 不好的做法：使用贪婪匹配和模糊的字符类
@ParameterType("iPhone (.*)")
public Product iphoneModel(String modelAndVariant) { ... }
```

### 3. 错误处理

**原则**：提供清晰的错误信息，帮助用户理解参数转换失败的原因。

**示例**：

```java
@ParameterType("([A-Z]{2})(\\d{4})")
public ProductCode productCode(String prefix, String number) {
    try {
        int num = Integer.parseInt(number);
        if (num < 1000 || num > 9999) {
            throw new IllegalArgumentException("产品代码数字部分必须在1000-9999之间，但得到: " + num);
        }
        return new ProductCode(prefix, num);
    } catch (NumberFormatException e) {
        throw new IllegalArgumentException("无效的数字格式: " + number, e);
    }
}
```

### 4. 参数类型复用

**原则**：创建可复用的参数类型，避免重复定义相似的转换逻辑。

**示例**：

```java
// 创建通用的货币参数类型
@ParameterType("(\\d+(?:\\.\\d+)?)\\s*([A-Z]{3})")
public Money money(String amount, String currency) {
    return new Money(Double.parseDouble(amount), Currency.getInstance(currency));
}

// 在多个场景中使用
@Given("产品价格为 {money}")
public void productPriceIs(Money price) { ... }

@When("用户支付 {money}")
public void userPays(Money amount) { ... }

@Then("账户余额应该为 {money}")
public void accountBalanceShouldBe(Money balance) { ... }
```

## 参数类型与数据表的结合

### 在数据表中使用自定义参数类型

```gherkin
Scenario: 在数据表中使用自定义参数类型
  Given 系统包含以下产品:
    | 产品代码 | 产品名称 | 价格     | 类别     |
    | AP1234   | iPhone 14 | 999.99 USD | 电子产品 |
    | SS5678   | Galaxy S23 | 899.99 USD | 电子产品 |
    | NK9012   | Air Max 90 | 120.00 USD | 服装     |
  When 用户搜索产品代码为 "AP1234" 的产品
  Then 系统应该显示产品 "iPhone 14"
  And 价格应该为 999.99 USD
```

### 步骤定义实现

```java
import io.cucumber.java.en.*;
import io.cucumber.datatable.DataTable;
import java.util.List;
import java.util.Map;

public class ProductSearchSteps {
    
    @Given("系统包含以下产品:")
    public void systemContainsProducts(DataTable productTable) {
        List<Map<String, String>> products = productTable.asMaps();
        
        for (Map<String, String> productData : products) {
            ProductCode code = new ProductCode(productData.get("产品代码"));
            String name = productData.get("产品名称");
            Price price = new Price(productData.get("价格"));
            ProductCategory category = ProductCategory.fromDisplayName(productData.get("类别"));
            
            Product product = new Product(code, name, price, category);
            productService.saveProduct(product);
        }
    }
    
    @When("用户搜索产品代码为 {productCode} 的产品")
    public void userSearchesForProductByCode(ProductCode productCode) {
        searchService.searchByCode(productCode);
    }
    
    @Then("系统应该显示产品 {string}")
    public void systemShouldDisplayProduct(String productName) {
        assertEquals(productName, searchService.getDisplayedProductName());
    }
    
    @And("价格应该为 {price}")
    public void priceShouldBe(Price expectedPrice) {
        assertEquals(expectedPrice, searchService.getDisplayedProductPrice());
    }
}
```

## 总结

自定义参数类型是Cucumber中的一个强大功能，它允许我们将步骤中的文本参数转换为特定的Java对象，从而简化步骤定义，提高代码的可读性和可维护性。

通过合理使用自定义参数类型，我们可以：
1. 使测试步骤更加贴近业务语言
2. 减少步骤定义中的重复代码
3. 提高测试的可读性和可维护性
4. 增强类型安全性
5. 提供更好的错误信息

在实际项目中，应该根据具体需求创建适当的自定义参数类型，并遵循最佳实践，确保测试的质量和可维护性。通过掌握自定义参数类型的使用，我们可以创建更加灵活和强大的BDD测试。