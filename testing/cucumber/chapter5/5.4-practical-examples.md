# 5.4 Hooks和标签的实际应用案例

## 引言

理论知识和实际应用之间存在差距，本章将通过多个实际案例展示Hooks和标签在真实项目中的应用方式。这些案例涵盖了Web测试、API测试、数据库测试、性能测试等不同场景，帮助读者更好地理解如何在实际项目中有效使用Hooks和标签。

## 案例1：Web应用测试

### 场景描述

我们需要测试一个电商网站的Web界面，包括用户登录、产品搜索、购物车管理等功能。测试需要在不同浏览器上运行，并且需要处理测试失败时的截图和日志记录。

### 特性文件

```gherkin
@web @smoke @high-priority
Feature: 用户登录功能

  @positive @critical
  Scenario: 使用有效凭据登录
    Given 用户在登录页面
    When 用户输入有效的用户名和密码
    Then 用户应该被成功登录到系统

  @negative @medium-priority
  Scenario: 使用无效凭据登录
    Given 用户在登录页面
    When 用户输入无效的用户名和密码
    Then 用户应该看到错误消息

  @slow @regression
  Scenario Outline: 使用不同类型的有效凭据登录
    Given 用户在登录页面
    When 用户输入用户名 "<用户名>" 和密码 "<密码>"
    Then 用户应该被成功登录到系统

    Examples:
      | 用户名 | 密码 |
      | admin | password |
      | user  | 123456  |

@web @regression @medium-priority
Feature: 产品搜索功能

  @smoke @critical
  Scenario: 搜索产品
    Given 用户在首页
    When 用户搜索产品 "iPhone"
    Then 系统应该显示相关的产品列表

  @slow @low-priority
  Scenario: 使用高级搜索功能
    Given 用户在产品搜索页面
    When 用户设置搜索条件 "类别:手机,品牌:Apple,价格范围:500-1000"
    Then 系统应该显示符合条件的产品
```

### Hooks实现

```java
import io.cucumber.java.*;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.apache.commons.io.FileUtils;
import java.io.File;
import java.io.IOException;
import java.util.concurrent.TimeUnit;

public class WebTestHooks {
    
    private static WebDriver driver;
    private static final String SCREENSHOT_DIR = "target/screenshots/";
    
    @BeforeAll
    public static void setUpClass() {
        // 创建截图目录
        new File(SCREENSHOT_DIR).mkdirs();
    }
    
    @Before(order = 1)
    public void setUp() {
        // 根据系统属性选择浏览器
        String browser = System.getProperty("browser", "chrome");
        
        switch (browser.toLowerCase()) {
            case "chrome":
                System.setProperty("webdriver.chrome.driver", "drivers/chromedriver");
                driver = new ChromeDriver();
                break;
            case "firefox":
                System.setProperty("webdriver.gecko.driver", "drivers/geckodriver");
                driver = new FirefoxDriver();
                break;
            default:
                throw new IllegalArgumentException("不支持的浏览器: " + browser);
        }
        
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
        driver.manage().window().maximize();
    }
    
    @Before("@slow")
    public void setUpForSlowTests() {
        // 为慢速测试设置更长的超时时间
        driver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS);
    }
    
    @Before("@critical")
    public void setUpForCriticalTests() {
        // 为关键测试设置额外的日志
        System.out.println("开始执行关键测试");
    }
    
    @After(order = 1)
    public void tearDown(Scenario scenario) {
        if (scenario.isFailed()) {
            // 测试失败时截图
            captureScreenshot(scenario);
        }
        
        if (driver != null) {
            driver.quit();
        }
    }
    
    @After("@critical")
    public void afterCriticalTest(Scenario scenario) {
        if (scenario.isFailed()) {
            // 关键测试失败时发送通知
            sendFailureNotification(scenario);
        }
    }
    
    @AfterStep
    public void afterStep(Scenario scenario) {
        // 每个步骤后检查是否有JavaScript错误
        checkForJavaScriptErrors();
    }
    
    @AfterAll
    public static void tearDownClass() {
        // 清理全局资源
        driver = null;
    }
    
    private void captureScreenshot(Scenario scenario) {
        try {
            TakesScreenshot takesScreenshot = (TakesScreenshot) driver;
            File sourceFile = takesScreenshot.getScreenshotAs(OutputType.FILE);
            String screenshotName = scenario.getName() + "_" + System.currentTimeMillis() + ".png";
            File destinationFile = new File(SCREENSHOT_DIR + screenshotName);
            
            FileUtils.copyFile(sourceFile, destinationFile);
            scenario.log("截图已保存: " + destinationFile.getAbsolutePath());
            scenario.embed(FileUtils.readFileToByteArray(destinationFile), "image/png");
        } catch (IOException e) {
            scenario.log("截图失败: " + e.getMessage());
        }
    }
    
    private void sendFailureNotification(Scenario scenario) {
        // 发送失败通知的实现
        System.out.println("关键测试失败通知: " + scenario.getName());
    }
    
    private void checkForJavaScriptErrors() {
        // 检查JavaScript错误的实现
    }
    
    public static WebDriver getDriver() {
        return driver;
    }
}
```

### 步骤定义

```java
import io.cucumber.java.en.*;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;
import java.time.Duration;

import static org.junit.jupiter.api.Assertions.*;

public class WebTestSteps {
    
    private final WebDriver driver = WebTestHooks.getDriver();
    private final WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
    
    @Given("用户在登录页面")
    public void userOnLoginPage() {
        driver.get("https://example.com/login");
    }
    
    @Given("用户在首页")
    public void userOnHomePage() {
        driver.get("https://example.com");
    }
    
    @Given("用户在产品搜索页面")
    public void userOnProductSearchPage() {
        driver.get("https://example.com/search");
    }
    
    @When("用户输入有效的用户名和密码")
    public void userEntersValidCredentials() {
        WebElement usernameField = wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("username")));
        WebElement passwordField = driver.findElement(By.id("password"));
        WebElement loginButton = driver.findElement(By.id("login-button"));
        
        usernameField.sendKeys("testuser");
        passwordField.sendKeys("password");
        loginButton.click();
    }
    
    @When("用户输入无效的用户名和密码")
    public void userEntersInvalidCredentials() {
        WebElement usernameField = wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("username")));
        WebElement passwordField = driver.findElement(By.id("password"));
        WebElement loginButton = driver.findElement(By.id("login-button"));
        
        usernameField.sendKeys("invaliduser");
        passwordField.sendKeys("wrongpassword");
        loginButton.click();
    }
    
    @When("用户输入用户名 {string} 和密码 {string}")
    public void userEntersUsernameAndPassword(String username, String password) {
        WebElement usernameField = wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("username")));
        WebElement passwordField = driver.findElement(By.id("password"));
        WebElement loginButton = driver.findElement(By.id("login-button"));
        
        usernameField.sendKeys(username);
        passwordField.sendKeys(password);
        loginButton.click();
    }
    
    @When("用户搜索产品 {string}")
    public void userSearchesForProduct(String productName) {
        WebElement searchField = wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("search")));
        WebElement searchButton = driver.findElement(By.id("search-button"));
        
        searchField.sendKeys(productName);
        searchButton.click();
    }
    
    @When("用户设置搜索条件 {string}")
    public void userSetsSearchConditions(String conditions) {
        // 解析搜索条件并设置相应的搜索参数
        String[] conditionPairs = conditions.split(",");
        for (String pair : conditionPairs) {
            String[] keyValue = pair.split(":");
            if (keyValue.length == 2) {
                String key = keyValue[0].trim();
                String value = keyValue[1].trim();
                
                switch (key) {
                    case "类别":
                        WebElement categoryDropdown = wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("category")));
                        // 选择类别
                        break;
                    case "品牌":
                        WebElement brandDropdown = driver.findElement(By.id("brand"));
                        // 选择品牌
                        break;
                    case "价格范围":
                        String[] priceRange = value.split("-");
                        if (priceRange.length == 2) {
                            WebElement minPriceField = driver.findElement(By.id("min-price"));
                            WebElement maxPriceField = driver.findElement(By.id("max-price"));
                            minPriceField.sendKeys(priceRange[0]);
                            maxPriceField.sendKeys(priceRange[1]);
                        }
                        break;
                }
            }
        }
        
        WebElement searchButton = driver.findElement(By.id("advanced-search-button"));
        searchButton.click();
    }
    
    @Then("用户应该被成功登录到系统")
    public void userShouldBeLoggedIn() {
        WebElement welcomeMessage = wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("welcome-message")));
        assertTrue(welcomeMessage.isDisplayed());
        assertTrue(welcomeMessage.getText().contains("欢迎"));
    }
    
    @Then("用户应该看到错误消息")
    public void userShouldSeeErrorMessage() {
        WebElement errorMessage = wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("error-message")));
        assertTrue(errorMessage.isDisplayed());
        assertTrue(errorMessage.getText().contains("错误"));
    }
    
    @Then("系统应该显示相关的产品列表")
    public void systemShouldDisplayRelatedProducts() {
        WebElement productResults = wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("product-results")));
        assertTrue(productResults.isDisplayed());
    }
    
    @Then("系统应该显示符合条件的产品")
    public void systemShouldDisplayMatchingProducts() {
        WebElement productResults = wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("product-results")));
        assertTrue(productResults.isDisplayed());
    }
}
```

## 案例2：API测试

### 场景描述

我们需要测试一个RESTful API，包括用户认证、产品管理、订单处理等功能。测试需要处理不同的HTTP状态码、响应格式和错误情况。

### 特性文件

```gherkin
@api @smoke @high-priority
Feature: 用户认证API

  @positive @critical
  Scenario: 使用有效凭据获取访问令牌
    Given API基础URL设置为 "https://api.example.com"
    And 请求头包含 "Content-Type": "application/json"
    When 用户发送 POST 请求到 "/auth/token"，请求体为:
      """
      {
        "username": "testuser",
        "password": "password"
      }
      """
    Then 响应状态码应该是 200
    And 响应应该包含字段 "access_token"

  @negative @medium-priority
  Scenario: 使用无效凭据获取访问令牌
    Given API基础URL设置为 "https://api.example.com"
    And 请求头包含 "Content-Type": "application/json"
    When 用户发送 POST 请求到 "/auth/token"，请求体为:
      """
      {
        "username": "invaliduser",
        "password": "wrongpassword"
      }
      """
    Then 响应状态码应该是 401
    And 响应应该包含字段 "error"

@api @regression @medium-priority
Feature: 产品管理API

  @smoke @critical
  Scenario: 获取产品列表
    Given API基础URL设置为 "https://api.example.com"
    And 请求头包含 "Content-Type": "application/json"
    And 用户已认证
    When 用户发送 GET 请求到 "/products"
    Then 响应状态码应该是 200
    And 响应应该包含字段 "products"

  @slow @low-priority
  Scenario Outline: 使用不同参数搜索产品
    Given API基础URL设置为 "https://api.example.com"
    And 请求头包含 "Content-Type": "application/json"
    And 用户已认证
    When 用户发送 GET 请求到 "/products?category=<类别>&brand=<品牌>&minPrice=<最低价格>&maxPrice=<最高价格>"
    Then 响应状态码应该是 200
    And 响应应该包含字段 "products"

    Examples:
      | 类别 | 品牌   | 最低价格 | 最高价格 |
      | 手机 | Apple  | 500      | 1000    |
      | 笔记本 |      | 1000     | 2000    |
```

### Hooks实现

```java
import io.cucumber.java.*;
import io.restassured.RestAssured;
import io.restassured.response.Response;
import io.restassured.specification.RequestSpecification;
import java.util.HashMap;
import java.util.Map;

import static io.restassured.RestAssured.given;

public class ApiTestHooks {
    
    private static RequestSpecification request;
    private static Response response;
    private static Map<String, String> authTokens = new HashMap<>();
    
    @Before(order = 1)
    public void setUp() {
        RestAssured.baseURI = "https://api.example.com";
        request = given();
        request.header("Content-Type", "application/json");
    }
    
    @Before("@smoke")
    public void setUpForSmokeTests() {
        // 为冒烟测试设置更短的超时时间
        request.timeout(5000);
    }
    
    @Before("@slow")
    public void setUpForSlowTests() {
        // 为慢速测试设置更长的超时时间
        request.timeout(30000);
    }
    
    @Before("@critical")
    public void setUpForCriticalTests() {
        // 为关键测试设置额外的日志
        System.out.println("开始执行关键API测试");
    }
    
    @Before("@api and not @auth")
    public void authenticateForApiTests() {
        // 为需要认证的API测试自动获取访问令牌
        if (!authTokens.containsKey("default")) {
            authenticate("testuser", "password");
        }
        request.header("Authorization", "Bearer " + authTokens.get("default"));
    }
    
    @After("@critical")
    public void afterCriticalApiTest(Scenario scenario) {
        if (scenario.isFailed()) {
            // 关键API测试失败时记录详细响应信息
            logDetailedResponse(scenario);
        }
    }
    
    @AfterStep
    public void afterStep(Scenario scenario) {
        // 每个步骤后记录响应时间
        if (response != null) {
            long responseTime = response.getTime();
            if (responseTime > 5000) {
                scenario.log("警告: API响应时间过长 (" + responseTime + "ms)");
            }
        }
    }
    
    private void authenticate(String username, String password) {
        Response authResponse = given()
            .header("Content-Type", "application/json")
            .body("{\"username\":\"" + username + "\",\"password\":\"" + password + "\"}")
            .post("/auth/token");
        
        if (authResponse.getStatusCode() == 200) {
            String accessToken = authResponse.jsonPath().getString("access_token");
            authTokens.put("default", accessToken);
        }
    }
    
    private void logDetailedResponse(Scenario scenario) {
        if (response != null) {
            scenario.log("响应状态码: " + response.getStatusCode());
            scenario.log("响应头: " + response.getHeaders().toString());
            scenario.log("响应体: " + response.getBody().asString());
        }
    }
    
    public static RequestSpecification getRequest() {
        return request;
    }
    
    public static Response getResponse() {
        return response;
    }
    
    public static void setResponse(Response response) {
        ApiTestHooks.response = response;
    }
}
```

### 步骤定义

```java
import io.cucumber.java.en.*;
import io.restassured.response.Response;
import io.restassured.specification.RequestSpecification;
import static io.restassured.RestAssured.given;
import static org.junit.jupiter.api.Assertions.*;

public class ApiTestSteps {
    
    private final RequestSpecification request = ApiTestHooks.getRequest();
    
    @Given("API基础URL设置为 {string}")
    public void setApiBaseUrl(String baseUrl) {
        // 基础URL已在Hooks中设置
    }
    
    @Given("请求头包含 {string}: {string}")
    public void setRequestHeader(String headerName, String headerValue) {
        request.header(headerName, headerValue);
    }
    
    @Given("用户已认证")
    public void userIsAuthenticated() {
        // 认证已在Hooks中处理
    }
    
    @When("用户发送 POST 请求到 {string}，请求体为:")
    public void userSendsPostRequest(String endpoint, String requestBody) {
        Response response = request.body(requestBody).post(endpoint);
        ApiTestHooks.setResponse(response);
    }
    
    @When("用户发送 GET 请求到 {string}")
    public void userSendsGetRequest(String endpoint) {
        Response response = request.get(endpoint);
        ApiTestHooks.setResponse(response);
    }
    
    @When("用户发送 GET 请求到 {string}?category={string}&brand={string}&minPrice={string}&maxPrice={string}")
    public void userSendsGetRequestWithParams(String endpoint, String category, String brand, String minPrice, String maxPrice) {
        RequestSpecification paramRequest = request;
        
        if (!category.isEmpty()) {
            paramRequest = paramRequest.queryParam("category", category);
        }
        if (!brand.isEmpty()) {
            paramRequest = paramRequest.queryParam("brand", brand);
        }
        if (!minPrice.isEmpty()) {
            paramRequest = paramRequest.queryParam("minPrice", minPrice);
        }
        if (!maxPrice.isEmpty()) {
            paramRequest = paramRequest.queryParam("maxPrice", maxPrice);
        }
        
        Response response = paramRequest.get(endpoint);
        ApiTestHooks.setResponse(response);
    }
    
    @Then("响应状态码应该是 {int}")
    public void responseStatusCodeShouldBe(int expectedStatusCode) {
        Response response = ApiTestHooks.getResponse();
        assertEquals(expectedStatusCode, response.getStatusCode());
    }
    
    @Then("响应应该包含字段 {string}")
    public void responseShouldContainField(String fieldName) {
        Response response = ApiTestHooks.getResponse();
        assertNotNull(response.jsonPath().get(fieldName));
    }
}
```

## 案例3：数据库测试

### 场景描述

我们需要测试数据库操作，包括数据插入、查询、更新和删除。测试需要处理事务管理、数据清理和并发访问等问题。

### 特性文件

```gherkin
@database @smoke @high-priority
Feature: 用户数据管理

  @positive @critical
  Scenario: 创建新用户
    Given 数据库连接已建立
    When 用户插入新用户数据:
      | 用户名 | 邮箱            | 年龄 | 状态   |
      | 张三   | zhangsan@example.com | 25   | 活跃   |
    Then 数据库应该包含用户 "张三"
    And 用户 "张三" 的邮箱应该是 "zhangsan@example.com"

  @negative @medium-priority
  Scenario: 创建重复用户
    Given 数据库连接已建立
    And 数据库已包含用户 "张三"
    When 用户尝试插入重复用户数据:
      | 用户名 | 邮箱            | 年龄 | 状态   |
      | 张三   | zhangsan2@example.com | 30   | 活跃   |
    Then 操作应该失败
    And 错误消息应该包含 "唯一约束"

@database @regression @medium-priority
Feature: 产品数据管理

  @smoke @critical
  Scenario: 查询产品列表
    Given 数据库连接已建立
    And 数据库已包含以下产品:
      | 产品名称 | 品牌   | 价格   | 类别 | 库存 |
      | iPhone 14 | Apple  | 999.00 | 手机 | 50   |
      | Galaxy S23 | Samsung | 899.00 | 手机 | 30   |
    When 用户查询所有产品
    Then 查询结果应该包含 2 个产品
    And 查询结果应该包含产品 "iPhone 14"

  @slow @low-priority
  Scenario Outline: 使用不同条件查询产品
    Given 数据库连接已建立
    And 数据库已包含多种产品
    When 用户使用条件 "<条件>" 查询产品
    Then 查询结果应该包含 "<结果数量>" 个产品

    Examples:
      | 条件               | 结果数量 |
      | 类别 = '手机'       | 2       |
      | 品牌 = 'Apple'     | 1       |
      | 价格 > 900         | 1       |
      | 库存 > 40          | 1       |
```

### Hooks实现

```java
import io.cucumber.java.*;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

public class DatabaseTestHooks {
    
    private static Connection connection;
    private static Properties config;
    
    @BeforeAll
    public static void setUpClass() throws SQLException {
        // 加载数据库配置
        config = loadDatabaseConfig();
        
        // 建立数据库连接
        String url = config.getProperty("db.url");
        String username = config.getProperty("db.username");
        String password = config.getProperty("db.password");
        
        connection = DriverManager.getConnection(url, username, password);
        
        // 设置自动提交为false，以便手动控制事务
        connection.setAutoCommit(false);
    }
    
    @Before(order = 1)
    public void setUp() throws SQLException {
        // 每个场景开始前，确保连接是有效的
        if (connection == null || connection.isClosed()) {
            String url = config.getProperty("db.url");
            String username = config.getProperty("db.username");
            String password = config.getProperty("db.password");
            
            connection = DriverManager.getConnection(url, username, password);
            connection.setAutoCommit(false);
        }
    }
    
    @Before("@slow")
    public void setUpForSlowTests() throws SQLException {
        // 为慢速测试设置更长的查询超时
        Statement statement = connection.createStatement();
        statement.execute("SET statement_timeout TO 30000");
        statement.close();
    }
    
    @After(order = 1)
    public void tearDown(Scenario scenario) throws SQLException {
        // 如果场景失败，回滚事务
        if (scenario.isFailed()) {
            connection.rollback();
            System.out.println("场景失败，事务已回滚");
        } else {
            // 场景成功，提交事务
            connection.commit();
            System.out.println("场景成功，事务已提交");
        }
    }
    
    @After("@cleanup")
    public void cleanupTestData() throws SQLException {
        // 清理测试数据
        Statement statement = connection.createStatement();
        statement.execute("DELETE FROM users WHERE username LIKE 'test_%'");
        statement.execute("DELETE FROM products WHERE name LIKE 'test_%'");
        statement.close();
        connection.commit();
    }
    
    @AfterAll
    public static void tearDownClass() throws SQLException {
        // 关闭数据库连接
        if (connection != null && !connection.isClosed()) {
            connection.close();
        }
    }
    
    private static Properties loadDatabaseConfig() {
        Properties props = new Properties();
        // 在实际项目中，这些配置应该从配置文件中读取
        props.setProperty("db.url", "jdbc:postgresql://localhost:5432/testdb");
        props.setProperty("db.username", "testuser");
        props.setProperty("db.password", "testpassword");
        return props;
    }
    
    public static Connection getConnection() {
        return connection;
    }
}
```

### 步骤定义

```java
import io.cucumber.java.en.*;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

public class DatabaseTestSteps {
    
    private final Connection connection = DatabaseTestHooks.getConnection();
    private List<Map<String, Object>> queryResults;
    
    @Given("数据库连接已建立")
    public void databaseConnectionIsEstablished() {
        assertNotNull(connection);
    }
    
    @Given("数据库已包含用户 {string}")
    public void databaseContainsUser(String username) throws SQLException {
        // 检查用户是否存在
        PreparedStatement statement = connection.prepareStatement(
            "SELECT COUNT(*) FROM users WHERE username = ?");
        statement.setString(1, username);
        ResultSet resultSet = statement.executeQuery();
        
        if (resultSet.next() && resultSet.getInt(1) == 0) {
            // 用户不存在，创建用户
            statement.close();
            statement = connection.prepareStatement(
                "INSERT INTO users (username, email, age, status) VALUES (?, ?, ?, ?)");
            statement.setString(1, username);
            statement.setString(2, username + "@example.com");
            statement.setInt(3, 25);
            statement.setString(4, "活跃");
            statement.executeUpdate();
        }
        
        statement.close();
    }
    
    @Given("数据库已包含以下产品:")
    public void databaseContainsProducts(io.cucumber.datatable.DataTable dataTable) throws SQLException {
        List<Map<String, String>> products = dataTable.asMaps(String.class, String.class);
        
        for (Map<String, String> product : products) {
            PreparedStatement statement = connection.prepareStatement(
                "INSERT INTO products (name, brand, price, category, stock) VALUES (?, ?, ?, ?, ?)");
            statement.setString(1, product.get("产品名称"));
            statement.setString(2, product.get("品牌"));
            statement.setDouble(3, Double.parseDouble(product.get("价格")));
            statement.setString(4, product.get("类别"));
            statement.setInt(5, Integer.parseInt(product.get("库存")));
            statement.executeUpdate();
            statement.close();
        }
    }
    
    @Given("数据库已包含多种产品")
    public void databaseContainsMultipleProducts() throws SQLException {
        // 插入多种产品用于测试
        Statement statement = connection.createStatement();
        statement.execute("INSERT INTO products (name, brand, price, category, stock) VALUES " +
            "('iPhone 14', 'Apple', 999.00, '手机', 50), " +
            "('Galaxy S23', 'Samsung', 899.00, '手机', 30), " +
            "('MacBook Pro', 'Apple', 2499.00, '笔记本', 15), " +
            "('ThinkPad X1', 'Lenovo', 1999.00, '笔记本', 20)");
        statement.close();
    }
    
    @When("用户插入新用户数据:")
    public void userInsertsNewUser(io.cucumber.datatable.DataTable dataTable) throws SQLException {
        Map<String, String> userData = dataTable.asMap(String.class, String.class);
        
        PreparedStatement statement = connection.prepareStatement(
            "INSERT INTO users (username, email, age, status) VALUES (?, ?, ?, ?)");
        statement.setString(1, userData.get("用户名"));
        statement.setString(2, userData.get("邮箱"));
        statement.setInt(3, Integer.parseInt(userData.get("年龄")));
        statement.setString(4, userData.get("状态"));
        
        try {
            statement.executeUpdate();
        } catch (SQLException e) {
            // 保存异常信息，以便在Then步骤中验证
            throw e;
        } finally {
            statement.close();
        }
    }
    
    @When("用户尝试插入重复用户数据:")
    public void userTriesToInsertDuplicateUser(io.cucumber.datatable.DataTable dataTable) {
        Map<String, String> userData = dataTable.asMap(String.class, String.class);
        
        try {
            PreparedStatement statement = connection.prepareStatement(
                "INSERT INTO users (username, email, age, status) VALUES (?, ?, ?, ?)");
            statement.setString(1, userData.get("用户名"));
            statement.setString(2, userData.get("邮箱"));
            statement.setInt(3, Integer.parseInt(userData.get("年龄")));
            statement.setString(4, userData.get("状态"));
            statement.executeUpdate();
            statement.close();
        } catch (SQLException e) {
            // 保存异常信息，以便在Then步骤中验证
            this.lastException = e;
        }
    }
    
    @When("用户查询所有产品")
    public void userQueriesAllProducts() throws SQLException {
        Statement statement = connection.createStatement();
        ResultSet resultSet = statement.executeQuery("SELECT * FROM products");
        
        queryResults = new ArrayList<>();
        while (resultSet.next()) {
            Map<String, Object> row = new java.util.HashMap<>();
            row.put("name", resultSet.getString("name"));
            row.put("brand", resultSet.getString("brand"));
            row.put("price", resultSet.getDouble("price"));
            row.put("category", resultSet.getString("category"));
            row.put("stock", resultSet.getInt("stock"));
            queryResults.add(row);
        }
        
        resultSet.close();
        statement.close();
    }
    
    @When("用户使用条件 {string} 查询产品")
    public void userQueriesProductsWithCondition(String condition) throws SQLException {
        String query = "SELECT * FROM products WHERE " + condition;
        Statement statement = connection.createStatement();
        ResultSet resultSet = statement.executeQuery(query);
        
        queryResults = new ArrayList<>();
        while (resultSet.next()) {
            Map<String, Object> row = new java.util.HashMap<>();
            row.put("name", resultSet.getString("name"));
            row.put("brand", resultSet.getString("brand"));
            row.put("price", resultSet.getDouble("price"));
            row.put("category", resultSet.getString("category"));
            row.put("stock", resultSet.getInt("stock"));
            queryResults.add(row);
        }
        
        resultSet.close();
        statement.close();
    }
    
    @Then("数据库应该包含用户 {string}")
    public void databaseShouldContainUser(String username) throws SQLException {
        PreparedStatement statement = connection.prepareStatement(
            "SELECT COUNT(*) FROM users WHERE username = ?");
        statement.setString(1, username);
        ResultSet resultSet = statement.executeQuery();
        
        assertTrue(resultSet.next());
        assertTrue(resultSet.getInt(1) > 0);
        
        resultSet.close();
        statement.close();
    }
    
    @Then("用户 {string} 的邮箱应该是 {string}")
    public void userEmailShouldBe(String username, String expectedEmail) throws SQLException {
        PreparedStatement statement = connection.prepareStatement(
            "SELECT email FROM users WHERE username = ?");
        statement.setString(1, username);
        ResultSet resultSet = statement.executeQuery();
        
        assertTrue(resultSet.next());
        assertEquals(expectedEmail, resultSet.getString("email"));
        
        resultSet.close();
        statement.close();
    }
    
    @Then("操作应该失败")
    public void operationShouldFail() {
        assertNotNull(lastException);
        assertTrue(lastException instanceof SQLException);
    }
    
    @Then("错误消息应该包含 {string}")
    public void errorMessageShouldContain(String expectedMessage) {
        assertNotNull(lastException);
        assertTrue(lastException.getMessage().contains(expectedMessage));
    }
    
    @Then("查询结果应该包含 {int} 个产品")
    public void queryResultShouldContainProducts(int expectedCount) {
        assertNotNull(queryResults);
        assertEquals(expectedCount, queryResults.size());
    }
    
    @Then("查询结果应该包含产品 {string}")
    public void queryResultShouldContainProduct(String productName) {
        assertNotNull(queryResults);
        boolean found = queryResults.stream()
            .anyMatch(row -> productName.equals(row.get("name")));
        assertTrue(found, "查询结果中未找到产品: " + productName);
    }
    
    private SQLException lastException;
}
```

## 案例4：性能测试

### 场景描述

我们需要测试系统在不同负载下的性能表现，包括响应时间、吞吐量和资源利用率等指标。

### 特性文件

```gherkin
@performance @smoke @high-priority
Feature: API性能测试

  @critical
  Scenario: 登录API性能测试
    Given API基础URL设置为 "https://api.example.com"
    When 用户发送 POST 请求到 "/auth/token" 10 次
    Then 平均响应时间应该小于 500 毫秒
    And 95%的请求响应时间应该小于 1000 毫秒
    And 所有请求都应该成功

  @slow @regression
  Scenario: 产品搜索API性能测试
    Given API基础URL设置为 "https://api.example.com"
    When 用户并发发送 50 个 GET 请求到 "/products"
    Then 平均响应时间应该小于 1000 毫秒
    And 95%的请求响应时间应该小于 2000 毫秒
    And 所有请求都应该成功

@performance @load-testing @medium-priority
Feature: 负载测试

  @slow
  Scenario: 高并发登录测试
    Given API基础URL设置为 "https://api.example.com"
    When 100 个并发用户同时登录
    Then 95%的用户应该成功登录
    And 平均登录时间应该小于 2000 毫秒
    And 系统错误率应该小于 1%
```

### Hooks实现

```java
import io.cucumber.java.*;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class PerformanceTestHooks {
    
    private static List<Long> responseTimes = new ArrayList<>();
    private static AtomicInteger successCount = new AtomicInteger(0);
    private static AtomicInteger failureCount = new AtomicInteger(0);
    private static ExecutorService executorService;
    
    @Before("@performance")
    public void setUpForPerformanceTests() {
        // 初始化性能测试数据
        responseTimes.clear();
        successCount.set(0);
        failureCount.set(0);
        
        // 创建线程池
        int threadPoolSize = Runtime.getRuntime().availableProcessors() * 2;
        executorService = Executors.newFixedThreadPool(threadPoolSize);
    }
    
    @Before("@slow")
    public void setUpForSlowTests() {
        // 为慢速测试设置更长的超时时间
        System.out.println("设置慢速测试环境");
    }
    
    @After("@performance")
    public void tearDownAfterPerformanceTests() {
        // 关闭线程池
        if (executorService != null) {
            executorService.shutdown();
            try {
                if (!executorService.awaitTermination(60, TimeUnit.SECONDS)) {
                    executorService.shutdownNow();
                }
            } catch (InterruptedException e) {
                executorService.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }
        
        // 打印性能统计信息
        printPerformanceStatistics();
    }
    
    private void printPerformanceStatistics() {
        if (responseTimes.isEmpty()) {
            System.out.println("没有收集到响应时间数据");
            return;
        }
        
        // 计算统计数据
        long sum = responseTimes.stream().mapToLong(Long::longValue).sum();
        double average = (double) sum / responseTimes.size();
        
        // 计算百分位数
        responseTimes.sort(Long::compareTo);
        int p95Index = (int) Math.ceil(0.95 * responseTimes.size()) - 1;
        long p95 = responseTimes.get(p95Index);
        
        System.out.println("性能测试统计:");
        System.out.println("请求数量: " + responseTimes.size());
        System.out.println("成功请求数: " + successCount.get());
        System.out.println("失败请求数: " + failureCount.get());
        System.out.println("平均响应时间: " + average + " 毫秒");
        System.out.println("95%响应时间: " + p95 + " 毫秒");
    }
    
    public static List<Long> getResponseTimes() {
        return responseTimes;
    }
    
    public static AtomicInteger getSuccessCount() {
        return successCount;
    }
    
    public static AtomicInteger getFailureCount() {
        return failureCount;
    }
    
    public static ExecutorService getExecutorService() {
        return executorService;
    }
}
```

### 步骤定义

```java
import io.cucumber.java.en.*;
import io.restassured.RestAssured;
import io.restassured.response.Response;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;

import static io.restassured.RestAssured.given;
import static org.junit.jupiter.api.Assertions.*;

public class PerformanceTestSteps {
    
    private final List<Long> responseTimes = PerformanceTestHooks.getResponseTimes();
    private final AtomicInteger successCount = PerformanceTestHooks.getSuccessCount();
    private final AtomicInteger failureCount = PerformanceTestHooks.getFailureCount();
    private final ExecutorService executorService = PerformanceTestHooks.getExecutorService();
    
    @Given("API基础URL设置为 {string}")
    public void setApiBaseUrl(String baseUrl) {
        RestAssured.baseURI = baseUrl;
    }
    
    @When("用户发送 POST 请求到 {string} {int} 次")
    public void userSendsPostRequestMultipleTimes(String endpoint, int times) throws InterruptedException {
        List<CompletableFuture<Void>> futures = new ArrayList<>();
        
        for (int i = 0; i < times; i++) {
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                try {
                    long startTime = System.currentTimeMillis();
                    
                    Response response = given()
                        .header("Content-Type", "application/json")
                        .body("{\"username\":\"testuser\",\"password\":\"password\"}")
                        .post(endpoint);
                    
                    long responseTime = System.currentTimeMillis() - startTime;
                    responseTimes.add(responseTime);
                    
                    if (response.getStatusCode() == 200) {
                        successCount.incrementAndGet();
                    } else {
                        failureCount.incrementAndGet();
                    }
                } catch (Exception e) {
                    failureCount.incrementAndGet();
                }
            }, executorService);
            
            futures.add(future);
        }
        
        // 等待所有请求完成
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
    }
    
    @When("用户并发发送 {int} 个 GET 请求到 {string}")
    public void userConcurrentlySendsGetRequests(int count, String endpoint) throws InterruptedException {
        List<CompletableFuture<Void>> futures = new ArrayList<>();
        
        for (int i = 0; i < count; i++) {
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                try {
                    long startTime = System.currentTimeMillis();
                    
                    Response response = given()
                        .header("Content-Type", "application/json")
                        .header("Authorization", "Bearer test-token")
                        .get(endpoint);
                    
                    long responseTime = System.currentTimeMillis() - startTime;
                    responseTimes.add(responseTime);
                    
                    if (response.getStatusCode() == 200) {
                        successCount.incrementAndGet();
                    } else {
                        failureCount.incrementAndGet();
                    }
                } catch (Exception e) {
                    failureCount.incrementAndGet();
                }
            }, executorService);
            
            futures.add(future);
        }
        
        // 等待所有请求完成
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
    }
    
    @When("{int} 个并发用户同时登录")
    public void concurrentUsersLogin(int userCount) throws InterruptedException {
        List<CompletableFuture<Void>> futures = new ArrayList<>();
        
        for (int i = 0; i < userCount; i++) {
            final int userId = i;
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                try {
                    long startTime = System.currentTimeMillis();
                    
                    Response response = given()
                        .header("Content-Type", "application/json")
                        .body("{\"username\":\"user" + userId + "\",\"password\":\"password\"}")
                        .post("/auth/token");
                    
                    long responseTime = System.currentTimeMillis() - startTime;
                    responseTimes.add(responseTime);
                    
                    if (response.getStatusCode() == 200) {
                        successCount.incrementAndGet();
                    } else {
                        failureCount.incrementAndGet();
                    }
                } catch (Exception e) {
                    failureCount.incrementAndGet();
                }
            }, executorService);
            
            futures.add(future);
        }
        
        // 等待所有请求完成
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
    }
    
    @Then("平均响应时间应该小于 {int} 毫秒")
    public void averageResponseTimeShouldBeLessThan(int maxAverageTime) {
        if (responseTimes.isEmpty()) {
            fail("没有收集到响应时间数据");
        }
        
        long sum = responseTimes.stream().mapToLong(Long::longValue).sum();
        double average = (double) sum / responseTimes.size();
        
        assertTrue(average < maxAverageTime, 
            "平均响应时间 " + average + " 毫秒超过了最大允许时间 " + maxAverageTime + " 毫秒");
    }
    
    @Then("{int}%的请求响应时间应该小于 {int} 毫秒")
    public void percentileResponseTimeShouldBeLessThan(int percentile, int maxTime) {
        if (responseTimes.isEmpty()) {
            fail("没有收集到响应时间数据");
        }
        
        // 计算百分位数
        List<Long> sortedTimes = new ArrayList<>(responseTimes);
        sortedTimes.sort(Long::compareTo);
        
        int index = (int) Math.ceil((percentile / 100.0) * sortedTimes.size()) - 1;
        long percentileTime = sortedTimes.get(index);
        
        assertTrue(percentileTime < maxTime, 
            percentile + "%的请求响应时间 " + percentileTime + " 毫秒超过了最大允许时间 " + maxTime + " 毫秒");
    }
    
    @Then("所有请求都应该成功")
    public void allRequestsShouldSucceed() {
        int totalRequests = successCount.get() + failureCount.get();
        assertEquals(totalRequests, successCount.get(), 
            "有 " + failureCount.get() + " 个请求失败");
    }
    
    @Then("{int}%的用户应该成功登录")
    public void percentageOfUsersShouldSuccessfullyLogin(int expectedPercentage) {
        int totalUsers = successCount.get() + failureCount.get();
        if (totalUsers == 0) {
            fail("没有用户登录");
        }
        
        double actualPercentage = (double) successCount.get() / totalUsers * 100;
        
        assertTrue(actualPercentage >= expectedPercentage, 
            "成功登录的用户比例 " + actualPercentage + "% 低于期望的 " + expectedPercentage + "%");
    }
    
    @Then("系统错误率应该小于 {int}%")
    public void systemErrorRateShouldBeLessThan(int maxErrorRate) {
        int totalRequests = successCount.get() + failureCount.get();
        if (totalRequests == 0) {
            fail("没有请求数据");
        }
        
        double actualErrorRate = (double) failureCount.get() / totalRequests * 100;
        
        assertTrue(actualErrorRate < maxErrorRate, 
            "系统错误率 " + actualErrorRate + "% 超过了最大允许错误率 " + maxErrorRate + "%");
    }
}
```

## 总结

通过以上四个实际案例，我们展示了Hooks和标签在不同测试场景中的应用：

1. **Web应用测试**：使用Hooks管理WebDriver生命周期、处理测试失败时的截图和日志记录
2. **API测试**：使用Hooks管理请求设置、认证和响应验证
3. **数据库测试**：使用Hooks管理数据库连接、事务和数据清理
4. **性能测试**：使用Hooks管理并发执行、性能数据收集和统计分析

这些案例展示了Hooks和标签的强大功能和灵活性，通过合理使用它们，我们可以创建更加高效、可维护和可靠的自动化测试套件。在实际项目中，可以根据具体需求调整和扩展这些案例中的实现方式。