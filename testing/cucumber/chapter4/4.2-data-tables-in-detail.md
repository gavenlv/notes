# 4.2 数据表详解

## 数据表基础

数据表（Data Tables）是Gherkin中用于表示表格数据的结构，可以在任何步骤中使用。数据表提供了一种清晰、结构化的方式来传递多组相关数据给步骤定义。

### 数据表的基本语法

```gherkin
Given 系统中有以下产品:
  | 产品ID | 产品名称    | 价格  | 库存 |
  | P001   | 笔记本电脑  | 5999  | 50   |
  | P002   | 智能手机    | 2999  | 100  |
  | P003   | 平板电脑    | 1999  | 75   |
```

### 数据表的位置

数据表可以出现在以下位置：
1. 在Given步骤之后，用于设置初始状态
2. 在When步骤之后，用于提供操作参数
3. 在Then步骤之后，用于验证预期结果

## 数据表的使用方式

### 1. 垂直表格（推荐）

垂直表格是最常见的数据表形式，第一行是表头，后续行是数据：

```gherkin
Given 系统中有以下用户:
  | username | email              | password     | role   |
  | admin    | admin@example.com  | AdminPass123 | admin  |
  | user1    | user1@example.com  | UserPass123  | user   |
  | user2    | user2@example.com  | UserPass123  | user   |
```

对应的步骤定义：

```java
@Given("系统中有以下用户:")
public void systemHasUsers(io.cucumber.datatable.DataTable dataTable) {
    List<Map<String, String>> data = dataTable.asMaps();
    for (Map<String, String> row : data) {
        String username = row.get("username");
        String email = row.get("email");
        String password = row.get("password");
        String role = row.get("role");
        
        // 创建用户逻辑
        userService.createUser(username, email, password, role);
    }
}
```

### 2. 水平表格

水平表格将数据以列的形式组织：

```gherkin
Given 用户信息如下:
  | admin    | admin@example.com  | AdminPass123 | admin  |
  | user1    | user1@example.com  | UserPass123  | user   |
  | user2    | user2@example.com  | UserPass123  | user   |
```

对应的步骤定义：

```java
@Given("用户信息如下:")
public void userInfoAsFollows(io.cucumber.datatable.DataTable dataTable) {
    List<List<String>> data = dataTable.asLists();
    for (List<String> row : data) {
        String username = row.get(0);
        String email = row.get(1);
        String password = row.get(2);
        String role = row.get(3);
        
        // 创建用户逻辑
        userService.createUser(username, email, password, role);
    }
}
```

## 数据表转换方法

Cucumber提供了多种方法来转换数据表：

### 1. asMaps()

将数据表转换为Map列表，每个Map代表一行数据：

```java
@Given("系统中有以下用户:")
public void systemHasUsers(io.cucumber.datatable.DataTable dataTable) {
    List<Map<String, String>> data = dataTable.asMaps();
    // 使用Map列表处理数据
}
```

### 2. asList()

将数据表转换为List列表，每个List代表一行数据：

```java
@Given("用户信息如下:")
public void userInfoAsFollows(io.cucumber.datatable.DataTable dataTable) {
    List<List<String>> data = dataTable.asLists();
    // 使用List列表处理数据
}
```

### 3. asList(Class)

将数据表转换为指定类型的对象列表：

```java
@Given("系统中有以下产品:")
public void systemHasProducts(List<Product> products) {
    // 直接使用Product对象列表
}
```

### 4. 自定义数据表转换器

使用`@DataTableType`注解创建自定义转换器：

```java
@DataTableType
public User userEntry(Map<String, String> entry) {
    return new User(
        entry.get("username"),
        entry.get("email"),
        entry.get("password"),
        entry.get("role")
    );
}

@Given("系统中有以下用户:")
public void systemHasUsers(List<User> users) {
    // 直接使用User对象列表
    for (User user : users) {
        userService.createUser(user);
    }
}
```

## 高级数据表技巧

### 1. 嵌套数据表

数据表可以包含复杂的数据结构：

```gherkin
Given 订单详情如下:
  | 订单ID | 客户   | 商品列表                      | 总金额 |
  | O001   | 张三   | "[{id: 'P001', qty: 2}, {id: 'P002', qty: 1}]" | 14997  |
  | O002   | 李四   | "[{id: 'P003', qty: 3}]"                 | 5997   |
```

对应的步骤定义：

```java
@Given("订单详情如下:")
public void orderDetailsAsFollows(io.cucumber.datatable.DataTable dataTable) {
    List<Map<String, String>> data = dataTable.asMaps();
    for (Map<String, String> row : data) {
        String orderId = row.get("订单ID");
        String customer = row.get("客户");
        String itemsJson = row.get("商品列表");
        BigDecimal totalAmount = new BigDecimal(row.get("总金额"));
        
        // 解析商品列表JSON
        List<OrderItem> items = parseItemsFromJson(itemsJson);
        
        // 创建订单
        Order order = new Order(orderId, customer, items, totalAmount);
        orderService.createOrder(order);
    }
}
```

### 2. 数据表中的空值处理

处理数据表中的空值：

```gherkin
Given 用户信息如下:
  | username | email              | phone       |
  | user1    | user1@example.com  | 1234567890  |
  | user2    | user2@example.com  |             |
  | user3    |                    | 9876543210  |
```

对应的步骤定义：

```java
@Given("用户信息如下:")
public void userInfoAsFollows(io.cucumber.datatable.DataTable dataTable) {
    List<Map<String, String>> data = dataTable.asMaps(String.class, String.class);
    for (Map<String, String> row : data) {
        String username = row.get("username");
        String email = row.get("email");
        String phone = row.get("phone");
        
        // 处理空值
        if (email == null || email.isEmpty()) {
            email = generateDefaultEmail(username);
        }
        
        if (phone == null || phone.isEmpty()) {
            phone = null; // 或者使用默认值
        }
        
        // 创建用户
        userService.createUser(username, email, phone);
    }
}
```

### 3. 数据表中的特殊字符

处理数据表中的特殊字符：

```gherkin
Given 产品描述如下:
  | 产品ID | 描述                     |
  | P001   | 高性能笔记本电脑，配备"Intel i7"处理器 |
  | P002   | 智能手机，支持5G网络       |
  | P003   | 平板电脑，10.1英寸显示屏   |
```

对应的步骤定义：

```java
@Given("产品描述如下:")
public void productDescriptionsAsFollows(io.cucumber.datatable.DataTable dataTable) {
    List<Map<String, String>> data = dataTable.asMaps();
    for (Map<String, String> row : data) {
        String productId = row.get("产品ID");
        String description = row.get("描述");
        
        // 创建产品
        Product product = new Product(productId, description);
        productService.createProduct(product);
    }
}
```

## 数据表最佳实践

### 1. 表头命名

- 使用清晰、有意义的表头名称
- 避免使用空格和特殊字符
- 保持命名一致性
- 使用驼峰命名或下划线分隔

```gherkin
# 好的表头命名
| username | emailAddress | phoneNumber | registrationDate |

# 不好的表头命名
| user name | e-mail | phone # | date |
```

### 2. 数据格式

- 保持数据格式一致
- 使用标准日期格式
- 数值使用统一的分隔符
- 布尔值使用一致的表示方式

```gherkin
# 好的数据格式
| username | email              | registrationDate | active |
| user1    | user1@example.com  | 2023-01-15       | true   |
| user2    | user2@example.com  | 2023-02-20       | false  |

# 不好的数据格式
| username | email              | reg_date   | is_active |
| user1    | user1@example.com  | 15/01/2023 | Y         |
| user2    | user2@example.com  | 2/20/23    | 1         |
```

### 3. 数据表大小

- 保持数据表简洁，避免过多行
- 考虑将大数据集拆分为多个场景
- 使用Scenario Outline处理大量相似数据
- 使用外部文件管理大量测试数据

### 4. 数据验证

- 在步骤定义中验证数据完整性
- 处理缺失或无效数据
- 提供有意义的错误消息
- 实现适当的默认值处理

## 数据表与Scenario Outline的比较

| 特性 | 数据表 | Scenario Outline |
|------|--------|------------------|
| 用途 | 在单个步骤中传递多组数据 | 参数化整个场景 |
| 语法 | 在步骤后使用表格 | 使用Examples关键字 |
| 灵活性 | 高，可以处理复杂结构 | 中等，适合简单参数 |
| 可读性 | 高，数据集中显示 | 高，场景清晰 |
| 维护性 | 中等，数据与步骤耦合 | 高，数据与场景分离 |

### 选择建议

- 使用数据表当：
  - 需要在单个步骤中处理多组数据
  - 数据结构复杂或嵌套
  - 数据与特定步骤紧密相关

- 使用Scenario Outline当：
  - 需要参数化整个场景
  - 数据相对简单
  - 需要为每组数据生成独立测试报告

## 总结

数据表是Cucumber中实现数据驱动测试的重要工具，它提供了一种清晰、结构化的方式来传递多组相关数据给步骤定义。通过合理使用数据表转换方法和高级技巧，我们可以创建灵活、可维护的测试用例。

在下一节中，我们将介绍Scenario Outline，这是另一种实现数据驱动测试的重要方式，特别适合参数化整个场景。