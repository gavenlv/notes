# 4.5 实践案例

## Overview

本节将通过几个实际案例展示如何在Cucumber中实现数据驱动测试。这些案例涵盖了不同的业务场景和测试需求，展示了数据驱动测试在实际项目中的应用方式。

## 案例1：电商产品搜索功能

### 业务需求

实现一个电商网站的产品搜索功能，需要测试不同搜索条件下的产品筛选结果。

### 特性文件

```gherkin
@search
Feature: 产品搜索功能
  作为网站用户
  我希望能够使用多种条件搜索产品
  以便快速找到我需要的商品

  @smoke
  Scenario Outline: 基本关键词搜索
    Given 产品目录包含以下产品:
      | name              | category    | price | stock | rating |
      | iPhone 13         | 手机        | 6999  | 50    | 4.5    |
      | Samsung Galaxy S22| 手机        | 5999  | 30    | 4.3    |
      | MacBook Pro       | 笔记本      | 12999 | 20    | 4.7    |
      | Dell XPS 13       | 笔记本      | 8999  | 25    | 4.2    |
      | AirPods Pro       | 耳机        | 1999  | 100   | 4.6    |
    When 用户使用关键词 "<keyword>" 搜索产品
    Then 搜索结果应该包含 "<expectedResult>" 个产品
    And 结果应该包含产品 "<expectedProduct>"

    Examples: 有效关键词
      | keyword | expectedResult | expectedProduct |
      | iPhone  | 1              | iPhone 13       |
      | MacBook | 1              | MacBook Pro     |
      | Pro     | 2              | MacBook Pro     |
      | 手机    | 2              | iPhone 13       |

    Examples: 无效关键词
      | keyword | expectedResult | expectedProduct |
      | Xbox    | 0              |                 |
      | 索尼    | 0              |                 |
      | 游戏    | 0              |                 |

  @regression
  Scenario Outline: 分类筛选搜索
    Given 产品目录包含以下产品:
      | name              | category    | price | stock | rating |
      | iPhone 13         | 手机        | 6999  | 50    | 4.5    |
      | Samsung Galaxy S22| 手机        | 5999  | 30    | 4.3    |
      | MacBook Pro       | 笔记本      | 12999 | 20    | 4.7    |
      | Dell XPS 13       | 笔记本      | 8999  | 25    | 4.2    |
      | AirPods Pro       | 耳机        | 1999  | 100   | 4.6    |
    When 用户选择分类 "<category>" 筛选产品
    Then 搜索结果应该包含 "<expectedResult>" 个产品
    And 所有产品都属于 "<category>" 分类

    Examples:
      | category | expectedResult |
      | 手机     | 2              |
      | 笔记本   | 2              |
      | 耳机     | 1              |

  @regression
  Scenario Outline: 价格范围搜索
    Given 产品目录包含以下产品:
      | name              | category    | price | stock | rating |
      | iPhone 13         | 手机        | 6999  | 50    | 4.5    |
      | Samsung Galaxy S22| 手机        | 5999  | 30    | 4.3    |
      | MacBook Pro       | 笔记本      | 12999 | 20    | 4.7    |
      | Dell XPS 13       | 笔记本      | 8999  | 25    | 4.2    |
      | AirPods Pro       | 耳机        | 1999  | 100   | 4.6    |
    When 用户设置价格范围从 "<minPrice>" 到 "<maxPrice>"
    Then 搜索结果应该包含 "<expectedResult>" 个产品
    And 所有产品价格都在 "<minPrice>" 到 "<maxPrice>" 范围内

    Examples:
      | minPrice | maxPrice | expectedResult |
      | 0        | 5000     | 1              |
      | 5000     | 10000    | 3              |
      | 10000    | 15000    | 1              |

  @regression
  Scenario Outline: 多条件组合搜索
    Given 产品目录包含以下产品:
      | name              | category    | price | stock | rating |
      | iPhone 13         | 手机        | 6999  | 50    | 4.5    |
      | Samsung Galaxy S22| 手机        | 5999  | 30    | 4.3    |
      | MacBook Pro       | 笔记本      | 12999 | 20    | 4.7    |
      | Dell XPS 13       | 笔记本      | 8999  | 25    | 4.2    |
      | AirPods Pro       | 耳机        | 1999  | 100   | 4.6    |
    When 用户使用关键词 "<keyword>" 和分类 "<category>" 搜索
    Then 搜索结果应该包含 "<expectedResult>" 个产品
    And 所有产品都属于 "<category>" 分类
    And 产品名称包含 "<keyword>"

    Examples:
      | keyword | category | expectedResult |
      | Pro     | 笔记本   | 1              |
      | Pro     | 手机     | 0              |
      | Dell    | 笔记本   | 1              |
```

### 步骤定义实现

```java
package com.example.ecommerce.stepdefinitions;

import com.example.ecommerce.model.Product;
import com.example.ecommerce.service.ProductService;
import com.example.ecommerce.service.SearchService;
import io.cucumber.java.en.Given;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;
import io.cucumber.datatable.DataTable;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

public class ProductSearchSteps {
    
    @Autowired
    private ProductService productService;
    
    @Autowired
    private SearchService searchService;
    
    @Given("产品目录包含以下产品:")
    public void productCatalogContainsFollowingProducts(DataTable dataTable) {
        List<Map<String, String>> products = dataTable.asMaps();
        products.forEach(productMap -> {
            Product product = new Product(
                productMap.get("name"),
                productMap.get("category"),
                Double.parseDouble(productMap.get("price")),
                Integer.parseInt(productMap.get("stock")),
                Double.parseDouble(productMap.get("rating"))
            );
            productService.addProduct(product);
        });
    }
    
    @When("用户使用关键词 {string} 搜索产品")
    public void userSearchesWithKeyword(String keyword) {
        searchService.searchByKeyword(keyword);
    }
    
    @When("用户选择分类 {string} 筛选产品")
    public void userFiltersByCategory(String category) {
        searchService.filterByCategory(category);
    }
    
    @When("用户设置价格范围从 {double} 到 {double}")
    public void userSetsPriceRange(double minPrice, double maxPrice) {
        searchService.filterByPriceRange(minPrice, maxPrice);
    }
    
    @When("用户使用关键词 {string} 和分类 {string} 搜索")
    public void userSearchesWithKeywordAndCategory(String keyword, String category) {
        searchService.searchByKeywordAndCategory(keyword, category);
    }
    
    @Then("搜索结果应该包含 {int} 个产品")
    public void searchResultsShouldContainProducts(int expectedCount) {
        List<Product> results = searchService.getSearchResults();
        assertEquals(expectedCount, results.size());
    }
    
    @Then("结果应该包含产品 {string}")
    public void resultsShouldContainProduct(String expectedProduct) {
        List<Product> results = searchService.getSearchResults();
        boolean found = results.stream()
            .anyMatch(product -> product.getName().equals(expectedProduct));
        assertTrue(found, "Expected product not found in results: " + expectedProduct);
    }
    
    @Then("所有产品都属于 {string} 分类")
    public void allProductsBelongToCategory(String expectedCategory) {
        List<Product> results = searchService.getSearchResults();
        assertTrue(results.stream().allMatch(product -> 
            product.getCategory().equals(expectedCategory)),
            "Not all products belong to category: " + expectedCategory);
    }
    
    @Then("所有产品价格都在 {double} 到 {double} 范围内")
    public void allProductsAreInPriceRange(double minPrice, double maxPrice) {
        List<Product> results = searchService.getSearchResults();
        assertTrue(results.stream().allMatch(product -> 
            product.getPrice() >= minPrice && product.getPrice() <= maxPrice),
            "Not all products are in price range: " + minPrice + " - " + maxPrice);
    }
    
    @Then("产品名称包含 {string}")
    public void productNameContains(String keyword) {
        List<Product> results = searchService.getSearchResults();
        assertTrue(results.stream().allMatch(product -> 
            product.getName().toLowerCase().contains(keyword.toLowerCase())),
            "Not all products contain keyword: " + keyword);
    }
}
```

### 参数转换器

```java
package com.example.ecommerce.transformers;

import com.example.ecommerce.model.Product;
import io.cucumber.java.ParameterType;
import org.springframework.stereotype.Component;

@Component
public class ProductParameterTransformers {
    
    @ParameterType("([0-9]+(?:\\.[0-9]{1,2})?)")
    public double price(String priceString) {
        return Double.parseDouble(priceString);
    }
    
    @ParameterType("(手机|笔记本|耳机|平板|相机)")
    public String category(String categoryString) {
        return categoryString;
    }
    
    @ParameterType("([A-Za-z0-9 ]+)")
    public String productName(String nameString) {
        return nameString.trim();
    }
}
```

## 案例2：银行账户管理系统

### 业务需求

实现一个银行账户管理系统，需要测试账户创建、存款、取款、转账等功能的边界条件和异常情况。

### 特性文件

```gherkin
@banking
Feature: 银行账户管理
  作为银行客户
  我希望能够管理我的银行账户
  以便进行存款、取款和转账等操作

  @smoke
  Scenario Outline: 账户创建
    Given 银行系统已初始化
    When 客户 "<customerName>" 创建类型为 "<accountType>" 的账户
    Then 账户创建成功，账户号为 "<accountNumber>"
    And 初始余额为 "<initialBalance>" 元
    And 账户状态为 "<accountStatus>"

    Examples:
      | customerName | accountType | accountNumber | initialBalance | accountStatus |
      | 张三         | 储蓄账户    | ACC001        | 0              | 活跃          |
      | 李四         | 支票账户    | ACC002        | 100            | 活跃          |
      | 王五         | 信用卡      | ACC003        | 0              | 活跃          |

  @regression
  Scenario Outline: 存款操作
    Given 账户 "<accountNumber>" 存在，余额为 "<initialBalance>" 元
    When 客户向账户 "<accountNumber>" 存入 "<amount>" 元
    Then 账户余额更新为 "<finalBalance>" 元
    And 交易记录显示存款 "<amount>" 元

    Examples: 正常存款
      | accountNumber | initialBalance | amount | finalBalance |
      | ACC001        | 1000           | 500    | 1500         |
      | ACC002        | 2000           | 1000   | 3000         |
      | ACC003        | 0              | 200    | 200          |

    Examples: 边界条件
      | accountNumber | initialBalance | amount | finalBalance |
      | ACC001        | 1000           | 0.01   | 1000.01      |
      | ACC002        | 2000           | 999999 | 1001999      |

  @regression
  Scenario Outline: 取款操作
    Given 账户 "<accountNumber>" 存在，余额为 "<initialBalance>" 元
    When 客户从账户 "<accountNumber>" 取出 "<amount>" 元
    Then 账户余额更新为 "<finalBalance>" 元
    And 交易记录显示取款 "<amount>" 元

    Examples: 正常取款
      | accountNumber | initialBalance | amount | finalBalance |
      | ACC001        | 1500           | 500    | 1000         |
      | ACC002        | 3000           | 1000   | 2000         |
      | ACC003        | 200            | 200    | 0            |

    Examples: 边界条件
      | accountNumber | initialBalance | amount | finalBalance |
      | ACC001        | 1000           | 1000   | 0            |
      | ACC002        | 2000           | 0.01   | 1999.99      |

  @regression
  Scenario Outline: 取款失败情况
    Given 账户 "<accountNumber>" 存在，余额为 "<initialBalance>" 元
    When 客户尝试从账户 "<accountNumber>" 取出 "<amount>" 元
    Then 取款操作失败，错误信息为 "<errorMessage>"
    And 账户余额保持为 "<initialBalance>" 元

    Examples:
      | accountNumber | initialBalance | amount | errorMessage                     |
      | ACC001        | 1000           | 1001   | 余额不足                         |
      | ACC002        | 2000           | 0      | 取款金额必须大于0                |
      | ACC003        | 200            | -100   | 取款金额必须大于0                |

  @regression
  Scenario Outline: 转账操作
    Given 账户 "<fromAccount>" 存在，余额为 "<fromBalance>" 元
    And 账户 "<toAccount>" 存在，余额为 "<toBalance>" 元
    When 客户从账户 "<fromAccount>" 向账户 "<toAccount>" 转账 "<amount>" 元
    Then 账户 "<fromAccount>" 余额更新为 "<fromFinalBalance>" 元
    And 账户 "<toAccount>" 余额更新为 "<toFinalBalance>" 元
    And 两笔交易记录被创建

    Examples:
      | fromAccount | fromBalance | toAccount | toBalance | amount | fromFinalBalance | toFinalBalance |
      | ACC001      | 1500        | ACC002    | 2000      | 500    | 1000             | 2500           |
      | ACC002      | 3000        | ACC003    | 200       | 1000   | 2000             | 1200           |
      | ACC003      | 200         | ACC001    | 1000      | 200    | 0                | 1200           |

  @regression
  Scenario Outline: 转账失败情况
    Given 账户 "<fromAccount>" 存在，余额为 "<fromBalance>" 元
    And 账户 "<toAccount>" 存在，余额为 "<toBalance>" 元
    When 客户尝试从账户 "<fromAccount>" 向账户 "<toAccount>" 转账 "<amount>" 元
    Then 转账操作失败，错误信息为 "<errorMessage>"
    And 账户 "<fromAccount>" 余额保持为 "<fromBalance>" 元
    And 账户 "<toAccount>" 余额保持为 "<toBalance>" 元
    And 没有交易记录被创建

    Examples:
      | fromAccount | fromBalance | toAccount | toBalance | amount | errorMessage                     |
      | ACC001      | 1000        | ACC002    | 2000      | 1001   | 余额不足                         |
      | ACC002      | 2000        | ACC003    | 200       | 0      | 转账金额必须大于0                |
      | ACC003      | 200         | ACC001    | 1000      | -100   | 转账金额必须大于0                |
      | ACC001      | 1000        | ACC001    | 1000      | 500    | 不能向同一账户转账                |
```

### 步骤定义实现

```java
package com.example.banking.stepdefinitions;

import com.example.banking.model.Account;
import com.example.banking.model.Transaction;
import com.example.banking.model.TransactionType;
import com.example.banking.service.AccountService;
import com.example.banking.service.TransactionService;
import io.cucumber.java.en.Given;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;
import io.cucumber.java.en.And;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class BankingAccountSteps {
    
    @Autowired
    private AccountService accountService;
    
    @Autowired
    private TransactionService transactionService;
    
    @Given("银行系统已初始化")
    public void bankSystemIsInitialized() {
        accountService.initialize();
        transactionService.initialize();
    }
    
    @Given("账户 {string} 存在，余额为 {double} 元")
    public void accountExistsWithBalance(String accountNumber, double balance) {
        Account account = accountService.getAccount(accountNumber);
        if (account == null) {
            account = accountService.createAccount(accountNumber, "测试客户", "储蓄账户", balance);
        } else {
            account.setBalance(balance);
            accountService.updateAccount(account);
        }
    }
    
    @Given("账户 {string} 存在，余额为 {double} 元")
    public void accountExistsWithBalance(String accountNumber, double initialBalance) {
        accountExistsWithBalance(accountNumber, initialBalance);
    }
    
    @And("账户 {string} 存在，余额为 {double} 元")
    public void andAccountExistsWithBalance(String accountNumber, double balance) {
        accountExistsWithBalance(accountNumber, balance);
    }
    
    @When("客户 {string} 创建类型为 {string} 的账户")
    public void customerCreatesAccount(String customerName, String accountType) {
        accountService.createAccount(customerName, accountType);
    }
    
    @When("客户向账户 {string} 存入 {double} 元")
    public void customerDepositsToAccount(String accountNumber, double amount) {
        accountService.deposit(accountNumber, amount);
    }
    
    @When("客户从账户 {string} 取出 {double} 元")
    public void customerWithdrawsFromAccount(String accountNumber, double amount) {
        try {
            accountService.withdraw(accountNumber, amount);
        } catch (Exception e) {
            // 存储异常信息，用于后续验证
            scenarioContext.setException(e);
        }
    }
    
    @When("客户尝试从账户 {string} 取出 {double} 元")
    public void customerTriesToWithdrawFromAccount(String accountNumber, double amount) {
        customerWithdrawsFromAccount(accountNumber, amount);
    }
    
    @When("客户从账户 {string} 向账户 {string} 转账 {double} 元")
    public void customerTransfersFromAccountToAccount(String fromAccount, String toAccount, double amount) {
        try {
            accountService.transfer(fromAccount, toAccount, amount);
        } catch (Exception e) {
            // 存储异常信息，用于后续验证
            scenarioContext.setException(e);
        }
    }
    
    @When("客户尝试从账户 {string} 向账户 {string} 转账 {double} 元")
    public void customerTriesToTransferFromAccountToAccount(String fromAccount, String toAccount, double amount) {
        customerTransfersFromAccountToAccount(fromAccount, toAccount, amount);
    }
    
    @Then("账户创建成功，账户号为 {string}")
    public void accountCreatedSuccessfullyWithNumber(String accountNumber) {
        Account account = accountService.getAccount(accountNumber);
        assertNotNull(account, "Account should be created: " + accountNumber);
    }
    
    @Then("初始余额为 {double} 元")
    public void initialBalanceIs(double expectedBalance) {
        // 这个方法需要与上一个方法结合使用，获取最新创建的账户
        // 这里简化处理，假设我们有一个方法获取最新创建的账户
        Account latestAccount = accountService.getLatestAccount();
        assertEquals(expectedBalance, latestAccount.getBalance(), 0.01);
    }
    
    @Then("账户状态为 {string}")
    public void accountStatusIs(String expectedStatus) {
        Account latestAccount = accountService.getLatestAccount();
        assertEquals(expectedStatus, latestAccount.getStatus());
    }
    
    @Then("账户余额更新为 {double} 元")
    public void accountBalanceUpdatedTo(double expectedBalance) {
        // 需要根据上下文获取当前操作的账户
        String accountNumber = scenarioContext.getCurrentAccountNumber();
        Account account = accountService.getAccount(accountNumber);
        assertEquals(expectedBalance, account.getBalance(), 0.01);
    }
    
    @Then("交易记录显示存款 {double} 元")
    public void transactionRecordShowsDeposit(double amount) {
        String accountNumber = scenarioContext.getCurrentAccountNumber();
        List<Transaction> transactions = transactionService.getTransactionsForAccount(accountNumber);
        
        boolean found = transactions.stream()
            .anyMatch(t -> t.getType() == TransactionType.DEPOSIT && 
                         t.getAmount() == amount);
        assertTrue(found, "Deposit transaction not found for amount: " + amount);
    }
    
    @Then("交易记录显示取款 {double} 元")
    public void transactionRecordShowsWithdrawal(double amount) {
        String accountNumber = scenarioContext.getCurrentAccountNumber();
        List<Transaction> transactions = transactionService.getTransactionsForAccount(accountNumber);
        
        boolean found = transactions.stream()
            .anyMatch(t -> t.getType() == TransactionType.WITHDRAWAL && 
                         t.getAmount() == amount);
        assertTrue(found, "Withdrawal transaction not found for amount: " + amount);
    }
    
    @Then("取款操作失败，错误信息为 {string}")
    public void withdrawalFailsWithErrorMessage(String expectedErrorMessage) {
        Exception exception = scenarioContext.getException();
        assertNotNull(exception, "Expected an exception but none was thrown");
        assertTrue(exception.getMessage().contains(expectedErrorMessage),
            "Expected error message: " + expectedErrorMessage + 
            ", but got: " + exception.getMessage());
    }
    
    @Then("账户 {string} 余额更新为 {double} 元")
    public void accountBalanceUpdatedTo(String accountNumber, double expectedBalance) {
        Account account = accountService.getAccount(accountNumber);
        assertEquals(expectedBalance, account.getBalance(), 0.01);
    }
    
    @Then("账户 {string} 余额保持为 {double} 元")
    public void accountBalanceRemains(String accountNumber, double expectedBalance) {
        accountBalanceUpdatedTo(accountNumber, expectedBalance);
    }
    
    @Then("两笔交易记录被创建")
    public void twoTransactionRecordsCreated() {
        String fromAccount = scenarioContext.getFromAccountNumber();
        String toAccount = scenarioContext.getToAccountNumber();
        
        List<Transaction> fromTransactions = transactionService.getTransactionsForAccount(fromAccount);
        List<Transaction> toTransactions = transactionService.getTransactionsForAccount(toAccount);
        
        // 检查源账户的取款交易
        boolean fromTransactionFound = fromTransactions.stream()
            .anyMatch(t -> t.getType() == TransactionType.WITHDRAWAL);
        assertTrue(fromTransactionFound, "Withdrawal transaction not found for source account");
        
        // 检查目标账户的存款交易
        boolean toTransactionFound = toTransactions.stream()
            .anyMatch(t -> t.getType() == TransactionType.DEPOSIT);
        assertTrue(toTransactionFound, "Deposit transaction not found for destination account");
    }
    
    @Then("转账操作失败，错误信息为 {string}")
    public void transferFailsWithErrorMessage(String expectedErrorMessage) {
        Exception exception = scenarioContext.getException();
        assertNotNull(exception, "Expected an exception but none was thrown");
        assertTrue(exception.getMessage().contains(expectedErrorMessage),
            "Expected error message: " + expectedErrorMessage + 
            ", but got: " + exception.getMessage());
    }
    
    @Then("没有交易记录被创建")
    public void noTransactionRecordsCreated() {
        String fromAccount = scenarioContext.getFromAccountNumber();
        String toAccount = scenarioContext.getToAccountNumber();
        
        List<Transaction> fromTransactions = transactionService.getTransactionsForAccount(fromAccount);
        List<Transaction> toTransactions = transactionService.getTransactionsForAccount(toAccount);
        
        // 简化处理，假设我们检查的是最近的交易
        // 实际实现可能需要更复杂的逻辑
        assertTrue(fromTransactions.isEmpty() || toTransactions.isEmpty(),
            "Expected no transactions to be created");
    }
}
```

## 案例3：API测试数据驱动

### 业务需求

测试一个RESTful API的各种输入和输出情况，包括正常请求、边界条件和错误处理。

### 特性文件

```gherkin
@api
Feature: 用户管理API测试
  作为API开发者
  我希望验证用户管理API的各种输入和输出
  以确保API的正确性和可靠性

  @smoke
  Scenario Outline: 创建用户API
    Given API服务已启动
    When 客户端发送POST请求到 "/api/users" 请求体为:
      """
      {
        "username": "<username>",
        "email": "<email>",
        "password": "<password>",
        "firstName": "<firstName>",
        "lastName": "<lastName>"
      }
      """
    Then 响应状态码为 "<statusCode>"
    And 响应内容包含用户ID
    And 数据库中存在用户 "<username>"

    Examples: 有效用户数据
      | username | email               | password    | firstName | lastName | statusCode |
      | user1    | user1@example.com   | Password123 | John      | Doe      | 201        |
      | user2    | user2@example.com   | StrongPass  | Jane      | Smith    | 201        |
      | user3    | user3@example.com   | MyPass123   | Bob       | Johnson  | 201        |

    Examples: 无效用户数据
      | username | email               | password    | firstName | lastName | statusCode |
      |          | user1@example.com   | Password123 | John      | Doe      | 400        |
      | user1    | invalid-email       | Password123 | John      | Doe      | 400        |
      | user1    | user1@example.com   | 123         | John      | Doe      | 400        |
      | user1    | user1@example.com   | Password123 |          | Doe      | 400        |

  @regression
  Scenario Outline: 获取用户API
    Given API服务已启动
    And 用户 "<username>" 存在
    When 客户端发送GET请求到 "/api/users/<username>"
    Then 响应状态码为 "<statusCode>"
    And 响应内容包含用户信息

    Examples:
      | username | statusCode |
      | user1    | 200        |
      | user2    | 200        |
      | nonexist | 404        |

  @regression
  Scenario Outline: 更新用户API
    Given API服务已启动
    And 用户 "<username>" 存在
    When 客户端发送PUT请求到 "/api/users/<username>" 请求体为:
      """
      {
        "email": "<email>",
        "firstName": "<firstName>",
        "lastName": "<lastName>"
      }
      """
    Then 响应状态码为 "<statusCode>"
    And 用户信息已更新

    Examples: 有效更新
      | username | email               | firstName | lastName | statusCode |
      | user1    | newemail@example.com| John      | Doe      | 200        |
      | user2    | updated@example.com | Jane      | Smith    | 200        |

    Examples: 无效更新
      | username | email         | firstName | lastName | statusCode |
      | user1    | invalid-email | John      | Doe      | 400        |
      | nonexist | test@test.com | Test      | User     | 404        |

  @regression
  Scenario Outline: 删除用户API
    Given API服务已启动
    And 用户 "<username>" 存在
    When 客户端发送DELETE请求到 "/api/users/<username>"
    Then 响应状态码为 "<statusCode>"
    And 用户 "<username>" 不存在

    Examples:
      | username | statusCode |
      | user1    | 204        |
      | user2    | 204        |
      | nonexist | 404        |

  @regression
  Scenario Outline: 分页查询用户API
    Given API服务已启动
    And 存在 "<totalUsers>" 个用户
    When 客户端发送GET请求到 "/api/users?page=<page>&size=<size>"
    Then 响应状态码为 200
    And 响应内容包含 "<expectedUsers>" 个用户
    And 响应内容包含分页信息

    Examples:
      | totalUsers | page | size | expectedUsers |
      | 50         | 0    | 10   | 10            |
      | 50         | 1    | 10   | 10            |
      | 50         | 4    | 10   | 10            |
      | 50         | 5    | 10   | 0             |
      | 50         | 0    | 20   | 20            |
      | 50         | 2    | 20   | 10            |

  @regression
  Scenario Outline: 搜索用户API
    Given API服务已启动
    And 存在以下用户:
      | username | email               | firstName | lastName |
      | john.doe | john@example.com    | John      | Doe      |
      | jane.smith| jane@example.com   | Jane      | Smith    |
      | bob.johnson| bob@example.com  | Bob       | Johnson  |
      | alice.williams| alice@example.com | Alice | Williams |
    When 客户端发送GET请求到 "/api/users/search?q=<query>"
    Then 响应状态码为 200
    And 响应内容包含 "<expectedCount>" 个用户

    Examples:
      | query | expectedCount |
      | john  | 2             |
      | smith | 1             |
      | alice | 1             |
      | xyz   | 0             |
```

### 步骤定义实现

```java
package com.example.api.stepdefinitions;

import com.example.api.model.User;
import com.example.api.service.UserService;
import io.cucumber.java.en.Given;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;
import io.cucumber.java.en.And;
import io.cucumber.datatable.DataTable;
import io.restassured.response.Response;
import io.restassured.specification.RequestSpecification;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.List;
import java.util.Map;

import static io.restassured.RestAssured.given;
import static org.junit.jupiter.api.Assertions.*;

public class UserApiSteps {
    
    @Autowired
    private UserService userService;
    
    private RequestSpecification request;
    private Response response;
    
    @Given("API服务已启动")
    public void apiServiceIsStarted() {
        request = given()
            .baseUri("http://localhost:8080")
            .contentType("application/json");
    }
    
    @Given("用户 {string} 存在")
    public void userExists(String username) {
        User user = userService.getUserByUsername(username);
        if (user == null) {
            // 创建一个测试用户
            user = new User(username, username + "@example.com", "Password123", "Test", "User");
            userService.createUser(user);
        }
    }
    
    @Given("存在 {int} 个用户")
    public void usersExist(int count) {
        // 清理现有用户
        userService.deleteAllUsers();
        
        // 创建指定数量的用户
        for (int i = 1; i <= count; i++) {
            User user = new User(
                "user" + i,
                "user" + i + "@example.com",
                "Password123",
                "First" + i,
                "Last" + i
            );
            userService.createUser(user);
        }
    }
    
    @Given("存在以下用户:")
    public void followingUsersExist(DataTable dataTable) {
        List<Map<String, String>> users = dataTable.asMaps();
        users.forEach(userMap -> {
            User user = new User(
                userMap.get("username"),
                userMap.get("email"),
                "Password123",
                userMap.get("firstName"),
                userMap.get("lastName")
            );
            userService.createUser(user);
        });
    }
    
    @When("客户端发送POST请求到 {string} 请求体为:")
    public void clientSendsPostRequestWithBody(String endpoint, String requestBody) {
        response = request
            .body(requestBody)
            .when()
            .post(endpoint);
    }
    
    @When("客户端发送GET请求到 {string}")
    public void clientSendsGetRequest(String endpoint) {
        response = request
            .when()
            .get(endpoint);
    }
    
    @When("客户端发送PUT请求到 {string} 请求体为:")
    public void clientSendsPutRequestWithBody(String endpoint, String requestBody) {
        response = request
            .body(requestBody)
            .when()
            .put(endpoint);
    }
    
    @When("客户端发送DELETE请求到 {string}")
    public void clientSendsDeleteRequest(String endpoint) {
        response = request
            .when()
            .delete(endpoint);
    }
    
    @Then("响应状态码为 {int}")
    public void responseStatusCodeIs(int expectedStatusCode) {
        assertEquals(expectedStatusCode, response.getStatusCode());
    }
    
    @Then("响应内容包含用户ID")
    public void responseContainsUserId() {
        String responseBody = response.getBody().asString();
        assertTrue(responseBody.contains("id"), "Response should contain user ID");
    }
    
    @Then("数据库中存在用户 {string}")
    public void userExistsInDatabase(String username) {
        User user = userService.getUserByUsername(username);
        assertNotNull(user, "User should exist in database: " + username);
    }
    
    @Then("响应内容包含用户信息")
    public void responseContainsUserInfo() {
        String responseBody = response.getBody().asString();
        assertTrue(responseBody.contains("username"), "Response should contain username");
        assertTrue(responseBody.contains("email"), "Response should contain email");
    }
    
    @Then("用户信息已更新")
    public void userInfoUpdated() {
        // 这个验证需要根据具体的更新内容进行
        // 这里简化处理，假设我们检查的是响应状态码
        assertEquals(200, response.getStatusCode());
    }
    
    @Then("用户 {string} 不存在")
    public void userDoesNotExist(String username) {
        User user = userService.getUserByUsername(username);
        assertNull(user, "User should not exist in database: " + username);
    }
    
    @Then("响应内容包含 {int} 个用户")
    public void responseContainsUsers(int expectedCount) {
        String responseBody = response.getBody().asString();
        // 这里简化处理，实际可能需要解析JSON并计算数组长度
        // 或者使用JSONPath查询
        assertTrue(responseBody.contains("\"content\""), "Response should contain content array");
        // 更详细的验证需要解析JSON
    }
    
    @Then("响应内容包含分页信息")
    public void responseContainsPaginationInfo() {
        String responseBody = response.getBody().asString();
        assertTrue(responseBody.contains("\"page\""), "Response should contain page info");
        assertTrue(responseBody.contains("\"size\""), "Response should contain size info");
        assertTrue(responseBody.contains("\"totalElements\""), "Response should contain total elements");
    }
}
```

## 总结

通过以上三个案例，我们可以看到数据驱动测试在不同场景下的应用：

1. **电商产品搜索功能**：展示了如何使用Scenario Outline和DataTable测试搜索功能的各种输入组合。
2. **银行账户管理系统**：展示了如何测试复杂的业务逻辑，包括边界条件和异常情况。
3. **API测试数据驱动**：展示了如何测试RESTful API的各种请求和响应情况。

这些案例共同展示了数据驱动测试的以下优势：
- 减少代码重复，提高测试效率
- 提高测试覆盖率，包括正常、边界和异常情况
- 增强测试的可维护性和可读性
- 便于添加新的测试用例

在实际项目中，可以根据具体需求选择合适的数据驱动测试方式，结合Scenario Outline、DataTable和参数转换器，创建高效、可维护的测试套件。