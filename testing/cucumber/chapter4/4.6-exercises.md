# 4.6 练习题

## 练习1：基础Scenario Outline实现

### 目标
掌握Scenario Outline的基本语法和使用方法，实现简单的数据驱动测试。

### 需求描述
创建一个计算器功能测试，使用Scenario Outline测试不同数字的加法运算。

### 任务要求
1. 创建一个特性文件，包含一个Scenario Outline用于测试加法运算
2. 创建相应的步骤定义类
3. 实现参数转换器处理数字输入
4. 确保测试能够正常运行

### 提示
- 使用`<parameter>`语法定义参数
- 在Examples部分提供测试数据
- 考虑使用`@ParameterType`注解处理数字参数

### 预期结果
特性文件应包含至少5组测试数据，包括正数、负数和零的情况。

## 练习2：DataTable高级应用

### 目标
掌握DataTable的高级用法，处理复杂的数据结构。

### 需求描述
创建一个用户批量注册功能测试，使用DataTable处理多个用户的注册信息。

### 任务要求
1. 创建一个特性文件，使用DataTable定义多个用户的注册信息
2. 实现步骤定义，能够处理DataTable中的用户数据
3. 添加数据验证逻辑，确保用户数据的有效性
4. 实现自定义DataTable转换器

### 提示
- 使用`asMaps()`方法处理DataTable
- 考虑实现`DataTableType`接口创建自定义转换器
- 添加数据验证步骤，检查必填字段

### 预期结果
特性文件应包含至少3个有效用户和2个无效用户的测试数据。

## 练习3：参数转换器实现

### 目标
掌握自定义参数转换器的创建和使用，处理复杂的数据类型转换。

### 需求描述
创建一个日期范围查询功能测试，实现自定义参数转换器处理各种日期格式。

### 任务要求
1. 创建一个特性文件，测试不同日期格式的查询
2. 实现多个参数转换器，处理不同的日期格式
3. 添加日期验证逻辑，确保日期的有效性
4. 实现日期范围计算功能

### 提示
- 使用正则表达式匹配不同的日期格式
- 考虑使用Java 8的日期时间API
- 添加异常处理，处理无效日期

### 预期结果
实现至少3种不同日期格式的转换器，包括ISO格式、美式格式和自定义格式。

## 练习4：复杂Scenario Outline应用

### 目标
掌握复杂Scenario Outline的应用，处理多参数组合测试。

### 需求描述
创建一个电商订单处理功能测试，测试不同订单参数组合的处理结果。

### 任务要求
1. 创建一个特性文件，使用Scenario Outline测试订单处理
2. 实现步骤定义，处理订单创建、支付和发货流程
3. 添加多个Examples块，按场景分类测试数据
4. 实现订单状态验证逻辑

### 提示
- 使用多个Examples块组织测试数据
- 考虑添加标签，用于选择性运行测试
- 实现状态转换逻辑，验证订单状态变化

### 预期结果
特性文件应包含正常订单、异常订单和边界条件的测试场景。

## 练习5：数据驱动测试与API集成

### 目标
掌握数据驱动测试与API集成的应用，测试RESTful API的各种输入和输出。

### 需求描述
创建一个产品管理API测试，使用数据驱动测试验证API的各种功能。

### 任务要求
1. 创建一个特性文件，测试产品API的各种操作
2. 实现API请求和响应处理的步骤定义
3. 使用Scenario Outline测试不同的API输入参数
4. 添加响应验证逻辑，确保API的正确性

### 提示
- 使用RestAssured或类似库处理HTTP请求
- 考虑使用JSON Schema验证响应结构
- 实现参数化测试，覆盖各种输入组合

### 预期结果
特性文件应包含产品创建、查询、更新和删除的测试场景，覆盖正常和异常情况。

## 练习6：数据驱动测试最佳实践

### 目标
应用数据驱动测试的最佳实践，优化现有测试代码。

### 需求描述
优化一个现有的测试套件，应用数据驱动测试的最佳实践，提高代码质量和可维护性。

### 任务要求
1. 分析现有测试代码，识别可以应用数据驱动测试的部分
2. 重构测试代码，使用Scenario Outline或DataTable优化测试
3. 实现参数转换器，提高代码的可读性和类型安全性
4. 添加测试数据管理，提高测试数据的可维护性

### 提示
- 遵循DRY（Don't Repeat Yourself）原则
- 考虑测试数据的组织和管理
- 实现清晰的错误处理和验证逻辑

### 预期结果
重构后的测试代码应更加简洁、可读和可维护，同时保持或提高测试覆盖率。

## 练习7：综合项目：数据驱动测试框架

### 目标
综合应用数据驱动测试的各种技术，创建一个简单的数据驱动测试框架。

### 需求描述
创建一个简单的数据驱动测试框架，支持从外部文件加载测试数据，并自动执行测试。

### 任务要求
1. 设计测试数据文件格式（JSON、CSV或YAML）
2. 实现测试数据加载器，从外部文件读取测试数据
3. 创建通用的步骤定义，能够处理动态测试数据
4. 实现测试结果报告，展示测试执行情况

### 提示
- 考虑使用Jackson或Gson处理JSON数据
- 实现灵活的数据映射机制
- 添加测试数据验证，确保数据的有效性

### 预期结果
创建一个完整的数据驱动测试框架，能够从外部文件加载测试数据并执行测试。

## 练习8：性能测试与数据驱动

### 目标
探索数据驱动测试在性能测试中的应用，测试系统在不同数据量下的表现。

### 需求描述
创建一个性能测试，使用数据驱动测试验证系统在不同数据量下的响应时间和资源使用情况。

### 任务要求
1. 创建一个特性文件，测试系统在不同数据量下的性能
2. 实现性能测试步骤，收集响应时间和资源使用数据
3. 使用Scenario Outline测试不同的数据量级别
4. 实现性能基准验证，确保系统性能符合要求

### 提示
- 考虑使用JMH或类似库进行性能测试
- 实现资源监控，收集CPU、内存使用情况
- 添加性能回归测试，确保性能不会下降

### 预期结果
特性文件应包含不同数据量级别的性能测试场景，并提供性能基准验证。

## 练习参考答案

### 练习1参考实现

#### 特性文件 (calculator.feature)

```gherkin
Feature: 计算器加法功能
  作为用户
  我希望能够使用计算器进行加法运算
  以便得到正确的计算结果

  Scenario Outline: 数字加法运算
    Given 计算器已启动
    When 用户输入 "<firstNumber>" 和 "<secondNumber>" 进行加法运算
    Then 计算器显示结果 "<result>"

    Examples:
      | firstNumber | secondNumber | result |
      | 5           | 3            | 8      |
      | 10          | 0            | 10     |
      | -5          | 5            | 0      |
      | -3          | -7           | -10    |
      | 0           | 0            | 0      |
```

#### 步骤定义 (CalculatorSteps.java)

```java
package com.example.calculator.stepdefinitions;

import io.cucumber.java.en.Given;
import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import io.cucumber.java.ParameterType;
import org.springframework.stereotype.Component;

import static org.junit.jupiter.api.Assertions.assertEquals;

@Component
public class CalculatorSteps {
    
    private Calculator calculator;
    private double result;
    
    @Given("计算器已启动")
    public void calculatorIsStarted() {
        calculator = new Calculator();
    }
    
    @When("用户输入 {double} 和 {double} 进行加法运算")
    public void userEntersNumbersAndAdds(double firstNumber, double secondNumber) {
        result = calculator.add(firstNumber, secondNumber);
    }
    
    @Then("计算器显示结果 {double}")
    public void calculatorDisplaysResult(double expectedResult) {
        assertEquals(expectedResult, result, 0.001);
    }
    
    @ParameterType("(-?\\d+(?:\\.\\d+)?)")
    public double number(String numberString) {
        return Double.parseDouble(numberString);
    }
    
    // 简单的计算器实现
    private static class Calculator {
        public double add(double a, double b) {
            return a + b;
        }
    }
}
```

### 练习2参考实现

#### 特性文件 (user-batch-registration.feature)

```gherkin
Feature: 用户批量注册功能
  作为系统管理员
  我希望能够批量注册用户
  以便快速创建多个用户账户

  Scenario: 批量注册有效用户
    Given 用户注册服务已启动
    When 管理员提交以下用户注册信息:
      | username | email               | password    | firstName | lastName |
      | user1    | user1@example.com   | Password123 | John      | Doe      |
      | user2    | user2@example.com   | StrongPass  | Jane      | Smith    |
      | user3    | user3@example.com   | MyPass123   | Bob       | Johnson  |
    Then 所有用户注册成功
    And 系统中存在3个用户

  Scenario: 批量注册包含无效用户
    Given 用户注册服务已启动
    When 管理员提交以下用户注册信息:
      | username | email               | password    | firstName | lastName |
      | user1    | user1@example.com   | Password123 | John      | Doe      |
      |          | user2@example.com   | StrongPass  | Jane      | Smith    |
      | user3    | invalid-email       | MyPass123   | Bob       | Johnson  |
    Then 只有有效用户注册成功
    And 系统中存在1个用户
    And 注册失败的用户数为2
```

#### 步骤定义 (UserBatchRegistrationSteps.java)

```java
package com.example.user.stepdefinitions;

import com.example.user.model.User;
import com.example.user.service.UserService;
import io.cucumber.java.en.Given;
import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import io.cucumber.datatable.DataTable;
import io.cucumber.java.DataTableType;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.List;
import java.util.Map;
import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;

public class UserBatchRegistrationSteps {
    
    @Autowired
    private UserService userService;
    
    private List<User> registeredUsers;
    private List<String> failedRegistrations;
    
    @Given("用户注册服务已启动")
    public void userRegistrationServiceIsStarted() {
        userService.initialize();
        registeredUsers = new ArrayList<>();
        failedRegistrations = new ArrayList<>();
    }
    
    @When("管理员提交以下用户注册信息:")
    public void adminSubmitsUserRegistrationInfo(DataTable dataTable) {
        List<User> users = dataTable.asList(User.class);
        
        for (User user : users) {
            try {
                User registeredUser = userService.registerUser(user);
                registeredUsers.add(registeredUser);
            } catch (Exception e) {
                failedRegistrations.add(user.getUsername());
            }
        }
    }
    
    @Then("所有用户注册成功")
    public void allUsersRegisteredSuccessfully() {
        assertEquals(3, registeredUsers.size());
        assertTrue(failedRegistrations.isEmpty());
    }
    
    @Then("系统中存在{int}个用户")
    public void systemContainsUsers(int expectedCount) {
        assertEquals(expectedCount, userService.getUserCount());
    }
    
    @Then("只有有效用户注册成功")
    public void onlyValidUsersRegisteredSuccessfully() {
        assertEquals(1, registeredUsers.size());
        assertEquals(2, failedRegistrations.size());
    }
    
    @Then("注册失败的用户数为{int}")
    public void failedRegistrationCountIs(int expectedCount) {
        assertEquals(expectedCount, failedRegistrations.size());
    }
    
    @DataTableType
    public User userEntry(Map<String, String> entry) {
        return new User(
            entry.get("username"),
            entry.get("email"),
            entry.get("password"),
            entry.get("firstName"),
            entry.get("lastName")
        );
    }
}
```

## 总结

这些练习题涵盖了数据驱动测试的各个方面，从基础的Scenario Outline到复杂的参数转换器和API集成。通过完成这些练习，您将能够：

1. 掌握Scenario Outline和DataTable的基本用法
2. 实现自定义参数转换器，处理复杂的数据类型
3. 应用数据驱动测试的最佳实践，提高代码质量
4. 集成数据驱动测试与API测试，创建全面的测试套件
5. 探索数据驱动测试在性能测试中的应用

建议按照从易到难的顺序完成这些练习，并在实际项目中应用所学知识，不断提高数据驱动测试的技能。