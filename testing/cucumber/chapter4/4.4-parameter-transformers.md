# 4.4 参数转换器详解

## Overview

参数转换器（Parameter Transformers）是Cucumber中用于将Gherkin特性文件中的文本参数转换为Java对象的机制。通过参数转换器，我们可以处理复杂的数据类型、验证输入数据、创建领域对象，并使步骤定义更加类型安全和可维护。

## 参数转换器类型

Cucumber提供了几种类型的参数转换器：

1. **内置转换器**：Cucumber自动提供的常见类型转换
2. **自定义转换器**：使用`@ParameterType`注解定义的转换器
3. **DataTable转换器**：用于处理数据表的转换器
4. **文档字符串转换器**：用于处理文档字符串的转换器

## 内置转换器

Cucumber自动支持以下类型的转换：

- 基本类型：`int`, `long`, `double`, `float`, `boolean`
- 字符串：`String`
- 日期时间：`Date`, `LocalDate`, `LocalTime`, `LocalDateTime`
- 枚举：`Enum`
- 大数字：`BigInteger`, `BigDecimal`
- 其他：`byte`, `short`, `char`

示例：

```java
Given 用户年龄为 {int} 岁
Given 用户余额为 {double} 元
Given 用户状态为 {boolean}
Given 注册日期为 {localDate}
Given 用户等级为 {userLevel}
```

## 自定义参数转换器

### 基本语法

使用`@ParameterType`注解定义自定义转换器：

```java
import io.cucumber.java.ParameterType;

public class ParameterTransformers {
    
    @ParameterType("([A-Z][a-z]+) ([A-Z][a-z]+)")
    public User fullName(String firstName, String lastName) {
        return new User(firstName, lastName);
    }
    
    @ParameterType("(\\d{4}-\\d{2}-\\d{2})")
    public LocalDate date(String dateString) {
        return LocalDate.parse(dateString);
    }
    
    @ParameterType("(active|inactive|pending)")
    public UserStatus status(String statusText) {
        return UserStatus.valueOf(statusText.toUpperCase());
    }
}
```

对应的步骤定义：

```java
Given 用户 {fullName} 存在
And 账户创建于 {date}
And 账户状态为 {status}
```

对应的Gherkin特性：

```gherkin
Given 用户 John Doe 存在
And 账户创建于 2023-01-15
And 账户状态为 active
```

### 正则表达式

参数转换器使用正则表达式匹配和提取参数：

```java
// 匹配邮箱
@ParameterType("([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})")
public Email email(String emailString) {
    return new Email(emailString);
}

// 匹配电话号码
@ParameterType("(\\+?[0-9]{1,3}?[-.\\s]?\\(?[0-9]{1,4}?\\)?[-.\\s]?[0-9]{1,4}[-.\\s]?[0-9]{1,9})")
public PhoneNumber phoneNumber(String phoneString) {
    return new PhoneNumber(phoneString);
}

// 匹配价格
@ParameterType("\\$([0-9]+(?:\\.[0-9]{2})?)")
public Money price(String priceString) {
    BigDecimal amount = new BigDecimal(priceString.substring(1));
    return new Money(amount, Currency.getInstance("USD"));
}
```

### 捕获组

正则表达式中的捕获组对应转换器方法的参数：

```java
// 单个捕获组
@ParameterType("(\\d{4}-\\d{2}-\\d{2})")
public LocalDate date(String dateString) {
    return LocalDate.parse(dateString);
}

// 多个捕获组
@ParameterType("(\\d{4})-(\\d{2})-(\\d{2})")
public LocalDate dateParts(String year, String month, String day) {
    return LocalDate.of(
        Integer.parseInt(year),
        Integer.parseInt(month),
        Integer.parseInt(day)
    );
}

// 命名捕获组（Java不支持，但可以使用注释说明）
@ParameterType("(\\d{4})-(\\d{2})-(\\d{2})") // year-month-day
public LocalDate dateWithNames(String year, String month, String day) {
    return LocalDate.of(
        Integer.parseInt(year),
        Integer.parseInt(month),
        Integer.parseInt(day)
    );
}
```

### 转换器命名

可以为转换器指定名称，在步骤定义中使用：

```java
@ParameterType(value = "(\\d{4}-\\d{2}-\\d{2})", name = "isoDate")
public LocalDate isoDate(String dateString) {
    return LocalDate.parse(dateString);
}

@ParameterType(value = "(\\d{1,2})/(\\d{1,2})/(\\d{4})", name = "usDate")
public LocalDate usDate(String month, String day, String year) {
    return LocalDate.of(
        Integer.parseInt(year),
        Integer.parseInt(month),
        Integer.parseInt(day)
    );
}
```

对应的步骤定义：

```java
Given 开始日期为 {isoDate}
And 结束日期为 {usDate}
```

对应的Gherkin特性：

```gherkin
Given 开始日期为 2023-01-15
And 结束日期为 02/28/2023
```

## 高级参数转换器

### 枚举转换器

```java
public enum OrderStatus {
    PENDING, PROCESSING, SHIPPED, DELIVERED, CANCELLED
}

@ParameterType("(pending|processing|shipped|delivered|cancelled)")
public OrderStatus orderStatus(String statusText) {
    return OrderStatus.valueOf(statusText.toUpperCase());
}

// 或者使用枚举的内置转换
@ParameterType(".*")  // 匹配任何文本
public OrderStatus anyOrderStatus(String statusText) {
    try {
        return OrderStatus.valueOf(statusText.toUpperCase());
    } catch (IllegalArgumentException e) {
        throw new IllegalArgumentException("Unknown order status: " + statusText);
    }
}
```

### 复杂对象转换器

```java
@ParameterType("(\\w+)@(\\w+\\.\\w+)")
public UserCredentials credentials(String username, String domain) {
    return new UserCredentials(username, domain);
}

@ParameterType("(\\d+)\\s*(kg|g|lb|oz)")
public Weight weight(String amount, String unit) {
    double value = Double.parseDouble(amount);
    WeightUnit weightUnit = WeightUnit.fromSymbol(unit);
    return new Weight(value, weightUnit);
}

@ParameterType("(\\d+\\.\\d+\\.\\d+\\.\\d+):(\\d+)")
public ServerAddress serverAddress(String ip, String port) {
    return new ServerAddress(ip, Integer.parseInt(port));
}
```

### 可选参数转换器

```java
@ParameterType("(?:active|inactive|pending)?")
public Optional<UserStatus> optionalStatus(String statusText) {
    if (statusText == null || statusText.isEmpty()) {
        return Optional.empty();
    }
    return Optional.of(UserStatus.valueOf(statusText.toUpperCase()));
}

@ParameterType("(?:\\d+)?")
public Optional<Integer> optionalNumber(String numberText) {
    if (numberText == null || numberText.isEmpty()) {
        return Optional.empty();
    }
    return Optional.of(Integer.parseInt(numberText));
}
```

### 集合转换器

```java
@ParameterType("(?:[^,]+)(?:,(?:[^,]+))*")
public List<String> commaSeparatedList(String listText) {
    return Arrays.asList(listText.split(","));
}

@ParameterType("(?:\\d+)(?:,(?:\\d+))*")
public Set<Integer> numberSet(String numbersText) {
    return Arrays.stream(numbersText.split(","))
        .map(Integer::parseInt)
        .collect(Collectors.toSet());
}

@ParameterType("(?:[^|]+)(?:\\|(?:[^|]+))*")
public Map<String, String> pipeSeparatedMap(String mapText) {
    return Arrays.stream(mapText.split("\\|"))
        .map(entry -> entry.split("="))
        .collect(Collectors.toMap(
            parts -> parts[0],
            parts -> parts[1]
        ));
}
```

## DataTable转换器

### 基本DataTable转换

```java
@Given("以下用户存在:")
public void followingUsersExist(DataTable dataTable) {
    List<User> users = dataTable.asList(User.class);
    users.forEach(userService::createUser);
}

@Given("以下产品存在:")
public void followingProductsExist(DataTable dataTable) {
    List<Map<String, String>> products = dataTable.asMaps();
    products.forEach(productMap -> {
        Product product = new Product(
            productMap.get("name"),
            Double.parseDouble(productMap.get("price")),
            Integer.parseInt(productMap.get("stock"))
        );
        productService.createProduct(product);
    });
}
```

### 自定义DataTable转换器

```java
public class UserDataTableTransformer implements DataTableTypeEntry<User> {
    @Override
    public User transform(Map<String, String> entry) {
        return new User(
            entry.get("username"),
            entry.get("email"),
            entry.get("password"),
            UserStatus.valueOf(entry.get("status").toUpperCase())
        );
    }

    @Override
    public List<String> headers() {
        return Arrays.asList("username", "email", "password", "status");
    }
}

// 注册转换器
@Before
public void setupDataTableTypes(DataTableTypeRegistry dataTableTypeRegistry) {
    dataTableTypeRegistry.defineDataTableType(new DataTableType(User.class, new UserDataTableTransformer()));
}
```

### 复杂DataTable转换

```java
@Given("以下订单存在:")
public void followingOrdersExist(DataTable dataTable) {
    List<Order> orders = dataTable.asList(Order.class);
    orders.forEach(orderService::createOrder);
}

// Order类可能需要自定义转换器
public class OrderDataTableTransformer implements DataTableTypeEntry<Order> {
    @Override
    public Order transform(Map<String, String> entry) {
        Order order = new Order();
        order.setId(entry.get("id"));
        order.setCustomerId(entry.get("customerId"));
        order.setStatus(OrderStatus.valueOf(entry.get("status")));
        
        // 解析订单项
        String itemsJson = entry.get("items");
        List<OrderItem> items = parseOrderItems(itemsJson);
        order.setItems(items);
        
        // 解析日期
        String orderDateStr = entry.get("orderDate");
        order.setOrderDate(LocalDate.parse(orderDateStr));
        
        return order;
    }
    
    private List<OrderItem> parseOrderItems(String itemsJson) {
        // 实现JSON解析逻辑
        // ...
    }
}
```

## 文档字符串转换器

### 基本文档字符串处理

```java
@Given("用户配置如下:")
public void userConfiguration(String docString) {
    // 处理文档字符串
    Properties properties = new Properties();
    try {
        properties.load(new StringReader(docString));
        userService.configureUser(properties);
    } catch (IOException e) {
        throw new RuntimeException("Failed to parse user configuration", e);
    }
}
```

### JSON文档字符串转换

```java
@Given("用户数据如下:")
public void userData(String jsonDocString) {
    ObjectMapper objectMapper = new ObjectMapper();
    try {
        User user = objectMapper.readValue(jsonDocString, User.class);
        userService.createUser(user);
    } catch (JsonProcessingException e) {
        throw new RuntimeException("Failed to parse user JSON", e);
    }
}
```

对应的Gherkin特性：

```gherkin
Given 用户数据如下:
  """
  {
    "username": "john.doe",
    "email": "john.doe@example.com",
    "password": "Password123",
    "status": "active",
    "profile": {
      "firstName": "John",
      "lastName": "Doe",
      "age": 30
    }
  }
  """
```

### XML文档字符串转换

```java
@Given("产品配置如下:")
public void productConfiguration(String xmlDocString) {
    try {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.parse(new InputSource(new StringReader(xmlDocString)));
        
        Product product = parseProductFromXml(document);
        productService.createProduct(product);
    } catch (Exception e) {
        throw new RuntimeException("Failed to parse product XML", e);
    }
}
```

## 参数转换器最佳实践

### 1. 转换器组织

- 将相关的转换器组织在同一个类中
- 使用有意义的类名和方法名
- 添加适当的注释和文档
- 考虑按功能域分组转换器

```java
public class UserParameterTransformers {
    
    @ParameterType("([A-Z][a-z]+) ([A-Z][a-z]+)")
    public User fullName(String firstName, String lastName) {
        return new User(firstName, lastName);
    }
    
    @ParameterType("(active|inactive|pending)")
    public UserStatus status(String statusText) {
        return UserStatus.valueOf(statusText.toUpperCase());
    }
    
    @ParameterType("([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})")
    public Email email(String emailString) {
        return new Email(emailString);
    }
}

public class OrderParameterTransformers {
    
    @ParameterType("(pending|processing|shipped|delivered|cancelled)")
    public OrderStatus orderStatus(String statusText) {
        return OrderStatus.valueOf(statusText.toUpperCase());
    }
    
    @ParameterType("(ORD-\\d+)")
    public OrderId orderId(String orderIdString) {
        return new OrderId(orderIdString);
    }
}
```

### 2. 错误处理

- 提供有意义的错误消息
- 验证输入数据的有效性
- 处理边界条件和异常情况
- 考虑使用自定义异常

```java
@ParameterType("(\\d+\\.\\d{2})")
public Money price(String priceString) {
    try {
        BigDecimal amount = new BigDecimal(priceString);
        if (amount.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Price cannot be negative: " + priceString);
        }
        return new Money(amount, Currency.getInstance("USD"));
    } catch (NumberFormatException e) {
        throw new IllegalArgumentException("Invalid price format: " + priceString, e);
    }
}

@ParameterType("(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})")
public IPAddress ipAddress(String ipString) {
    if (!isValidIPAddress(ipString)) {
        throw new IllegalArgumentException("Invalid IP address: " + ipString);
    }
    return new IPAddress(ipString);
}
```

### 3. 性能考虑

- 避免在转换器中执行耗时操作
- 考虑缓存常用转换结果
- 使用高效的字符串处理方法
- 避免创建不必要的对象

```java
// 不好的做法：每次转换都创建新的SimpleDateFormat
@ParameterType("(\\d{2}/\\d{2}/\\d{4})")
public Date date(String dateString) {
    SimpleDateFormat format = new SimpleDateFormat("MM/dd/yyyy");
    return format.parse(dateString);
}

// 好的做法：使用线程安全的DateTimeFormatter
private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("MM/dd/yyyy");

@ParameterType("(\\d{2}/\\d{2}/\\d{4})")
public LocalDate date(String dateString) {
    return LocalDate.parse(dateString, DATE_FORMATTER);
}
```

### 4. 测试转换器

- 为转换器编写单元测试
- 测试边界条件和异常情况
- 验证转换结果的正确性
- 考虑使用参数化测试

```java
class UserParameterTransformersTest {
    
    private UserParameterTransformers transformers = new UserParameterTransformers();
    
    @ParameterizedTest
    @CsvSource({
        "John Doe, John, Doe",
        "Jane Smith, Jane, Smith"
    })
    void testFullName(String input, String expectedFirstName, String expectedLastName) {
        User user = transformers.fullName(input);
        assertEquals(expectedFirstName, user.getFirstName());
        assertEquals(expectedLastName, user.getLastName());
    }
    
    @ParameterizedTest
    @ValueSource(strings = {"active", "inactive", "pending"})
    void testStatus(String input) {
        UserStatus status = transformers.status(input);
        assertNotNull(status);
    }
    
    @Test
    void testInvalidStatus() {
        assertThrows(IllegalArgumentException.class, () -> {
            transformers.status("unknown");
        });
    }
}
```

## 总结

参数转换器是Cucumber中实现类型安全测试的重要机制，通过自定义转换器，我们可以：

1. 将文本参数转换为领域对象
2. 验证输入数据的有效性
3. 提高步骤定义的可读性和可维护性
4. 减少重复的数据转换代码

在设计参数转换器时，应该考虑：
- 转换器的职责单一性
- 错误处理的完整性
- 性能和资源使用
- 测试覆盖的全面性

在下一节中，我们将介绍如何结合参数转换器和数据驱动测试，创建更强大、更灵活的测试场景。