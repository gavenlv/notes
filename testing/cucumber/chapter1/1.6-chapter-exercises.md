# 1.6 本章实验

## 实验概述

本章实验旨在帮助您巩固Cucumber基础知识，通过实际操作加深对BDD概念、Cucumber安装配置、特性文件编写和步骤定义实现的理解。实验分为三个难度级别，从基础到进阶，逐步提升您的Cucumber技能。

## 实验环境准备

在开始实验前，请确保已准备好以下环境：

1. Java JDK 8或更高版本
2. Maven 3.6或更高版本
3. IDE（推荐IntelliJ IDEA或Eclipse）
4. 已安装Cucumber插件

## 实验一：创建简单的计算器测试（基础）

### 实验目标

创建一个简单的计算器应用的Cucumber测试，包括加法、减法、乘法和除法功能。

### 实验步骤

1. **创建Maven项目**

```bash
mvn archetype:generate -DgroupId=com.example -DartifactId=calculator-cucumber-test -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
cd calculator-cucumber-test
```

2. **配置项目依赖**

在`pom.xml`中添加Cucumber依赖：

```xml
<dependencies>
    <dependency>
        <groupId>io.cucumber</groupId>
        <artifactId>cucumber-java</artifactId>
        <version>7.11.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>io.cucumber</groupId>
        <artifactId>cucumber-junit</artifactId>
        <version>7.11.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.13.2</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

3. **创建目录结构**

```bash
mkdir -p src/main/java/com/example/calculator
mkdir -p src/test/java/com/example/cucumber/stepdefinitions
mkdir -p src/test/java/com/example/cucumber/runners
mkdir -p src/test/resources/features
```

4. **实现计算器类**

创建`src/main/java/com/example/calculator/Calculator.java`：

```java
package com.example.calculator;

public class Calculator {
    private double result;
    
    public double add(double a, double b) {
        result = a + b;
        return result;
    }
    
    public double subtract(double a, double b) {
        result = a - b;
        return result;
    }
    
    public double multiply(double a, double b) {
        result = a * b;
        return result;
    }
    
    public double divide(double a, double b) {
        if (b == 0) {
            throw new ArithmeticException("除数不能为零");
        }
        result = a / b;
        return result;
    }
    
    public double getResult() {
        return result;
    }
}
```

5. **编写特性文件**

创建`src/test/resources/features/calculator.feature`：

```gherkin
Feature: 计算器功能
  作为一个用户
  我希望能够使用计算器进行基本数学运算
  以便得到正确的计算结果

  Scenario: 执行加法运算
    Given 我有一个计算器
    When 我输入 5 和 10 进行加法运算
    Then 结果应该是 15

  Scenario: 执行减法运算
    Given 我有一个计算器
    When 我输入 10 和 5 进行减法运算
    Then 结果应该是 5

  Scenario: 执行乘法运算
    Given 我有一个计算器
    When 我输入 5 和 10 进行乘法运算
    Then 结果应该是 50

  Scenario: 执行除法运算
    Given 我有一个计算器
    When 我输入 10 和 5 进行除法运算
    Then 结果应该是 2

  Scenario: 除数为零的错误处理
    Given 我有一个计算器
    When 我尝试用 10 除以 0
    Then 我应该得到 "除数不能为零" 的错误
```

6. **实现步骤定义**

创建`src/test/java/com/example/cucumber/stepdefinitions/CalculatorSteps.java`：

```java
package com.example.cucumber.stepdefinitions;

import com.example.calculator.Calculator;
import io.cucumber.java.en.Given;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;
import static org.junit.Assert.*;

public class CalculatorSteps {
    private Calculator calculator;
    private double result;
    private Exception exception;

    @Given("我有一个计算器")
    public void 我有一个计算器() {
        calculator = new Calculator();
    }

    @When("我输入 {double} 和 {double} 进行加法运算")
    public void 我输入和进行加法运算(double a, double b) {
        result = calculator.add(a, b);
    }

    @When("我输入 {double} 和 {double} 进行减法运算")
    public void 我输入和进行减法运算(double a, double b) {
        result = calculator.subtract(a, b);
    }

    @When("我输入 {double} 和 {double} 进行乘法运算")
    public void 我输入和进行乘法运算(double a, double b) {
        result = calculator.multiply(a, b);
    }

    @When("我输入 {double} 和 {double} 进行除法运算")
    public void 我输入和进行除法运算(double a, double b) {
        result = calculator.divide(a, b);
    }

    @When("我尝试用 {double} 除以 {double}")
    public void 我尝试用除以(double a, double b) {
        try {
            result = calculator.divide(a, b);
        } catch (Exception e) {
            exception = e;
        }
    }

    @Then("结果应该是 {double}")
    public void 结果应该是(double expectedResult) {
        assertEquals("计算结果不正确", expectedResult, result, 0.001);
    }

    @Then("我应该得到 {string} 的错误")
    public void 我应该得到的错误(String expectedMessage) {
        assertNotNull("应该抛出异常", exception);
        assertEquals("错误消息不正确", expectedMessage, exception.getMessage());
    }
}
```

7. **创建测试运行器**

创建`src/test/java/com/example/cucumber/runners/CalculatorTestRunner.java`：

```java
package com.example.cucumber.runners;

import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(
    features = "src/test/resources/features",
    glue = "com.example.cucumber.stepdefinitions",
    plugin = {"pretty", "html:target/cucumber-reports/calculator-report.html"}
)
public class CalculatorTestRunner {
}
```

8. **运行测试**

```bash
mvn test
```

### 实验要求

1. 成功运行所有测试场景
2. 理解特性文件和步骤定义的对应关系
3. 尝试修改测试数据，观察测试结果变化

### 实验思考

1. 如果在步骤定义中不使用参数化步骤，会有什么问题？
2. 为什么需要异常处理步骤？它与其他步骤有什么区别？

## 实验二：购物车功能测试（进阶）

### 实验目标

创建一个购物车功能的Cucumber测试，包括添加商品、移除商品、计算总价等功能，并使用数据表和场景大纲。

### 实验步骤

1. **创建项目**

```bash
mvn archetype:generate -DgroupId=com.example -DartifactId=shopping-cart-cucumber-test -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
cd shopping-cart-cucumber-test
```

2. **配置项目依赖**

与实验一相同，添加Cucumber依赖。

3. **创建目录结构**

```bash
mkdir -p src/main/java/com/example/shopping
mkdir -p src/test/java/com/example/cucumber/stepdefinitions
mkdir -p src/test/java/com/example/cucumber/runners
mkdir -p src/test/resources/features
```

4. **实现购物车相关类**

创建`src/main/java/com/example/shopping/Product.java`：

```java
package com.example.shopping;

public class Product {
    private String id;
    private String name;
    private double price;
    
    public Product(String id, String name, double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }
    
    public String getId() {
        return id;
    }
    
    public String getName() {
        return name;
    }
    
    public double getPrice() {
        return price;
    }
}
```

创建`src/main/java/com/example/shopping/CartItem.java`：

```java
package com.example.shopping;

public class CartItem {
    private Product product;
    private int quantity;
    
    public CartItem(Product product, int quantity) {
        this.product = product;
        this.quantity = quantity;
    }
    
    public Product getProduct() {
        return product;
    }
    
    public int getQuantity() {
        return quantity;
    }
    
    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }
    
    public double getSubtotal() {
        return product.getPrice() * quantity;
    }
}
```

创建`src/main/java/com/example/shopping/ShoppingCart.java`：

```java
package com.example.shopping;

import java.util.ArrayList;
import java.util.List;

public class ShoppingCart {
    private List<CartItem> items;
    
    public ShoppingCart() {
        items = new ArrayList<>();
    }
    
    public void addItem(Product product, int quantity) {
        // 检查商品是否已在购物车中
        for (CartItem item : items) {
            if (item.getProduct().getId().equals(product.getId())) {
                item.setQuantity(item.getQuantity() + quantity);
                return;
            }
        }
        
        // 如果商品不在购物车中，添加新商品
        items.add(new CartItem(product, quantity));
    }
    
    public void removeItem(String productId) {
        items.removeIf(item -> item.getProduct().getId().equals(productId));
    }
    
    public void updateQuantity(String productId, int quantity) {
        for (CartItem item : items) {
            if (item.getProduct().getId().equals(productId)) {
                if (quantity <= 0) {
                    items.remove(item);
                } else {
                    item.setQuantity(quantity);
                }
                return;
            }
        }
    }
    
    public List<CartItem> getItems() {
        return new ArrayList<>(items);
    }
    
    public double getTotalPrice() {
        return items.stream().mapToDouble(CartItem::getSubtotal).sum();
    }
    
    public int getItemCount() {
        return items.stream().mapToInt(CartItem::getQuantity).sum();
    }
    
    public void clear() {
        items.clear();
    }
}
```

5. **编写特性文件**

创建`src/test/resources/features/shopping-cart.feature`：

```gherkin
Feature: 购物车功能
  作为一个在线购物用户
  我希望能够管理我的购物车
  以便购买我需要的商品

  Background:
    Given 我有一个空的购物车

  Scenario: 添加单个商品到购物车
    When 我添加 1 个 "P001" 商品到购物车
    Then 购物车应该包含 1 个商品
    And 购物车总数量应该是 1

  Scenario: 添加多个相同商品到购物车
    When 我添加 3 个 "P001" 商品到购物车
    Then 购物车应该包含 1 个商品
    And 购物车总数量应该是 3

  Scenario: 添加多个不同商品到购物车
    When 我添加以下商品到购物车:
      | productId | quantity |
      | P001      | 2        |
      | P002      | 1        |
      | P003      | 3        |
    Then 购物车应该包含 3 个商品
    And 购物车总数量应该是 6

  Scenario: 从购物车移除商品
    Given 我已经添加以下商品到购物车:
      | productId | quantity |
      | P001      | 2        |
      | P002      | 1        |
    When 我从购物车移除 "P001" 商品
    Then 购物车应该包含 1 个商品
    And 购物车总数量应该是 1

  Scenario: 更新购物车商品数量
    Given 我已经添加 2 个 "P001" 商品到购物车
    When 我将 "P001" 商品的数量更新为 5
    Then 购物车总数量应该是 5

  Scenario: 计算购物车总价
    Given 商品价格如下:
      | productId | price |
      | P001      | 10.99 |
      | P002      | 5.50  |
      | P003      | 2.99  |
    And 我已经添加以下商品到购物车:
      | productId | quantity |
      | P001      | 2        |
      | P002      | 1        |
    When 我计算购物车总价
    Then 总价应该是 27.48

  Scenario Outline: 验证购物车商品数量
    Given 我添加了 {quantity} 个 "P001" 商品到购物车
    When 我查看购物车
    Then 购物车总数量应该是 {expectedQuantity}

    Examples:
      | quantity | expectedQuantity |
      | 1        | 1                |
      | 5        | 5                |
      | 10       | 10               |
```

6. **实现步骤定义**

创建`src/test/java/com/example/cucumber/stepdefinitions/ShoppingCartSteps.java`：

```java
package com.example.cucumber.stepdefinitions;

import com.example.shopping.Product;
import com.example.shopping.ShoppingCart;
import io.cucumber.java.en.And;
import io.cucumber.java.en.Given;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;
import io.cucumber.datatable.DataTable;
import java.util.Map;
import static org.junit.Assert.*;

public class ShoppingCartSteps {
    private ShoppingCart cart;
    private Map<String, Product> products;
    private double totalPrice;

    @Given("我有一个空的购物车")
    public void 我有一个空的购物车() {
        cart = new ShoppingCart();
        // 初始化一些测试商品
        products = Map.of(
            "P001", new Product("P001", "商品1", 10.99),
            "P002", new Product("P002", "商品2", 5.50),
            "P003", new Product("P003", "商品3", 2.99)
        );
    }

    @When("我添加 {int} 个 {string} 商品到购物车")
    public void 我添加个商品到购物车(int quantity, String productId) {
        Product product = products.get(productId);
        cart.addItem(product, quantity);
    }

    @Then("购物车应该包含 {int} 个商品")
    public void 购物车应该包含个商品(int expectedItemCount) {
        assertEquals("购物车商品种类数量不正确", expectedItemCount, cart.getItems().size());
    }

    @And("购物车总数量应该是 {int}")
    public void 购物车总数量应该是(int expectedTotalQuantity) {
        assertEquals("购物车商品总数量不正确", expectedTotalQuantity, cart.getItemCount());
    }

    @When("我添加以下商品到购物车:")
    public void 我添加以下商品到购物车(DataTable dataTable) {
        for (Map<String, String> row : dataTable.asMaps()) {
            String productId = row.get("productId");
            int quantity = Integer.parseInt(row.get("quantity"));
            Product product = products.get(productId);
            cart.addItem(product, quantity);
        }
    }

    @Given("我已经添加以下商品到购物车:")
    public void 我已经添加以下商品到购物车(DataTable dataTable) {
        我添加以下商品到购物车(dataTable);
    }

    @When("我从购物车移除 {string} 商品")
    public void 我从购物车移除商品(String productId) {
        cart.removeItem(productId);
    }

    @When("我将 {string} 商品的数量更新为 {int}")
    public void 我将商品的数量更新为(String productId, int quantity) {
        cart.updateQuantity(productId, quantity);
    }

    @Given("商品价格如下:")
    public void 商品价格如下(DataTable dataTable) {
        // 在实际应用中，这里可以从数据库或其他来源加载商品价格
        // 在这个例子中，我们已经初始化了商品价格
    }

    @When("我计算购物车总价")
    public void 我计算购物车总价() {
        totalPrice = cart.getTotalPrice();
    }

    @Then("总价应该是 {double}")
    public void 总价应该是(double expectedPrice) {
        assertEquals("购物车总价不正确", expectedPrice, totalPrice, 0.01);
    }

    @Given("我添加了 {int} 个 {string} 商品到购物车")
    public void 我添加了个商品到购物车(int quantity, String productId) {
        Product product = products.get(productId);
        cart.addItem(product, quantity);
    }

    @When("我查看购物车")
    public void 我查看购物车() {
        // 这个步骤主要用于场景大纲，实际不需要做任何操作
    }
}
```

7. **创建测试运行器**

创建`src/test/java/com/example/cucumber/runners/ShoppingCartTestRunner.java`：

```java
package com.example.cucumber.runners;

import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(
    features = "src/test/resources/features",
    glue = "com.example.cucumber.stepdefinitions",
    plugin = {"pretty", "html:target/cucumber-reports/shopping-cart-report.html"}
)
public class ShoppingCartTestRunner {
}
```

8. **运行测试**

```bash
mvn test
```

### 实验要求

1. 成功运行所有测试场景
2. 理解数据表和场景大纲的使用
3. 尝试添加新的测试场景，如清空购物车

### 实验思考

1. 数据表和场景大纲有什么区别？分别在什么场景下使用？
2. 如何在步骤定义中管理复杂的状态？

## 实验三：用户注册登录系统测试（高级）

### 实验目标

创建一个用户注册登录系统的Cucumber测试，包括用户注册、登录验证、密码重置等功能，并使用标签和Hooks进行测试管理。

### 实验步骤

1. **创建项目**

```bash
mvn archetype:generate -DgroupId=com.example -DartifactId=user-auth-cucumber-test -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
cd user-auth-cucumber-test
```

2. **配置项目依赖**

添加Cucumber依赖和额外的依赖：

```xml
<dependencies>
    <dependency>
        <groupId>io.cucumber</groupId>
        <artifactId>cucumber-java</artifactId>
        <version>7.11.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>io.cucumber</groupId>
        <artifactId>cucumber-junit</artifactId>
        <version>7.11.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.13.2</version>
        <scope>test</scope>
    </dependency>
    <!-- 添加额外的依赖，如密码加密等 -->
    <dependency>
        <groupId>org.mindrot</groupId>
        <artifactId>jbcrypt</artifactId>
        <version>0.4</version>
    </dependency>
</dependencies>
```

3. **创建目录结构**

```bash
mkdir -p src/main/java/com/example/auth
mkdir -p src/test/java/com/example/cucumber/stepdefinitions
mkdir -p src/test/java/com/example/cucumber/runners
mkdir -p src/test/java/com/example/cucumber/hooks
mkdir -p src/test/resources/features
```

4. **实现用户认证系统**

创建`src/main/java/com/example/auth/User.java`：

```java
package com.example.auth;

import java.time.LocalDateTime;

public class User {
    private String id;
    private String username;
    private String password;
    private String email;
    private LocalDateTime createdAt;
    private boolean active;
    
    public User(String id, String username, String password, String email) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.email = email;
        this.createdAt = LocalDateTime.now();
        this.active = true;
    }
    
    public String getId() {
        return id;
    }
    
    public String getUsername() {
        return username;
    }
    
    public String getPassword() {
        return password;
    }
    
    public String getEmail() {
        return email;
    }
    
    public LocalDateTime getCreatedAt() {
        return createdAt;
    }
    
    public boolean isActive() {
        return active;
    }
    
    public void setActive(boolean active) {
        this.active = active;
    }
    
    public void setPassword(String password) {
        this.password = password;
    }
}
```

创建`src/main/java/com/example/auth/UserRepository.java`：

```java
package com.example.auth;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;

public class UserRepository {
    private Map<String, User> users;
    private Map<String, String> passwordResetTokens;
    
    public UserRepository() {
        users = new HashMap<>();
        passwordResetTokens = new HashMap<>();
    }
    
    public User save(User user) {
        if (user.getId() == null) {
            user = new User(
                UUID.randomUUID().toString(),
                user.getUsername(),
                user.getPassword(),
                user.getEmail()
            );
        }
        users.put(user.getId(), user);
        return user;
    }
    
    public Optional<User> findById(String id) {
        return Optional.ofNullable(users.get(id));
    }
    
    public Optional<User> findByUsername(String username) {
        return users.values().stream()
            .filter(user -> user.getUsername().equals(username))
            .findFirst();
    }
    
    public Optional<User> findByEmail(String email) {
        return users.values().stream()
            .filter(user -> user.getEmail().equals(email))
            .findFirst();
    }
    
    public boolean existsByUsername(String username) {
        return users.values().stream()
            .anyMatch(user -> user.getUsername().equals(username));
    }
    
    public boolean existsByEmail(String email) {
        return users.values().stream()
            .anyMatch(user -> user.getEmail().equals(email));
    }
    
    public String createPasswordResetToken(String userId) {
        String token = UUID.randomUUID().toString();
        passwordResetTokens.put(token, userId);
        return token;
    }
    
    public Optional<String> validatePasswordResetToken(String token) {
        return Optional.ofNullable(passwordResetTokens.get(token));
    }
    
    public void invalidatePasswordResetToken(String token) {
        passwordResetTokens.remove(token);
    }
}
```

创建`src/main/java/com/example/auth/PasswordService.java`：

```java
package com.example.auth;

import org.mindrot.jbcrypt.BCrypt;

public class PasswordService {
    public String hashPassword(String plainPassword) {
        return BCrypt.hashpw(plainPassword, BCrypt.gensalt());
    }
    
    public boolean checkPassword(String plainPassword, String hashedPassword) {
        return BCrypt.checkpw(plainPassword, hashedPassword);
    }
}
```

创建`src/main/java/com/example/auth/AuthenticationService.java`：

```java
package com.example.auth;

import java.util.Optional;

public class AuthenticationService {
    private UserRepository userRepository;
    private PasswordService passwordService;
    
    public AuthenticationService(UserRepository userRepository, PasswordService passwordService) {
        this.userRepository = userRepository;
        this.passwordService = passwordService;
    }
    
    public AuthResult register(String username, String password, String email) {
        // 验证输入
        if (username == null || username.trim().isEmpty()) {
            return AuthResult.failure("用户名不能为空");
        }
        
        if (password == null || password.length() < 6) {
            return AuthResult.failure("密码长度至少为6位");
        }
        
        if (email == null || !email.contains("@")) {
            return AuthResult.failure("邮箱格式不正确");
        }
        
        // 检查用户名和邮箱是否已存在
        if (userRepository.existsByUsername(username)) {
            return AuthResult.failure("用户名已存在");
        }
        
        if (userRepository.existsByEmail(email)) {
            return AuthResult.failure("邮箱已被使用");
        }
        
        // 创建新用户
        String hashedPassword = passwordService.hashPassword(password);
        User user = new User(null, username, hashedPassword, email);
        userRepository.save(user);
        
        return AuthResult.success("注册成功");
    }
    
    public AuthResult login(String username, String password) {
        if (username == null || username.trim().isEmpty()) {
            return AuthResult.failure("用户名不能为空");
        }
        
        if (password == null || password.isEmpty()) {
            return AuthResult.failure("密码不能为空");
        }
        
        Optional<User> userOptional = userRepository.findByUsername(username);
        if (!userOptional.isPresent()) {
            return AuthResult.failure("用户名或密码错误");
        }
        
        User user = userOptional.get();
        if (!user.isActive()) {
            return AuthResult.failure("账户已被禁用");
        }
        
        if (!passwordService.checkPassword(password, user.getPassword())) {
            return AuthResult.failure("用户名或密码错误");
        }
        
        return AuthResult.success("登录成功");
    }
    
    public Optional<String> createPasswordResetToken(String email) {
        Optional<User> userOptional = userRepository.findByEmail(email);
        if (!userOptional.isPresent()) {
            return Optional.empty();
        }
        
        User user = userOptional.get();
        String token = userRepository.createPasswordResetToken(user.getId());
        return Optional.of(token);
    }
    
    public AuthResult resetPassword(String token, String newPassword) {
        Optional<String> userIdOptional = userRepository.validatePasswordResetToken(token);
        if (!userIdOptional.isPresent()) {
            return AuthResult.failure("重置令牌无效或已过期");
        }
        
        if (newPassword == null || newPassword.length() < 6) {
            return AuthResult.failure("密码长度至少为6位");
        }
        
        String userId = userIdOptional.get();
        Optional<User> userOptional = userRepository.findById(userId);
        if (!userOptional.isPresent()) {
            return AuthResult.failure("用户不存在");
        }
        
        User user = userOptional.get();
        String hashedPassword = passwordService.hashPassword(newPassword);
        user.setPassword(hashedPassword);
        userRepository.save(user);
        
        userRepository.invalidatePasswordResetToken(token);
        
        return AuthResult.success("密码重置成功");
    }
    
    public static class AuthResult {
        private boolean success;
        private String message;
        
        private AuthResult(boolean success, String message) {
            this.success = success;
            this.message = message;
        }
        
        public static AuthResult success(String message) {
            return new AuthResult(true, message);
        }
        
        public static AuthResult failure(String message) {
            return new AuthResult(false, message);
        }
        
        public boolean isSuccess() {
            return success;
        }
        
        public String getMessage() {
            return message;
        }
    }
}
```

5. **编写特性文件**

创建`src/test/resources/features/user-auth.feature`：

```gherkin
@user-auth
Feature: 用户认证系统
  作为一个系统用户
  我希望能够注册、登录和管理我的账户
  以便使用系统的功能

  @registration
  Scenario: 成功注册新用户
    Given 我是一个新用户
    And 我的用户名是 "newuser"
    And 我的密码是 "password123"
    And 我的邮箱是 "newuser@example.com"
    When 我尝试注册
    Then 我应该能够成功注册
    And 我应该看到 "注册成功" 的消息

  @registration
  Scenario: 用户名已存在的注册失败
    Given 用户 "existinguser" 已经注册
    And 我是一个新用户
    And 我的用户名是 "existinguser"
    And 我的密码是 "password123"
    And 我的邮箱是 "newuser@example.com"
    When 我尝试注册
    Then 我应该无法注册
    And 我应该看到 "用户名已存在" 的消息

  @registration
  Scenario: 邮箱已被使用的注册失败
    Given 用户 "existinguser" 已经使用邮箱 "existing@example.com" 注册
    And 我是一个新用户
    And 我的用户名是 "newuser"
    And 我的密码是 "password123"
    And 我的邮箱是 "existing@example.com"
    When 我尝试注册
    Then 我应该无法注册
    And 我应该看到 "邮箱已被使用" 的消息

  @registration
  Scenario Outline: 注册输入验证
    Given 我是一个新用户
    And 我的用户名是 "{username}"
    And 我的密码是 "{password}"
    And 我的邮箱是 "{email}"
    When 我尝试注册
    Then 我应该{success}注册
    And 我应该看到 "{message}" 的消息

    Examples:
      | username | password      | email                | success | message               |
      | ""       | password123   | test@example.com     | 无法    | 用户名不能为空         |
      | testuser | ""            | test@example.com     | 无法    | 密码长度至少为6位      |
      | testuser | 123           | test@example.com     | 无法    | 密码长度至少为6位      |
      | testuser | password123   | ""                   | 无法    | 邮箱格式不正确         |
      | testuser | password123   | invalid-email        | 无法    | 邮箱格式不正确         |
      | testuser | password123   | test@example.com     | 能够    | 注册成功               |

  @login
  Scenario: 成功登录
    Given 用户 "testuser" 已经使用密码 "password123" 注册
    And 我是一个已注册用户
    And 我的用户名是 "testuser"
    And 我的密码是 "password123"
    When 我尝试登录
    Then 我应该能够成功登录
    And 我应该看到 "登录成功" 的消息

  @login
  Scenario: 密码错误的登录失败
    Given 用户 "testuser" 已经使用密码 "password123" 注册
    And 我是一个已注册用户
    And 我的用户名是 "testuser"
    And 我的密码是 "wrongpassword"
    When 我尝试登录
    Then 我应该无法登录
    And 我应该看到 "用户名或密码错误" 的消息

  @login
  Scenario: 用户不存在的登录失败
    Given 我是一个未注册用户
    And 我的用户名是 "nonexistentuser"
    And 我的密码是 "password123"
    When 我尝试登录
    Then 我应该无法登录
    And 我应该看到 "用户名或密码错误" 的消息

  @password-reset
  Scenario: 成功重置密码
    Given 用户 "testuser" 已经使用邮箱 "test@example.com" 注册
    When 我请求重置密码使用邮箱 "test@example.com"
    Then 我应该收到重置令牌
    And 我使用重置令牌和新密码 "newpassword123" 重置密码
    Then 我应该能够成功重置密码
    And 我应该看到 "密码重置成功" 的消息

  @password-reset
  Scenario: 无效邮箱的密码重置失败
    When 我请求重置密码使用邮箱 "nonexistent@example.com"
    Then 我不应该收到重置令牌

  @password-reset
  Scenario: 无效令牌的密码重置失败
    When 我使用重置令牌 "invalid-token" 和新密码 "newpassword123" 重置密码
    Then 我应该无法重置密码
    And 我应该看到 "重置令牌无效或已过期" 的消息
```

6. **实现Hooks**

创建`src/test/java/com/example/cucumber/hooks/AuthHooks.java`：

```java
package com.example.cucumber.hooks;

import com.example.auth.AuthenticationService;
import com.example.auth.PasswordService;
import com.example.auth.User;
import com.example.auth.UserRepository;
import io.cucumber.java.After;
import io.cucumber.java.Before;
import io.cucumber.java.BeforeAll;
import io.cucumber.java.Scenario;

public class AuthHooks {
    private static UserRepository userRepository;
    private static PasswordService passwordService;
    private static AuthenticationService authService;
    
    @BeforeAll
    public static void setup() {
        userRepository = new UserRepository();
        passwordService = new PasswordService();
        authService = new AuthenticationService(userRepository, passwordService);
    }
    
    @Before("@user-auth")
    public void beforeUserAuth(Scenario scenario) {
        // 清理用户数据
        userRepository = new UserRepository();
        authService = new AuthenticationService(userRepository, passwordService);
        System.out.println("开始执行用户认证测试: " + scenario.getName());
    }
    
    @After("@user-auth")
    public void afterUserAuth(Scenario scenario) {
        System.out.println("完成执行用户认证测试: " + scenario.getName() + ", 状态: " + scenario.getStatus());
    }
    
    public static UserRepository getUserRepository() {
        return userRepository;
    }
    
    public static PasswordService getPasswordService() {
        return passwordService;
    }
    
    public static AuthenticationService getAuthService() {
        return authService;
    }
}
```

7. **实现步骤定义**

创建`src/test/java/com/example/cucumber/stepdefinitions/UserAuthSteps.java`：

```java
package com.example.cucumber.stepdefinitions;

import com.example.auth.AuthenticationService;
import com.example.cucumber.hooks.AuthHooks;
import io.cucumber.java.en.And;
import io.cucumber.java.en.Given;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;
import static org.junit.Assert.*;

public class UserAuthSteps {
    private AuthenticationService.AuthResult authResult;
    private String resetToken;
    
    @Given("用户 {string} 已经使用密码 {string} 注册")
    public void 用户已经使用密码注册(String username, String password) {
        AuthHooks.getAuthService().register(username, password, username + "@example.com");
    }

    @Given("用户 {string} 已经使用邮箱 {string} 注册")
    public void 用户已经使用邮箱注册(String username, String email) {
        AuthHooks.getAuthService().register(username, "password123", email);
    }

    @Given("我是一个新用户")
    public void 我是一个新用户() {
        // 这个步骤主要用于设置上下文，不需要实际操作
    }

    @Given("我是一个已注册用户")
    public void 我是一个已注册用户() {
        // 这个步骤主要用于设置上下文，不需要实际操作
    }

    @Given("我是一个未注册用户")
    public void 我是一个未注册用户() {
        // 这个步骤主要用于设置上下文，不需要实际操作
    }

    @And("我的用户名是 {string}")
    public void 我的用户名是(String username) {
        // 存储用户名，供后续步骤使用
        // 在实际应用中，可能需要更复杂的状态管理
    }

    @And("我的密码是 {string}")
    public void 我的密码是(String password) {
        // 存储密码，供后续步骤使用
    }

    @And("我的邮箱是 {string}")
    public void 我的邮箱是(String email) {
        // 存储邮箱，供后续步骤使用
    }

    @When("我尝试注册")
    public void 我尝试注册() {
        // 在实际应用中，这里应该使用之前存储的值
        // 为了简化，我们使用固定的值
        authResult = AuthHooks.getAuthService().register("newuser", "password123", "newuser@example.com");
    }

    @Then("我应该能够成功注册")
    public void 我应该能够成功注册() {
        assertTrue("注册应该成功", authResult.isSuccess());
    }

    @And("我应该看到 {string} 的消息")
    public void 我应该看到的消息(String expectedMessage) {
        assertEquals("消息不匹配", expectedMessage, authResult.getMessage());
    }

    @Then("我应该无法注册")
    public void 我应该无法注册() {
        assertFalse("注册应该失败", authResult.isSuccess());
    }

    @When("我尝试登录")
    public void 我尝试登录() {
        // 在实际应用中，这里应该使用之前存储的值
        // 为了简化，我们使用固定的值
        authResult = AuthHooks.getAuthService().login("testuser", "password123");
    }

    @Then("我应该能够成功登录")
    public void 我应该能够成功登录() {
        assertTrue("登录应该成功", authResult.isSuccess());
    }

    @Then("我应该无法登录")
    public void 我应该无法登录() {
        assertFalse("登录应该失败", authResult.isSuccess());
    }

    @When("我请求重置密码使用邮箱 {string}")
    public void 我请求重置密码使用邮箱(String email) {
        resetToken = AuthHooks.getAuthService().createPasswordResetToken(email).orElse(null);
    }

    @Then("我应该收到重置令牌")
    public void 我应该收到重置令牌() {
        assertNotNull("应该收到重置令牌", resetToken);
    }

    @And("我使用重置令牌和新密码 {string} 重置密码")
    public void 我使用重置令牌和新密码重置密码(String newPassword) {
        authResult = AuthHooks.getAuthService().resetPassword(resetToken, newPassword);
    }

    @Then("我应该能够成功重置密码")
    public void 我应该能够成功重置密码() {
        assertTrue("密码重置应该成功", authResult.isSuccess());
    }

    @Then("我不应该收到重置令牌")
    public void 我不应该收到重置令牌() {
        assertNull("不应该收到重置令牌", resetToken);
    }

    @When("我使用重置令牌 {string} 和新密码 {string} 重置密码")
    public void 我使用重置令牌和新密码重置密码(String token, String newPassword) {
        authResult = AuthHooks.getAuthService().resetPassword(token, newPassword);
    }

    @Then("我应该无法重置密码")
    public void 我应该无法重置密码() {
        assertFalse("密码重置应该失败", authResult.isSuccess());
    }

    @When("我尝试注册")
    public void 我尝试注册(String username, String password, String email) {
        authResult = AuthHooks.getAuthService().register(username, password, email);
    }

    @Then("我应该{string}注册")
    public void 我应该注册(String success) {
        if ("能够".equals(success)) {
            assertTrue("注册应该成功", authResult.isSuccess());
        } else {
            assertFalse("注册应该失败", authResult.isSuccess());
        }
    }
}
```

8. **创建测试运行器**

创建`src/test/java/com/example/cucumber/runners/UserAuthTestRunner.java`：

```java
package com.example.cucumber.runners;

import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(
    features = "src/test/resources/features",
    glue = {"com.example.cucumber.stepdefinitions", "com.example.cucumber.hooks"},
    plugin = {"pretty", "html:target/cucumber-reports/user-auth-report.html"},
    tags = "@user-auth"
)
public class UserAuthTestRunner {
}
```

9. **创建标签特定的测试运行器**

创建`src/test/java/com/example/cucumber/runners/RegistrationTestRunner.java`：

```java
package com.example.cucumber.runners;

import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(
    features = "src/test/resources/features",
    glue = {"com.example.cucumber.stepdefinitions", "com.example.cucumber.hooks"},
    plugin = {"pretty", "html:target/cucumber-reports/registration-report.html"},
    tags = "@registration"
)
public class RegistrationTestRunner {
}
```

10. **运行测试**

```bash
# 运行所有用户认证测试
mvn test -Dtest=UserAuthTestRunner

# 只运行注册测试
mvn test -Dtest=RegistrationTestRunner
```

### 实验要求

1. 成功运行所有测试场景
2. 理解标签和Hooks的使用
3. 尝试添加新的测试场景和标签

### 实验思考

1. Hooks在测试生命周期中有什么作用？如何合理使用？
2. 标签如何帮助组织和管理测试？如何设计标签策略？
3. 在复杂的状态管理场景下，如何保持步骤定义的简洁性？

## 实验总结

通过以上三个实验，您应该已经掌握了：

1. Cucumber的基本概念和用法
2. 特性文件的编写技巧
3. 步骤定义的实现方法
4. 数据表和场景大纲的使用
5. 标签和Hooks的应用

这些技能为您深入学习Cucumber和在实际项目中应用BDD打下了坚实的基础。在后续章节中，我们将继续探讨更高级的Cucumber特性和最佳实践。

## 扩展练习

如果您想进一步挑战自己，可以尝试以下扩展练习：

1. 为计算器实验添加科学计算功能
2. 为购物车实验添加优惠券和折扣功能
3. 为用户认证实验添加账户激活和邮箱验证功能
4. 尝试将Cucumber与Selenium集成，实现Web UI测试
5. 探索Cucumber与REST API测试的结合