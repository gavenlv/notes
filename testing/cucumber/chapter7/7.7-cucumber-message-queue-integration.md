# 7.7 Cucumber与消息队列集成

## 引言

在现代分布式系统中，消息队列是实现系统解耦、异步处理和削峰填谷的重要组件。测试消息队列集成是确保系统可靠性的关键环节。Cucumber与消息队列的集成使我们能够编写端到端的验收测试，验证消息的生产、消费和处理逻辑。本章将深入探讨Cucumber与各种消息队列的集成方式、测试策略和最佳实践。

## 集成基础

### 依赖配置

#### Maven依赖

```xml
<dependencies>
    <!-- Cucumber核心依赖 -->
    <dependency>
        <groupId>io.cucumber</groupId>
        <artifactId>cucumber-java</artifactId>
        <version>7.11.0</version>
        <scope>test</scope>
    </dependency>
    
    <dependency>
        <groupId>io.cucumber</groupId>
        <artifactId>cucumber-junit</artifactId>
        <version>7.11.0</version>
        <scope>test</scope>
    </dependency>
    
    <!-- Spring Boot测试依赖 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <version>3.0.5</version>
        <scope>test</scope>
    </dependency>
    
    <!-- Spring AMQP依赖（RabbitMQ） -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-amqp</artifactId>
        <version>3.0.5</version>
        <scope>test</scope>
    </dependency>
    
    <!-- Spring Kafka依赖 -->
    <dependency>
        <groupId>org.springframework.kafka</groupId>
        <artifactId>spring-kafka</artifactId>
        <version>3.0.5</version>
        <scope>test</scope>
    </dependency>
    
    <!-- Spring JMS依赖（ActiveMQ） -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-activemq</artifactId>
        <version>3.0.5</version>
        <scope>test</scope>
    </dependency>
    
    <!-- Testcontainers（用于集成测试） -->
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>junit-jupiter</artifactId>
        <version>1.17.6</version>
        <scope>test</scope>
    </dependency>
    
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>rabbitmq</artifactId>
        <version>1.17.6</version>
        <scope>test</scope>
    </dependency>
    
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>kafka</artifactId>
        <version>1.17.6</version>
        <scope>test</scope>
    </dependency>
    
    <!-- Awaitility（用于异步测试） -->
    <dependency>
        <groupId>org.awaitility</groupId>
        <artifactId>awaitility</artifactId>
        <version>4.2.0</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

#### Gradle依赖

```groovy
dependencies {
    testImplementation 'io.cucumber:cucumber-java:7.11.0'
    testImplementation 'io.cucumber:cucumber-junit:7.11.0'
    testImplementation 'org.springframework.boot:spring-boot-starter-test:3.0.5'
    testImplementation 'org.springframework.boot:spring-boot-starter-amqp:3.0.5'
    testImplementation 'org.springframework.kafka:spring-kafka:3.0.5'
    testImplementation 'org.springframework.boot:spring-boot-starter-activemq:3.0.5'
    testImplementation 'org.testcontainers:junit-jupiter:1.17.6'
    testImplementation 'org.testcontainers:rabbitmq:1.17.6'
    testImplementation 'org.testcontainers:kafka:1.17.6'
    testImplementation 'org.awaitility:awaitility:4.2.0'
}
```

### 测试配置

#### application-test.properties

```properties
# RabbitMQ测试配置
spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
spring.rabbitmq.virtual-host=/

# Kafka测试配置
spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.consumer.group-id=test-group
spring.kafka.consumer.auto-offset-reset=earliest
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer

# ActiveMQ测试配置
spring.activemq.broker-url=tcp://localhost:61616
spring.activemq.user=admin
spring.activemq.password=admin
spring.jms.pub-sub-domain=false
```

## RabbitMQ集成

### 基本RabbitMQ配置

#### RabbitMQ配置类

```java
package com.example.gherkin.config;

import org.springframework.amqp.core.*;
import org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.amqp.support.converter.MessageConverter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitMQConfig {
    
    public static final String USER_QUEUE = "user.queue";
    public static final String USER_EXCHANGE = "user.exchange";
    public static final String USER_ROUTING_KEY = "user.routing.key";
    
    @Bean
    public Queue userQueue() {
        return QueueBuilder.durable(USER_QUEUE).build();
    }
    
    @Bean
    public TopicExchange userExchange() {
        return new TopicExchange(USER_EXCHANGE);
    }
    
    @Bean
    public Binding userBinding() {
        return BindingBuilder
                .bind(userQueue())
                .to(userExchange())
                .with(USER_ROUTING_KEY);
    }
    
    @Bean
    public MessageConverter messageConverter() {
        return new Jackson2JsonMessageConverter();
    }
    
    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
        rabbitTemplate.setMessageConverter(messageConverter());
        return rabbitTemplate;
    }
    
    @Bean
    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(
            ConnectionFactory connectionFactory) {
        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory);
        factory.setMessageConverter(messageConverter());
        return factory;
    }
}
```

#### 消息模型

```java
package com.example.gherkin.models;

import com.fasterxml.jackson.annotation.JsonFormat;

import java.time.LocalDateTime;

public class UserMessage {
    
    private Long id;
    private String username;
    private String email;
    private String action;
    
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime timestamp;
    
    public UserMessage() {
        this.timestamp = LocalDateTime.now();
    }
    
    public UserMessage(Long id, String username, String email, String action) {
        this();
        this.id = id;
        this.username = username;
        this.email = email;
        this.action = action;
    }
    
    // Getters和Setters
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getUsername() {
        return username;
    }
    
    public void setUsername(String username) {
        this.username = username;
    }
    
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
    
    public String getAction() {
        return action;
    }
    
    public void setAction(String action) {
        this.action = action;
    }
    
    public LocalDateTime getTimestamp() {
        return timestamp;
    }
    
    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }
}
```

#### 消息生产者

```java
package com.example.gherkin.producers;

import com.example.gherkin.config.RabbitMQConfig;
import com.example.gherkin.models.UserMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserMessageProducer {
    
    private static final Logger logger = LoggerFactory.getLogger(UserMessageProducer.class);
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    public void sendUserMessage(UserMessage message) {
        logger.info("发送用户消息: {}", message);
        rabbitTemplate.convertAndSend(
            RabbitMQConfig.USER_EXCHANGE,
            RabbitMQConfig.USER_ROUTING_KEY,
            message
        );
    }
}
```

#### 消息消费者

```java
package com.example.gherkin.consumers;

import com.example.gherkin.config.RabbitMQConfig;
import com.example.gherkin.models.UserMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;

@Component
public class UserMessageConsumer {
    
    private static final Logger logger = LoggerFactory.getLogger(UserMessageConsumer.class);
    
    private final List<UserMessage> receivedMessages = new ArrayList<>();
    
    @RabbitListener(queues = RabbitMQConfig.USER_QUEUE)
    public void receiveUserMessage(UserMessage message) {
        logger.info("接收到用户消息: {}", message);
        receivedMessages.add(message);
    }
    
    public List<UserMessage> getReceivedMessages() {
        return new ArrayList<>(receivedMessages);
    }
    
    public void clearReceivedMessages() {
        receivedMessages.clear();
    }
    
    public boolean hasReceivedMessageForUser(String username) {
        return receivedMessages.stream()
                .anyMatch(msg -> msg.getUsername().equals(username));
    }
    
    public UserMessage getLastReceivedMessage() {
        if (receivedMessages.isEmpty()) {
            return null;
        }
        return receivedMessages.get(receivedMessages.size() - 1);
    }
}
```

#### RabbitMQ步骤定义

```java
package com.example.gherkin.stepdefinitions.rabbitmq;

import io.cucumber.java.en.*;
import com.example.gherkin.models.UserMessage;
import com.example.gherkin.producers.UserMessageProducer;
import com.example.gherkin.consumers.UserMessageConsumer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.List;
import java.util.concurrent.TimeUnit;

import static org.awaitility.Awaitility.await;
import static org.junit.Assert.*;

@SpringBootTest
public class RabbitMQSteps {
    
    @Autowired
    private UserMessageProducer messageProducer;
    
    @Autowired
    private UserMessageConsumer messageConsumer;
    
    private UserMessage sentMessage;
    private List<UserMessage> receivedMessages;
    
    @Given("RabbitMQ消息生产者已启动")
    public void rabbitMQMessageProducerIsStarted() {
        assertNotNull("消息生产者不应为空", messageProducer);
    }
    
    @Given("RabbitMQ消息消费者已启动")
    public void rabbitMQMessageConsumerIsStarted() {
        assertNotNull("消息消费者不应为空", messageConsumer);
        messageConsumer.clearReceivedMessages();
    }
    
    @Given("创建用户消息，ID为 {long}，用户名为 {string}，邮箱为 {string}，动作为 {string}")
    public void createUserMessage(Long id, String username, String email, String action) {
        sentMessage = new UserMessage(id, username, email, action);
        assertNotNull("创建的消息不应为空", sentMessage);
    }
    
    @When("发送用户消息到RabbitMQ")
    public void sendUserMessageToRabbitMQ() {
        messageProducer.sendUserMessage(sentMessage);
    }
    
    @When("等待消息被消费")
    public void waitForMessageToBeConsumed() {
        await().atMost(5, TimeUnit.SECONDS).until(() -> 
            messageConsumer.hasReceivedMessageForUser(sentMessage.getUsername())
        );
    }
    
    @When("获取所有接收到的消息")
    public void getAllReceivedMessages() {
        receivedMessages = messageConsumer.getReceivedMessages();
        assertNotNull("接收到的消息列表不应为空", receivedMessages);
    }
    
    @Then("应该接收到 {int} 条消息")
    public void shouldReceiveMessages(int count) {
        assertEquals("消息数量应该匹配", count, receivedMessages.size());
    }
    
    @Then("接收到的消息ID应该为 {long}")
    public void receivedMessageIdShouldBe(Long id) {
        UserMessage lastMessage = messageConsumer.getLastReceivedMessage();
        assertNotNull("最后一条消息不应为空", lastMessage);
        assertEquals("消息ID应该匹配", id, lastMessage.getId());
    }
    
    @Then("接收到的消息用户名应该为 {string}")
    public void receivedMessageUsernameShouldBe(String username) {
        UserMessage lastMessage = messageConsumer.getLastReceivedMessage();
        assertNotNull("最后一条消息不应为空", lastMessage);
        assertEquals("消息用户名应该匹配", username, lastMessage.getUsername());
    }
    
    @Then("接收到的消息邮箱应该为 {string}")
    public void receivedMessageEmailShouldBe(String email) {
        UserMessage lastMessage = messageConsumer.getLastReceivedMessage();
        assertNotNull("最后一条消息不应为空", lastMessage);
        assertEquals("消息邮箱应该匹配", email, lastMessage.getEmail());
    }
    
    @Then("接收到的消息动作为 {string}")
    public void receivedMessageActionShouldBe(String action) {
        UserMessage lastMessage = messageConsumer.getLastReceivedMessage();
        assertNotNull("最后一条消息不应为空", lastMessage);
        assertEquals("消息动作应该匹配", action, lastMessage.getAction());
    }
}
```

#### RabbitMQ特性文件

#### rabbitmq_messaging.feature

```gherkin
Feature: RabbitMQ消息队列测试
  作为系统开发者
  我希望测试RabbitMQ消息的发送和接收
  以便确保消息队列功能正常工作

  Background:
    Given RabbitMQ消息生产者已启动
    And RabbitMQ消息消费者已启动

  Scenario: 发送和接收用户消息
    Given 创建用户消息，ID为 1，用户名为 "testuser"，邮箱为 "testuser@example.com"，动作为 "CREATE"
    When 发送用户消息到RabbitMQ
    And 等待消息被消费
    Then 接收到的消息ID应该为 1
    And 接收到的消息用户名应该为 "testuser"
    And 接收到的消息邮箱应该为 "testuser@example.com"
    And 接收到的消息动作为 "CREATE"

  Scenario: 发送多条消息
    Given 创建用户消息，ID为 1，用户名为 "user1"，邮箱为 "user1@example.com"，动作为 "CREATE"
    And 发送用户消息到RabbitMQ
    And 创建用户消息，ID为 2，用户名为 "user2"，邮箱为 "user2@example.com"，动作为 "UPDATE"
    And 发送用户消息到RabbitMQ
    When 等待消息被消费
    And 获取所有接收到的消息
    Then 应该接收到 2 条消息
```

## Kafka集成

### 基本Kafka配置

#### Kafka配置类

```java
package com.example.gherkin.config;

import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.annotation.EnableKafka;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.core.*;
import org.springframework.kafka.support.serializer.JsonDeserializer;
import org.springframework.kafka.support.serializer.JsonSerializer;

import java.util.HashMap;
import java.util.Map;

@Configuration
@EnableKafka
public class KafkaConfig {
    
    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;
    
    @Value("${spring.kafka.consumer.group-id}")
    private String consumerGroupId;
    
    @Bean
    public ProducerFactory<String, Object> producerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        return new DefaultKafkaProducerFactory<>(configProps);
    }
    
    @Bean
    public KafkaTemplate<String, Object> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
    
    @Bean
    public ConsumerFactory<String, Object> consumerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ConsumerConfig.GROUP_ID_CONFIG, consumerGroupId);
        configProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        configProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);
        configProps.put(JsonDeserializer.TRUSTED_PACKAGES, "com.example.gherkin.models");
        configProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        return new DefaultKafkaConsumerFactory<>(configProps);
    }
    
    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, Object> kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, Object> factory = 
            new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());
        return factory;
    }
}
```

#### Kafka主题配置

```java
package com.example.gherkin.config;

import org.apache.kafka.clients.admin.AdminClientConfig;
import org.apache.kafka.clients.admin.NewTopic;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.core.KafkaAdmin;

import java.util.HashMap;
import java.util.Map;

@Configuration
public class KafkaTopicConfig {
    
    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;
    
    @Bean
    public KafkaAdmin kafkaAdmin() {
        Map<String, Object> configs = new HashMap<>();
        configs.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        return new KafkaAdmin(configs);
    }
    
    @Bean
    public NewTopic userTopic() {
        return new NewTopic("user-topic", 1, (short) 1);
    }
}
```

#### Kafka消息生产者

```java
package com.example.gherkin.producers;

import com.example.gherkin.models.UserMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

@Service
public class UserKafkaProducer {
    
    private static final Logger logger = LoggerFactory.getLogger(UserKafkaProducer.class);
    
    private static final String TOPIC = "user-topic";
    
    @Autowired
    private KafkaTemplate<String, Object> kafkaTemplate;
    
    public void sendUserMessage(UserMessage message) {
        logger.info("发送用户消息到Kafka: {}", message);
        kafkaTemplate.send(TOPIC, message.getUsername(), message);
    }
}
```

#### Kafka消息消费者

```java
package com.example.gherkin.consumers;

import com.example.gherkin.models.UserMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;

@Component
public class UserKafkaConsumer {
    
    private static final Logger logger = LoggerFactory.getLogger(UserKafkaConsumer.class);
    
    private final List<UserMessage> receivedMessages = new ArrayList<>();
    
    @KafkaListener(topics = "user-topic", groupId = "user-group")
    public void receiveUserMessage(UserMessage message) {
        logger.info("从Kafka接收到用户消息: {}", message);
        receivedMessages.add(message);
    }
    
    public List<UserMessage> getReceivedMessages() {
        return new ArrayList<>(receivedMessages);
    }
    
    public void clearReceivedMessages() {
        receivedMessages.clear();
    }
    
    public boolean hasReceivedMessageForUser(String username) {
        return receivedMessages.stream()
                .anyMatch(msg -> msg.getUsername().equals(username));
    }
    
    public UserMessage getLastReceivedMessage() {
        if (receivedMessages.isEmpty()) {
            return null;
        }
        return receivedMessages.get(receivedMessages.size() - 1);
    }
}
```

#### Kafka步骤定义

```java
package com.example.gherkin.stepdefinitions.kafka;

import io.cucumber.java.en.*;
import com.example.gherkin.models.UserMessage;
import com.example.gherkin.producers.UserKafkaProducer;
import com.example.gherkin.consumers.UserKafkaConsumer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.List;
import java.util.concurrent.TimeUnit;

import static org.awaitility.Awaitility.await;
import static org.junit.Assert.*;

@SpringBootTest
public class KafkaSteps {
    
    @Autowired
    private UserKafkaProducer messageProducer;
    
    @Autowired
    private UserKafkaConsumer messageConsumer;
    
    private UserMessage sentMessage;
    private List<UserMessage> receivedMessages;
    
    @Given("Kafka消息生产者已启动")
    public void kafkaMessageProducerIsStarted() {
        assertNotNull("消息生产者不应为空", messageProducer);
    }
    
    @Given("Kafka消息消费者已启动")
    public void kafkaMessageConsumerIsStarted() {
        assertNotNull("消息消费者不应为空", messageConsumer);
        messageConsumer.clearReceivedMessages();
    }
    
    @Given("创建Kafka用户消息，ID为 {long}，用户名为 {string}，邮箱为 {string}，动作为 {string}")
    public void createKafkaUserMessage(Long id, String username, String email, String action) {
        sentMessage = new UserMessage(id, username, email, action);
        assertNotNull("创建的消息不应为空", sentMessage);
    }
    
    @When("发送用户消息到Kafka")
    public void sendUserMessageToKafka() {
        messageProducer.sendUserMessage(sentMessage);
    }
    
    @When("等待Kafka消息被消费")
    public void waitForKafkaMessageToBeConsumed() {
        await().atMost(5, TimeUnit.SECONDS).until(() -> 
            messageConsumer.hasReceivedMessageForUser(sentMessage.getUsername())
        );
    }
    
    @When("获取所有从Kafka接收到的消息")
    public void getAllReceivedKafkaMessages() {
        receivedMessages = messageConsumer.getReceivedMessages();
        assertNotNull("接收到的消息列表不应为空", receivedMessages);
    }
    
    @Then("应该从Kafka接收到 {int} 条消息")
    public void shouldReceiveKafkaMessages(int count) {
        assertEquals("消息数量应该匹配", count, receivedMessages.size());
    }
    
    @Then("从Kafka接收到的消息ID应该为 {long}")
    public void receivedKafkaMessageIdShouldBe(Long id) {
        UserMessage lastMessage = messageConsumer.getLastReceivedMessage();
        assertNotNull("最后一条消息不应为空", lastMessage);
        assertEquals("消息ID应该匹配", id, lastMessage.getId());
    }
    
    @Then("从Kafka接收到的消息用户名应该为 {string}")
    public void receivedKafkaMessageUsernameShouldBe(String username) {
        UserMessage lastMessage = messageConsumer.getLastReceivedMessage();
        assertNotNull("最后一条消息不应为空", lastMessage);
        assertEquals("消息用户名应该匹配", username, lastMessage.getUsername());
    }
}
```

#### Kafka特性文件

#### kafka_messaging.feature

```gherkin
Feature: Kafka消息队列测试
  作为系统开发者
  我希望测试Kafka消息的发送和接收
  以便确保消息队列功能正常工作

  Background:
    Given Kafka消息生产者已启动
    And Kafka消息消费者已启动

  Scenario: 发送和接收Kafka用户消息
    Given 创建Kafka用户消息，ID为 1，用户名为 "kafkauser"，邮箱为 "kafkauser@example.com"，动作为 "CREATE"
    When 发送用户消息到Kafka
    And 等待Kafka消息被消费
    Then 从Kafka接收到的消息ID应该为 1
    And 从Kafka接收到的消息用户名应该为 "kafkauser"

  Scenario: 发送多条Kafka消息
    Given 创建Kafka用户消息，ID为 1，用户名为 "kafkauser1"，邮箱为 "kafkauser1@example.com"，动作为 "CREATE"
    And 发送用户消息到Kafka
    And 创建Kafka用户消息，ID为 2，用户名为 "kafkauser2"，邮箱为 "kafkauser2@example.com"，动作为 "UPDATE"
    And 发送用户消息到Kafka
    When 等待Kafka消息被消费
    And 获取所有从Kafka接收到的消息
    Then 应该从Kafka接收到 2 条消息
```

## Testcontainers集成

### Testcontainers配置

#### RabbitMQ Testcontainers配置

```java
package com.example.gherkin.config;

import org.junit.jupiter.api.BeforeAll;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.testcontainers.containers.RabbitMQContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

@SpringBootTest
@ActiveProfiles("integration-test")
@Testcontainers
public abstract class BaseRabbitMQIntegrationTest {
    
    @Container
    static RabbitMQContainer rabbitmq = new RabbitMQContainer("rabbitmq:3.11-management")
            .withReuse(true);
    
    @BeforeAll
    static void setUp() {
        System.setProperty("spring.rabbitmq.host", rabbitmq.getHost());
        System.setProperty("spring.rabbitmq.port", String.valueOf(rabbitmq.getMappedPort(5672)));
        System.setProperty("spring.rabbitmq.username", rabbitmq.getAdminUsername());
        System.setProperty("spring.rabbitmq.password", rabbitmq.getAdminPassword());
    }
}
```

#### Kafka Testcontainers配置

```java
package com.example.gherkin.config;

import org.junit.jupiter.api.BeforeAll;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.testcontainers.containers.KafkaContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import org.testcontainers.utility.DockerImageName;

@SpringBootTest
@ActiveProfiles("integration-test")
@Testcontainers
public abstract class BaseKafkaIntegrationTest {
    
    @Container
    static KafkaContainer kafka = new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:7.2.1"))
            .withReuse(true);
    
    @BeforeAll
    static void setUp() {
        System.setProperty("spring.kafka.bootstrap-servers", kafka.getBootstrapServers());
    }
}
```

#### 集成测试运行器

```java
package com.example.gherkin;

import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import com.example.gherkin.config.BaseRabbitMQIntegrationTest;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(
    features = {"src/test/resources/features/integration/rabbitmq"},
    glue = {"com.example.gherkin.stepdefinitions.integration.rabbitmq"},
    plugin = {
        "pretty",
        "html:target/cucumber-reports",
        "json:target/cucumber-reports/cucumber.json"
    },
    monochrome = true,
    tags = "@rabbitmq-integration"
)
public class CucumberRabbitMQIntegrationTest extends BaseRabbitMQIntegrationTest {
}
```

## 最佳实践

### 1. 使用Testcontainers进行集成测试

**原则**：使用Testcontainers进行消息队列集成测试，模拟真实环境。

**指导**：
- 配置Testcontainers容器
- 使用@Container注解管理容器生命周期
- 配置容器重用以提高测试速度

### 2. 使用Awaitility处理异步操作

**原则**：使用Awaitility处理异步消息操作，确保测试的稳定性。

**指导**：
- 使用await().atMost()设置超时时间
- 使用until()条件等待消息被处理
- 避免使用Thread.sleep()进行硬编码等待

### 3. 分离测试配置

**原则**：分离测试配置，避免测试影响生产环境。

**指导**：
- 使用application-test.properties配置测试环境
- 使用@ActiveProfiles激活测试配置
- 使用不同的消息队列配置

### 4. 使用消息收集器验证消息

**原则**：使用消息收集器收集接收到的消息，便于验证。

**指导**：
- 创建消息消费者收集器
- 提供查询和清理方法
- 在测试前清理历史消息

### 5. 使用消息模板简化测试

**原则**：使用消息模板简化消息发送和接收的测试代码。

**指导**：
- 创建消息模板类
- 封装常用的消息操作
- 提供类型安全的消息处理

### 6. 使用测试标签组织测试

**原则**：使用测试标签组织不同类型的消息队列测试。

**指导**：
- 使用@rabbitmq、@kafka等标签区分测试类型
- 使用@integration标签标记集成测试
- 使用@slow标记耗时较长的测试

## 总结

Cucumber与消息队列的集成为BDD测试提供了强大的异步处理能力，通过RabbitMQ、Kafka和Testcontainers，我们可以构建全面、可靠的消息队列集成测试体系。

在实际项目中，应该根据项目需求选择合适的消息队列集成策略，并遵循最佳实践。通过合理的配置和设计，Cucumber与消息队列的集成可以大大提高测试覆盖率，确保应用程序与消息队列的交互正确无误。