# 7.5 Cucumber与Mockito集成详解

## 引言

在单元测试和集成测试中，模拟对象（Mock Objects）是隔离测试依赖、提高测试速度和可靠性的重要技术。Mockito作为Java生态中最流行的模拟框架，与Cucumber结合可以实现强大的行为驱动测试。本章将深入探讨Cucumber与Mockito的集成方式、配置方法和最佳实践，帮助读者构建高效、可维护的测试体系。

## 集成基础

### 依赖配置

#### Maven依赖

```xml
<dependencies>
    <!-- Mockito核心依赖 -->
    <dependency>
        <groupId>org.mockito</groupId>
        <artifactId>mockito-core</artifactId>
        <version>5.3.1</version>
        <scope>test</scope>
    </dependency>
    
    <!-- Mockito JUnit集成 -->
    <dependency>
        <groupId>org.mockito</groupId>
        <artifactId>mockito-junit-jupiter</artifactId>
        <version>5.3.1</version>
        <scope>test</scope>
    </dependency>
    
    <!-- Cucumber核心依赖 -->
    <dependency>
        <groupId>io.cucumber</groupId>
        <artifactId>cucumber-java</artifactId>
        <version>7.11.0</version>
        <scope>test</scope>
    </dependency>
    
    <!-- Cucumber JUnit集成 -->
    <dependency>
        <groupId>io.cucumber</groupId>
        <artifactId>cucumber-junit</artifactId>
        <version>7.11.0</version>
        <scope>test</scope>
    </dependency>
    
    <!-- Cucumber Spring集成（可选） -->
    <dependency>
        <groupId>io.cucumber</groupId>
        <artifactId>cucumber-spring</artifactId>
        <version>7.11.0</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

#### Gradle依赖

```groovy
dependencies {
    testImplementation 'org.mockito:mockito-core:5.3.1'
    testImplementation 'org.mockito:mockito-junit-jupiter:5.3.1'
    testImplementation 'io.cucumber:cucumber-java:7.11.0'
    testImplementation 'io.cucumber:cucumber-junit:7.11.0'
    testImplementation 'io.cucumber:cucumber-spring:7.11.0'
}
```

### 基本测试运行器

```java
package com.example.gherkin;

import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(
    features = {"src/test/resources/features"},
    glue = {"com.example.gherkin.stepdefinitions"},
    plugin = {
        "pretty",
        "html:target/cucumber-reports",
        "json:target/cucumber-reports/cucumber.json"
    },
    monochrome = true
)
public class CucumberMockitoIntegrationTest {
}
```

## Mockito基础

### 基本模拟

#### 创建模拟对象

```java
package com.example.gherkin.stepdefinitions;

import io.cucumber.java.en.*;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import com.example.gherkin.services.UserService;
import com.example.gherkin.services.EmailService;
import com.example.gherkin.models.User;
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

public class BasicMockingSteps {
    
    @Mock
    private UserService userService;
    
    @Mock
    private EmailService emailService;
    
    @Before
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }
    
    @Given("用户服务模拟已创建")
    public void userServiceMockIsCreated() {
        assertNotNull("用户服务模拟不应为空", userService);
    }
    
    @Given("当调用用户服务查找用户 {string} 时返回模拟用户")
    public void whenUserServiceFindUserCalledReturnMockUser(String username) {
        User mockUser = new User();
        mockUser.setUsername(username);
        mockUser.setEmail(username + "@example.com");
        
        when(userService.findByUsername(username)).thenReturn(mockUser);
    }
    
    @When("调用用户服务查找用户 {string}")
    public void callUserServiceFindUser(String username) {
        User user = userService.findByUsername(username);
        assertNotNull("用户不应为空", user);
        assertEquals("用户名应该匹配", username, user.getUsername());
    }
    
    @Then("验证用户服务查找方法被调用一次")
    public void verifyUserServiceFindMethodCalledOnce() {
        verify(userService, times(1)).findByUsername(anyString());
    }
    
    @Then("验证邮件服务发送方法被调用一次")
    public void verifyEmailServiceSendMethodCalledOnce() {
        verify(emailService, times(1)).sendEmail(anyString(), anyString(), anyString());
    }
}
```

#### 参数匹配

```java
package com.example.gherkin.stepdefinitions;

import io.cucumber.java.en.*;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import com.example.gherkin.services.UserService;
import com.example.gherkin.models.User;
import static org.mockito.Mockito.*;
import static org.mockito.ArgumentMatchers.*;
import static org.junit.Assert.*;

public class ArgumentMatcherSteps {
    
    @Mock
    private UserService userService;
    
    @Before
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }
    
    @Given("当调用用户服务查找用户时返回模拟用户")
    public void whenUserServiceFindUserCalledReturnMockUser() {
        User mockUser = new User();
        mockUser.setUsername("testuser");
        mockUser.setEmail("testuser@example.com");
        
        // 使用anyString()匹配器
        when(userService.findByUsername(anyString())).thenReturn(mockUser);
    }
    
    @When("调用用户服务查找用户 {string}")
    public void callUserServiceFindUser(String username) {
        User user = userService.findByUsername(username);
        assertNotNull("用户不应为空", user);
    }
    
    @Then("验证用户服务查找方法被调用，参数为 {string}")
    public void verifyUserServiceFindMethodCalledWith(String username) {
        verify(userService, times(1)).findByUsername(eq(username));
    }
    
    @Then("验证用户服务查找方法被调用，参数包含 {string}")
    public void verifyUserServiceFindMethodCalledWithContains(String substring) {
        verify(userService, times(1)).findByUsername(contains(substring));
    }
    
    @Then("验证用户服务查找方法被调用，参数以 {string} 开头")
    public void verifyUserServiceFindMethodCalledWithStartsWith(String prefix) {
        verify(userService, times(1)).findByUsername(startsWith(prefix));
    }
    
    @Then("验证用户服务查找方法被调用，参数以 {string} 结尾")
    public void verifyUserServiceFindMethodCalledWithEndsWith(String suffix) {
        verify(userService, times(1)).findByUsername(endsWith(suffix));
    }
    
    @Then("验证用户服务查找方法被调用，参数匹配正则表达式 {string}")
    public void verifyUserServiceFindMethodCalledWithRegex(String regex) {
        verify(userService, times(1)).findByUsername(matches(regex));
    }
}
```

### 高级模拟

#### 连续调用

```java
package com.example.gherkin.stepdefinitions;

import io.cucumber.java.en.*;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import com.example.gherkin.services.UserService;
import com.example.gherkin.models.User;
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

public class ConsecutiveCallsSteps {
    
    @Mock
    private UserService userService;
    
    @Before
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }
    
    @Given("当连续调用用户服务查找用户 {string} 时返回不同的用户")
    public void whenConsecutiveCallsToUserServiceFindUserReturnDifferentUsers(String username) {
        User firstUser = new User();
        firstUser.setUsername(username);
        firstUser.setEmail(username + "@example.com");
        
        User secondUser = new User();
        secondUser.setUsername(username + "2");
        secondUser.setEmail(username + "2@example.com");
        
        // 配置连续调用返回不同值
        when(userService.findByUsername(username))
            .thenReturn(firstUser)
            .thenReturn(secondUser)
            .thenReturn(null);
    }
    
    @When("第一次调用用户服务查找用户 {string}")
    public void firstCallToUserServiceFindUser(String username) {
        User user = userService.findByUsername(username);
        assertNotNull("用户不应为空", user);
        assertEquals("用户名应该匹配", username, user.getUsername());
    }
    
    @When("第二次调用用户服务查找用户 {string}")
    public void secondCallToUserServiceFindUser(String username) {
        User user = userService.findByUsername(username);
        assertNotNull("用户不应为空", user);
        assertEquals("用户名应该匹配", username + "2", user.getUsername());
    }
    
    @When("第三次调用用户服务查找用户 {string}")
    public void thirdCallToUserServiceFindUser(String username) {
        User user = userService.findByUsername(username);
        assertNull("用户应该为空", user);
    }
    
    @Then("验证用户服务查找方法被调用三次")
    public void verifyUserServiceFindMethodCalledThreeTimes() {
        verify(userService, times(3)).findByUsername(anyString());
    }
}
```

#### 异常模拟

```java
package com.example.gherkin.stepdefinitions;

import io.cucumber.java.en.*;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import com.example.gherkin.services.UserService;
import com.example.gherkin.exceptions.UserNotFoundException;
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

public class ExceptionMockingSteps {
    
    @Mock
    private UserService userService;
    
    @Before
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }
    
    @Given("当调用用户服务查找用户 {string} 时抛出用户未找到异常")
    public void whenUserServiceFindUserCalledThrowUserNotFoundException(String username) {
        when(userService.findByUsername(username))
            .thenThrow(new UserNotFoundException("用户未找到: " + username));
    }
    
    @When("调用用户服务查找用户 {string}")
    public void callUserServiceFindUser(String username) {
        try {
            User user = userService.findByUsername(username);
            fail("应该抛出异常");
        } catch (UserNotFoundException e) {
            // 预期的异常
            assertTrue("异常消息应该包含用户名", e.getMessage().contains(username));
        }
    }
    
    @Then("验证用户服务查找方法被调用一次")
    public void verifyUserServiceFindMethodCalledOnce() {
        verify(userservice, times(1)).findByUsername(anyString());
    }
}
```

## 与Spring集成

### 基本Spring集成

#### 使用@MockBean

```java
package com.example.gherkin.stepdefinitions;

import io.cucumber.java.en.*;
import io.cucumber.spring.CucumberContextConfiguration;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import com.example.gherkin.services.UserService;
import com.example.gherkin.services.EmailService;
import com.example.gherkin.models.User;
import com.example.gherkin.controllers.UserController;
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

@CucumberContextConfiguration
@SpringBootTest
public class SpringMockingSteps {
    
    @Autowired
    private UserController userController;
    
    @MockBean
    private UserService userService;
    
    @MockBean
    private EmailService emailService;
    
    @Given("用户服务模拟已配置")
    public void userServiceMockIsConfigured() {
        assertNotNull("用户服务模拟不应为空", userService);
    }
    
    @Given("当调用用户服务查找用户 {string} 时返回模拟用户")
    public void whenUserServiceFindUserCalledReturnMockUser(String username) {
        User mockUser = new User();
        mockUser.setUsername(username);
        mockUser.setEmail(username + "@example.com");
        
        when(userService.findByUsername(username)).thenReturn(mockUser);
    }
    
    @When("通过用户控制器获取用户 {string}")
    public void getUserThroughUserController(String username) {
        User user = userController.getUserByUsername(username);
        assertNotNull("用户不应为空", user);
        assertEquals("用户名应该匹配", username, user.getUsername());
    }
    
    @Then("验证用户服务查找方法被调用一次")
    public void verifyUserServiceFindMethodCalledOnce() {
        verify(userService, times(1)).findByUsername(anyString());
    }
}
```

### 高级Spring集成

#### 使用Spy

```java
package com.example.gherkin.stepdefinitions;

import io.cucumber.java.en.*;
import io.cucumber.spring.CucumberContextConfiguration;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.SpyBean;
import com.example.gherkin.services.UserService;
import com.example.gherkin.models.User;
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

@CucumberContextConfiguration
@SpringBootTest
public class SpringSpyingSteps {
    
    @Autowired
    private UserService userService;
    
    @SpyBean
    private EmailService emailService;
    
    @Given("邮件服务Spy已配置")
    public void emailServiceSpyIsConfigured() {
        assertNotNull("邮件服务Spy不应为空", emailService);
    }
    
    @Given("当调用邮件服务发送邮件时执行真实方法")
    public void whenEmailServiceSendCalledExecuteRealMethod() {
        // 使用doNothing()避免实际发送邮件
        doNothing().when(emailService).sendEmail(anyString(), anyString(), anyString());
    }
    
    @When("创建用户 {string}")
    public void createUser(String username) {
        User user = new User();
        user.setUsername(username);
        user.setEmail(username + "@example.com");
        
        userService.save(user);
    }
    
    @Then("验证邮件服务发送方法被调用一次")
    public void verifyEmailServiceSendMethodCalledOnce() {
        verify(emailService, times(1)).sendEmail(anyString(), anyString(), anyString());
    }
}
```

## 测试上下文与Mock管理

### Mock上下文

```java
package com.example.gherkin.context;

import org.mockito.Mockito;
import java.util.HashMap;
import java.util.Map;

public class MockContext {
    
    private final Map<String, Object> mocks;
    
    public MockContext() {
        this.mocks = new HashMap<>();
    }
    
    public <T> T addMock(Class<T> classToMock) {
        T mock = Mockito.mock(classToMock);
        mocks.put(classToMock.getName(), mock);
        return mock;
    }
    
    public <T> T getMock(Class<T> mockClass) {
        Object mock = mocks.get(mockClass.getName());
        if (mock == null) {
            throw new RuntimeException("Mock not found for class: " + mockClass.getName());
        }
        return mockClass.cast(mock);
    }
    
    public boolean containsMock(Class<?> mockClass) {
        return mocks.containsKey(mockClass.getName());
    }
    
    public void resetAllMocks() {
        mocks.values().forEach(Mockito::reset);
    }
    
    public void clear() {
        mocks.clear();
    }
}
```

### Mock管理器

```java
package com.example.gherkin.manager;

import com.example.gherkin.context.MockContext;
import io.cucumber.java.After;
import io.cucumber.java.Before;
import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class MockManager {
    
    @Autowired
    private MockContext mockContext;
    
    @Before
    public void setUp() {
        // 每个场景前的设置
    }
    
    @After
    public void tearDown() {
        // 每个场景后重置所有模拟对象
        mockContext.resetAllMocks();
    }
    
    public <T> T createMock(Class<T> classToMock) {
        return mockContext.addMock(classToMock);
    }
    
    public <T> T getMock(Class<T> mockClass) {
        return mockContext.getMock(mockClass);
    }
    
    public <T> boolean hasMock(Class<T> mockClass) {
        return mockContext.containsMock(mockClass);
    }
}
```

### 使用Mock管理器的步骤定义

```java
package com.example.gherkin.stepdefinitions;

import io.cucumber.java.en.*;
import com.example.gherkin.manager.MockManager;
import com.example.gherkin.services.UserService;
import com.example.gherkin.services.EmailService;
import com.example.gherkin.models.User;
import org.springframework.beans.factory.annotation.Autowired;
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

public class MockManagerSteps {
    
    @Autowired
    private MockManager mockManager;
    
    @Given("创建用户服务模拟")
    public void createUserServiceMock() {
        UserService userService = mockManager.createMock(UserService.class);
        assertNotNull("用户服务模拟不应为空", userService);
    }
    
    @Given("创建邮件服务模拟")
    public void createEmailServiceMock() {
        EmailService emailService = mockManager.createMock(EmailService.class);
        assertNotNull("邮件服务模拟不应为空", emailService);
    }
    
    @Given("当调用用户服务查找用户 {string} 时返回模拟用户")
    public void whenUserServiceFindUserCalledReturnMockUser(String username) {
        UserService userService = mockManager.getMock(UserService.class);
        
        User mockUser = new User();
        mockUser.setUsername(username);
        mockUser.setEmail(username + "@example.com");
        
        when(userService.findByUsername(username)).thenReturn(mockUser);
    }
    
    @When("调用用户服务查找用户 {string}")
    public void callUserServiceFindUser(String username) {
        UserService userService = mockManager.getMock(UserService.class);
        User user = userService.findByUsername(username);
        assertNotNull("用户不应为空", user);
        assertEquals("用户名应该匹配", username, user.getUsername());
    }
    
    @Then("验证用户服务查找方法被调用一次")
    public void verifyUserServiceFindMethodCalledOnce() {
        UserService userService = mockManager.getMock(UserService.class);
        verify(userService, times(1)).findByUsername(anyString());
    }
}
```

## 高级Mock技术

### Answer接口

```java
package com.example.gherkin.stepdefinitions;

import io.cucumber.java.en.*;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.stubbing.Answer;
import com.example.gherkin.services.UserService;
import com.example.gherkin.models.User;
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

public class AnswerInterfaceSteps {
    
    @Mock
    private UserService userService;
    
    @Before
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }
    
    @Given("当调用用户服务查找用户时使用Answer接口返回动态用户")
    public void whenUserServiceFindUserCalledUseAnswerInterfaceReturnDynamicUser() {
        // 使用Answer接口动态创建返回值
        when(userService.findByUsername(anyString())).thenAnswer(invocation -> {
            String username = invocation.getArgument(0);
            
            User user = new User();
            user.setUsername(username);
            user.setEmail(username + "@example.com");
            
            return user;
        });
    }
    
    @When("调用用户服务查找用户 {string}")
    public void callUserServiceFindUser(String username) {
        User user = userService.findByUsername(username);
        assertNotNull("用户不应为空", user);
        assertEquals("用户名应该匹配", username, user.getUsername());
        assertEquals("邮箱应该匹配", username + "@example.com", user.getEmail());
    }
    
    @Then("验证用户服务查找方法被调用一次")
    public void verifyUserServiceFindMethodCalledOnce() {
        verify(userService, times(1)).findByUsername(anyString());
    }
}
```

### ArgumentCaptor

```java
package com.example.gherkin.stepdefinitions;

import io.cucumber.java.en.*;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import com.example.gherkin.services.EmailService;
import com.example.gherkin.models.User;
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

public class ArgumentCaptorSteps {
    
    @Mock
    private EmailService emailService;
    
    @Before
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }
    
    @Given("邮件服务模拟已创建")
    public void emailServiceMockIsCreated() {
        assertNotNull("邮件服务模拟不应为空", emailService);
    }
    
    @When("发送邮件给用户")
    public void sendEmailToUser() {
        User user = new User();
        user.setUsername("testuser");
        user.setEmail("testuser@example.com");
        
        emailService.sendEmail(user.getEmail(), "欢迎", "欢迎加入我们的平台");
    }
    
    @Then("验证邮件参数")
    public void verifyEmailParameters() {
        // 创建参数捕获器
        ArgumentCaptor<String> emailCaptor = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> subjectCaptor = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> bodyCaptor = ArgumentCaptor.forClass(String.class);
        
        // 验证方法调用并捕获参数
        verify(emailService, times(1)).sendEmail(
            emailCaptor.capture(),
            subjectCaptor.capture(),
            bodyCaptor.capture()
        );
        
        // 验证捕获的参数
        assertEquals("邮箱应该匹配", "testuser@example.com", emailCaptor.getValue());
        assertEquals("主题应该匹配", "欢迎", subjectCaptor.getValue());
        assertEquals("内容应该匹配", "欢迎加入我们的平台", bodyCaptor.getValue());
    }
}
```

## 最佳实践

### 1. 使用Mock管理器管理模拟对象

**原则**：使用Mock管理器统一管理模拟对象，避免在步骤定义中重复创建和配置模拟对象。

**指导**：
- 创建MockContext类存储模拟对象
- 创建MockManager类管理模拟对象
- 在步骤定义中使用MockManager获取模拟对象

### 2. 使用参数匹配器

**原则**：使用参数匹配器而不是具体值，提高测试的灵活性。

**指导**：
- 使用anyString()、anyInt()等通用匹配器
- 使用eq()匹配具体值
- 使用自定义匹配器处理复杂参数

### 3. 使用ArgumentCaptor验证参数

**原则**：使用ArgumentCaptor捕获方法参数，进行详细验证。

**指导**：
- 创建ArgumentCaptor捕获参数
- 使用verify()方法验证方法调用
- 验证捕获的参数值

### 4. 使用Answer接口处理复杂逻辑

**原则**：使用Answer接口处理复杂的返回逻辑，而不是简单的thenReturn()。

**指导**：
- 实现Answer接口处理动态返回值
- 使用thenAnswer()配置Answer
- 在Answer中访问方法参数

### 5. 重置模拟对象

**原则**：在每个场景后重置模拟对象，避免场景之间的相互影响。

**指导**：
- 在@After钩子中重置模拟对象
- 使用Mockito.reset()重置模拟对象
- 使用MockContext统一管理重置

### 6. 使用Spy部分模拟

**原则**：使用Spy进行部分模拟，保留真实方法的行为。

**指导**：
- 使用@SpyBean创建Spring Bean的Spy
- 使用doNothing()、doReturn()配置Spy
- 验证Spy的方法调用

## 总结

Cucumber与Mockito的集成为BDD测试提供了强大的模拟功能，通过模拟对象、参数匹配器、ArgumentCaptor、Answer接口等技术，我们可以隔离测试依赖，提高测试的速度和可靠性。

在实际项目中，应该根据项目需求选择合适的模拟策略，并遵循最佳实践。通过合理的配置和设计，Cucumber与Mockito的集成可以大大提高测试效率和质量，支持高质量的软件开发。