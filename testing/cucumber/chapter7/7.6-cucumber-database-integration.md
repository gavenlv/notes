# 7.6 Cucumber与数据库集成

## 引言

在现代应用测试中，数据库集成测试是不可或缺的一部分。Cucumber与数据库的集成使我们能够编写端到端的验收测试，验证应用程序与数据库的交互是否正确。本章将深入探讨Cucumber与各种数据库的集成方式、测试数据管理、事务处理和最佳实践，帮助读者构建健壮的数据库集成测试体系。

## 集成基础

### 依赖配置

#### Maven依赖

```xml
<dependencies>
    <!-- Cucumber核心依赖 -->
    <dependency>
        <groupId>io.cucumber</groupId>
        <artifactId>cucumber-java</artifactId>
        <version>7.11.0</version>
        <scope>test</scope>
    </dependency>
    
    <dependency>
        <groupId>io.cucumber</groupId>
        <artifactId>cucumber-junit</artifactId>
        <version>7.11.0</version>
        <scope>test</scope>
    </dependency>
    
    <!-- Spring Boot测试依赖 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <version>3.0.5</version>
        <scope>test</scope>
    </dependency>
    
    <!-- Spring Data JPA依赖 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
        <version>3.0.5</version>
        <scope>test</scope>
    </dependency>
    
    <!-- H2内存数据库 -->
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <version>2.1.214</version>
        <scope>test</scope>
    </dependency>
    
    <!-- Testcontainers（用于集成测试） -->
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>junit-jupiter</artifactId>
        <version>1.17.6</version>
        <scope>test</scope>
    </dependency>
    
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>mysql</artifactId>
        <version>1.17.6</version>
        <scope>test</scope>
    </dependency>
    
    <!-- DBUnit（用于数据库测试） -->
    <dependency>
        <groupId>com.github.springtestdbunit</groupId>
        <artifactId>spring-test-dbunit</artifactId>
        <version>1.3.0</version>
        <scope>test</scope>
    </dependency>
    
    <dependency>
        <groupId>org.dbunit</groupId>
        <artifactId>dbunit</artifactId>
        <version>2.7.3</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

#### Gradle依赖

```groovy
dependencies {
    testImplementation 'io.cucumber:cucumber-java:7.11.0'
    testImplementation 'io.cucumber:cucumber-junit:7.11.0'
    testImplementation 'org.springframework.boot:spring-boot-starter-test:3.0.5'
    testImplementation 'org.springframework.boot:spring-boot-starter-data-jpa:3.0.5'
    testImplementation 'com.h2database:h2:2.1.214'
    testImplementation 'org.testcontainers:junit-jupiter:1.17.6'
    testImplementation 'org.testcontainers:mysql:1.17.6'
    testImplementation 'com.github.springtestdbunit:spring-test-dbunit:1.3.0'
    testImplementation 'org.dbunit:dbunit:2.7.3'
}
```

### 测试配置

#### application-test.properties

```properties
# 测试数据库配置
spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.datasource.initialization-mode=always

# JPA配置
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# 日志配置
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
```

#### application-integration-test.properties

```properties
# 集成测试数据库配置（使用Testcontainers）
spring.datasource.url=jdbc:tc:mysql:8.0.32:///testdb
spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver
spring.datasource.username=root
spring.datasource.password=test

# JPA配置
spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true

# Testcontainers配置
testcontainers.reuse.enable=true
```

## 基本数据库集成

### 使用H2内存数据库

#### 测试运行器

```java
package com.example.gherkin;

import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

@RunWith(Cucumber.class)
@CucumberOptions(
    features = {"src/test/resources/features"},
    glue = {"com.example.gherkin.stepdefinitions"},
    plugin = {
        "pretty",
        "html:target/cucumber-reports",
        "json:target/cucumber-reports/cucumber.json"
    },
    monochrome = true
)
@SpringBootTest
@ActiveProfiles("test")
public class CucumberDatabaseIntegrationTest {
}
```

#### 实体类

```java
package com.example.gherkin.models;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String username;
    
    @Column(nullable = false)
    private String email;
    
    @Column(nullable = false)
    private String password;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // 构造函数
    public User() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    public User(String username, String email, String password) {
        this();
        this.username = username;
        this.email = email;
        this.password = password;
    }
    
    // Getters和Setters
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getUsername() {
        return username;
    }
    
    public void setUsername(String username) {
        this.username = username;
        this.updatedAt = LocalDateTime.now();
    }
    
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
        this.updatedAt = LocalDateTime.now();
    }
    
    public String getPassword() {
        return password;
    }
    
    public void setPassword(String password) {
        this.password = password;
        this.updatedAt = LocalDateTime.now();
    }
    
    public LocalDateTime getCreatedAt() {
        return createdAt;
    }
    
    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }
    
    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }
    
    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }
}
```

#### 仓库接口

```java
package com.example.gherkin.repositories;

import com.example.gherkin.models.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    Optional<User> findByUsername(String username);
    
    Optional<User> findByEmail(String email);
    
    boolean existsByUsername(String username);
    
    boolean existsByEmail(String email);
}
```

#### 服务类

```java
package com.example.gherkin.services;

import com.example.gherkin.models.User;
import com.example.gherkin.repositories.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User save(User user) {
        return userRepository.save(user);
    }
    
    public Optional<User> findById(Long id) {
        return userRepository.findById(id);
    }
    
    public Optional<User> findByUsername(String username) {
        return userRepository.findByUsername(username);
    }
    
    public Optional<User> findByEmail(String email) {
        return userRepository.findByEmail(email);
    }
    
    public List<User> findAll() {
        return userRepository.findAll();
    }
    
    public void deleteById(Long id) {
        userRepository.deleteById(id);
    }
    
    public boolean existsByUsername(String username) {
        return userRepository.existsByUsername(username);
    }
    
    public boolean existsByEmail(String email) {
        return userRepository.existsByEmail(email);
    }
}
```

#### 步骤定义

```java
package com.example.gherkin.stepdefinitions;

import io.cucumber.java.en.*;
import com.example.gherkin.models.User;
import com.example.gherkin.services.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

import java.util.List;
import java.util.Optional;

import static org.junit.Assert.*;

@SpringBootTest
@ActiveProfiles("test")
public class UserDatabaseSteps {
    
    @Autowired
    private UserService userService;
    
    private User savedUser;
    private List<User> userList;
    private Exception exception;
    
    @Given("用户服务已启动")
    public void userServiceIsStarted() {
        assertNotNull("用户服务不应为空", userService);
    }
    
    @Given("创建用户 {string}，邮箱 {string}，密码 {string}")
    public void createUser(String username, String email, String password) {
        User user = new User(username, email, password);
        savedUser = userService.save(user);
        assertNotNull("保存的用户不应为空", savedUser);
        assertNotNull("用户ID不应为空", savedUser.getId());
    }
    
    @When("通过ID查询用户")
    public void findUserById() {
        if (savedUser != null) {
            Optional<User> user = userService.findById(savedUser.getId());
            assertTrue("用户应该存在", user.isPresent());
            savedUser = user.get();
        }
    }
    
    @When("通过用户名 {string} 查询用户")
    public void findUserByUsername(String username) {
        Optional<User> user = userService.findByUsername(username);
        assertTrue("用户应该存在", user.isPresent());
        savedUser = user.get();
    }
    
    @When("查询所有用户")
    public void findAllUsers() {
        userList = userService.findAll();
        assertNotNull("用户列表不应为空", userList);
    }
    
    @When("尝试创建已存在的用户 {string}")
    public void tryToCreateExistingUser(String username) {
        try {
            User user = new User(username, username + "@example.com", "password");
            userService.save(user);
        } catch (Exception e) {
            exception = e;
        }
    }
    
    @Then("用户名应该是 {string}")
    public void usernameShouldBe(String username) {
        assertEquals("用户名应该匹配", username, savedUser.getUsername());
    }
    
    @Then("邮箱应该是 {string}")
    public void emailShouldBe(String email) {
        assertEquals("邮箱应该匹配", email, savedUser.getEmail());
    }
    
    @Then("用户列表应该包含 {int} 个用户")
    public void userListShouldContainUsers(int count) {
        assertEquals("用户数量应该匹配", count, userList.size());
    }
    
    @Then("应该抛出异常")
    public void shouldThrowException() {
        assertNotNull("应该抛出异常", exception);
    }
}
```

### 特性文件示例

#### user_database.feature

```gherkin
Feature: 用户数据库操作
  作为系统管理员
  我希望能够管理用户数据
  以便能够进行用户相关的业务操作

  Background:
    Given 用户服务已启动

  Scenario: 创建并查询用户
    Given 创建用户 "testuser"，邮箱 "testuser@example.com"，密码 "password"
    When 通过ID查询用户
    Then 用户名应该是 "testuser"
    And 邮箱应该是 "testuser@example.com"

  Scenario: 通过用户名查询用户
    Given 创建用户 "john"，邮箱 "john@example.com"，密码 "password"
    When 通过用户名 "john" 查询用户
    Then 用户名应该是 "john"
    And 邮箱应该是 "john@example.com"

  Scenario: 查询所有用户
    Given 创建用户 "user1"，邮箱 "user1@example.com"，密码 "password"
    And 创建用户 "user2"，邮箱 "user2@example.com"，密码 "password"
    When 查询所有用户
    Then 用户列表应该包含 2 个用户

  Scenario: 创建重复用户
    Given 创建用户 "duplicate"，邮箱 "duplicate@example.com"，密码 "password"
    When 尝试创建已存在的用户 "duplicate"
    Then 应该抛出异常
```

## 使用Testcontainers进行集成测试

### Testcontainers配置

#### 测试基类

```java
package com.example.gherkin.config;

import org.junit.jupiter.api.BeforeAll;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.testcontainers.containers.MySQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

@SpringBootTest
@ActiveProfiles("integration-test")
@Testcontainers
public abstract class BaseIntegrationTest {
    
    @Container
    static MySQLContainer<?> mysql = new MySQLContainer<>("mysql:8.0.32")
            .withDatabaseName("testdb")
            .withUsername("root")
            .withPassword("test")
            .withReuse(true);
    
    @BeforeAll
    static void setUp() {
        System.setProperty("spring.datasource.url", mysql.getJdbcUrl());
        System.setProperty("spring.datasource.username", mysql.getUsername());
        System.setProperty("spring.datasource.password", mysql.getPassword());
        System.setProperty("spring.datasource.driver-class-name", mysql.getDriverClassName());
    }
}
```

#### 测试运行器

```java
package com.example.gherkin;

import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import com.example.gherkin.config.BaseIntegrationTest;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(
    features = {"src/test/resources/features/integration"},
    glue = {"com.example.gherkin.stepdefinitions.integration"},
    plugin = {
        "pretty",
        "html:target/cucumber-reports",
        "json:target/cucumber-reports/cucumber.json"
    },
    monochrome = true,
    tags = "@integration"
)
public class CucumberIntegrationTest extends BaseIntegrationTest {
}
```

#### 集成测试步骤定义

```java
package com.example.gherkin.stepdefinitions.integration;

import io.cucumber.java.en.*;
import com.example.gherkin.config.BaseIntegrationTest;
import com.example.gherkin.models.User;
import com.example.gherkin.services.UserService;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.List;
import java.util.Optional;

import static org.junit.Assert.*;

public class UserIntegrationSteps extends BaseIntegrationTest {
    
    @Autowired
    private UserService userService;
    
    private User savedUser;
    private List<User> userList;
    
    @Given("集成测试环境已准备就绪")
    public void integrationTestEnvironmentIsReady() {
        assertNotNull("用户服务不应为空", userService);
    }
    
    @Given("在集成测试环境中创建用户 {string}，邮箱 {string}，密码 {string}")
    public void createUserInIntegrationTest(String username, String email, String password) {
        User user = new User(username, email, password);
        savedUser = userService.save(user);
        assertNotNull("保存的用户不应为空", savedUser);
        assertNotNull("用户ID不应为空", savedUser.getId());
    }
    
    @When("在集成测试环境中通过ID查询用户")
    public void findUserByIdInIntegrationTest() {
        if (savedUser != null) {
            Optional<User> user = userService.findById(savedUser.getId());
            assertTrue("用户应该存在", user.isPresent());
            savedUser = user.get();
        }
    }
    
    @When("在集成测试环境中查询所有用户")
    public void findAllUsersInIntegrationTest() {
        userList = userService.findAll();
        assertNotNull("用户列表不应为空", userList);
    }
    
    @Then("集成测试环境中用户名应该是 {string}")
    public void usernameInIntegrationTestShouldBe(String username) {
        assertEquals("用户名应该匹配", username, savedUser.getUsername());
    }
    
    @Then("集成测试环境中用户列表应该包含 {int} 个用户")
    public void userListInIntegrationTestShouldContainUsers(int count) {
        assertEquals("用户数量应该匹配", count, userList.size());
    }
}
```

#### 集成测试特性文件

#### user_integration.feature

```gherkin
@integration
Feature: 用户数据库集成测试
  作为系统管理员
  我希望能够在真实数据库环境中测试用户操作
  以便确保应用程序与数据库的集成正常工作

  Background:
    Given 集成测试环境已准备就绪

  Scenario: 在真实数据库中创建并查询用户
    Given 在集成测试环境中创建用户 "realuser"，邮箱 "realuser@example.com"，密码 "password"
    When 在集成测试环境中通过ID查询用户
    Then 集成测试环境中用户名应该是 "realuser"

  Scenario: 在真实数据库中查询所有用户
    Given 在集成测试环境中创建用户 "realuser1"，邮箱 "realuser1@example.com"，密码 "password"
    And 在集成测试环境中创建用户 "realuser2"，邮箱 "realuser2@example.com"，密码 "password"
    When 在集成测试环境中查询所有用户
    Then 集成测试环境中用户列表应该包含 2 个用户
```

## 使用DBUnit进行数据管理

### DBUnit配置

#### DBUnit配置类

```java
package com.example.gherkin.config;

import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.DatabaseTearDown;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;

@TestExecutionListeners({
    DependencyInjectionTestExecutionListener.class,
    DirtiesContextTestExecutionListener.class,
    TransactionalTestExecutionListener.class,
    DbUnitTestExecutionListener.class
})
public abstract class BaseDbUnitTest {
}
```

#### 测试运行器

```java
package com.example.gherkin;

import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import com.example.gherkin.config.BaseDbUnitTest;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(
    features = {"src/test/resources/features/dbunit"},
    glue = {"com.example.gherkin.stepdefinitions.dbunit"},
    plugin = {
        "pretty",
        "html:target/cucumber-reports",
        "json:target/cucumber-reports/cucumber.json"
    },
    monochrome = true,
    tags = "@dbunit"
)
public class CucumberDbUnitTest extends BaseDbUnitTest {
}
```

#### 数据集文件

#### src/test/resources/datasets/user-data.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<dataset>
    <users id="1" username="user1" email="user1@example.com" password="password1" />
    <users id="2" username="user2" email="user2@example.com" password="password2" />
    <users id="3" username="user3" email="user3@example.com" password="password3" />
</dataset>
```

#### src/test/resources/datasets/empty-dataset.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<dataset>
    <!-- 空数据集，用于清理数据 -->
</dataset>
```

#### DBUnit步骤定义

```java
package com.example.gherkin.stepdefinitions.dbunit;

import io.cucumber.java.en.*;
import com.example.gherkin.config.BaseDbUnitTest;
import com.example.gherkin.models.User;
import com.example.gherkin.services.UserService;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.DatabaseTearDown;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.List;
import java.util.Optional;

import static org.junit.Assert.*;

public class UserDbUnitSteps extends BaseDbUnitTest {
    
    @Autowired
    private UserService userService;
    
    private User savedUser;
    private List<User> userList;
    
    @Given("数据库已加载用户测试数据")
    @DatabaseSetup("/datasets/user-data.xml")
    public void databaseLoadedWithUserData() {
        // 数据已加载
    }
    
    @Given("数据库已清空")
    @DatabaseSetup("/datasets/empty-dataset.xml")
    public void databaseIsEmpty() {
        // 数据库已清空
    }
    
    @When("查询所有用户")
    public void findAllUsers() {
        userList = userService.findAll();
        assertNotNull("用户列表不应为空", userList);
    }
    
    @When("通过用户名 {string} 查询用户")
    public void findUserByUsername(String username) {
        Optional<User> user = userService.findByUsername(username);
        assertTrue("用户应该存在", user.isPresent());
        savedUser = user.get();
    }
    
    @When("创建新用户 {string}，邮箱 {string}，密码 {string}")
    public void createNewUser(String username, String email, String password) {
        User user = new User(username, email, password);
        savedUser = userService.save(user);
        assertNotNull("保存的用户不应为空", savedUser);
        assertNotNull("用户ID不应为空", savedUser.getId());
    }
    
    @Then("用户列表应该包含 {int} 个用户")
    public void userListShouldContainUsers(int count) {
        assertEquals("用户数量应该匹配", count, userList.size());
    }
    
    @Then("用户名应该是 {string}")
    public void usernameShouldBe(String username) {
        assertEquals("用户名应该匹配", username, savedUser.getUsername());
    }
    
    @Then("邮箱应该是 {string}")
    public void emailShouldBe(String email) {
        assertEquals("邮箱应该匹配", email, savedUser.getEmail());
    }
    
    @After
    @DatabaseTearDown("/datasets/empty-dataset.xml")
    public void tearDown() {
        // 清理数据
    }
}
```

#### DBUnit特性文件

#### user_dbunit.feature

```gherkin
@dbunit
Feature: 用户数据库DBUnit测试
  作为系统管理员
  我希望使用DBUnit管理测试数据
  以便能够进行一致的数据测试

  Scenario: 使用预加载数据查询用户
    Given 数据库已加载用户测试数据
    When 查询所有用户
    Then 用户列表应该包含 3 个用户

  Scenario: 使用预加载数据通过用户名查询
    Given 数据库已加载用户测试数据
    When 通过用户名 "user1" 查询用户
    Then 用户名应该是 "user1"
    And 邮箱应该是 "user1@example.com"

  Scenario: 在清空数据库中创建用户
    Given 数据库已清空
    When 创建新用户 "newuser"，邮箱 "newuser@example.com"，密码 "password"
    Then 用户名应该是 "newuser"
    And 邮箱应该是 "newuser@example.com"
```

## 事务管理

### 事务配置

#### 事务测试基类

```java
package com.example.gherkin.config;

import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.transaction.TestTransaction;
import org.springframework.transaction.annotation.Transactional;

@SpringBootTest
@ActiveProfiles("test")
@Transactional
public abstract class BaseTransactionalTest {
    
    protected void startNewTransaction() {
        TestTransaction.end();
        TestTransaction.start();
    }
    
    protected void endTransaction() {
        TestTransaction.end();
    }
    
    protected void flagForRollback() {
        TestTransaction.flagForRollback();
    }
    
    protected boolean isTransactionActive() {
        return TestTransaction.isActive();
    }
}
```

#### 事务步骤定义

```java
package com.example.gherkin.stepdefinitions.transaction;

import io.cucumber.java.en.*;
import com.example.gherkin.config.BaseTransactionalTest;
import com.example.gherkin.models.User;
import com.example.gherkin.services.UserService;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.List;
import java.util.Optional;

import static org.junit.Assert.*;

public class UserTransactionSteps extends BaseTransactionalTest {
    
    @Autowired
    private UserService userService;
    
    private User savedUser;
    private List<User> userList;
    
    @Given("事务测试环境已准备就绪")
    public void transactionTestEnvironmentIsReady() {
        assertTrue("事务应该是活跃的", isTransactionActive());
    }
    
    @Given("在事务中创建用户 {string}，邮箱 {string}，密码 {string}")
    public void createUserInTransaction(String username, String email, String password) {
        User user = new User(username, email, password);
        savedUser = userService.save(user);
        assertNotNull("保存的用户不应为空", savedUser);
        assertNotNull("用户ID不应为空", savedUser.getId());
    }
    
    @When("在事务中查询所有用户")
    public void findAllUsersInTransaction() {
        userList = userService.findAll();
        assertNotNull("用户列表不应为空", userList);
    }
    
    @When("回滚当前事务")
    public void rollbackCurrentTransaction() {
        flagForRollback();
        endTransaction();
        startNewTransaction();
    }
    
    @When("提交当前事务")
    public void commitCurrentTransaction() {
        endTransaction();
        startNewTransaction();
    }
    
    @Then("事务中用户列表应该包含 {int} 个用户")
    public void userListInTransactionShouldContainUsers(int count) {
        assertEquals("用户数量应该匹配", count, userList.size());
    }
    
    @Then("回滚后查询用户 {string} 应该不存在")
    public void afterRollbackUserShouldNotExist(String username) {
        Optional<User> user = userService.findByUsername(username);
        assertFalse("用户不应该存在", user.isPresent());
    }
    
    @Then("提交后查询用户 {string} 应该存在")
    public void afterCommitUserShouldExist(String username) {
        Optional<User> user = userService.findByUsername(username);
        assertTrue("用户应该存在", user.isPresent());
    }
}
```

#### 事务特性文件

#### user_transaction.feature

```gherkin
Feature: 用户数据库事务测试
  作为系统管理员
  我希望能够在事务中管理用户数据
  以便确保数据的一致性和完整性

  Background:
    Given 事务测试环境已准备就绪

  Scenario: 在事务中创建和查询用户
    Given 在事务中创建用户 "txuser"，邮箱 "txuser@example.com"，密码 "password"
    When 在事务中查询所有用户
    Then 事务中用户列表应该包含 1 个用户

  Scenario: 事务回滚测试
    Given 在事务中创建用户 "rollbackuser"，邮箱 "rollbackuser@example.com"，密码 "password"
    When 回滚当前事务
    Then 回滚后查询用户 "rollbackuser" 应该不存在

  Scenario: 事务提交测试
    Given 在事务中创建用户 "commituser"，邮箱 "commituser@example.com"，密码 "password"
    When 提交当前事务
    Then 提交后查询用户 "commituser" 应该存在
```

## 最佳实践

### 1. 使用适当的数据库类型

**原则**：根据测试需求选择合适的数据库类型，平衡测试速度和真实性。

**指导**：
- 使用H2内存数据库进行快速单元测试
- 使用Testcontainers进行集成测试
- 使用真实数据库进行端到端测试

### 2. 使用事务管理测试数据

**原则**：使用事务管理测试数据，确保测试之间的隔离性。

**指导**：
- 使用@Transactional注解管理事务
- 在测试后回滚事务
- 使用TestTransaction控制事务边界

### 3. 使用DBUnit管理测试数据

**原则**：使用DBUnit管理测试数据，确保测试数据的一致性。

**指导**：
- 使用XML文件定义测试数据
- 使用@DatabaseSetup加载数据
- 使用@DatabaseTearDown清理数据

### 4. 使用Testcontainers进行集成测试

**原则**：使用Testcontainers进行集成测试，模拟真实环境。

**指导**：
- 配置Testcontainers容器
- 使用@Container注解管理容器生命周期
- 配置容器重用以提高测试速度

### 5. 分离测试配置

**原则**：分离测试配置，避免测试影响生产环境。

**指导**：
- 使用application-test.properties配置测试环境
- 使用@ActiveProfiles激活测试配置
- 使用不同的数据库配置

### 6. 使用数据工厂创建测试数据

**原则**：使用数据工厂创建测试数据，提高测试数据的可维护性。

**指导**：
- 创建数据工厂类
- 使用Builder模式构建测试数据
- 提供默认值和自定义选项

## 总结

Cucumber与数据库的集成为BDD测试提供了强大的数据管理能力，通过H2内存数据库、Testcontainers、DBUnit和事务管理，我们可以构建全面、可靠的数据库集成测试体系。

在实际项目中，应该根据项目需求选择合适的数据库集成策略，并遵循最佳实践。通过合理的配置和设计，Cucumber与数据库的集成可以大大提高测试覆盖率，确保应用程序与数据库的交互正确无误。