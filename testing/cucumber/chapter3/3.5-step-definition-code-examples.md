# 3.5 Step Definition代码示例

## 基础步骤定义示例

### 简单步骤定义

```java
package com.example.stepdefinitions;

import io.cucumber.java.en.Given;
import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import static org.junit.Assert.*;

public class SimpleStepDefinitions {
    
    @Given("用户在登录页面")
    public void userIsOnLoginPage() {
        // 导航到登录页面的代码
        System.out.println("导航到登录页面");
    }
    
    @When("用户输入用户名 {string} 和密码 {string}")
    public void userEntersCredentials(String username, String password) {
        // 输入用户名和密码的代码
        System.out.println("输入用户名: " + username + ", 密码: " + password);
    }
    
    @When("用户点击登录按钮")
    public void userClicksLoginButton() {
        // 点击登录按钮的代码
        System.out.println("点击登录按钮");
    }
    
    @Then("用户应该成功登录")
    public void userShouldBeLoggedIn() {
        // 验证用户已登录的代码
        System.out.println("验证用户已登录");
        assertTrue("用户应该已登录", true);
    }
}
```

### 使用正则表达式的步骤定义

```java
package com.example.stepdefinitions;

import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import static org.junit.Assert.*;

public class RegexStepDefinitions {
    
    @When("^用户搜索 (.+) 产品$")
    public void userSearchesForProduct(String productName) {
        // 搜索产品的代码
        System.out.println("搜索产品: " + productName);
    }
    
    @When("^用户添加 (\\d+) 个 (.+) 到购物车$")
    public void userAddsItemsToCart(int quantity, String productName) {
        // 添加产品到购物车的代码
        System.out.println("添加 " + quantity + " 个 " + productName + " 到购物车");
    }
    
    @Then("^购物车总价应该是 (\\d+\\.\\d+) 元$")
    public void cartTotalShouldBe(double expectedTotal) {
        // 验证购物车总价的代码
        System.out.println("验证购物车总价: " + expectedTotal);
        assertTrue("购物车总价应该正确", true);
    }
}
```

## 数据表处理示例

### 简单数据表处理

```java
package com.example.stepdefinitions;

import io.cucumber.java.en.Given;
import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import io.cucumber.datatable.DataTable;
import java.util.List;
import java.util.Map;
import static org.junit.Assert.*;

public class DataTableStepDefinitions {
    
    @Given("以下产品已存在:")
    public void productsExist(DataTable dataTable) {
        List<Map<String, String>> products = dataTable.asMaps(String.class, String.class);
        
        for (Map<String, String> product : products) {
            String name = product.get("名称");
            String price = product.get("价格");
            String category = product.get("类别");
            
            // 创建产品的代码
            System.out.println("创建产品: " + name + ", 价格: " + price + ", 类别: " + category);
        }
    }
    
    @When("用户批量购买以下产品:")
    public void userBatchPurchasesProducts(DataTable dataTable) {
        List<Map<String, String>> purchases = dataTable.asMaps(String.class, String.class);
        
        for (Map<String, String> purchase : purchases) {
            String productName = purchase.get("产品");
            int quantity = Integer.parseInt(purchase.get("数量"));
            
            // 购买产品的代码
            System.out.println("购买产品: " + productName + ", 数量: " + quantity);
        }
    }
    
    @Then("订单应该包含以下产品:")
    public void orderShouldContainProducts(DataTable expectedProducts) {
        List<Map<String, String>> expected = expectedProducts.asMaps(String.class, String.class);
        
        // 验证订单中产品的代码
        for (Map<String, String> product : expected) {
            String name = product.get("名称");
            int quantity = Integer.parseInt(product.get("数量"));
            
            System.out.println("验证订单包含产品: " + name + ", 数量: " + quantity);
        }
        
        assertTrue("订单应该包含所有预期产品", true);
    }
}
```

### 对象转换数据表

```java
package com.example.stepdefinitions;

import io.cucumber.java.en.Given;
import io.cucumber.java.en.When;
import java.util.List;

public class ObjectDataTableStepDefinitions {
    
    // 假设有一个Product类
    public static class Product {
        private String name;
        private double price;
        private String category;
        
        // 构造函数、getter和setter方法
        public Product(String name, double price, String category) {
            this.name = name;
            this.price = price;
            this.category = category;
        }
        
        // getters
        public String getName() { return name; }
        public double getPrice() { return price; }
        public String getCategory() { return category; }
    }
    
    @Given("以下产品已加载:")
    public void productsAreLoaded(List<Product> products) {
        // Cucumber会自动将数据表转换为Product对象列表
        for (Product product : products) {
            System.out.println("加载产品: " + product.getName() + 
                             ", 价格: " + product.getPrice() + 
                             ", 类别: " + product.getCategory());
        }
    }
    
    @When("用户购买以下产品:")
    public void userPurchasesProducts(List<Product> products) {
        for (Product product : products) {
            System.out.println("购买产品: " + product.getName());
        }
    }
}
```

## 参数转换器示例

### 自定义参数转换器

```java
package com.example.transformers;

import io.cucumber.java.ParameterType;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

public class DateTransformer {
    
    @ParameterType("([0-9]{4})-([0-9]{2})-([0-9]{2})")
    public LocalDate date(String year, String month, String day) {
        return LocalDate.of(
            Integer.parseInt(year),
            Integer.parseInt(month),
            Integer.parseInt(day)
        );
    }
    
    @ParameterType("([0-9]{2})/([0-9]{2})/([0-9]{4})")
    public LocalDate americanDate(String month, String day, String year) {
        return LocalDate.of(
            Integer.parseInt(year),
            Integer.parseInt(month),
            Integer.parseInt(day)
        );
    }
}
```

### 使用自定义参数转换器

```java
package com.example.stepdefinitions;

import io.cucumber.java.en.Given;
import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import java.time.LocalDate;
import static org.junit.Assert.*;

public class ParameterTypeStepDefinitions {
    
    @Given("今天是 {date}")
    public void todayIs(LocalDate date) {
        System.out.println("设置当前日期为: " + date);
        // 设置当前日期的代码
    }
    
    @When("用户在 {date} 创建订单")
    public void userCreatesOrderOn(LocalDate orderDate) {
        System.out.println("在 " + orderDate + " 创建订单");
        // 创建订单的代码
    }
    
    @When("用户在 {americanDate} 支付账单")
    public void userPaysBillOn(LocalDate paymentDate) {
        System.out.println("在 " + paymentDate + " 支付账单");
        // 支付账单的代码
    }
    
    @Then("订单应该在 {date} 之前创建")
    public void orderShouldBeCreatedBefore(LocalDate expectedDate) {
        System.out.println("验证订单创建日期早于: " + expectedDate);
        // 验证订单创建日期的代码
        assertTrue("订单创建日期应该正确", true);
    }
}
```

## 依赖注入示例

### Spring依赖注入

```java
package com.example.stepdefinitions;

import io.cucumber.java.en.Given;
import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import static org.junit.Assert.*;

@SpringBootTest
public class SpringStepDefinitions {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private OrderService orderService;
    
    @Given("用户 {string} 已存在")
    public void userExists(String username) {
        if (!userService.existsByUsername(username)) {
            User user = new User(username, username + "@example.com", "password");
            userService.create(user);
        }
    }
    
    @When("用户 {string} 创建订单")
    public void userCreatesOrder(String username) {
        User user = userService.findByUsername(username);
        Order order = orderService.createForUser(user);
        // 存储订单以供后续验证
        // ...
    }
    
    @Then("订单应该成功创建")
    public void orderShouldBeCreated() {
        // 验证订单创建的代码
        assertTrue("订单应该已创建", true);
    }
}
```

### PicoContainer依赖注入

```java
package com.example.stepdefinitions;

import io.cucumber.java.en.Given;
import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import static org.junit.Assert.*;

public class PicoContainerStepDefinitions {
    
    private final UserService userService;
    private final OrderService orderService;
    private final TestContext context;
    
    // 通过构造函数注入依赖
    public PicoContainerStepDefinitions(UserService userService, 
                                       OrderService orderService, 
                                       TestContext context) {
        this.userService = userService;
        this.orderService = orderService;
        this.context = context;
    }
    
    @Given("用户 {string} 已存在")
    public void userExists(String username) {
        if (!userService.existsByUsername(username)) {
            User user = new User(username, username + "@example.com", "password");
            userService.create(user);
        }
        context.setCurrentUsername(username);
    }
    
    @When("用户创建订单")
    public void userCreatesOrder() {
        String username = context.getCurrentUsername();
        User user = userService.findByUsername(username);
        Order order = orderService.createForUser(user);
        context.setCurrentOrder(order);
    }
    
    @Then("订单应该成功创建")
    public void orderShouldBeCreated() {
        Order order = context.getCurrentOrder();
        assertNotNull("订单应该存在", order);
        assertTrue("订单应该有效", order.isValid());
    }
}
```

## 状态管理示例

### 共享测试上下文

```java
package com.example.context;

import org.springframework.stereotype.Component;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.annotation.Scope;
import java.util.HashMap;
import java.util.Map;

@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) // 每个场景一个实例
public class TestContext {
    private Map<String, Object> data = new HashMap<>();
    
    public <T> T get(String key, Class<T> type) {
        return type.cast(data.get(key));
    }
    
    public void set(String key, Object value) {
        data.put(key, value);
    }
    
    public User getCurrentUser() {
        return get("currentUser", User.class);
    }
    
    public void setCurrentUser(User user) {
        set("currentUser", user);
    }
    
    public Order getCurrentOrder() {
        return get("currentOrder", Order.class);
    }
    
    public void setCurrentOrder(Order order) {
        set("currentOrder", order);
    }
}
```

### 使用共享上下文

```java
package com.example.stepdefinitions;

import io.cucumber.java.en.Given;
import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import org.springframework.beans.factory.annotation.Autowired;
import static org.junit.Assert.*;

public class ContextStepDefinitions {
    
    @Autowired
    private TestContext context;
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private OrderService orderService;
    
    @Given("用户 {string} 已存在")
    public void userExists(String username) {
        User user = userService.findByUsername(username);
        context.setCurrentUser(user);
    }
    
    @When("用户创建订单")
    public void userCreatesOrder() {
        User currentUser = context.getCurrentUser();
        Order order = orderService.createForUser(currentUser);
        context.setCurrentOrder(order);
    }
    
    @When("用户添加产品 {string} 到订单")
    public void userAddsProductToOrder(String productName) {
        Order currentOrder = context.getCurrentOrder();
        Product product = productService.findByName(productName);
        orderService.addProductToOrder(currentOrder, product);
    }
    
    @Then("订单应该包含 {int} 个产品")
    public void orderShouldContainProducts(int expectedCount) {
        Order currentOrder = context.getCurrentOrder();
        assertEquals("订单产品数量应该正确", expectedCount, currentOrder.getProductCount());
    }
}
```

## 异步操作示例

### 处理异步操作

```java
package com.example.stepdefinitions;

import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.concurrent.CompletableFuture;
import static org.junit.Assert.*;
import static java.util.concurrent.TimeUnit.SECONDS;

public class AsyncStepDefinitions {
    
    @Autowired
    private AsyncService asyncService;
    
    @Autowired
    private TestContext context;
    
    @When("用户发起异步请求")
    public void userInitiatesAsyncRequest() {
        CompletableFuture<String> future = asyncService.processRequest();
        context.set("requestFuture", future);
    }
    
    @Then("异步请求应该在 {int} 秒内完成")
    public void asyncRequestShouldCompleteWithinSeconds(int timeoutSeconds) throws Exception {
        CompletableFuture<String> future = context.get("requestFuture", CompletableFuture.class);
        
        try {
            String result = future.get(timeoutSeconds, SECONDS);
            context.set("requestResult", result);
        } catch (Exception e) {
            fail("异步请求未在 " + timeoutSeconds + " 秒内完成: " + e.getMessage());
        }
    }
    
    @Then("异步请求应该返回 {string}")
    public void asyncRequestShouldReturn(String expectedResult) {
        String actualResult = context.get("requestResult", String.class);
        assertEquals("异步请求结果应该正确", expectedResult, actualResult);
    }
}
```

### 使用等待机制

```java
package com.example.stepdefinitions;

import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import org.springframework.beans.factory.annotation.Autowired;
import static org.junit.Assert.*;
import static org.awaitility.Awaitility.await;
import static java.util.concurrent.TimeUnit.SECONDS;

public class AwaitilityStepDefinitions {
    
    @Autowired
    private FileUploadService fileUploadService;
    
    @When("用户上传文件 {string}")
    public void userUploadsFile(String fileName) {
        fileUploadService.uploadAsync(fileName);
        
        // 使用Awaitility等待上传完成
        await().atMost(10, SECONDS).until(() -> 
            fileUploadService.getStatus(fileName) == UploadStatus.COMPLETED
        );
    }
    
    @Then("文件 {string} 应该上传成功")
    public void fileShouldBeUploadedSuccessfully(String fileName) {
        assertEquals("文件应该上传成功", 
                    UploadStatus.COMPLETED, 
                    fileUploadService.getStatus(fileName));
    }
}
```

## 错误处理示例

### 自定义异常处理

```java
package com.example.stepdefinitions;

import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.And;
import org.springframework.beans.factory.annotation.Autowired;
import static org.junit.Assert.*;

public class ErrorHandlingStepDefinitions {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private TestContext context;
    
    @When("用户尝试使用无效凭证登录")
    public void userTriesToLoginWithInvalidCredentials() {
        try {
            userService.login("invaliduser", "invalidpassword");
            context.set("loginException", null);
        } catch (AuthenticationException e) {
            context.set("loginException", e);
        }
    }
    
    @Then("登录应该失败")
    public void loginShouldFail() {
        AuthenticationException exception = context.get("loginException", AuthenticationException.class);
        assertNotNull("应该抛出认证异常", exception);
    }
    
    @And("错误消息应该是 {string}")
    public void errorMessageShouldBe(String expectedMessage) {
        AuthenticationException exception = context.get("loginException", AuthenticationException.class);
        assertEquals("错误消息应该正确", expectedMessage, exception.getMessage());
    }
}
```

### 软断言

```java
package com.example.stepdefinitions;

import io.cucumber.java.en.Then;
import org.springframework.beans.factory.annotation.Autowired;
import org.assertj.core.api.SoftAssertions;
import static org.junit.Assert.*;

public class SoftAssertionStepDefinitions {
    
    @Autowired
    private TestContext context;
    
    @Autowired
    private OrderService orderService;
    
    @Then("订单详情应该正确")
    public void orderDetailsShouldBeCorrect() {
        Order expectedOrder = context.get("expectedOrder", Order.class);
        Order actualOrder = orderService.findById(expectedOrder.getId());
        
        SoftAssertions softly = new SoftAssertions();
        
        softly.assertThat(actualOrder.getId()).isEqualTo(expectedOrder.getId());
        softly.assertThat(actualOrder.getUserId()).isEqualTo(expectedOrder.getUserId());
        softly.assertThat(actualOrder.getStatus()).isEqualTo(expectedOrder.getStatus());
        softly.assertThat(actualOrder.getTotalAmount()).isEqualByComparingTo(expectedOrder.getTotalAmount());
        softly.assertThat(actualOrder.getItems()).hasSize(expectedOrder.getItems().size());
        
        // 一次性验证所有断言
        softly.assertAll();
    }
}
```

## 总结

这些代码示例展示了Step Definition的各种实现方式，从基础步骤定义到高级技术，如参数转换、依赖注入、状态管理、异步操作和错误处理。

通过参考这些示例，您可以更好地理解如何编写清晰、可维护的步骤定义，并根据您的具体需求选择合适的实现方式。记住，好的步骤定义应该易于理解、表达业务意图，并且易于维护。