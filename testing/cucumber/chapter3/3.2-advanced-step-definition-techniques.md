# 3.2 高级Step Definition技术

## 参数转换器 (Parameter Types)

Cucumber允许自定义参数转换器，用于将Gherkin中的字符串转换为Java对象。这使得步骤定义更加类型安全和可读。

### 内置参数转换器

Cucumber提供了一些内置的参数转换器：

```java
@When("用户在 {int} 年 {int} 月 {int} 日创建订单")
public void userCreatesOrderOnDate(int year, int month, int day) {
    LocalDate orderDate = LocalDate.of(year, month, day);
    orderService.createOrder(orderDate);
}

@When("用户支付金额为 {double}")
public void userPaysAmount(double amount) {
    paymentService.process(amount);
}

@When("用户选择 {bigdecimal} 折扣")
public void userSelectsDiscount(BigDecimal discount) {
    discountService.apply(discount);
}
```

### 自定义参数转换器

可以创建自定义参数转换器来处理复杂的类型转换：

```java
public class ProductTypeConverter implements TypeRegistryConfigurer {
    @Override
    public void configure(TypeRegistry typeRegistry) {
        typeRegistry.defineParameterType(new ParameterType<>(
            "product",  // 名称
            "([^\\s]+)", // 正则表达式
            Product.class, // 目标类型
            new Transformer<Product>() {
                @Override
                public Product transform(String productName) throws Throwable {
                    return productService.findByName(productName);
                }
            }
        ));
    }
}
```

然后在步骤定义中使用自定义参数类型：

```java
@When("用户添加 {product} 到购物车")
public void userAddsProductToCart(Product product) {
    cartService.add(product);
}
```

### 复杂对象转换

对于复杂对象，可以使用更高级的转换技术：

```java
public class AddressConverter implements TypeRegistryConfigurer {
    @Override
    public void configure(TypeRegistry typeRegistry) {
        typeRegistry.defineParameterType(new ParameterType<>(
            "address",
            "(.+),\\s*(.+),\\s*(\\d+)", // 格式: "街道, 城市, 邮编"
            Address.class,
            (String[] args) -> new Address(args[0], args[1], args[2])
        ));
    }
}

// 使用示例
@When("用户配送地址为 {address}")
public void userSetsDeliveryAddress(Address address) {
    orderService.setDeliveryAddress(address);
}
```

## 数据表转换器 (Data Table Transformers)

Cucumber提供了强大的数据表转换功能，可以将Gherkin中的数据表直接转换为Java对象。

### 基本数据表转换

```java
@When("用户创建以下产品:")
public void userCreatesProducts(List<Product> products) {
    // Cucumber会自动将数据表转换为Product对象列表
    for (Product product : products) {
        productService.create(product);
    }
}
```

对应的Gherkin数据表：

```gherkin
When 用户创建以下产品:
  | name    | price | category |
  | 苹果    | 5.99  | 水果     |
  | 香蕉    | 3.99  | 水果     |
  | 牛奶    | 12.99 | 乳制品   |
```

### 自定义数据表转换器

可以创建自定义的数据表转换器来处理更复杂的转换逻辑：

```java
public class ProductDataTableTransformer implements DataTableTypeRegistryConfigurer {
    @Override
    public void configure(DataTableTypeRegistry dataTableTypeRegistry) {
        dataTableTypeRegistry.defineDataTableType(new DataTableType(
            Product.class,
            (Map<String, String> row) -> {
                Product product = new Product();
                product.setName(row.get("name"));
                product.setPrice(new BigDecimal(row.get("price")));
                product.setCategory(row.get("category"));
                
                // 自定义处理逻辑
                if (row.containsKey("discount")) {
                    product.setDiscount(new BigDecimal(row.get("discount")));
                }
                
                return product;
            }
        ));
    }
}
```

### 嵌套对象转换

对于嵌套对象，可以使用更复杂的数据表转换：

```java
@When("用户创建以下订单:")
public void userCreatesOrders(List<Order> orders) {
    // 自动转换包含嵌套对象的订单列表
    orderService.createAll(orders);
}
```

对应的Gherkin数据表：

```gherkin
When 用户创建以下订单:
  | id  | customerName | deliveryAddress        | items                          |
  | 101 | 张三         | 北京市朝阳区xxx路100号 | 苹果:2,香蕉:3                  |
  | 102 | 李四         | 上海市浦东新区yyy路200号 | 牛奶:1,面包:2,鸡蛋:5           |
```

## 步骤定义中的依赖注入

### 使用Cucumber的依赖注入

Cucumber支持多种依赖注入框架，如Spring、PicoContainer等。

#### Spring依赖注入

```java
@SpringBootTest
@CucumberContextConfiguration
public class SpringStepDefinitions {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private OrderService orderService;
    
    @Given("用户 {string} 已存在")
    public void userExists(String username) {
        User user = new User(username, username + "@example.com", "password");
        userService.create(user);
    }
}
```

#### PicoContainer依赖注入

```java
public class UserServiceSteps {
    private final UserService userService;
    private final TestContext context;
    
    // 通过构造函数注入依赖
    public UserServiceSteps(UserService userService, TestContext context) {
        this.userService = userService;
        this.context = context;
    }
    
    @When("用户登录")
    public void userLogsIn() {
        User user = userService.login(context.getUsername(), context.getPassword());
        context.setCurrentUser(user);
    }
}
```

### 共享测试上下文

创建共享的测试上下文类来在不同步骤定义之间共享状态：

```java
@Component
@Scope(CucumberTestExecutionListener.CUCUMBER_GLUE_SCOPE)
public class TestContext {
    private User currentUser;
    private List<Product> products;
    private Order currentOrder;
    private Map<String, Object> data = new HashMap<>();
    
    // getters and setters
    public <T> T get(String key, Class<T> type) {
        return type.cast(data.get(key));
    }
    
    public void set(String key, Object value) {
        data.put(key, value);
    }
}
```

然后在步骤定义中使用共享上下文：

```java
public class UserSteps {
    @Autowired
    private TestContext context;
    
    @Autowired
    private UserService userService;
    
    @When("用户 {string} 登录")
    public void userLogsIn(String username) {
        User user = userService.findByUsername(username);
        context.setCurrentUser(user);
    }
}

public class OrderSteps {
    @Autowired
    private TestContext context;
    
    @Autowired
    private OrderService orderService;
    
    @When("用户创建订单")
    public void userCreatesOrder() {
        User currentUser = context.getCurrentUser();
        Order order = orderService.createForUser(currentUser);
        context.setCurrentOrder(order);
    }
}
```

## 条件步骤定义

### 基于标签的条件执行

可以根据标签来控制步骤的执行：

```java
@When("用户执行操作")
@If(env = "test", value = "true")
public void userPerformsOperation() {
    // 仅在测试环境中执行
}

@When("用户执行操作")
@If(env = "prod", value = "false")
public void userPerformsOperationInProd() {
    // 在非生产环境中执行
}
```

### 基于状态的条件执行

根据当前状态决定是否执行某个步骤：

```java
@When("用户尝试登录")
public void userAttemptsLogin() {
    if (!isSystemAvailable()) {
        throw new PendingException("系统不可用，跳过登录步骤");
    }
    
    loginService.login(username, password);
}

private boolean isSystemAvailable() {
    // 检查系统是否可用
    return systemHealthChecker.isHealthy();
}
```

## 动态步骤定义

### 使用ScenarioContext动态生成步骤

```java
public class DynamicSteps {
    @Autowired
    private TestContext context;
    
    @When("用户执行 {string} 操作")
    public void userPerformsOperation(String operationName) {
        switch (operationName) {
            case "登录":
                performLogin();
                break;
            case "注册":
                performRegistration();
                break;
            case "下单":
                performOrderCreation();
                break;
            default:
                throw new IllegalArgumentException("未知操作: " + operationName);
        }
    }
    
    private void performLogin() {
        // 登录逻辑
    }
    
    private void performRegistration() {
        // 注册逻辑
    }
    
    private void performOrderCreation() {
        // 下单逻辑
    }
}
```

### 使用反射动态调用方法

```java
public class ReflectionSteps {
    @When("用户调用 {string} 方法，参数为 {string}")
    public void userCallsMethodWithParameter(String methodName, String parameter) throws Exception {
        Method method = this.getClass().getDeclaredMethod(methodName, String.class);
        method.invoke(this, parameter);
    }
    
    public void login(String username) {
        // 登录逻辑
    }
    
    public void search(String keyword) {
        // 搜索逻辑
    }
}
```

## 异步步骤定义

### 处理异步操作

对于异步操作，可以使用等待机制：

```java
@When("用户上传文件")
public void userUploadsFile() {
    fileUploadService.uploadAsync("test.txt");
    
    // 等待上传完成
    await().atMost(10, SECONDS).until(() -> 
        fileUploadService.getStatus("test.txt") == UploadStatus.COMPLETED
    );
}

@Then("文件应该上传成功")
public void fileShouldBeUploadedSuccessfully() {
    assertEquals(UploadStatus.COMPLETED, fileUploadService.getStatus("test.txt"));
}
```

### 使用CompletableFuture

```java
@When("用户发起异步请求")
public void userInitiatesAsyncRequest() {
    CompletableFuture<String> future = asyncService.processRequest();
    
    try {
        String result = future.get(5, SECONDS);
        context.set("asyncResult", result);
    } catch (Exception e) {
        fail("异步请求失败: " + e.getMessage());
    }
}

@Then("异步请求应该返回 {string}")
public void asyncRequestShouldReturn(String expectedResult) {
    String actualResult = context.get("asyncResult", String.class);
    assertEquals(expectedResult, actualResult);
}
```

## 步骤定义中的错误处理

### 自定义异常

创建自定义异常类型来处理特定的错误情况：

```java
public class BusinessException extends RuntimeException {
    private final String errorCode;
    
    public BusinessException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
    
    public String getErrorCode() {
        return errorCode;
    }
}

// 在步骤定义中使用
@When("用户执行可能失败的操作")
public void userPerformsPotentiallyFailingOperation() {
    try {
        riskyService.execute();
    } catch (BusinessException e) {
        context.set("lastError", e);
        // 不要重新抛出异常，让测试继续执行验证步骤
    }
}

@Then("用户应该看到错误代码 {string}")
public void userShouldSeeErrorCode(String expectedErrorCode) {
    BusinessException error = context.get("lastError", BusinessException.class);
    assertNotNull(error);
    assertEquals(expectedErrorCode, error.getErrorCode());
}
```

### 使用软断言

对于多个验证点，使用软断言可以收集所有失败信息：

```java
@Then("用户信息应该正确显示")
public void userInfoShouldBeDisplayedCorrectly() {
    UserPage userPage = pageFactory.getUserPage();
    
    SoftAssertions softly = new SoftAssertions();
    
    softly.assertThat(userPage.getUsername()).isEqualTo(expectedUsername);
    softly.assertThat(userPage.getEmail()).isEqualTo(expectedEmail);
    softly.assertThat(userPage.getRole()).isEqualTo(expectedRole);
    
    // 一次性验证所有断言
    softly.assertAll();
}
```

## 步骤定义的性能优化

### 缓存重复数据

对于重复使用的数据，可以实施缓存策略：

```java
public class CachedSteps {
    private Map<String, User> userCache = new HashMap<>();
    
    @Given("用户 {string} 存在")
    public void userExists(String username) {
        if (!userCache.containsKey(username)) {
            User user = userService.findByUsername(username);
            userCache.put(username, user);
        }
        
        context.setCurrentUser(userCache.get(username));
    }
}
```

### 批量操作优化

对于批量操作，可以优化数据库访问：

```java
@When("批量创建以下用户:")
public void batchCreateUsers(List<User> users) {
    // 使用批量插入而不是单个插入
    userService.batchCreate(users);
}

@When("批量验证用户存在:")
public void batchVerifyUsersExist(List<String> usernames) {
    // 使用批量查询而不是单个查询
    List<User> existingUsers = userService.findByUsernames(usernames);
    
    for (String username : usernames) {
        boolean exists = existingUsers.stream()
            .anyMatch(user -> user.getUsername().equals(username));
        assertTrue(exists, "用户 " + username + " 应该存在");
    }
}
```

## 总结

高级Step Definition技术提供了更强大和灵活的方式来编写BDD测试。通过使用参数转换器、数据表转换器、依赖注入、条件执行、动态步骤、异步处理和错误处理等技术，可以创建更复杂、更可维护的测试场景。

掌握这些高级技术将帮助您构建更强大、更灵活的Cucumber测试套件，能够处理复杂的应用程序和业务场景。