# 3.6 Step Definition实践练习

## 练习1：基础步骤定义实现

### 目标
实现一个简单的用户登录功能的步骤定义，掌握基本的步骤定义编写方法。

### 需求描述
创建一个用户登录功能的BDD测试，包含以下场景：
1. 用户使用有效凭证登录
2. 用户使用无效密码登录
3. 用户使用不存在的用户名登录

### 任务要求

1. **创建Gherkin特性文件**
   - 创建`user-login.feature`文件
   - 定义上述三个场景
   - 使用Given-When-Then结构描述每个场景

2. **实现步骤定义类**
   - 创建`UserLoginSteps.java`类
   - 实现所有步骤定义方法
   - 使用适当的断言验证结果

3. **创建模拟服务类**
   - 创建`UserService.java`模拟类
   - 实现用户验证逻辑
   - 处理各种登录情况

### 提示
- 使用`@Given`、`@When`、`@Then`注解标记步骤定义方法
- 使用JUnit的断言方法验证结果
- 考虑使用简单的Map或List存储用户数据

### 预期结果
- 所有测试场景应该能够正确执行
- 测试结果应该反映预期的业务逻辑
- 步骤定义代码应该清晰易读

---

## 练习2：数据表处理

### 目标
学习如何使用数据表处理批量数据，实现产品管理功能的测试。

### 需求描述
创建一个产品管理功能的BDD测试，包含以下场景：
1. 批量创建产品
2. 批量更新产品价格
3. 按类别筛选产品

### 任务要求

1. **创建Gherkin特性文件**
   - 创建`product-management.feature`文件
   - 定义使用数据表的场景
   - 使用Given-When-Then结构描述每个场景

2. **实现步骤定义类**
   - 创建`ProductManagementSteps.java`类
   - 实现处理数据表的步骤定义方法
   - 使用DataTable API处理输入数据

3. **创建产品模型和服务类**
   - 创建`Product.java`模型类
   - 创建`ProductService.java`服务类
   - 实现产品的CRUD操作

### 提示
- 使用`DataTable.asMaps()`方法将数据表转换为Map列表
- 考虑实现自定义数据表转换器
- 使用流式API处理产品列表

### 预期结果
- 能够正确解析和处理数据表
- 批量操作应该正确执行
- 测试应该验证产品的状态变化

---

## 练习3：参数转换器实现

### 目标
学习如何创建和使用自定义参数转换器，处理复杂的参数类型。

### 需求描述
创建一个订单管理功能的BDD测试，包含以下场景：
1. 在特定日期创建订单
2. 使用不同货币支付订单
3. 设置订单配送地址

### 任务要求

1. **创建Gherkin特性文件**
   - 创建`order-management.feature`文件
   - 定义使用复杂参数的场景
   - 使用各种日期和货币格式

2. **实现自定义参数转换器**
   - 创建`ParameterTypeRegistryConfigurer`实现类
   - 实现日期、货币和地址的参数转换器
   - 使用正则表达式匹配参数格式

3. **实现步骤定义类**
   - 创建`OrderManagementSteps.java`类
   - 使用自定义参数类型
   - 实现订单管理逻辑

4. **创建相关模型类**
   - 创建`Order.java`、`Money.java`、`Address.java`等模型类
   - 实现适当的业务逻辑

### 提示
- 使用`@ParameterType`注解定义自定义参数类型
- 考虑使用Java 8的日期时间API
- 实现适当的equals和hashCode方法

### 预期结果
- 自定义参数应该正确转换
- 不同格式的参数应该都能正确处理
- 订单操作应该正确执行

---

## 练习4：依赖注入与状态管理

### 目标
学习如何使用依赖注入框架和共享状态管理，实现复杂的多步骤场景。

### 需求描述
创建一个电商购物流程的BDD测试，包含以下场景：
1. 用户浏览产品并添加到购物车
2. 用户查看购物车并更新数量
3. 用户结算并创建订单

### 任务要求

1. **创建Gherkin特性文件**
   - 创建`shopping-cart.feature`文件
   - 定义多步骤购物流程场景
   - 使用Given-When-Then-And结构

2. **实现共享上下文类**
   - 创建`TestContext.java`类
   - 实现状态共享机制
   - 提供类型安全的数据访问方法

3. **实现步骤定义类**
   - 创建多个步骤定义类，按功能域组织
   - 使用依赖注入注入服务和上下文
   - 实现跨步骤的状态共享

4. **配置依赖注入**
   - 配置Spring或PicoContainer
   - 创建测试配置类
   - 定义Bean依赖关系

5. **创建相关服务类**
   - 创建`ProductService.java`、`CartService.java`、`OrderService.java`等
   - 实现业务逻辑

### 提示
- 使用`@Autowired`或构造函数注入依赖
- 考虑使用`@Scope("cucumber-glue")`确保正确的生命周期
- 使用类型安全的方法访问上下文数据

### 预期结果
- 依赖注入应该正确工作
- 状态应该在步骤之间正确共享
- 购物流程应该正确执行

---

## 练习5：异步操作处理

### 目标
学习如何处理异步操作，实现涉及异步调用的测试场景。

### 需求描述
创建一个文件上传功能的BDD测试，包含以下场景：
1. 用户上传单个文件
2. 用户批量上传文件
3. 用户检查上传状态

### 任务要求

1. **创建Gherkin特性文件**
   - 创建`file-upload.feature`文件
   - 定义涉及异步操作的场景
   - 包含状态检查和结果验证

2. **实现异步服务类**
   - 创建`FileUploadService.java`类
   - 实现异步文件上传逻辑
   - 提供状态查询方法

3. **实现步骤定义类**
   - 创建`FileUploadSteps.java`类
   - 实现异步操作的步骤定义
   - 使用适当的等待机制

4. **处理异步结果**
   - 使用`CompletableFuture`处理异步结果
   - 实现超时和错误处理
   - 验证异步操作的结果

### 提示
- 考虑使用Awaitility库处理等待
- 实现适当的超时机制
- 处理异步操作中的异常情况

### 预期结果
- 异步操作应该正确执行
- 测试应该正确等待异步操作完成
- 异步结果应该正确验证

---

## 练习6：错误处理与验证

### 目标
学习如何处理测试中的错误情况，实现健壮的错误验证机制。

### 需求描述
创建一个支付处理功能的BDD测试，包含以下场景：
1. 成功支付
2. 支付失败（余额不足）
3. 支付失败（无效卡号）
4. 支付超时

### 任务要求

1. **创建Gherkin特性文件**
   - 创建`payment-processing.feature`文件
   - 定义成功和失败场景
   - 包含错误消息验证

2. **实现支付服务类**
   - 创建`PaymentService.java`类
   - 实现支付处理逻辑
   - 模拟各种错误情况

3. **实现步骤定义类**
   - 创建`PaymentSteps.java`类
   - 实现错误处理的步骤定义
   - 使用软断言验证多个条件

4. **处理异常情况**
   - 捕获和验证业务异常
   - 验证错误消息和错误代码
   - 实现适当的错误恢复机制

5. **使用软断言**
   - 使用AssertJ的SoftAssertions
   - 验证多个错误条件
   - 收集所有验证失败信息

### 提示
- 创建自定义异常类表示业务错误
- 考虑使用错误代码和消息
- 实现适当的错误日志记录

### 预期结果
- 成功场景应该正确执行
- 错误场景应该正确捕获和验证
- 错误信息应该准确和有用

---

## 练习7：性能优化

### 目标
学习如何优化步骤定义的性能，实现高效的测试执行。

### 需求描述
创建一个大数据量处理的BDD测试，包含以下场景：
1. 批量创建大量用户
2. 批量处理大量订单
3. 高并发操作

### 任务要求

1. **创建Gherkin特性文件**
   - 创建`performance-testing.feature`文件
   - 定义大数据量场景
   - 包含性能验证步骤

2. **实现优化的服务类**
   - 创建优化的`UserService.java`和`OrderService.java`
   - 实现批量操作
   - 使用缓存机制

3. **实现优化的步骤定义**
   - 创建`PerformanceSteps.java`类
   - 实现高效的步骤定义
   - 避免不必要的等待和重复操作

4. **性能测量**
   - 实现性能测量机制
   - 验证操作在预期时间内完成
   - 记录性能指标

5. **批量操作优化**
   - 使用批量数据库操作
   - 实现并行处理
   - 优化内存使用

### 提示
- 考虑使用连接池和批处理
- 实现适当的缓存策略
- 使用性能分析工具识别瓶颈

### 预期结果
- 大数据量操作应该在合理时间内完成
- 测试应该高效执行
- 性能指标应该满足预期

---

## 练习8：综合项目

### 目标
综合运用所学知识，实现一个完整的电商系统的BDD测试。

### 需求描述
创建一个完整的电商系统的BDD测试套件，包含以下功能：
1. 用户管理（注册、登录、个人资料）
2. 产品管理（浏览、搜索、筛选）
3. 购物车管理（添加、更新、删除）
4. 订单管理（创建、支付、配送）
5. 库存管理（检查、更新）

### 任务要求

1. **设计测试架构**
   - 设计合理的步骤定义组织结构
   - 定义共享上下文和状态管理策略
   - 规划依赖注入配置

2. **实现核心功能**
   - 创建所有必要的模型类
   - 实现核心业务服务
   - 创建完整的步骤定义

3. **实现高级特性**
   - 使用自定义参数转换器
   - 实现数据表转换器
   - 处理异步操作

4. **错误处理和验证**
   - 实现全面的错误处理
   - 使用软断言验证复杂场景
   - 实现详细的错误报告

5. **性能优化**
   - 优化测试执行速度
   - 实现高效的批量操作
   - 减少不必要的等待

6. **测试报告**
   - 配置详细的测试报告
   - 实现截图和日志记录
   - 集成测试覆盖率报告

### 提示
- 分阶段实现，从核心功能开始
- 重视代码的可维护性和可读性
- 考虑使用测试数据工厂创建测试数据

### 预期结果
- 完整的BDD测试套件
- 清晰的步骤定义组织结构
- 高效的测试执行
- 全面的错误处理和验证
- 详细的测试报告

---

## 练习解答参考

### 练习1参考实现

#### user-login.feature
```gherkin
Feature: 用户登录功能
  作为系统用户
  我希望能够登录系统
  以便访问我的个人账户

  Scenario: 用户使用有效凭证登录
    Given 用户 "john.doe" 存在，密码为 "password123"
    When 用户使用用户名 "john.doe" 和密码 "password123" 登录
    Then 用户应该成功登录
    And 用户应该看到欢迎消息

  Scenario: 用户使用无效密码登录
    Given 用户 "john.doe" 存在，密码为 "password123"
    When 用户使用用户名 "john.doe" 和密码 "wrongpassword" 登录
    Then 用户登录应该失败
    And 用户应该看到错误消息 "用户名或密码错误"

  Scenario: 用户使用不存在的用户名登录
    Given 用户 "nonexistent" 不存在
    When 用户使用用户名 "nonexistent" 和密码 "anypassword" 登录
    Then 用户登录应该失败
    And 用户应该看到错误消息 "用户名或密码错误"
```

#### UserLoginSteps.java
```java
package com.example.stepdefinitions;

import io.cucumber.java.en.Given;
import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.And;
import static org.junit.Assert.*;

public class UserLoginSteps {
    
    private UserService userService = new UserService();
    private String currentUser;
    private String errorMessage;
    private boolean loginSuccess;
    
    @Given("用户 {string} 存在，密码为 {string}")
    public void userExistsWithPassword(String username, String password) {
        userService.createUser(username, password);
    }
    
    @Given("用户 {string} 不存在")
    public void userDoesNotExist(String username) {
        // 确保用户不存在
        if (userService.userExists(username)) {
            userService.deleteUser(username);
        }
    }
    
    @When("用户使用用户名 {string} 和密码 {string} 登录")
    public void userLogsInWithCredentials(String username, String password) {
        currentUser = username;
        try {
            loginSuccess = userService.login(username, password);
            errorMessage = null;
        } catch (AuthenticationException e) {
            loginSuccess = false;
            errorMessage = e.getMessage();
        }
    }
    
    @Then("用户应该成功登录")
    public void userShouldBeLoggedIn() {
        assertTrue("用户应该成功登录", loginSuccess);
    }
    
    @Then("用户登录应该失败")
    public void userLoginShouldFail() {
        assertFalse("用户登录应该失败", loginSuccess);
    }
    
    @And("用户应该看到欢迎消息")
    public void userShouldSeeWelcomeMessage() {
        String welcomeMessage = userService.getWelcomeMessage(currentUser);
        assertNotNull("欢迎消息不应该为空", welcomeMessage);
        assertTrue("欢迎消息应该包含用户名", welcomeMessage.contains(currentUser));
    }
    
    @And("用户应该看到错误消息 {string}")
    public void userShouldSeeErrorMessage(String expectedMessage) {
        assertEquals("错误消息应该正确", expectedMessage, errorMessage);
    }
}
```

#### UserService.java
```java
package com.example.stepdefinitions;

import java.util.HashMap;
import java.util.Map;

public class UserService {
    
    private Map<String, String> users = new HashMap<>();
    
    public void createUser(String username, String password) {
        users.put(username, password);
    }
    
    public boolean userExists(String username) {
        return users.containsKey(username);
    }
    
    public void deleteUser(String username) {
        users.remove(username);
    }
    
    public boolean login(String username, String password) throws AuthenticationException {
        if (!userExists(username)) {
            throw new AuthenticationException("用户名或密码错误");
        }
        
        String storedPassword = users.get(username);
        if (!storedPassword.equals(password)) {
            throw new AuthenticationException("用户名或密码错误");
        }
        
        return true;
    }
    
    public String getWelcomeMessage(String username) {
        return "欢迎, " + username + "!";
    }
}

class AuthenticationException extends Exception {
    public AuthenticationException(String message) {
        super(message);
    }
}
```

---

## 总结

这些练习涵盖了Step Definition的各个方面，从基础实现到高级技术。通过完成这些练习，您将能够：

1. 掌握基本的步骤定义编写方法
2. 学会处理数据表和复杂参数
3. 理解依赖注入和状态管理
4. 处理异步操作和错误情况
5. 优化测试性能
6. 构建完整的BDD测试套件

建议按照顺序完成这些练习，逐步提高复杂度。每个练习都建立在前一个练习的基础上，帮助您全面掌握Step Definition的实现技术。