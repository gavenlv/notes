# 第6章：参数化测试与测试套件

## 6.1 参数化测试概述

### 6.1.1 什么是参数化测试

参数化测试是一种测试方法，允许使用不同的输入参数多次执行相同的测试逻辑。这种测试模式的优势包括：

- **减少重复代码**：避免为不同输入编写相似测试
- **提高测试覆盖率**：使用多种输入场景测试同一逻辑
- **增强可维护性**：修改测试逻辑只需更新一处代码
- **发现边界问题**：更容易发现边界条件和异常情况

```java
// 传统测试方式（重复代码）
public class TraditionalMathTest {
    
    @Test
    public void testAddition1() {
        assertEquals(5, MathUtils.add(2, 3));
    }
    
    @Test
    public void testAddition2() {
        assertEquals(0, MathUtils.add(-2, 2));
    }
    
    @Test
    public void testAddition3() {
        assertEquals(10, MathUtils.add(4, 6));
    }
    
    @Test
    public void testAddition4() {
        assertEquals(-5, MathUtils.add(-2, -3));
    }
}

// 参数化测试方式（简洁代码）
public class ParameterizedMathTest {
    
    @ParameterizedTest
    @ValueSource(ints = {2, -2, 4, -2})  // 第一个参数
    @ValueSource(ints = {3, 2, 6, -3})  // 第二个参数
    public void testAddition(int a, int b) {
        int expected = a + b;
        assertEquals(expected, MathUtils.add(a, b));
    }
}
```

### 6.1.2 参数化测试的应用场景

参数化测试适用于以下场景：

1. **数学计算**：使用不同数值测试数学函数
2. **字符串处理**：测试各种字符串输入情况
3. **边界值测试**：测试最小值、最大值和临界值
4. **配置验证**：测试不同配置组合
5. **API端点**：测试各种请求参数组合

```java
public class ParameterizedTestScenarios {
    
    // 场景1：数学计算
    @ParameterizedTest
    @ValueSource(doubles = {0, Math.PI/2, Math.PI, 3*Math.PI/2, 2*Math.PI})
    public void testTrigonometricFunctions(double angle) {
        assertEquals(Math.sin(angle), Math.sin(angle), 0.0001);
    }
    
    // 场景2：字符串处理
    @ParameterizedTest
    @ValueSource(strings = {"", " ", "  ", "a", "ab", "a b c"})
    public void testStringTrimming(String input) {
        String trimmed = input.trim();
        assertFalse(trimmed.startsWith(" "));
        assertFalse(trimmed.endsWith(" "));
    }
    
    // 场景3：边界值测试
    @ParameterizedTest
    @ValueSource(ints = {Integer.MIN_VALUE, -1, 0, 1, Integer.MAX_VALUE})
    public void testBoundaryValues(int value) {
        assertTrue(value >= Integer.MIN_VALUE);
        assertTrue(value <= Integer.MAX_VALUE);
    }
    
    // 场景4：配置验证
    @ParameterizedTest
    @EnumSource(Configuration.Environment.class)
    public void testEnvironmentConfiguration(Configuration.Environment env) {
        Configuration config = new Configuration(env);
        assertNotNull(config.getDatabaseUrl());
        assertTrue(config.getDatabaseUrl().length() > 0);
    }
    
    // 场景5：API端点
    @ParameterizedTest
    @ValueSource(strings = {"GET", "POST", "PUT", "DELETE", "PATCH"})
    public void testHttpMethods(String method) {
        assertTrue(HttpUtils.isValidHttpMethod(method));
    }
}
```

## 6.2 JUnit 5参数化测试

### 6.2.1 @ParameterizedTest基础

JUnit 5的参数化测试需要添加额外依赖和注解：

```xml
<!-- 在pom.xml中添加参数化测试依赖 -->
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-params</artifactId>
    <version>5.9.2</version>
    <scope>test</scope>
</dependency>
```

```java
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.*;

public class BasicParameterizedTest {
    
    // 使用@ValueSource提供基本类型参数
    @ParameterizedTest
    @ValueSource(ints = {1, 2, 3, 4, 5})
    public void testWithIntValues(int number) {
        assertTrue(number > 0);
        assertTrue(number <= 5);
    }
    
    // 使用多个@ValueSource（注意：这样不行，需要使用其他方法）
    // 以下是错误示例，多个@ValueSource不能同时用于同一方法
    /*
    @ParameterizedTest
    @ValueSource(ints = {1, 2, 3})
    @ValueSource(strings = {"a", "b", "c"})
    public void wrongWay(int num, String str) { }
    */
    
    // 正确方式：使用@CsvSource提供多参数
    @ParameterizedTest
    @CsvSource({
        "1, a", 
        "2, b", 
        "3, c"
    })
    public void testWithCsvSource(int num, String str) {
        assertEquals(num, str.charAt(0) - 'a' + 1);
    }
    
    // 使用@EnumSource提供枚举参数
    @ParameterizedTest
    @EnumSource(TimeUnit.class)
    public void testWithEnumSource(TimeUnit unit) {
        assertNotNull(unit);
        assertNotNull(unit.name());
    }
    
    // 使用@EnumSource并排除特定值
    @ParameterizedTest
    @EnumSource(value = TimeUnit.class, names = {"SECONDS", "MILLISECONDS"})
    public void testWithFilteredEnumSource(TimeUnit unit) {
        assertTrue(unit == TimeUnit.SECONDS || unit == TimeUnit.MILLISECONDS);
    }
    
    // 使用@EnumSource并使用正则表达式匹配
    @ParameterizedTest
    @EnumSource(mode = EnumSource.Mode.MATCH_ALL, names = ".*_TIME")
    public void testWithRegexEnumSource(TimeUnit unit) {
        assertTrue(unit.name().endsWith("_TIME"));
    }
}
```

### 6.2.2 @ValueSource详解

@ValueSource是提供单一参数的最简单方式：

```java
public class ValueSourceExamples {
    
    // 整数参数
    @ParameterizedTest
    @ValueSource(ints = {1, 2, 3, 4, 5})
    public void testIntParameters(int value) {
        assertTrue(value > 0 && value <= 5);
    }
    
    // 长整数参数
    @ParameterizedTest
    @ValueSource(longs = {1L, 2L, 100L, 1000L})
    public void testLongParameters(long value) {
        assertTrue(value > 0);
    }
    
    // 双精度浮点数参数
    @ParameterizedTest
    @ValueSource(doubles = {0.0, 0.5, 1.0, Math.PI, Math.E})
    public void testDoubleParameters(double value) {
        assertTrue(value >= 0.0);
    }
    
    // 字符串参数
    @ParameterizedTest
    @ValueSource(strings = {"", " ", "hello", "JUnit 5", "参数化测试"})
    public void testStringParameters(String value) {
        assertNotNull(value);
    }
    
    // 字符参数
    @ParameterizedTest
    @ValueSource(chars = {'a', 'A', '1', '?', '#'})
    public void testCharParameters(char value) {
        assertTrue(Character.isDefined(value));
    }
    
    // 类参数
    @ParameterizedTest
    @ValueSource(classes = {String.class, Integer.class, Double.class, Boolean.class})
    public void testClassParameters(Class<?> clazz) {
        assertNotNull(clazz);
        assertFalse(clazz.isPrimitive());
    }
}
```

### 6.2.3 @CsvSource和@CsvFileSource

使用CSV格式提供多参数：

```java
public class CsvSourceExamples {
    
    // 基本CSV源
    @ParameterizedTest
    @CsvSource({
        "apple, 1, RED",
        "banana, 2, YELLOW", 
        "grape, 3, PURPLE"
    })
    public void testBasicCsv(String fruit, int rank, String color) {
        assertNotNull(fruit);
        assertTrue(rank > 0);
        assertNotNull(color);
    }
    
    // 使用空值和引号
    @ParameterizedTest
    @CsvSource({
        "value1, value2, value3",
        "value4, '', value6",    // 空字符串
        "value7, null, value9",  // null值
        "'value, with, comma', 10, 'color with space'"  // 包含逗号的值
    })
    public void testSpecialCsvValues(String col1, String col2, String col3) {
        assertNotNull(col1);
        assertNotNull(col3);
        
        if ("null".equals(col2)) {
            assertNull(col2);
        } else if ("''".equals(col2)) {
            assertEquals("", col2);
        }
    }
    
    // 使用分隔符
    @ParameterizedTest
    @CsvSource(value = {
        "apple|red|fruit",
        "carrot|orange|vegetable",
        "sky|blue|nature"
    }, delimiter = '|')
    public void testCustomDelimiter(String item, String color, String category) {
        assertNotNull(item);
        assertNotNull(color);
        assertNotNull(category);
    }
    
    // 从CSV文件读取
    @ParameterizedTest
    @CsvFileSource(resources = "/test-data/users.csv", numLinesToSkip = 1) // 跳过标题行
    public void testCsvFileSource(String name, int age, String email) {
        assertNotNull(name);
        assertTrue(age > 0);
        assertTrue(email.contains("@"));
    }
    
    // 使用不同的编码和分隔符
    @ParameterizedTest
    @CsvFileSource(resources = "/test-data/international.csv", 
                   encoding = "UTF-8", 
                   delimiterString = ";",
                   numLinesToSkip = 1)
    public void testInternationalCsv(String name, String country, int population) {
        assertNotNull(name);
        assertNotNull(country);
        assertTrue(population > 0);
    }
}
```

### 6.2.4 @MethodSource和@EnumSource

使用方法或枚举提供参数：

```java
public class MethodAndEnumSourceExamples {
    
    // 使用方法作为参数源
    @ParameterizedTest
    @MethodSource("stringProvider")
    public void testMethodSource(String argument) {
        assertNotNull(argument);
        assertFalse(argument.isEmpty());
    }
    
    // 提供参数的方法必须是静态的，返回Stream、Iterable或数组
    static Stream<String> stringProvider() {
        return Stream.of("apple", "banana", "cherry");
    }
    
    // 使用Arguments提供多参数
    @ParameterizedTest
    @MethodSource("argumentProvider")
    public void testMultiParameterMethodSource(int number, String text, boolean flag) {
        assertTrue(number > 0);
        assertNotNull(text);
        // flag可以是true或false
    }
    
    static Stream<Arguments> argumentProvider() {
        return Stream.of(
            Arguments.of(1, "one", true),
            Arguments.of(2, "two", false),
            Arguments.of(3, "three", true)
        );
    }
    
    // 使用自定义类作为参数
    @ParameterizedTest
    @MethodSource("userProvider")
    public void testCustomObjectParameter(User user) {
        assertNotNull(user);
        assertNotNull(user.getName());
        assertTrue(user.getId() > 0);
    }
    
    static Stream<User> userProvider() {
        return Stream.of(
            new User(1, "Alice"),
            new User(2, "Bob"),
            new User(3, "Charlie")
        );
    }
    
    // 使用枚举源
    @ParameterizedTest
    @EnumSource(Status.class)
    public void testEnumSource(Status status) {
        assertNotNull(status);
        assertNotNull(status.name());
    }
    
    // 过滤枚举值
    @ParameterizedTest
    @EnumSource(value = Status.class, names = {"ACTIVE", "INACTIVE"})
    public void testFilteredEnumSource(Status status) {
        assertTrue(status == Status.ACTIVE || status == Status.INACTIVE);
    }
    
    // 排除特定枚举值
    @ParameterizedTest
    @EnumSource(value = Status.class, mode = EnumSource.Mode.EXCLUDE, names = {"DELETED"})
    public void testExcludedEnumSource(Status status) {
        assertNotEquals(Status.DELETED, status);
    }
    
    // 使用正则表达式匹配枚举
    @ParameterizedTest
    @EnumSource(mode = EnumSource.Mode.MATCH_ALL, names = ".*ED")
    public void testRegexEnumSource(Status status) {
        assertTrue(status.name().endsWith("ED"));
    }
    
    // 辅助类
    enum Status {
        ACTIVE, INACTIVE, PENDING, DELETED, COMPLETED
    }
    
    static class User {
        private int id;
        private String name;
        
        public User(int id, String name) {
            this.id = id;
            this.name = name;
        }
        
        public int getId() { return id; }
        public String getName() { return name; }
    }
}
```

### 6.2.5 @ArgumentsSource自定义参数源

创建自定义参数源：

```java
public class CustomArgumentsSourceExample {
    
    // 使用自定义参数源
    @ParameterizedTest
    @ArgumentsSource(CustomIntegerArgumentsProvider.class)
    public void testCustomArgumentsSource(int number) {
        assertTrue(number >= 0 && number <= 100);
    }
    
    @ParameterizedTest
    @ArgumentsSource(CustomUserArgumentsProvider.class)
    public void testCustomUserArgumentsSource(User user) {
        assertNotNull(user);
        assertNotNull(user.getName());
        assertNotNull(user.getEmail());
        assertTrue(user.getEmail().contains("@"));
    }
    
    // 自定义参数提供器
    static class CustomIntegerArgumentsProvider implements ArgumentsProvider {
        
        @Override
        public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
            // 提供0-100之间的质数作为参数
            return IntStream.rangeClosed(2, 100)
                .filter(this::isPrime)
                .mapToObj(Arguments::of);
        }
        
        private boolean isPrime(int n) {
            if (n <= 1) return false;
            for (int i = 2; i * i <= n; i++) {
                if (n % i == 0) return false;
            }
            return true;
        }
    }
    
    static class CustomUserArgumentsProvider implements ArgumentsProvider {
        
        @Override
        public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
            // 从配置文件或数据库读取测试用户
            List<User> users = Arrays.asList(
                new User("user1@example.com", "User One"),
                new User("user2@example.com", "User Two"),
                new User("admin@example.com", "Admin User")
            );
            
            return users.stream().map(Arguments::of);
        }
    }
    
    // 使用注解配置自定义参数源
    @Target({ElementType.ANNOTATION_TYPE, ElementType.METHOD})
    @Retention(RetentionPolicy.RUNTIME)
    @ArgumentsSource(TemperatureArgumentsProvider.class)
    public @interface TemperatureSource {
        double min() default -50.0;
        double max() default 50.0;
        double step() default 10.0;
    }
    
    @ParameterizedTest
    @TemperatureSource(min = 0.0, max = 100.0, step = 25.0)
    public void testTemperatureConversion(double celsius) {
        double fahrenheit = celsius * 9.0 / 5.0 + 32.0;
        assertTrue(fahrenheit >= 32.0);
        
        if (celsius == 0.0) {
            assertEquals(32.0, fahrenheit);
        } else if (celsius == 100.0) {
            assertEquals(212.0, fahrenheit);
        }
    }
    
    static class TemperatureArgumentsProvider implements ArgumentsProvider, AnnotationConsumer<TemperatureSource> {
        private double min;
        private double max;
        private double step;
        
        @Override
        public void accept(TemperatureSource source) {
            this.min = source.min();
            this.max = source.max();
            this.step = source.step();
        }
        
        @Override
        public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
            return Stream.iterate(min, d -> d <= max, d -> d + step)
                .map(Arguments::of);
        }
    }
    
    // 辅助类
    static class User {
        private String email;
        private String name;
        
        public User(String email, String name) {
            this.email = email;
            this.name = name;
        }
        
        public String getEmail() { return email; }
        public String getName() { return name; }
    }
}
```

## 6.3 高级参数化测试

### 6.3.1 动态测试

JUnit 5引入了动态测试，可以在运行时生成测试用例：

```java
public class DynamicTestExample {
    
    @TestFactory
    Collection<DynamicTest> dynamicTestsWithCollection() {
        List<String> inputs = Arrays.asList("apple", "banana", "cherry");
        
        return inputs.stream()
            .map(input -> DynamicTest.dynamicTest("Test with input: " + input, () -> {
                assertNotNull(input);
                assertTrue(input.length() > 0);
                assertEquals(Character.toLowerCase(input.charAt(0)), input.charAt(0));
            }))
            .collect(Collectors.toList());
    }
    
    @TestFactory
    Stream<DynamicTest> dynamicTestsWithStream() {
        return IntStream.range(1, 5)
            .mapToObj(num -> DynamicTest.dynamicTest("Factorial of " + num, () -> {
                long expected = factorial(num);
                long actual = MathUtils.factorial(num);
                assertEquals(expected, actual, "Factorial of " + num + " should be " + expected);
            }));
    }
    
    @TestFactory
    Stream<DynamicNode> dynamicTestsWithContainer() {
        return Stream.of("strings", "numbers", "booleans")
            .map(type -> DynamicContainer.dynamicContainer("Tests for " + type, Stream.of(
                DynamicTest.dynamicTest("Test 1 for " + type, () -> assertTrue(true)),
                DynamicTest.dynamicTest("Test 2 for " + type, () -> assertFalse(false))
            )));
    }
    
    // 动态测试结合参数化测试
    @TestFactory
    Stream<DynamicTest> parameterizedDynamicTests() {
        List<User> testUsers = loadTestUsers();
        
        return testUsers.stream()
            .map(user -> DynamicTest.dynamicTest(
                "Validate user: " + user.getName(),
                () -> {
                    assertTrue(validateUser(user));
                    assertTrue(isEmailValid(user.getEmail()));
                }
            ));
    }
    
    private long factorial(int n) {
        if (n <= 1) return 1;
        return n * factorial(n - 1);
    }
    
    private List<User> loadTestUsers() {
        return Arrays.asList(
            new User("user1@example.com", "User One", 25),
            new User("user2@example.com", "User Two", 30),
            new User("admin@example.com", "Admin", 40)
        );
    }
    
    private boolean validateUser(User user) {
        return user.getName() != null && !user.getName().isEmpty() 
               && user.getEmail() != null && user.getEmail().contains("@");
    }
    
    private boolean isEmailValid(String email) {
        return email != null && email.matches("^[A-Za-z0-9+_.-]+@(.+)$");
    }
    
    static class User {
        private String email;
        private String name;
        private int age;
        
        public User(String email, String name, int age) {
            this.email = email;
            this.name = name;
            this.age = age;
        }
        
        public String getEmail() { return email; }
        public String getName() { return name; }
        public int getAge() { return age; }
    }
}
```

### 6.3.2 参数转换

在参数化测试中使用参数转换：

```java
public class ParameterConversionExample {
    
    // 字符串到整数转换
    @ParameterizedTest
    @ValueSource(strings = {"1", "2", "3", "10", "100"})
    public void testStringToIntConversion(@ConvertWith(StringToIntConverter.class) int number) {
        assertTrue(number > 0);
    }
    
    // 字符串到日期转换
    @ParameterizedTest
    @ValueSource(strings = {"2023-01-01", "2023-06-15", "2023-12-31"})
    public void testStringToDateConversion(@ConvertWith(StringToDateConverter.class) LocalDate date) {
        assertEquals(2023, date.getYear());
    }
    
    // 自定义转换器
    static class StringToIntConverter implements ArgumentConverter {
        @Override
        public Object convert(Object source, ParameterContext context) 
            throws ArgumentConversionException {
            if (source instanceof String) {
                try {
                    return Integer.parseInt((String) source);
                } catch (NumberFormatException e) {
                    throw new ArgumentConversionException(
                        "Cannot convert '" + source + "' to Integer");
                }
            }
            throw new ArgumentConversionException("Source must be a String");
        }
    }
    
    static class StringToDateConverter implements ArgumentConverter {
        private static final DateTimeFormatter DATE_FORMATTER = 
            DateTimeFormatter.ofPattern("yyyy-MM-dd");
        
        @Override
        public Object convert(Object source, ParameterContext context) 
            throws ArgumentConversionException {
            if (source instanceof String) {
                try {
                    return LocalDate.parse((String) source, DATE_FORMATTER);
                } catch (DateTimeParseException e) {
                    throw new ArgumentConversionException(
                        "Cannot convert '" + source + "' to LocalDate. Expected format: yyyy-MM-dd");
                }
            }
            throw new ArgumentConversionException("Source must be a String");
        }
    }
    
    // 使用Java 8的显式转换（需要Java 8+）
    @ParameterizedTest
    @ValueSource(strings = {"1", "2", "3"})
    public void testExplicitConversion(Integer number) {
        // JUnit 5会自动尝试转换字符串到整数
        assertNotNull(number);
        assertTrue(number > 0);
    }
    
    // 复杂对象转换
    @ParameterizedTest
    @ValueSource(strings = {
        "user1@example.com,User One,25",
        "user2@example.com,User Two,30",
        "admin@example.com,Admin,40"
    })
    public void testComplexObjectConversion(@ConvertWith(UserConverter.class) User user) {
        assertNotNull(user);
        assertNotNull(user.getEmail());
        assertNotNull(user.getName());
        assertTrue(user.getAge() > 0);
    }
    
    static class UserConverter implements ArgumentConverter {
        @Override
        public Object convert(Object source, ParameterContext context) 
            throws ArgumentConversionException {
            if (source instanceof String) {
                String[] parts = ((String) source).split(",");
                if (parts.length != 3) {
                    throw new ArgumentConversionException(
                        "Expected format: email,name,age but got: " + source);
                }
                
                try {
                    String email = parts[0].trim();
                    String name = parts[1].trim();
                    int age = Integer.parseInt(parts[2].trim());
                    return new User(email, name, age);
                } catch (NumberFormatException e) {
                    throw new ArgumentConversionException(
                        "Cannot parse age from: " + parts[2]);
                }
            }
            throw new ArgumentConversionException("Source must be a String");
        }
    }
    
    // 辅助类
    static class User {
        private String email;
        private String name;
        private int age;
        
        public User(String email, String name, int age) {
            this.email = email;
            this.name = name;
            this.age = age;
        }
        
        public String getEmail() { return email; }
        public String getName() { return name; }
        public int getAge() { return age; }
    }
}
```

### 6.3.3 参数显示名称

为参数化测试提供有意义的显示名称：

```java
public class ParameterDisplayNameExample {
    
    // 基本显示名称模板
    @ParameterizedTest(name = "Test with value {0}")
    @ValueSource(ints = {1, 2, 3})
    public void testBasicDisplayName(int value) {
        assertTrue(value > 0);
    }
    
    // 多参数显示名称模板
    @ParameterizedTest(name = "Multiply {0} by {1} = {2}")
    @CsvSource({
        "2, 3, 6",
        "5, 5, 25",
        "-2, 4, -8"
    })
    public void testMultiplyDisplayName(int a, int b, int expected) {
        assertEquals(expected, a * b);
    }
    
    // 使用自定义显示名称
    @ParameterizedTest(name = "Check if [{0}] is a palindrome")
    @ValueSource(strings = {"racecar", "level", "hello", "world"})
    public void testPalindromeDisplayName(String text) {
        boolean isPalindrome = text.equals(new StringBuilder(text).reverse().toString());
        // 根据文本内容断言不同结果
    }
    
    // 复杂显示名称
    @ParameterizedTest(name = "[{index}] User: {0}, Email: {1}, Age: {2}")
    @CsvSource({
        "Alice, alice@example.com, 25",
        "Bob, bob@example.com, 30",
        "Charlie, charlie@example.com, 35"
    })
    public void testUserDisplayName(String name, String email, int age) {
        assertNotNull(name);
        assertTrue(email.contains("@"));
        assertTrue(age > 0);
    }
    
    // 使用显示名称格式化
    @ParameterizedTest(name = "{displayName}[{index}] -> Input: {0}, Output: {1}")
    @CsvSource({
        "5, 120",  // 5! = 120
        "4, 24",   // 4! = 24
        "3, 6"     // 3! = 6
    })
    @DisplayName("Factorial calculation")
    public void testFactorialDisplayName(int input, int expected) {
        int actual = MathUtils.factorial(input);
        assertEquals(expected, actual);
    }
    
    // 使用枚举的显示名称
    @ParameterizedTest(name = "Testing {0} environment")
    @EnumSource(Environment.class)
    public void testEnvironmentDisplayName(Environment environment) {
        assertNotNull(environment);
        assertNotNull(environment.name());
    }
    
    // 枚举类
    enum Environment {
        DEVELOPMENT, TESTING, STAGING, PRODUCTION
    }
}
```

## 6.4 测试套件

### 6.4.1 @Suite注解

JUnit 5 Platform提供了测试套件支持，可以组合多个测试类：

```xml
<!-- 在pom.xml中添加测试套件依赖 -->
<dependency>
    <groupId>org.junit.platform</groupId>
    <artifactId>junit-platform-suite</artifactId>
    <version>1.9.2</version>
    <scope>test</scope>
</dependency>
```

```java
import org.junit.platform.suite.api.*;

// 基本测试套件
@Suite
@SuiteDisplayName("Mathematics Test Suite")
@SelectClasses({
    AdditionTest.class,
    SubtractionTest.class,
    MultiplicationTest.class
})
public class MathSuite {
    // 这个类可以包含before/after all逻辑
    @BeforeAll
    static void setUp() {
        System.out.println("数学测试套件开始");
    }
    
    @AfterAll
    static void tearDown() {
        System.out.println("数学测试套件结束");
    }
}

// 使用包选择
@Suite
@SuiteDisplayName("All Repository Tests")
@SelectPackages("com.example.repository")
public class RepositorySuite {
    // 运行指定包下的所有测试
}

// 使用类名模式选择
@Suite
@SuiteDisplayName("Pattern-based Test Suite")
@SelectClasses({
    ServiceTest.class,
    RepositoryTest.class,
    ControllerTest.class
})
public class PatternBasedSuite {
    // 测试套件逻辑
}

// 组合多个选择条件
@Suite
@SuiteDisplayName("Comprehensive Test Suite")
@SelectPackages("com.example.service")
@SelectClasses({IntegrationTest.class, PerformanceTest.class})
public class ComprehensiveSuite {
    // 先运行service包下的所有测试，然后运行指定的类
}

// 排除测试
@Suite
@SuiteDisplayName("Test Suite with Exclusions")
@SelectPackages("com.example")
@ExcludePackages("com.example.integration")
@ExcludeClasses({SlowTest.class, FlakyTest.class})
public class FilteredSuite {
    // 运行com.example包下除integration包和指定类外的所有测试
}
```

### 6.4.2 嵌套测试套件

创建嵌套的测试套件结构：

```java
// 顶层测试套件
@Suite
@SuiteDisplayName("Application Test Suite")
@SelectClasses({
    UnitTestSuite.class,
    IntegrationTestSuite.class,
    EndToEndTestSuite.class
})
public class ApplicationTestSuite {
    // 应用级测试套件
}

// 单元测试套件
@Suite
@SuiteDisplayName("Unit Test Suite")
@SelectPackages({
    "com.example.service",
    "com.example.repository",
    "com.example.util"
})
@ExcludePackages("com.example.integration")
public class UnitTestSuite {
    // 单元测试套件
}

// 集成测试套件
@Suite
@SuiteDisplayName("Integration Test Suite")
@SelectPackages({
    "com.example.integration.database",
    "com.example.integration.messaging"
})
public class IntegrationTestSuite {
    // 集成测试套件
}

// 端到端测试套件
@Suite
@SuiteDisplayName("End-to-End Test Suite")
@SelectClasses({
    UserJourneyTest.class,
    OrderProcessingTest.class,
    PaymentFlowTest.class
})
public class EndToEndTestSuite {
    // 端到端测试套件
}
```

### 6.4.3 条件测试套件

根据条件选择性运行测试：

```java
// 使用@IncludeClassNamePatterns
@Suite
@SuiteDisplayName("Pattern Inclusion Test Suite")
@SelectPackages("com.example")
@IncludeClassNamePatterns({".*Test$", ".*Tests$"})
public class PatternInclusionSuite {
    // 包含所有以Test或Tests结尾的类
}

// 使用@ExcludeClassNamePatterns
@Suite
@SuiteDisplayName("Pattern Exclusion Test Suite")
@SelectPackages("com.example")
@ExcludeClassNamePatterns({".*IT$", ".*IntegrationTest$"})
public class PatternExclusionSuite {
    // 排除所有以IT或IntegrationTest结尾的类
}

// 根据标签选择
@Suite
@SuiteDisplayName("Tag-based Test Suite")
@SelectPackages("com.example")
@IncludeTags("unit", "fast")
@ExcludeTags("slow", "integration")
public class TagBasedSuite {
    // 只运行标记为unit或fast的测试，排除标记为slow或integration的测试
}

// 使用JUnit Jupiter条件
@Suite
@SuiteDisplayName("Conditional Test Suite")
@SelectPackages("com.example")
@IncludeClassNamePatterns(".*Test")
public class ConditionalSuite {
    
    // 使用条件注解在套件级别
    @BeforeAll
    @EnabledIfEnvironmentVariable(named = "RUN_SLOW_TESTS", matches = "true")
    static void enableSlowTests() {
        System.out.println("运行慢速测试");
    }
    
    @BeforeAll
    @EnabledIfSystemProperty(named = "test.profile", matches = "integration")
    static void enableIntegrationTests() {
        System.out.println("运行集成测试");
    }
}
```

## 6.5 测试执行与报告

### 6.5.1 运行参数化测试

```bash
# 运行所有测试
mvn test

# 运行特定测试类
mvn test -Dtest=ParameterizedMathTest

# 运行特定测试方法
mvn test -Dtest=ParameterizedMathTest#testMultiply*

# 运行测试套件
mvn test -Dtest=MathSuite

# 使用标签过滤
mvn test -Dgroups="unit"

# 排除特定标签
mvn test -DexcludedGroups="slow"

# 运行所有参数化测试
mvn test -Dtest="*Parameterized*"
```

### 6.5.2 测试报告与分析

```java
public class ParameterizedTestReporting {
    
    // 使用测试信息进行条件验证
    @ParameterizedTest
    @ValueSource(strings = {"short", "medium length", "this is a very long string"})
    public void testStringLength(String input, TestInfo testInfo) {
        // 根据测试信息添加断言
        String displayName = testInfo.getDisplayName();
        
        if (displayName.contains("short")) {
            assertTrue(input.length() < 10);
        } else if (displayName.contains("long")) {
            assertTrue(input.length() > 10);
        }
        
        // 记录测试信息
        System.out.println("Test: " + displayName + ", Input: '" + input + 
                          "', Length: " + input.length());
    }
    
    // 使用重复信息进行报告
    @RepeatedTest(3)
    public void repeatedTestWithReporting(RepetitionInfo repetitionInfo, TestInfo testInfo) {
        int currentRepetition = repetitionInfo.getCurrentRepetition();
        int totalRepetitions = repetitionInfo.getTotalRepetitions();
        
        System.out.printf("Running %s - Repetition %d of %d%n",
            testInfo.getDisplayName(), currentRepetition, totalRepetitions);
        
        // 根据重复次数执行不同逻辑
        if (currentRepetition == 1) {
            // 第一次重复的逻辑
        } else {
            // 其他重复的逻辑
        }
        
        assertTrue(true); // 简单的断言
    }
    
    // 动态测试的报告
    @TestFactory
    Stream<DynamicTest> dynamicTestsWithReporting() {
        return Stream.of("apple", "banana", "cherry")
            .map(fruit -> DynamicTest.dynamicTest(
                "Validate fruit: " + fruit,
                () -> {
                    System.out.println("Testing fruit: " + fruit);
                    assertNotNull(fruit);
                    assertFalse(fruit.isEmpty());
                    System.out.println("Successfully tested: " + fruit);
                }
            ));
    }
}
```

## 6.6 最佳实践

### 6.6.1 参数化测试设计原则

1. **单一职责**：每个参数化测试只验证一个功能点
2. **数据与逻辑分离**：将测试数据和测试逻辑分开
3. **清晰命名**：使用有意义的测试方法和参数名称
4. **边界覆盖**：包含边界条件和异常情况
5. **可读性优先**：优先考虑测试的可读性而非简洁性

```java
public class ParameterizedTestBestPractices {
    
    // 好的做法：清晰的数据源，有意义的显示名称
    @ParameterizedTest(name = "[{index}] Text: '{0}', Expected length: {1}")
    @MethodSource("textAndExpectedLengthProvider")
    public void testStringLengthWithClearNames(String text, int expectedLength) {
        assertEquals(expectedLength, text.length(), 
            "Text length of '" + text + "' should be " + expectedLength);
    }
    
    static Stream<Arguments> textAndExpectedLengthProvider() {
        return Stream.of(
            Arguments.of("", 0),                   // 空字符串
            Arguments.of("a", 1),                  // 单字符
            Arguments.of("hello", 5),              // 普通文本
            Arguments.of("special chars !@#", 16), // 包含特殊字符
            Arguments.of("multiple words here", 19) // 多个单词
        );
    }
    
    // 好的做法：使用枚举提供清晰的参数
    @ParameterizedTest(name = "Testing email format for {0}")
    @EnumSource(EmailTestCase.class)
    public void testEmailValidationWithEnum(EmailTestCase testCase) {
        boolean isValid = EmailValidator.isValid(testCase.email);
        assertEquals(testCase.expectedResult, isValid, 
            "Email '" + testCase.email + "' should be " + testCase.expectedResult);
    }
    
    // 测试用例枚举
    enum EmailTestCase {
        VALID_SIMPLE("user@example.com", true),
        VALID_WITH_SUBDOMAIN("user@sub.example.com", true),
        VALID_WITH_PLUS("user+tag@example.com", true),
        INVALID_NO_AT("userexample.com", false),
        INVALID_NO_DOMAIN("user@", false),
        INVALID_MULTIPLE_AT("user@@example.com", false);
        
        final String email;
        final boolean expectedResult;
        
        EmailTestCase(String email, boolean expectedResult) {
            this.email = email;
            this.expectedResult = expectedResult;
        }
    }
    
    // 好的做法：测试边界条件
    @ParameterizedTest(name = "[{index}] Testing calculator with {0} and {1}")
    @CsvSource({
        "1, 1, 2",    // 最小正整数
        "0, 0, 0",    // 零值
        "-1, -1, -2", // 负数
        "2147483647, 0, 2147483647",  // 最大整数
        "-2147483648, 0, -2147483648"  // 最小整数
    })
    public void testCalculatorBoundaryValues(int a, int b, int expected) {
        assertEquals(expected, MathUtils.add(a, b), 
            String.format("Boundary test: %d + %d should equal %d", a, b, expected));
    }
    
    // 差的做法：参数和数据混合，不够清晰
    /*
    @ParameterizedTest
    @ValueSource(ints = {1, 2, 3, 4, 5})
    public void testUnclearParameterization(int value) {
        // 这个测试不够清晰，不知道每个值代表什么
        // 应该添加显示名称和有意义的断言消息
        assertTrue(value > 0);
    }
    */
    
    // 好的做法：针对特定场景的参数化测试
    @ParameterizedTest(name = "[{index}] {0} should be correctly identified as valid/invalid")
    @CsvSource({
        "user@example.com, true, Valid standard email",
        "user@sub.domain.com, true, Valid email with subdomain",
        "user@domain.co.uk, true, Valid email with multi-level TLD",
        "user.name@domain.com, true, Valid email with dot in local part",
        "invalid-email, false, Missing @ symbol",
        "@domain.com, false, Missing local part",
        "user@, false, Missing domain part"
    })
    public void testEmailValidationWithDescriptions(
            String email, boolean expected, String description) {
        boolean isValid = EmailValidator.isValid(email);
        assertEquals(expected, isValid, description + ": " + email);
    }
}
```

### 6.6.2 测试套件组织策略

1. **按层次组织**：按测试类型（单元、集成、端到端）组织套件
2. **按功能组织**：按应用程序功能模块组织套件
3. **按速度组织**：区分快速测试和慢速测试
4. **按环境组织**：区分不同环境（开发、测试、生产）的测试

```java
// 按测试类型组织的套件
@Suite
@SuiteDisplayName("All Test Types Suite")
@SelectClasses({
    UnitTestSuite.class,
    IntegrationTestSuite.class,
    EndToEndTestSuite.class
})
public class AllTestTypesSuite {
    // 包含所有类型的测试
}

// 快速测试套件（用于持续集成）
@Suite
@SuiteDisplayName("Fast Tests Suite")
@SelectPackages({
    "com.example.service",
    "com.example.util",
    "com.example.repository"
})
@ExcludeTags("slow", "integration")
public class FastTestsSuite {
    // 只运行快速测试，适合CI环境
}

// 慢速测试套件（夜间运行）
@Suite
@SuiteDisplayName("Slow Tests Suite")
@SelectClasses({
    PerformanceTest.class,
    LoadTest.class,
    EnduranceTest.class
})
@IncludeTags("slow", "performance")
public class SlowTestsSuite {
    // 只运行慢速测试，适合夜间运行
}

// 按功能模块组织的套件
@Suite
@SuiteDisplayName("User Management Module Tests")
@SelectPackages({
    "com.example.user.repository",
    "com.example.user.service",
    "com.example.user.controller"
})
public class UserManagementSuite {
    // 用户管理模块的所有测试
}

// 预发布测试套件
@Suite
@SuiteDisplayName("Pre-Release Test Suite")
@SelectClasses({
    CriticalPathTest.class,
    SmokeTest.class,
    RegressionTest.class
})
@ExcludeTags("flaky", "experimental")
public class PreReleaseTestSuite {
    // 发布前的关键测试
}
```

## 6.7 小结

本章深入讲解了参数化测试与测试套件的使用，主要内容包括：

1. **参数化测试概述**：什么是参数化测试及其应用场景
2. **JUnit 5参数化测试**：@ParameterizedTest和各种参数源的使用
3. **高级参数化测试**：动态测试、参数转换、显示名称
4. **测试套件**：@Suite注解和套件组织策略
5. **测试执行与报告**：运行测试和分析结果
6. **最佳实践**：设计原则和组织策略

掌握参数化测试和测试套件可以大大提高测试的效率和覆盖率。在下一章中，我们将学习测试驱动开发(TDD)实践，探索如何通过测试驱动代码设计。

## 6.8 实践练习

### 练习1：参数化测试实现
1. 为字符串处理类创建参数化测试
2. 使用不同的参数源（@ValueSource、@CsvSource、@MethodSource）
3. 添加有意义的显示名称和断言消息

### 练习2：自定义参数源
1. 创建自定义参数提供器
2. 实现参数转换器
3. 使用动态测试生成测试用例

### 练习3：测试套件组织
1. 创建分层测试套件结构
2. 使用标签和模式过滤测试
3. 设计不同场景的测试套件

通过这些练习，您将掌握参数化测试和测试套件的使用，能够编写高效、全面的测试代码。