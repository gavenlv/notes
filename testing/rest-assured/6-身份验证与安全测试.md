# 第6章：身份验证与安全测试

## 6.1 身份验证概述

### 6.1.1 常见认证机制

REST Assured支持多种HTTP认证机制，可以满足不同API的安全需求：

```java
// 基本认证 (Basic Authentication)
given()
    .auth().basic("username", "password")
.when()
    .get("/api/secure/data");

// 摘要认证 (Digest Authentication)
given()
    .auth().digest("username", "password")
.when()
    .get("/api/secure/data");

// OAuth 2.0 认证
given()
    .auth().oauth2("access_token")
.when()
    .get("/api/secure/data");

// 预认证 (Preemptive Authentication)
given()
    .auth().preemptive().basic("username", "password")
.when()
    .get("/api/secure/data");

// OAuth 1.0 认证
given()
    .auth().oauth("consumerKey", "consumerSecret", "accessToken", "tokenSecret")
.when()
    .get("/api/secure/data");

// Form认证
given()
    .auth().form("username", "password", FormAuthConfig.springSecurity())
.when()
    .get("/api/secure/data");
```

### 6.1.2 认证流程与策略

```java
// 多步骤认证流程
public class AuthenticationFlow {
    
    // 1. 获取认证令牌
    public static String getAuthToken(String username, String password) {
        return given()
            .contentType(ContentType.JSON)
            .body("{\"username\":\"" + username + "\",\"password\":\"" + password + "\"}")
        .when()
            .post("/auth/login")
        .then()
            .statusCode(200)
            .extract()
            .path("token");
    }
    
    // 2. 刷新认证令牌
    public static String refreshToken(String refreshToken) {
        return given()
            .contentType(ContentType.JSON)
            .body("{\"refreshToken\":\"" + refreshToken + "\"}")
        .when()
            .post("/auth/refresh")
        .then()
            .statusCode(200)
            .extract()
            .path("token");
    }
    
    // 3. 撤销认证令牌
    public static void revokeToken(String token) {
        given()
            .header("Authorization", "Bearer " + token)
        .when()
            .post("/auth/logout")
        .then()
            .statusCode(200);
    }
    
    // 4. 完整的认证流程测试
    @Test
    public void testCompleteAuthenticationFlow() {
        // 1. 登录获取令牌
        String token = getAuthToken("testuser", "testpass");
        assertNotNull(token, "Token should not be null");
        
        // 2. 使用令牌访问受保护资源
        given()
            .header("Authorization", "Bearer " + token)
        .when()
            .get("/api/profile")
        .then()
            .statusCode(200)
            .body("username", equalTo("testuser"));
        
        // 3. 获取刷新令牌
        String refreshToken = given()
            .header("Authorization", "Bearer " + token)
        .when()
            .get("/auth/token-info")
        .then()
            .statusCode(200)
            .extract()
            .path("refreshToken");
        
        // 4. 刷新令牌
        String newToken = refreshToken(refreshToken);
        assertNotNull(newToken, "New token should not be null");
        assertNotEquals(token, newToken, "New token should be different");
        
        // 5. 使用新令牌访问资源
        given()
            .header("Authorization", "Bearer " + newToken)
        .when()
            .get("/api/profile")
        .then()
            .statusCode(200)
            .body("username", equalTo("testuser"));
        
        // 6. 撤销令牌
        revokeToken(newToken);
        
        // 7. 验证令牌已撤销
        given()
            .header("Authorization", "Bearer " + newToken)
        .when()
            .get("/api/profile")
        .then()
            .statusCode(401);
    }
}
```

## 6.2 基本认证与表单认证

### 6.2.1 基本认证详解

```java
// 基本认证基础使用
@Test
public void testBasicAuthentication() {
    given()
        .auth().basic("admin", "password123")
    .when()
        .get("/api/admin/users")
    .then()
        .statusCode(200)
        .body("users", notNullValue())
        .body("users.size()", greaterThan(0));
}

// 基本认证与非预认证的区别
@Test
public void testBasicVsPreemptiveAuth() {
    // 非预认证（默认）：先发送无认证请求，收到401响应后再发送认证请求
    given()
        .auth().basic("user", "pass")
    .when()
        .get("/api/data")
    .then()
        .statusCode(200);
    
    // 预认证：在第一次请求就包含认证信息，避免额外的401响应
    given()
        .auth().preemptive().basic("user", "pass")
    .when()
        .get("/api/data")
    .then()
        .statusCode(200);
}

// 基本认证安全性测试
@Test
public void testBasicAuthSecurity() {
    // 测试无效凭证
    given()
        .auth().basic("invalid", "credentials")
    .when()
        .get("/api/secure")
    .then()
        .statusCode(401);
    
    // 测试空凭证
    given()
        .auth().basic("", "")
    .when()
        .get("/api/secure")
    .then()
        .statusCode(401);
    
    // 测试缺失认证
    given()
        .when()
        .get("/api/secure")
    .then()
        .statusCode(401);
}
```

### 6.2.2 表单认证详解

```java
// 标准表单认证
@Test
public void testFormAuthentication() {
    given()
        .auth().form("username", "password")
    .when()
        .get("/api/secure")
    .then()
        .statusCode(200);
}

// Spring Security表单认证
@Test
public void testSpringSecurityFormAuth() {
    given()
        .auth().form("username", "password", FormAuthConfig.springSecurity())
    .when()
        .get("/api/secure")
    .then()
        .statusCode(200);
}

// 自定义表单认证配置
@Test
public void testCustomFormAuthConfig() {
    FormAuthConfig formAuthConfig = new FormAuthConfig(
        "/custom/login",  // 自定义登录页面URL
        "username",       // 用户名字段名
        "password"        // 密码字段名
    );
    
    given()
        .auth().form("testuser", "testpass", formAuthConfig)
    .when()
        .get("/api/secure")
    .then()
        .statusCode(200);
}

// 表单认证与CSRF
@Test
public void testFormAuthWithCsrf() {
    // 1. 获取登录页面和CSRF令牌
    String csrfToken = given()
        .when()
        .get("/login")
    .then()
        .statusCode(200)
    .extract()
    .htmlPath()
    .getString("**.find { it.@name == '_csrf' }.@value");
    
    // 2. 提交登录表单包含CSRF令牌
    given()
        .formParam("username", "testuser")
        .formParam("password", "testpass")
        .formParam("_csrf", csrfToken)
        .header("X-Requested-With", "XMLHttpRequest")  // 可能需要的额外头
    .when()
        .post("/login")
    .then()
        .statusCode(302)  // 登录成功通常重定向
    
    // 3. 验证会话已建立
    given()
        .cookie("JSESSIONID")  // 验证会话Cookie存在
    .when()
        .get("/api/secure")
    .then()
        .statusCode(200);
}
```

## 6.3 OAuth认证详解

### 6.3.1 OAuth 2.0 认证流程

```java
// OAuth 2.0 客户端凭证流程
public class OAuth2ClientCredentialsFlow {
    
    private static final String CLIENT_ID = "test-client";
    private static final String CLIENT_SECRET = "test-secret";
    private static final String TOKEN_ENDPOINT = "/oauth/token";
    
    // 获取客户端凭证令牌
    public static String getClientCredentialsToken() {
        return given()
            .auth().basic(CLIENT_ID, CLIENT_SECRET)
            .contentType("application/x-www-form-urlencoded")
            .formParam("grant_type", "client_credentials")
        .when()
            .post(TOKEN_ENDPOINT)
        .then()
            .statusCode(200)
            .extract()
            .path("access_token");
    }
    
    // 使用令牌访问资源
    @Test
    public void testClientCredentialsFlow() {
        String token = getClientCredentialsToken();
        assertNotNull(token, "Access token should not be null");
        
        // 使用令牌访问受保护的资源
        given()
            .auth().oauth2(token)
        .when()
            .get("/api/client-data")
        .then()
            .statusCode(200)
            .body("data", notNullValue());
        
        // 也可以使用Bearer令牌头格式
        given()
            .header("Authorization", "Bearer " + token)
        .when()
            .get("/api/client-data")
        .then()
            .statusCode(200);
    }
}

// OAuth 2.0 授权码流程
public class OAuth2AuthorizationCodeFlow {
    
    @Test
    public void testAuthorizationCodeFlow() {
        String clientId = "test-client";
        String redirectUri = "https://example.com/callback";
        String state = "random-state-value";
        
        // 1. 构建授权请求URL（这通常需要用户交互）
        String authUrl = "/oauth/authorize?" +
            "response_type=code&" +
            "client_id=" + clientId + "&" +
            "redirect_uri=" + redirectUri + "&" +
            "scope=read&" +
            "state=" + state;
        
        // 在实际测试中，这里可能需要模拟用户授权过程
        // 假设我们已经获得了授权码
        
        String authorizationCode = "sample-auth-code";
        
        // 2. 使用授权码获取访问令牌
        Map<String, String> tokenRequest = new HashMap<>();
        tokenRequest.put("grant_type", "authorization_code");
        tokenRequest.put("code", authorizationCode);
        tokenRequest.put("redirect_uri", redirectUri);
        tokenRequest.put("client_id", clientId);
        
        String token = given()
            .contentType("application/x-www-form-urlencoded")
            .formParams(tokenRequest)
        .when()
            .post("/oauth/token")
        .then()
            .statusCode(200)
            .extract()
            .path("access_token");
        
        // 3. 使用访问令牌获取用户资源
        given()
            .auth().oauth2(token)
        .when()
            .get("/api/user/profile")
        .then()
            .statusCode(200)
            .body("user", notNullValue());
    }
}

// OAuth 2.0 刷新令牌
public class OAuth2TokenRefresh {
    
    @Test
    public void testTokenRefresh() {
        String clientId = "test-client";
        String clientSecret = "test-secret";
        String refreshToken = "sample-refresh-token";
        
        // 使用刷新令牌获取新的访问令牌
        String newAccessToken = given()
            .auth().basic(clientId, clientSecret)
            .contentType("application/x-www-form-urlencoded")
            .formParam("grant_type", "refresh_token")
            .formParam("refresh_token", refreshToken)
        .when()
            .post("/oauth/token")
        .then()
            .statusCode(200)
            .extract()
            .path("access_token");
        
        // 验证新令牌有效
        given()
            .auth().oauth2(newAccessToken)
        .when()
            .get("/api/secure")
        .then()
            .statusCode(200);
    }
}
```

### 6.3.2 OAuth 1.0 认证流程

```java
// OAuth 1.0 三脚架认证
public class OAuth1ThreeLeggedAuthentication {
    
    private static final String CONSUMER_KEY = "test-consumer-key";
    private static final String CONSUMER_SECRET = "test-consumer-secret";
    private static final String ACCESS_TOKEN = "test-access-token";
    private static final String TOKEN_SECRET = "test-token-secret";
    
    @Test
    public void testOAuth1Authentication() {
        given()
            .auth().oauth(CONSUMER_KEY, CONSUMER_SECRET, ACCESS_TOKEN, TOKEN_SECRET)
        .when()
            .get("/api/oauth1/protected")
        .then()
            .statusCode(200);
    }
    
    // 模拟OAuth 1.0 流程
    @Test
    public void testOAuth1Flow() {
        // 1. 获取请求令牌
        String requestToken = given()
            .auth().oauth(CONSUMER_KEY, CONSUMER_SECRET, "", "")
            .contentType("application/x-www-form-urlencoded")
        .when()
            .post("/oauth1/request_token")
        .then()
            .statusCode(200)
            .extract()
            .asString();
        
        // 解析请求令牌（简化版，实际需要更复杂的解析）
        String token = parseTokenFromResponse(requestToken);
        String tokenSecret = parseTokenSecretFromResponse(requestToken);
        
        // 2. 用户授权（这通常需要用户交互）
        // 在真实测试中可能需要模拟浏览器交互
        
        // 3. 使用请求令牌获取访问令牌
        String accessTokenResponse = given()
            .auth().oauth(CONSUMER_KEY, CONSUMER_SECRET, token, tokenSecret)
            .contentType("application/x-www-form-urlencoded")
        .when()
            .post("/oauth1/access_token")
        .then()
            .statusCode(200)
            .extract()
            .asString();
        
        // 解析访问令牌
        String accessToken = parseTokenFromResponse(accessTokenResponse);
        String accessTokenSecret = parseTokenSecretFromResponse(accessTokenResponse);
        
        // 4. 使用访问令牌访问受保护资源
        given()
            .auth().oauth(CONSUMER_KEY, CONSUMER_SECRET, accessToken, accessTokenSecret)
        .when()
            .get("/api/oauth1/protected")
        .then()
            .statusCode(200);
    }
}
```

## 6.4 API密钥与自定义认证

### 6.4.1 API密钥认证

```java
// API密钥作为查询参数
@Test
public void testApiKeyAsQueryParam() {
    given()
        .queryParam("api_key", "my-api-key-123")
    .when()
        .get("/api/data")
    .then()
        .statusCode(200);
}

// API密钥作为请求头
@Test
public void testApiKeyAsHeader() {
    given()
        .header("X-API-Key", "my-api-key-123")
        .header("X-API-Version", "1.0")
    .when()
        .get("/api/data")
    .then()
        .statusCode(200);
}

// API密钥与用户认证结合
@Test
public void testApiKeyWithUserAuth() {
    given()
        .header("X-API-Key", "my-api-key-123")
        .header("Authorization", "Bearer user-jwt-token")
    .when()
        .get("/api/protected-data")
    .then()
        .statusCode(200);
}

// API密钥有效性验证
@Test
public void testApiKeyValidation() {
    // 测试有效API密钥
    given()
        .header("X-API-Key", "valid-api-key")
    .when()
        .get("/api/data")
    .then()
        .statusCode(200);
    
    // 测试无效API密钥
    given()
        .header("X-API-Key", "invalid-api-key")
    .when()
        .get("/api/data")
    .then()
        .statusCode(401);
    
    // 测试缺失API密钥
    given()
        .when()
        .get("/api/data")
    .then()
        .statusCode(401);
}
```

### 6.4.2 自定义认证机制

```java
// 自定义签名认证
public class CustomSignatureAuth {
    
    @Test
    public void testCustomSignatureAuthentication() {
        String apiKey = "my-api-key";
        String apiSecret = "my-api-secret";
        
        // 生成签名的数据
        String timestamp = String.valueOf(System.currentTimeMillis());
        String nonce = UUID.randomUUID().toString();
        String method = "GET";
        String path = "/api/secure/data";
        
        // 生成签名（简化版）
        String message = method + "\n" + path + "\n" + timestamp + "\n" + nonce;
        String signature = generateHmacSha256Signature(message, apiSecret);
        
        given()
            .header("X-API-Key", apiKey)
            .header("X-Timestamp", timestamp)
            .header("X-Nonce", nonce)
            .header("X-Signature", signature)
        .when()
            .get(path)
        .then()
            .statusCode(200);
    }
    
    // HMAC SHA256签名生成
    private String generateHmacSha256Signature(String data, String secret) {
        try {
            Mac sha256_HMAC = Mac.getInstance("HmacSHA256");
            SecretKeySpec secret_key = new SecretKeySpec(secret.getBytes("UTF-8"), "HmacSHA256");
            sha256_HMAC.init(secret_key);
            
            byte[] signatureBytes = sha256_HMAC.doFinal(data.getBytes("UTF-8"));
            
            // 转换为十六进制字符串
            return bytesToHex(signatureBytes);
        } catch (Exception e) {
            throw new RuntimeException("Failed to generate signature", e);
        }
    }
    
    private String bytesToHex(byte[] bytes) {
        StringBuilder hexString = new StringBuilder();
        for (byte b : bytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }
        return hexString.toString();
    }
}

// JWT令牌认证
public class JwtAuthentication {
    
    @Test
    public void testJwtTokenAuthentication() {
        String jwtToken = generateValidJwtToken();
        
        given()
            .header("Authorization", "Bearer " + jwtToken)
        .when()
            .get("/api/jwt-protected")
        .then()
            .statusCode(200);
    }
    
    // 测试JWT令牌过期
    @Test
    public void testExpiredJwtToken() {
        String expiredToken = generateExpiredJwtToken();
        
        given()
            .header("Authorization", "Bearer " + expiredToken)
        .when()
            .get("/api/jwt-protected")
        .then()
            .statusCode(401)
            .body("error.message", containsString("token expired"));
    }
    
    // 测试无效JWT令牌
    @Test
    public void testInvalidJwtToken() {
        String invalidToken = "invalid.jwt.token";
        
        given()
            .header("Authorization", "Bearer " + invalidToken)
        .when()
            .get("/api/jwt-protected")
        .then()
            .statusCode(401)
            .body("error.message", containsString("invalid token"));
    }
    
    // 生成有效的JWT令牌（简化版，实际应使用JWT库）
    private String generateValidJwtToken() {
        // 在实际实现中，应使用如jjwt或auth0的java-jwt库
        // 这里只是一个示例
        return "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c";
    }
    
    private String generateExpiredJwtToken() {
        // 在实际实现中，应使用JWT库生成已过期令牌
        return "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiZXhwIjoxNTE2MjM5MDIyfQ.invalid-signature";
    }
}
```

## 6.5 安全测试技术

### 6.5.1 输入验证测试

```java
// SQL注入测试
public class SqlInjectionTests {
    
    @Test
    public void testSqlInjectionVulnerabilities() {
        // 测试基本SQL注入
        String maliciousInput = "admin' OR '1'='1";
        
        // 测试登录表单
        given()
            .contentType(ContentType.JSON)
            .body("{\"username\":\"" + maliciousInput + "\",\"password\":\"password\"}")
        .when()
            .post("/login")
        .then()
            .statusCode(401);  // 应该拒绝认证，不应该成功
            
        // 测试搜索功能
        given()
            .queryParam("q", maliciousInput)
        .when()
            .get("/api/search")
        .then()
            .statusCode(400);  // 应该返回错误，不应该返回所有结果
            
        // 测试ID参数
        given()
            .pathParam("id", maliciousInput)
        .when()
            .get("/api/users/{id}")
        .then()
            .statusCode(400);  // 应该返回错误
    }
    
    @Test
    public void testUnionBasedSqlInjection() {
        String unionInjection = "1 UNION SELECT username, password FROM users--";
        
        given()
            .pathParam("id", unionInjection)
        .when()
            .get("/api/products/{id}")
        .then()
            .statusCode(400);  // 应该拒绝
    }
    
    @Test
    public void testTimeBasedSqlInjection() {
        String timeInjection = "1' AND SLEEP(5)--";
        
        long startTime = System.currentTimeMillis();
        
        given()
            .pathParam("id", timeInjection)
        .when()
            .get("/api/users/{id}")
        .then()
            .statusCode(400);  // 应该拒绝，不应延迟
            
        long endTime = System.currentTimeMillis();
        
        // 验证响应时间不应显著延长
        assertTrue(endTime - startTime < 2000, 
            "Response should not be delayed by time-based injection");
    }
}

// XSS攻击测试
public class XssAttackTests {
    
    @Test
    public void testXssVulnerabilities() {
        // 测试反射型XSS
        String xssPayload = "<script>alert('XSS')</script>";
        
        // 测试搜索功能
        given()
            .queryParam("q", xssPayload)
        .when()
            .get("/api/search")
        .then()
            .statusCode(200)
            .body(not(containsString("<script>")));  // 响应不应包含原始脚本
            
        // 测试用户资料更新
        given()
            .contentType(ContentType.JSON)
            .body("{\"displayName\":\"" + xssPayload + "\"}")
        .when()
            .post("/api/profile")
        .then()
            .statusCode(400);  // 应该拒绝包含脚本的输入
            
        // 测试评论提交
        given()
            .contentType(ContentType.JSON)
            .body("{\"comment\":\"" + xssPayload + "\"}")
        .when()
            .post("/api/comments")
        .then()
            .statusCode(400);  // 应该拒绝
    }
    
    @Test
    public void testEncodedXssPayloads() {
        // 测试URL编码的XSS
        String encodedXss = "%3Cscript%3Ealert%28%27XSS%27%29%3C%2Fscript%3E";
        
        given()
            .queryParam("q", encodedXss)
        .when()
            .get("/api/search")
        .then()
            .statusCode(200)
            .body(not(containsString("<script>")));
            
        // 测试HTML实体编码的XSS
        String htmlEntityXss = "&lt;script&gt;alert('XSS')&lt;/script&gt;";
        
        given()
            .contentType(ContentType.JSON)
            .body("{\"comment\":\"" + htmlEntityXss + "\"}")
        .when()
            .post("/api/comments")
        .then()
            .statusCode(200)  // 可能接受编码后的内容
            .body(not(containsString("<script>")));  // 但显示时应该转义
    }
}
```

### 6.5.2 权限与访问控制测试

```java
// 角色基础访问控制测试
public class RoleBasedAccessControlTests {
    
    @Test
    public void testRoleBasedAccess() {
        String adminToken = authenticateAsAdmin();
        String userToken = authenticateAsUser();
        String guestToken = authenticateAsGuest();
        
        // 管理员功能测试
        given()
            .header("Authorization", "Bearer " + adminToken)
        .when()
            .get("/api/admin/users")
        .then()
            .statusCode(200);  // 管理员应该能够访问
            
        given()
            .header("Authorization", "Bearer " + userToken)
        .when()
            .get("/api/admin/users")
        .then()
            .statusCode(403);  // 普通用户应该被拒绝
            
        given()
            .header("Authorization", "Bearer " + guestToken)
        .when()
            .get("/api/admin/users")
        .then()
            .statusCode(401);  // 访客应该被拒绝
            
        // 用户功能测试
        given()
            .header("Authorization", "Bearer " + adminToken)
        .when()
            .get("/api/user/profile")
        .then()
            .statusCode(200);  // 管理员也应该能访问用户功能
            
        given()
            .header("Authorization", "Bearer " + userToken)
        .when()
            .get("/api/user/profile")
        .then()
            .statusCode(200);  // 用户应该能访问自己的功能
            
        given()
            .header("Authorization", "Bearer " + guestToken)
        .when()
            .get("/api/user/profile")
        .then()
            .statusCode(401);  // 访客应该被拒绝
    }
    
    @Test
    public void testDataLevelAccessControl() {
        String user1Token = authenticateAsUser("user1");
        String user2Token = authenticateAsUser("user2");
        
        // 测试用户只能访问自己的数据
        given()
            .header("Authorization", "Bearer " + user1Token)
        .when()
            .get("/api/orders")
        .then()
            .statusCode(200)
            .body("orders", not(hasItem(hasEntry("userId", 2))));  // 不应包含用户2的数据
            
        given()
            .header("Authorization", "Bearer " + user2Token)
        .when()
            .get("/api/orders")
        .then()
            .statusCode(200)
            .body("orders", not(hasItem(hasEntry("userId", 1))));  // 不应包含用户1的数据
            
        // 测试用户不能直接访问其他用户的数据
        given()
            .header("Authorization", "Bearer " + user1Token)
        .when()
            .get("/api/users/2/profile")  // 尝试访问用户2的资料
        .then()
            .statusCode(403);  // 应该被拒绝
    }
    
    @Test
    public void testResourceOwnership() {
        String userToken = authenticateAsUser();
        
        // 创建资源
        int resourceId = given()
            .header("Authorization", "Bearer " + userToken)
            .contentType(ContentType.JSON)
            .body("{\"title\":\"My Resource\", \"content\":\"Resource content\"}")
        .when()
            .post("/api/resources")
        .then()
            .statusCode(201)
            .extract()
            .path("id");
            
        // 验证可以访问自己的资源
        given()
            .header("Authorization", "Bearer " + userToken)
        .when()
            .get("/api/resources/" + resourceId)
        .then()
            .statusCode(200);
            
        // 获取另一个用户的令牌
        String anotherUserToken = authenticateAsUser("anotheruser");
        
        // 验证不能访问其他用户的资源
        given()
            .header("Authorization", "Bearer " + anotherUserToken)
        .when()
            .get("/api/resources/" + resourceId)
        .then()
            .statusCode(403);
            
        // 验证不能修改其他用户的资源
        given()
            .header("Authorization", "Bearer " + anotherUserToken)
            .contentType(ContentType.JSON)
            .body("{\"title\":\"Modified Title\"}")
        .when()
            .put("/api/resources/" + resourceId)
        .then()
            .statusCode(403);
            
        // 验证不能删除其他用户的资源
        given()
            .header("Authorization", "Bearer " + anotherUserToken)
        .when()
            .delete("/api/resources/" + resourceId)
        .then()
            .statusCode(403);
    }
}
```

### 6.5.3 认证绕过与安全漏洞测试

```java
// 认证绕过测试
public class AuthenticationBypassTests {
    
    @Test
    public void testAuthenticationBypassAttempts() {
        // 测试空认证头
        given()
            .header("Authorization", "")
        .when()
            .get("/api/secure")
        .then()
            .statusCode(401);
            
        // 测试无效认证头
        given()
            .header("Authorization", "Invalid token")
        .when()
            .get("/api/secure")
        .then()
            .statusCode(401);
            
        // 测试部分认证头
        given()
            .header("Authorization", "Bearer")
        .when()
            .get("/api/secure")
        .then()
            .statusCode(401);
            
        // 测试使用旧令牌
        given()
            .header("Authorization", "Bearer expired-token")
        .when()
            .get("/api/secure")
        .then()
            .statusCode(401);
    }
    
    @Test
    public void testTokenManipulation() {
        // 获取有效令牌
        String validToken = authenticateAsUser();
        
        // 尝试修改令牌
        String modifiedToken = validToken.substring(0, validToken.length() - 10) + "modified";
        
        given()
            .header("Authorization", "Bearer " + modifiedToken)
        .when()
            .get("/api/secure")
        .then()
            .statusCode(401);
            
        // 尝试伪造令牌
        String forgedToken = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkZvcmdlZCBVc2VyIiwiaWF0IjoxNTE2MjM5MDIyfQ.fake-signature";
        
        given()
            .header("Authorization", "Bearer " + forgedToken)
        .when()
            .get("/api/secure")
        .then()
            .statusCode(401);
    }
    
    @Test
    public void testSessionHijackingPrevention() {
        // 模拟登录获取会话
        String sessionId = loginAndGetSessionId("user", "password");
        
        // 验证会话有效
        given()
            .cookie("SESSIONID", sessionId)
        .when()
            .get("/api/secure")
        .then()
            .statusCode(200);
            
        // 登出会话
        logout(sessionId);
        
        // 验证会话已失效
        given()
            .cookie("SESSIONID", sessionId)
        .when()
            .get("/api/secure")
        .then()
            .statusCode(401);
            
        // 测试会话固定保护
        String initialSessionId = getInitialSessionId();
        String newSessionIdAfterLogin = loginAndReturnNewSessionId("user", "password", initialSessionId);
        
        // 验证登录后会话ID已改变（防止会话固定）
        assertNotEquals(initialSessionId, newSessionIdAfterLogin,
            "Session ID should change after login to prevent session fixation");
    }
}
```

## 6.6 安全头验证

### 6.6.1 HTTP安全头验证

```java
// 安全头验证测试
public class SecurityHeadersTests {
    
    @Test
    public void testSecurityHeaders() {
        given()
            .when()
            .get("/api/data")
        .then()
            .statusCode(200)
            
            // 验证X-Frame-Options头
            .header("X-Frame-Options", oneOf("DENY", "SAMEORIGIN"))
            
            // 验证X-Content-Type-Options头
            .header("X-Content-Type-Options", "nosniff")
            
            // 验证X-XSS-Protection头
            .header("X-XSS-Protection", oneOf("1; mode=block", "0"))
            
            // 验证Strict-Transport-Security头（HTTPS）
            .header("Strict-Transport-Security", containsString("max-age="))
            
            // 验证Content-Security-Policy头
            .header("Content-Security-Policy", containsString("default-src"))
            
            // 验证Referrer-Policy头
            .header("Referrer-Policy", notNullValue());
    }
    
    @Test
    public void testCORSHeaders() {
        // 测试预检请求
        given()
            .header("Origin", "https://example.com")
            .header("Access-Control-Request-Method", "POST")
            .header("Access-Control-Request-Headers", "Content-Type")
        .when()
            .options("/api/data")
        .then()
            .statusCode(200)
            
            // 验证CORS响应头
            .header("Access-Control-Allow-Origin", either(equalTo("https://example.com")).or(equalTo("*")))
            .header("Access-Control-Allow-Methods", containsString("POST"))
            .header("Access-Control-Allow-Headers", containsString("Content-Type"))
            .header("Access-Control-Max-Age", notNullValue());
            
        // 测试实际CORS请求
        given()
            .header("Origin", "https://example.com")
        .when()
            .post("/api/data")
        .then()
            .statusCode(201)
            .header("Access-Control-Allow-Origin", either(equalTo("https://example.com")).or(equalTo("*")));
    }
    
    @Test
    public void testNoSensitiveDataInHeaders() {
        given()
            .when()
            .get("/api/data")
        .then()
            .statusCode(200);
            
        // 验证响应头中不包含敏感信息
        Response response = given()
            .when()
            .get("/api/data")
            .then()
            .extract()
            .response();
            
        Headers headers = response.getHeaders();
        for (Header header : headers) {
            String headerName = header.getName();
            String headerValue = header.getValue();
            
            // 检查头部名称中不包含敏感词
            assertFalse(headerName.toLowerCase().contains("password"),
                "Header name should not contain sensitive information: " + headerName);
            assertFalse(headerName.toLowerCase().contains("token"),
                "Header name should not contain sensitive information: " + headerName);
            assertFalse(headerName.toLowerCase().contains("secret"),
                "Header name should not contain sensitive information: " + headerName);
                
            // 检查头部值中不包含敏感信息
            if (headerValue != null) {
                assertFalse(headerValue.toLowerCase().contains("password"),
                    "Header value should not contain sensitive information: " + headerValue);
                assertFalse(headerValue.toLowerCase().contains("token"),
                    "Header value should not contain sensitive information: " + headerValue);
                assertFalse(headerValue.toLowerCase().contains("secret"),
                    "Header value should not contain sensitive information: " + headerValue);
            }
        }
    }
}
```

## 6.7 加密与数据完整性

### 6.7.1 数据传输加密

```java
// HTTPS验证测试
public class HttpsTests {
    
    @Test
    public void testHttpsEnforcement() {
        // 尝试通过HTTP访问，应重定向到HTTPS或拒绝
        given()
            .relaxedHTTPSValidation()  // 仅用于测试，生产环境不应使用
        .when()
            .get("http://api.example.com/data")
        .then()
            .statusCode(anyOf(equalTo(301), equalTo(302), equalTo(403)));
            
        // 通过HTTPS访问应成功
        given()
            .relaxedHTTPSValidation()
        .when()
            .get("https://api.example.com/data")
        .then()
            .statusCode(200);
    }
    
    @Test
    public void testCertificateValidation() {
        // 配置信任的证书
        RestAssured.config = RestAssured.config()
            .sslConfig(new SSLConfig()
                .trustStore("/path/to/truststore.jks", "truststore-password")
                .keystore("/path/to/keystore.jks", "keystore-password"));
            
        // 使用有效证书访问
        given()
        .when()
            .get("https://api.example.com/data")
        .then()
            .statusCode(200);
            
        // 测试无效证书（如果有测试环境）
        // RestAssured.config = RestAssured.config()
        //    .sslConfig(new SSLConfig()
        //        .trustStore("/path/to/wrong-truststore.jks", "password"));
    }
}

// 数据完整性验证
public class DataIntegrityTests {
    
    @Test
    public void testDataIntegrityWithHash() {
        // 生成请求数据
        String requestData = "{\"name\":\"John\",\"email\":\"john@example.com\"}";
        String requestDataHash = calculateSHA256(requestData);
        
        // 发送带哈希的请求
        given()
            .contentType(ContentType.JSON)
            .header("X-Content-Hash", requestDataHash)
            .body(requestData)
        .when()
            .post("/api/users")
        .then()
            .statusCode(201);
            
        // 测试篡改的数据
        String tamperedData = "{\"name\":\"John\",\"email\":\"john@hacker.com\"}";
        String originalHash = requestDataHash;  // 使用原始数据的哈希
        
        given()
            .contentType(ContentType.JSON)
            .header("X-Content-Hash", originalHash)
            .body(tamperedData)
        .when()
            .post("/api/users")
        .then()
            .statusCode(400);  // 应该拒绝，因为哈希不匹配
    }
    
    @Test
    public void testResponseDataIntegrity() {
        Response response = given()
            .when()
            .get("/api/secure-data")
            .then()
            .statusCode(200)
            .extract()
            .response();
            
        String responseBody = response.getBody().asString();
        String responseHash = response.getHeader("X-Content-Hash");
        
        if (responseHash != null) {
            String calculatedHash = calculateSHA256(responseBody);
            
            // 验证响应数据完整性
            assertEquals(responseHash, calculatedHash,
                "Response hash should match calculated hash");
        }
    }
    
    private String calculateSHA256(String data) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hashBytes = digest.digest(data.getBytes("UTF-8"));
            
            StringBuilder hexString = new StringBuilder();
            for (byte b : hashBytes) {
                String hex = Integer.toHexString(0xff & b);
                if (hex.length() == 1) {
                    hexString.append('0');
                }
                hexString.append(hex);
            }
            
            return hexString.toString();
        } catch (Exception e) {
            throw new RuntimeException("Failed to calculate SHA-256", e);
        }
    }
}
```

## 6.8 实践练习

### 练习1：多因素认证测试

实现一个测试，验证以下多因素认证流程：
1. 用户名/密码认证
2. 发送验证码到用户设备
3. 验证码验证
4. 获取最终访问令牌

### 练习2：权限验证矩阵

创建一个测试套件，验证不同角色对各种资源的访问权限，包括：
- 管理员权限
- 普通用户权限
- 访客权限
- 数据级访问控制

### 练习3：安全漏洞测试

实现测试验证以下安全漏洞防护：
- SQL注入防护
- XSS攻击防护
- 认证绕过防护
- 会话固定防护

## 6.9 总结

本章深入探讨了REST Assured中的身份验证与安全测试技术，包括：

1. **身份验证概述** - 了解各种常见认证机制及其特点
2. **基本认证与表单认证** - 掌握基础认证方法的实现和测试
3. **OAuth认证详解** - 学习OAuth 1.0和OAuth 2.0的完整流程
4. **API密钥与自定义认证** - 掌握API密钥和自定义认证机制的实现
5. **安全测试技术** - 学习输入验证、权限控制和访问控制测试
6. **安全头验证** - 了解HTTP安全头和CORS头的验证方法
7. **加密与数据完整性** - 掌握HTTPS验证和数据完整性检查

通过本章的学习，您应该能够设计和实现全面的API安全测试，包括各种认证机制测试、安全漏洞检测和安全性验证。在下一章中，我们将学习测试框架设计与组织的方法。