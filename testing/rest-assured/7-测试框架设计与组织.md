# 第7章：测试框架设计与组织

## 7.1 测试框架设计原则

### 7.1.1 设计原则概述

构建一个可维护、可扩展的REST Assured测试框架需要遵循以下核心原则：

```java
/**
 * 测试框架设计原则示例
 */
public class TestFrameworkPrinciples {
    
    // 1. 单一职责原则 - 每个类负责一个特定功能
    public class ApiRequestBuilder {
        public RequestSpecification buildUserRequest(String userId) {
            return given()
                .pathParam("userId", userId)
                .header("Accept", "application/json");
        }
    }
    
    public class ApiResponseValidator {
        public void validateUserResponse(Response response) {
            response.then()
                .statusCode(200)
                .contentType(ContentType.JSON)
                .body("id", notNullValue())
                .body("name", notNullValue());
        }
    }
    
    // 2. 开闭原则 - 对扩展开放，对修改关闭
    public abstract class BaseApiTest {
        protected RequestSpecification baseRequest() {
            return given()
                .baseUri(getApiBaseUrl())
                .contentType(ContentType.JSON)
                .header("Accept", "application/json");
        }
        
        protected abstract String getApiBaseUrl();
    }
    
    public class UserApiTest extends BaseApiTest {
        @Override
        protected String getApiBaseUrl() {
            return "https://api.example.com/users";
        }
    }
    
    // 3. 依赖倒置原则 - 依赖抽象而非具体实现
    public interface AuthenticationService {
        String authenticate(String username, String password);
        void logout(String token);
    }
    
    public class AuthenticationServiceTest {
        private AuthenticationService authService; // 依赖抽象
        
        @Test
        public void testAuthentication() {
            String token = authService.authenticate("user", "pass");
            assertNotNull(token);
        }
    }
}
```

### 7.1.2 分层架构设计

```java
/**
 * 分层架构测试框架示例
 */
public class LayeredTestFramework {
    
    // 1. 数据层 - 负责测试数据管理
    public class TestDataManager {
        public User createTestUser() {
            return User.builder()
                .name("Test User")
                .email("test@example.com")
                .password("password123")
                .build();
        }
        
        public Product createTestProduct() {
            return Product.builder()
                .name("Test Product")
                .price(99.99)
                .category("electronics")
                .build();
        }
    }
    
    // 2. 业务逻辑层 - 负责测试业务流程
    public class UserTestService {
        private TestDataManager dataManager;
        private UserApiClient apiClient;
        
        public UserTestService(TestDataManager dataManager, UserApiClient apiClient) {
            this.dataManager = dataManager;
            this.apiClient = apiClient;
        }
        
        public User createAndVerifyUser() {
            // 创建测试用户数据
            User testUser = dataManager.createTestUser();
            
            // 调用API创建用户
            User createdUser = apiClient.createUser(testUser);
            
            // 验证用户创建成功
            assertNotNull(createdUser.getId());
            assertEquals(testUser.getName(), createdUser.getName());
            
            return createdUser;
        }
    }
    
    // 3. API客户端层 - 封装API调用
    public class UserApiClient {
        private RequestSpecification requestSpec;
        
        public UserApiClient(RequestSpecification requestSpec) {
            this.requestSpec = requestSpec;
        }
        
        public User createUser(User user) {
            return requestSpec
                .body(user)
            .when()
                .post("/users")
            .then()
                .statusCode(201)
                .extract()
                .as(User.class);
        }
        
        public User getUser(int userId) {
            return requestSpec
                .pathParam("userId", userId)
            .when()
                .get("/users/{userId}")
            .then()
                .statusCode(200)
                .extract()
                .as(User.class);
        }
    }
    
    // 4. 测试执行层 - 组织和执行测试
    public class UserApiTests {
        private UserTestService userTestService;
        
        @Before
        public void setup() {
            TestDataManager dataManager = new TestDataManager();
            RequestSpecification requestSpec = given()
                .baseUri("https://api.example.com")
                .contentType(ContentType.JSON);
            UserApiClient apiClient = new UserApiClient(requestSpec);
            userTestService = new UserTestService(dataManager, apiClient);
        }
        
        @Test
        public void testCreateUser() {
            User user = userTestService.createAndVerifyUser();
            assertNotNull(user.getId());
        }
    }
}
```

## 7.2 测试数据管理

### 7.2.1 测试数据生成策略

```java
/**
 * 测试数据生成策略
 */
public class TestDataGeneration {
    
    // 1. 固定测试数据 - 适用于已知场景
    public class FixedTestData {
        public static User getAdminUser() {
            return User.builder()
                .id(1)
                .name("Admin User")
                .email("admin@example.com")
                .role("admin")
                .build();
        }
        
        public static User getRegularUser() {
            return User.builder()
                .id(2)
                .name("Regular User")
                .email("user@example.com")
                .role("user")
                .build();
        }
        
        public static Product getSampleProduct() {
            return Product.builder()
                .id(101)
                .name("Sample Product")
                .price(29.99)
                .category("electronics")
                .description("A sample electronic product")
                .build();
        }
    }
    
    // 2. 随机测试数据 - 适用于多样性和边界测试
    public class RandomTestData {
        private static Random random = new Random();
        
        public static User getRandomUser() {
            String[] firstNames = {"John", "Jane", "Mike", "Sarah", "David", "Lisa"};
            String[] lastNames = {"Smith", "Johnson", "Williams", "Brown", "Jones", "Garcia"};
            String[] domains = {"example.com", "test.org", "demo.net"};
            
            String firstName = firstNames[random.nextInt(firstNames.length)];
            String lastName = lastNames[random.nextInt(lastNames.length)];
            String domain = domains[random.nextInt(domains.length)];
            
            return User.builder()
                .name(firstName + " " + lastName)
                .email(firstName.toLowerCase() + "." + lastName.toLowerCase() + "@" + domain)
                .age(18 + random.nextInt(50))  // 18-67 years
                .active(random.nextBoolean())
                .build();
        }
        
        public static Product getRandomProduct() {
            String[] categories = {"electronics", "clothing", "books", "home", "sports"};
            String[] adjectives = {"Super", "Premium", "Deluxe", "Eco", "Smart"};
            String[] products = {"Phone", "Shirt", "Book", "Chair", "Ball"};
            
            String category = categories[random.nextInt(categories.length)];
            String adjective = adjectives[random.nextInt(adjectives.length)];
            String product = products[random.nextInt(products.length)];
            
            return Product.builder()
                .name(adjective + " " + product)
                .price(10.0 + random.nextDouble() * 990.0)  // 10-1000
                .category(category)
                .inStock(random.nextBoolean())
                .rating(1.0 + random.nextDouble() * 4.0)  // 1.0-5.0
                .build();
        }
    }
    
    // 3. 边界值测试数据
    public class BoundaryTestData {
        public static User getUserWithMinBoundaryValues() {
            return User.builder()
                .name("A")  // 最小长度姓名
                .age(18)   // 最小年龄
                .email("a@b.c")  // 最小有效邮箱
                .build();
        }
        
        public static User getUserWithMaxBoundaryValues() {
            String longName = "A".repeat(100);  // 假设最大长度为100
            return User.builder()
                .name(longName)
                .age(99)   // 最大年龄
                .email("very.long.email.address@example.com")
                .build();
        }
        
        public static User getUserWithInvalidBoundaryValues() {
            return User.builder()
                .name("")   // 空名称
                .age(17)    // 低于最小年龄
                .email("invalid-email")  // 无效邮箱
                .build();
        }
    }
    
    // 4. 数据工厂模式
    public class TestDataFactory {
        public static class UserBuilder {
            private String name = "Default User";
            private String email = "default@example.com";
            private int age = 25;
            private boolean active = true;
            private String role = "user";
            
            public UserBuilder withName(String name) {
                this.name = name;
                return this;
            }
            
            public UserBuilder withEmail(String email) {
                this.email = email;
                return this;
            }
            
            public UserBuilder withAge(int age) {
                this.age = age;
                return this;
            }
            
            public UserBuilder withActiveStatus(boolean active) {
                this.active = active;
                return this;
            }
            
            public UserBuilder withRole(String role) {
                this.role = role;
                return this;
            }
            
            public User build() {
                return User.builder()
                    .name(name)
                    .email(email)
                    .age(age)
                    .active(active)
                    .role(role)
                    .build();
            }
        }
        
        public static UserBuilder aUser() {
            return new UserBuilder();
        }
        
        public static class ProductBuilder {
            private String name = "Default Product";
            private double price = 10.0;
            private String category = "general";
            private boolean inStock = true;
            private double rating = 4.0;
            
            public ProductBuilder withName(String name) {
                this.name = name;
                return this;
            }
            
            public ProductBuilder withPrice(double price) {
                this.price = price;
                return this;
            }
            
            public ProductBuilder withCategory(String category) {
                this.category = category;
                return this;
            }
            
            public ProductBuilder withStockStatus(boolean inStock) {
                this.inStock = inStock;
                return this;
            }
            
            public ProductBuilder withRating(double rating) {
                this.rating = rating;
                return this;
            }
            
            public Product build() {
                return Product.builder()
                    .name(name)
                    .price(price)
                    .category(category)
                    .inStock(inStock)
                    .rating(rating)
                    .build();
            }
        }
        
        public static ProductBuilder aProduct() {
            return new ProductBuilder();
        }
    }
}
```

### 7.2.2 测试数据生命周期管理

```java
/**
 * 测试数据生命周期管理
 */
public class TestDataLifecycle {
    
    // 1. 测试前数据准备
    @BeforeClass
    public static void setupTestData() {
        // 创建测试数据库或环境
        setupTestDatabase();
        
        // 准备通用测试数据
        prepareCommonTestData();
        
        // 重置测试状态
        resetTestEnvironment();
    }
    
    @Before
    public void setupTestSpecificData() {
        // 准备当前测试特定数据
        createTestUser();
        createTestProducts();
    }
    
    // 2. 测试后数据清理
    @After
    public void cleanupTestData() {
        // 清理当前测试创建的数据
        deleteTestData();
        
        // 验证测试环境状态
        verifyTestEnvironmentState();
    }
    
    @AfterClass
    public static void cleanupTestEnvironment() {
        // 清理所有测试数据
        cleanupAllTestData();
        
        // 关闭测试环境
        shutdownTestEnvironment();
    }
    
    // 3. 数据隔离策略
    public class DataIsolationStrategy {
        // 每个测试使用独立的数据集
        @Test
        public void testWithIsolatedData() {
            // 创建独立测试数据
            String uniqueId = UUID.randomUUID().toString();
            User testUser = TestDataFactory.aUser()
                .withName("Test User " + uniqueId)
                .withEmail("test." + uniqueId + "@example.com")
                .build();
            
            // 执行测试
            User createdUser = userApiClient.createUser(testUser);
            
            // 验证结果
            assertEquals(testUser.getName(), createdUser.getName());
            assertEquals(testUser.getEmail(), createdUser.getEmail());
        }
        
        // 使用事务回滚
        @Test
        @Transactional
        public void testWithTransactionRollback() {
            // 在事务中创建数据
            User testUser = TestDataFactory.aUser().build();
            User createdUser = userApiClient.createUser(testUser);
            
            // 测试逻辑
            assertNotNull(createdUser.getId());
            
            // 测试结束后事务自动回滚，数据不会持久化
        }
    }
    
    // 4. 测试数据存储和检索
    public class TestDataRepository {
        private Map<String, Object> testData = new HashMap<>();
        
        public void store(String key, Object value) {
            testData.put(key, value);
        }
        
        @SuppressWarnings("unchecked")
        public <T> T retrieve(String key, Class<T> type) {
            return (T) testData.get(key);
        }
        
        public User getStoredUser() {
            return retrieve("user", User.class);
        }
        
        public Product getStoredProduct() {
            return retrieve("product", Product.class);
        }
        
        public String getStoredToken() {
            return retrieve("token", String.class);
        }
    }
    
    // 使用示例
    @Test
    public void testWithTestDataRepository() {
        TestDataRepository dataRepo = new TestDataRepository();
        
        // 创建并存储测试数据
        User testUser = TestDataFactory.aUser().build();
        dataRepo.store("user", testUser);
        
        // 调用API
        User createdUser = userApiClient.createUser(testUser);
        dataRepo.store("createdUser", createdUser);
        
        // 在后续步骤中使用存储的数据
        User storedUser = dataRepo.getStoredUser();
        User storedCreatedUser = dataRepo.retrieve("createdUser", User.class);
        
        assertEquals(storedUser.getName(), storedCreatedUser.getName());
    }
}
```

## 7.3 页面对象模式在API测试中的应用

### 7.3.1 API页面对象基础

```java
/**
 * API页面对象模式示例
 */
public class ApiPageObjects {
    
    // 1. 基础API页面对象
    public abstract class BaseApiPage {
        protected RequestSpecification requestSpec;
        protected TestDataRepository dataRepository;
        
        public BaseApiPage(RequestSpecification requestSpec, TestDataRepository dataRepository) {
            this.requestSpec = requestSpec;
            this.dataRepository = dataRepository;
        }
        
        // 通用API调用方法
        protected Response get(String endpoint) {
            return requestSpec.when().get(endpoint);
        }
        
        protected Response post(String endpoint, Object body) {
            return requestSpec.body(body).when().post(endpoint);
        }
        
        protected Response put(String endpoint, Object body) {
            return requestSpec.body(body).when().put(endpoint);
        }
        
        protected Response delete(String endpoint) {
            return requestSpec.when().delete(endpoint);
        }
        
        // 通用验证方法
        protected void validateSuccessResponse(Response response) {
            response.then()
                .statusCode(anyOf(equalTo(200), equalTo(201)))
                .contentType(ContentType.JSON);
        }
        
        protected void validateErrorResponse(Response response, int expectedStatusCode) {
            response.then()
                .statusCode(expectedStatusCode)
                .contentType(ContentType.JSON)
                .body("error", notNullValue());
        }
    }
    
    // 2. 用户API页面对象
    public class UserApiPage extends BaseApiPage {
        public UserApiPage(RequestSpecification requestSpec, TestDataRepository dataRepository) {
            super(requestSpec, dataRepository);
        }
        
        public User createUser(User user) {
            Response response = post("/users", user);
            validateSuccessResponse(response);
            
            User createdUser = response.as(User.class);
            dataRepository.store("user", createdUser);
            
            return createdUser;
        }
        
        public User getUser(int userId) {
            Response response = get("/users/" + userId);
            validateSuccessResponse(response);
            
            return response.as(User.class);
        }
        
        public List<User> getUsers() {
            Response response = get("/users");
            validateSuccessResponse(response);
            
            return response.jsonPath().getList("users", User.class);
        }
        
        public User updateUser(int userId, User user) {
            Response response = put("/users/" + userId, user);
            validateSuccessResponse(response);
            
            return response.as(User.class);
        }
        
        public void deleteUser(int userId) {
            Response response = delete("/users/" + userId);
            validateSuccessResponse(response);
        }
        
        public User getStoredUser() {
            return dataRepository.getStoredUser();
        }
    }
    
    // 3. 产品API页面对象
    public class ProductApiPage extends BaseApiPage {
        public ProductApiPage(RequestSpecification requestSpec, TestDataRepository dataRepository) {
            super(requestSpec, dataRepository);
        }
        
        public Product createProduct(Product product) {
            Response response = post("/products", product);
            validateSuccessResponse(response);
            
            Product createdProduct = response.as(Product.class);
            dataRepository.store("product", createdProduct);
            
            return createdProduct;
        }
        
        public Product getProduct(int productId) {
            Response response = get("/products/" + productId);
            validateSuccessResponse(response);
            
            return response.as(Product.class);
        }
        
        public List<Product> getProducts(String category) {
            String endpoint = "/products";
            if (category != null && !category.isEmpty()) {
                endpoint += "?category=" + category;
            }
            
            Response response = get(endpoint);
            validateSuccessResponse(response);
            
            return response.jsonPath().getList("products", Product.class);
        }
        
        public Product updateProduct(int productId, Product product) {
            Response response = put("/products/" + productId, product);
            validateSuccessResponse(response);
            
            return response.as(Product.class);
        }
        
        public void deleteProduct(int productId) {
            Response response = delete("/products/" + productId);
            validateSuccessResponse(response);
        }
        
        public Product getStoredProduct() {
            return dataRepository.getStoredProduct();
        }
    }
    
    // 4. 认证API页面对象
    public class AuthenticationApiPage extends BaseApiPage {
        public AuthenticationApiPage(RequestSpecification requestSpec, TestDataRepository dataRepository) {
            super(requestSpec, dataRepository);
        }
        
        public String login(String username, String password) {
            LoginRequest loginRequest = new LoginRequest(username, password);
            Response response = post("/auth/login", loginRequest);
            validateSuccessResponse(response);
            
            String token = response.jsonPath().getString("token");
            dataRepository.store("token", token);
            
            return token;
        }
        
        public void logout(String token) {
            Response response = requestSpec
                .header("Authorization", "Bearer " + token)
            .when()
                .post("/auth/logout");
            
            validateSuccessResponse(response);
        }
        
        public String refreshToken(String refreshToken) {
            RefreshTokenRequest request = new RefreshTokenRequest(refreshToken);
            Response response = post("/auth/refresh", request);
            validateSuccessResponse(response);
            
            String newToken = response.jsonPath().getString("token");
            dataRepository.store("token", newToken);
            
            return newToken;
        }
        
        public String getStoredToken() {
            return dataRepository.getStoredToken();
        }
    }
}
```

### 7.3.2 复杂业务流程页面对象

```java
/**
 * 复杂业务流程页面对象
 */
public class BusinessFlowPageObjects {
    
    // 1. 订单管理页面对象
    public class OrderManagementPage extends BaseApiPage {
        private UserApiPage userApi;
        private ProductApiPage productApi;
        
        public OrderManagementPage(RequestSpecification requestSpec, TestDataRepository dataRepository,
                                 UserApiPage userApi, ProductApiPage productApi) {
            super(requestSpec, dataRepository);
            this.userApi = userApi;
            this.productApi = productApi;
        }
        
        public Order createOrder(int userId, List<OrderItem> items) {
            // 验证用户存在
            User user = userApi.getUser(userId);
            assertNotNull(user, "User should exist");
            
            // 验证所有产品存在并有库存
            for (OrderItem item : items) {
                Product product = productApi.getProduct(item.getProductId());
                assertNotNull(product, "Product should exist");
                assertTrue(product.isInStock(), "Product should be in stock");
                assertTrue(product.getStockQuantity() >= item.getQuantity(), 
                    "Insufficient stock for product: " + product.getName());
            }
            
            // 创建订单
            OrderRequest orderRequest = new OrderRequest(userId, items);
            Response response = post("/orders", orderRequest);
            validateSuccessResponse(response);
            
            Order createdOrder = response.as(Order.class);
            dataRepository.store("order", createdOrder);
            
            return createdOrder;
        }
        
        public Order getOrder(int orderId) {
            Response response = get("/orders/" + orderId);
            validateSuccessResponse(response);
            
            return response.as(Order.class);
        }
        
        public Order updateOrderStatus(int orderId, String status) {
            OrderStatusUpdateRequest request = new OrderStatusUpdateRequest(status);
            Response response = put("/orders/" + orderId + "/status", request);
            validateSuccessResponse(response);
            
            return response.as(Order.class);
        }
        
        public void cancelOrder(int orderId) {
            Response response = delete("/orders/" + orderId);
            validateSuccessResponse(response);
        }
        
        public Order getStoredOrder() {
            return dataRepository.retrieve("order", Order.class);
        }
    }
    
    // 2. 购物车管理页面对象
    public class ShoppingCartPage extends BaseApiPage {
        private ProductApiPage productApi;
        
        public ShoppingCartPage(RequestSpecification requestSpec, TestDataRepository dataRepository,
                              ProductApiPage productApi) {
            super(requestSpec, dataRepository);
            this.productApi = productApi;
        }
        
        public Cart getCart(int userId) {
            Response response = get("/users/" + userId + "/cart");
            validateSuccessResponse(response);
            
            return response.as(Cart.class);
        }
        
        public Cart addToCart(int userId, int productId, int quantity) {
            // 验证产品存在
            Product product = productApi.getProduct(productId);
            assertNotNull(product, "Product should exist");
            assertTrue(product.isInStock(), "Product should be in stock");
            assertTrue(product.getStockQuantity() >= quantity, 
                "Insufficient stock for product: " + product.getName());
            
            // 添加到购物车
            CartItemRequest itemRequest = new CartItemRequest(productId, quantity);
            Response response = post("/users/" + userId + "/cart/items", itemRequest);
            validateSuccessResponse(response);
            
            return response.as(Cart.class);
        }
        
        public Cart updateCartItem(int userId, int itemId, int quantity) {
            CartItemRequest itemRequest = new CartItemRequest(quantity);
            Response response = put("/users/" + userId + "/cart/items/" + itemId, itemRequest);
            validateSuccessResponse(response);
            
            return response.as(Cart.class);
        }
        
        public Cart removeFromCart(int userId, int itemId) {
            Response response = delete("/users/" + userId + "/cart/items/" + itemId);
            validateSuccessResponse(response);
            
            return response.as(Cart.class);
        }
        
        public Cart clearCart(int userId) {
            Response response = delete("/users/" + userId + "/cart");
            validateSuccessResponse(response);
            
            return response.as(Cart.class);
        }
        
        public Order checkout(int userId, CheckoutRequest checkoutRequest) {
            Response response = post("/users/" + userId + "/checkout", checkoutRequest);
            validateSuccessResponse(response);
            
            Order order = response.as(Order.class);
            dataRepository.store("order", order);
            
            return order;
        }
    }
    
    // 3. 综合业务流程页面对象
    public class EcommerceBusinessFlowPage extends BaseApiPage {
        private AuthenticationApiPage authApi;
        private UserApiPage userApi;
        private ProductApiPage productApi;
        private ShoppingCartPage cartApi;
        private OrderManagementPage orderApi;
        
        public EcommerceBusinessFlowPage(RequestSpecification requestSpec, TestDataRepository dataRepository,
                                       AuthenticationApiPage authApi, UserApiPage userApi,
                                       ProductApiPage productApi, ShoppingCartPage cartApi,
                                       OrderManagementPage orderApi) {
            super(requestSpec, dataRepository);
            this.authApi = authApi;
            this.userApi = userApi;
            this.productApi = productApi;
            this.cartApi = cartApi;
            this.orderApi = orderApi;
        }
        
        // 完整的购物流程：注册 -> 登录 -> 浏览产品 -> 添加到购物车 -> 结账
        public Order performCompleteShoppingFlow() {
            // 1. 创建用户
            User newUser = TestDataFactory.aUser()
                .withName("Test Shopper")
                .withEmail("shopper@example.com")
                .build();
            User createdUser = userApi.createUser(newUser);
            
            // 2. 用户登录
            String token = authApi.login(newUser.getEmail(), newUser.getPassword());
            
            // 3. 设置认证后的请求规范
            RequestSpecification authenticatedRequest = requestSpec
                .header("Authorization", "Bearer " + token);
            
            // 4. 浏览产品
            List<Product> products = productApi.getProducts("electronics");
            assertFalse(products.isEmpty(), "Should have electronics products");
            
            // 5. 添加到购物车
            Product selectedProduct = products.get(0);
            Cart cart = cartApi.addToCart(createdUser.getId(), selectedProduct.getId(), 1);
            assertEquals(1, cart.getItems().size(), "Cart should have 1 item");
            
            // 6. 结账
            CheckoutRequest checkoutRequest = new CheckoutRequest(
                cart.getShippingAddress(), 
                cart.getPaymentMethod()
            );
            Order order = new EcommerceBusinessFlowPage(authenticatedRequest, dataRepository,
                authApi, userApi, productApi, cartApi, orderApi)
                .checkout(createdUser.getId(), checkoutRequest);
            
            assertNotNull(order, "Order should be created");
            
            return order;
        }
    }
}
```

## 7.4 测试报告与日志

### 7.4.1 自定义测试报告

```java
/**
 * 自定义测试报告
 */
public class CustomTestReports {
    
    // 1. 测试结果收集器
    public class TestResultCollector {
        private List<TestResult> results = new ArrayList<>();
        
        public void addTestResult(String testName, boolean passed, long duration, String errorMessage) {
            results.add(new TestResult(testName, passed, duration, errorMessage));
        }
        
        public void addTestResult(String testName, boolean passed, long duration) {
            addTestResult(testName, passed, duration, null);
        }
        
        public List<TestResult> getResults() {
            return Collections.unmodifiableList(results);
        }
        
        public TestSummary getSummary() {
            int total = results.size();
            long passed = results.stream().mapToLong(r -> r.isPassed() ? 1 : 0).sum();
            long failed = total - passed;
            long totalTime = results.stream().mapToLong(TestResult::getDuration).sum();
            
            return new TestSummary(total, passed, failed, totalTime);
        }
    }
    
    // 2. 测试结果数据结构
    public class TestResult {
        private String testName;
        private boolean passed;
        private long duration;
        private String errorMessage;
        private Date timestamp;
        
        public TestResult(String testName, boolean passed, long duration, String errorMessage) {
            this.testName = testName;
            this.passed = passed;
            this.duration = duration;
            this.errorMessage = errorMessage;
            this.timestamp = new Date();
        }
        
        // Getters and setters
        public String getTestName() { return testName; }
        public boolean isPassed() { return passed; }
        public long getDuration() { return duration; }
        public String getErrorMessage() { return errorMessage; }
        public Date getTimestamp() { return timestamp; }
    }
    
    // 3. HTML报告生成器
    public class HtmlReportGenerator {
        public void generateReport(List<TestResult> results, String outputPath) throws IOException {
            String htmlContent = generateHtmlContent(results);
            
            try (FileWriter writer = new FileWriter(outputPath)) {
                writer.write(htmlContent);
            }
        }
        
        private String generateHtmlContent(List<TestResult> results) {
            StringBuilder html = new StringBuilder();
            
            // HTML头部
            html.append("<!DOCTYPE html>\n")
                .append("<html>\n")
                .append("<head>\n")
                .append("    <title>REST Assured Test Report</title>\n")
                .append("    <style>\n")
                .append(getReportStyles())
                .append("    </style>\n")
                .append("    <script>\n")
                .append(getReportScripts())
                .append("    </script>\n")
                .append("</head>\n")
                .append("<body>\n");
            
            // 报告标题和摘要
            TestSummary summary = new TestSummary(
                results.size(),
                (int) results.stream().filter(TestResult::isPassed).count(),
                (int) results.stream().filter(r -> !r.isPassed()).count(),
                results.stream().mapToLong(TestResult::getDuration).sum()
            );
            
            html.append("    <div class=\"header\">\n")
                .append("        <h1>REST Assured API Test Report</h1>\n")
                .append("        <div class=\"summary\">\n")
                .append("            <div class=\"summary-item total\">Total: ").append(summary.getTotal()).append("</div>\n")
                .append("            <div class=\"summary-item passed\">Passed: ").append(summary.getPassed()).append("</div>\n")
                .append("            <div class=\"summary-item failed\">Failed: ").append(summary.getFailed()).append("</div>\n")
                .append("            <div class=\"summary-item duration\">Duration: ").append(formatDuration(summary.getTotalTime())).append("</div>\n")
                .append("        </div>\n")
                .append("        <div class=\"timestamp\">Generated on: ").append(new Date()).append("</div>\n")
                .append("    </div>\n");
            
            // 测试结果表格
            html.append("    <div class=\"content\">\n")
                .append("        <table>\n")
                .append("            <thead>\n")
                .append("                <tr>\n")
                .append("                    <th>Test Name</th>\n")
                .append("                    <th>Status</th>\n")
                .append("                    <th>Duration</th>\n")
                .append("                    <th>Error Message</th>\n")
                .append("                </tr>\n")
                .append("            </thead>\n")
                .append("            <tbody>\n");
            
            for (TestResult result : results) {
                html.append("                <tr class=\"").append(result.isPassed() ? "passed" : "failed").append("\">\n")
                    .append("                    <td>").append(result.getTestName()).append("</td>\n")
                    .append("                    <td>").append(result.isPassed() ? "Passed" : "Failed").append("</td>\n")
                    .append("                    <td>").append(formatDuration(result.getDuration())).append("</td>\n")
                    .append("                    <td>").append(result.getErrorMessage() != null ? result.getErrorMessage() : "").append("</td>\n")
                    .append("                </tr>\n");
            }
            
            html.append("            </tbody>\n")
                .append("        </table>\n")
                .append("    </div>\n")
                .append("</body>\n")
                .append("</html>");
            
            return html.toString();
        }
        
        private String getReportStyles() {
            return "body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }\n" +
                   ".header { margin-bottom: 20px; }\n" +
                   ".summary { display: flex; margin-bottom: 10px; }\n" +
                   ".summary-item { padding: 10px; margin-right: 10px; border-radius: 5px; color: white; }\n" +
                   ".total { background-color: #3498db; }\n" +
                   ".passed { background-color: #2ecc71; }\n" +
                   ".failed { background-color: #e74c3c; }\n" +
                   ".duration { background-color: #f39c12; }\n" +
                   ".timestamp { color: #7f8c8d; }\n" +
                   "table { width: 100%; border-collapse: collapse; }\n" +
                   "th, td { padding: 10px; text-align: left; border-bottom: 1px solid #ddd; }\n" +
                   ".passed { background-color: #d4edda; }\n" +
                   ".failed { background-color: #f8d7da; }";
        }
        
        private String getReportScripts() {
            return "function sortTable(n) {\n" +
                   "  var table, rows, switching, i, x, y, shouldSwitch, dir, switchcount = 0;\n" +
                   "  table = document.getElementsByTagName('table')[0];\n" +
                   "  switching = true;\n" +
                   "  dir = 'asc';\n" +
                   "  while (switching) {\n" +
                   "    switching = false;\n" +
                   "    rows = table.getElementsByTagName('tr');\n" +
                   "    for (i = 1; i < (rows.length - 1); i++) {\n" +
                   "      shouldSwitch = false;\n" +
                   "      x = rows[i].getElementsByTagName('td')[n];\n" +
                   "      y = rows[i + 1].getElementsByTagName('td')[n];\n" +
                   "      if (dir == 'asc') {\n" +
                   "        if (x.innerHTML.toLowerCase() > y.innerHTML.toLowerCase()) {\n" +
                   "          shouldSwitch = true;\n" +
                   "          break;\n" +
                   "        }\n" +
                   "      } else if (dir == 'desc') {\n" +
                   "        if (x.innerHTML.toLowerCase() < y.innerHTML.toLowerCase()) {\n" +
                   "          shouldSwitch = true;\n" +
                   "          break;\n" +
                   "        }\n" +
                   "      }\n" +
                   "    }\n" +
                   "    if (shouldSwitch) {\n" +
                   "      rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);\n" +
                   "      switching = true;\n" +
                   "      switchcount++;\n" +
                   "    } else {\n" +
                   "      if (switchcount == 0 && dir == 'asc') {\n" +
                   "        dir = 'desc';\n" +
                   "        switching = true;\n" +
                   "      }\n" +
                   "    }\n" +
                   "  }\n" +
                   "}";
        }
        
        private String formatDuration(long millis) {
            long seconds = millis / 1000;
            long minutes = seconds / 60;
            seconds = seconds % 60;
            
            if (minutes > 0) {
                return String.format("%dm %ds", minutes, seconds);
            } else {
                return String.format("%d.%03ds", seconds, millis % 1000);
            }
        }
    }
    
    // 4. JSON报告生成器
    public class JsonReportGenerator {
        public void generateReport(List<TestResult> results, String outputPath) throws IOException {
            Map<String, Object> report = new HashMap<>();
            report.put("timestamp", new Date());
            report.put("results", results);
            
            TestSummary summary = new TestSummary(
                results.size(),
                (int) results.stream().filter(TestResult::isPassed).count(),
                (int) results.stream().filter(r -> !r.isPassed()).count(),
                results.stream().mapToLong(TestResult::getDuration).sum()
            );
            report.put("summary", summary);
            
            ObjectMapper mapper = new ObjectMapper();
            try (FileWriter writer = new FileWriter(outputPath)) {
                writer.write(mapper.writerWithDefaultPrettyPrinter().writeValueAsString(report));
            }
        }
    }
}
```

### 7.4.2 高级日志记录

```java
/**
 * 高级日志记录
 */
public class AdvancedLogging {
    
    // 1. 自定义请求/响应过滤器
    public class CustomLoggingFilter implements Filter {
        private static final Logger logger = LoggerFactory.getLogger(CustomLoggingFilter.class);
        private final LogDetail logDetail;
        
        public CustomLoggingFilter(LogDetail logDetail) {
            this.logDetail = logDetail;
        }
        
        @Override
        public Response filter(FilterableRequestSpecification requestSpec, 
                              FilterableResponseSpecification responseSpec, 
                              FilterContext ctx) {
            
            // 记录请求信息
            logRequest(requestSpec, ctx);
            
            // 执行请求
            Response response = ctx.next(requestSpec, responseSpec);
            
            // 记录响应信息
            logResponse(response, ctx);
            
            return response;
        }
        
        private void logRequest(FilterableRequestSpecification requestSpec, FilterContext ctx) {
            if (logDetail == LogDetail.METHOD || logDetail == LogDetail.ALL) {
                logger.info("Request Method: {}", requestSpec.getMethod());
            }
            
            if (logDetail == LogDetail.URI || logDetail == LogDetail.ALL) {
                logger.info("Request URI: {}", requestSpec.getBaseUri() + requestSpec.getBasePath() + requestSpec.getDerivedPath());
            }
            
            if (logDetail == LogDetail.HEADERS || logDetail == LogDetail.ALL) {
                logger.info("Request Headers: {}", requestSpec.getHeaders());
            }
            
            if (logDetail == LogDetail.PARAMS || logDetail == LogDetail.ALL) {
                logger.info("Request Params: {}", requestSpec.getRequestParams());
            }
            
            if (logDetail == LogDetail.BODY || logDetail == LogDetail.ALL) {
                if (requestSpec.getBody() != null) {
                    // 记录请求体，但可能需要屏蔽敏感信息
                    String requestBody = maskSensitiveData(requestSpec.getBody());
                    logger.info("Request Body: {}", requestBody);
                }
            }
        }
        
        private void logResponse(Response response, FilterContext ctx) {
            if (logDetail == LogDetail.STATUS || logDetail == LogDetail.ALL) {
                logger.info("Response Status: {}", response.getStatusCode());
            }
            
            if (logDetail == LogDetail.HEADERS || logDetail == LogDetail.ALL) {
                logger.info("Response Headers: {}", response.getHeaders());
            }
            
            if (logDetail == LogDetail.BODY || logDetail == LogDetail.ALL) {
                // 记录响应体，但可能需要屏蔽敏感信息
                String responseBody = maskSensitiveData(response.getBody().asString());
                logger.info("Response Body: {}", responseBody);
            }
            
            if (logDetail == LogDetail.ALL) {
                logger.info("Response Time: {} ms", response.getTime());
            }
        }
        
        private String maskSensitiveData(Object data) {
            if (data == null) {
                return null;
            }
            
            String dataStr = data.toString();
            
            // 屏蔽常见的敏感信息
            dataStr = dataStr.replaceAll("\"password\"\\s*:\\s*\"[^\"]*\"", "\"password\":\"******\"");
            dataStr = dataStr.replaceAll("\"token\"\\s*:\\s*\"[^\"]*\"", "\"token\":\"******\"");
            dataStr = dataStr.replaceAll("\"apiKey\"\\s*:\\s*\"[^\"]*\"", "\"apiKey\":\"******\"");
            dataStr = dataStr.replaceAll("\"secret\"\\s*:\\s*\"[^\"]*\"", "\"secret\":\"******\"");
            
            return dataStr;
        }
    }
    
    // 2. 测试上下文日志记录器
    public class TestContextLogger {
        private static final Logger logger = LoggerFactory.getLogger(TestContextLogger.class);
        private static final ThreadLocal<Map<String, Object>> context = ThreadLocal.withInitial(HashMap::new);
        
        public static void setContext(String key, Object value) {
            context.get().put(key, value);
        }
        
        public static Object getContext(String key) {
            return context.get().get(key);
        }
        
        public static void logTestStart(String testName) {
            setContext("testName", testName);
            setContext("startTime", System.currentTimeMillis());
            logger.info("========== Starting test: {} ==========", testName);
        }
        
        public static void logTestEnd(String testName, boolean passed) {
            long startTime = (Long) getContext("startTime");
            long duration = System.currentTimeMillis() - startTime;
            
            logger.info("========== {} test: {} (Duration: {} ms) ==========", 
                passed ? "Finished" : "Failed", testName, duration);
            
            context.remove();
        }
        
        public static void logApiCall(String method, String uri, int statusCode, long responseTime) {
            logger.info("API Call: {} {} -> {} ({} ms)", method, uri, statusCode, responseTime);
        }
        
        public static void logValidation(String description, boolean passed, String expected, String actual) {
            logger.info("Validation [{}]: {} - Expected: {}, Actual: {}", 
                description, passed ? "PASSED" : "FAILED", expected, actual);
        }
        
        public static void logError(String testName, String errorMessage, Exception exception) {
            logger.error("Error in test {}: {}", testName, errorMessage, exception);
        }
    }
    
    // 3. 测试步骤日志记录器
    public class TestStepLogger {
        private static final Logger logger = LoggerFactory.getLogger(TestStepLogger.class);
        private static final ThreadLocal<List<TestStep>> steps = ThreadLocal.withInitial(ArrayList::new);
        
        public static void startStep(String description) {
            TestStep step = new TestStep(description, System.currentTimeMillis());
            steps.get().add(step);
            logger.info("--- Step {}: {} ---", steps.get().size(), description);
        }
        
        public static void endStep() {
            List<TestStep> stepList = steps.get();
            if (!stepList.isEmpty()) {
                TestStep currentStep = stepList.get(stepList.size() - 1);
                currentStep.setEndTime(System.currentTimeMillis());
                long duration = currentStep.getDuration();
                logger.info("--- Completed Step {} (Duration: {} ms) ---", 
                    stepList.size(), duration);
            }
        }
        
        public static void logStepResult(String result) {
            List<TestStep> stepList = steps.get();
            if (!stepList.isEmpty()) {
                TestStep currentStep = stepList.get(stepList.size() - 1);
                currentStep.setResult(result);
                logger.info("--- Step Result: {} ---", result);
            }
        }
        
        public static List<TestStep> getSteps() {
            return new ArrayList<>(steps.get());
        }
        
        public static void clearSteps() {
            steps.get().clear();
        }
    }
    
    // 4. 测试步骤数据结构
    public class TestStep {
        private String description;
        private long startTime;
        private long endTime;
        private String result;
        
        public TestStep(String description, long startTime) {
            this.description = description;
            this.startTime = startTime;
        }
        
        public long getDuration() {
            return endTime - startTime;
        }
        
        // Getters and setters
        public String getDescription() { return description; }
        public long getStartTime() { return startTime; }
        public long getEndTime() { return endTime; }
        public void setEndTime(long endTime) { this.endTime = endTime; }
        public String getResult() { return result; }
        public void setResult(String result) { this.result = result; }
    }
    
    // 5. 使用示例
    @Test
    public void testWithAdvancedLogging() {
        // 初始化测试日志
        TestContextLogger.logTestStart("testWithAdvancedLogging");
        
        try {
            // 步骤1: 创建测试数据
            TestStepLogger.startStep("Create test user");
            User testUser = TestDataFactory.aUser()
                .withName("Test User")
                .withEmail("test@example.com")
                .build();
            TestStepLogger.logStepResult("User created successfully");
            TestStepLogger.endStep();
            
            // 步骤2: 发送API请求
            TestStepLogger.startStep("Send create user API request");
            
            long startTime = System.currentTimeMillis();
            Response response = given()
                .filter(new CustomLoggingFilter(LogDetail.ALL))
                .contentType(ContentType.JSON)
                .body(testUser)
            .when()
                .post("/users");
            long responseTime = System.currentTimeMillis() - startTime;
            
            TestStepLogger.logStepResult("API request sent successfully");
            TestStepLogger.endStep();
            
            // 记录API调用
            TestContextLogger.logApiCall("POST", "/users", response.getStatusCode(), responseTime);
            
            // 步骤3: 验证响应
            TestStepLogger.startStep("Validate API response");
            
            // 状态码验证
            boolean statusCheck = response.getStatusCode() == 201;
            TestContextLogger.logValidation("Status Code", statusCheck, "201", String.valueOf(response.getStatusCode()));
            
            // 响应体验证
            User createdUser = response.as(User.class);
            boolean nameCheck = testUser.getName().equals(createdUser.getName());
            TestContextLogger.logValidation("User Name", nameCheck, testUser.getName(), createdUser.getName());
            
            boolean emailCheck = testUser.getEmail().equals(createdUser.getEmail());
            TestContextLogger.logValidation("User Email", emailCheck, testUser.getEmail(), createdUser.getEmail());
            
            TestStepLogger.logStepResult("Response validation completed");
            TestStepLogger.endStep();
            
            // 完成测试
            TestContextLogger.logTestEnd("testWithAdvancedLogging", true);
            
        } catch (Exception e) {
            TestContextLogger.logError("testWithAdvancedLogging", e.getMessage(), e);
            TestContextLogger.logTestEnd("testWithAdvancedLogging", false);
            throw e;
        } finally {
            TestStepLogger.clearSteps();
        }
    }
}
```

## 7.5 测试组织与执行策略

### 7.5.1 测试分类与标记

```java
/**
 * 测试分类与标记
 */
public class TestCategorization {
    
    // 1. 使用JUnit分类
    @Category(SmokeTests.class)
    @Test
    public void criticalUserCreationTest() {
        // 关键功能测试
        User user = TestDataFactory.aUser().build();
        given()
            .contentType(ContentType.JSON)
            .body(user)
        .when()
            .post("/users")
        .then()
            .statusCode(201);
    }
    
    @Category(RegressionTests.class)
    @Test
    public void userFeatureRegressionTest() {
        // 回归测试
        User user = TestDataFactory.aUser().build();
        
        // 测试创建用户
        Response createResponse = given()
            .contentType(ContentType.JSON)
            .body(user)
        .when()
            .post("/users");
        
        createResponse.then().statusCode(201);
        
        // 测试获取用户
        int userId = createResponse.jsonPath().getInt("id");
        given()
            .pathParam("userId", userId)
        .when()
            .get("/users/{userId}")
        .then()
            .statusCode(200)
            .body("name", equalTo(user.getName()));
    }
    
    @Category(IntegrationTests.class)
    @Test
    public void userApiIntegrationTest() {
        // 集成测试
        // 1. 创建用户
        User user = TestDataFactory.aUser().build();
        int userId = given()
            .contentType(ContentType.JSON)
            .body(user)
        .when()
            .post("/users")
        .then()
            .statusCode(201)
        .extract()
        .path("id");
        
        // 2. 更新用户
        User updatedUser = new User();
        updatedUser.setName("Updated Name");
        given()
            .pathParam("userId", userId)
            .contentType(ContentType.JSON)
            .body(updatedUser)
        .when()
            .put("/users/{userId}")
        .then()
            .statusCode(200)
            .body("name", equalTo("Updated Name"));
        
        // 3. 删除用户
        given()
            .pathParam("userId", userId)
        .when()
            .delete("/users/{userId}")
        .then()
            .statusCode(200);
        
        // 4. 验证用户已删除
        given()
            .pathParam("userId", userId)
        .when()
            .get("/users/{userId}")
        .then()
            .statusCode(404);
    }
    
    // 测试分类接口
    public interface SmokeTests {}  // 关键功能测试
    public interface RegressionTests {}  // 回归测试
    public interface IntegrationTests {}  // 集成测试
    public interface SecurityTests {}  // 安全测试
    public interface PerformanceTests {}  // 性能测试
    
    // 2. 使用自定义注解分类
    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.METHOD)
    public @interface TestCategory {
        String value();
        String description() default "";
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.METHOD)
    public @interface TestPriority {
        int value();
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.METHOD)
    public @interface TestTags {
        String[] value();
    }
    
    // 使用自定义注解
    @TestCategory(value = "authentication", description = "User authentication tests")
    @TestPriority(1)  // 高优先级
    @TestTags({"security", "authentication", "critical"})
    @Test
    public void userLoginTest() {
        // 用户登录测试
        given()
            .contentType(ContentType.JSON)
            .body("{\"username\":\"user\",\"password\":\"pass\"}")
        .when()
            .post("/auth/login")
        .then()
            .statusCode(200)
            .body("token", notNullValue());
    }
    
    @TestCategory(value = "user-management", description = "User CRUD operations")
    @TestPriority(2)  // 中等优先级
    @TestTags({"user", "crud"})
    @Test
    public void userCrudOperationsTest() {
        // 用户CRUD操作测试
        User user = TestDataFactory.aUser().build();
        
        // Create
        Response createResponse = given()
            .contentType(ContentType.JSON)
            .body(user)
        .when()
            .post("/users");
        
        createResponse.then().statusCode(201);
        int userId = createResponse.jsonPath().getInt("id");
        
        // Read
        given()
            .pathParam("userId", userId)
        .when()
            .get("/users/{userId}")
        .then()
            .statusCode(200);
        
        // Update
        given()
            .pathParam("userId", userId)
            .contentType(ContentType.JSON)
            .body("{\"name\":\"Updated Name\"}")
        .when()
            .put("/users/{userId}")
        .then()
            .statusCode(200);
        
        // Delete
        given()
            .pathParam("userId", userId)
        .when()
            .delete("/users/{userId}")
        .then()
            .statusCode(200);
    }
    
    // 3. 测试分类收集器
    public class TestCategoryCollector {
        public static Map<String, List<TestMethod>> collectTestsByCategory(Class<?> testClass) {
            Map<String, List<TestMethod>> categorizedTests = new HashMap<>();
            
            for (Method method : testClass.getDeclaredMethods()) {
                if (method.isAnnotationPresent(Test.class)) {
                    List<String> categories = new ArrayList<>();
                    
                    // 收集自定义分类注解
                    if (method.isAnnotationPresent(TestCategory.class)) {
                        TestCategory annotation = method.getAnnotation(TestCategory.class);
                        categories.add(annotation.value());
                    }
                    
                    // 收集标签
                    if (method.isAnnotationPresent(TestTags.class)) {
                        TestTags annotation = method.getAnnotation(TestTags.class);
                        categories.addAll(Arrays.asList(annotation.value()));
                    }
                    
                    // 收集JUnit分类
                    for (Class<?> categoryInterface : method.getAnnotation(Category.class).value()) {
                        categories.add(categoryInterface.getSimpleName());
                    }
                    
                    // 如果没有分类，则归类为"未分类"
                    if (categories.isEmpty()) {
                        categories.add("Uncategorized");
                    }
                    
                    TestMethod testMethod = new TestMethod(method.getName(), categories);
                    
                    for (String category : categories) {
                        categorizedTests.computeIfAbsent(category, k -> new ArrayList<>()).add(testMethod);
                    }
                }
            }
            
            return categorizedTests;
        }
    }
    
    // 4. 测试方法数据结构
    public static class TestMethod {
        private String name;
        private List<String> categories;
        
        public TestMethod(String name, List<String> categories) {
            this.name = name;
            this.categories = new ArrayList<>(categories);
        }
        
        // Getters
        public String getName() { return name; }
        public List<String> getCategories() { return categories; }
    }
}
```

### 7.5.2 测试套件组织

```java
/**
 * 测试套件组织
 */
public class TestSuiteOrganization {
    
    // 1. 基础测试套件
    @RunWith(Suite.class)
    @Suite.SuiteClasses({
        UserApiTests.class,
        ProductApiTests.class,
        OrderApiTests.class
    })
    public class ApiTestSuite {
        // 运行所有API测试
    }
    
    // 2. 功能模块测试套件
    @RunWith(Suite.class)
    @Suite.SuiteClasses({
        UserRegistrationTests.class,
        UserLoginTests.class,
        UserProfileTests.class,
        UserPermissionsTests.class
    })
    public class UserModuleTestSuite {
        // 运行用户模块所有测试
    }
    
    // 3. 分类测试套件
    @RunWith(Categories.class)
    @Categories.IncludeCategory(SmokeTests.class)
    @Suite.SuiteClasses({
        UserApiTests.class,
        ProductApiTests.class,
        OrderApiTests.class,
        PaymentApiTests.class
    })
    public class SmokeTestSuite {
        // 运行所有冒烟测试
    }
    
    @RunWith(Categories.class)
    @Categories.IncludeCategory(SecurityTests.class)
    @Suite.SuiteClasses({
        AuthenticationTests.class,
        AuthorizationTests.class,
        DataProtectionTests.class
    })
    public class SecurityTestSuite {
        // 运行所有安全测试
    }
    
    // 4. 动态测试套件构建
    public class DynamicTestSuiteBuilder {
        public static Class<?>[] buildTestSuiteByTag(String... tags) {
            List<Class<?>> testClasses = new ArrayList<>();
            
            // 搜索包含特定标签的测试类
            Reflections reflections = new Reflections("com.example.tests");
            Set<Class<?>> classes = reflections.getTypesAnnotatedWith(RunWith.class);
            
            for (Class<?> testClass : classes) {
                if (containsAllTags(testClass, tags)) {
                    testClasses.add(testClass);
                }
            }
            
            return testClasses.toArray(new Class<?>[0]);
        }
        
        private static boolean containsAllTags(Class<?> testClass, String[] tags) {
            for (String tag : tags) {
                boolean found = false;
                
                // 检查类级别的注解
                if (testClass.isAnnotationPresent(TestTags.class)) {
                    TestTags annotation = testClass.getAnnotation(TestTags.class);
                    if (Arrays.asList(annotation.value()).contains(tag)) {
                        found = true;
                    }
                }
                
                // 检查方法级别的注解
                if (!found) {
                    for (Method method : testClass.getDeclaredMethods()) {
                        if (method.isAnnotationPresent(Test.class) && 
                            method.isAnnotationPresent(TestTags.class)) {
                            TestTags annotation = method.getAnnotation(TestTags.class);
                            if (Arrays.asList(annotation.value()).contains(tag)) {
                                found = true;
                                break;
                            }
                        }
                    }
                }
                
                if (!found) {
                    return false;
                }
            }
            
            return true;
        }
    }
    
    // 5. 测试套件执行器
    public class TestSuiteRunner {
        private static final Logger logger = LoggerFactory.getLogger(TestSuiteRunner.class);
        
        public static void runSuite(Class<?> testSuiteClass) {
            logger.info("Running test suite: {}", testSuiteClass.getSimpleName());
            
            // 运行测试套件
            JUnitCore junit = new JUnitCore();
            junit.addListener(new TestExecutionListener());
            
            Result result = junit.run(testSuiteClass);
            
            // 记录结果
            logger.info("Tests run: {}, Failures: {}, Ignored: {}, Time: {} ms",
                result.getRunCount(),
                result.getFailureCount(),
                result.getIgnoreCount(),
                result.getRunTime());
            
            // 生成报告
            generateTestReport(result, testSuiteClass);
        }
        
        private static void generateTestReport(Result result, Class<?> testSuiteClass) {
            try {
                String reportPath = "target/test-reports/" + testSuiteClass.getSimpleName() + ".html";
                
                List<CustomTestReports.TestResult> testResults = new ArrayList<>();
                
                for (Failure failure : result.getFailures()) {
                    testResults.add(new CustomTestReports.TestResult(
                        failure.getDescription().getMethodName(),
                        false,
                        0,
                        failure.getMessage()
                    ));
                }
                
                CustomTestReports.HtmlReportGenerator generator = new CustomTestReports.HtmlReportGenerator();
                generator.generateReport(testResults, reportPath);
                
                logger.info("Test report generated at: {}", reportPath);
            } catch (IOException e) {
                logger.error("Failed to generate test report", e);
            }
        }
    }
    
    // 6. 测试执行监听器
    public static class TestExecutionListener extends RunListener {
        private static final Logger logger = LoggerFactory.getLogger(TestExecutionListener.class);
        
        @Override
        public void testRunStarted(Description description) throws Exception {
            logger.info("Test run started: {}", description.getDisplayName());
        }
        
        @Override
        public void testStarted(Description description) throws Exception {
            logger.info("Test started: {}", description.getMethodName());
        }
        
        @Override
        public void testFinished(Description description) throws Exception {
            logger.info("Test finished: {}", description.getMethodName());
        }
        
        @Override
        public void testFailure(Failure failure) throws Exception {
            logger.error("Test failed: {}", failure.getDescription().getMethodName(), failure.getException());
        }
        
        @Override
        public void testIgnored(Description description) throws Exception {
            logger.warn("Test ignored: {}", description.getMethodName());
        }
    }
}
```

## 7.6 实践练习

### 练习1：设计完整的测试框架

设计一个完整的REST Assured测试框架，包括：
- 测试数据管理
- 页面对象模式实现
- 测试报告生成
- 日志记录系统

### 练习2：实现测试分类系统

实现一个测试分类系统，支持：
- 基于功能的分类
- 基于优先级的分类
- 基于标签的分类
- 动态测试套件构建

### 练习3：集成持续集成流程

设计一个与CI/CD集成的测试框架，支持：
- 测试结果通知
- 测试报告归档
- 失败测试重试
- 测试环境自动切换

## 7.7 总结

本章深入探讨了REST Assured测试框架设计与组织的技术，包括：

1. **测试框架设计原则** - 了解测试框架的设计原则和分层架构
2. **测试数据管理** - 掌握测试数据生成、生命周期管理和存储策略
3. **页面对象模式** - 学习将页面对象模式应用于API测试
4. **测试报告与日志** - 了解如何创建自定义测试报告和高级日志记录
5. **测试组织与执行策略** - 掌握测试分类、标记和测试套件组织方法

通过本章的学习，您应该能够设计、构建和组织一个专业级的REST Assured测试框架，使其具有可维护性、可扩展性和高效率。在最后一章中，我们将探讨REST Assured的高级特性与最佳实践。