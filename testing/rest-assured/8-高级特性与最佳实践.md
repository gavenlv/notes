# 第8章：高级特性与最佳实践

## 8.1 REST Assured高级特性

### 8.1.1 高级请求配置

```java
/**
 * REST Assured高级请求配置
 */
public class AdvancedRequestConfiguration {
    
    // 1. 代理配置
    @Test
    public void testWithProxy() {
        // 使用HTTP代理
        given()
            .proxy("proxy.example.com", 8080)
        .when()
            .get("/api/data")
        .then()
            .statusCode(200);
            
        // 使用带认证的代理
        given()
            .proxy("proxy.example.com", 8080, "proxyuser", "proxypass")
        .when()
            .get("/api/data")
        .then()
            .statusCode(200);
            
        // 使用SOCKS代理
        given()
            .proxy(ProxySpecification
                .host("socks.example.com")
                .withPort(1080)
                .withScheme("socks5"))
        .when()
            .get("/api/data")
        .then()
            .statusCode(200);
    }
    
    // 2. 连接池配置
    @Test
    public void testWithConnectionPool() {
        // 配置连接池
        RestAssured.config = RestAssuredConfig.config()
            .connectionConfig(new ConnectionConfig()
                .maxConnections(50)  // 最大连接数
                .maxConnectionsPerHost(20)  // 每个主机的最大连接数
                .closeIdleConnectionsAfterEachResponse(true)  // 每次响应后关闭空闲连接
                .idleConnectionTimeout(30000, TimeUnit.MILLISECONDS)  // 空闲连接超时
            );
            
        given()
            .when()
            .get("/api/data")
        .then()
            .statusCode(200);
    }
    
    // 3. HTTP客户端配置
    @Test
    public void testWithHttpClientConfig() {
        RestAssured.config = RestAssuredConfig.config()
            .httpClient(HttpClientConfig.httpClientConfig()
                .setParam("http.protocol.handle-redirects", true)  // 启用重定向处理
                .setParam("http.protocol.allow-circular-redirects", false)  // 禁用循环重定向
                .setParam("http.protocol.max-redirects", 5)  // 最大重定向次数
                .setParam("http.conn-manager.timeout", 5000)  // 连接管理器超时
                .setParam("http.socket.timeout", 10000)  // 套接字超时
                .setParam("http.connection.timeout", 5000)  // 连接超时
            );
            
        given()
            .when()
            .get("/api/data")
        .then()
            .statusCode(200);
    }
    
    // 4. 重试机制
    @Test
    public void testWithRetryMechanism() {
        // 使用RetryFilter实现自动重试
        given()
            .filter(new RetryFilter(
                3,  // 最大重试次数
                1000,  // 重试间隔(毫秒)
                Arrays.asList(500, 502, 503, 504)  // 需要重试的状态码
            ))
        .when()
            .get("/api/unstable")
        .then()
            .statusCode(200);
            
        // 自定义重试策略
        given()
            .filter(new RequestLoggingFilter())
            .filter(new Filter() {
                private int retryCount = 0;
                private static final int MAX_RETRIES = 3;
                
                @Override
                public Response filter(FilterableRequestSpecification requestSpec, 
                                      FilterableResponseSpecification responseSpec, 
                                      FilterContext ctx) {
                    Response response = ctx.next(requestSpec, responseSpec);
                    
                    // 如果响应状态码是服务器错误且重试次数未达到上限
                    if ((response.getStatusCode() >= 500 && response.getStatusCode() < 600) 
                        && retryCount < MAX_RETRIES) {
                        retryCount++;
                        System.out.println("Retrying request... Attempt " + retryCount);
                        
                        // 指数退避策略
                        long delay = (long) Math.pow(2, retryCount) * 1000;
                        try {
                            Thread.sleep(delay);
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                        
                        return ctx.next(requestSpec, responseSpec);
                    }
                    
                    return response;
                }
            })
        .when()
            .get("/api/unstable")
        .then()
            .statusCode(anyOf(equalTo(200), equalTo(500)));  // 可能成功或失败
    }
    
    // 5. 请求拦截器
    @Test
    public void testWithRequestInterceptors() {
        // 添加请求拦截器，自动添加时间戳
        given()
            .filter((requestSpec, responseSpec, ctx) -> {
                // 在发送请求前修改请求规范
                requestSpec.header("X-Request-Timestamp", String.valueOf(System.currentTimeMillis()));
                
                // 继续执行请求
                Response response = ctx.next(requestSpec, responseSpec);
                
                // 在接收响应后修改响应
                if (response.getStatusCode() == 200) {
                    System.out.println("Request completed successfully");
                }
                
                return response;
            })
        .when()
            .get("/api/data")
        .then()
            .statusCode(200);
    }
    
    // 6. 响应断言拦截器
    @Test
    public void testWithResponseAssertionInterceptor() {
        given()
            .filter((requestSpec, responseSpec, ctx) -> {
                Response response = ctx.next(requestSpec, responseSpec);
                
                // 自动验证所有成功响应包含内容类型头
                if (response.getStatusCode() >= 200 && response.getStatusCode() < 300) {
                    response.then().header("Content-Type", notNullValue());
                }
                
                return response;
            })
        .when()
            .get("/api/data")
        .then()
            .statusCode(200);
    }
}
```

### 8.1.2 高级响应处理

```java
/**
 * 高级响应处理
 */
public class AdvancedResponseHandling {
    
    // 1. 响应转换器
    @Test
    public void testWithResponseConverter() {
        // 使用自定义响应转换器
        Response response = given()
            .when()
            .get("/api/users")
        .then()
            .statusCode(200)
        .extract()
            .response();
            
        // 将响应转换为自定义对象列表
        List<User> users = response.jsonPath().getList("users", User.class);
        
        // 转换为DTO列表
        List<UserDTO> userDTOs = users.stream()
            .map(this::convertToDTO)
            .collect(Collectors.toList());
            
        // 验证转换结果
        assertFalse(userDTOs.isEmpty());
        for (UserDTO dto : userDTOs) {
            assertNotNull(dto.getFullName());
            assertNotNull(dto.getEmailDomain());
        }
    }
    
    private UserDTO convertToDTO(User user) {
        UserDTO dto = new UserDTO();
        dto.setFullName(user.getName());
        dto.setEmailDomain(extractDomainFromEmail(user.getEmail()));
        dto.setAgeGroup(determineAgeGroup(user.getAge()));
        return dto;
    }
    
    private String extractDomainFromEmail(String email) {
        return email.substring(email.indexOf('@') + 1);
    }
    
    private String determineAgeGroup(Integer age) {
        if (age == null) return "Unknown";
        if (age < 18) return "Minor";
        if (age < 30) return "Young Adult";
        if (age < 50) return "Adult";
        return "Senior";
    }
    
    // 2. 条件响应处理
    @Test
    public void testWithConditionalResponseHandling() {
        Response response = given()
            .when()
            .get("/api/resource")
        .then()
            .statusCode(200)
        .extract()
            .response();
            
        // 根据响应内容执行不同的处理
        String resourceType = response.jsonPath().getString("type");
        
        switch (resourceType) {
            case "user":
                User user = response.as(User.class);
                // 处理用户资源
                assertNotNull(user.getId());
                break;
                
            case "product":
                Product product = response.as(Product.class);
                // 处理产品资源
                assertTrue(product.getPrice() > 0);
                break;
                
            case "order":
                Order order = response.as(Order.class);
                // 处理订单资源
                assertNotNull(order.getOrderDate());
                break;
                
            default:
                fail("Unknown resource type: " + resourceType);
                break;
        }
    }
    
    // 3. 响应数据验证器
    @Test
    public void testWithResponseDataValidator() {
        Response response = given()
            .when()
            .get("/api/complex-data")
        .then()
            .statusCode(200)
        .extract()
            .response();
            
        // 使用自定义验证器验证响应
        ResponseDataValidator validator = new ResponseDataValidator();
        ValidationResult result = validator.validate(response);
        
        // 处理验证结果
        if (!result.isValid()) {
            String errorMessage = "Response validation failed:\n" +
                String.join("\n", result.getErrors());
            fail(errorMessage);
        }
    }
    
    // 4. 响应数据提取器
    @Test
    public void testWithResponseDataExtractor() {
        Response response = given()
            .when()
            .get("/api/users-with-orders")
        .then()
            .statusCode(200)
        .extract()
            .response();
            
        // 使用自定义提取器提取复杂数据
        UserDataExtractor extractor = new UserDataExtractor();
        UserOrderSummary summary = extractor.extractSummary(response);
        
        // 验证提取结果
        assertNotNull(summary);
        assertTrue(summary.getTotalUsers() > 0);
        assertTrue(summary.getTotalOrders() > 0);
        assertTrue(summary.getAverageOrdersPerUser() > 0);
    }
}

// 自定义响应数据验证器
public class ResponseDataValidator {
    public ValidationResult validate(Response response) {
        ValidationResult result = new ValidationResult();
        
        try {
            // 验证状态码
            int statusCode = response.getStatusCode();
            if (statusCode < 200 || statusCode >= 300) {
                result.addError("Invalid status code: " + statusCode);
            }
            
            // 验证内容类型
            String contentType = response.getContentType();
            if (contentType == null || !contentType.contains("application/json")) {
                result.addError("Invalid content type: " + contentType);
            }
            
            // 验证响应体
            String responseBody = response.getBody().asString();
            if (responseBody == null || responseBody.isEmpty()) {
                result.addError("Empty response body");
            } else {
                // 验证JSON格式
                try {
                    new ObjectMapper().readTree(responseBody);
                } catch (JsonProcessingException e) {
                    result.addError("Invalid JSON format: " + e.getMessage());
                }
                
                // 验证必需字段
                JsonPath jsonPath = new JsonPath(responseBody);
                if (!jsonPath.getMap("$").containsKey("data")) {
                    result.addError("Missing required field: data");
                }
            }
            
        } catch (Exception e) {
            result.addError("Validation error: " + e.getMessage());
        }
        
        return result;
    }
}

// 验证结果类
public class ValidationResult {
    private boolean valid = true;
    private List<String> errors = new ArrayList<>();
    
    public void addError(String error) {
        valid = false;
        errors.add(error);
    }
    
    public boolean isValid() {
        return valid;
    }
    
    public List<String> getErrors() {
        return Collections.unmodifiableList(errors);
    }
}

// 用户数据提取器
public class UserDataExtractor {
    public UserOrderSummary extractSummary(Response response) {
        JsonPath jsonPath = response.jsonPath();
        
        // 提取用户数据
        List<Map<String, Object>> users = jsonPath.getList("users");
        int totalUsers = users.size();
        
        // 提取订单数据
        List<Map<String, Object>> orders = jsonPath.getList("orders");
        int totalOrders = orders.size();
        
        // 计算平均订单数
        double averageOrdersPerUser = totalOrders > 0 && totalUsers > 0 ? 
            (double) totalOrders / totalUsers : 0;
        
        // 提取订单总金额
        List<Double> orderAmounts = jsonPath.getList("orders.amount");
        double totalOrderAmount = orderAmounts.stream().mapToDouble(Double::doubleValue).sum();
        
        // 构建摘要
        UserOrderSummary summary = new UserOrderSummary();
        summary.setTotalUsers(totalUsers);
        summary.setTotalOrders(totalOrders);
        summary.setAverageOrdersPerUser(averageOrdersPerUser);
        summary.setTotalOrderAmount(totalOrderAmount);
        
        return summary;
    }
}
```

### 8.1.3 高级JSON/XML处理

```java
/**
 * 高级JSON/XML处理
 */
public class AdvancedJsonXmlProcessing {
    
    // 1. 复杂JSONPath表达式
    @Test
    public void testComplexJsonPathExpressions() {
        given()
            .when()
            .get("/api/complex-data")
        .then()
            .statusCode(200)
            
            // 嵌套条件查询
            .body("users[?(@.profile.age > 30 && @.active == true)].name", 
                hasItems("John Doe", "Jane Smith"))
                
            // 计算操作
            .body("products[?(@.price * @.quantity > 100)].name", 
                hasItem("Premium Product"))
                
            // 字符串操作
            .body("users[?(@.name =~ /^J.*/)].email", 
                everyItem(containsString("@example.com")))
                
            // 聚合操作
            .body("orders.collect { it.totalAmount }.sum()", 
                greaterThan(1000.0))
                
            // 分组操作
            .body("products.groupBy { it.category }.collectEntries { k, v -> [k, v.size()] }", 
                hasEntry("electronics", 5));
    }
    
    // 2. JSON Schema验证
    @Test
    public void testJsonSchemaValidation() {
        // 定义JSON Schema
        String userSchema = "{\n" +
            "  \"type\": \"object\",\n" +
            "  \"properties\": {\n" +
            "    \"id\": {\"type\": \"integer\"},\n" +
            "    \"name\": {\"type\": \"string\"},\n" +
            "    \"email\": {\"type\": \"string\", \"format\": \"email\"},\n" +
            "    \"age\": {\"type\": \"integer\", \"minimum\": 0, \"maximum\": 150},\n" +
            "    \"active\": {\"type\": \"boolean\"}\n" +
            "  },\n" +
            "  \"required\": [\"id\", \"name\", \"email\"]\n" +
            "}";
            
        // 验证响应是否符合Schema
        given()
            .when()
            .get("/api/users/1")
        .then()
            .statusCode(200)
            .body(matchesJsonSchema(userSchema));
            
        // 从文件加载Schema验证
        given()
            .when()
            .get("/api/products")
        .then()
            .statusCode(200)
            .body(matchesJsonSchemaInClasspath("schemas/product-schema.json"));
    }
    
    // 3. JSON Schema文件
    // src/test/resources/schemas/product-schema.json:
    /*
    {
      "$schema": "http://json-schema.org/draft-04/schema#",
      "type": "object",
      "properties": {
        "products": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {"type": "integer"},
              "name": {"type": "string"},
              "price": {"type": "number", "minimum": 0},
              "category": {"type": "string"},
              "inStock": {"type": "boolean"}
            },
            "required": ["id", "name", "price", "category"]
          }
        }
      },
      "required": ["products"]
    }
    */
    
    // 4. 高级XML处理
    @Test
    public void testAdvancedXmlProcessing() {
        given()
            .when()
            .get("/api/complex-data.xml")
        .then()
            .statusCode(200)
            
            // 使用命名空间
            .body(hasXPath("//ns:user/ns:name", 
                Map.of("ns", "http://example.com/namespace"),
                equalTo("John")))
                
            // 复杂XPath表达式
            .body(hasXPath("//users/user[age > 30]/name", hasItem("John")))
            .body(hasXPath("count(//orders/order[status='completed'])", greaterThan("0")))
            .body(hasXPath("//products/product[@category='electronics']/name", hasItems("Phone", "Laptop")))
                
            // 使用XPath函数
            .body(hasXPath("sum(//orders/order/totalAmount)", greaterThan("1000")))
            .body(hasXPath("concat(//user/firstName, ' ', //user/lastName)", equalTo("John Doe")));
    }
    
    // 5. XML与JSON转换
    @Test
    public void testXmlJsonConversion() {
        // 获取XML响应
        Response xmlResponse = given()
            .when()
            .get("/api/data.xml")
        .then()
            .statusCode(200)
        .extract()
            .response();
            
        // 转换为JSON
        String jsonString = convertXmlToJson(xmlResponse.getBody().asString());
        
        // 验证JSON结构
        JsonPath jsonPath = new JsonPath(jsonString);
        assertNotNull(jsonPath.get("data"));
        assertNotNull(jsonPath.get("data.users"));
        assertTrue(jsonPath.getList("data.users").size() > 0);
        
        // 获取JSON响应进行比较
        Response jsonResponse = given()
            .header("Accept", "application/json")
            .when()
            .get("/api/data")
        .then()
            .statusCode(200)
        .extract()
            .response();
            
        // 验证转换后的JSON与原始JSON响应具有相同的数据结构
        JsonPath originalJsonPath = jsonResponse.jsonPath();
        assertEquals(originalJsonPath.get("data.users.size()"), jsonPath.get("data.users.size()"));
    }
    
    private String convertXmlToJson(String xml) {
        // 使用Jackson或其他库转换XML到JSON
        try {
            XmlMapper xmlMapper = new XmlMapper();
            ObjectMapper jsonMapper = new ObjectMapper();
            
            // 读取XML并转换为Map
            Map<String, Object> xmlData = xmlMapper.readValue(xml, new TypeReference<Map<String, Object>>() {});
            
            // 将Map转换为JSON字符串
            return jsonMapper.writeValueAsString(xmlData);
        } catch (Exception e) {
            throw new RuntimeException("Failed to convert XML to JSON", e);
        }
    }
    
    // 6. 自定义序列化/反序列化
    @Test
    public void testCustomSerializationDeserialization() {
        // 自定义序列化器处理日期
        ObjectMapper customMapper = new ObjectMapper();
        customMapper.registerModule(new JavaTimeModule());
        customMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        customMapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"));
        
        // 使用自定义序列化器发送请求
        User user = new User();
        user.setName("John Doe");
        user.setBirthDate(LocalDate.of(1990, 1, 1));
        
        String jsonRequest = customMapper.writeValueAsString(user);
        
        given()
            .contentType(ContentType.JSON)
            .body(jsonRequest)
        .when()
            .post("/api/users")
        .then()
            .statusCode(201);
            
        // 使用自定义反序列化器解析响应
        Response response = given()
            .when()
            .get("/api/users/1")
        .then()
            .statusCode(200)
        .extract()
            .response();
            
        User returnedUser = customMapper.readValue(response.getBody().asString(), User.class);
        assertNotNull(returnedUser.getBirthDate());
    }
}
```

## 8.2 性能测试与优化

### 8.2.1 REST Assured性能测试

```java
/**
 * REST Assured性能测试
 */
public class RestAssuredPerformanceTesting {
    
    // 1. 基本性能测试
    @Test
    public void testBasicPerformance() {
        // 单次请求性能测试
        long startTime = System.currentTimeMillis();
        
        given()
            .when()
            .get("/api/data")
        .then()
            .statusCode(200);
            
        long endTime = System.currentTimeMillis();
        long responseTime = endTime - startTime;
        
        // 验证响应时间
        assertTrue(responseTime < 2000, "Response time should be less than 2 seconds");
        
        // REST Assured内置的时间验证
        given()
            .when()
            .get("/api/data")
        .then()
            .statusCode(200)
            .time(lessThan(2000L));
    }
    
    // 2. 并发请求测试
    @Test
    public void testConcurrentRequests() {
        int threadCount = 10;
        int requestsPerThread = 5;
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        CountDownLatch latch = new CountDownLatch(threadCount);
        List<Long> responseTimes = Collections.synchronizedList(new ArrayList<>());
        AtomicInteger successCount = new AtomicInteger(0);
        AtomicInteger errorCount = new AtomicInteger(0);
        
        for (int i = 0; i < threadCount; i++) {
            final int threadIndex = i;
            executor.submit(() -> {
                try {
                    for (int j = 0; j < requestsPerThread; j++) {
                        long startTime = System.currentTimeMillis();
                        
                        try {
                            given()
                                .when()
                                .get("/api/data")
                            .then()
                                .statusCode(200);
                                
                            successCount.incrementAndGet();
                        } catch (Exception e) {
                            errorCount.incrementAndGet();
                        }
                        
                        long endTime = System.currentTimeMillis();
                        responseTimes.add(endTime - startTime);
                    }
                } finally {
                    latch.countDown();
                }
            });
        }
        
        try {
            // 等待所有线程完成
            latch.await(30, TimeUnit.SECONDS);
            
            // 分析结果
            int totalRequests = threadCount * requestsPerThread;
            double successRate = (double) successCount.get() / totalRequests * 100;
            
            // 计算响应时间统计
            Collections.sort(responseTimes);
            long minResponseTime = responseTimes.get(0);
            long maxResponseTime = responseTimes.get(responseTimes.size() - 1);
            double avgResponseTime = responseTimes.stream().mapToLong(Long::longValue).average().orElse(0);
            
            // 计算百分位数
            long p50 = responseTimes.get((int) (responseTimes.size() * 0.5));
            long p95 = responseTimes.get((int) (responseTimes.size() * 0.95));
            long p99 = responseTimes.get((int) (responseTimes.size() * 0.99));
            
            // 输出性能报告
            System.out.println("Performance Test Results:");
            System.out.println("Total Requests: " + totalRequests);
            System.out.println("Successful Requests: " + successCount.get());
            System.out.println("Failed Requests: " + errorCount.get());
            System.out.println("Success Rate: " + successRate + "%");
            System.out.println("Min Response Time: " + minResponseTime + " ms");
            System.out.println("Max Response Time: " + maxResponseTime + " ms");
            System.out.println("Average Response Time: " + avgResponseTime + " ms");
            System.out.println("50th Percentile: " + p50 + " ms");
            System.out.println("95th Percentile: " + p95 + " ms");
            System.out.println("99th Percentile: " + p99 + " ms");
            
            // 验证性能指标
            assertTrue(successRate > 95, "Success rate should be greater than 95%");
            assertTrue(p95 < 5000, "95th percentile response time should be less than 5 seconds");
            
        } catch (InterruptedException e) {
            fail("Performance test was interrupted");
        } finally {
            executor.shutdown();
        }
    }
    
    // 3. 负载测试
    @Test
    public void testLoad() {
        // 逐步增加负载的负载测试
        int[] threadCounts = {1, 5, 10, 20};
        Map<Integer, LoadTestResult> results = new HashMap<>();
        
        for (int threadCount : threadCounts) {
            System.out.println("Running load test with " + threadCount + " threads");
            
            LoadTestResult result = runLoadTest(threadCount, 100);
            results.put(threadCount, result);
            
            System.out.println("Success Rate: " + result.getSuccessRate() + "%");
            System.out.println("Average Response Time: " + result.getAvgResponseTime() + " ms");
            System.out.println("95th Percentile: " + result.getP95ResponseTime() + " ms");
            System.out.println("---");
        }
        
        // 验证系统在不同负载下的性能表现
        for (Map.Entry<Integer, LoadTestResult> entry : results.entrySet()) {
            int threadCount = entry.getKey();
            LoadTestResult result = entry.getValue();
            
            // 随着负载增加，成功率不应显著下降
            assertTrue(result.getSuccessRate() > 90, 
                "Success rate should be > 90% with " + threadCount + " threads");
                
            // 响应时间应在合理范围内
            assertTrue(result.getP95ResponseTime() < 10000, 
                "95th percentile should be < 10s with " + threadCount + " threads");
        }
    }
    
    private LoadTestResult runLoadTest(int threadCount, int requestsPerThread) {
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        CountDownLatch latch = new CountDownLatch(threadCount);
        List<Long> responseTimes = Collections.synchronizedList(new ArrayList<>());
        AtomicInteger successCount = new AtomicInteger(0);
        AtomicInteger errorCount = new AtomicInteger(0);
        
        for (int i = 0; i < threadCount; i++) {
            executor.submit(() -> {
                try {
                    for (int j = 0; j < requestsPerThread; j++) {
                        long startTime = System.currentTimeMillis();
                        
                        try {
                            given()
                                .when()
                                .get("/api/data")
                            .then()
                                .statusCode(200);
                                
                            successCount.incrementAndGet();
                        } catch (Exception e) {
                            errorCount.incrementAndGet();
                        }
                        
                        long endTime = System.currentTimeMillis();
                        responseTimes.add(endTime - startTime);
                    }
                } finally {
                    latch.countDown();
                }
            });
        }
        
        try {
            latch.await(60, TimeUnit.SECONDS);
            
            int totalRequests = threadCount * requestsPerThread;
            double successRate = (double) successCount.get() / totalRequests * 100;
            
            Collections.sort(responseTimes);
            double avgResponseTime = responseTimes.stream().mapToLong(Long::longValue).average().orElse(0);
            long p95ResponseTime = responseTimes.get((int) (responseTimes.size() * 0.95));
            
            return new LoadTestResult(
                totalRequests, 
                successCount.get(), 
                errorCount.get(), 
                successRate, 
                avgResponseTime, 
                p95ResponseTime
            );
            
        } catch (InterruptedException e) {
            throw new RuntimeException("Load test interrupted", e);
        } finally {
            executor.shutdown();
        }
    }
    
    // 4. 响应时间监控
    @Test
    public void testResponseTimeMonitoring() {
        // 使用自定义过滤器监控响应时间
        ResponseTimeMonitor monitor = new ResponseTimeMonitor();
        
        given()
            .filter(monitor)
        .when()
            .get("/api/data")
        .then()
            .statusCode(200);
            
        // 获取监控数据
        List<ResponseTimeData> responseTimeData = monitor.getResponseTimeData();
        
        // 验证响应时间数据
        assertEquals(1, responseTimeData.size());
        ResponseTimeData data = responseTimeData.get(0);
        assertTrue(data.getConnectTime() >= 0);
        assertTrue(data.getServiceTime() >= 0);
        assertTrue(data.getTotalTime() >= 0);
        assertTrue(data.getTotalTime() >= data.getConnectTime() + data.getServiceTime());
        
        // 输出详细时间分解
        System.out.println("Connect Time: " + data.getConnectTime() + " ms");
        System.out.println("Service Time: " + data.getServiceTime() + " ms");
        System.out.println("Total Time: " + data.getTotalTime() + " ms");
    }
    
    // 响应时间监控器
    public static class ResponseTimeMonitor implements Filter {
        private List<ResponseTimeData> responseTimeData = new ArrayList<>();
        
        @Override
        public Response filter(FilterableRequestSpecification requestSpec, 
                             FilterableResponseSpecification responseSpec, 
                             FilterContext ctx) {
            long startTime = System.currentTimeMillis();
            
            Response response = ctx.next(requestSpec, responseSpec);
            
            long endTime = System.currentTimeMillis();
            long totalTime = endTime - startTime;
            
            // REST Assured 5.x 可以获取详细的时间分解
            long connectTime = response.getTimeIn(TimeUnit.MILLISECONDS) - response.getTime();
            long serviceTime = response.getTime();
            
            responseTimeData.add(new ResponseTimeData(connectTime, serviceTime, totalTime));
            
            return response;
        }
        
        public List<ResponseTimeData> getResponseTimeData() {
            return Collections.unmodifiableList(responseTimeData);
        }
    }
    
    // 响应时间数据类
    public static class ResponseTimeData {
        private final long connectTime;
        private final long serviceTime;
        private final long totalTime;
        
        public ResponseTimeData(long connectTime, long serviceTime, long totalTime) {
            this.connectTime = connectTime;
            this.serviceTime = serviceTime;
            this.totalTime = totalTime;
        }
        
        public long getConnectTime() { return connectTime; }
        public long getServiceTime() { return serviceTime; }
        public long getTotalTime() { return totalTime; }
    }
    
    // 5. 内存使用监控
    @Test
    public void testMemoryUsage() {
        // 记录测试开始时的内存使用
        Runtime runtime = Runtime.getRuntime();
        long initialMemory = runtime.totalMemory() - runtime.freeMemory();
        
        // 执行大量API请求
        for (int i = 0; i < 100; i++) {
            given()
                .when()
                .get("/api/data")
            .then()
                .statusCode(200);
                
            // 每10次请求强制垃圾回收
            if (i % 10 == 0) {
                System.gc();
                long currentMemory = runtime.totalMemory() - runtime.freeMemory();
                System.out.println("Request " + i + " - Memory usage: " + 
                    (currentMemory / 1024 / 1024) + " MB");
            }
        }
        
        // 强制垃圾回收并检查最终内存使用
        System.gc();
        long finalMemory = runtime.totalMemory() - runtime.freeMemory();
        
        long memoryIncrease = finalMemory - initialMemory;
        double memoryIncreasePercent = (double) memoryIncrease / initialMemory * 100;
        
        System.out.println("Initial memory: " + (initialMemory / 1024 / 1024) + " MB");
        System.out.println("Final memory: " + (finalMemory / 1024 / 1024) + " MB");
        System.out.println("Memory increase: " + (memoryIncrease / 1024 / 1024) + " MB (" + 
            String.format("%.2f", memoryIncreasePercent) + "%)");
        
        // 验证内存增长在可接受范围内
        assertTrue(memoryIncreasePercent < 50, 
            "Memory increase should be less than 50%");
    }
}

// 负载测试结果类
public class LoadTestResult {
    private final int totalRequests;
    private final int successCount;
    private final int errorCount;
    private final double successRate;
    private final double avgResponseTime;
    private final long p95ResponseTime;
    
    public LoadTestResult(int totalRequests, int successCount, int errorCount, 
                         double successRate, double avgResponseTime, long p95ResponseTime) {
        this.totalRequests = totalRequests;
        this.successCount = successCount;
        this.errorCount = errorCount;
        this.successRate = successRate;
        this.avgResponseTime = avgResponseTime;
        this.p95ResponseTime = p95ResponseTime;
    }
    
    // Getters
    public int getTotalRequests() { return totalRequests; }
    public int getSuccessCount() { return successCount; }
    public int getErrorCount() { return errorCount; }
    public double getSuccessRate() { return successRate; }
    public double getAvgResponseTime() { return avgResponseTime; }
    public long getP95ResponseTime() { return p95ResponseTime; }
}
```

### 8.2.2 性能优化技巧

```java
/**
 * REST Assured性能优化技巧
 */
public class RestAssuredPerformanceOptimization {
    
    // 1. 连接池优化
    @Test
    public void testConnectionPoolOptimization() {
        // 配置优化的连接池
        RestAssured.config = RestAssuredConfig.config()
            .connectionConfig(new ConnectionConfig()
                .maxConnections(50)
                .maxConnectionsPerHost(20)
                .closeIdleConnectionsAfterEachResponse(true)  // 每次响应后关闭空闲连接
                .idleConnectionTimeout(30000, TimeUnit.MILLISECONDS)  // 30秒空闲超时
            )
            .httpClient(HttpClientConfig.httpClientConfig()
                .setParam("http.conn-manager.timeout", 5000)  // 连接管理器超时
                .setParam("http.socket.timeout", 10000)  // 套接字超时
                .setParam("http.connection.timeout", 5000)  // 连接超时
            );
            
        // 使用优化的配置执行测试
        long startTime = System.currentTimeMillis();
        
        for (int i = 0; i < 10; i++) {
            given()
                .when()
                .get("/api/data")
            .then()
                .statusCode(200);
        }
        
        long totalTime = System.currentTimeMillis() - startTime;
        double avgTime = (double) totalTime / 10;
        
        System.out.println("Average response time with optimized connection pool: " + avgTime + " ms");
        
        // 验证优化效果
        assertTrue(avgTime < 1000, "Optimized average response time should be less than 1 second");
    }
    
    // 2. 请求重用
    @Test
    public void testRequestReuse() {
        // 创建可重用的请求规范
        RequestSpecification reusableSpec = new RequestSpecBuilder()
            .setBaseUri("https://api.example.com")
            .setBasePath("/v1")
            .setContentType(ContentType.JSON)
            .addHeader("Accept", "application/json")
            .addHeader("User-Agent", "REST Assured Tests")
            .build();
            
        // 重用请求规范执行多个请求
        long startTime = System.currentTimeMillis();
        
        // 使用重用的请求规范
        given()
            .spec(reusableSpec)
        .when()
            .get("/users")
        .then()
            .statusCode(200);
            
        given()
            .spec(reusableSpec)
        .when()
            .get("/products")
        .then()
            .statusCode(200);
            
        long totalTime = System.currentTimeMillis() - startTime;
        
        System.out.println("Total time for two requests with reusable spec: " + totalTime + " ms");
    }
    
    // 3. 批量操作优化
    @Test
    public void testBatchOperationOptimization() {
        // 创建多个用户
        List<User> users = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            users.add(TestDataFactory.aUser().withName("User " + i).build());
        }
        
        // 优化前：逐个创建用户
        long startTime = System.currentTimeMillis();
        
        for (User user : users) {
            given()
                .contentType(ContentType.JSON)
                .body(user)
            .when()
                .post("/users")
            .then()
                .statusCode(201);
        }
        
        long individualTime = System.currentTimeMillis() - startTime;
        
        // 优化后：批量创建用户
        startTime = System.currentTimeMillis();
        
        given()
            .contentType(ContentType.JSON)
            .body(users)
        .when()
            .post("/users/batch")
        .then()
            .statusCode(201);
            
        long batchTime = System.currentTimeMillis() - startTime;
        
        System.out.println("Individual requests time: " + individualTime + " ms");
        System.out.println("Batch request time: " + batchTime + " ms");
        
        // 验证批量操作确实更快
        assertTrue(batchTime < individualTime, "Batch operation should be faster");
    }
    
    // 4. 响应处理优化
    @Test
    public void testResponseProcessingOptimization() {
        // 避免不必要的完整响应提取
        long startTime = System.currentTimeMillis();
        
        // 优化前：提取完整响应
        Response fullResponse = given()
            .when()
            .get("/api/users")
        .then()
            .statusCode(200)
        .extract()
            .response();
            
        List<User> allUsers = fullResponse.jsonPath().getList("users", User.class);
        
        long fullResponseTime = System.currentTimeMillis() - startTime;
        
        // 优化后：只提取需要的数据
        startTime = System.currentTimeMillis();
        
        List<String> userNames = given()
            .when()
            .get("/api/users")
        .then()
            .statusCode(200)
        .extract()
            .jsonPath()
            .getList("users.name");
            
        long optimizedTime = System.currentTimeMillis() - startTime;
        
        System.out.println("Full response processing time: " + fullResponseTime + " ms");
        System.out.println("Optimized response processing time: " + optimizedTime + " ms");
        
        // 验证优化效果
        assertTrue(optimizedTime <= fullResponseTime, "Optimized processing should be faster or equal");
    }
    
    // 5. 并行请求优化
    @Test
    public void testParallelRequestOptimization() {
        // 定义多个需要获取的资源
        String[] resources = {"/users", "/products", "/orders", "/categories"};
        
        // 优化前：串行请求
        long startTime = System.currentTimeMillis();
        
        for (String resource : resources) {
            given()
                .when()
                .get(resource)
            .then()
                .statusCode(200);
        }
        
        long serialTime = System.currentTimeMillis() - startTime;
        
        // 优化后：并行请求
        startTime = System.currentTimeMillis();
        
        ExecutorService executor = Executors.newFixedThreadPool(resources.length);
        List<Future<?>> futures = new ArrayList<>();
        
        for (String resource : resources) {
            futures.add(executor.submit(() -> {
                given()
                    .when()
                    .get(resource)
                .then()
                    .statusCode(200);
            }));
        }
        
        // 等待所有请求完成
        for (Future<?> future : futures) {
            try {
                future.get(10, TimeUnit.SECONDS);
            } catch (Exception e) {
                fail("Parallel request failed: " + e.getMessage());
            }
        }
        
        long parallelTime = System.currentTimeMillis() - startTime;
        
        executor.shutdown();
        
        System.out.println("Serial requests time: " + serialTime + " ms");
        System.out.println("Parallel requests time: " + parallelTime + " ms");
        
        // 验证并行请求确实更快
        assertTrue(parallelTime < serialTime, "Parallel requests should be faster");
    }
    
    // 6. 缓存优化
    @Test
    public void testCachingOptimization() {
        // 配置响应缓存
        ResponseCache cache = new ResponseCache();
        
        // 第一次请求，从服务器获取
        long startTime = System.currentTimeMillis();
        
        given()
            .filter((requestSpec, responseSpec, ctx) -> {
                String cacheKey = generateCacheKey(requestSpec);
                
                // 检查缓存
                if (cache.contains(cacheKey)) {
                    return cache.get(cacheKey);
                }
                
                // 发送请求并缓存响应
                Response response = ctx.next(requestSpec, responseSpec);
                cache.put(cacheKey, response);
                return response;
            })
        .when()
            .get("/api/users")
        .then()
            .statusCode(200);
            
        long firstRequestTime = System.currentTimeMillis() - startTime;
        
        // 第二次请求，从缓存获取
        startTime = System.currentTimeMillis();
        
        given()
            .filter((requestSpec, responseSpec, ctx) -> {
                String cacheKey = generateCacheKey(requestSpec);
                
                // 检查缓存
                if (cache.contains(cacheKey)) {
                    return cache.get(cacheKey);
                }
                
                // 发送请求并缓存响应
                Response response = ctx.next(requestSpec, responseSpec);
                cache.put(cacheKey, response);
                return response;
            })
        .when()
            .get("/api/users")
        .then()
            .statusCode(200);
            
        long cachedRequestTime = System.currentTimeMillis() - startTime;
        
        System.out.println("First request time: " + firstRequestTime + " ms");
        System.out.println("Cached request time: " + cachedRequestTime + " ms");
        
        // 验证缓存请求更快
        assertTrue(cachedRequestTime < firstRequestTime, "Cached request should be faster");
    }
    
    private String generateCacheKey(FilterableRequestSpecification requestSpec) {
        return requestSpec.getMethod() + ":" + requestSpec.getBaseUri() + requestSpec.getDerivedPath();
    }
    
    // 简单响应缓存实现
    public static class ResponseCache {
        private final Map<String, Response> cache = new ConcurrentHashMap<>();
        private final Map<String, Long> timestamps = new ConcurrentHashMap<>();
        private final long maxAge = 60000; // 1分钟缓存
        
        public boolean contains(String key) {
            Long timestamp = timestamps.get(key);
            if (timestamp == null) {
                return false;
            }
            
            // 检查缓存是否过期
            if (System.currentTimeMillis() - timestamp > maxAge) {
                cache.remove(key);
                timestamps.remove(key);
                return false;
            }
            
            return true;
        }
        
        public Response get(String key) {
            return cache.get(key);
        }
        
        public void put(String key, Response response) {
            cache.put(key, response);
            timestamps.put(key, System.currentTimeMillis());
        }
    }
}
```

## 8.3 企业级最佳实践

### 8.3.1 代码组织与维护

```java
/**
 * 企业级REST Assured最佳实践
 */
public class EnterpriseBestPractices {
    
    // 1. 使用页面对象模式组织API测试
    public class EnterpriseApiTestBase {
        protected static TestConfiguration testConfig;
        protected TestDataRepository dataRepository;
        protected RequestSpecification authenticatedRequestSpec;
        
        @BeforeClass
        public static void setUpClass() {
            // 加载测试配置
            testConfig = TestConfiguration.loadFromProperties();
            
            // 配置全局设置
            configureGlobalSettings();
        }
        
        @Before
        public void setUp() {
            // 初始化测试数据仓库
            dataRepository = new TestDataRepository();
            
            // 获取认证令牌并构建认证请求规范
            String authToken = authenticate();
            authenticatedRequestSpec = buildAuthenticatedRequestSpec(authToken);
        }
        
        @After
        public void tearDown() {
            // 清理测试数据
            cleanupTestData();
        }
        
        private void configureGlobalSettings() {
            RestAssured.baseURI = testConfig.getApiBaseUrl();
            RestAssured.basePath = testConfig.getApiBasePath();
            RestAssured.port = testConfig.getApiPort();
            
            // 配置全局日志
            if (testConfig.isEnableLogging()) {
                RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();
            }
            
            // 配置全局过滤器
            RestAssured.filters(
                new RequestLoggingFilter(LogDetail.ALL),
                new ResponseLoggingFilter(LogDetail.ALL)
            );
            
            // 配置SSL设置
            if (testConfig.isRelaxedHTTPSValidation()) {
                RestAssured.useRelaxedHTTPSValidation();
            }
        }
        
        private String authenticate() {
            return given()
                .contentType(ContentType.JSON)
                .body(new LoginRequest(testConfig.getApiUsername(), testConfig.getApiPassword()))
            .when()
                .post("/auth/login")
            .then()
                .statusCode(200)
            .extract()
            .path("token");
        }
        
        private RequestSpecification buildAuthenticatedRequestSpec(String token) {
            return new RequestSpecBuilder()
                .addHeader("Authorization", "Bearer " + token)
                .addHeader("Accept", "application/json")
                .addHeader("X-API-Version", testConfig.getApiVersion())
                .setConnectionConfig(new ConnectionConfig()
                    .maxConnections(testConfig.getMaxConnections())
                    .maxConnectionsPerHost(testConfig.getMaxConnectionsPerHost())
                )
                .build();
        }
        
        private void cleanupTestData() {
            // 清理测试期间创建的数据
            List<Integer> userIdsToDelete = dataRepository.getCreatedUserIds();
            for (Integer userId : userIdsToDelete) {
                try {
                    given()
                        .spec(authenticatedRequestSpec)
                    .when()
                        .delete("/users/" + userId)
                    .then()
                        .statusCode(anyOf(equalTo(200), equalTo(404)));
                } catch (Exception e) {
                    // 记录但不中断清理过程
                    System.err.println("Failed to delete user with ID " + userId + ": " + e.getMessage());
                }
            }
            
            // 清理其他资源...
        }
    }
    
    // 2. 使用数据工厂创建测试数据
    public class EnterpriseTestDataFactory {
        
        // 创建真实感的测试数据
        public static User createRealisticUser() {
            return User.builder()
                .name(generateRealisticName())
                .email(generateRealisticEmail())
                .age(generateRealisticAge())
                .address(generateRealisticAddress())
                .build();
        }
        
        private static String generateRealisticName() {
            String[] firstNames = {"James", "John", "Robert", "Michael", "William", "David", "Richard", "Joseph"};
            String[] lastNames = {"Smith", "Johnson", "Williams", "Brown", "Jones", "Garcia", "Miller", "Davis"};
            
            Random random = new Random();
            return firstNames[random.nextInt(firstNames.length)] + " " + 
                   lastNames[random.nextInt(lastNames.length)];
        }
        
        private static String generateRealisticEmail() {
            String[] domains = {"gmail.com", "yahoo.com", "hotmail.com", "example.com", "test.org"};
            Random random = new Random();
            
            return "user" + (random.nextInt(10000) + 1) + "@" + 
                   domains[random.nextInt(domains.length)];
        }
        
        private static int generateRealisticAge() {
            // 生成18-65之间的年龄
            return new Random().nextInt(48) + 18;
        }
        
        private static Address generateRealisticAddress() {
            String[] streets = {"Main St", "Oak Ave", "Park Blvd", "Elm St", "Washington St"};
            String[] cities = {"New York", "Los Angeles", "Chicago", "Houston", "Phoenix"};
            String[] states = {"NY", "CA", "IL", "TX", "AZ"};
            
            Random random = new Random();
            
            return Address.builder()
                .street(random.nextInt(999) + 1 + " " + streets[random.nextInt(streets.length)])
                .city(cities[random.nextInt(cities.length)])
                .state(states[random.nextInt(states.length)])
                .zipCode(String.format("%05d", random.nextInt(90000) + 10000))
                .build();
        }
        
        // 创建完整的测试场景
        public static TestScenario createCompleteEcommerceScenario() {
            TestScenario scenario = new TestScenario();
            
            // 创建用户
            User user = createRealisticUser();
            scenario.setPrimaryUser(user);
            
            // 创建产品
            List<Product> products = new ArrayList<>();
            for (int i = 0; i < 5; i++) {
                Product product = Product.builder()
                    .name("Product " + (i + 1))
                    .price(10.0 + new Random().nextDouble() * 990.0)
                    .category(getRandomCategory())
                    .inStock(new Random().nextBoolean())
                    .build();
                products.add(product);
            }
            scenario.setProducts(products);
            
            // 创建订单
            List<OrderItem> orderItems = products.stream()
                .filter(Product::isInStock)
                .limit(2)
                .map(p -> new OrderItem(p.getId(), new Random().nextInt(3) + 1))
                .collect(Collectors.toList());
                
            if (!orderItems.isEmpty()) {
                Order order = Order.builder()
                    .userId(user.getId())
                    .items(orderItems)
                    .status(OrderStatus.PENDING)
                    .orderDate(new Date())
                    .build();
                scenario.setOrder(order);
            }
            
            return scenario;
        }
        
        private static String getRandomCategory() {
            String[] categories = {"electronics", "clothing", "books", "home", "sports"};
            return categories[new Random().nextInt(categories.length)];
        }
    }
    
    // 3. 实现测试数据隔离
    public class TestIsolationStrategy {
        
        // 使用测试特定命名空间隔离数据
        @Before
        public void setUpTestIsolation() {
            String testNamespace = "test_" + System.currentTimeMillis();
            
            // 将命名空间添加到请求头
            RestAssured.requestSpecification = RestAssured.given()
                .header("X-Test-Namespace", testNamespace);
        }
        
        // 使用事务回滚隔离数据
        @Test
        @Transactional
        public void testWithTransactionRollback() {
            // 在事务中创建数据
            User user = EnterpriseTestDataFactory.createRealisticUser();
            
            Response createResponse = given()
                .contentType(ContentType.JSON)
                .body(user)
            .when()
                .post("/users");
                
            createResponse.then().statusCode(201);
            
            // 验证数据存在
            int userId = createResponse.jsonPath().getInt("id");
            
            given()
                .pathParam("userId", userId)
            .when()
                .get("/users/{userId}")
            .then()
                .statusCode(200);
                
            // 测试结束后事务自动回滚，数据不会持久化
        }
        
        // 使用数据清理策略隔离数据
        @After
        public void cleanupTestData() {
            // 获取测试期间创建的所有资源ID
            List<Integer> createdUserIds = getCreatedUserIds();
            List<Integer> createdProductIds = getCreatedProductIds();
            List<Integer> createdOrderIds = getCreatedOrderIds();
            
            // 清理创建的资源
            cleanupResources("/users/", createdUserIds);
            cleanupResources("/products/", createdProductIds);
            cleanupResources("/orders/", createdOrderIds);
        }
        
        private void cleanupResources(String endpoint, List<Integer> ids) {
            for (Integer id : ids) {
                try {
                    given()
                    .when()
                        .delete(endpoint + id)
                    .then()
                        .statusCode(anyOf(equalTo(200), equalTo(404)));
                } catch (Exception e) {
                    System.err.println("Failed to delete resource " + endpoint + id + ": " + e.getMessage());
                }
            }
        }
        
        private List<Integer> getCreatedUserIds() {
            // 实现获取测试期间创建的用户ID的逻辑
            return Collections.emptyList();
        }
        
        private List<Integer> getCreatedProductIds() {
            // 实现获取测试期间创建的产品ID的逻辑
            return Collections.emptyList();
        }
        
        private List<Integer> getCreatedOrderIds() {
            // 实现获取测试期间创建的订单ID的逻辑
            return Collections.emptyList();
        }
    }
    
    // 4. 使用数据驱动测试
    @RunWith(Parameterized.class)
    public class DataDrivenUserValidationTest {
        
        private final User testUser;
        private final boolean expectedValidationResult;
        
        public DataDrivenUserValidationTest(User testUser, boolean expectedValidationResult) {
            this.testUser = testUser;
            this.expectedValidationResult = expectedValidationResult;
        }
        
        @Parameterized.Parameters(name = "{index}: User({0}) - Expected: {1}")
        public static Collection<Object[]> userData() {
            return Arrays.asList(new Object[][] {
                // 有效用户数据
                {EnterpriseTestDataFactory.createRealisticUser(), true},
                {User.builder().name("Valid User").email("valid@example.com").age(25).build(), true},
                
                // 无效用户数据
                {User.builder().name("").email("invalid@example.com").age(25).build(), false},
                {User.builder().name("Valid User").email("invalid-email").age(25).build(), false},
                {User.builder().name("Valid User").email("valid@example.com").age(17).build(), false},
                {User.builder().name("Valid User").email("valid@example.com").age(150).build(), false}
            });
        }
        
        @Test
        public void testUserValidation() {
            Response response = given()
                .contentType(ContentType.JSON)
                .body(testUser)
            .when()
                .post("/users/validate")
            .then()
            .extract()
            .response();
            
            if (expectedValidationResult) {
                response.then()
                    .statusCode(200)
                    .body("valid", equalTo(true));
            } else {
                response.then()
                    .statusCode(400)
                    .body("valid", equalTo(false));
            }
        }
    }
    
    // 5. 实现测试环境管理
    public class TestEnvironmentManager {
        
        private static final Logger logger = LoggerFactory.getLogger(TestEnvironmentManager.class);
        private static TestEnvironment currentEnvironment;
        
        public static void setupTestEnvironment(String environmentName) {
            logger.info("Setting up test environment: {}", environmentName);
            
            try {
                // 根据环境名称加载配置
                TestEnvironmentConfig config = loadEnvironmentConfig(environmentName);
                
                // 初始化环境
                initializeEnvironment(config);
                
                // 验证环境健康状态
                verifyEnvironmentHealth();
                
                currentEnvironment = new TestEnvironment(environmentName, config);
                logger.info("Test environment {} is ready", environmentName);
                
            } catch (Exception e) {
                logger.error("Failed to setup test environment: {}", environmentName, e);
                throw new RuntimeException("Environment setup failed", e);
            }
        }
        
        public static void teardownTestEnvironment() {
            if (currentEnvironment != null) {
                logger.info("Tearing down test environment: {}", currentEnvironment.getName());
                
                try {
                    // 清理测试数据
                    cleanupEnvironmentData();
                    
                    // 执行环境特定的清理
                    performEnvironmentSpecificCleanup();
                    
                    logger.info("Test environment {} has been torn down", currentEnvironment.getName());
                    
                } catch (Exception e) {
                    logger.error("Failed to teardown test environment: {}", currentEnvironment.getName(), e);
                } finally {
                    currentEnvironment = null;
                }
            }
        }
        
        private static TestEnvironmentConfig loadEnvironmentConfig(String environmentName) {
            // 实现从配置文件或服务加载环境配置
            return new TestEnvironmentConfig();
        }
        
        private static void initializeEnvironment(TestEnvironmentConfig config) {
            // 实现环境初始化逻辑
            // 例如：启动Docker容器、配置数据库、初始化测试数据等
        }
        
        private static void verifyEnvironmentHealth() {
            // 实现环境健康检查
            given()
                .get("/health")
            .then()
                .statusCode(200);
        }
        
        private static void cleanupEnvironmentData() {
            // 实现测试数据清理
        }
        
        private static void performEnvironmentSpecificCleanup() {
            // 实现环境特定的清理
        }
    }
}
```

### 8.3.2 测试报告与监控

```java
/**
 * 企业级测试报告与监控
 */
public class EnterpriseTestReporting {
    
    // 1. 综合测试报告生成器
    public class ComprehensiveTestReportGenerator {
        
        public void generateReport(TestExecutionResult result, String outputPath) {
            try {
                // 生成HTML报告
                generateHtmlReport(result, outputPath + "/report.html");
                
                // 生成JSON报告
                generateJsonReport(result, outputPath + "/report.json");
                
                // 生成Excel报告
                generateExcelReport(result, outputPath + "/report.xlsx");
                
                // 生成趋势图表
                generateTrendCharts(result, outputPath + "/trends/");
                
            } catch (Exception e) {
                throw new RuntimeException("Failed to generate comprehensive test report", e);
            }
        }
        
        private void generateHtmlReport(TestExecutionResult result, String outputPath) throws IOException {
            // 使用模板引擎生成HTML报告
            Map<String, Object> templateData = new HashMap<>();
            templateData.put("testResult", result);
            templateData.put("generatedAt", new Date());
            templateData.put("environment", System.getProperty("test.environment", "unknown"));
            
            String htmlContent = TemplateEngine.render("test-report-template.html", templateData);
            
            try (FileWriter writer = new FileWriter(outputPath)) {
                writer.write(htmlContent);
            }
        }
        
        private void generateJsonReport(TestExecutionResult result, String outputPath) throws IOException {
            ObjectMapper mapper = new ObjectMapper();
            try (FileWriter writer = new FileWriter(outputPath)) {
                writer.write(mapper.writerWithDefaultPrettyPrinter().writeValueAsString(result));
            }
        }
        
        private void generateExcelReport(TestExecutionResult result, String outputPath) {
            // 使用Apache POI或类似库生成Excel报告
            // 实现细节省略
        }
        
        private void generateTrendCharts(TestExecutionResult result, String outputDir) {
            // 生成趋势图表
            // 实现细节省略
        }
    }
    
    // 2. 测试执行结果数据结构
    public class TestExecutionResult {
        private String suiteName;
        private Date startTime;
        private Date endTime;
        private long duration;
        private List<TestResult> testResults = new ArrayList<>();
        private Map<String, Object> environmentInfo = new HashMap<>();
        private Map<String, Object> testMetrics = new HashMap<>();
        
        // 计算属性
        public int getTotalTests() {
            return testResults.size();
        }
        
        public int getPassedTests() {
            return (int) testResults.stream().filter(TestResult::isPassed).count();
        }
        
        public int getFailedTests() {
            return (int) testResults.stream().filter(r -> !r.isPassed()).count();
        }
        
        public int getSkippedTests() {
            return (int) testResults.stream().filter(TestResult::isSkipped).count();
        }
        
        public double getSuccessRate() {
            return getTotalTests() > 0 ? (double) getPassedTests() / getTotalTests() * 100 : 0;
        }
        
        public long getAverageResponseTime() {
            return testResults.stream()
                .filter(r -> r.getResponseTime() > 0)
                .mapToLong(TestResult::getResponseTime)
                .sum() / Math.max(1, getPassedTests());
        }
        
        public Map<String, Integer> getTestsByCategory() {
            return testResults.stream()
                .flatMap(r -> r.getCategories().stream())
                .collect(Collectors.groupingBy(
                    Function.identity(),
                    Collectors.collectingAndThen(Collectors.counting(), Math::toIntExact)
                ));
        }
        
        // Getters and setters
        public String getSuiteName() { return suiteName; }
        public void setSuiteName(String suiteName) { this.suiteName = suiteName; }
        public Date getStartTime() { return startTime; }
        public void setStartTime(Date startTime) { this.startTime = startTime; }
        public Date getEndTime() { return endTime; }
        public void setEndTime(Date endTime) { this.endTime = endTime; }
        public long getDuration() { return duration; }
        public void setDuration(long duration) { this.duration = duration; }
        public List<TestResult> getTestResults() { return testResults; }
        public void setTestResults(List<TestResult> testResults) { this.testResults = testResults; }
        public Map<String, Object> getEnvironmentInfo() { return environmentInfo; }
        public void setEnvironmentInfo(Map<String, Object> environmentInfo) { this.environmentInfo = environmentInfo; }
        public Map<String, Object> getTestMetrics() { return testMetrics; }
        public void setTestMetrics(Map<String, Object> testMetrics) { this.testMetrics = testMetrics; }
    }
    
    // 3. 实时测试监控
    public class RealTimeTestMonitor {
        
        private WebSocketClient webSocketClient;
        private List<TestEventListener> listeners = new ArrayList<>();
        
        public void startMonitoring(String monitorUrl) {
            try {
                webSocketClient = new StandardWebSocketClient();
                
                WebSocketSession session = webSocketClient.doHandshake(
                    new WebSocketHandler() {
                        @Override
                        public void afterConnectionEstablished(WebSocketSession session) {
                            System.out.println("Connected to test monitor");
                        }
                        
                        @Override
                        public void handleMessage(WebSocketSession session, WebSocketMessage<?> message) {
                            TestEvent event = parseTestEvent(message.getPayload().toString());
                            notifyListeners(event);
                        }
                        
                        @Override
                        public void handleTransportError(WebSocketSession session, Throwable exception) {
                            System.err.println("Test monitor error: " + exception.getMessage());
                        }
                        
                        @Override
                        public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) {
                            System.out.println("Disconnected from test monitor");
                        }
                        
                        @Override
                        public boolean supportsPartialMessages() {
                            return false;
                        }
                    }, 
                    null, 
                    monitorUrl
                ).get();
                
            } catch (Exception e) {
                throw new RuntimeException("Failed to start test monitoring", e);
            }
        }
        
        public void stopMonitoring() {
            if (webSocketClient != null) {
                try {
                    webSocketClient.stop();
                } catch (Exception e) {
                    System.err.println("Failed to stop test monitoring: " + e.getMessage());
                }
            }
        }
        
        public void addListener(TestEventListener listener) {
            listeners.add(listener);
        }
        
        private void notifyListeners(TestEvent event) {
            for (TestEventListener listener : listeners) {
                listener.onTestEvent(event);
            }
        }
        
        private TestEvent parseTestEvent(String eventJson) {
            try {
                ObjectMapper mapper = new ObjectMapper();
                return mapper.readValue(eventJson, TestEvent.class);
            } catch (Exception e) {
                throw new RuntimeException("Failed to parse test event: " + eventJson, e);
            }
        }
    }
    
    // 4. 测试事件监听器
    public interface TestEventListener {
        void onTestEvent(TestEvent event);
    }
    
    public class TestEventLogger implements TestEventListener {
        private static final Logger logger = LoggerFactory.getLogger(TestEventLogger.class);
        
        @Override
        public void onTestEvent(TestEvent event) {
            logger.info("Test event: {} - {} ({} ms)", 
                event.getTestName(), 
                event.getStatus(), 
                event.getDuration());
        }
    }
    
    public class TestEventDatabaseLogger implements TestEventListener {
        private TestEventRepository eventRepository;
        
        public TestEventDatabaseLogger(TestEventRepository eventRepository) {
            this.eventRepository = eventRepository;
        }
        
        @Override
        public void onTestEvent(TestEvent event) {
            eventRepository.save(event);
        }
    }
    
    public class TestEventAlerting implements TestEventListener {
        private static final Logger logger = LoggerFactory.getLogger(TestEventAlerting.class);
        private AlertService alertService;
        
        public TestEventAlerting(AlertService alertService) {
            this.alertService = alertService;
        }
        
        @Override
        public void onTestEvent(TestEvent event) {
            if ("FAILED".equals(event.getStatus())) {
                logger.warn("Test failed: {}", event.getTestName());
                alertService.sendTestFailureAlert(event);
            }
        }
    }
    
    // 5. 测试指标收集
    public class TestMetricsCollector {
        
        private MetricRegistry metricRegistry = new MetricRegistry();
        private Timer responseTimer;
        private Histogram responseSizeHistogram;
        private Meter successMeter;
        private Meter failureMeter;
        private Counter testCounter;
        
        public TestMetricsCollector() {
            responseTimer = metricRegistry.timer("test.response.time");
            responseSizeHistogram = metricRegistry.histogram("test.response.size");
            successMeter = metricRegistry.meter("test.success.rate");
            failureMeter = metricRegistry.meter("test.failure.rate");
            testCounter = metricRegistry.counter("test.total.count");
        }
        
        public void recordTestExecution(TestResult testResult) {
            Timer.Context timerContext = responseTimer.time();
            
            try {
                // 记录测试数量
                testCounter.inc();
                
                // 记录响应时间
                if (testResult.getResponseTime() > 0) {
                    responseTimer.update(testResult.getResponseTime(), TimeUnit.MILLISECONDS);
                }
                
                // 记录响应大小
                if (testResult.getResponseSize() > 0) {
                    responseSizeHistogram.update(testResult.getResponseSize());
                }
                
                // 记录成功/失败率
                if (testResult.isPassed()) {
                    successMeter.mark();
                } else {
                    failureMeter.mark();
                }
                
            } finally {
                timerContext.stop();
            }
        }
        
        public TestMetricsSnapshot getMetricsSnapshot() {
            return new TestMetricsSnapshot(
                testCounter.getCount(),
                successMeter.getCount(),
                failureMeter.getCount(),
                responseTimer.getSnapshot().getMean(),
                responseTimer.getSnapshot().get95thPercentile(),
                responseSizeHistogram.getSnapshot().getMean()
            );
        }
        
        public void exportMetrics(String format, OutputStream outputStream) {
            if ("json".equals(format)) {
                exportMetricsAsJson(outputStream);
            } else if ("csv".equals(format)) {
                exportMetricsAsCsv(outputStream);
            }
        }
        
        private void exportMetricsAsJson(OutputStream outputStream) {
            // 实现JSON格式导出
            try {
                ObjectMapper mapper = new ObjectMapper();
                Map<String, Object> metrics = new HashMap<>();
                
                metrics.put("test.total.count", testCounter.getCount());
                metrics.put("test.success.rate", successMeter.getCount());
                metrics.put("test.failure.rate", failureMeter.getCount());
                metrics.put("test.response.time.mean", responseTimer.getSnapshot().getMean());
                metrics.put("test.response.time.p95", responseTimer.getSnapshot().get95thPercentile());
                metrics.put("test.response.size.mean", responseSizeHistogram.getSnapshot().getMean());
                
                mapper.writeValue(outputStream, metrics);
            } catch (Exception e) {
                throw new RuntimeException("Failed to export metrics as JSON", e);
            }
        }
        
        private void exportMetricsAsCsv(OutputStream outputStream) {
            // 实现CSV格式导出
            try (PrintWriter writer = new PrintWriter(new OutputStreamWriter(outputStream))) {
                writer.println("metric,value");
                writer.println("test.total.count," + testCounter.getCount());
                writer.println("test.success.rate," + successMeter.getCount());
                writer.println("test.failure.rate," + failureMeter.getCount());
                writer.println("test.response.time.mean," + responseTimer.getSnapshot().getMean());
                writer.println("test.response.time.p95," + responseTimer.getSnapshot().get95thPercentile());
                writer.println("test.response.size.mean," + responseSizeHistogram.getSnapshot().getMean());
            } catch (Exception e) {
                throw new RuntimeException("Failed to export metrics as CSV", e);
            }
        }
    }
}
```

## 8.4 实践练习

### 练习1：实现企业级测试框架

设计并实现一个完整的企业级REST Assured测试框架，包括：
- 多环境支持
- 测试数据隔离
- 综合报告生成
- 实时监控

### 练习2：性能测试与优化

实现一个性能测试套件，包括：
- 负载测试
- 响应时间分析
- 资源使用监控
- 性能优化建议

### 练习3：持续集成集成

将REST Assured测试集成到CI/CD流程中，包括：
- 自动化测试执行
- 测试结果通知
- 测试报告归档
- 失败分析

## 8.5 总结

本章深入探讨了REST Assured的高级特性和企业级最佳实践，包括：

1. **REST Assured高级特性** - 掌握高级请求配置、响应处理和JSON/XML处理技术
2. **性能测试与优化** - 学习性能测试方法和优化技巧
3. **企业级最佳实践** - 了解代码组织、测试报告和监控的企业级解决方案

通过本章的学习，您应该能够设计和实现专业级的REST Assured测试框架，满足企业级应用的测试需求，并能够进行性能测试和优化，生成全面的测试报告和监控。

## 结语

恭喜您完成了REST Assured从入门到专家的完整学习旅程！通过这8个章节的学习，您已经掌握了：

1. REST Assured的基础概念和环境搭建
2. 核心语法和请求构建技巧
3. 响应验证与断言方法
4. JSON与XML数据处理技术
5. 身份验证与安全测试
6. 测试框架设计与组织
7. 高级特性和最佳实践

现在，您应该能够设计、构建和维护专业级的REST API测试框架，满足各种复杂场景的需求。祝您在API测试领域取得更大的成功！