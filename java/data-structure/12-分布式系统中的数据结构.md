# 第十二章：分布式系统中的数据结构

## 本章概要

本章将探讨分布式系统中特有的数据结构和算法，包括：
- 分布式哈希表（DHT）
- 一致性哈希
- Raft共识算法
- 分布式锁
- 分布式缓存
- 分布式队列
- 分布式事务处理
- 实际应用案例分析

## 12.1 分布式系统概述

### 12.1.1 分布式系统的特点

分布式系统是由多台计算机通过网络连接组成的系统，具有以下特点：
1. **并发性**：多个节点可以同时执行任务
2. **缺乏全局时钟**：节点之间没有统一的时间标准
3. **独立故障**：单个节点的故障不会影响整个系统
4. **消息传递**：节点之间通过消息进行通信

### 12.1.2 分布式系统面临的挑战

1. **网络分区**：网络故障导致部分节点无法通信
2. **节点故障**：单个节点可能随时崩溃
3. **消息丢失**：网络传输过程中消息可能丢失
4. **延迟**：网络通信存在延迟
5. **一致性**：保持数据在多个节点间的一致性

## 12.2 分布式哈希表（DHT）

### 12.2.1 DHT的基本概念

分布式哈希表是一种分布式系统，提供了一个类似于哈希表的接口，但数据存储在分布式网络中的多个节点上。

### 12.2.2 DHT的特点

1. **去中心化**：没有中心节点控制整个系统
2. **可扩展性**：可以动态添加或删除节点
3. **容错性**：单个节点故障不会影响整个系统
4. **负载均衡**：数据均匀分布在各个节点上

### 12.2.3 常见的DHT实现

1. **Chord**：基于环形拓扑的DHT
2. **Kademlia**：基于异或距离的DHT
3. **Pastry**：基于前缀匹配的DHT

```java
// 简化的DHT节点实现
public class DHTNode {
    private String nodeId;
    private Map<String, String> localData;
    private DHTNode successor;
    private DHTNode predecessor;
    
    public DHTNode(String nodeId) {
        this.nodeId = nodeId;
        this.localData = new HashMap<>();
    }
    
    // 存储键值对
    public void put(String key, String value) {
        String targetNode = findNode(key);
        if (targetNode.equals(this.nodeId)) {
            localData.put(key, value);
        } else {
            // 转发到目标节点
            forwardPut(targetNode, key, value);
        }
    }
    
    // 获取值
    public String get(String key) {
        String targetNode = findNode(key);
        if (targetNode.equals(this.nodeId)) {
            return localData.get(key);
        } else {
            // 转发到目标节点
            return forwardGet(targetNode, key);
        }
    }
    
    // 查找负责该键的节点
    private String findNode(String key) {
        // 简化实现：使用哈希函数确定节点
        return hashKey(key);
    }
    
    // 哈希函数
    private String hashKey(String key) {
        // 简化实现
        return String.valueOf(key.hashCode() % 1000);
    }
    
    // 转发PUT请求
    private void forwardPut(String targetNodeId, String key, String value) {
        // 在实际实现中，这里会将请求转发到目标节点
        System.out.println("Forwarding PUT request to node " + targetNodeId);
    }
    
    // 转发GET请求
    private String forwardGet(String targetNodeId, String key) {
        // 在实际实现中，这里会将请求转发到目标节点
        System.out.println("Forwarding GET request to node " + targetNodeId);
        return null;
    }
    
    // Getters and setters
    public String getNodeId() { return nodeId; }
    public void setSuccessor(DHTNode successor) { this.successor = successor; }
    public void setPredecessor(DHTNode predecessor) { this.predecessor = predecessor; }
}
```

## 12.3 一致性哈希

### 12.3.1 一致性哈希原理

一致性哈希是一种特殊的哈希算法，当哈希表的大小发生变化时，平均只需要重新映射K/n个键值，其中K是键的数量，n是槽的数量。

### 12.3.2 一致性哈希的优势

1. **负载均衡**：数据均匀分布在各个节点上
2. **可扩展性**：添加或删除节点时，只需要重新分配少量数据
3. **容错性**：节点故障时，只影响相邻节点的数据

```java
import java.util.*;

// 一致性哈希实现
public class ConsistentHashing {
    private TreeMap<Integer, String> circle = new TreeMap<>();
    private List<String> nodes;
    private int numberOfReplicas; // 虚拟节点数量
    
    public ConsistentHashing(List<String> nodes, int numberOfReplicas) {
        this.nodes = nodes;
        this.numberOfReplicas = numberOfReplicas;
        
        // 初始化哈希环
        for (String node : nodes) {
            addNode(node);
        }
    }
    
    // 添加节点
    public void addNode(String node) {
        for (int i = 0; i < numberOfReplicas; i++) {
            // 为每个节点创建虚拟节点
            circle.put((node + i).hashCode(), node);
        }
    }
    
    // 删除节点
    public void removeNode(String node) {
        for (int i = 0; i < numberOfReplicas; i++) {
            circle.remove((node + i).hashCode());
        }
    }
    
    // 获取负责该键的节点
    public String getNode(String key) {
        if (circle.isEmpty()) {
            return null;
        }
        
        int hash = key.hashCode();
        // 顺时针找到第一个节点
        SortedMap<Integer, String> tailMap = circle.tailMap(hash);
        int nodeHash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey();
        return circle.get(nodeHash);
    }
    
    // 测试一致性哈希
    public static void main(String[] args) {
        List<String> nodes = Arrays.asList("node1", "node2", "node3");
        ConsistentHashing consistentHashing = new ConsistentHashing(nodes, 3);
        
        // 测试数据分布
        Map<String, Integer> distribution = new HashMap<>();
        for (int i = 0; i < 100; i++) {
            String key = "key" + i;
            String node = consistentHashing.getNode(key);
            distribution.put(node, distribution.getOrDefault(node, 0) + 1);
        }
        
        System.out.println("数据分布情况:");
        for (Map.Entry<String, Integer> entry : distribution.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue() + " keys");
        }
        
        // 添加新节点
        System.out.println("\n添加新节点后:");
        consistentHashing.addNode("node4");
        Map<String, Integer> newDistribution = new HashMap<>();
        for (int i = 0; i < 100; i++) {
            String key = "key" + i;
            String node = consistentHashing.getNode(key);
            newDistribution.put(node, newDistribution.getOrDefault(node, 0) + 1);
        }
        
        for (Map.Entry<String, Integer> entry : newDistribution.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue() + " keys");
        }
    }
}
```

## 12.4 Raft共识算法

### 12.4.1 Raft算法概述

Raft是一种用于管理复制日志的一致性算法，旨在易于理解和实现。它将一致性问题分解为几个相对独立的子问题：
1. 领导人选举
2. 日志复制
3. 安全性

### 12.4.2 Raft节点状态

1. **领导人（Leader）**：处理所有客户端请求
2. **候选人（Candidate）**：参与领导人选举
3. **跟随者（Follower）**：响应领导人和候选人的请求

```java
// 简化的Raft节点实现
public class RaftNode {
    // 节点状态枚举
    enum State {
        FOLLOWER, CANDIDATE, LEADER
    }
    
    private State state;
    private int currentTerm;
    private String votedFor;
    private List<LogEntry> log;
    private int commitIndex;
    private int lastApplied;
    private Map<String, Integer> nextIndex;
    private Map<String, Integer> matchIndex;
    private String nodeId;
    private List<String> peers;
    private long lastHeartbeat;
    private long electionTimeout;
    
    public RaftNode(String nodeId, List<String> peers) {
        this.nodeId = nodeId;
        this.peers = peers;
        this.state = State.FOLLOWER;
        this.currentTerm = 0;
        this.log = new ArrayList<>();
        this.commitIndex = 0;
        this.lastApplied = 0;
        this.nextIndex = new HashMap<>();
        this.matchIndex = new HashMap<>();
        this.lastHeartbeat = System.currentTimeMillis();
        this.electionTimeout = 150 + new Random().nextInt(150); // 150-300ms
        
        // 初始化跟随者索引
        for (String peer : peers) {
            if (!peer.equals(nodeId)) {
                nextIndex.put(peer, 1);
                matchIndex.put(peer, 0);
            }
        }
    }
    
    // 服务器规则
    public void run() {
        while (true) {
            switch (state) {
                case FOLLOWER:
                    followerLogic();
                    break;
                case CANDIDATE:
                    candidateLogic();
                    break;
                case LEADER:
                    leaderLogic();
                    break;
            }
        }
    }
    
    // 跟随者逻辑
    private void followerLogic() {
        long now = System.currentTimeMillis();
        if (now - lastHeartbeat > electionTimeout) {
            // 超时，转换为候选人
            becomeCandidate();
        }
        
        // 模拟处理请求
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    // 候选人逻辑
    private void candidateLogic() {
        // 开始选举
        currentTerm++;
        votedFor = nodeId;
        int votesReceived = 1; // 自己的一票
        
        // 向其他节点发送投票请求
        for (String peer : peers) {
            if (!peer.equals(nodeId)) {
                if (requestVote(peer)) {
                    votesReceived++;
                }
            }
        }
        
        // 检查是否获得多数票
        if (votesReceived > peers.size() / 2) {
            becomeLeader();
        } else {
            // 选举失败，重新开始
            state = State.FOLLOWER;
        }
    }
    
    // 领导人逻辑
    private void leaderLogic() {
        // 发送心跳
        sendHeartbeat();
        
        // 模拟处理客户端请求
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    // 转换为候选人
    private void becomeCandidate() {
        state = State.CANDIDATE;
        System.out.println(nodeId + " became candidate");
    }
    
    // 转换为领导人
    private void becomeLeader() {
        state = State.LEADER;
        System.out.println(nodeId + " became leader");
    }
    
    // 请求投票
    private boolean requestVote(String peer) {
        // 简化实现：随机返回投票结果
        return new Random().nextBoolean();
    }
    
    // 发送心跳
    private void sendHeartbeat() {
        lastHeartbeat = System.currentTimeMillis();
        // 在实际实现中，这里会向所有跟随者发送心跳消息
        System.out.println(nodeId + " sending heartbeat");
    }
    
    // 处理投票请求
    public VoteResponse handleRequestVote(VoteRequest request) {
        if (request.getTerm() < currentTerm) {
            return new VoteResponse(currentTerm, false);
        }
        
        if ((votedFor == null || votedFor.equals(request.getCandidateId())) && 
            request.getLastLogIndex() >= getLastLogIndex()) {
            votedFor = request.getCandidateId();
            lastHeartbeat = System.currentTimeMillis();
            return new VoteResponse(currentTerm, true);
        }
        
        return new VoteResponse(currentTerm, false);
    }
    
    // 处理追加条目请求
    public AppendEntriesResponse handleAppendEntries(AppendEntriesRequest request) {
        if (request.getTerm() < currentTerm) {
            return new AppendEntriesResponse(currentTerm, false);
        }
        
        lastHeartbeat = System.currentTimeMillis();
        state = State.FOLLOWER;
        currentTerm = request.getTerm();
        
        // 在实际实现中，这里会处理日志条目
        return new AppendEntriesResponse(currentTerm, true);
    }
    
    // 获取最后日志索引
    private int getLastLogIndex() {
        return log.size() > 0 ? log.size() - 1 : -1;
    }
    
    // 内部类：日志条目
    static class LogEntry {
        private int term;
        private String command;
        
        public LogEntry(int term, String command) {
            this.term = term;
            this.command = command;
        }
        
        // Getters
        public int getTerm() { return term; }
        public String getCommand() { return command; }
    }
    
    // 内部类：投票请求
    static class VoteRequest {
        private int term;
        private String candidateId;
        private int lastLogIndex;
        private int lastLogTerm;
        
        public VoteRequest(int term, String candidateId, int lastLogIndex, int lastLogTerm) {
            this.term = term;
            this.candidateId = candidateId;
            this.lastLogIndex = lastLogIndex;
            this.lastLogTerm = lastLogTerm;
        }
        
        // Getters
        public int getTerm() { return term; }
        public String getCandidateId() { return candidateId; }
        public int getLastLogIndex() { return lastLogIndex; }
        public int getLastLogTerm() { return lastLogTerm; }
    }
    
    // 内部类：投票响应
    static class VoteResponse {
        private int term;
        private boolean voteGranted;
        
        public VoteResponse(int term, boolean voteGranted) {
            this.term = term;
            this.voteGranted = voteGranted;
        }
        
        // Getters
        public int getTerm() { return term; }
        public boolean isVoteGranted() { return voteGranted; }
    }
    
    // 内部类：追加条目请求
    static class AppendEntriesRequest {
        private int term;
        private String leaderId;
        private int prevLogIndex;
        private int prevLogTerm;
        private List<LogEntry> entries;
        private int leaderCommit;
        
        public AppendEntriesRequest(int term, String leaderId, int prevLogIndex, 
                                  int prevLogTerm, List<LogEntry> entries, int leaderCommit) {
            this.term = term;
            this.leaderId = leaderId;
            this.prevLogIndex = prevLogIndex;
            this.prevLogTerm = prevLogTerm;
            this.entries = entries;
            this.leaderCommit = leaderCommit;
        }
        
        // Getters
        public int getTerm() { return term; }
        public String getLeaderId() { return leaderId; }
        public int getPrevLogIndex() { return prevLogIndex; }
        public int getPrevLogTerm() { return prevLogTerm; }
        public List<LogEntry> getEntries() { return entries; }
        public int getLeaderCommit() { return leaderCommit; }
    }
    
    // 内部类：追加条目响应
    static class AppendEntriesResponse {
        private int term;
        private boolean success;
        
        public AppendEntriesResponse(int term, boolean success) {
            this.term = term;
            this.success = success;
        }
        
        // Getters
        public int getTerm() { return term; }
        public boolean isSuccess() { return success; }
    }
}
```

## 12.5 分布式锁

### 12.5.1 分布式锁的概念

分布式锁是分布式系统中用于控制多个节点对共享资源访问的同步机制。

### 12.5.2 分布式锁的实现方式

1. **基于数据库**：利用数据库的唯一约束实现
2. **基于Redis**：利用Redis的原子操作实现
3. **基于ZooKeeper**：利用临时顺序节点实现

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

// 基于Redis的分布式锁实现
public class RedisDistributedLock implements Lock {
    private RedisClient redisClient;
    private String lockKey;
    private String lockValue;
    private long expireTime;
    
    public RedisDistributedLock(RedisClient redisClient, String lockKey, long expireTime) {
        this.redisClient = redisClient;
        this.lockKey = lockKey;
        this.expireTime = expireTime;
        this.lockValue = java.util.UUID.randomUUID().toString();
    }
    
    @Override
    public void lock() {
        while (true) {
            if (tryLock()) {
                return;
            }
            // 等待一段时间后重试
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return;
            }
        }
    }
    
    @Override
    public void lockInterruptibly() throws InterruptedException {
        while (true) {
            if (tryLock()) {
                return;
            }
            if (Thread.currentThread().isInterrupted()) {
                throw new InterruptedException();
            }
            Thread.sleep(100);
        }
    }
    
    @Override
    public boolean tryLock() {
        // 使用SET命令的NX和EX选项实现原子加锁
        String result = redisClient.set(lockKey, lockValue, "NX", "EX", expireTime);
        return "OK".equals(result);
    }
    
    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        long timeout = unit.toMillis(time);
        long start = System.currentTimeMillis();
        
        while (true) {
            if (tryLock()) {
                return true;
            }
            if (System.currentTimeMillis() - start > timeout) {
                return false;
            }
            if (Thread.currentThread().isInterrupted()) {
                throw new InterruptedException();
            }
            Thread.sleep(100);
        }
    }
    
    @Override
    public void unlock() {
        // 使用Lua脚本确保原子性
        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                       "return redis.call('del', KEYS[1]) " +
                       "else return 0 end";
        redisClient.eval(script, 1, lockKey, lockValue);
    }
    
    @Override
    public Condition newCondition() {
        throw new UnsupportedOperationException("RedisDistributedLock does not support conditions");
    }
    
    // 简化的Redis客户端
    static class RedisClient {
        private Map<String, String> data = new HashMap<>();
        private Map<String, Long> expireTimes = new HashMap<>();
        
        public String set(String key, String value, String nx, String ex, long expireTime) {
            if ("NX".equals(nx) && data.containsKey(key)) {
                return null; // 键已存在
            }
            data.put(key, value);
            expireTimes.put(key, System.currentTimeMillis() + expireTime * 1000);
            return "OK";
        }
        
        public String get(String key) {
            // 检查是否过期
            Long expireTime = expireTimes.get(key);
            if (expireTime != null && System.currentTimeMillis() > expireTime) {
                data.remove(key);
                expireTimes.remove(key);
                return null;
            }
            return data.get(key);
        }
        
        public Object eval(String script, int keyCount, String key, String value) {
            // 简化的Lua脚本执行
            if (script.contains("redis.call('get'") && script.contains("redis.call('del'")) {
                if (value.equals(get(key))) {
                    data.remove(key);
                    expireTimes.remove(key);
                    return 1L;
                }
            }
            return 0L;
        }
    }
    
    // 测试分布式锁
    public static void main(String[] args) throws InterruptedException {
        RedisClient redisClient = new RedisClient();
        RedisDistributedLock lock = new RedisDistributedLock(redisClient, "test_lock", 10);
        
        // 模拟多个线程竞争锁
        for (int i = 0; i < 3; i++) {
            final int threadId = i;
            new Thread(() -> {
                try {
                    lock.lock();
                    System.out.println("Thread " + threadId + " acquired lock");
                    Thread.sleep(2000); // 模拟业务处理
                    System.out.println("Thread " + threadId + " released lock");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    lock.unlock();
                }
            }).start();
        }
        
        Thread.sleep(10000); // 等待所有线程执行完毕
    }
}
```

## 12.6 分布式缓存

### 12.6.1 分布式缓存概述

分布式缓存是将数据存储在多个节点上的缓存系统，用于提高系统性能和可扩展性。

### 12.6.2 分布式缓存的特点

1. **高性能**：提供快速的数据访问
2. **可扩展性**：支持水平扩展
3. **高可用性**：通过数据复制保证可用性
4. **一致性**：保证数据在多个节点间的一致性

```java
import java.util.concurrent.ConcurrentHashMap;

// 简化的分布式缓存实现
public class DistributedCache {
    private Map<String, CacheNode> nodes;
    private ConsistentHashing consistentHashing;
    
    public DistributedCache(List<String> nodeIds) {
        this.nodes = new ConcurrentHashMap<>();
        for (String nodeId : nodeIds) {
            nodes.put(nodeId, new CacheNode(nodeId));
        }
        this.consistentHashing = new ConsistentHashing(nodeIds, 3);
    }
    
    // 设置缓存
    public void put(String key, String value) {
        String nodeId = consistentHashing.getNode(key);
        CacheNode node = nodes.get(nodeId);
        if (node != null) {
            node.put(key, value);
            System.out.println("PUT " + key + " -> " + value + " on node " + nodeId);
        }
    }
    
    // 获取缓存
    public String get(String key) {
        String nodeId = consistentHashing.getNode(key);
        CacheNode node = nodes.get(nodeId);
        if (node != null) {
            String value = node.get(key);
            System.out.println("GET " + key + " from node " + nodeId + ": " + value);
            return value;
        }
        return null;
    }
    
    // 删除缓存
    public void remove(String key) {
        String nodeId = consistentHashing.getNode(key);
        CacheNode node = nodes.get(nodeId);
        if (node != null) {
            node.remove(key);
            System.out.println("REMOVE " + key + " from node " + nodeId);
        }
    }
    
    // 缓存节点实现
    static class CacheNode {
        private String nodeId;
        private Map<String, String> data;
        
        public CacheNode(String nodeId) {
            this.nodeId = nodeId;
            this.data = new ConcurrentHashMap<>();
        }
        
        public void put(String key, String value) {
            data.put(key, value);
        }
        
        public String get(String key) {
            return data.get(key);
        }
        
        public void remove(String key) {
            data.remove(key);
        }
        
        public String getNodeId() {
            return nodeId;
        }
    }
    
    // 测试分布式缓存
    public static void main(String[] args) {
        List<String> nodeIds = Arrays.asList("node1", "node2", "node3");
        DistributedCache cache = new DistributedCache(nodeIds);
        
        // 存储数据
        cache.put("key1", "value1");
        cache.put("key2", "value2");
        cache.put("key3", "value3");
        
        // 获取数据
        System.out.println("\nRetrieving data:");
        System.out.println(cache.get("key1"));
        System.out.println(cache.get("key2"));
        System.out.println(cache.get("key3"));
        
        // 删除数据
        System.out.println("\nRemoving key2:");
        cache.remove("key2");
        System.out.println("key2 after removal: " + cache.get("key2"));
    }
}
```

## 12.7 分布式队列

### 12.7.1 分布式队列概述

分布式队列是跨多个节点的队列系统，用于在分布式系统中传递消息。

### 12.7.2 分布式队列的特点

1. **可靠性**：确保消息不丢失
2. **顺序性**：保证消息的顺序
3. **可扩展性**：支持水平扩展
4. **容错性**：节点故障不影响整体系统

```java
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

// 简化的分布式队列实现
public class DistributedQueue {
    private String queueName;
    private Map<String, QueueNode> nodes;
    private ConsistentHashing consistentHashing;
    
    public DistributedQueue(String queueName, List<String> nodeIds) {
        this.queueName = queueName;
        this.nodes = new ConcurrentHashMap<>();
        for (String nodeId : nodeIds) {
            nodes.put(nodeId, new QueueNode(nodeId));
        }
        this.consistentHashing = new ConsistentHashing(nodeIds, 3);
    }
    
    // 入队
    public void enqueue(String message) {
        String nodeId = consistentHashing.getNode(message);
        QueueNode node = nodes.get(nodeId);
        if (node != null) {
            node.enqueue(message);
            System.out.println("ENQUEUE '" + message + "' to node " + nodeId);
        }
    }
    
    // 出队
    public String dequeue() {
        // 简化实现：随机选择一个节点出队
        for (QueueNode node : nodes.values()) {
            String message = node.dequeue();
            if (message != null) {
                System.out.println("DEQUEUE '" + message + "' from node " + node.getNodeId());
                return message;
            }
        }
        return null;
    }
    
    // 队列节点实现
    static class QueueNode {
        private String nodeId;
        private BlockingQueue<String> queue;
        
        public QueueNode(String nodeId) {
            this.nodeId = nodeId;
            this.queue = new LinkedBlockingQueue<>();
        }
        
        public void enqueue(String message) {
            try {
                queue.put(message);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        public String dequeue() {
            try {
                return queue.poll();
            } catch (Exception e) {
                return null;
            }
        }
        
        public String getNodeId() {
            return nodeId;
        }
    }
    
    // 测试分布式队列
    public static void main(String[] args) throws InterruptedException {
        List<String> nodeIds = Arrays.asList("node1", "node2", "node3");
        DistributedQueue queue = new DistributedQueue("test_queue", nodeIds);
        
        // 入队
        System.out.println("Enqueuing messages:");
        queue.enqueue("message1");
        queue.enqueue("message2");
        queue.enqueue("message3");
        queue.enqueue("message4");
        queue.enqueue("message5");
        
        // 出队
        System.out.println("\nDequeuing messages:");
        for (int i = 0; i < 5; i++) {
            String message = queue.dequeue();
            if (message != null) {
                System.out.println("Dequeued: " + message);
            }
            Thread.sleep(100); // 模拟处理时间
        }
    }
}
```

## 12.8 分布式事务处理

### 12.8.1 分布式事务概述

分布式事务是指在分布式系统中，涉及多个节点的操作要么全部成功，要么全部失败。

### 12.8.2 分布式事务的挑战

1. **原子性**：保证所有操作要么全部成功，要么全部失败
2. **一致性**：保证数据在事务前后保持一致
3. **隔离性**：并发事务之间互不干扰
4. **持久性**：事务提交后，结果永久保存

### 12.8.3 分布式事务解决方案

1. **两阶段提交（2PC）**
2. **三阶段提交（3PC）**
3. **补偿事务（Saga模式）**
4. **TCC（Try-Confirm-Cancel）**

```java
// 简化的两阶段提交实现
public class TwoPhaseCommit {
    // 事务协调者
    static class Coordinator {
        private List<Participant> participants;
        private String transactionId;
        
        public Coordinator(String transactionId, List<Participant> participants) {
            this.transactionId = transactionId;
            this.participants = participants;
        }
        
        // 两阶段提交
        public boolean commit() {
            // 第一阶段：准备阶段
            boolean canCommit = true;
            for (Participant participant : participants) {
                if (!participant.prepare(transactionId)) {
                    canCommit = false;
                    break;
                }
            }
            
            // 第二阶段：提交或回滚
            if (canCommit) {
                // 提交
                for (Participant participant : participants) {
                    participant.commit(transactionId);
                }
                System.out.println("Transaction " + transactionId + " committed");
                return true;
            } else {
                // 回滚
                for (Participant participant : participants) {
                    participant.rollback(transactionId);
                }
                System.out.println("Transaction " + transactionId + " rolled back");
                return false;
            }
        }
    }
    
    // 事务参与者
    static class Participant {
        private String participantId;
        private Map<String, List<String>> preparedTransactions;
        
        public Participant(String participantId) {
            this.participantId = participantId;
            this.preparedTransactions = new ConcurrentHashMap<>();
        }
        
        // 准备阶段
        public boolean prepare(String transactionId) {
            // 模拟准备操作
            System.out.println("Participant " + participantId + " preparing transaction " + transactionId);
            
            // 模拟准备成功或失败
            boolean success = new Random().nextBoolean();
            if (success) {
                // 记录准备好的事务
                preparedTransactions.computeIfAbsent(transactionId, k -> new ArrayList<>());
                System.out.println("Participant " + participantId + " ready for transaction " + transactionId);
            } else {
                System.out.println("Participant " + participantId + " failed to prepare transaction " + transactionId);
            }
            return success;
        }
        
        // 提交阶段
        public void commit(String transactionId) {
            // 执行提交操作
            System.out.println("Participant " + participantId + " committing transaction " + transactionId);
            preparedTransactions.remove(transactionId);
        }
        
        // 回滚阶段
        public void rollback(String transactionId) {
            // 执行回滚操作
            System.out.println("Participant " + participantId + " rolling back transaction " + transactionId);
            preparedTransactions.remove(transactionId);
        }
    }
    
    // 测试两阶段提交
    public static void main(String[] args) {
        // 创建参与者
        List<Participant> participants = Arrays.asList(
            new Participant("participant1"),
            new Participant("participant2"),
            new Participant("participant3")
        );
        
        // 创建协调者
        Coordinator coordinator = new Coordinator("tx-001", participants);
        
        // 执行两阶段提交
        System.out.println("Starting two-phase commit for transaction tx-001");
        boolean result = coordinator.commit();
        System.out.println("Transaction result: " + (result ? "SUCCESS" : "FAILURE"));
    }
}
```

## 12.9 实际应用案例分析

### 12.9.1 分布式缓存在电商系统中的应用

在电商系统中，分布式缓存广泛应用于：
1. **商品信息缓存**：缓存商品详情、价格等信息
2. **购物车缓存**：缓存用户购物车数据
3. **会话缓存**：缓存用户登录状态和会话信息
4. **热点数据缓存**：缓存访问频繁的数据

### 12.9.2 分布式队列在订单处理系统中的应用

在订单处理系统中，分布式队列用于：
1. **订单创建**：将新订单放入队列等待处理
2. **库存扣减**：从队列中获取订单并扣减库存
3. **支付处理**：处理支付相关的消息
4. **物流通知**：发送物流状态更新消息

### 12.9.3 分布式锁在秒杀系统中的应用

在秒杀系统中，分布式锁用于：
1. **库存控制**：防止超卖
2. **用户限购**：限制用户购买数量
3. **防止重复下单**：确保同一用户不会重复下单

## 12.10 Java标准库和流行框架中的分布式数据结构

### 12.10.1 Apache ZooKeeper

ZooKeeper是一个分布式的、开源的协调服务，用于维护配置信息、命名、提供分布式同步和提供组服务。

### 12.10.2 Redis

Redis是一个开源的内存数据结构存储系统，可以用作数据库、缓存和消息中间件。

### 12.10.3 Apache Kafka

Kafka是一个分布式流处理平台，用于构建实时数据管道和流应用。

```java
// 使用Java操作Redis的示例
public class RedisExample {
    // Jedis客户端示例
    public static void jedisExample() {
        // 连接Redis
        Jedis jedis = new Jedis("localhost", 6379);
        
        // 字符串操作
        jedis.set("name", "Java");
        String name = jedis.get("name");
        System.out.println("Name: " + name);
        
        // 列表操作
        jedis.lpush("frameworks", "Spring", "Hibernate", "MyBatis");
        List<String> frameworks = jedis.lrange("frameworks", 0, -1);
        System.out.println("Frameworks: " + frameworks);
        
        // 哈希操作
        jedis.hset("user:1000", "name", "Alice");
        jedis.hset("user:1000", "email", "alice@example.com");
        String userName = jedis.hget("user:1000", "name");
        System.out.println("User name: " + userName);
        
        // 关闭连接
        jedis.close();
    }
    
    // 使用Lettuce客户端示例
    public static void lettuceExample() {
        // 创建客户端
        RedisClient client = RedisClient.create("redis://localhost:6379");
        StatefulRedisConnection<String, String> connection = client.connect();
        RedisCommands<String, String> syncCommands = connection.sync();
        
        // 设置和获取值
        syncCommands.set("key", "value");
        String value = syncCommands.get("key");
        System.out.println("Value: " + value);
        
        // 关闭连接
        connection.close();
        client.shutdown();
    }
    
    // 注意：这些示例需要添加相应的依赖
    // Jedis依赖: compile 'redis.clients:jedis:3.7.0'
    // Lettuce依赖: compile 'io.lettuce:lettuce-core:6.1.5.RELEASE'
}

// 使用Apache Curator操作ZooKeeper的示例
public class ZooKeeperExample {
    // Curator客户端示例
    public static void curatorExample() throws Exception {
        // 创建客户端
        CuratorFramework client = CuratorFrameworkFactory.newClient(
            "localhost:2181", 
            new ExponentialBackoffRetry(1000, 3)
        );
        client.start();
        
        // 创建节点
        String path = client.create()
            .creatingParentsIfNeeded()
            .withMode(CreateMode.PERSISTENT)
            .forPath("/example/node", "data".getBytes());
        System.out.println("Created node: " + path);
        
        // 获取节点数据
        byte[] data = client.getData().forPath("/example/node");
        System.out.println("Node data: " + new String(data));
        
        // 更新节点数据
        client.setData().forPath("/example/node", "new data".getBytes());
        
        // 删除节点
        client.delete().forPath("/example/node");
        
        // 关闭客户端
        client.close();
    }
    
    // 注意：这个示例需要添加Curator依赖
    // Curator依赖: compile 'org.apache.curator:curator-framework:5.2.0'
}
```

## 12.11 最佳实践与注意事项

1. **选择合适的一致性模型**：根据业务需求选择强一致性或最终一致性
2. **处理网络分区**：实现合理的故障恢复机制
3. **监控和告警**：建立完善的监控体系
4. **数据备份和恢复**：定期备份重要数据
5. **安全考虑**：确保数据传输和存储的安全性
6. **性能优化**：合理设计数据分片和缓存策略

## 12.12 总结

本章介绍了分布式系统中常用的数据结构和算法，包括分布式哈希表、一致性哈希、Raft共识算法、分布式锁、分布式缓存、分布式队列和分布式事务处理等。掌握这些知识对于构建高可用、可扩展的分布式系统至关重要。

下一章我们将探讨大数据处理中的数据结构和算法。