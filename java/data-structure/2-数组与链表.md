# 第2章：数组与链表 - 线性数据结构详解

## 2.1 数组（Array）

### 2.1.1 数组的基本概念

数组是一种线性数据结构，用于存储相同类型的元素。数组中的元素在内存中是连续存储的，可以通过索引直接访问任意元素。

数组的特点：
- 元素类型相同
- 内存连续存储
- 支持随机访问（通过索引）
- 大小固定（静态数组）

### 2.1.2 数组的实现与操作

在Java中，数组的声明和初始化方式如下：

```java
// 声明并初始化数组
int[] array = new int[5];  // 创建长度为5的整型数组
int[] array2 = {1, 2, 3, 4, 5};  // 直接初始化数组

// 访问数组元素
int firstElement = array2[0];  // 获取第一个元素
array2[0] = 10;  // 修改数组元素
```

### 2.1.3 数组的操作及时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| 访问元素 | O(1) | 通过索引直接访问 |
| 更新元素 | O(1) | 通过索引直接修改 |
| 插入元素 | O(n) | 需要移动插入位置后的所有元素 |
| 删除元素 | O(n) | 需要移动删除位置后的所有元素 |
| 查找元素 | O(n) | 需要遍历数组 |

### 2.1.4 数组的应用场景

数组适用于以下场景：
- 需要频繁通过索引访问元素
- 数据量相对固定
- 不需要频繁插入和删除操作

## 2.2 链表（Linked List）

### 2.2.1 链表的基本概念

链表是一种线性数据结构，由一系列节点组成，每个节点包含数据域和指向下一个节点的指针。链表中的元素在内存中不是连续存储的。

链表的特点：
- 元素在内存中非连续存储
- 通过指针链接各个节点
- 动态大小，可根据需要增长或缩小
- 插入和删除操作效率高

### 2.2.2 链表的类型

#### 单向链表（Singly Linked List）

每个节点只有一个指向下一个节点的指针。

```java
class ListNode {
    int val;
    ListNode next;
    
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
```

#### 双向链表（Doubly Linked List）

每个节点有两个指针，分别指向前一个节点和后一个节点。

```java
class DoublyListNode {
    int val;
    DoublyListNode next;
    DoublyListNode prev;
    
    DoublyListNode() {}
    DoublyListNode(int val) { this.val = val; }
    DoublyListNode(int val, DoublyListNode next, DoublyListNode prev) {
        this.val = val;
        this.next = next;
        this.prev = prev;
    }
}
```

#### 循环链表（Circular Linked List）

尾节点指向头节点，形成一个环。

### 2.2.3 链表的操作及时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| 访问元素 | O(n) | 需要从头节点开始遍历 |
| 更新元素 | O(n) | 需要先找到该元素 |
| 插入元素（头部） | O(1) | 只需修改头节点指针 |
| 插入元素（尾部） | O(n) | 需要遍历到尾节点 |
| 删除元素 | O(n) | 需要先找到该元素 |
| 查找元素 | O(n) | 需要遍历链表 |

### 2.2.4 链表的实现

让我们看一个简单的单向链表实现：

```java
public class LinkedList {
    private ListNode head;
    
    public LinkedList() {
        this.head = null;
    }
    
    // 在链表头部插入元素
    public void insertAtHead(int val) {
        ListNode newNode = new ListNode(val);
        newNode.next = head;
        head = newNode;
    }
    
    // 在链表尾部插入元素
    public void insertAtTail(int val) {
        ListNode newNode = new ListNode(val);
        if (head == null) {
            head = newNode;
            return;
        }
        
        ListNode current = head;
        while (current.next != null) {
            current = current.next;
        }
        current.next = newNode;
    }
    
    // 删除指定值的节点
    public boolean delete(int val) {
        if (head == null) return false;
        
        // 如果要删除的是头节点
        if (head.val == val) {
            head = head.next;
            return true;
        }
        
        ListNode current = head;
        while (current.next != null && current.next.val != val) {
            current = current.next;
        }
        
        if (current.next != null) {
            current.next = current.next.next;
            return true;
        }
        
        return false;
    }
    
    // 查找元素
    public boolean search(int val) {
        ListNode current = head;
        while (current != null) {
            if (current.val == val) {
                return true;
            }
            current = current.next;
        }
        return false;
    }
    
    // 打印链表
    public void printList() {
        ListNode current = head;
        while (current != null) {
            System.out.print(current.val + " -> ");
            current = current.next;
        }
        System.out.println("null");
    }
}
```

## 2.3 数组与链表的对比

### 2.3.1 存储方式对比

| 特性 | 数组 | 链表 |
|------|------|------|
| 存储方式 | 连续存储 | 非连续存储 |
| 内存分配 | 编译时分配 | 运行时动态分配 |
| 内存利用率 | 可能浪费空间 | 充分利用空间 |

### 2.3.2 访问方式对比

| 特性 | 数组 | 链表 |
|------|------|------|
| 随机访问 | 支持，O(1) | 不支持，O(n) |
| 顺序访问 | O(n) | O(n) |

### 2.3.3 插入删除对比

| 操作 | 数组 | 链表 |
|------|------|------|
| 头部插入/删除 | O(n) | O(1) |
| 尾部插入 | O(1)* | O(n) |
| 中间插入/删除 | O(n) | O(n) |

*注：假设我们知道数组末尾的位置

### 2.3.4 应用场景选择

选择数组的情况：
- 需要频繁随机访问元素
- 数据量相对稳定
- 对内存使用要求较高

选择链表的情况：
- 需要频繁插入和删除操作
- 数据量变化较大
- 不需要随机访问元素

## 2.4 实际应用案例

### 2.4.1 数组应用：图像处理

在图像处理中，像素数据通常以二维数组形式存储：

```java
// 表示一张宽度为width，高度为height的灰度图像
int[][] image = new int[height][width];

// 访问坐标(x,y)的像素值
int pixelValue = image[y][x];

// 设置坐标(x,y)的像素值
image[y][x] = newValue;
```

### 2.4.2 链表应用：浏览器历史记录

浏览器的历史记录可以用双向链表实现，支持前进和后退功能：

```java
class BrowserHistory {
    private DoublyListNode currentPage;
    private DoublyListNode head;
    
    public BrowserHistory(String homepage) {
        head = new DoublyListNode(homepage);
        currentPage = head;
    }
    
    // 访问新的页面
    public void visit(String url) {
        DoublyListNode newNode = new DoublyListNode(url);
        currentPage.next = newNode;
        newNode.prev = currentPage;
        currentPage = newNode;
    }
    
    // 后退
    public String back(int steps) {
        while (steps > 0 && currentPage.prev != null) {
            currentPage = currentPage.prev;
            steps--;
        }
        return currentPage.val;
    }
    
    // 前进
    public String forward(int steps) {
        while (steps > 0 && currentPage.next != null) {
            currentPage = currentPage.next;
            steps--;
        }
        return currentPage.val;
    }
}
```

## 2.5 最佳实践与注意事项

### 2.5.1 数组的最佳实践

1. **预估容量**：根据实际需求合理预估数组大小
2. **边界检查**：访问数组前检查索引是否越界
3. **内存管理**：注意大数组可能造成的内存压力

### 2.5.2 链表的最佳实践

1. **空指针检查**：操作链表时要注意空指针异常
2. **内存释放**：在不需要链表时，确保没有循环引用导致内存泄漏
3. **哨兵节点**：在某些情况下使用哨兵节点可以简化操作

### 2.5.3 性能优化建议

1. **选择合适的数据结构**：根据具体操作频率选择数组或链表
2. **批量操作优化**：对于大量插入操作，可以考虑先用链表，最后转为数组
3. **缓存友好性**：数组具有更好的缓存局部性，在性能敏感场景优先考虑

## 2.6 本章小结

本章详细介绍了两种最基本的线性数据结构：数组和链表。我们学习了它们的基本概念、实现方式、操作特点以及适用场景。

数组适合需要频繁随机访问的场景，而链表适合需要频繁插入删除的场景。在实际开发中，我们需要根据具体的业务需求和性能要求来选择合适的数据结构。

下一章我们将学习另外两种重要的线性数据结构：栈和队列，它们在很多算法和实际应用中都发挥着重要作用。