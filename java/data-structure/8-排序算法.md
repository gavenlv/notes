# 第八章：排序算法 - 数据有序化之道

## 目录
1. [排序算法概述](#排序算法概述)
2. [冒泡排序](#冒泡排序)
3. [选择排序](#选择排序)
4. [插入排序](#插入排序)
5. [希尔排序](#希尔排序)
6. [归并排序](#归并排序)
7. [快速排序](#快速排序)
8. [堆排序](#堆排序)
9. [计数排序](#计数排序)
10. [桶排序](#桶排序)
11. [基数排序](#基数排序)
12. [排序算法性能比较](#排序算法性能比较)
13. [最佳实践](#最佳实践)

---

## 排序算法概述

排序是计算机科学中最基本也是最重要的问题之一。它是指将一组数据按照特定顺序重新排列的过程。排序算法广泛应用于各种场景，如数据库查询优化、搜索引擎结果排序、数据分析等领域。

### 排序算法分类

1. **稳定性**
   - 稳定排序：相等元素在排序后保持原有相对顺序
   - 不稳定排序：相等元素在排序后可能改变相对顺序

2. **时间复杂度**
   - O(n²)：简单排序算法
   - O(n log n)：高效排序算法
   - O(n)：特殊条件下的线性排序

3. **空间复杂度**
   - 原地排序：只需要常数级别的额外空间
   - 非原地排序：需要额外的空间存储临时数据

4. **适用场景**
   - 小规模数据：简单排序算法
   - 大规模数据：高效排序算法
   - 特殊数据类型：线性排序算法

---

## 冒泡排序

冒泡排序是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。这个过程重复进行，直到没有再需要交换的元素为止。

### 算法原理

1. 比较相邻的元素，如果第一个比第二个大，就交换它们两个
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，最后的元素应该会是最大的数
3. 针对所有的元素重复以上的步骤，除了最后一个
4. 重复步骤1~3，直到排序完成

### Java实现

```java
public class BubbleSort {
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            // 标记是否发生交换
            boolean swapped = false;
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    // 交换元素
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }
            // 如果没有发生交换，说明已经有序
            if (!swapped) {
                break;
            }
        }
    }
}
```

### 时间复杂度分析

- 最好情况：O(n) - 数组已经有序
- 平均情况：O(n²)
- 最坏情况：O(n²) - 数组逆序排列
- 空间复杂度：O(1) - 原地排序

### 应用场景

- 教学演示排序算法的基本思想
- 小规模数据集的排序
- 数据基本有序的情况

---

## 选择排序

选择排序是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（或最大）元素，然后放到已排序序列的末尾。

### 算法原理

1. 在未排序序列中找到最小元素，存放到排序序列的起始位置
2. 从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾
3. 重复第二步，直到所有元素均排序完毕

### Java实现

```java
public class SelectionSort {
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            // 找到未排序部分的最小元素索引
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            // 交换找到的最小元素与未排序部分的第一个元素
            if (minIndex != i) {
                int temp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
            }
        }
    }
}
```

### 时间复杂度分析

- 最好情况：O(n²)
- 平均情况：O(n²)
- 最坏情况：O(n²)
- 空间复杂度：O(1) - 原地排序

### 应用场景

- 数据量较小的情况
- 对内存使用要求严格的情况
- 不关心排序的稳定性

---

## 插入排序

插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

### 算法原理

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5

### Java实现

```java
public class InsertionSort {
    public static void insertionSort(int[] arr) {
        int n = arr.length;
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            
            // 将大于key的元素向后移动
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            // 插入key到正确位置
            arr[j + 1] = key;
        }
    }
}
```

### 时间复杂度分析

- 最好情况：O(n) - 数组已经有序
- 平均情况：O(n²)
- 最坏情况：O(n²) - 数组逆序排列
- 空间复杂度：O(1) - 原地排序

### 应用场景

- 小规模数据集
- 数据基本有序的情况
- 在线算法（边输入边排序）

---

## 希尔排序

希尔排序是插入排序的一种更高效的改进版本，也称为缩小增量排序。它通过将原始数组分割成若干子序列来分别进行插入排序，这些子序列是由某个增量（gap）决定的。

### 算法原理

1. 选择一个增量序列 t1, t2, ..., tk，其中 ti > tj, tk = 1
2. 按增量序列个数k，对序列进行k趟排序
3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序
4. 仅当增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度

### Java实现

```java
public class ShellSort {
    public static void shellSort(int[] arr) {
        int n = arr.length;
        // 初始增量为数组长度的一半，每次减半
        for (int gap = n / 2; gap > 0; gap /= 2) {
            // 对各个子序列进行插入排序
            for (int i = gap; i < n; i++) {
                int key = arr[i];
                int j = i;
                
                // 在子序列中进行插入排序
                while (j >= gap && arr[j - gap] > key) {
                    arr[j] = arr[j - gap];
                    j -= gap;
                }
                arr[j] = key;
            }
        }
    }
}
```

### 时间复杂度分析

- 最好情况：O(n log n)
- 平均情况：取决于增量序列的选择
- 最坏情况：O(n²)
- 空间复杂度：O(1) - 原地排序

### 应用场景

- 中等规模的数据集
- 对插入排序的改进需求
- 增量序列选择合适的场景

---

## 归并排序

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

### 算法原理

1. 分解：将待排序的n个元素分成各包含n/2个元素的子序列
2. 解决：使用归并排序递归地排序两个子序列
3. 合并：合并两个已排序的子序列以产生已排序的答案

### Java实现

```java
public class MergeSort {
    public static void mergeSort(int[] arr) {
        if (arr.length <= 1) return;
        mergeSortHelper(arr, 0, arr.length - 1);
    }
    
    private static void mergeSortHelper(int[] arr, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            
            // 递归排序左半部分
            mergeSortHelper(arr, left, mid);
            // 递归排序右半部分
            mergeSortHelper(arr, mid + 1, right);
            // 合并两个有序部分
            merge(arr, left, mid, right);
        }
    }
    
    private static void merge(int[] arr, int left, int mid, int right) {
        // 创建临时数组存储合并结果
        int[] temp = new int[right - left + 1];
        int i = left, j = mid + 1, k = 0;
        
        // 合并两个有序数组
        while (i <= mid && j <= right) {
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }
        
        // 复制剩余元素
        while (i <= mid) {
            temp[k++] = arr[i++];
        }
        while (j <= right) {
            temp[k++] = arr[j++];
        }
        
        // 将临时数组复制回原数组
        System.arraycopy(temp, 0, arr, left, temp.length);
    }
}
```

### 时间复杂度分析

- 最好情况：O(n log n)
- 平均情况：O(n log n)
- 最坏情况：O(n log n)
- 空间复杂度：O(n) - 需要额外的存储空间

### 应用场景

- 大规模数据集排序
- 对稳定性有要求的场景
- 外部排序（数据量超过内存容量）

---

## 快速排序

快速排序是一种高效的排序算法，采用分治法策略来把一个序列分为较小和较大的两个子序列，然后递归地排序两个子序列。

### 算法原理

1. 从数列中挑出一个元素，称为"基准"（pivot）
2. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）
3. 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序

### Java实现

```java
public class QuickSort {
    public static void quickSort(int[] arr) {
        if (arr.length <= 1) return;
        quickSortHelper(arr, 0, arr.length - 1);
    }
    
    private static void quickSortHelper(int[] arr, int low, int high) {
        if (low < high) {
            // 获取分区点
            int pivotIndex = partition(arr, low, high);
            
            // 递归排序基准左边的元素
            quickSortHelper(arr, low, pivotIndex - 1);
            // 递归排序基准右边的元素
            quickSortHelper(arr, pivotIndex + 1, high);
        }
    }
    
    private static int partition(int[] arr, int low, int high) {
        // 选择最后一个元素作为基准
        int pivot = arr[high];
        int i = low - 1; // 小于基准的元素的索引
        
        for (int j = low; j < high; j++) {
            // 如果当前元素小于或等于基准
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        // 将基准放到正确位置
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 时间复杂度分析

- 最好情况：O(n log n) - 每次分区都能平均分割
- 平均情况：O(n log n)
- 最坏情况：O(n²) - 每次选择的基准都是最大或最小元素
- 空间复杂度：O(log n) - 递归调用栈空间

### 应用场景

- 大规模数据集排序
- 内存中排序的首选算法
- 对平均性能要求高的场景

---

## 堆排序

堆排序是一种基于比较的排序算法，利用堆这种数据结构所设计的一种排序算法。

### 算法原理

1. 构造初始堆：将给定的无序序列构造成一个大顶堆（升序排列构造大顶堆，降序排列构造小顶堆）
2. 将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端
3. 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序

### Java实现

```java
public class HeapSort {
    public static void heapSort(int[] arr) {
        int n = arr.length;
        
        // 构建最大堆
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        // 逐个提取元素
        for (int i = n - 1; i > 0; i--) {
            // 将当前最大元素移到末尾
            swap(arr, 0, i);
            
            // 重新调整堆
            heapify(arr, i, 0);
        }
    }
    
    private static void heapify(int[] arr, int n, int i) {
        int largest = i; // 初始化最大为根
        int left = 2 * i + 1; // 左子节点
        int right = 2 * i + 2; // 右子节点
        
        // 如果左子节点存在且大于根
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        // 如果右子节点存在且大于当前最大
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        // 如果最大不是根
        if (largest != i) {
            swap(arr, i, largest);
            
            // 递归调整受影响的子树
            heapify(arr, n, largest);
        }
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 时间复杂度分析

- 最好情况：O(n log n)
- 平均情况：O(n log n)
- 最坏情况：O(n log n)
- 空间复杂度：O(1) - 原地排序

### 应用场景

- 对时间和空间复杂度都有要求的场景
- 不需要稳定性的排序场景
- 内存受限但需要高效排序的环境

---

## 计数排序

计数排序是一种非比较排序算法，适用于一定范围内的整数排序。

### 算法原理

1. 找出待排序的数组中的最大值和最小值
2. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项
3. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
4. 反向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1

### Java实现

```java
public class CountingSort {
    public static void countingSort(int[] arr) {
        if (arr.length <= 1) return;
        
        // 找到最大值和最小值
        int max = arr[0], min = arr[0];
        for (int num : arr) {
            max = Math.max(max, num);
            min = Math.min(min, num);
        }
        
        // 计算范围
        int range = max - min + 1;
        int[] count = new int[range];
        int[] output = new int[arr.length];
        
        // 统计每个元素出现的次数
        for (int num : arr) {
            count[num - min]++;
        }
        
        // 计算累积计数
        for (int i = 1; i < range; i++) {
            count[i] += count[i - 1];
        }
        
        // 构建输出数组
        for (int i = arr.length - 1; i >= 0; i--) {
            output[count[arr[i] - min] - 1] = arr[i];
            count[arr[i] - min]--;
        }
        
        // 复制回原数组
        System.arraycopy(output, 0, arr, 0, arr.length);
    }
}
```

### 时间复杂度分析

- 最好情况：O(n + k) - n为元素个数，k为数据范围
- 平均情况：O(n + k)
- 最坏情况：O(n + k)
- 空间复杂度：O(k) - 需要额外的计数数组

### 应用场景

- 数据范围较小的整数排序
- 需要稳定排序的场景
- 数据分布相对均匀的情况

---

## 桶排序

桶排序是计数排序的升级版，它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。

### 算法原理

1. 设置一个定量的数组当作空桶
2. 遍历输入数据，并且把数据一个一个放到对应的桶里去
3. 对每个不是空的桶进行排序
4. 从不是空的桶里把排好序的数据拼接起来

### Java实现

```java
import java.util.*;

public class BucketSort {
    public static void bucketSort(float[] arr) {
        if (arr.length <= 1) return;
        
        // 创建桶
        int bucketCount = arr.length;
        List<List<Float>> buckets = new ArrayList<>(bucketCount);
        
        // 初始化桶
        for (int i = 0; i < bucketCount; i++) {
            buckets.add(new ArrayList<>());
        }
        
        // 将元素分配到桶中
        for (float num : arr) {
            int bucketIndex = (int) (num * bucketCount);
            // 处理边界情况
            if (bucketIndex >= bucketCount) {
                bucketIndex = bucketCount - 1;
            }
            buckets.get(bucketIndex).add(num);
        }
        
        // 对每个桶进行排序
        for (List<Float> bucket : buckets) {
            Collections.sort(bucket);
        }
        
        // 合并桶中的元素
        int index = 0;
        for (List<Float> bucket : buckets) {
            for (float num : bucket) {
                arr[index++] = num;
            }
        }
    }
}
```

### 时间复杂度分析

- 最好情况：O(n + k) - 数据均匀分布在各个桶中
- 平均情况：O(n + k)
- 最坏情况：O(n²) - 所有数据都分配到同一个桶中
- 空间复杂度：O(n + k)

### 应用场景

- 输入数据均匀分布在一个范围内
- 浮点数排序
- 外部排序的辅助算法

---

## 基数排序

基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。

### 算法原理

1. 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零
2. 从最低位开始，依次进行一次排序
3. 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列

### Java实现

```java
public class RadixSort {
    public static void radixSort(int[] arr) {
        if (arr.length <= 1) return;
        
        // 找到最大数以确定位数
        int max = getMax(arr);
        
        // 对每一位进行计数排序
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countingSortByDigit(arr, exp);
        }
    }
    
    private static int getMax(int[] arr) {
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        return max;
    }
    
    private static void countingSortByDigit(int[] arr, int exp) {
        int n = arr.length;
        int[] output = new int[n];
        int[] count = new int[10];
        
        // 统计每个数字出现的次数
        for (int i = 0; i < n; i++) {
            count[(arr[i] / exp) % 10]++;
        }
        
        // 计算累积计数
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }
        
        // 构建输出数组
        for (int i = n - 1; i >= 0; i--) {
            output[count[(arr[i] / exp) % 10] - 1] = arr[i];
            count[(arr[i] / exp) % 10]--;
        }
        
        // 复制回原数组
        System.arraycopy(output, 0, arr, 0, n);
    }
}
```

### 时间复杂度分析

- 最好情况：O(d × (n + k)) - d为位数，k为基数（通常为10）
- 平均情况：O(d × (n + k))
- 最坏情况：O(d × (n + k))
- 空间复杂度：O(n + k)

### 应用场景

- 整数排序
- 字符串排序（按字符顺序）
- 固定位数的数据排序

---

## 排序算法性能比较

| 排序算法 | 最好时间复杂度 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 稳定性 | 原地排序 |
|---------|---------------|---------------|---------------|-----------|--------|----------|
| 冒泡排序 | O(n)         | O(n²)         | O(n²)         | O(1)      | 稳定   | 是       |
| 选择排序 | O(n²)        | O(n²)         | O(n²)         | O(1)      | 不稳定 | 是       |
| 插入排序 | O(n)         | O(n²)         | O(n²)         | O(1)      | 稳定   | 是       |
| 希尔排序 | O(n log n)   | 取决于增量序列 | 取决于增量序列 | O(1)      | 不稳定 | 是       |
| 归并排序 | O(n log n)   | O(n log n)    | O(n log n)    | O(n)      | 稳定   | 否       |
| 快速排序 | O(n log n)   | O(n log n)    | O(n²)         | O(log n)  | 不稳定 | 是       |
| 堆排序   | O(n log n)   | O(n log n)    | O(n log n)    | O(1)      | 不稳定 | 是       |
| 计数排序 | O(n + k)     | O(n + k)      | O(n + k)      | O(k)      | 稳定   | 否       |
| 桶排序   | O(n + k)     | O(n + k)      | O(n²)         | O(n + k)  | 稳定   | 否       |
| 基数排序 | O(d(n + k))  | O(d(n + k))   | O(d(n + k))   | O(n + k)  | 稳定   | 否       |

---

## 最佳实践

### 1. 选择合适的排序算法

- **小规模数据（n < 50）**：插入排序通常是最佳选择
- **大规模数据**：快速排序、归并排序或堆排序
- **需要稳定性**：归并排序
- **内存受限**：堆排序
- **整数且范围有限**：计数排序
- **浮点数且分布均匀**：桶排序
- **固定位数的整数**：基数排序

### 2. 实际应用建议

1. **Java内置排序**：
   ```java
   // 对于对象数组，使用归并排序（稳定）
   Arrays.sort(objectArray);
   
   // 对于基本类型数组，使用双轴快速排序
   Arrays.sort(primitiveArray);
   ```

2. **自定义比较器**：
   ```java
   // 使用自定义比较器进行排序
   Arrays.sort(array, Comparator.comparingInt(obj -> obj.getValue()));
   ```

3. **并行排序**：
   ```java
   // 对于大数据集，使用并行排序
   Arrays.parallelSort(largeArray);
   ```

### 3. 性能优化技巧

1. **混合排序**：当递归深度过大时切换到插入排序
2. **三数取中法**：选择更好的基准元素提高快速排序性能
3. **三路快排**：处理大量重复元素的情况
4. **内省排序**：结合快速排序、堆排序和插入排序的优点

### 4. 错误避免

1. **边界条件处理**：确保正确处理空数组、单元素数组等特殊情况
2. **稳定性保持**：在需要稳定性的场景中选择稳定排序算法
3. **内存管理**：注意非原地排序算法的内存消耗
4. **数据类型考虑**：针对不同数据类型选择合适的算法

### 5. 测试验证

1. **边界测试**：测试空数组、单元素、已排序、逆序等特殊情况
2. **随机测试**：使用随机数据验证算法正确性
3. **性能测试**：在不同规模数据上测试性能表现
4. **稳定性测试**：验证稳定排序算法确实保持相等元素的相对顺序

通过本章的学习，你应该掌握了各种排序算法的原理、实现和应用场景。在实际开发中，合理选择和使用排序算法能够显著提升程序性能。