# 第十一章：算法设计与分析基础

## 本章概要

本章将介绍算法设计与分析的基础知识，包括：
- 算法复杂度分析（时间复杂度和空间复杂度）
- 常见算法设计技巧（分治法、贪心算法、动态规划、回溯法）
- 算法正确性证明方法
- NP完全性理论简介
- 实际应用案例分析

## 11.1 算法复杂度分析

### 11.1.1 时间复杂度

时间复杂度用来描述算法执行时间随输入规模增长的变化趋势。常用大O记号表示。

常见的时间复杂度等级：
- O(1)：常数时间复杂度
- O(log n)：对数时间复杂度
- O(n)：线性时间复杂度
- O(n log n)：线性对数时间复杂度
- O(n²)：平方时间复杂度
- O(2ⁿ)：指数时间复杂度

### 11.1.2 空间复杂度

空间复杂度用来描述算法所需存储空间随输入规模增长的变化趋势。

```java
// 示例：不同复杂度的算法
public class ComplexityExamples {
    // O(1) 常数时间复杂度
    public int getFirstElement(int[] array) {
        return array[0]; // 不管数组多大，都只需要一次操作
    }
    
    // O(n) 线性时间复杂度
    public int sumArray(int[] array) {
        int sum = 0;
        for (int i = 0; i < array.length; i++) {
            sum += array[i]; // 需要遍历整个数组
        }
        return sum;
    }
    
    // O(n²) 平方时间复杂度
    public void printPairs(int[] array) {
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array.length; j++) {
                System.out.println(array[i] + "," + array[j]);
            }
        }
    }
    
    // O(log n) 对数时间复杂度
    public boolean binarySearch(int[] array, int target) {
        int left = 0;
        int right = array.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (array[mid] == target) {
                return true;
            } else if (array[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return false;
    }
}
```

### 11.1.3 复杂度分析技巧

1. **加法规则**：当算法由若干个独立步骤组成时，总的时间复杂度是各步骤时间复杂度的最大值。
2. **乘法规则**：当一个步骤在另一个步骤内部重复执行时，总的时间复杂度是两者的乘积。
3. **循环分析**：对于循环结构，时间复杂度等于循环次数乘以循环体内的复杂度。

## 11.2 算法设计技巧

### 11.2.1 分治法（Divide and Conquer）

分治法是一种重要的算法设计思想，它将问题分解为若干个规模较小的相同问题，递归地求解这些子问题，然后合并子问题的解得到原问题的解。

经典例子：归并排序、快速排序、二分查找

```java
// 归并排序实现（分治法）
public class MergeSort {
    public void mergeSort(int[] array, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            
            // 分解
            mergeSort(array, left, mid);
            mergeSort(array, mid + 1, right);
            
            // 合并
            merge(array, left, mid, right);
        }
    }
    
    private void merge(int[] array, int left, int mid, int right) {
        // 创建临时数组
        int[] temp = new int[right - left + 1];
        int i = left, j = mid + 1, k = 0;
        
        // 合并两个有序数组
        while (i <= mid && j <= right) {
            if (array[i] <= array[j]) {
                temp[k++] = array[i++];
            } else {
                temp[k++] = array[j++];
            }
        }
        
        // 复制剩余元素
        while (i <= mid) {
            temp[k++] = array[i++];
        }
        while (j <= right) {
            temp[k++] = array[j++];
        }
        
        // 将临时数组复制回原数组
        for (int p = 0; p < temp.length; p++) {
            array[left + p] = temp[p];
        }
    }
}
```

### 11.2.2 贪心算法（Greedy Algorithm）

贪心算法在每一步选择中都采取在当前状态下最好或最优的选择，从而希望导致结果是最好或最优的算法。

适用条件：
1. 贪心选择性质：所求问题的整体最优解可以通过一系列局部最优的选择得到
2. 最优子结构性质：一个问题的最优解包含其子问题的最优解

经典例子：活动选择问题、霍夫曼编码、最小生成树（Kruskal和Prim算法）

```java
// 活动选择问题（贪心算法）
public class ActivitySelection {
    static class Activity {
        int start, finish;
        
        public Activity(int start, int finish) {
            this.start = start;
            this.finish = finish;
        }
    }
    
    public static void selectActivities(Activity[] activities) {
        // 按结束时间排序
        Arrays.sort(activities, (a, b) -> a.finish - b.finish);
        
        System.out.println("选中的活动:");
        int i = 0;
        System.out.println("(" + activities[i].start + ", " + activities[i].finish + ")");
        
        // 贪心选择：总是选择下一个与前一个兼容且结束时间最早的活动
        for (int j = 1; j < activities.length; j++) {
            if (activities[j].start >= activities[i].finish) {
                System.out.println("(" + activities[j].start + ", " + activities[j].finish + ")");
                i = j;
            }
        }
    }
    
    public static void main(String[] args) {
        Activity[] activities = {
            new Activity(1, 4),
            new Activity(3, 5),
            new Activity(0, 6),
            new Activity(5, 7),
            new Activity(3, 9),
            new Activity(5, 9),
            new Activity(6, 10),
            new Activity(8, 11),
            new Activity(8, 12),
            new Activity(2, 14),
            new Activity(12, 16)
        };
        
        selectActivities(activities);
    }
}
```

### 11.2.3 动态规划（Dynamic Programming）

动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。

核心要素：
1. 最优子结构：问题的最优解包含子问题的最优解
2. 重叠子问题：在求解过程中，很多子问题被重复计算
3. 状态转移方程：描述状态之间的关系

经典例子：斐波那契数列、背包问题、最长公共子序列

```java
// 斐波那契数列（动态规划实现）
public class FibonacciDP {
    // 自顶向下（记忆化搜索）
    public static int fibonacciMemo(int n, int[] memo) {
        if (n <= 1) return n;
        if (memo[n] != 0) return memo[n];
        
        memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);
        return memo[n];
    }
    
    // 自底向上（表格法）
    public static int fibonacciTabulation(int n) {
        if (n <= 1) return n;
        
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        
        return dp[n];
    }
    
    public static void main(String[] args) {
        int n = 10;
        int[] memo = new int[n + 1];
        
        System.out.println("斐波那契数列第" + n + "项（记忆化搜索）: " + fibonacciMemo(n, memo));
        System.out.println("斐波那契数列第" + n + "项（表格法）: " + fibonacciTabulation(n));
    }
}

// 0-1背包问题（动态规划实现）
public class KnapsackProblem {
    public static int knapsack(int W, int[] weights, int[] values, int n) {
        // dp[i][w] 表示前i个物品在重量限制为w时的最大价值
        int[][] dp = new int[n + 1][W + 1];
        
        // 填充dp表
        for (int i = 1; i <= n; i++) {
            for (int w = 1; w <= W; w++) {
                // 如果当前物品重量超过背包容量，则不能放入
                if (weights[i - 1] > w) {
                    dp[i][w] = dp[i - 1][w];
                } else {
                    // 比较放入和不放入当前物品的价值
                    dp[i][w] = Math.max(
                        dp[i - 1][w],  // 不放入
                        dp[i - 1][w - weights[i - 1]] + values[i - 1]  // 放入
                    );
                }
            }
        }
        
        return dp[n][W];
    }
    
    public static void main(String[] args) {
        int[] values = {60, 100, 120};
        int[] weights = {10, 20, 30};
        int W = 50;
        int n = values.length;
        
        int maxValue = knapsack(W, weights, values, n);
        System.out.println("背包最大价值: " + maxValue);
    }
}
```

### 11.2.4 回溯法（Backtracking）

回溯法是一种通过探索所有可能的候选解来找出所有解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化即回溯的方式撤消上一步的操作，然后再尝试其他的可能。

经典例子：N皇后问题、数独求解、图的着色问题

```java
// N皇后问题（回溯法实现）
public class NQueens {
    private int[] queens;  // queens[i] 表示第i行皇后所在的列
    private int solutions; // 解的数量
    
    public NQueens(int n) {
        queens = new int[n];
        solutions = 0;
    }
    
    // 检查在(row, col)放置皇后是否合法
    private boolean isValid(int row, int col) {
        for (int i = 0; i < row; i++) {
            // 检查列冲突和对角线冲突
            if (queens[i] == col || 
                Math.abs(queens[i] - col) == Math.abs(i - row)) {
                return false;
            }
        }
        return true;
    }
    
    // 回溯求解
    public void solve(int row) {
        if (row == queens.length) {
            solutions++;
            printSolution();
            return;
        }
        
        for (int col = 0; col < queens.length; col++) {
            if (isValid(row, col)) {
                queens[row] = col;
                solve(row + 1);
                // 回溯：不需要显式重置，因为下次循环会覆盖
            }
        }
    }
    
    // 打印解决方案
    private void printSolution() {
        System.out.println("解决方案 #" + solutions + ":");
        for (int i = 0; i < queens.length; i++) {
            for (int j = 0; j < queens.length; j++) {
                if (queens[i] == j) {
                    System.out.print("Q ");
                } else {
                    System.out.print(". ");
                }
            }
            System.out.println();
        }
        System.out.println();
    }
    
    public static void main(String[] args) {
        int n = 4;
        NQueens nQueens = new NQueens(n);
        nQueens.solve(0);
        System.out.println("总共找到 " + nQueens.solutions + " 个解决方案");
    }
}
```

## 11.3 算法正确性证明

### 11.3.1 数学归纳法

数学归纳法是证明算法正确性的常用方法，特别适用于递归算法。

证明步骤：
1. 基础情况：证明算法对最小规模的输入是正确的
2. 归纳假设：假设算法对规模小于n的所有输入都是正确的
3. 归纳步骤：证明算法对规模为n的输入也是正确的

### 11.3.2 循环不变式

循环不变式是在循环的每次迭代开始时都为真的条件。

三个性质：
1. 初始化：循环第一次迭代之前，循环不变式成立
2. 保持：如果循环某次迭代之前循环不变式成立，那么下次迭代之前它仍然成立
3. 终止：循环终止时，循环不变式为我们提供了一个有用的性质，帮助证明算法的正确性

```java
// 使用循环不变式证明选择排序的正确性
public class SelectionSortProof {
    /*
     * 循环不变式：在第i次迭代开始时，数组的前i个元素包含了数组中最小的i个元素，
     * 并且它们已经按升序排列。
     * 
     * 初始化：i=0时，前0个元素为空，不变式显然成立。
     * 保持：第i次迭代中，我们找到剩余元素中的最小值并将其放到位置i，
     *      因此前i+1个元素包含了最小的i+1个元素并且已排序。
     * 终止：循环结束时i=n，整个数组已排序。
     */
    public static void selectionSort(int[] array) {
        int n = array.length;
        
        for (int i = 0; i < n - 1; i++) {
            // 循环不变式：array[0..i-1]已排序且包含最小的i个元素
            
            // 找到未排序部分的最小元素
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (array[j] < array[minIndex]) {
                    minIndex = j;
                }
            }
            
            // 交换元素
            int temp = array[minIndex];
            array[minIndex] = array[i];
            array[i] = temp;
            
            // 循环结束后，array[0..i]已排序且包含最小的i+1个元素
        }
    }
}
```

## 11.4 NP完全性理论简介

### 11.4.1 P类问题

P类问题是可以在多项式时间内被确定性图灵机解决的判定问题。

### 11.4.2 NP类问题

NP类问题是可以在多项式时间内被非确定性图灵机解决的判定问题，或者说，给定一个候选解，可以在多项式时间内验证该解是否正确。

### 11.4.3 NPC类问题（NP完全问题）

NPC类问题是NP类问题中最难的问题，满足以下两个条件：
1. 属于NP类问题
2. 所有NP类问题都可以在多项式时间内归约到它

### 11.4.4 NP难问题

NP难问题是至少和NP完全问题一样难的问题，但不一定属于NP类。

常见的NP完全问题：
- 旅行商问题（TSP）
- 0-1背包问题
- 图着色问题
- 布尔可满足性问题（SAT）

## 11.5 实际应用案例分析

### 11.5.1 最短路径问题

在地图导航系统中，需要找到两点之间的最短路径。Dijkstra算法和A*算法是常用的解决方案。

### 11.5.2 字符串匹配

在文本编辑器中，需要高效地查找和替换文本。KMP算法和Boyer-Moore算法可以提高匹配效率。

### 11.5.3 数据压缩

在文件传输中，需要减少数据大小以节省带宽。霍夫曼编码和LZW算法是常用的压缩算法。

## 11.6 Java标准库中的算法

Java标准库提供了丰富的算法实现：

```java
import java.util.*;
import java.util.stream.*;

public class JavaAlgorithms {
    public static void main(String[] args) {
        // 排序算法
        List<Integer> list = Arrays.asList(5, 2, 8, 1, 9);
        Collections.sort(list); // 使用优化的归并排序/Timsort
        
        // 二分查找
        int[] array = {1, 2, 5, 8, 9};
        int index = Arrays.binarySearch(array, 5); // 返回索引2
        
        // 集合操作
        List<Integer> list1 = Arrays.asList(1, 2, 3);
        List<Integer> list2 = Arrays.asList(3, 4, 5);
        
        // 交集
        Set<Integer> intersection = list1.stream()
            .filter(list2::contains)
            .collect(Collectors.toSet());
        
        // 并集
        Set<Integer> union = Stream.concat(list1.stream(), list2.stream())
            .collect(Collectors.toSet());
        
        // 差集
        Set<Integer> difference = list1.stream()
            .filter(x -> !list2.contains(x))
            .collect(Collectors.toSet());
        
        System.out.println("交集: " + intersection);
        System.out.println("并集: " + union);
        System.out.println("差集: " + difference);
    }
}
```

## 11.7 最佳实践与注意事项

1. **选择合适的算法**：根据具体问题的特点选择最适合的算法
2. **考虑时间和空间权衡**：有时可以用空间换时间或用时间换空间
3. **边界条件处理**：注意处理空输入、单元素输入等特殊情况
4. **算法优化**：利用缓存、预处理等方式优化算法性能
5. **代码可读性**：在保证效率的前提下，保持代码清晰易懂

## 11.8 总结

本章介绍了算法设计与分析的基础知识，包括复杂度分析、常见算法设计技巧、正确性证明方法等。掌握这些基础知识对于开发高效、可靠的程序至关重要。

下一章我们将深入探讨分布式系统中的数据结构和算法问题。