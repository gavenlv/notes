# 第4章：树结构 - 二叉树、搜索树与平衡树

## 4.1 树的基本概念

### 4.1.1 树的定义

树是一种非线性的数据结构，它是由n（n≥0）个有限节点组成一个具有层次关系的集合。把它叫做"树"是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

树的基本术语：
- **节点（Node）**：树中的元素
- **根节点（Root）**：树的顶端节点
- **子节点（Child）**：节点的直接后继
- **父节点（Parent）**：节点的直接前驱
- **叶子节点（Leaf）**：没有子节点的节点
- **兄弟节点（Sibling）**：具有相同父节点的节点
- **路径（Path）**：从一个节点到另一个节点的节点序列
- **深度（Depth）**：从根节点到该节点的路径长度
- **高度（Height）**：从该节点到叶子节点的最长路径长度

### 4.1.2 树的性质

1. 树中任意两个节点之间有且仅有一条路径
2. 除根节点外，每个节点有且仅有一个父节点
3. 根节点没有父节点
4. 叶子节点没有子节点

## 4.2 二叉树（Binary Tree）

### 4.2.1 二叉树的定义

二叉树是每个节点最多有两个子树的树结构，通常子树被称作"左子树"和"右子树"。

二叉树的特点：
- 每个节点最多有两个子节点
- 左子树和右子树是有顺序的，不能颠倒
- 即使某节点只有一棵子树，也要区分是左子树还是右子树

### 4.2.2 二叉树的类型

#### 1. 满二叉树（Full Binary Tree）

除最后一层无任何节点外，每一层上的所有节点都有两个子节点的二叉树。

#### 2. 完全二叉树（Complete Binary Tree）

若设二叉树的高度为h，除第h层外，其它各层(1～h-1)的结点数都达到最大个数，第h层从左到右连续排列。

#### 3. 二叉搜索树（Binary Search Tree）

对于任意节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。

### 4.2.3 二叉树的实现

```java
// 二叉树节点定义
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

// 二叉树基本操作
public class BinaryTree {
    private TreeNode root;
    
    public BinaryTree() {
        this.root = null;
    }
    
    // 插入节点
    public void insert(int val) {
        root = insertRec(root, val);
        System.out.println("插入节点: " + val);
    }
    
    private TreeNode insertRec(TreeNode root, int val) {
        if (root == null) {
            return new TreeNode(val);
        }
        
        if (val < root.val) {
            root.left = insertRec(root.left, val);
        } else if (val > root.val) {
            root.right = insertRec(root.right, val);
        }
        
        return root;
    }
    
    // 查找节点
    public boolean search(int val) {
        boolean result = searchRec(root, val);
        System.out.println("查找节点 " + val + ": " + (result ? "找到" : "未找到"));
        return result;
    }
    
    private boolean searchRec(TreeNode root, int val) {
        if (root == null) {
            return false;
        }
        
        if (val == root.val) {
            return true;
        }
        
        if (val < root.val) {
            return searchRec(root.left, val);
        } else {
            return searchRec(root.right, val);
        }
    }
    
    // 删除节点
    public void delete(int val) {
        root = deleteRec(root, val);
        System.out.println("删除节点: " + val);
    }
    
    private TreeNode deleteRec(TreeNode root, int val) {
        if (root == null) {
            return root;
        }
        
        if (val < root.val) {
            root.left = deleteRec(root.left, val);
        } else if (val > root.val) {
            root.right = deleteRec(root.right, val);
        } else {
            // 找到要删除的节点
            if (root.left == null) {
                return root.right;
            } else if (root.right == null) {
                return root.left;
            }
            
            // 节点有两个子节点，找到右子树的最小值
            root.val = minValue(root.right);
            
            // 删除右子树的最小值节点
            root.right = deleteRec(root.right, root.val);
        }
        
        return root;
    }
    
    private int minValue(TreeNode root) {
        int minValue = root.val;
        while (root.left != null) {
            minValue = root.left.val;
            root = root.left;
        }
        return minValue;
    }
    
    // 前序遍历（根-左-右）
    public void preorderTraversal() {
        System.out.print("前序遍历: ");
        preorderRec(root);
        System.out.println();
    }
    
    private void preorderRec(TreeNode root) {
        if (root != null) {
            System.out.print(root.val + " ");
            preorderRec(root.left);
            preorderRec(root.right);
        }
    }
    
    // 中序遍历（左-根-右）
    public void inorderTraversal() {
        System.out.print("中序遍历: ");
        inorderRec(root);
        System.out.println();
    }
    
    private void inorderRec(TreeNode root) {
        if (root != null) {
            inorderRec(root.left);
            System.out.print(root.val + " ");
            inorderRec(root.right);
        }
    }
    
    // 后序遍历（左-右-根）
    public void postorderTraversal() {
        System.out.print("后序遍历: ");
        postorderRec(root);
        System.out.println();
    }
    
    private void postorderRec(TreeNode root) {
        if (root != null) {
            postorderRec(root.left);
            postorderRec(root.right);
            System.out.print(root.val + " ");
        }
    }
    
    // 层序遍历（广度优先遍历）
    public void levelOrderTraversal() {
        if (root == null) {
            System.out.println("层序遍历: 树为空");
            return;
        }
        
        java.util.Queue<TreeNode> queue = new java.util.LinkedList<>();
        queue.offer(root);
        System.out.print("层序遍历: ");
        
        while (!queue.isEmpty()) {
            TreeNode current = queue.poll();
            System.out.print(current.val + " ");
            
            if (current.left != null) {
                queue.offer(current.left);
            }
            
            if (current.right != null) {
                queue.offer(current.right);
            }
        }
        System.out.println();
    }
}
```

### 4.2.4 二叉树的遍历

二叉树的遍历是树结构中最重要的操作之一，主要有以下几种方式：

#### 1. 前序遍历（Preorder Traversal）

访问顺序：根节点 → 左子树 → 右子树

#### 2. 中序遍历（Inorder Traversal）

访问顺序：左子树 → 根节点 → 右子树

对于二叉搜索树，中序遍历的结果是有序的。

#### 3. 后序遍历（Postorder Traversal）

访问顺序：左子树 → 右子树 → 根节点

#### 4. 层序遍历（Level Order Traversal）

按层次从上到下、从左到右访问节点，也称为广度优先遍历。

### 4.2.5 二叉树操作的时间复杂度

| 操作 | 平均时间复杂度 | 最坏时间复杂度 | 说明 |
|------|----------------|----------------|------|
| 查找 | O(log n) | O(n) | 在平衡树中为O(log n) |
| 插入 | O(log n) | O(n) | 在平衡树中为O(log n) |
| 删除 | O(log n) | O(n) | 在平衡树中为O(log n) |
| 遍历 | O(n) | O(n) | 需要访问所有节点 |

## 4.3 二叉搜索树（Binary Search Tree）

### 4.3.1 二叉搜索树的性质

二叉搜索树（BST）是一种特殊的二叉树，具有以下性质：
1. 若左子树不空，则左子树上所有节点的值均小于根节点的值
2. 若右子树不空，则右子树上所有节点的值均大于根节点的值
3. 左、右子树也分别为二叉搜索树
4. 没有键值相等的节点

### 4.3.2 二叉搜索树的优势

1. **高效的查找**：平均时间复杂度为O(log n)
2. **有序性**：中序遍历可以得到有序序列
3. **动态性**：支持动态插入和删除操作

### 4.3.3 二叉搜索树的应用

```java
// 使用二叉搜索树实现有序集合
public class BSTSet {
    private TreeNode root;
    private int size;
    
    public BSTSet() {
        this.root = null;
        this.size = 0;
    }
    
    // 添加元素
    public void add(int val) {
        if (!contains(val)) {
            root = insertRec(root, val);
            size++;
            System.out.println("添加元素: " + val);
        } else {
            System.out.println("元素已存在: " + val);
        }
    }
    
    private TreeNode insertRec(TreeNode root, int val) {
        if (root == null) {
            return new TreeNode(val);
        }
        
        if (val < root.val) {
            root.left = insertRec(root.left, val);
        } else if (val > root.val) {
            root.right = insertRec(root.right, val);
        }
        
        return root;
    }
    
    // 检查是否包含元素
    public boolean contains(int val) {
        return searchRec(root, val);
    }
    
    private boolean searchRec(TreeNode root, int val) {
        if (root == null) {
            return false;
        }
        
        if (val == root.val) {
            return true;
        }
        
        if (val < root.val) {
            return searchRec(root.left, val);
        } else {
            return searchRec(root.right, val);
        }
    }
    
    // 删除元素
    public void remove(int val) {
        if (contains(val)) {
            root = deleteRec(root, val);
            size--;
            System.out.println("删除元素: " + val);
        } else {
            System.out.println("元素不存在: " + val);
        }
    }
    
    private TreeNode deleteRec(TreeNode root, int val) {
        if (root == null) {
            return root;
        }
        
        if (val < root.val) {
            root.left = deleteRec(root.left, val);
        } else if (val > root.val) {
            root.right = deleteRec(root.right, val);
        } else {
            // 找到要删除的节点
            if (root.left == null) {
                return root.right;
            } else if (root.right == null) {
                return root.left;
            }
            
            // 节点有两个子节点，找到右子树的最小值
            root.val = minValue(root.right);
            
            // 删除右子树的最小值节点
            root.right = deleteRec(root.right, root.val);
        }
        
        return root;
    }
    
    private int minValue(TreeNode root) {
        int minValue = root.val;
        while (root.left != null) {
            minValue = root.left.val;
            root = root.left;
        }
        return minValue;
    }
    
    // 获取集合大小
    public int size() {
        return size;
    }
    
    // 中序遍历打印所有元素
    public void printElements() {
        System.out.print("集合元素: ");
        inorderRec(root);
        System.out.println();
    }
    
    private void inorderRec(TreeNode root) {
        if (root != null) {
            inorderRec(root.left);
            System.out.print(root.val + " ");
            inorderRec(root.right);
        }
    }
}
```

## 4.4 平衡二叉树（AVL Tree）

### 4.4.1 平衡二叉树的概念

平衡二叉树（AVL树）是一种自平衡的二叉搜索树，任何节点的两个子树的高度差最多为1。

AVL树的特点：
1. 本身是二叉搜索树
2. 带有平衡条件：每个节点的左右子树的高度差不超过1
3. 查找、插入和删除在平均和最坏情况下都是O(log n)

### 4.4.2 平衡因子

平衡因子 = 左子树高度 - 右子树高度

平衡因子的取值范围：{-1, 0, 1}

### 4.4.3 旋转操作

当插入或删除节点导致树不平衡时，需要通过旋转操作来恢复平衡：

#### 1. 右旋（Right Rotation）

当左子树过高时进行右旋：

```java
// 右旋操作
private TreeNode rightRotate(TreeNode y) {
    TreeNode x = y.left;
    TreeNode T2 = x.right;
    
    // 执行旋转
    x.right = y;
    y.left = T2;
    
    // 更新高度
    // updateHeight(y);
    // updateHeight(x);
    
    // 返回新的根节点
    return x;
}
```

#### 2. 左旋（Left Rotation）

当右子树过高时进行左旋：

```java
// 左旋操作
private TreeNode leftRotate(TreeNode x) {
    TreeNode y = x.right;
    TreeNode T2 = y.left;
    
    // 执行旋转
    y.left = x;
    x.right = T2;
    
    // 更新高度
    // updateHeight(x);
    // updateHeight(y);
    
    // 返回新的根节点
    return y;
}
```

#### 3. 左右旋（Left-Right Rotation）

先对左子树进行左旋，再对整棵树进行右旋。

#### 4. 右左旋（Right-Left Rotation）

先对右子树进行右旋，再对整棵树进行左旋。

### 4.4.4 AVL树的实现

```java
// AVL树节点定义
class AVLNode {
    int val;
    AVLNode left;
    AVLNode right;
    int height;
    
    AVLNode(int val) {
        this.val = val;
        this.height = 1;
    }
}

// AVL树实现
public class AVLTree {
    private AVLNode root;
    
    // 获取节点高度
    private int getHeight(AVLNode node) {
        if (node == null) {
            return 0;
        }
        return node.height;
    }
    
    // 获取平衡因子
    private int getBalance(AVLNode node) {
        if (node == null) {
            return 0;
        }
        return getHeight(node.left) - getHeight(node.right);
    }
    
    // 右旋
    private AVLNode rightRotate(AVLNode y) {
        AVLNode x = y.left;
        AVLNode T2 = x.right;
        
        // 执行旋转
        x.right = y;
        y.left = T2;
        
        // 更新高度
        y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1;
        x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1;
        
        // 返回新的根节点
        return x;
    }
    
    // 左旋
    private AVLNode leftRotate(AVLNode x) {
        AVLNode y = x.right;
        AVLNode T2 = y.left;
        
        // 执行旋转
        y.left = x;
        x.right = T2;
        
        // 更新高度
        x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1;
        y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1;
        
        // 返回新的根节点
        return y;
    }
    
    // 插入节点
    public void insert(int val) {
        root = insertRec(root, val);
        System.out.println("AVL树插入节点: " + val);
    }
    
    private AVLNode insertRec(AVLNode node, int val) {
        // 1. 执行正常的BST插入
        if (node == null) {
            return new AVLNode(val);
        }
        
        if (val < node.val) {
            node.left = insertRec(node.left, val);
        } else if (val > node.val) {
            node.right = insertRec(node.right, val);
        } else {
            // 相等的值不插入
            return node;
        }
        
        // 2. 更新当前节点的高度
        node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));
        
        // 3. 获取平衡因子
        int balance = getBalance(node);
        
        // 4. 如果节点不平衡，进行相应的旋转
        
        // Left Left Case
        if (balance > 1 && val < node.left.val) {
            return rightRotate(node);
        }
        
        // Right Right Case
        if (balance < -1 && val > node.right.val) {
            return leftRotate(node);
        }
        
        // Left Right Case
        if (balance > 1 && val > node.left.val) {
            node.left = leftRotate(node.left);
            return rightRotate(node);
        }
        
        // Right Left Case
        if (balance < -1 && val < node.right.val) {
            node.right = rightRotate(node.right);
            return leftRotate(node);
        }
        
        // 返回未修改的节点指针
        return node;
    }
    
    // 中序遍历
    public void inorderTraversal() {
        System.out.print("AVL树中序遍历: ");
        inorderRec(root);
        System.out.println();
    }
    
    private void inorderRec(AVLNode root) {
        if (root != null) {
            inorderRec(root.left);
            System.out.print(root.val + " ");
            inorderRec(root.right);
        }
    }
}
```

## 4.5 树结构的应用场景

### 4.5.1 文件系统

操作系统中的文件系统通常采用树形结构组织：

```java
// 简化的文件系统节点
class FileSystemNode {
    String name;
    boolean isDirectory;
    java.util.List<FileSystemNode> children;
    String content;  // 仅对文件有效
    
    public FileSystemNode(String name, boolean isDirectory) {
        this.name = name;
        this.isDirectory = isDirectory;
        if (isDirectory) {
            this.children = new java.util.ArrayList<>();
        }
    }
    
    // 添加子节点
    public void addChild(FileSystemNode child) {
        if (isDirectory && children != null) {
            children.add(child);
        }
    }
    
    // 查找子节点
    public FileSystemNode findChild(String name) {
        if (!isDirectory || children == null) {
            return null;
        }
        
        for (FileSystemNode child : children) {
            if (child.name.equals(name)) {
                return child;
            }
        }
        return null;
    }
}
```

### 4.5.2 数据库索引

数据库中的B树和B+树索引是树结构的重要应用：

```java
// 简化的B树节点（概念演示）
class BTreeNode {
    int[] keys;          // 关键字数组
    int t;               // 最小度数
    BTreeNode[] children; // 子节点数组
    int n;               // 当前关键字数量
    boolean leaf;        // 是否为叶子节点
    
    public BTreeNode(int t, boolean leaf) {
        this.t = t;
        this.leaf = leaf;
        this.keys = new int[2 * t - 1];
        this.children = new BTreeNode[2 * t];
        this.n = 0;
    }
    
    // 查找关键字
    public BTreeNode search(int k) {
        int i = 0;
        while (i < n && k > keys[i]) {
            i++;
        }
        
        if (i < n && keys[i] == k) {
            return this;
        }
        
        if (leaf) {
            return null;
        }
        
        return children[i].search(k);
    }
}
```

### 4.5.3 表达式树

编译器中使用表达式树来表示和计算表达式：

```java
// 表达式树节点
class ExpressionNode {
    char value;
    ExpressionNode left, right;
    
    public ExpressionNode(char value) {
        this.value = value;
        this.left = this.right = null;
    }
}

// 表达式树构建和计算
public class ExpressionTree {
    // 根据后缀表达式构建表达式树
    public ExpressionNode buildExpressionTree(String postfix) {
        java.util.Stack<ExpressionNode> stack = new java.util.Stack<>();
        
        for (char ch : postfix.toCharArray()) {
            if (isOperand(ch)) {
                stack.push(new ExpressionNode(ch));
            } else {
                ExpressionNode node = new ExpressionNode(ch);
                node.right = stack.pop();
                node.left = stack.pop();
                stack.push(node);
            }
        }
        
        return stack.pop();
    }
    
    // 计算表达式树的值
    public int evaluate(ExpressionNode root) {
        if (root == null) {
            return 0;
        }
        
        // 如果是叶子节点（操作数）
        if (root.left == null && root.right == null) {
            return root.value - '0';  // 简化处理，假设是单数字
        }
        
        // 递归计算左右子树
        int leftVal = evaluate(root.left);
        int rightVal = evaluate(root.right);
        
        // 根据操作符计算结果
        switch (root.value) {
            case '+': return leftVal + rightVal;
            case '-': return leftVal - rightVal;
            case '*': return leftVal * rightVal;
            case '/': return leftVal / rightVal;
        }
        
        return 0;
    }
    
    private boolean isOperand(char ch) {
        return Character.isDigit(ch);
    }
}
```

## 4.6 最佳实践与注意事项

### 4.6.1 选择合适的树结构

1. **普通二叉树**：适用于简单的层次结构表示
2. **二叉搜索树**：适用于需要频繁查找、插入、删除且对顺序有要求的场景
3. **平衡二叉树**：适用于对性能要求较高的搜索场景
4. **B树/B+树**：适用于数据库和文件系统的索引

### 4.6.2 性能优化建议

1. **平衡性维护**：对于搜索频繁的场景，使用自平衡树
2. **内存管理**：合理设计节点结构，避免内存浪费
3. **迭代替代递归**：对于深度较大的树，使用迭代避免栈溢出

### 4.6.3 常见问题及解决方案

1. **树的不平衡**：使用AVL树、红黑树等自平衡树
2. **内存泄漏**：确保正确释放不再使用的节点
3. **遍历效率**：根据需求选择合适的遍历方式

## 4.7 本章小结

本章详细介绍了树结构这一重要的非线性数据结构。我们学习了树的基本概念、二叉树的性质和操作、二叉搜索树的特点以及平衡二叉树的自平衡机制。

树结构在计算机科学中应用广泛，如文件系统、数据库索引、表达式计算等。掌握树结构对于理解更复杂的数据结构和算法至关重要。

下一章我们将学习堆这种特殊的树结构，以及优先队列的实现。