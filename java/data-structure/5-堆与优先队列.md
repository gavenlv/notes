# 第5章：堆与优先队列 - 高效的数据管理

## 5.1 堆的基本概念

### 5.1.1 堆的定义

堆（Heap）是一种特殊的完全二叉树，满足堆属性的数据结构。堆分为两种类型：
1. **最大堆（Max Heap）**：父节点的值总是大于或等于任何一个子节点的值
2. **最小堆（Min Heap）**：父节点的值总是小于或等于任何一个子节点的值

### 5.1.2 堆的性质

1. **结构性质**：堆是一棵完全二叉树，这意味着除了最后一层，其他层都被完全填满，且最后一层的节点都尽可能地集中在左边
2. **堆序性质**：对于最大堆，任意节点的值都不大于其父节点的值；对于最小堆，任意节点的值都不小于其父节点的值

### 5.1.3 堆的存储结构

由于堆是完全二叉树，我们可以使用数组来高效地存储堆，而不需要使用指针链接的节点结构。

在基于数组的表示中，如果父节点的索引为i（从0开始），则：
- 左子节点的索引为 2*i + 1
- 右子节点的索引为 2*i + 2
- 父节点的索引为 (i-1)/2

## 5.2 堆的操作

### 5.2.1 堆的插入操作

向堆中插入新元素的过程：
1. 将新元素添加到数组的末尾（即树的最后一层最右边的位置）
2. 执行"上浮"（heapify up）操作，将新元素与其父节点比较并交换位置，直到满足堆的性质

```java
// 向最小堆中插入元素
public void insert(int val) {
    heap.add(val);  // 添加到末尾
    heapifyUp(heap.size() - 1);  // 上浮操作
}

// 上浮操作
private void heapifyUp(int index) {
    // 当不是根节点且父节点值大于当前节点值时，交换并继续上浮
    while (index > 0 && heap.get(parent(index)) > heap.get(index)) {
        swap(index, parent(index));
        index = parent(index);
    }
}
```

### 5.2.2 堆的删除操作

从堆中删除元素通常是删除根节点（最大堆的最大值或最小堆的最小值）：
1. 将最后一个元素移到根节点位置
2. 移除最后一个元素
3. 执行"下沉"（heapify down）操作，将根节点与其子节点比较并交换位置，直到满足堆的性质

```java
// 从最小堆中删除最小元素（根节点）
public int extractMin() {
    if (heap.isEmpty()) {
        throw new IllegalStateException("堆为空");
    }
    
    int min = heap.get(0);  // 获取根节点（最小值）
    int lastElement = heap.remove(heap.size() - 1);  // 移除最后一个元素
    
    if (!heap.isEmpty()) {
        heap.set(0, lastElement);  // 将最后一个元素放到根节点
        heapifyDown(0);  // 下沉操作
    }
    
    return min;
}

// 下沉操作
private void heapifyDown(int index) {
    int leftChildIndex = leftChild(index);
    int rightChildIndex = rightChild(index);
    int smallest = index;
    
    // 找到当前节点及其子节点中的最小值
    if (leftChildIndex < heap.size() && heap.get(leftChildIndex) < heap.get(smallest)) {
        smallest = leftChildIndex;
    }
    
    if (rightChildIndex < heap.size() && heap.get(rightChildIndex) < heap.get(smallest)) {
        smallest = rightChildIndex;
    }
    
    // 如果最小值不是当前节点，则交换并继续下沉
    if (smallest != index) {
        swap(index, smallest);
        heapifyDown(smallest);
    }
}
```

### 5.2.3 构建堆

可以通过两种方式构建堆：
1. **逐个插入法**：逐个插入元素，每次插入后维护堆性质，时间复杂度为O(n log n)
2. **堆化法**：先将所有元素放入数组，然后从最后一个非叶子节点开始向前依次进行下沉操作，时间复杂度为O(n)

```java
// 通过堆化构建最小堆
public void buildHeap(List<Integer> array) {
    heap = new ArrayList<>(array);
    // 从最后一个非叶子节点开始向前进行下沉操作
    for (int i = (heap.size() / 2) - 1; i >= 0; i--) {
        heapifyDown(i);
    }
}
```

## 5.3 堆的实现

```java
import java.util.*;

// 最小堆实现
public class MinHeap {
    private List<Integer> heap;
    
    public MinHeap() {
        this.heap = new ArrayList<>();
    }
    
    // 获取父节点索引
    private int parent(int index) {
        return (index - 1) / 2;
    }
    
    // 获取左子节点索引
    private int leftChild(int index) {
        return 2 * index + 1;
    }
    
    // 获取右子节点索引
    private int rightChild(int index) {
        return 2 * index + 2;
    }
    
    // 交换两个元素
    private void swap(int i, int j) {
        int temp = heap.get(i);
        heap.set(i, heap.get(j));
        heap.set(j, temp);
    }
    
    // 插入元素
    public void insert(int val) {
        heap.add(val);
        heapifyUp(heap.size() - 1);
        System.out.println("插入元素: " + val);
    }
    
    // 上浮操作
    private void heapifyUp(int index) {
        while (index > 0 && heap.get(parent(index)) > heap.get(index)) {
            swap(index, parent(index));
            index = parent(index);
        }
    }
    
    // 删除最小元素
    public int extractMin() {
        if (heap.isEmpty()) {
            throw new IllegalStateException("堆为空");
        }
        
        int min = heap.get(0);
        int lastElement = heap.remove(heap.size() - 1);
        
        if (!heap.isEmpty()) {
            heap.set(0, lastElement);
            heapifyDown(0);
        }
        
        System.out.println("删除最小元素: " + min);
        return min;
    }
    
    // 下沉操作
    private void heapifyDown(int index) {
        int leftChildIndex = leftChild(index);
        int rightChildIndex = rightChild(index);
        int smallest = index;
        
        if (leftChildIndex < heap.size() && heap.get(leftChildIndex) < heap.get(smallest)) {
            smallest = leftChildIndex;
        }
        
        if (rightChildIndex < heap.size() && heap.get(rightChildIndex) < heap.get(smallest)) {
            smallest = rightChildIndex;
        }
        
        if (smallest != index) {
            swap(index, smallest);
            heapifyDown(smallest);
        }
    }
    
    // 获取最小元素（不删除）
    public int peek() {
        if (heap.isEmpty()) {
            throw new IllegalStateException("堆为空");
        }
        return heap.get(0);
    }
    
    // 判断堆是否为空
    public boolean isEmpty() {
        return heap.isEmpty();
    }
    
    // 获取堆的大小
    public int size() {
        return heap.size();
    }
    
    // 打印堆
    public void printHeap() {
        System.out.println("堆内容: " + heap);
    }
    
    // 通过堆化构建堆
    public void buildHeap(List<Integer> array) {
        heap = new ArrayList<>(array);
        for (int i = (heap.size() / 2) - 1; i >= 0; i--) {
            heapifyDown(i);
        }
        System.out.println("通过数组构建堆: " + array);
    }
}
```

## 5.4 优先队列

### 5.4.1 优先队列的概念

优先队列是一种特殊的队列，其中每个元素都有一个优先级。当访问元素时，具有最高优先级的元素最先被删除。优先队列通常使用堆来实现，因为堆能够高效地维护元素的优先级顺序。

### 5.4.2 优先队列的应用

1. **任务调度**：操作系统中的进程调度
2. **事件驱动仿真**：按照时间顺序处理事件
3. **图算法**：Dijkstra算法、Prim算法等
4. **数据压缩**：赫夫曼编码
5. **寻找前K个最大/最小元素**

### 5.4.3 优先队列的实现

```java
import java.util.*;

// 自定义优先队列实现（基于最小堆）
public class PriorityQueueCustom<T> {
    private List<QueueElement<T>> heap;
    private Comparator<T> comparator;
    
    // 队列元素类，包含元素值和优先级
    private static class QueueElement<T> {
        T value;
        int priority;
        
        QueueElement(T value, int priority) {
            this.value = value;
            this.priority = priority;
        }
    }
    
    // 默认构造函数（数值越小优先级越高）
    public PriorityQueueCustom() {
        this.heap = new ArrayList<>();
        this.comparator = null;
    }
    
    // 使用自定义比较器构造函数
    public PriorityQueueCustom(Comparator<T> comparator) {
        this.heap = new ArrayList<>();
        this.comparator = comparator;
    }
    
    // 获取父节点索引
    private int parent(int index) {
        return (index - 1) / 2;
    }
    
    // 获取左子节点索引
    private int leftChild(int index) {
        return 2 * index + 1;
    }
    
    // 获取右子节点索引
    private int rightChild(int index) {
        return 2 * index + 2;
    }
    
    // 交换两个元素
    private void swap(int i, int j) {
        QueueElement<T> temp = heap.get(i);
        heap.set(i, heap.get(j));
        heap.set(j, temp);
    }
    
    // 比较两个元素的优先级
    private boolean hasHigherPriority(int i, int j) {
        if (comparator != null) {
            // 使用自定义比较器
            return comparator.compare(heap.get(i).value, heap.get(j).value) < 0;
        } else {
            // 默认比较优先级数值（数值越小优先级越高）
            return heap.get(i).priority < heap.get(j).priority;
        }
    }
    
    // 入队操作
    public void enqueue(T value, int priority) {
        heap.add(new QueueElement<>(value, priority));
        heapifyUp(heap.size() - 1);
        System.out.println("入队元素: " + value + " (优先级: " + priority + ")");
    }
    
    // 上浮操作
    private void heapifyUp(int index) {
        while (index > 0 && hasHigherPriority(index, parent(index))) {
            swap(index, parent(index));
            index = parent(index);
        }
    }
    
    // 出队操作
    public T dequeue() {
        if (heap.isEmpty()) {
            throw new IllegalStateException("队列为空");
        }
        
        T value = heap.get(0).value;
        QueueElement<T> lastElement = heap.remove(heap.size() - 1);
        
        if (!heap.isEmpty()) {
            heap.set(0, lastElement);
            heapifyDown(0);
        }
        
        System.out.println("出队元素: " + value);
        return value;
    }
    
    // 下沉操作
    private void heapifyDown(int index) {
        int leftChildIndex = leftChild(index);
        int rightChildIndex = rightChild(index);
        int highestPriority = index;
        
        if (leftChildIndex < heap.size() && hasHigherPriority(leftChildIndex, highestPriority)) {
            highestPriority = leftChildIndex;
        }
        
        if (rightChildIndex < heap.size() && hasHigherPriority(rightChildIndex, highestPriority)) {
            highestPriority = rightChildIndex;
        }
        
        if (highestPriority != index) {
            swap(index, highestPriority);
            heapifyDown(highestPriority);
        }
    }
    
    // 查看队首元素（不删除）
    public T peek() {
        if (heap.isEmpty()) {
            throw new IllegalStateException("队列为空");
        }
        return heap.get(0).value;
    }
    
    // 判断队列是否为空
    public boolean isEmpty() {
        return heap.isEmpty();
    }
    
    // 获取队列大小
    public int size() {
        return heap.size();
    }
    
    // 打印队列
    public void printQueue() {
        System.out.print("队列内容: ");
        for (QueueElement<T> element : heap) {
            System.out.print("(" + element.value + ", " + element.priority + ") ");
        }
        System.out.println();
    }
}
```

## 5.5 堆与优先队列的应用场景

### 5.5.1 Top K 问题

寻找数据集中前K个最大或最小的元素：

```java
import java.util.*;

public class TopKElements {
    // 寻找前K个最大的元素（使用最小堆）
    public static List<Integer> findKLargest(int[] nums, int k) {
        // 使用最小堆维护K个最大元素
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        
        for (int num : nums) {
            if (minHeap.size() < k) {
                minHeap.offer(num);
            } else if (num > minHeap.peek()) {
                minHeap.poll();
                minHeap.offer(num);
            }
        }
        
        return new ArrayList<>(minHeap);
    }
    
    // 寻找前K个最小的元素（使用最大堆）
    public static List<Integer> findKSmallest(int[] nums, int k) {
        // 使用最大堆维护K个最小元素
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
        
        for (int num : nums) {
            if (maxHeap.size() < k) {
                maxHeap.offer(num);
            } else if (num < maxHeap.peek()) {
                maxHeap.poll();
                maxHeap.offer(num);
            }
        }
        
        return new ArrayList<>(maxHeap);
    }
}
```

### 5.5.2 合并K个有序链表

```java
import java.util.*;

class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

public class MergeKSortedLists {
    // 合并K个有序链表
    public static ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) {
            return null;
        }
        
        // 使用最小堆维护各个链表的头节点
        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);
        
        // 将所有非空链表的头节点加入堆中
        for (ListNode list : lists) {
            if (list != null) {
                minHeap.offer(list);
            }
        }
        
        // 构建合并后的链表
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        
        while (!minHeap.isEmpty()) {
            // 取出最小节点
            ListNode node = minHeap.poll();
            current.next = node;
            current = current.next;
            
            // 如果该节点还有下一个节点，将其加入堆中
            if (node.next != null) {
                minHeap.offer(node.next);
            }
        }
        
        return dummy.next;
    }
}
```

### 5.5.3 任务调度系统

```java
import java.time.LocalDateTime;
import java.util.*;

// 任务类
class Task {
    String name;
    LocalDateTime executionTime;
    int priority;
    
    public Task(String name, LocalDateTime executionTime, int priority) {
        this.name = name;
        this.executionTime = executionTime;
        this.priority = priority;
    }
    
    @Override
    public String toString() {
        return "Task{name='" + name + "', time=" + executionTime + ", priority=" + priority + "}";
    }
}

// 基于时间和优先级的任务调度器
public class TaskScheduler {
    // 任务调度优先队列（按执行时间和优先级排序）
    private PriorityQueue<Task> taskQueue;
    
    public TaskScheduler() {
        // 比较器：首先按执行时间排序，时间相同的按优先级排序
        this.taskQueue = new PriorityQueue<>((t1, t2) -> {
            int timeComparison = t1.executionTime.compareTo(t2.executionTime);
            if (timeComparison != 0) {
                return timeComparison;
            }
            return Integer.compare(t1.priority, t2.priority);
        });
    }
    
    // 添加任务
    public void addTask(Task task) {
        taskQueue.offer(task);
        System.out.println("添加任务: " + task);
    }
    
    // 获取下一个要执行的任务
    public Task getNextTask() {
        if (taskQueue.isEmpty()) {
            return null;
        }
        return taskQueue.poll();
    }
    
    // 查看下一个任务（不移除）
    public Task peekNextTask() {
        if (taskQueue.isEmpty()) {
            return null;
        }
        return taskQueue.peek();
    }
    
    // 获取待处理任务数量
    public int getPendingTasksCount() {
        return taskQueue.size();
    }
}
```

## 5.6 堆操作的时间复杂度分析

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| 插入元素 | O(log n) | 需要上浮调整 |
| 删除根元素 | O(log n) | 需要下沉调整 |
| 获取根元素 | O(1) | 直接访问数组第一个元素 |
| 构建堆 | O(n) | 使用堆化方法 |
| 空间复杂度 | O(n) | 存储n个元素 |

## 5.7 最佳实践与注意事项

### 5.7.1 选择合适的堆类型

1. **最大堆**：适用于需要快速获取最大元素的场景
2. **最小堆**：适用于需要快速获取最小元素的场景
3. **自定义堆**：根据具体需求定义比较规则

### 5.7.2 性能优化建议

1. **预估容量**：如果知道大致元素数量，预先设置合适容量避免频繁扩容
2. **批量构建**：如果有大量初始数据，使用堆化方法构建比逐个插入更高效
3. **避免频繁重建**：尽量复用已有堆结构而不是频繁重建

### 5.7.3 常见问题及解决方案

1. **内存泄漏**：确保及时清理不用的对象引用
2. **并发安全**：在多线程环境中使用同步机制保护堆操作
3. **异常处理**：正确处理空堆的边界情况

## 5.8 Java标准库中的堆和优先队列

Java提供了内置的优先队列实现：

```java
import java.util.*;

public class JavaPriorityQueueExample {
    public static void demonstrateJavaPriorityQueue() {
        System.out.println("=== Java标准库PriorityQueue演示 ===");
        
        // 默认最小堆
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        int[] values = {4, 1, 3, 2, 16, 9, 10, 14, 8, 7};
        
        System.out.println("插入元素到最小堆:");
        for (int val : values) {
            minHeap.offer(val);
            System.out.print(val + " ");
        }
        System.out.println("\n最小堆内容: " + minHeap);
        
        System.out.println("依次取出最小元素:");
        while (!minHeap.isEmpty()) {
            System.out.print(minHeap.poll() + " ");
        }
        System.out.println();
        
        // 最大堆（使用自定义比较器）
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
        System.out.println("\n插入元素到最大堆:");
        for (int val : values) {
            maxHeap.offer(val);
            System.out.print(val + " ");
        }
        System.out.println("\n最大堆内容: " + maxHeap);
        
        System.out.println("依次取出最大元素:");
        while (!maxHeap.isEmpty()) {
            System.out.print(maxHeap.poll() + " ");
        }
        System.out.println();
        
        // 自定义对象的优先队列
        PriorityQueue<Task> taskQueue = new PriorityQueue<>((t1, t2) -> 
            Integer.compare(t1.priority, t2.priority));
        
        taskQueue.offer(new Task("低优先级任务", LocalDateTime.now().plusMinutes(10), 3));
        taskQueue.offer(new Task("高优先级任务", LocalDateTime.now().plusMinutes(5), 1));
        taskQueue.offer(new Task("中优先级任务", LocalDateTime.now().plusMinutes(7), 2));
        
        System.out.println("\n按优先级处理任务:");
        while (!taskQueue.isEmpty()) {
            System.out.println("处理: " + taskQueue.poll());
        }
    }
}
```

## 5.9 本章小结

本章详细介绍了堆这种重要的数据结构以及基于堆实现的优先队列。我们学习了堆的性质、操作原理和实现方式，以及如何利用堆解决实际问题。

堆的主要优势在于能够高效地维护元素的优先级关系，特别适合需要频繁获取最大或最小元素的场景。通过堆实现的优先队列在任务调度、图算法、数据处理等领域有着广泛应用。

掌握了堆和优先队列的概念和实现后，我们在下一章将学习哈希表，这是一种能够提供常数时间查找效率的数据结构。