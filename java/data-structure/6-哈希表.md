# 第6章：哈希表 - 快速查找的艺术

## 6.1 哈希表的基本概念

### 6.1.1 哈希表的定义

哈希表（Hash Table），也称为散列表，是一种根据键（Key）直接访问在内存存储位置的数据结构。它通过一个哈希函数（Hash Function）将键映射到表中的一个位置来访问记录，以加快查找速度。

哈希表的核心思想是用空间换时间，通过直接寻址的方式实现平均O(1)时间复杂度的查找、插入和删除操作。

### 6.1.2 哈希表的基本原理

哈希表的工作原理可以分为以下几个步骤：
1. **哈希函数计算**：对键进行哈希计算，得到一个哈希值
2. **索引映射**：将哈希值映射到数组的索引范围
3. **存储/查找**：在对应索引位置存储或查找数据

### 6.1.3 哈希函数

哈希函数是哈希表的核心组件，它决定了键值对在哈希表中的分布情况。一个好的哈希函数应该具备以下特点：
1. **确定性**：相同的键总是产生相同的哈希值
2. **均匀分布**：尽可能均匀地将键映射到哈希表的各个位置
3. **高效性**：计算简单快速
4. **雪崩效应**：输入的微小变化能引起输出的显著变化

常见的哈希函数：
1. **除法散列法**：h(k) = k mod m（m通常选择素数）
2. **乘法散列法**：h(k) = floor(m * (k * A mod 1))（A为常数）
3. **全域散列法**：使用随机化技术

## 6.2 哈希冲突及解决方案

### 6.2.1 哈希冲突的概念

由于哈希表的存储空间是有限的，而键的取值范围可能很大，因此不同的键可能被映射到同一个位置，这种现象称为哈希冲突（Hash Collision）。

### 6.2.2 冲突解决方法

#### 1. 链地址法（Chaining）

链地址法将哈希到同一个位置的所有元素存储在一个链表中。当发生冲突时，将新元素添加到链表中。

```java
// 链地址法实现的哈希表节点
class HashNode<K, V> {
    K key;
    V value;
    HashNode<K, V> next;
    
    public HashNode(K key, V value) {
        this.key = key;
        this.value = value;
        this.next = null;
    }
}

// 链地址法哈希表实现
public class ChainedHashTable<K, V> {
    private int bucketSize;  // 桶的数量
    private List<HashNode<K, V>> bucketArray;  // 桶数组
    
    public ChainedHashTable(int bucketSize) {
        this.bucketSize = bucketSize;
        this.bucketArray = new ArrayList<>(bucketSize);
        
        // 初始化桶数组
        for (int i = 0; i < bucketSize; i++) {
            bucketArray.add(null);
        }
    }
    
    // 哈希函数
    private int getBucketIndex(K key) {
        int hashCode = key.hashCode();
        return Math.abs(hashCode) % bucketSize;
    }
    
    // 插入键值对
    public void put(K key, V value) {
        int bucketIndex = getBucketIndex(key);
        HashNode<K, V> head = bucketArray.get(bucketIndex);
        
        // 检查键是否已存在
        while (head != null) {
            if (head.key.equals(key)) {
                head.value = value;  // 更新值
                return;
            }
            head = head.next;
        }
        
        // 键不存在，插入新节点
        HashNode<K, V> newNode = new HashNode<>(key, value);
        head = bucketArray.get(bucketIndex);
        newNode.next = head;
        bucketArray.set(bucketIndex, newNode);
        System.out.println("插入键值对: (" + key + ", " + value + ")");
    }
    
    // 获取值
    public V get(K key) {
        int bucketIndex = getBucketIndex(key);
        HashNode<K, V> head = bucketArray.get(bucketIndex);
        
        // 在链表中查找键
        while (head != null) {
            if (head.key.equals(key)) {
                System.out.println("查找键 " + key + ": " + head.value);
                return head.value;
            }
            head = head.next;
        }
        
        System.out.println("查找键 " + key + ": 未找到");
        return null;
    }
    
    // 删除键值对
    public V remove(K key) {
        int bucketIndex = getBucketIndex(key);
        HashNode<K, V> head = bucketArray.get(bucketIndex);
        
        // 如果要删除的是第一个节点
        if (head != null && head.key.equals(key)) {
            V value = head.value;
            bucketArray.set(bucketIndex, head.next);
            System.out.println("删除键值对: (" + key + ", " + value + ")");
            return value;
        }
        
        // 在链表中查找要删除的节点
        while (head != null && head.next != null) {
            if (head.next.key.equals(key)) {
                V value = head.next.value;
                head.next = head.next.next;
                System.out.println("删除键值对: (" + key + ", " + value + ")");
                return value;
            }
            head = head.next;
        }
        
        System.out.println("删除键 " + key + ": 未找到");
        return null;
    }
}
```

#### 2. 开放地址法（Open Addressing）

开放地址法在发生冲突时，通过某种探测方法在哈希表中寻找下一个空闲位置。

常见的探测方法：
1. **线性探测**：逐个检查下一个位置
2. **二次探测**：使用二次函数确定探测序列
3. **双重散列**：使用第二个哈希函数确定探测步长

```java
// 开放地址法哈希表实现（线性探测）
public class OpenAddressingHashTable<K, V> {
    private int capacity;  // 哈希表容量
    private int size;      // 当前元素数量
    private K[] keys;      // 键数组
    private V[] values;    // 值数组
    private boolean[] isOccupied;  // 标记位置是否被占用
    private boolean[] isDeleted;   // 标记位置是否被删除
    
    @SuppressWarnings("unchecked")
    public OpenAddressingHashTable(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.keys = (K[]) new Object[capacity];
        this.values = (V[]) new Object[capacity];
        this.isOccupied = new boolean[capacity];
        this.isDeleted = new boolean[capacity];
    }
    
    // 哈希函数
    private int hash(K key) {
        return Math.abs(key.hashCode()) % capacity;
    }
    
    // 线性探测
    private int findSlot(K key) {
        int index = hash(key);
        int startIndex = index;
        
        // 线性探测直到找到空槽或匹配的键
        while (isOccupied[index] && !isDeleted[index] && !keys[index].equals(key)) {
            index = (index + 1) % capacity;
            // 防止无限循环
            if (index == startIndex) {
                return -1;  // 哈希表已满
            }
        }
        
        return index;
    }
    
    // 插入键值对
    public void put(K key, V value) {
        if (size >= capacity) {
            System.out.println("哈希表已满，无法插入: (" + key + ", " + value + ")");
            return;
        }
        
        int index = findSlot(key);
        if (index == -1) {
            System.out.println("哈希表已满，无法插入: (" + key + ", " + value + ")");
            return;
        }
        
        // 如果是新插入而不是更新
        if (!isOccupied[index] || isDeleted[index]) {
            size++;
        }
        
        keys[index] = key;
        values[index] = value;
        isOccupied[index] = true;
        isDeleted[index] = false;
        System.out.println("插入键值对: (" + key + ", " + value + ")");
    }
    
    // 获取值
    public V get(K key) {
        int index = findSlot(key);
        if (index != -1 && isOccupied[index] && !isDeleted[index] && keys[index].equals(key)) {
            System.out.println("查找键 " + key + ": " + values[index]);
            return values[index];
        }
        
        System.out.println("查找键 " + key + ": 未找到");
        return null;
    }
    
    // 删除键值对
    public V remove(K key) {
        int index = findSlot(key);
        if (index != -1 && isOccupied[index] && !isDeleted[index] && keys[index].equals(key)) {
            V value = values[index];
            isDeleted[index] = true;  // 标记为已删除
            size--;
            System.out.println("删除键值对: (" + key + ", " + value + ")");
            return value;
        }
        
        System.out.println("删除键 " + key + ": 未找到");
        return null;
    }
    
    // 获取当前元素数量
    public int size() {
        return size;
    }
    
    // 检查哈希表是否为空
    public boolean isEmpty() {
        return size == 0;
    }
}
```

## 6.3 哈希表的实现

### 6.3.1 动态扩容的哈希表

为了保持哈希表的性能，当负载因子（元素数量/桶数量）超过某个阈值时，需要对哈希表进行扩容。

```java
import java.util.*;

// 支持动态扩容的哈希表实现
public class DynamicHashTable<K, V> {
    private int capacity;  // 当前容量
    private int size;      // 当前元素数量
    private double loadFactorThreshold;  // 负载因子阈值
    private List<HashNode<K, V>>[] buckets;  // 桶数组
    
    // 哈希表节点
    private static class HashNode<K, V> {
        K key;
        V value;
        HashNode<K, V> next;
        
        HashNode(K key, V value) {
            this.key = key;
            this.value = value;
            this.next = null;
        }
    }
    
    // 构造函数
    @SuppressWarnings("unchecked")
    public DynamicHashTable() {
        this.capacity = 16;  // 初始容量
        this.size = 0;
        this.loadFactorThreshold = 0.75;  // 负载因子阈值
        this.buckets = new List[capacity];
        
        // 初始化桶数组
        for (int i = 0; i < capacity; i++) {
            buckets[i] = null;
        }
    }
    
    // 哈希函数
    private int getBucketIndex(K key) {
        return Math.abs(key.hashCode()) % capacity;
    }
    
    // 计算负载因子
    private double getLoadFactor() {
        return (double) size / capacity;
    }
    
    // 扩容操作
    @SuppressWarnings("unchecked")
    private void resize() {
        System.out.println("扩容哈希表，当前容量: " + capacity + " -> " + (capacity * 2));
        
        int oldCapacity = capacity;
        List<HashNode<K, V>>[] oldBuckets = buckets;
        
        // 扩大容量
        capacity *= 2;
        size = 0;
        buckets = new List[capacity];
        
        // 初始化新桶数组
        for (int i = 0; i < capacity; i++) {
            buckets[i] = null;
        }
        
        // 重新哈希所有元素
        for (int i = 0; i < oldCapacity; i++) {
            List<HashNode<K, V>> bucket = oldBuckets[i];
            HashNode<K, V> node = bucket != null ? bucket.get(0) : null;
            
            while (node != null) {
                put(node.key, node.value);
                node = node.next;
            }
        }
    }
    
    // 插入键值对
    public void put(K key, V value) {
        // 检查是否需要扩容
        if (getLoadFactor() >= loadFactorThreshold) {
            resize();
        }
        
        int bucketIndex = getBucketIndex(key);
        
        // 如果桶为空，创建新的链表
        if (buckets[bucketIndex] == null) {
            buckets[bucketIndex] = new ArrayList<>();
        }
        
        List<HashNode<K, V>> bucket = buckets[bucketIndex];
        
        // 检查键是否已存在
        for (HashNode<K, V> node : bucket) {
            if (node.key.equals(key)) {
                node.value = value;  // 更新值
                System.out.println("更新键值对: (" + key + ", " + value + ")");
                return;
            }
        }
        
        // 键不存在，插入新节点
        bucket.add(new HashNode<>(key, value));
        size++;
        System.out.println("插入键值对: (" + key + ", " + value + ")");
    }
    
    // 获取值
    public V get(K key) {
        int bucketIndex = getBucketIndex(key);
        
        if (buckets[bucketIndex] == null) {
            System.out.println("查找键 " + key + ": 未找到");
            return null;
        }
        
        List<HashNode<K, V>> bucket = buckets[bucketIndex];
        
        // 在链表中查找键
        for (HashNode<K, V> node : bucket) {
            if (node.key.equals(key)) {
                System.out.println("查找键 " + key + ": " + node.value);
                return node.value;
            }
        }
        
        System.out.println("查找键 " + key + ": 未找到");
        return null;
    }
    
    // 删除键值对
    public V remove(K key) {
        int bucketIndex = getBucketIndex(key);
        
        if (buckets[bucketIndex] == null) {
            System.out.println("删除键 " + key + ": 未找到");
            return null;
        }
        
        List<HashNode<K, V>> bucket = buckets[bucketIndex];
        
        // 在链表中查找要删除的节点
        Iterator<HashNode<K, V>> iterator = bucket.iterator();
        while (iterator.hasNext()) {
            HashNode<K, V> node = iterator.next();
            if (node.key.equals(key)) {
                V value = node.value;
                iterator.remove();
                size--;
                System.out.println("删除键值对: (" + key + ", " + value + ")");
                return value;
            }
        }
        
        System.out.println("删除键 " + key + ": 未找到");
        return null;
    }
    
    // 获取当前元素数量
    public int size() {
        return size;
    }
    
    // 检查哈希表是否为空
    public boolean isEmpty() {
        return size == 0;
    }
    
    // 打印哈希表状态
    public void printStats() {
        System.out.println("哈希表状态:");
        System.out.println("  容量: " + capacity);
        System.out.println("  元素数量: " + size);
        System.out.println("  负载因子: " + String.format("%.2f", getLoadFactor()));
        System.out.println("  负载因子阈值: " + loadFactorThreshold);
    }
}
```

## 6.4 哈希表的应用场景

### 6.4.1 缓存系统

哈希表是实现缓存系统的核心数据结构，能够提供快速的键值对存储和检索：

```java
import java.util.*;

// 简单的LRU缓存实现
class LRUCache<K, V> {
    private final int capacity;
    private final Map<K, V> cache;
    private final LinkedList<K> accessOrder;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap<>();
        this.accessOrder = new LinkedList<>();
    }
    
    public V get(K key) {
        if (!cache.containsKey(key)) {
            System.out.println("缓存未命中: " + key);
            return null;
        }
        
        // 更新访问顺序
        accessOrder.remove(key);
        accessOrder.addFirst(key);
        System.out.println("缓存命中: " + key + " = " + cache.get(key));
        return cache.get(key);
    }
    
    public void put(K key, V value) {
        if (cache.containsKey(key)) {
            // 更新已存在的键
            cache.put(key, value);
            accessOrder.remove(key);
            accessOrder.addFirst(key);
        } else {
            // 添加新键
            if (cache.size() >= capacity) {
                // 移除最近最少使用的项
                K lruKey = accessOrder.removeLast();
                cache.remove(lruKey);
                System.out.println("移除LRU项: " + lruKey);
            }
            cache.put(key, value);
            accessOrder.addFirst(key);
        }
        System.out.println("缓存存储: " + key + " = " + value);
    }
    
    public void printCache() {
        System.out.println("当前缓存内容:");
        for (K key : accessOrder) {
            System.out.println("  " + key + " = " + cache.get(key));
        }
    }
}
```

### 6.4.2 数据库索引

数据库系统广泛使用哈希索引来加速数据检索：

```java
// 简化的数据库索引实现
class DatabaseIndex {
    private Map<String, List<Integer>> index;  // 索引：字段值 -> 记录ID列表
    
    public DatabaseIndex() {
        this.index = new HashMap<>();
    }
    
    // 为字段值添加记录ID
    public void addIndex(String fieldValue, int recordId) {
        index.computeIfAbsent(fieldValue, k -> new ArrayList<>()).add(recordId);
        System.out.println("添加索引: " + fieldValue + " -> " + recordId);
    }
    
    // 根据字段值查找记录ID
    public List<Integer> findRecords(String fieldValue) {
        List<Integer> recordIds = index.getOrDefault(fieldValue, new ArrayList<>());
        System.out.println("查找索引 " + fieldValue + ": " + recordIds);
        return recordIds;
    }
    
    // 删除字段值对应的记录ID
    public void removeIndex(String fieldValue, int recordId) {
        List<Integer> recordIds = index.get(fieldValue);
        if (recordIds != null) {
            recordIds.remove(Integer.valueOf(recordId));
            // 如果该字段值没有对应的记录了，删除索引项
            if (recordIds.isEmpty()) {
                index.remove(fieldValue);
            }
            System.out.println("删除索引: " + fieldValue + " -> " + recordId);
        } else {
            System.out.println("删除索引: " + fieldValue + " -> " + recordId + " (未找到)");
        }
    }
}
```

### 6.4.3 字符串匹配

哈希表可以用于字符串匹配算法，如Rabin-Karp算法：

```java
import java.util.*;

// Rabin-Karp字符串匹配算法
public class RabinKarp {
    private static final int PRIME = 101;  // 质数用于哈希计算
    
    // 在文本中查找模式串的所有出现位置
    public static List<Integer> search(String pattern, String text) {
        List<Integer> result = new ArrayList<>();
        int patternLength = pattern.length();
        int textLength = text.length();
        
        if (patternLength > textLength) {
            return result;
        }
        
        // 计算模式串和文本第一个窗口的哈希值
        int patternHash = calculateHash(pattern, patternLength);
        int textHash = calculateHash(text, patternLength);
        
        // 计算最高位的权重
        int h = 1;
        for (int i = 0; i < patternLength - 1; i++) {
            h = (h * 256) % PRIME;
        }
        
        // 滑动窗口匹配
        for (int i = 0; i <= textLength - patternLength; i++) {
            // 如果哈希值匹配，进行字符比较确认
            if (patternHash == textHash) {
                boolean match = true;
                for (int j = 0; j < patternLength; j++) {
                    if (text.charAt(i + j) != pattern.charAt(j)) {
                        match = false;
                        break;
                    }
                }
                
                if (match) {
                    result.add(i);
                    System.out.println("找到匹配位置: " + i);
                }
            }
            
            // 计算下一个窗口的哈希值
            if (i < textLength - patternLength) {
                textHash = (256 * (textHash - text.charAt(i) * h) + text.charAt(i + patternLength)) % PRIME;
                
                // 处理负数情况
                if (textHash < 0) {
                    textHash += PRIME;
                }
            }
        }
        
        return result;
    }
    
    // 计算字符串的哈希值
    private static int calculateHash(String str, int length) {
        int hash = 0;
        for (int i = 0; i < length; i++) {
            hash = (256 * hash + str.charAt(i)) % PRIME;
        }
        return hash;
    }
}
```

## 6.5 哈希表的性能分析

### 6.5.1 时间复杂度

| 操作 | 平均时间复杂度 | 最坏时间复杂度 | 说明 |
|------|----------------|----------------|------|
| 查找 | O(1) | O(n) | 在理想情况下为常数时间 |
| 插入 | O(1) | O(n) | 在理想情况下为常数时间 |
| 删除 | O(1) | O(n) | 在理想情况下为常数时间 |

### 6.5.2 空间复杂度

哈希表的空间复杂度为O(n)，其中n为存储的元素数量。

### 6.5.3 影响性能的因素

1. **哈希函数质量**：好的哈希函数能均匀分布键值，减少冲突
2. **负载因子**：负载因子过高会导致冲突增多，性能下降
3. **冲突解决策略**：不同的冲突解决方法有不同的性能特征
4. **扩容策略**：合理的扩容机制能保持哈希表的性能

## 6.6 Java标准库中的哈希表

Java提供了多种哈希表实现：

```java
import java.util.*;

public class JavaHashMapExample {
    public static void demonstrateJavaHashMap() {
        System.out.println("=== Java标准库HashMap演示 ===");
        
        // HashMap基本操作
        Map<String, Integer> hashMap = new HashMap<>();
        
        // 插入键值对
        hashMap.put("apple", 5);
        hashMap.put("banana", 3);
        hashMap.put("orange", 8);
        hashMap.put("grape", 12);
        System.out.println("HashMap内容: " + hashMap);
        
        // 查找值
        System.out.println("apple的数量: " + hashMap.get("apple"));
        System.out.println("不存在的键kiwi: " + hashMap.get("kiwi"));
        
        // 更新值
        hashMap.put("apple", 7);
        System.out.println("更新后apple的数量: " + hashMap.get("apple"));
        
        // 删除键值对
        Integer removedValue = hashMap.remove("banana");
        System.out.println("删除banana，值为: " + removedValue);
        System.out.println("删除后HashMap内容: " + hashMap);
        
        // 遍历HashMap
        System.out.println("遍历HashMap:");
        for (Map.Entry<String, Integer> entry : hashMap.entrySet()) {
            System.out.println("  " + entry.getKey() + " = " + entry.getValue());
        }
        
        // LinkedHashMap保持插入顺序
        System.out.println("\n=== LinkedHashMap演示 ===");
        Map<String, Integer> linkedHashMap = new LinkedHashMap<>();
        linkedHashMap.put("first", 1);
        linkedHashMap.put("second", 2);
        linkedHashMap.put("third", 3);
        System.out.println("LinkedHashMap内容: " + linkedHashMap);
        
        // TreeMap按键排序
        System.out.println("\n=== TreeMap演示 ===");
        Map<String, Integer> treeMap = new TreeMap<>();
        treeMap.put("zebra", 26);
        treeMap.put("apple", 1);
        treeMap.put("banana", 2);
        System.out.println("TreeMap内容（按键排序）: " + treeMap);
        
        // Hashtable线程安全（但不推荐使用）
        System.out.println("\n=== Hashtable演示 ===");
        Hashtable<String, Integer> hashtable = new Hashtable<>();
        hashtable.put("key1", 100);
        hashtable.put("key2", 200);
        System.out.println("Hashtable内容: " + hashtable);
    }
}
```

## 6.7 最佳实践与注意事项

### 6.7.1 选择合适的哈希表实现

1. **HashMap**：通用场景下的首选，性能好但不保证顺序
2. **LinkedHashMap**：需要保持插入顺序或访问顺序的场景
3. **TreeMap**：需要按键排序的场景
4. **ConcurrentHashMap**：多线程环境下的高并发场景

### 6.7.2 设计良好的哈希函数

1. **使用对象的hashCode()方法**：对于自定义类，应正确重写hashCode()和equals()方法
2. **避免哈希碰撞**：确保不同对象产生不同的哈希值
3. **考虑性能**：哈希函数应简单高效

### 6.7.3 性能优化建议

1. **合理设置初始容量**：如果能预估元素数量，设置合适的初始容量避免频繁扩容
2. **调整负载因子**：根据时间和空间需求权衡，调整负载因子
3. **避免频繁扩容**：扩容操作代价较高，应尽量避免

### 6.7.4 常见问题及解决方案

1. **哈希碰撞过多**：检查哈希函数质量，考虑使用更好的哈希算法
2. **内存泄漏**：及时清理不用的键值对，避免持有无用引用
3. **并发安全**：在多线程环境中使用线程安全的哈希表实现

## 6.8 本章小结

本章详细介绍了哈希表这一重要的数据结构。我们学习了哈希表的基本原理、哈希函数的设计、冲突解决方法以及动态扩容机制。

哈希表以其平均O(1)时间复杂度的查找、插入和删除操作，在缓存系统、数据库索引、字符串匹配等领域有着广泛应用。掌握哈希表的实现原理和使用技巧对于提高程序性能至关重要。

在下一章中，我们将学习图结构，这是一种能够表示复杂关系的数据结构，在社交网络、路径规划等领域发挥着重要作用。