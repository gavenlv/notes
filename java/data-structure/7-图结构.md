# 第7章：图结构 - 复杂关系建模

## 7.1 图的基本概念

### 7.1.1 图的定义

图（Graph）是由顶点（Vertex）的非空有限集合和顶点之间边（Edge）的集合组成的一种数据结构，通常表示为 G(V, E)，其中：
- V 是顶点集合
- E 是边集合

图可以用来表示各种复杂的二元关系，如社交网络、交通网络、计算机网络等。

### 7.1.2 图的分类

#### 1. 有向图与无向图

- **无向图（Undirected Graph）**：边没有方向，连接顶点u和v的边可以用(u,v)或(v,u)表示
- **有向图（Directed Graph）**：边有方向，从顶点u指向顶点v的边只能用<u,v>表示

#### 2. 权重图与非权重图

- **权重图（Weighted Graph）**：每条边都有一个权重值，表示距离、成本或其他度量
- **非权重图（Unweighted Graph）**：所有边都没有权重

#### 3. 简单图与多重图

- **简单图（Simple Graph）**：没有自环（顶点到自身的边）和多重边（两个顶点之间的多条边）
- **多重图（Multigraph）**：允许自环和多重边

### 7.1.3 图的相关术语

1. **邻接（Adjacency）**：如果两个顶点之间有一条边相连，则称它们是邻接的
2. **度（Degree）**：与顶点相连的边的数量
   - 无向图中，顶点的度就是与其相连的边数
   - 有向图中，分为入度（In-degree）和出度（Out-degree）
3. **路径（Path）**：从一个顶点到另一个顶点经过的顶点序列
4. **环（Cycle）**：起点和终点相同的路径
5. **连通性（Connectivity）**：
   - 无向图：任意两个顶点之间都存在路径
   - 有向图：强连通（任意两个顶点互相可达）和弱连通（忽略方向后连通）

## 7.2 图的表示方法

### 7.2.1 邻接矩阵

邻接矩阵是一个二维数组，其中行和列分别代表图中的顶点。如果顶点i和顶点j之间有边，则矩阵[i][j]为1（或权重值），否则为0。

```java
/**
 * 邻接矩阵表示的图
 */
public class AdjacencyMatrixGraph {
    private int vertices;           // 顶点数量
    private boolean[][] adjMatrix;  // 邻接矩阵
    private boolean isDirected;     // 是否为有向图
    
    public AdjacencyMatrixGraph(int vertices, boolean isDirected) {
        this.vertices = vertices;
        this.isDirected = isDirected;
        this.adjMatrix = new boolean[vertices][vertices];
    }
    
    // 添加边
    public void addEdge(int src, int dest) {
        if (src >= 0 && src < vertices && dest >= 0 && dest < vertices) {
            adjMatrix[src][dest] = true;
            // 如果是无向图，还需要添加反向边
            if (!isDirected) {
                adjMatrix[dest][src] = true;
            }
            System.out.println("添加边: " + src + " -> " + dest);
        }
    }
    
    // 删除边
    public void removeEdge(int src, int dest) {
        if (src >= 0 && src < vertices && dest >= 0 && dest < vertices) {
            adjMatrix[src][dest] = false;
            if (!isDirected) {
                adjMatrix[dest][src] = false;
            }
            System.out.println("删除边: " + src + " -> " + dest);
        }
    }
    
    // 检查是否存在边
    public boolean hasEdge(int src, int dest) {
        if (src >= 0 && src < vertices && dest >= 0 && dest < vertices) {
            return adjMatrix[src][dest];
        }
        return false;
    }
    
    // 获取顶点的邻居
    public List<Integer> getNeighbors(int vertex) {
        List<Integer> neighbors = new ArrayList<>();
        if (vertex >= 0 && vertex < vertices) {
            for (int i = 0; i < vertices; i++) {
                if (adjMatrix[vertex][i]) {
                    neighbors.add(i);
                }
            }
        }
        return neighbors;
    }
    
    // 获取顶点的度
    public int getDegree(int vertex) {
        int degree = 0;
        if (vertex >= 0 && vertex < vertices) {
            for (int i = 0; i < vertices; i++) {
                if (adjMatrix[vertex][i]) {
                    degree++;
                }
            }
        }
        return degree;
    }
    
    // 打印邻接矩阵
    public void printGraph() {
        System.out.println("邻接矩阵表示的图:");
        System.out.print("   ");
        for (int i = 0; i < vertices; i++) {
            System.out.printf("%3d", i);
        }
        System.out.println();
        
        for (int i = 0; i < vertices; i++) {
            System.out.printf("%2d:", i);
            for (int j = 0; j < vertices; j++) {
                System.out.printf("%3s", adjMatrix[i][j] ? "1" : "0");
            }
            System.out.println();
        }
    }
}
```

### 7.2.2 邻接表

邻接表使用一个数组或列表来存储每个顶点的邻居列表。这种方法更节省空间，特别适用于稀疏图。

```java
import java.util.*;

/**
 * 邻接表表示的图
 */
public class AdjacencyListGraph {
    private int vertices;              // 顶点数量
    private List<List<Integer>> adjList;  // 邻接表
    private boolean isDirected;        // 是否为有向图
    
    public AdjacencyListGraph(int vertices, boolean isDirected) {
        this.vertices = vertices;
        this.isDirected = isDirected;
        this.adjList = new ArrayList<>(vertices);
        
        // 初始化邻接表
        for (int i = 0; i < vertices; i++) {
            adjList.add(new ArrayList<>());
        }
    }
    
    // 添加边
    public void addEdge(int src, int dest) {
        if (src >= 0 && src < vertices && dest >= 0 && dest < vertices) {
            adjList.get(src).add(dest);
            // 如果是无向图，还需要添加反向边
            if (!isDirected) {
                adjList.get(dest).add(src);
            }
            System.out.println("添加边: " + src + " -> " + dest);
        }
    }
    
    // 删除边
    public void removeEdge(int src, int dest) {
        if (src >= 0 && src < vertices && dest >= 0 && dest < vertices) {
            adjList.get(src).remove(Integer.valueOf(dest));
            if (!isDirected) {
                adjList.get(dest).remove(Integer.valueOf(src));
            }
            System.out.println("删除边: " + src + " -> " + dest);
        }
    }
    
    // 检查是否存在边
    public boolean hasEdge(int src, int dest) {
        if (src >= 0 && src < vertices && dest >= 0 && dest < vertices) {
            return adjList.get(src).contains(dest);
        }
        return false;
    }
    
    // 获取顶点的邻居
    public List<Integer> getNeighbors(int vertex) {
        if (vertex >= 0 && vertex < vertices) {
            return new ArrayList<>(adjList.get(vertex));
        }
        return new ArrayList<>();
    }
    
    // 获取顶点的度
    public int getDegree(int vertex) {
        if (vertex >= 0 && vertex < vertices) {
            return adjList.get(vertex).size();
        }
        return 0;
    }
    
    // 打印邻接表
    public void printGraph() {
        System.out.println("邻接表表示的图:");
        for (int i = 0; i < vertices; i++) {
            System.out.print(i + ": ");
            for (int neighbor : adjList.get(i)) {
                System.out.print(neighbor + " ");
            }
            System.out.println();
        }
    }
}
```

### 7.2.3 边的列表表示

边的列表表示将图中的所有边存储在一个列表中，每条边由起点、终点和权重（如果是权重图）组成。

```java
import java.util.*;

/**
 * 边的表示
 */
class Edge {
    int src;      // 起点
    int dest;     // 终点
    int weight;   // 权重
    
    public Edge(int src, int dest, int weight) {
        this.src = src;
        this.dest = dest;
        this.weight = weight;
    }
    
    @Override
    public String toString() {
        return "(" + src + "->" + dest + ", " + weight + ")";
    }
}

/**
 * 边的列表表示的图
 */
public class EdgeListGraph {
    private int vertices;         // 顶点数量
    private List<Edge> edgeList;  // 边列表
    private boolean isDirected;   // 是否为有向图
    private boolean isWeighted;   // 是否为权重图
    
    public EdgeListGraph(int vertices, boolean isDirected, boolean isWeighted) {
        this.vertices = vertices;
        this.isDirected = isDirected;
        this.isWeighted = isWeighted;
        this.edgeList = new ArrayList<>();
    }
    
    // 添加边
    public void addEdge(int src, int dest, int weight) {
        if (src >= 0 && src < vertices && dest >= 0 && dest < vertices) {
            edgeList.add(new Edge(src, dest, weight));
            // 如果是无向图，还需要添加反向边
            if (!isDirected) {
                edgeList.add(new Edge(dest, src, weight));
            }
            System.out.println("添加边: (" + src + "->" + dest + ", " + weight + ")");
        }
    }
    
    // 添加无权重边
    public void addEdge(int src, int dest) {
        addEdge(src, dest, 1);
    }
    
    // 获取所有边
    public List<Edge> getEdges() {
        return new ArrayList<>(edgeList);
    }
    
    // 获取顶点的邻居（基于边列表）
    public List<Integer> getNeighbors(int vertex) {
        List<Integer> neighbors = new ArrayList<>();
        for (Edge edge : edgeList) {
            if (edge.src == vertex) {
                neighbors.add(edge.dest);
            }
        }
        return neighbors;
    }
    
    // 打印边列表
    public void printGraph() {
        System.out.println("边列表表示的图:");
        for (Edge edge : edgeList) {
            System.out.println(edge);
        }
    }
}
```

## 7.3 图的遍历算法

### 7.3.1 深度优先搜索（DFS）

深度优先搜索从一个起始顶点开始，沿着一条路径尽可能深地访问顶点，直到不能再继续为止，然后回溯并探索其他路径。

```java
import java.util.*;

/**
 * 使用邻接表实现的图的DFS遍历
 */
public class DFSGraph extends AdjacencyListGraph {
    
    public DFSGraph(int vertices, boolean isDirected) {
        super(vertices, isDirected);
    }
    
    // 递归版本的DFS
    public void dfsRecursive(int startVertex) {
        boolean[] visited = new boolean[super.vertices];
        System.out.print("DFS遍历 (递归): ");
        dfsRecursiveHelper(startVertex, visited);
        System.out.println();
    }
    
    private void dfsRecursiveHelper(int vertex, boolean[] visited) {
        visited[vertex] = true;
        System.out.print(vertex + " ");
        
        // 访问所有未访问的邻居
        for (int neighbor : super.getNeighbors(vertex)) {
            if (!visited[neighbor]) {
                dfsRecursiveHelper(neighbor, visited);
            }
        }
    }
    
    // 迭代版本的DFS（使用栈）
    public void dfsIterative(int startVertex) {
        boolean[] visited = new boolean[super.vertices];
        Stack<Integer> stack = new Stack<>();
        
        stack.push(startVertex);
        System.out.print("DFS遍历 (迭代): ");
        
        while (!stack.isEmpty()) {
            int vertex = stack.pop();
            
            if (!visited[vertex]) {
                visited[vertex] = true;
                System.out.print(vertex + " ");
                
                // 将邻居压入栈中（逆序压入以保证正确的访问顺序）
                List<Integer> neighbors = super.getNeighbors(vertex);
                for (int i = neighbors.size() - 1; i >= 0; i--) {
                    int neighbor = neighbors.get(i);
                    if (!visited[neighbor]) {
                        stack.push(neighbor);
                    }
                }
            }
        }
        System.out.println();
    }
    
    // 检查图是否连通
    public boolean isConnected() {
        if (super.vertices == 0) return true;
        
        boolean[] visited = new boolean[super.vertices];
        dfsRecursiveHelper(0, visited);
        
        // 检查是否所有顶点都被访问过
        for (boolean v : visited) {
            if (!v) return false;
        }
        return true;
    }
}
```

### 7.3.2 广度优先搜索（BFS）

广度优先搜索从一个起始顶点开始，先访问其所有邻居，然后再依次访问邻居的邻居，以此类推。

```java
import java.util.*;

/**
 * 使用邻接表实现的图的BFS遍历
 */
public class BFSGraph extends AdjacencyListGraph {
    
    public BFSGraph(int vertices, boolean isDirected) {
        super(vertices, isDirected);
    }
    
    // BFS遍历
    public void bfs(int startVertex) {
        boolean[] visited = new boolean[super.vertices];
        Queue<Integer> queue = new LinkedList<>();
        
        visited[startVertex] = true;
        queue.offer(startVertex);
        System.out.print("BFS遍历: ");
        
        while (!queue.isEmpty()) {
            int vertex = queue.poll();
            System.out.print(vertex + " ");
            
            // 访问所有未访问的邻居
            for (int neighbor : super.getNeighbors(vertex)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.offer(neighbor);
                }
            }
        }
        System.out.println();
    }
    
    // 寻找从源顶点到目标顶点的最短路径（无权重图）
    public List<Integer> findShortestPath(int src, int dest) {
        if (src == dest) {
            return Arrays.asList(src);
        }
        
        boolean[] visited = new boolean[super.vertices];
        int[] parent = new int[super.vertices];
        Queue<Integer> queue = new LinkedList<>();
        
        // 初始化parent数组
        for (int i = 0; i < super.vertices; i++) {
            parent[i] = -1;
        }
        
        visited[src] = true;
        queue.offer(src);
        
        while (!queue.isEmpty()) {
            int vertex = queue.poll();
            
            // 如果找到了目标顶点
            if (vertex == dest) {
                return reconstructPath(parent, src, dest);
            }
            
            // 访问所有未访问的邻居
            for (int neighbor : super.getNeighbors(vertex)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    parent[neighbor] = vertex;
                    queue.offer(neighbor);
                }
            }
        }
        
        // 如果没有找到路径
        return new ArrayList<>();
    }
    
    // 重构路径
    private List<Integer> reconstructPath(int[] parent, int src, int dest) {
        List<Integer> path = new ArrayList<>();
        int current = dest;
        
        while (current != -1) {
            path.add(current);
            current = parent[current];
        }
        
        Collections.reverse(path);
        return path;
    }
}
```

## 7.4 最短路径算法

### 7.4.1 Dijkstra算法

Dijkstra算法用于在权重非负的图中找到从源顶点到其他所有顶点的最短路径。

```java
import java.util.*;

/**
 * Dijkstra算法实现
 */
public class DijkstraGraph extends AdjacencyListGraph {
    // 带权重的边
    static class WeightedEdge {
        int dest;
        int weight;
        
        public WeightedEdge(int dest, int weight) {
            this.dest = dest;
            this.weight = weight;
        }
    }
    
    private List<List<WeightedEdge>> weightedAdjList;
    
    public DijkstraGraph(int vertices) {
        super(vertices, true); // Dijkstra通常用于有向图
        this.weightedAdjList = new ArrayList<>(vertices);
        for (int i = 0; i < vertices; i++) {
            weightedAdjList.add(new ArrayList<>());
        }
    }
    
    // 添加带权重的边
    public void addWeightedEdge(int src, int dest, int weight) {
        if (src >= 0 && src < super.vertices && dest >= 0 && dest < super.vertices) {
            weightedAdjList.get(src).add(new WeightedEdge(dest, weight));
            System.out.println("添加带权重边: " + src + " -> " + dest + " (权重: " + weight + ")");
        }
    }
    
    // Dijkstra算法
    public int[] dijkstra(int src) {
        // 距离数组，初始化为无穷大
        int[] dist = new int[super.vertices];
        boolean[] visited = new boolean[super.vertices];
        
        // 初始化距离数组
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[src] = 0;
        
        // 优先队列，存储(顶点, 距离)对
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
        pq.offer(new int[]{src, 0});
        
        System.out.println("Dijkstra算法执行过程:");
        
        while (!pq.isEmpty()) {
            int[] current = pq.poll();
            int u = current[0];
            int distance = current[1];
            
            // 如果已经处理过这个顶点，跳过
            if (visited[u]) continue;
            
            visited[u] = true;
            System.out.println("  访问顶点 " + u + "，当前距离: " + distance);
            
            // 更新邻居的距离
            for (WeightedEdge edge : weightedAdjList.get(u)) {
                int v = edge.dest;
                int weight = edge.weight;
                
                // 如果找到更短的路径
                if (!visited[v] && dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                    pq.offer(new int[]{v, dist[v]});
                    System.out.println("    更新顶点 " + v + " 的距离为: " + dist[v]);
                }
            }
        }
        
        return dist;
    }
    
    // 打印最短距离结果
    public void printShortestDistances(int src, int[] distances) {
        System.out.println("从顶点 " + src + " 到各顶点的最短距离:");
        for (int i = 0; i < distances.length; i++) {
            if (distances[i] == Integer.MAX_VALUE) {
                System.out.println("  到顶点 " + i + ": 无法到达");
            } else {
                System.out.println("  到顶点 " + i + ": " + distances[i]);
            }
        }
    }
}
```

### 7.4.2 Floyd-Warshall算法

Floyd-Warshall算法用于找到图中所有顶点对之间的最短路径。

```java
/**
 * Floyd-Warshall算法实现
 */
public class FloydWarshallGraph {
    private int vertices;
    private int[][] graph;
    private static final int INF = Integer.MAX_VALUE;
    
    public FloydWarshallGraph(int vertices) {
        this.vertices = vertices;
        this.graph = new int[vertices][vertices];
        
        // 初始化图，对角线为0，其他为无穷大
        for (int i = 0; i < vertices; i++) {
            for (int j = 0; j < vertices; j++) {
                if (i == j) {
                    graph[i][j] = 0;
                } else {
                    graph[i][j] = INF;
                }
            }
        }
    }
    
    // 添加带权重的边
    public void addEdge(int src, int dest, int weight) {
        if (src >= 0 && src < vertices && dest >= 0 && dest < vertices) {
            graph[src][dest] = weight;
            System.out.println("添加带权重边: " + src + " -> " + dest + " (权重: " + weight + ")");
        }
    }
    
    // Floyd-Warshall算法
    public int[][] floydWarshall() {
        // 创建距离矩阵的副本
        int[][] dist = new int[vertices][vertices];
        for (int i = 0; i < vertices; i++) {
            for (int j = 0; j < vertices; j++) {
                dist[i][j] = graph[i][j];
            }
        }
        
        System.out.println("Floyd-Warshall算法执行过程:");
        
        // 对于每个中间顶点k
        for (int k = 0; k < vertices; k++) {
            System.out.println("  以顶点 " + k + " 作为中间顶点:");
            
            // 对于每个源顶点i
            for (int i = 0; i < vertices; i++) {
                // 对于每个目标顶点j
                for (int j = 0; j < vertices; j++) {
                    // 如果顶点k可以从i到达，且j可以从k到达
                    if (dist[i][k] != INF && dist[k][j] != INF) {
                        // 检查通过k的路径是否更短
                        if (dist[i][k] + dist[k][j] < dist[i][j]) {
                            dist[i][j] = dist[i][k] + dist[k][j];
                            System.out.println("    更新路径: " + i + " -> " + j + 
                                             " (通过 " + k + ")，新距离: " + dist[i][j]);
                        }
                    }
                }
            }
        }
        
        return dist;
    }
    
    // 打印距离矩阵
    public void printDistanceMatrix(int[][] dist) {
        System.out.println("所有顶点对之间的最短距离矩阵:");
        System.out.printf("%4s", "");
        for (int i = 0; i < vertices; i++) {
            System.out.printf("%6d", i);
        }
        System.out.println();
        
        for (int i = 0; i < vertices; i++) {
            System.out.printf("%3d:", i);
            for (int j = 0; j < vertices; j++) {
                if (dist[i][j] == INF) {
                    System.out.printf("%6s", "INF");
                } else {
                    System.out.printf("%6d", dist[i][j]);
                }
            }
            System.out.println();
        }
    }
}
```

## 7.5 最小生成树算法

### 7.5.1 Kruskal算法

Kruskal算法是一种贪心算法，用于在无向权重图中找到最小生成树。

```java
import java.util.*;

/**
 * Kruskal算法实现
 */
public class KruskalMST {
    // 边的表示
    static class Edge implements Comparable<Edge> {
        int src, dest, weight;
        
        public Edge(int src, int dest, int weight) {
            this.src = src;
            this.dest = dest;
            this.weight = weight;
        }
        
        @Override
        public int compareTo(Edge other) {
            return this.weight - other.weight;
        }
    }
    
    // 并查集（Union-Find）数据结构
    static class UnionFind {
        private int[] parent;
        private int[] rank;
        
        public UnionFind(int n) {
            parent = new int[n];
            rank = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                rank[i] = 0;
            }
        }
        
        // 查找根节点（带路径压缩）
        public int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]); // 路径压缩
            }
            return parent[x];
        }
        
        // 合并两个集合（按秩合并）
        public void union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            
            if (rootX != rootY) {
                // 按秩合并
                if (rank[rootX] < rank[rootY]) {
                    parent[rootX] = rootY;
                } else if (rank[rootX] > rank[rootY]) {
                    parent[rootY] = rootX;
                } else {
                    parent[rootY] = rootX;
                    rank[rootX]++;
                }
            }
        }
    }
    
    private int vertices;
    private List<Edge> edges;
    
    public KruskalMST(int vertices) {
        this.vertices = vertices;
        this.edges = new ArrayList<>();
    }
    
    // 添加边
    public void addEdge(int src, int dest, int weight) {
        edges.add(new Edge(src, dest, weight));
        System.out.println("添加边: (" + src + ", " + dest + ", " + weight + ")");
    }
    
    // Kruskal算法
    public List<Edge> kruskalMST() {
        List<Edge> result = new ArrayList<>();
        
        // 按权重排序所有边
        Collections.sort(edges);
        System.out.println("按权重排序后的边:");
        for (Edge edge : edges) {
            System.out.println("  (" + edge.src + ", " + edge.dest + ", " + edge.weight + ")");
        }
        
        // 初始化并查集
        UnionFind uf = new UnionFind(vertices);
        
        System.out.println("Kruskal算法执行过程:");
        
        // 处理每条边
        for (Edge edge : edges) {
            int rootSrc = uf.find(edge.src);
            int rootDest = uf.find(edge.dest);
            
            // 如果这条边不会形成环，就加入结果
            if (rootSrc != rootDest) {
                result.add(edge);
                uf.union(rootSrc, rootDest);
                System.out.println("  选择边: (" + edge.src + ", " + edge.dest + ", " + edge.weight + ")");
            } else {
                System.out.println("  跳过边: (" + edge.src + ", " + edge.dest + ", " + edge.weight + ") (会形成环)");
            }
            
            // 如果已经选择了V-1条边，就停止
            if (result.size() == vertices - 1) {
                break;
            }
        }
        
        return result;
    }
    
    // 打印最小生成树
    public void printMST(List<Edge> mst) {
        System.out.println("最小生成树的边:");
        int totalWeight = 0;
        for (Edge edge : mst) {
            System.out.println("  (" + edge.src + ", " + edge.dest + ", " + edge.weight + ")");
            totalWeight += edge.weight;
        }
        System.out.println("最小生成树的总权重: " + totalWeight);
    }
}
```

### 7.5.2 Prim算法

Prim算法也是一种贪心算法，用于在无向权重图中找到最小生成树。

```java
import java.util.*;

/**
 * Prim算法实现
 */
public class PrimMST extends AdjacencyListGraph {
    // 带权重的边
    static class WeightedEdge {
        int dest;
        int weight;
        
        public WeightedEdge(int dest, int weight) {
            this.dest = dest;
            this.weight = weight;
        }
    }
    
    private List<List<WeightedEdge>> weightedAdjList;
    
    public PrimMST(int vertices) {
        super(vertices, false); // Prim算法用于无向图
        this.weightedAdjList = new ArrayList<>(vertices);
        for (int i = 0; i < vertices; i++) {
            weightedAdjList.add(new ArrayList<>());
        }
    }
    
    // 添加带权重的边
    public void addWeightedEdge(int src, int dest, int weight) {
        if (src >= 0 && src < super.vertices && dest >= 0 && dest < super.vertices) {
            weightedAdjList.get(src).add(new WeightedEdge(dest, weight));
            weightedAdjList.get(dest).add(new WeightedEdge(src, weight)); // 无向图
            System.out.println("添加带权重边: " + src + " <-> " + dest + " (权重: " + weight + ")");
        }
    }
    
    // Prim算法
    public List<Edge> primMST() {
        List<Edge> result = new ArrayList<>();
        boolean[] inMST = new boolean[super.vertices]; // 标记顶点是否在MST中
        int[] minEdge = new int[super.vertices];       // 到MST的最小边权重
        int[] parent = new int[super.vertices];        // MST中顶点的父节点
        
        // 初始化数组
        Arrays.fill(minEdge, Integer.MAX_VALUE);
        Arrays.fill(parent, -1);
        
        // 从顶点0开始
        minEdge[0] = 0;
        
        System.out.println("Prim算法执行过程:");
        
        // 添加V-1条边到MST
        for (int count = 0; count < super.vertices - 1; count++) {
            // 找到不在MST中且具有最小边权重的顶点
            int u = findMinVertex(minEdge, inMST);
            inMST[u] = true;
            
            System.out.println("  选择顶点: " + u);
            
            // 更新与u相邻的顶点的最小边权重
            for (WeightedEdge edge : weightedAdjList.get(u)) {
                int v = edge.dest;
                int weight = edge.weight;
                
                // 如果v不在MST中，且通过u到v的边权重更小
                if (!inMST[v] && weight < minEdge[v]) {
                    minEdge[v] = weight;
                    parent[v] = u;
                    System.out.println("    更新顶点 " + v + " 的最小边权重为: " + weight);
                }
            }
        }
        
        // 构建结果
        for (int i = 1; i < super.vertices; i++) {
            if (parent[i] != -1) {
                result.add(new Edge(parent[i], i, minEdge[i]));
            }
        }
        
        return result;
    }
    
    // 找到不在MST中且具有最小边权重的顶点
    private int findMinVertex(int[] minEdge, boolean[] inMST) {
        int min = Integer.MAX_VALUE;
        int minIndex = -1;
        
        for (int v = 0; v < super.vertices; v++) {
            if (!inMST[v] && minEdge[v] < min) {
                min = minEdge[v];
                minIndex = v;
            }
        }
        
        return minIndex;
    }
    
    // 打印最小生成树
    public void printMST(List<Edge> mst) {
        System.out.println("Prim算法生成的最小生成树:");
        int totalWeight = 0;
        for (Edge edge : mst) {
            System.out.println("  (" + edge.src + ", " + edge.dest + ", " + edge.weight + ")");
            totalWeight += edge.weight;
        }
        System.out.println("最小生成树的总权重: " + totalWeight);
    }
}
```

## 7.6 拓扑排序

拓扑排序是对有向无环图（DAG）的顶点进行线性排序，使得对于任何有向边(u,v)，顶点u在排序中都出现在顶点v之前。

```java
import java.util.*;

/**
 * 拓扑排序实现
 */
public class TopologicalSort extends AdjacencyListGraph {
    
    public TopologicalSort(int vertices) {
        super(vertices, true); // 拓扑排序用于有向图
    }
    
    // 使用DFS实现拓扑排序
    public List<Integer> topologicalSortDFS() {
        boolean[] visited = new boolean[super.vertices];
        Stack<Integer> stack = new Stack<>();
        
        System.out.println("拓扑排序 (DFS方法) 执行过程:");
        
        // 对每个未访问的顶点调用DFS
        for (int i = 0; i < super.vertices; i++) {
            if (!visited[i]) {
                dfsForTopoSort(i, visited, stack);
            }
        }
        
        // 构建结果
        List<Integer> result = new ArrayList<>();
        while (!stack.isEmpty()) {
            result.add(stack.pop());
        }
        
        return result;
    }
    
    // DFS辅助函数
    private void dfsForTopoSort(int vertex, boolean[] visited, Stack<Integer> stack) {
        visited[vertex] = true;
        System.out.println("  访问顶点: " + vertex);
        
        // 递归访问所有邻居
        for (int neighbor : super.getNeighbors(vertex)) {
            if (!visited[neighbor]) {
                dfsForTopoSort(neighbor, visited, stack);
            }
        }
        
        // 当前顶点处理完毕，压入栈中
        stack.push(vertex);
        System.out.println("  顶点 " + vertex + " 处理完毕，入栈");
    }
    
    // 使用Kahn算法实现拓扑排序
    public List<Integer> topologicalSortKahn() {
        // 计算每个顶点的入度
        int[] inDegree = new int[super.vertices];
        for (int i = 0; i < super.vertices; i++) {
            for (int neighbor : super.getNeighbors(i)) {
                inDegree[neighbor]++;
            }
        }
        
        System.out.println("拓扑排序 (Kahn算法) 执行过程:");
        System.out.print("  各顶点的入度: ");
        for (int i = 0; i < super.vertices; i++) {
            System.out.print(i + ":" + inDegree[i] + " ");
        }
        System.out.println();
        
        // 将所有入度为0的顶点加入队列
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < super.vertices; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
                System.out.println("  将入度为0的顶点 " + i + " 加入队列");
            }
        }
        
        List<Integer> result = new ArrayList<>();
        
        // 处理队列中的顶点
        while (!queue.isEmpty()) {
            int vertex = queue.poll();
            result.add(vertex);
            System.out.println("  处理顶点: " + vertex);
            
            // 减少邻居的入度
            for (int neighbor : super.getNeighbors(vertex)) {
                inDegree[neighbor]--;
                System.out.println("    顶点 " + neighbor + " 的入度减1，当前入度: " + inDegree[neighbor]);
                
                // 如果邻居的入度变为0，加入队列
                if (inDegree[neighbor] == 0) {
                    queue.offer(neighbor);
                    System.out.println("    将入度为0的顶点 " + neighbor + " 加入队列");
                }
            }
        }
        
        // 检查是否存在环
        if (result.size() != super.vertices) {
            System.out.println("图中存在环，无法进行拓扑排序");
            return new ArrayList<>();
        }
        
        return result;
    }
}
```

## 7.7 图的应用场景

### 7.7.1 社交网络分析

```java
import java.util.*;

/**
 * 社交网络分析示例
 */
public class SocialNetworkAnalysis extends AdjacencyListGraph {
    
    public SocialNetworkAnalysis(int users) {
        super(users, false); // 社交网络通常是无向图
    }
    
    // 添加好友关系
    public void addFriendship(int user1, int user2) {
        super.addEdge(user1, user2);
        System.out.println("用户 " + user1 + " 和用户 " + user2 + " 成为好友");
    }
    
    // 计算两个用户之间的共同好友
    public List<Integer> getCommonFriends(int user1, int user2) {
        List<Integer> friends1 = super.getNeighbors(user1);
        List<Integer> friends2 = super.getNeighbors(user2);
        List<Integer> commonFriends = new ArrayList<>();
        
        // 找到共同好友
        for (int friend : friends1) {
            if (friends2.contains(friend)) {
                commonFriends.add(friend);
            }
        }
        
        return commonFriends;
    }
    
    // 推荐好友（共同好友最多的用户）
    public List<Integer> recommendFriends(int user) {
        Map<Integer, Integer> recommendationScore = new HashMap<>();
        List<Integer> friends = super.getNeighbors(user);
        
        // 为每个好友的好友增加推荐分数
        for (int friend : friends) {
            for (int friendOfFriend : super.getNeighbors(friend)) {
                // 不推荐已经是好友的用户或用户自己
                if (friendOfFriend != user && !friends.contains(friendOfFriend)) {
                    recommendationScore.put(friendOfFriend, 
                                          recommendationScore.getOrDefault(friendOfFriend, 0) + 1);
                }
            }
        }
        
        // 按推荐分数排序
        List<Map.Entry<Integer, Integer>> sortedRecommendations = 
            new ArrayList<>(recommendationScore.entrySet());
        sortedRecommendations.sort((a, b) -> b.getValue().compareTo(a.getValue()));
        
        // 返回推荐的用户ID
        List<Integer> recommendations = new ArrayList<>();
        for (Map.Entry<Integer, Integer> entry : sortedRecommendations) {
            recommendations.add(entry.getKey());
        }
        
        return recommendations;
    }
}
```

### 7.7.2 网络路由

```java
import java.util.*;

/**
 * 网络路由示例
 */
public class NetworkRouting extends DijkstraGraph {
    
    public NetworkRouting(int nodes) {
        super(nodes);
    }
    
    // 添加网络连接
    public void addConnection(int node1, int node2, int latency) {
        super.addWeightedEdge(node1, node2, latency);
        super.addWeightedEdge(node2, node1, latency); // 双向连接
        System.out.println("在网络节点 " + node1 + " 和 " + node2 + " 之间建立连接，延迟: " + latency + "ms");
    }
    
    // 找到两个节点之间的最短路径（最低延迟路径）
    public List<Integer> findLowestLatencyPath(int src, int dest) {
        System.out.println("寻找从节点 " + src + " 到节点 " + dest + " 的最低延迟路径...");
        
        // 使用Dijkstra算法找到最短距离
        int[] distances = super.dijkstra(src);
        
        if (distances[dest] == Integer.MAX_VALUE) {
            System.out.println("无法找到从节点 " + src + " 到节点 " + dest + " 的路径");
            return new ArrayList<>();
        }
        
        System.out.println("从节点 " + src + " 到节点 " + dest + " 的最低延迟为: " + distances[dest] + "ms");
        return new ArrayList<>(); // 简化实现，实际应用中需要重构路径
    }
}
```

## 7.8 Java标准库中的图结构

虽然Java标准库没有直接提供图的数据结构，但我们可以使用现有的集合类来实现图：

```java
import java.util.*;

/**
 * Java标准库图结构示例
 */
public class JavaStandardLibraryGraph {
    
    // 使用Map和Set实现邻接表
    public static class MapBasedGraph {
        private Map<Integer, Set<Integer>> adjacencyMap;
        private boolean isDirected;
        
        public MapBasedGraph(boolean isDirected) {
            this.adjacencyMap = new HashMap<>();
            this.isDirected = isDirected;
        }
        
        // 添加顶点
        public void addVertex(int vertex) {
            adjacencyMap.putIfAbsent(vertex, new HashSet<>());
        }
        
        // 添加边
        public void addEdge(int src, int dest) {
            addVertex(src);
            addVertex(dest);
            
            adjacencyMap.get(src).add(dest);
            if (!isDirected) {
                adjacencyMap.get(dest).add(src);
            }
            System.out.println("添加边: " + src + " -> " + dest);
        }
        
        // 获取邻居
        public Set<Integer> getNeighbors(int vertex) {
            return adjacencyMap.getOrDefault(vertex, new HashSet<>());
        }
        
        // 打印图
        public void printGraph() {
            System.out.println("基于Map的图表示:");
            for (Map.Entry<Integer, Set<Integer>> entry : adjacencyMap.entrySet()) {
                System.out.println(entry.getKey() + ": " + entry.getValue());
            }
        }
    }
    
    // 演示Java标准库图结构
    public static void demonstrateJavaGraph() {
        System.out.println("=== Java标准库图结构演示 ===");
        
        // 创建无向图
        MapBasedGraph graph = new MapBasedGraph(false);
        graph.addEdge(0, 1);
        graph.addEdge(0, 2);
        graph.addEdge(1, 3);
        graph.addEdge(2, 4);
        graph.addEdge(3, 4);
        
        graph.printGraph();
        
        System.out.println("顶点1的邻居: " + graph.getNeighbors(1));
        System.out.println("顶点4的邻居: " + graph.getNeighbors(4));
    }
}
```

## 7.9 性能分析

### 7.9.1 时间复杂度

| 操作 | 邻接矩阵 | 邻接表 | 边列表 |
|------|----------|--------|--------|
| 存储空间 | O(V²) | O(V+E) | O(E) |
| 添加边 | O(1) | O(1) | O(1) |
| 删除边 | O(1) | O(V) | O(E) |
| 检查边 | O(1) | O(V) | O(E) |
| 获取邻居 | O(V) | O(degree) | O(E) |

### 7.9.2 算法复杂度

| 算法 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| DFS/BFS | O(V+E) | O(V) |
| Dijkstra | O((V+E)logV) | O(V) |
| Floyd-Warshall | O(V³) | O(V²) |
| Kruskal | O(ElogE) | O(V) |
| Prim | O((V+E)logV) | O(V) |
| 拓扑排序 | O(V+E) | O(V) |

## 7.10 最佳实践与注意事项

### 7.10.1 选择合适的图表示方法

1. **稠密图**：边的数量接近顶点数量的平方，使用邻接矩阵
2. **稀疏图**：边的数量远小于顶点数量的平方，使用邻接表
3. **需要频繁查询边的存在性**：使用邻接矩阵
4. **需要节省空间**：使用邻接表

### 7.10.2 算法选择建议

1. **单源最短路径**：使用Dijkstra算法（非负权重）或Bellman-Ford算法（可有负权重）
2. **所有顶点对最短路径**：使用Floyd-Warshall算法
3. **最小生成树**：稠密图使用Prim算法，稀疏图使用Kruskal算法
4. **拓扑排序**：使用DFS方法或Kahn算法

### 7.10.3 实现注意事项

1. **处理大图**：考虑使用外部存储或分布式计算
2. **内存优化**：使用合适的数据类型和压缩技术
3. **并发安全**：在多线程环境中需要同步机制
4. **错误处理**：处理无效输入和边界情况

## 7.11 本章小结

本章详细介绍了图这一重要的数据结构。我们学习了图的基本概念、表示方法、遍历算法、最短路径算法、最小生成树算法以及拓扑排序等重要内容。

图在现实世界中有广泛的应用，如社交网络、网络路由、任务调度等。掌握图的各种算法对于解决复杂的实际问题具有重要意义。

在下一章中，我们将学习排序算法，这是数据处理中的基础操作，对于提高数据检索效率至关重要。