# 第3章：栈与队列 - 特殊线性结构及应用场景

## 3.1 栈（Stack）

### 3.1.1 栈的基本概念

栈是一种特殊的线性表，只允许在一端进行插入和删除操作。这端称为栈顶，另一端称为栈底。栈遵循"后进先出"（LIFO - Last In First Out）的原则。

栈的基本操作：
- **入栈（Push）**：将元素添加到栈顶
- **出栈（Pop）**：移除并返回栈顶元素
- **查看栈顶（Peek/Top）**：返回栈顶元素但不移除
- **判断栈空（IsEmpty）**：检查栈是否为空

### 3.1.2 栈的实现

栈可以用数组或链表来实现。下面我们用数组实现一个简单的栈：

```java
public class ArrayStack {
    private int[] stack;
    private int top;
    private int capacity;
    
    // 构造函数
    public ArrayStack(int size) {
        this.capacity = size;
        this.stack = new int[capacity];
        this.top = -1;  // -1表示栈为空
    }
    
    // 入栈操作
    public void push(int value) {
        if (isFull()) {
            throw new RuntimeException("栈已满");
        }
        stack[++top] = value;
        System.out.println("入栈: " + value);
    }
    
    // 出栈操作
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈为空");
        }
        int value = stack[top--];
        System.out.println("出栈: " + value);
        return value;
    }
    
    // 查看栈顶元素
    public int peek() {
        if (isEmpty()) {
            throw new RuntimeException("栈为空");
        }
        return stack[top];
    }
    
    // 判断栈是否为空
    public boolean isEmpty() {
        return top == -1;
    }
    
    // 判断栈是否已满
    public boolean isFull() {
        return top == capacity - 1;
    }
    
    // 获取栈的大小
    public int size() {
        return top + 1;
    }
    
    // 打印栈的内容
    public void printStack() {
        if (isEmpty()) {
            System.out.println("栈为空");
            return;
        }
        System.out.print("栈内容（从栈顶到栈底）: ");
        for (int i = top; i >= 0; i--) {
            System.out.print(stack[i] + " ");
        }
        System.out.println();
    }
}
```

### 3.1.3 栈的操作及时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| 入栈（Push） | O(1) | 直接在栈顶添加元素 |
| 出栈（Pop） | O(1) | 直接移除栈顶元素 |
| 查看栈顶（Peek） | O(1) | 直接返回栈顶元素 |
| 判空（IsEmpty） | O(1) | 检查栈顶指针 |

### 3.1.4 栈的应用场景

#### 1. 表达式求值

栈可以用于表达式的求值和转换，如中缀表达式转后缀表达式：

```java
// 简单的括号匹配检查
public class ParenthesesChecker {
    public static boolean isBalanced(String expression) {
        ArrayStack stack = new ArrayStack(expression.length());
        
        for (char ch : expression.toCharArray()) {
            if (ch == '(' || ch == '[' || ch == '{') {
                // 遇到开括号，入栈
                stack.push(ch);
            } else if (ch == ')' || ch == ']' || ch == '}') {
                // 遇到闭括号，检查是否匹配
                if (stack.isEmpty()) {
                    return false;
                }
                
                char top = (char) stack.pop();
                if (!isMatchingPair(top, ch)) {
                    return false;
                }
            }
        }
        
        // 最后栈应该为空
        return stack.isEmpty();
    }
    
    private static boolean isMatchingPair(char open, char close) {
        return (open == '(' && close == ')') ||
               (open == '[' && close == ']') ||
               (open == '{' && close == '}');
    }
}
```

#### 2. 函数调用栈

在程序执行过程中，函数调用会形成调用栈：

```java
public class FunctionCallSimulation {
    // 递归计算阶乘（模拟函数调用栈）
    public static int factorial(int n) {
        System.out.println("调用 factorial(" + n + ")");
        
        if (n <= 1) {
            System.out.println("返回 factorial(" + n + ") = 1");
            return 1;
        }
        
        int result = n * factorial(n - 1);
        System.out.println("返回 factorial(" + n + ") = " + result);
        return result;
    }
}
```

#### 3. 浏览器后退功能

浏览器的后退功能可以用栈来实现：

```java
import java.util.ArrayList;
import java.util.List;

public class BrowserBackFunction {
    private List<String> backStack;  // 后退栈
    private List<String> forwardStack;  // 前进栈
    private String currentPage;
    
    public BrowserBackFunction() {
        backStack = new ArrayList<>();
        forwardStack = new ArrayList<>();
        currentPage = "";
    }
    
    // 访问新页面
    public void visit(String url) {
        if (!currentPage.isEmpty()) {
            backStack.add(currentPage);
        }
        currentPage = url;
        forwardStack.clear();  // 访问新页面后清空前进栈
        System.out.println("访问页面: " + url);
    }
    
    // 后退
    public void back() {
        if (backStack.isEmpty()) {
            System.out.println("无法后退");
            return;
        }
        
        forwardStack.add(currentPage);
        currentPage = backStack.remove(backStack.size() - 1);
        System.out.println("后退到: " + currentPage);
    }
    
    // 前进
    public void forward() {
        if (forwardStack.isEmpty()) {
            System.out.println("无法前进");
            return;
        }
        
        backStack.add(currentPage);
        currentPage = forwardStack.remove(forwardStack.size() - 1);
        System.out.println("前进到: " + currentPage);
    }
}
```

## 3.2 队列（Queue）

### 3.2.1 队列的基本概念

队列是一种特殊的线性表，只允许在一端进行插入操作（队尾），在另一端进行删除操作（队头）。队列遵循"先进先出"（FIFO - First In First Out）的原则。

队列的基本操作：
- **入队（Enqueue）**：将元素添加到队尾
- **出队（Dequeue）**：移除并返回队头元素
- **查看队头（Front）**：返回队头元素但不移除
- **判断队空（IsEmpty）**：检查队列是否为空

### 3.2.2 队列的实现

我们可以用数组实现一个简单的队列：

```java
public class ArrayQueue {
    private int[] queue;
    private int front;
    private int rear;
    private int size;
    private int capacity;
    
    // 构造函数
    public ArrayQueue(int capacity) {
        this.capacity = capacity;
        this.queue = new int[capacity];
        this.front = 0;
        this.rear = -1;
        this.size = 0;
    }
    
    // 入队操作
    public void enqueue(int value) {
        if (isFull()) {
            throw new RuntimeException("队列已满");
        }
        rear = (rear + 1) % capacity;  // 循环队列
        queue[rear] = value;
        size++;
        System.out.println("入队: " + value);
    }
    
    // 出队操作
    public int dequeue() {
        if (isEmpty()) {
            throw new RuntimeException("队列为空");
        }
        int value = queue[front];
        front = (front + 1) % capacity;  // 循环队列
        size--;
        System.out.println("出队: " + value);
        return value;
    }
    
    // 查看队头元素
    public int front() {
        if (isEmpty()) {
            throw new RuntimeException("队列为空");
        }
        return queue[front];
    }
    
    // 判断队列是否为空
    public boolean isEmpty() {
        return size == 0;
    }
    
    // 判断队列是否已满
    public boolean isFull() {
        return size == capacity;
    }
    
    // 获取队列大小
    public int size() {
        return size;
    }
    
    // 打印队列内容
    public void printQueue() {
        if (isEmpty()) {
            System.out.println("队列为空");
            return;
        }
        System.out.print("队列内容（从队头到队尾）: ");
        for (int i = 0; i < size; i++) {
            int index = (front + i) % capacity;
            System.out.print(queue[index] + " ");
        }
        System.out.println();
    }
}
```

### 3.2.3 队列的操作及时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| 入队（Enqueue） | O(1) | 直接在队尾添加元素 |
| 出队（Dequeue） | O(1) | 直接移除队头元素 |
| 查看队头（Front） | O(1) | 直接返回队头元素 |
| 判空（IsEmpty） | O(1) | 检查队列大小 |

### 3.2.4 队列的应用场景

#### 1. 任务调度

操作系统中的任务调度可以用队列实现：

```java
class Task {
    private String name;
    private int priority;
    
    public Task(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }
    
    public String getName() {
        return name;
    }
    
    public int getPriority() {
        return priority;
    }
    
    @Override
    public String toString() {
        return "Task{name='" + name + "', priority=" + priority + "}";
    }
}

// 简单的任务调度器
public class TaskScheduler {
    private ArrayQueue taskQueue;
    
    public TaskScheduler(int capacity) {
        taskQueue = new ArrayQueue(capacity);
    }
    
    // 添加任务
    public void addTask(Task task) {
        // 简化实现，实际中可能需要按优先级排序
        System.out.println("添加任务: " + task);
    }
    
    // 执行任务
    public void executeTask() {
        if (taskQueue.isEmpty()) {
            System.out.println("没有待执行的任务");
            return;
        }
        // 执行队头任务
        System.out.println("执行任务");
    }
}
```

#### 2. 广度优先搜索（BFS）

队列在图的广度优先搜索算法中起关键作用：

```java
import java.util.*;

// 图的广度优先搜索示例
public class BFSGraphTraversal {
    private Map<Integer, List<Integer>> adjacencyList;
    
    public BFSGraphTraversal() {
        adjacencyList = new HashMap<>();
    }
    
    // 添加边
    public void addEdge(int source, int destination) {
        adjacencyList.computeIfAbsent(source, k -> new ArrayList<>()).add(destination);
        adjacencyList.computeIfAbsent(destination, k -> new ArrayList<>()).add(source);
    }
    
    // 广度优先搜索
    public void bfs(int startVertex) {
        Set<Integer> visited = new HashSet<>();
        ArrayQueue queue = new ArrayQueue(100);  // 简化的队列实现
        
        visited.add(startVertex);
        // 注意：这里为了演示概念，简化了实现
        System.out.println("从顶点 " + startVertex + " 开始BFS遍历");
    }
}
```

#### 3. 缓冲区管理

在网络编程和I/O操作中，队列用于缓冲区管理：

```java
// 数据包缓冲区示例
public class PacketBuffer {
    private ArrayQueue packetQueue;
    
    public PacketBuffer(int capacity) {
        packetQueue = new ArrayQueue(capacity);
    }
    
    // 接收数据包
    public void receivePacket(String packet) {
        System.out.println("接收数据包: " + packet);
        // 实际实现中会将数据包加入队列等待处理
    }
    
    // 发送数据包
    public void sendPacket() {
        if (packetQueue.isEmpty()) {
            System.out.println("没有待发送的数据包");
            return;
        }
        System.out.println("发送数据包");
    }
}
```

## 3.3 栈与队列的对比

### 3.3.1 基本特性对比

| 特性 | 栈 | 队列 |
|------|----|------|
| 访问原则 | LIFO（后进先出） | FIFO（先进先出） |
| 操作端 | 同一端（栈顶） | 不同端（队头和队尾） |
| 插入位置 | 栈顶 | 队尾 |
| 删除位置 | 栈顶 | 队头 |

### 3.3.2 时间复杂度对比

| 操作 | 栈 | 队列 |
|------|----|------|
| 插入 | O(1) | O(1) |
| 删除 | O(1) | O(1) |
| 访问 | O(1)（仅限栈顶/队头） | O(1)（仅限队头） |

### 3.3.3 应用场景对比

| 场景 | 栈适用 | 队列适用 |
|------|--------|----------|
| 需要逆序处理 | ✓ | ✗ |
| 需要顺序处理 | ✗ | ✓ |
| 函数调用管理 | ✓ | ✗ |
| 任务调度 | ✗ | ✓ |
| 表达式求值 | ✓ | ✗ |
| 广度优先搜索 | ✗ | ✓ |

## 3.4 双端队列（Deque）

双端队列是一种特殊的队列，允许在两端进行插入和删除操作。

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class DequeExample {
    public static void demonstrateDeque() {
        Deque<Integer> deque = new ArrayDeque<>();
        
        // 在队尾添加元素
        deque.offerLast(1);
        deque.offerLast(2);
        
        // 在队头添加元素
        deque.offerFirst(0);
        
        System.out.println("双端队列内容: " + deque);
        
        // 从队头移除元素
        int first = deque.pollFirst();
        System.out.println("从队头移除: " + first);
        
        // 从队尾移除元素
        int last = deque.pollLast();
        System.out.println("从队尾移除: " + last);
        
        System.out.println("剩余元素: " + deque);
    }
}
```

## 3.5 最佳实践与注意事项

### 3.5.1 栈的最佳实践

1. **边界检查**：操作栈之前检查是否为空或已满
2. **异常处理**：合理处理栈溢出和下溢异常
3. **内存管理**：对于动态扩容的栈，注意内存使用

### 3.5.2 队列的最佳实践

1. **循环队列**：使用循环队列提高空间利用率
2. **阻塞队列**：在多线程环境中使用阻塞队列
3. **优先队列**：根据业务需求选择合适的队列类型

### 3.5.3 性能优化建议

1. **选择合适实现**：根据使用场景选择数组或链表实现
2. **预分配容量**：合理预估容量避免频繁扩容
3. **避免频繁扩容**：监控使用率，适时调整容量

## 3.6 本章小结

本章详细介绍了栈和队列这两种重要的线性数据结构。栈遵循LIFO原则，适用于需要逆序处理的场景，如函数调用、表达式求值等。队列遵循FIFO原则，适用于需要顺序处理的场景，如任务调度、缓冲区管理等。

我们还学习了它们的实现方式、操作特点以及实际应用场景。掌握栈和队列对于理解更复杂的数据结构和算法至关重要。

下一章我们将学习树结构，这是一种非线性的数据结构，在计算机科学中有着广泛的应用。