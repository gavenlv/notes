# 第1章：数据结构与算法入门 - 基础概念与复杂度分析

## 1.1 什么是数据结构与算法

### 1.1.1 数据结构的概念

数据结构（Data Structure）是计算机存储、组织数据的方式。它是相互之间存在一种或多种特定关系的数据元素的集合。

简单来说，数据结构就是数据元素之间的关系以及对这些关系的操作。

常见的数据结构包括：
- 数组（Array）
- 链表（Linked List）
- 栈（Stack）
- 队列（Queue）
- 树（Tree）
- 图（Graph）
- 哈希表（Hash Table）
- 堆（Heap）

### 1.1.2 算法的概念

算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令。

算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。

算法的重要特征：
1. **有穷性**：算法必须能在执行有限个步骤之后终止
2. **确切性**：算法的每个步骤必须要做到精确无误
3. **输入项**：一个算法有0个或多个输入
4. **输出项**：一个算法有一个或多个输出
5. **可行性**：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤

## 1.2 为什么要学习数据结构与算法

### 1.2.1 提升编程能力

掌握数据结构与算法能够帮助我们：
- 编写出更高效的程序
- 解决更复杂的业务问题
- 在面试中脱颖而出
- 更好地理解和使用各种框架和库

### 1.2.2 实际应用场景

数据结构与算法广泛应用于：
- 搜索引擎的网页排名算法
- 社交媒体的好友推荐系统
- 电商平台的商品推荐算法
- 导航软件的路径规划算法
- 数据库的索引优化

## 1.3 算法复杂度分析

### 1.3.1 时间复杂度

时间复杂度是用来衡量算法执行时间随数据规模增长的变化趋势。

常见的时间复杂度（按效率从高到低）：
- O(1)：常数时间复杂度
- O(log n)：对数时间复杂度
- O(n)：线性时间复杂度
- O(n log n)：线性对数时间复杂度
- O(n²)：平方时间复杂度
- O(2ⁿ)：指数时间复杂度

#### 示例：计算时间复杂度

```java
// O(1) - 常数时间复杂度
public int getFirstElement(int[] array) {
    return array[0];
}

// O(n) - 线性时间复杂度
public int sumArray(int[] array) {
    int sum = 0;
    for (int i = 0; i < array.length; i++) {
        sum += array[i];
    }
    return sum;
}

// O(n²) - 平方时间复杂度
public void printPairs(int[] array) {
    for (int i = 0; i < array.length; i++) {
        for (int j = 0; j < array.length; j++) {
            System.out.println(array[i] + "," + array[j]);
        }
    }
}
```

### 1.3.2 空间复杂度

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。

常见的空间复杂度：
- O(1)：只使用了常数级别的额外空间
- O(n)：使用了与输入规模成正比的额外空间
- O(n²)：使用了与输入规模平方成正比的额外空间

#### 示例：计算空间复杂度

```java
// O(1) - 只使用了常数级别的额外空间
public int sum(int a, int b) {
    return a + b;
}

// O(n) - 使用了与输入规模成正比的额外空间
public int[] copyArray(int[] array) {
    int[] newArray = new int[array.length];
    for (int i = 0; i < array.length; i++) {
        newArray[i] = array[i];
    }
    return newArray;
}
```

## 1.4 大O表示法详解

大O表示法（Big O notation）用于描述算法的渐进行为，表示算法的上界。

### 1.4.1 常见的大O表示法

| 表示法 | 名称 | 描述 |
|--------|------|------|
| O(1) | 常数阶 | 最优时间复杂度，不随输入规模变化 |
| O(log n) | 对数阶 | 随输入规模增加，时间增长缓慢 |
| O(n) | 线性阶 | 时间与输入规模成正比 |
| O(n log n) | 线性对数阶 | 比线性稍差，但仍在可接受范围 |
| O(n²) | 平方阶 | 当输入规模较大时，性能较差 |
| O(n³) | 立方阶 | 性能很差，仅适用于小规模数据 |
| O(2ⁿ) | 指数阶 | 性能极差，应尽量避免 |

### 1.4.2 大O表示法的计算规则

1. **加法规则**：O(f(n)) + O(g(n)) = O(max(f(n), g(n)))
2. **乘法规则**：O(f(n)) × O(g(n)) = O(f(n) × g(n))
3. **忽略常数**：O(c × f(n)) = O(f(n))，其中c为常数
4. **忽略低次项**：只保留最高次项

## 1.5 最佳实践与注意事项

### 1.5.1 如何选择合适的数据结构

选择数据结构时需要考虑以下因素：
1. 数据的特点（有序/无序、重复/唯一等）
2. 需要频繁执行的操作（查找、插入、删除等）
3. 内存使用情况
4. 时间复杂度要求

### 1.5.2 算法设计的基本原则

1. **正确性**：算法应该能够正确解决问题
2. **可读性**：代码应该易于理解和维护
3. **健壮性**：能够处理各种边界条件和异常情况
4. **高效性**：在时间和空间上尽可能优化

## 1.6 本章小结

本章介绍了数据结构与算法的基础概念，重点讲解了算法复杂度分析方法。掌握了这些基础知识后，我们就可以更好地理解和应用后续章节中的各种数据结构和算法。

下一章我们将深入学习最基础也是最重要的两种线性数据结构：数组和链表。