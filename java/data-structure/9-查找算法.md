# 第九章：查找算法 - 高效检索策略

## 目录
1. [查找算法概述](#查找算法概述)
2. [顺序查找](#顺序查找)
3. [二分查找](#二分查找)
4. [插值查找](#插值查找)
5. [斐波那契查找](#斐波那契查找)
6. [树表查找](#树表查找)
7. [分块查找](#分块查找)
8. [哈希查找](#哈希查找)
9. [查找算法性能比较](#查找算法性能比较)
10. [最佳实践](#最佳实践)

---

## 查找算法概述

查找是计算机科学中的一个基本操作，指的是在一个数据集合中寻找满足特定条件的元素的过程。查找算法的效率直接影响到程序的性能，特别是在处理大规模数据时。

### 查找算法分类

1. **静态查找**：数据集合在查找过程中不发生变化
2. **动态查找**：数据集合在查找过程中可以插入、删除元素

3. **无序查找**：数据集合没有特定的排列顺序
4. **有序查找**：数据集合按照特定顺序排列

### 查找算法评价指标

1. **时间复杂度**：查找操作所需的时间
2. **空间复杂度**：查找算法所需的额外存储空间
3. **平均查找长度(ASL)**：查找成功时平均需要比较的次数

---

## 顺序查找

顺序查找是最简单的查找算法，它从数据结构的第一个元素开始，逐个比较每个元素，直到找到目标元素或遍历完所有元素。

### 算法原理

1. 从数组的第一个元素开始
2. 逐个比较当前元素与目标值
3. 如果相等则返回索引，否则继续下一个元素
4. 如果遍历完所有元素仍未找到，则返回-1表示未找到

### Java实现

```java
public class SequentialSearch {
    /**
     * 顺序查找算法
     * @param arr 待查找的数组
     * @param target 目标值
     * @return 目标值在数组中的索引，未找到返回-1
     */
    public static int sequentialSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i;
            }
        }
        return -1;
    }
    
    /**
     * 带哨兵的顺序查找
     * @param arr 待查找的数组
     * @param target 目标值
     * @return 目标值在数组中的索引，未找到返回-1
     */
    public static int sequentialSearchWithSentinel(int[] arr, int target) {
        // 设置哨兵
        int last = arr[arr.length - 1];
        arr[arr.length - 1] = target;
        
        int i = 0;
        while (arr[i] != target) {
            i++;
        }
        
        // 恢复哨兵
        arr[arr.length - 1] = last;
        
        // 判断是否找到
        if (i < arr.length - 1 || last == target) {
            return i;
        }
        return -1;
    }
}
```

### 时间复杂度分析

- 最好情况：O(1) - 目标元素在第一个位置
- 平均情况：O(n/2) ≈ O(n)
- 最坏情况：O(n) - 目标元素在最后一个位置或不存在
- 空间复杂度：O(1)

### 应用场景

- 小规模数据集查找
- 无序数据查找
- 教学演示查找算法基本思想

---

## 二分查找

二分查找是一种在有序数组中查找特定元素的高效算法。它通过将查找区间一分为二，逐步缩小查找范围，直到找到目标元素或确定目标元素不存在。

### 算法原理

1. 设定数组的起始位置low和结束位置high
2. 计算中间位置mid = (low + high) / 2
3. 比较arr[mid]与目标值：
   - 如果相等，则找到目标元素
   - 如果arr[mid] > 目标值，则在左半部分查找
   - 如果arr[mid] < 目标值，则在右半部分查找
4. 重复步骤2-3，直到找到目标元素或low > high

### Java实现

```java
public class BinarySearch {
    /**
     * 二分查找（递归实现）
     * @param arr 有序数组
     * @param target 目标值
     * @param low 起始索引
     * @param high 结束索引
     * @return 目标值在数组中的索引，未找到返回-1
     */
    public static int binarySearchRecursive(int[] arr, int target, int low, int high) {
        if (low > high) {
            return -1;
        }
        
        int mid = low + (high - low) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] > target) {
            return binarySearchRecursive(arr, target, low, mid - 1);
        } else {
            return binarySearchRecursive(arr, target, mid + 1, high);
        }
    }
    
    /**
     * 二分查找（迭代实现）
     * @param arr 有序数组
     * @param target 目标值
     * @return 目标值在数组中的索引，未找到返回-1
     */
    public static int binarySearchIterative(int[] arr, int target) {
        int low = 0;
        int high = arr.length - 1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] > target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        
        return -1;
    }
    
    /**
     * 查找第一个等于目标值的元素
     * @param arr 有序数组
     * @param target 目标值
     * @return 第一个等于目标值的元素索引，未找到返回-1
     */
    public static int findFirstEqual(int[] arr, int target) {
        int low = 0;
        int high = arr.length - 1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            
            if (arr[mid] > target) {
                high = mid - 1;
            } else if (arr[mid] < target) {
                low = mid + 1;
            } else {
                // 找到目标值，但需要判断是否是第一个
                if (mid == 0 || arr[mid - 1] != target) {
                    return mid;
                }
                high = mid - 1;
            }
        }
        
        return -1;
    }
    
    /**
     * 查找最后一个等于目标值的元素
     * @param arr 有序数组
     * @param target 目标值
     * @return 最后一个等于目标值的元素索引，未找到返回-1
     */
    public static int findLastEqual(int[] arr, int target) {
        int low = 0;
        int high = arr.length - 1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            
            if (arr[mid] > target) {
                high = mid - 1;
            } else if (arr[mid] < target) {
                low = mid + 1;
            } else {
                // 找到目标值，但需要判断是否是最后一个
                if (mid == arr.length - 1 || arr[mid + 1] != target) {
                    return mid;
                }
                low = mid + 1;
            }
        }
        
        return -1;
    }
    
    /**
     * 查找第一个大于等于目标值的元素
     * @param arr 有序数组
     * @param target 目标值
     * @return 第一个大于等于目标值的元素索引，未找到返回-1
     */
    public static int findFirstGreaterOrEqual(int[] arr, int target) {
        int low = 0;
        int high = arr.length - 1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            
            if (arr[mid] >= target) {
                if (mid == 0 || arr[mid - 1] < target) {
                    return mid;
                }
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        
        return -1;
    }
}
```

### 时间复杂度分析

- 最好情况：O(1) - 目标元素在中间位置
- 平均情况：O(log n)
- 最坏情况：O(log n)
- 空间复杂度：O(1) - 迭代实现，O(log n) - 递归实现（递归调用栈）

### 应用场景

- 大规模有序数据查找
- 数据库索引查找
- 算法题中的经典问题

---

## 插值查找

插值查找是二分查找的改进版本，它根据目标值在数据集中的分布情况来确定中间位置，从而更快速地定位目标元素。

### 算法原理

1. 计算插值位置：mid = low + (target - arr[low]) * (high - low) / (arr[high] - arr[low])
2. 比较arr[mid]与目标值：
   - 如果相等，则找到目标元素
   - 如果arr[mid] > 目标值，则在左半部分查找
   - 如果arr[mid] < 目标值，则在右半部分查找
3. 重复上述过程，直到找到目标元素或确定目标元素不存在

### Java实现

```java
public class InterpolationSearch {
    /**
     * 插值查找
     * @param arr 有序数组（均匀分布效果最好）
     * @param target 目标值
     * @return 目标值在数组中的索引，未找到返回-1
     */
    public static int interpolationSearch(int[] arr, int target) {
        int low = 0;
        int high = arr.length - 1;
        
        while (low <= high && target >= arr[low] && target <= arr[high]) {
            // 防止除零错误
            if (low == high) {
                if (arr[low] == target) {
                    return low;
                }
                return -1;
            }
            
            // 计算插值位置
            int pos = low + ((target - arr[low]) * (high - low)) / (arr[high] - arr[low]);
            
            if (arr[pos] == target) {
                return pos;
            } else if (arr[pos] < target) {
                low = pos + 1;
            } else {
                high = pos - 1;
            }
        }
        
        return -1;
    }
}
```

### 时间复杂度分析

- 最好情况：O(1) - 目标元素在插值位置
- 平均情况：O(log log n) - 数据均匀分布时
- 最坏情况：O(n) - 数据分布极不均匀时
- 空间复杂度：O(1)

### 应用场景

- 大规模均匀分布的有序数据查找
- 数据库中的范围查询
- 关键字在字典中的查找

---

## 斐波那契查找

斐波那契查找是二分查找的变种，它利用斐波那契数列来分割数组，从而实现查找。

### 算法原理

1. 找到最小的斐波那契数F(k)，使得F(k) >= n+1（n为数组长度）
2. 将数组长度扩展到F(k)-1，用数组最大值填充扩展部分
3. 根据F(k-1)分割数组，比较arr[F(k-1)-1]与目标值
4. 根据比较结果在左半部分或右半部分递归查找

### Java实现

```java
public class FibonacciSearch {
    /**
     * 斐波那契查找
     * @param arr 有序数组
     * @param target 目标值
     * @return 目标值在数组中的索引，未找到返回-1
     */
    public static int fibonacciSearch(int[] arr, int target) {
        int n = arr.length;
        
        // 构造斐波那契数列
        int[] fib = new int[20];
        fib[0] = 0;
        fib[1] = 1;
        for (int i = 2; i < 20; i++) {
            fib[i] = fib[i - 1] + fib[i - 2];
        }
        
        // 找到最小的斐波那契数使得fib[k] >= n
        int k = 0;
        while (fib[k] < n) {
            k++;
        }
        
        // 创建临时数组
        int[] temp = new int[fib[k]];
        System.arraycopy(arr, 0, temp, 0, n);
        // 用最大值填充扩展部分
        for (int i = n; i < fib[k]; i++) {
            temp[i] = arr[n - 1];
        }
        
        int low = 0;
        int high = n - 1;
        
        while (low <= high) {
            int mid = low + fib[k - 1] - 1;
            
            if (temp[mid] > target) {
                high = mid - 1;
                k = k - 1;
            } else if (temp[mid] < target) {
                low = mid + 1;
                k = k - 2;
            } else {
                if (mid <= high) {
                    return mid;
                } else {
                    return high;
                }
            }
            
            if (k < 2) {
                break;
            }
        }
        
        return -1;
    }
}
```

### 时间复杂度分析

- 最好情况：O(1)
- 平均情况：O(log n)
- 最坏情况：O(log n)
- 空间复杂度：O(log n) - 存储斐波那契数列

### 应用场景

- 大规模有序数据查找
- 对内存访问有特殊要求的场景
- 硬件实现的查找算法

---

## 树表查找

树表查找是基于树形数据结构的查找算法，主要包括二叉搜索树(BST)、平衡二叉树(AVL树)、红黑树等。

### 算法原理

1. 从根节点开始比较
2. 如果目标值等于当前节点值，则找到目标
3. 如果目标值小于当前节点值，则在左子树中查找
4. 如果目标值大于当前节点值，则在右子树中查找
5. 重复上述过程直到找到目标或到达空节点

### Java实现

```java
public class TreeSearch {
    // 二叉搜索树节点定义
    static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        
        TreeNode(int val) {
            this.val = val;
        }
    }
    
    /**
     * 二叉搜索树查找
     * @param root 树的根节点
     * @param target 目标值
     * @return 包含目标值的节点，未找到返回null
     */
    public static TreeNode bstSearch(TreeNode root, int target) {
        if (root == null || root.val == target) {
            return root;
        }
        
        if (target < root.val) {
            return bstSearch(root.left, target);
        } else {
            return bstSearch(root.right, target);
        }
    }
    
    /**
     * 二叉搜索树查找（迭代实现）
     * @param root 树的根节点
     * @param target 目标值
     * @return 包含目标值的节点，未找到返回null
     */
    public static TreeNode bstSearchIterative(TreeNode root, int target) {
        TreeNode current = root;
        
        while (current != null) {
            if (target == current.val) {
                return current;
            } else if (target < current.val) {
                current = current.left;
            } else {
                current = current.right;
            }
        }
        
        return null;
    }
    
    /**
     * AVL树节点定义
     */
    static class AVLNode {
        int val;
        int height;
        AVLNode left;
        AVLNode right;
        
        AVLNode(int val) {
            this.val = val;
            this.height = 1;
        }
    }
    
    /**
     * AVL树查找
     * @param root AVL树的根节点
     * @param target 目标值
     * @return 包含目标值的节点，未找到返回null
     */
    public static AVLNode avlSearch(AVLNode root, int target) {
        if (root == null || root.val == target) {
            return root;
        }
        
        if (target < root.val) {
            return avlSearch(root.left, target);
        } else {
            return avlSearch(root.right, target);
        }
    }
}
```

### 时间复杂度分析

- 二叉搜索树：
  - 最好情况：O(log n) - 平衡树
  - 平均情况：O(log n)
  - 最坏情况：O(n) - 退化为链表
- AVL树：
  - 最好情况：O(log n)
  - 平均情况：O(log n)
  - 最坏情况：O(log n)
- 空间复杂度：O(n) - 存储树结构

### 应用场景

- 需要频繁插入、删除和查找的场景
- 数据库索引结构
- 文件系统目录结构

---

## 分块查找

分块查找是顺序查找和二分查找的结合，它将数据分成若干块，块内元素可以无序，但块间必须有序。

### 算法原理

1. 将n个数据元素"按块有序"划分为m块（m≤n）
2. 每一块中的结点不必有序，但块与块之间必须"按块有序"
3. 在索引表中查找目标值所在的块
4. 在对应块中进行顺序查找

### Java实现

```java
import java.util.*;

public class BlockSearch {
    // 索引表项
    static class IndexItem {
        int maxValue;  // 块中的最大值
        int start;     // 块的起始位置
        int end;       // 块的结束位置
        
        IndexItem(int maxValue, int start, int end) {
            this.maxValue = maxValue;
            this.start = start;
            this.end = end;
        }
    }
    
    /**
     * 分块查找
     * @param arr 数据数组
     * @param indices 索引表
     * @param target 目标值
     * @return 目标值在数组中的索引，未找到返回-1
     */
    public static int blockSearch(int[] arr, List<IndexItem> indices, int target) {
        // 在索引表中查找目标值所在的块
        int blockIndex = -1;
        for (int i = 0; i < indices.size(); i++) {
            if (target <= indices.get(i).maxValue) {
                blockIndex = i;
                break;
            }
        }
        
        // 如果未找到合适的块，说明目标值不存在
        if (blockIndex == -1) {
            return -1;
        }
        
        // 在对应的块中进行顺序查找
        IndexItem block = indices.get(blockIndex);
        for (int i = block.start; i <= block.end; i++) {
            if (arr[i] == target) {
                return i;
            }
        }
        
        return -1;
    }
    
    /**
     * 构建索引表
     * @param arr 数据数组
     * @param blockSize 块大小
     * @return 索引表
     */
    public static List<IndexItem> buildIndex(int[] arr, int blockSize) {
        List<IndexItem> indices = new ArrayList<>();
        
        for (int i = 0; i < arr.length; i += blockSize) {
            int end = Math.min(i + blockSize - 1, arr.length - 1);
            int maxValue = arr[i];
            
            // 找到块中的最大值
            for (int j = i + 1; j <= end; j++) {
                if (arr[j] > maxValue) {
                    maxValue = arr[j];
                }
            }
            
            indices.add(new IndexItem(maxValue, i, end));
        }
        
        return indices;
    }
}
```

### 时间复杂度分析

- 查找索引表：O(log m) - 如果使用二分查找
- 块内查找：O(s) - s为块大小
- 总时间复杂度：O(log m + s)
- 空间复杂度：O(m) - 存储索引表

### 应用场景

- 大规模数据查找，但数据不能完全加载到内存
- 数据库的分页查询
- 文件系统的块查找

---

## 哈希查找

哈希查找是通过哈希函数将关键字映射到哈希表中的位置来实现查找的算法。

### 算法原理

1. 设计哈希函数将关键字映射到哈希表中的位置
2. 处理哈希冲突（链地址法、开放地址法等）
3. 根据哈希函数计算目标值的位置
4. 在对应位置查找目标值

### Java实现

```java
import java.util.*;

public class HashSearch {
    // 链地址法实现哈希表
    static class ChainedHashTable {
        private List<List<Integer>> table;
        private int size;
        private int capacity;
        
        public ChainedHashTable(int capacity) {
            this.capacity = capacity;
            this.size = 0;
            this.table = new ArrayList<>(capacity);
            for (int i = 0; i < capacity; i++) {
                table.add(new LinkedList<>());
            }
        }
        
        // 哈希函数
        private int hash(int key) {
            return key % capacity;
        }
        
        // 插入元素
        public void insert(int key) {
            int index = hash(key);
            table.get(index).add(key);
            size++;
        }
        
        // 查找元素
        public boolean search(int key) {
            int index = hash(key);
            return table.get(index).contains(key);
        }
        
        // 删除元素
        public boolean delete(int key) {
            int index = hash(key);
            boolean removed = table.get(index).remove(Integer.valueOf(key));
            if (removed) {
                size--;
            }
            return removed;
        }
        
        public int getSize() {
            return size;
        }
    }
    
    // 开放地址法实现哈希表（线性探测）
    static class OpenAddressHashTable {
        private Integer[] table;
        private boolean[] deleted;
        private int size;
        private int capacity;
        private static final Integer DELETED = Integer.MIN_VALUE;
        
        public OpenAddressHashTable(int capacity) {
            this.capacity = capacity;
            this.size = 0;
            this.table = new Integer[capacity];
            this.deleted = new boolean[capacity];
        }
        
        // 哈希函数
        private int hash(int key) {
            return key % capacity;
        }
        
        // 线性探测
        private int probe(int key) {
            int index = hash(key);
            int i = 0;
            
            while (table[index] != null && !table[index].equals(key)) {
                if (deleted[index] && table[index].equals(DELETED)) {
                    break;
                }
                i++;
                index = (hash(key) + i) % capacity;
                if (i >= capacity) {
                    return -1; // 哈希表已满
                }
            }
            
            return index;
        }
        
        // 插入元素
        public boolean insert(int key) {
            int index = probe(key);
            if (index == -1) {
                return false; // 哈希表已满
            }
            
            if (table[index] == null || deleted[index]) {
                table[index] = key;
                deleted[index] = false;
                size++;
                return true;
            }
            
            return false; // 元素已存在
        }
        
        // 查找元素
        public boolean search(int key) {
            int index = probe(key);
            return index != -1 && table[index] != null && table[index].equals(key) && !deleted[index];
        }
        
        // 删除元素
        public boolean delete(int key) {
            int index = probe(key);
            if (index != -1 && table[index] != null && table[index].equals(key) && !deleted[index]) {
                deleted[index] = true;
                table[index] = DELETED;
                size--;
                return true;
            }
            return false;
        }
        
        public int getSize() {
            return size;
        }
    }
}
```

### 时间复杂度分析

- 理想情况：O(1) - 无冲突
- 平均情况：O(1 + α) - α为装填因子
- 最坏情况：O(n) - 所有元素都发生冲突
- 空间复杂度：O(n)

### 应用场景

- 需要快速查找的场景
- 缓存系统实现
- 数据库索引
- 字典和集合的实现

---

## 查找算法性能比较

| 查找算法 | 最好时间复杂度 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 数据要求 | 适用场景 |
|---------|---------------|---------------|---------------|-----------|----------|----------|
| 顺序查找 | O(1) | O(n) | O(n) | O(1) | 无序 | 小规模数据 |
| 二分查找 | O(1) | O(log n) | O(log n) | O(1) | 有序 | 大规模有序数据 |
| 插值查找 | O(1) | O(log log n) | O(n) | O(1) | 均匀分布有序 | 均匀分布数据 |
| 斐波那契查找 | O(1) | O(log n) | O(log n) | O(log n) | 有序 | 特殊硬件实现 |
| 树表查找(BST) | O(1) | O(log n) | O(n) | O(n) | 有序 | 动态数据集 |
| 树表查找(AVL) | O(1) | O(log n) | O(log n) | O(n) | 有序 | 平衡要求高的场景 |
| 分块查找 | O(1) | O(√n) | O(√n) | O(√n) | 块间有序 | 大规模外部数据 |
| 哈希查找 | O(1) | O(1) | O(n) | O(n) | 无序 | 快速查找场景 |

---

## 最佳实践

### 1. 选择合适的查找算法

- **小规模无序数据**：顺序查找
- **大规模有序数据**：二分查找
- **均匀分布的有序数据**：插值查找
- **频繁插入删除的有序数据**：平衡二叉搜索树
- **快速查找需求**：哈希查找
- **外部存储的大规模数据**：分块查找

### 2. 实际应用建议

1. **Java内置查找**：
   ```java
   // 二分查找
   int index = Arrays.binarySearch(sortedArray, target);
   
   // 集合查找
   boolean found = set.contains(target);
   boolean found = map.containsKey(key);
   ```

2. **自定义比较器**：
   ```java
   // 使用自定义比较器进行查找
   Comparator<String> comparator = Comparator.comparingInt(String::length);
   int index = Collections.binarySearch(list, target, comparator);
   ```

### 3. 性能优化技巧

1. **预处理数据**：对于频繁查找的静态数据，可以预先排序
2. **选择合适的哈希函数**：减少哈希冲突提高查找效率
3. **动态调整数据结构**：根据数据特点选择合适的数据结构
4. **缓存热点数据**：对于热点数据可以使用缓存机制

### 4. 错误避免

1. **边界条件处理**：确保正确处理空数组、单元素数组等特殊情况
2. **数据有序性**：使用有序查找算法前确保数据已排序
3. **哈希冲突处理**：合理处理哈希冲突避免性能下降
4. **索引越界检查**：防止数组越界访问

### 5. 测试验证

1. **边界测试**：测试空数组、单元素、目标在开头/结尾等特殊情况
2. **随机测试**：使用随机数据验证算法正确性
3. **性能测试**：在不同规模数据上测试性能表现
4. **重复元素测试**：验证算法在有重复元素时的正确性

通过本章的学习，你应该掌握了各种查找算法的原理、实现和应用场景。在实际开发中，合理选择和使用查找算法能够显著提升程序性能。