# 第二十一章 策略模式详解

## 本章概要
- 策略模式的定义和概念
- 策略模式的结构和组成
- 策略模式的实现方式
- 实际应用场景分析
- 开源框架中的应用
- 策略模式的优缺点
- 与其他设计模式的比较
- 最佳实践和注意事项

## 策略模式概述

策略模式（Strategy Pattern）是一种行为型设计模式，它定义了一系列算法，并将每个算法封装起来，使它们可以互相替换。策略模式让算法的变化独立于使用算法的客户。

### 核心思想
策略模式的核心思想是定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。策略模式让算法的变化独立于使用算法的客户，使得算法可以独立于客户端变化。

### 应用场景
1. 当一个系统需要在多种算法中动态选择一种时
2. 当类中存在大量与算法相关的条件语句时，可以将这些算法封装成策略类
3. 当需要屏蔽算法规则的具体实现时
4. 当一个对象有很多的行为，如果不使用恰当的模式，这些行为就只好使用多重的条件选择语句来实现时
5. 当需要对客户隐藏具体策略（算法）的实现细节，彼此完全独立时

## 策略模式结构

策略模式包含以下角色：
1. **Strategy（策略）**：定义所有支持的算法的公共接口，Context使用这个接口来调用具体的策略定义的算法
2. **ConcreteStrategy（具体策略）**：实现了Strategy接口的具体算法
3. **Context（上下文）**：持有一个Strategy的引用，用一个ConcreteStrategy对象来配置，维护一个对Strategy对象的引用，可以定义一个接口来让Strategy访问它的数据

## 策略模式实现

### 基本实现

```java
// 策略接口
interface Strategy {
    int doOperation(int num1, int num2);
}

// 具体策略 - 加法
class OperationAdd implements Strategy {
    @Override
    public int doOperation(int num1, int num2) {
        return num1 + num2;
    }
}

// 具体策略 - 减法
class OperationSubtract implements Strategy {
    @Override
    public int doOperation(int num1, int num2) {
        return num1 - num2;
    }
}

// 具体策略 - 乘法
class OperationMultiply implements Strategy {
    @Override
    public int doOperation(int num1, int num2) {
        return num1 * num2;
    }
}

// 上下文
class Context {
    private Strategy strategy;
    
    public Context(Strategy strategy) {
        this.strategy = strategy;
    }
    
    public int executeStrategy(int num1, int num2) {
        return strategy.doOperation(num1, num2);
    }
}
```

### 更复杂的实现示例

让我们通过一个支付系统的例子来展示更复杂的实现。

## 实际应用示例

### 1. 支付系统

```java
// 支付策略接口
interface PaymentStrategy {
    void pay(double amount);
}

// 信用卡支付策略
class CreditCardPayment implements PaymentStrategy {
    private String cardNumber;
    private String cardHolderName;
    private String cvv;
    private String expiryDate;
    
    public CreditCardPayment(String cardNumber, String cardHolderName, String cvv, String expiryDate) {
        this.cardNumber = cardNumber;
        this.cardHolderName = cardHolderName;
        this.cvv = cvv;
        this.expiryDate = expiryDate;
    }
    
    @Override
    public void pay(double amount) {
        System.out.println("使用信用卡支付: ¥" + amount);
        System.out.println("卡号: " + cardNumber);
        System.out.println("持卡人: " + cardHolderName);
        // 处理信用卡支付逻辑
    }
}

// 支付宝支付策略
class AlipayPayment implements PaymentStrategy {
    private String alipayAccount;
    
    public AlipayPayment(String alipayAccount) {
        this.alipayAccount = alipayAccount;
    }
    
    @Override
    public void pay(double amount) {
        System.out.println("使用支付宝支付: ¥" + amount);
        System.out.println("账户: " + alipayAccount);
        // 处理支付宝支付逻辑
    }
}

// 微信支付策略
class WechatPayment implements PaymentStrategy {
    private String wechatAccount;
    
    public WechatPayment(String wechatAccount) {
        this.wechatAccount = wechatAccount;
    }
    
    @Override
    public void pay(double amount) {
        System.out.println("使用微信支付: ¥" + amount);
        System.out.println("账户: " + wechatAccount);
        // 处理微信支付逻辑
    }
}

// 支付上下文
class PaymentContext {
    private PaymentStrategy paymentStrategy;
    
    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }
    
    public void executePayment(double amount) {
        if (paymentStrategy == null) {
            System.out.println("请先选择支付方式");
            return;
        }
        paymentStrategy.pay(amount);
    }
}
```

### 2. 排序算法选择系统

```java
import java.util.*;

// 排序策略接口
interface SortStrategy {
    void sort(List<Integer> list);
}

// 冒泡排序策略
class BubbleSortStrategy implements SortStrategy {
    @Override
    public void sort(List<Integer> list) {
        System.out.println("使用冒泡排序算法");
        int n = list.size();
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (list.get(j) > list.get(j + 1)) {
                    // 交换元素
                    Collections.swap(list, j, j + 1);
                }
            }
        }
    }
}

// 快速排序策略
class QuickSortStrategy implements SortStrategy {
    @Override
    public void sort(List<Integer> list) {
        System.out.println("使用快速排序算法");
        quickSort(list, 0, list.size() - 1);
    }
    
    private void quickSort(List<Integer> list, int low, int high) {
        if (low < high) {
            int pi = partition(list, low, high);
            quickSort(list, low, pi - 1);
            quickSort(list, pi + 1, high);
        }
    }
    
    private int partition(List<Integer> list, int low, int high) {
        int pivot = list.get(high);
        int i = (low - 1);
        
        for (int j = low; j < high; j++) {
            if (list.get(j) <= pivot) {
                i++;
                Collections.swap(list, i, j);
            }
        }
        Collections.swap(list, i + 1, high);
        return i + 1;
    }
}

// 归并排序策略
class MergeSortStrategy implements SortStrategy {
    @Override
    public void sort(List<Integer> list) {
        System.out.println("使用归并排序算法");
        mergeSort(list, 0, list.size() - 1);
    }
    
    private void mergeSort(List<Integer> list, int left, int right) {
        if (left < right) {
            int mid = (left + right) / 2;
            mergeSort(list, left, mid);
            mergeSort(list, mid + 1, right);
            merge(list, left, mid, right);
        }
    }
    
    private void merge(List<Integer> list, int left, int mid, int right) {
        List<Integer> leftList = new ArrayList<>(list.subList(left, mid + 1));
        List<Integer> rightList = new ArrayList<>(list.subList(mid + 1, right + 1));
        
        int i = 0, j = 0, k = left;
        
        while (i < leftList.size() && j < rightList.size()) {
            if (leftList.get(i) <= rightList.get(j)) {
                list.set(k++, leftList.get(i++));
            } else {
                list.set(k++, rightList.get(j++));
            }
        }
        
        while (i < leftList.size()) {
            list.set(k++, leftList.get(i++));
        }
        
        while (j < rightList.size()) {
            list.set(k++, rightList.get(j++));
        }
    }
}

// 排序上下文
class SortContext {
    private SortStrategy sortStrategy;
    
    public void setSortStrategy(SortStrategy sortStrategy) {
        this.sortStrategy = sortStrategy;
    }
    
    public void executeSort(List<Integer> list) {
        if (sortStrategy == null) {
            System.out.println("请先选择排序算法");
            return;
        }
        sortStrategy.sort(list);
    }
}
```

## 开源框架中的应用

1. **Java Collections Framework**：Collections.sort()方法允许传入Comparator接口的实现，这就是策略模式的应用
2. **Spring Framework**：Spring的Resource接口有不同的实现类（ClassPathResource、FileSystemResource等），可以根据不同需求选择不同的资源加载策略
3. **Apache Commons**：在很多工具类中使用策略模式来提供不同的实现方式

## 策略模式的优缺点

### 优点
1. **算法可以自由切换**：策略模式使得算法可以在不影响到客户端的情况下进行切换
2. **避免使用多重条件判断**：在策略模式中，我们可以避免使用多重if-else或switch-case语句，使得代码更加清晰和易于维护
3. **扩展性良好**：遵循开闭原则，新的策略可以很方便地添加，而不需要修改上下文类的代码
4. **提高代码灵活性和可维护性**：算法的实现细节对客户端透明，客户端只需设置合适的策略对象，而不需要关心具体算法的实现
5. **代码复用性强**：策略可以独立于上下文，因此可以在不同上下文中复用

### 缺点
1. **策略类会增多**：每个算法都需要对应一个策略类，可能引起类膨胀
2. **所有策略类都需要对外暴露**：上层模块必须知道有哪些策略，并且自行决定使用哪一个策略类
3. **客户端必须知道所有的策略类**：策略模式只适用于客户端知道所有的算法或行为的情况

## 与其他设计模式的比较

1. **与状态模式的区别**：策略模式和状态模式的UML图很相似，但意图不同。状态模式允许一个对象在其内部状态改变时改变其行为，对象看起来似乎修改了其类；而策略模式是为了封装算法族，使得它们之间可以互相替换，算法的变化独立于使用算法的客户
2. **与模板方法模式的区别**：模板方法模式定义一个操作中的算法骨架，而将一些步骤延迟到子类中；策略模式则是定义一系列算法，把它们一个个封装起来，并且使它们可相互替换
3. **与命令模式的区别**：命令模式将请求封装成对象，使得可以用不同的请求对客户进行参数化；而策略模式则是定义一系列算法，把它们一个个封装起来，并且使它们可相互替换

## 最佳实践和注意事项

1. **合理选择策略**：在实际应用中，需要根据具体情况选择合适的策略，而不是盲目地使用策略模式
2. **避免过度设计**：如果算法族很少变化或者只有少数几种算法，那么使用策略模式可能是过度设计
3. **策略的初始化**：可以通过工厂模式或者配置文件来初始化策略，避免客户端直接依赖具体的策略类
4. **策略的组合**：有时候可以将多个策略组合使用，形成更复杂的策略
5. **策略的生命周期管理**：注意策略对象的创建和销毁，避免内存泄漏
6. **异常处理**：在策略执行过程中应该进行适当的异常处理，确保系统的稳定性