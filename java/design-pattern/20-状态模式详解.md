# 第二十章 状态模式详解

## 本章概要
- 状态模式的定义和概念
- 状态模式的结构和组成
- 状态模式的实现方式
- 实际应用场景分析
- 开源框架中的应用
- 状态模式的优缺点
- 与其他设计模式的比较
- 最佳实践和注意事项

## 状态模式概述

状态模式（State Pattern）是一种行为型设计模式，它允许一个对象在其内部状态改变时改变它的行为，使对象看起来似乎修改了它的类。状态模式将对象的状态封装成独立的类，并将对象的行为委托给当前的状态对象。

### 核心思想
状态模式的核心思想是将对象在不同状态下的行为封装在不同的状态类中，通过改变状态对象来改变对象的行为。这样做的好处是可以避免在对象中使用大量的条件语句来判断当前状态，使代码更加清晰和易于维护。

### 应用场景
1. 对象的行为依赖于它的状态，并且在运行时需要根据状态改变其行为
2. 代码中包含大量与对象状态有关的条件语句，这些条件分支依赖于对象的状态
3. 需要在运行时动态改变对象的行为
4. 实现有限状态机或工作流系统
5. 游戏开发中的角色状态管理、订单处理系统等

## 状态模式结构

状态模式包含以下角色：
1. **State（抽象状态）**：定义一个接口，用来封装与Context的一个特定状态相关的行为
2. **ConcreteState（具体状态）**：每一个具体状态类都实现了状态行为的不同实现
3. **Context（上下文）**：定义客户感兴趣的接口，维护一个ConcreteState子类的实例，这个实例定义当前状态

## 状态模式实现

### 基本实现

```java
// 抽象状态类
abstract class State {
    public abstract void handle(Context context);
}

// 具体状态A
class ConcreteStateA extends State {
    @Override
    public void handle(Context context) {
        System.out.println("处理状态A的逻辑");
        // 切换到状态B
        context.setState(new ConcreteStateB());
    }
}

// 具体状态B
class ConcreteStateB extends State {
    @Override
    public void handle(Context context) {
        System.out.println("处理状态B的逻辑");
        // 切换到状态A
        context.setState(new ConcreteStateA());
    }
}

// 上下文类
class Context {
    private State state;
    
    public Context() {
        // 初始化为状态A
        this.state = new ConcreteStateA();
    }
    
    public void setState(State state) {
        this.state = state;
    }
    
    public State getState() {
        return state;
    }
    
    public void request() {
        // 委托给当前状态处理
        state.handle(this);
    }
}
```

### 更复杂的实现示例

让我们通过一个订单处理系统来展示更复杂的实现。

## 实际应用示例

### 1. 订单处理系统

```java
// 订单状态接口
interface OrderState {
    void pay(OrderContext context);
    void cancel(OrderContext context);
    void ship(OrderContext context);
    void receive(OrderContext context);
    void complete(OrderContext context);
    String getStateName();
}

// 待支付状态
class UnpaidState implements OrderState {
    @Override
    public void pay(OrderContext context) {
        System.out.println("订单已支付");
        context.setState(new PaidState());
    }
    
    @Override
    public void cancel(OrderContext context) {
        System.out.println("订单已取消");
        context.setState(new CancelledState());
    }
    
    @Override
    public void ship(OrderContext context) {
        System.out.println("错误：未支付的订单不能发货");
    }
    
    @Override
    public void receive(OrderContext context) {
        System.out.println("错误：未支付的订单不能收货");
    }
    
    @Override
    public void complete(OrderContext context) {
        System.out.println("错误：未支付的订单不能完成");
    }
    
    @Override
    public String getStateName() {
        return "待支付";
    }
}

// 已支付状态
class PaidState implements OrderState {
    @Override
    public void pay(OrderContext context) {
        System.out.println("错误：订单已支付");
    }
    
    @Override
    public void cancel(OrderContext context) {
        System.out.println("订单已取消");
        context.setState(new CancelledState());
    }
    
    @Override
    public void ship(OrderContext context) {
        System.out.println("订单已发货");
        context.setState(new ShippedState());
    }
    
    @Override
    public void receive(OrderContext context) {
        System.out.println("错误：已支付但未发货的订单不能收货");
    }
    
    @Override
    public void complete(OrderContext context) {
        System.out.println("错误：已支付但未发货的订单不能完成");
    }
    
    @Override
    public String getStateName() {
        return "已支付";
    }
}

// 已发货状态
class ShippedState implements OrderState {
    @Override
    public void pay(OrderContext context) {
        System.out.println("错误：已发货的订单不能再次支付");
    }
    
    @Override
    public void cancel(OrderContext context) {
        System.out.println("错误：已发货的订单不能取消");
    }
    
    @Override
    public void ship(OrderContext context) {
        System.out.println("错误：订单已发货");
    }
    
    @Override
    public void receive(OrderContext context) {
        System.out.println("订单已收货");
        context.setState(new ReceivedState());
    }
    
    @Override
    public void complete(OrderContext context) {
        System.out.println("错误：未收货的订单不能完成");
    }
    
    @Override
    public String getStateName() {
        return "已发货";
    }
}

// 已收货状态
class ReceivedState implements OrderState {
    @Override
    public void pay(OrderContext context) {
        System.out.println("错误：已收货的订单不能支付");
    }
    
    @Override
    public void cancel(OrderContext context) {
        System.out.println("错误：已收货的订单不能取消");
    }
    
    @Override
    public void ship(OrderContext context) {
        System.out.println("错误：已收货的订单不能再次发货");
    }
    
    @Override
    public void receive(OrderContext context) {
        System.out.println("错误：订单已收货");
    }
    
    @Override
    public void complete(OrderContext context) {
        System.out.println("订单已完成");
        context.setState(new CompletedState());
    }
    
    @Override
    public String getStateName() {
        return "已收货";
    }
}

// 已完成状态
class CompletedState implements OrderState {
    @Override
    public void pay(OrderContext context) {
        System.out.println("错误：已完成的订单不能支付");
    }
    
    @Override
    public void cancel(OrderContext context) {
        System.out.println("错误：已完成的订单不能取消");
    }
    
    @Override
    public void ship(OrderContext context) {
        System.out.println("错误：已完成的订单不能发货");
    }
    
    @Override
    public void receive(OrderContext context) {
        System.out.println("错误：已完成的订单不能收货");
    }
    
    @Override
    public void complete(OrderContext context) {
        System.out.println("错误：订单已完成");
    }
    
    @Override
    public String getStateName() {
        return "已完成";
    }
}

// 已取消状态
class CancelledState implements OrderState {
    @Override
    public void pay(OrderContext context) {
        System.out.println("错误：已取消的订单不能支付");
    }
    
    @Override
    public void cancel(OrderContext context) {
        System.out.println("错误：订单已取消");
    }
    
    @Override
    public void ship(OrderContext context) {
        System.out.println("错误：已取消的订单不能发货");
    }
    
    @Override
    public void receive(OrderContext context) {
        System.out.println("错误：已取消的订单不能收货");
    }
    
    @Override
    public void complete(OrderContext context) {
        System.out.println("错误：已取消的订单不能完成");
    }
    
    @Override
    public String getStateName() {
        return "已取消";
    }
}

// 订单上下文
class OrderContext {
    private OrderState state;
    private String orderId;
    
    public OrderContext(String orderId) {
        this.orderId = orderId;
        // 默认状态为待支付
        this.state = new UnpaidState();
        System.out.println("创建订单: " + orderId + "，当前状态: " + state.getStateName());
    }
    
    public void setState(OrderState state) {
        this.state = state;
        System.out.println("订单 " + orderId + " 状态变更为: " + state.getStateName());
    }
    
    public OrderState getState() {
        return state;
    }
    
    public String getOrderId() {
        return orderId;
    }
    
    // 支付订单
    public void pay() {
        System.out.println("尝试支付订单 " + orderId);
        state.pay(this);
    }
    
    // 取消订单
    public void cancel() {
        System.out.println("尝试取消订单 " + orderId);
        state.cancel(this);
    }
    
    // 发货
    public void ship() {
        System.out.println("尝试发货订单 " + orderId);
        state.ship(this);
    }
    
    // 收货
    public void receive() {
        System.out.println("尝试收货订单 " + orderId);
        state.receive(this);
    }
    
    // 完成订单
    public void complete() {
        System.out.println("尝试完成订单 " + orderId);
        state.complete(this);
    }
}
```

### 2. 状态机示例 - 交通信号灯

```java
// 交通信号灯状态接口
interface TrafficLightState {
    void handle(TrafficLightContext context);
    String getColor();
}

// 红灯状态
class RedLightState implements TrafficLightState {
    @Override
    public void handle(TrafficLightContext context) {
        System.out.println("红灯亮起，车辆停止通行...");
        try {
            Thread.sleep(3000); // 红灯持续3秒
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 切换到绿灯
        context.setState(new GreenLightState());
    }
    
    @Override
    public String getColor() {
        return "红色";
    }
}

// 绿灯状态
class GreenLightState implements TrafficLightState {
    @Override
    public void handle(TrafficLightContext context) {
        System.out.println("绿灯亮起，车辆可以通行...");
        try {
            Thread.sleep(5000); // 绿灯持续5秒
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 切换到黄灯
        context.setState(new YellowLightState());
    }
    
    @Override
    public String getColor() {
        return "绿色";
    }
}

// 黄灯状态
class YellowLightState implements TrafficLightState {
    @Override
    public void handle(TrafficLightContext context) {
        System.out.println("黄灯亮起，准备变换信号...");
        try {
            Thread.sleep(2000); // 黄灯持续2秒
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 切换到红灯
        context.setState(new RedLightState());
    }
    
    @Override
    public String getColor() {
        return "黄色";
    }
}

// 交通信号灯上下文
class TrafficLightContext {
    private TrafficLightState state;
    
    public TrafficLightContext() {
        // 初始状态为红灯
        this.state = new RedLightState();
    }
    
    public void setState(TrafficLightState state) {
        this.state = state;
    }
    
    public TrafficLightState getState() {
        return state;
    }
    
    public void change() {
        System.out.println("当前信号灯颜色: " + state.getColor());
        state.handle(this);
    }
}
```

## 开源框架中的应用

### 1. Spring Web Flow

Spring Web Flow框架大量使用了状态模式来管理Web应用程序的流程状态：

```java
// Spring Web Flow中的状态模式示例（伪代码）
/*
@Configuration
public class BookingFlowConfig extends AbstractFlowConfiguration {
    
    @Bean
    public FlowDefinitionRegistry flowRegistry() {
        return getFlowDefinitionRegistryBuilder()
            .addFlowLocation("booking-flow.xml")
            .build();
    }
    
    // 状态定义示例
    public class BookingFlow extends AbstractFlow {
        @Override
        protected void buildStates(StateMachineBuilder builder) throws Exception {
            // 开始状态
            builder.onStart("enterBookingDetails")
                   .and()
                   // 视图状态
                   .viewState("enterBookingDetails")
                   .model("booking")
                   .view("bookingDetails")
                   .transition("proceed", "reviewBooking")
                   .transition("cancel", "cancelConfirmation");
                   
            // 动作状态
            builder.actionState("reviewBooking")
                   .action("bookingAction")
                   .transition("confirm", "bookingConfirmed")
                   .transition("revise", "enterBookingDetails");
        }
    }
}
*/
```

### 2. Netty框架

Netty框架中的Channel状态管理也使用了状态模式的思想：

```java
// Netty中的Channel状态管理（简化示例）
/*
public enum ChannelState {
    OPEN(true, false),
    BOUND(true, false),
    CONNECTED(true, true),
    DISCONNECTED(true, false),
    CLOSED(false, false);

    private final boolean active;
    private final boolean connected;

    ChannelState(boolean active, boolean connected) {
        this.active = active;
        this.connected = connected;
    }

    public boolean isActive() {
        return active;
    }

    public boolean isConnected() {
        return connected;
    }
}
*/
```

## 状态模式的优缺点

### 优点
1. **封装性好**：将特定状态的行为都放入一个对象中，通过定义新的子类可以很容易地增加新的状态和转换
2. **消除庞大的条件分支语句**：状态模式通过把各种状态转移逻辑分布到各个状态类中，避免了多重条件选择语句
3. **易于扩展**：增加新的状态非常容易，只需要增加一个新的子类并实现相应的方法即可
4. **结构清晰**：状态模式将与特定状态相关的行为局部化，并且将不同状态的行为分割开来

### 缺点
1. **增加类数量**：每种状态都需要一个类，导致类的数量增加
2. **状态切换复杂性**：如果状态间切换规则复杂，可能使上下文类难以管理
3. **对象开销**：每个状态都是一个对象，会增加系统的开销
4. **可能违反开闭原则**：如果状态转换逻辑需要修改，可能需要修改现有的状态类

## 与其他设计模式的比较

### 1. 与策略模式的关系
- 状态模式和策略模式在实现上很相似，都有一个上下文类和多个具体实现类
- 区别在于：
  - 策略模式是为了封装算法族，使得它们可以互相替换，客户端可以选择使用哪种算法
  - 状态模式是让对象在内部状态改变时改变其行为，状态的切换是由对象自身控制的

### 2. 与观察者模式的关系
- 观察者模式是当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新
- 状态模式是对象根据自己的状态改变行为
- 两种模式可以结合使用，比如在状态改变时通知观察者

### 3. 与模板方法模式的关系
- 模板方法模式定义了一个算法的骨架，而将一些步骤延迟到子类中实现
- 状态模式将对象的行为委托给当前的状态对象
- 两者都可以实现多态行为，但方式不同

## 最佳实践和注意事项

### 最佳实践
1. **合理划分状态**：状态的划分应该基于业务逻辑，每个状态都应该有明确的职责
2. **状态转换要明确**：状态之间的转换应该是明确定义的，避免出现非法状态转换
3. **共享状态对象**：如果状态对象没有实例变量，可以考虑使用单例模式共享状态对象
4. **使用枚举实现状态**：对于简单的状态模式，可以考虑使用枚举来实现

### 注意事项
1. **避免状态爆炸**：当状态过多时，会导致类的数量急剧增加，要考虑是否真的需要这么多状态
2. **状态持久化**：在分布式系统中，状态的持久化和恢复需要特别考虑
3. **并发安全**：在多线程环境中使用状态模式时，需要考虑线程安全问题
4. **状态切换时机**：要明确状态切换的时机和触发条件，避免状态混乱

## 总结

状态模式是一种非常有用的行为型设计模式，特别适用于那些具有明显状态特征的业务场景。通过将对象的状态封装成独立的类，状态模式可以有效地消除大量的条件判断语句，使代码更加清晰和易于维护。

在实际开发中，状态模式广泛应用于订单管理系统、工作流引擎、游戏开发等领域。合理使用状态模式可以显著提高代码的质量和可维护性，但也需要注意避免状态爆炸和过度设计的问题。