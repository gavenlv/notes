# 第十二章 代理模式详解

## 1. 代理模式概述

### 1.1 定义
代理模式(Proxy Pattern)是一种结构型设计模式，它为其他对象提供一种代理以控制对这个对象的访问。代理模式可以在客户端和目标对象之间起到中介的作用，并且可以添加额外的功能，比如权限控制、延迟加载、日志记录等。

### 1.2 核心思想
代理模式的核心思想是"控制访问"。通过引入代理对象来控制对真实对象的访问，代理对象可以执行一些额外的操作，然后再将请求转发给真实对象。

## 2. 代理模式结构

代理模式包含以下角色：

1. **Subject(抽象主题)**：声明了RealSubject和Proxy的共同接口，这样就可以在任何使用RealSubject的地方都使用Proxy
2. **RealSubject(真实主题)**：定义了代理所代表的真实对象，是最终要引用的对象
3. **Proxy(代理)**：保存一个引用使得代理可以访问实体，提供一个与Subject的接口相同的接口，这样代理就可以替代实体

## 3. 代理模式类型

### 3.1 远程代理(Remote Proxy)
为一个位于不同的地址空间的对象提供一个本地的代表对象。

### 3.2 虚拟代理(Virtual Proxy)
根据需要创建开销很大的对象，通过虚拟代理来优化性能。

### 3.3 保护代理(Protection Proxy)
控制对原始对象的访问，用于对象应该有不同的访问权限的时候。

### 3.4 智能引用代理(Smart Reference Proxy)
取代了简单的指针，在访问对象时执行一些附加操作。

## 4. 代理模式实现

### 4.1 基本实现
```java
// 抽象主题接口
interface Image {
    void display();
}

// 真实主题类
class RealImage implements Image {
    private String fileName;
    
    public RealImage(String fileName){
        this.fileName = fileName;
        loadFromDisk(fileName);
    }
    
    @Override
    public void display() {
        System.out.println("Displaying " + fileName);
    }
    
    private void loadFromDisk(String fileName){
        System.out.println("Loading " + fileName);
    }
}

// 代理类
class ProxyImage implements Image{
    private RealImage realImage;
    private String fileName;
    
    public ProxyImage(String fileName){
        this.fileName = fileName;
    }
    
    @Override
    public void display() {
        if(realImage == null){
            realImage = new RealImage(fileName);
        }
        realImage.display();
    }
}
```

### 4.2 保护代理示例
```java
// 抽象主题接口
interface Internet {
    void connectTo(String serverHost) throws Exception;
}

// 真实主题类
class RealInternet implements Internet {
    @Override
    public void connectTo(String serverHost) {
        System.out.println("Connecting to " + serverHost);
    }
}

// 保护代理类
class ProxyInternet implements Internet {
    private Internet internet = new RealInternet();
    private static java.util.List<String> bannedSites;
    
    static {
        bannedSites = new java.util.ArrayList<String>();
        bannedSites.add("badsite.com");
        bannedSites.add("restricted.com");
        bannedSites.add("illegal.com");
    }
    
    @Override
    public void connectTo(String serverHost) throws Exception {
        if(bannedSites.contains(serverHost.toLowerCase())) {
            throw new Exception("Access Denied to " + serverHost);
        }
        internet.connectTo(serverHost);
    }
}
```

## 5. 实际应用示例

### 5.1 虚拟代理 - 图片加载系统
```java
import javax.swing.*;
import java.net.URL;

// 抽象主题接口
interface Image {
    void display();
}

// 真实主题类
class RealImage implements Image {
    private String url;
    private ImageIcon image;
    
    public RealImage(String url) {
        this.url = url;
        loadImage(url);
    }
    
    private void loadImage(String url) {
        System.out.println("Loading image from: " + url);
        try {
            // 模拟网络加载时间
            Thread.sleep(2000);
            // 实际项目中会从URL加载图片
            // image = new ImageIcon(new URL(url));
            System.out.println("Image loaded successfully");
        } catch (Exception e) {
            System.out.println("Failed to load image: " + e.getMessage());
        }
    }
    
    @Override
    public void display() {
        System.out.println("Displaying image: " + url);
        // 实际项目中会显示图片
        // label.setIcon(image);
    }
}

// 虚拟代理类
class VirtualImageProxy implements Image {
    private RealImage realImage;
    private String url;
    private boolean loading = false;
    
    public VirtualImageProxy(String url) {
        this.url = url;
    }
    
    @Override
    public void display() {
        if (realImage == null && !loading) {
            loading = true;
            // 在单独的线程中加载图片，避免阻塞UI
            new Thread(() -> {
                realImage = new RealImage(url);
                loading = false;
            }).start();
            
            System.out.println("Image loading started in background...");
        } else if (realImage != null) {
            realImage.display();
        } else {
            System.out.println("Image is still loading...");
        }
    }
}
```

### 5.2 智能引用代理 - 访问计数器
```java
// 抽象主题接口
interface DatabaseConnection {
    void executeQuery(String sql);
    void close();
}

// 真实主题类
class RealDatabaseConnection implements DatabaseConnection {
    private String connectionId;
    private boolean closed = false;
    
    public RealDatabaseConnection(String connectionId) {
        this.connectionId = connectionId;
        System.out.println("Creating database connection: " + connectionId);
    }
    
    @Override
    public void executeQuery(String sql) {
        if (closed) {
            System.out.println("Connection is closed, cannot execute query");
            return;
        }
        System.out.println("Executing query on connection " + connectionId + ": " + sql);
    }
    
    @Override
    public void close() {
        if (!closed) {
            System.out.println("Closing database connection: " + connectionId);
            closed = true;
        }
    }
    
    public boolean isClosed() {
        return closed;
    }
}

// 智能引用代理类
class SmartDatabaseProxy implements DatabaseConnection {
    private RealDatabaseConnection realConnection;
    private String connectionId;
    private static int accessCount = 0;
    private static java.util.Map<String, Integer> connectionUsage = new java.util.HashMap<>();
    
    public SmartDatabaseProxy(String connectionId) {
        this.connectionId = connectionId;
        this.realConnection = new RealDatabaseConnection(connectionId);
    }
    
    @Override
    public void executeQuery(String sql) {
        // 记录访问次数
        accessCount++;
        connectionUsage.put(connectionId, connectionUsage.getOrDefault(connectionId, 0) + 1);
        
        System.out.println("Access count: " + accessCount);
        System.out.println("Connection " + connectionId + " usage: " + connectionUsage.get(connectionId));
        
        // 检查是否超过使用限制
        if (connectionUsage.get(connectionId) > 10) {
            System.out.println("Warning: Connection " + connectionId + " has been used more than 10 times");
        }
        
        realConnection.executeQuery(sql);
    }
    
    @Override
    public void close() {
        System.out.println("Closing proxy for connection: " + connectionId);
        realConnection.close();
    }
    
    // 获取统计信息
    public static int getTotalAccessCount() {
        return accessCount;
    }
    
    public static java.util.Map<String, Integer> getConnectionUsage() {
        return new java.util.HashMap<>(connectionUsage);
    }
}
```

## 6. 开源框架中的应用

### 6.1 Spring AOP中的代理模式
Spring框架广泛使用代理模式来实现面向切面编程(AOP)：

```java
// Spring AOP代理示例（概念性代码）
/*
@Service
public class UserServiceImpl implements UserService {
    @Override
    public User getUserById(Long id) {
        // 业务逻辑
        return userRepository.findById(id);
    }
}

// AOP切面
@Aspect
@Component
public class LoggingAspect {
    @Around("execution(* com.example.service.UserService.*(..))")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
        long startTime = System.currentTimeMillis();
        Object result = joinPoint.proceed();
        long endTime = System.currentTimeMillis();
        System.out.println("Method " + joinPoint.getSignature().getName() + 
                          " executed in " + (endTime - startTime) + "ms");
        return result;
    }
}
*/
```

### 6.2 Hibernate中的延迟加载代理
Hibernate使用代理模式实现延迟加载：

```java
// Hibernate代理示例（概念性代码）
/*
@Entity
public class User {
    @Id
    private Long id;
    
    @OneToMany(fetch = FetchType.LAZY)
    private List<Order> orders;
    
    // getters and setters
}

// 当访问orders时，Hibernate会返回一个代理对象，
// 只有在真正访问orders的数据时才会执行数据库查询
User user = session.get(User.class, 1L);
// 此时orders是一个代理对象
List<Order> orders = user.getOrders(); // 实际查询在此时执行
*/
```

## 7. 优缺点分析

### 7.1 优点
1. **职责清晰**：真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务
2. **高扩展性**：代理类可以在客户端毫无察觉的情况下增加额外的功能
3. **智能化**：代理可以在运行时动态地决定如何处理请求

### 7.2 缺点
1. **增加系统复杂性**：由于引入了代理对象，可能会使系统变得复杂
2. **性能影响**：在某些情况下，代理模式可能会导致请求的处理速度变慢
3. **实现复杂**：实现代理模式需要额外的工作，有些代理模式的实现非常复杂

## 8. 与其他模式的比较

### 8.1 与适配器模式的区别
- **代理模式**：代理类和被代理类实现相同的接口，代理类控制对被代理类的访问
- **适配器模式**：适配器类将一个接口转换成另一个接口，解决接口不兼容的问题

### 8.2 与装饰器模式的区别
- **代理模式**：代理类控制对真实对象的访问，通常在使用真实对象之前或之后执行一些操作
- **装饰器模式**：装饰器类增强对象的功能，可以动态地给对象添加职责

### 8.3 与外观模式的结合
代理模式可以与外观模式结合使用：

```java
// 外观模式提供统一接口，代理模式控制访问
class DatabaseFacadeProxy implements DatabaseFacade {
    private RealDatabaseFacade realFacade;
    private boolean authorized = false;
    
    public DatabaseFacadeProxy() {
        // 根据权限决定是否创建真实对象
    }
    
    @Override
    public void executeQuery(String query) {
        if (!authorized) {
            throw new SecurityException("Access denied");
        }
        if (realFacade == null) {
            realFacade = new RealDatabaseFacade();
        }
        realFacade.executeQuery(query);
    }
}
```

## 9. 最佳实践建议

### 9.1 适用场景
1. **远程代理**：为一个对象在不同的地址空间提供局部代表
2. **虚代理**：根据需要创建开销很大的对象
3. **保护代理**：控制对原始对象的访问，用于对象应该有不同的访问权限的时候
4. **智能指引**：取代了简单的指针，在访问对象时执行一些附加操作

### 9.2 设计要点
1. **明确代理类型**：根据具体需求选择合适的代理类型
2. **保持接口一致性**：代理类应该实现与真实主题相同的接口
3. **合理控制访问**：在代理类中实现适当的访问控制逻辑

### 9.3 注意事项
1. **避免过度使用**：不是所有情况都需要代理，只有在确实需要控制访问时才使用
2. **性能考虑**：代理模式可能会带来额外的性能开销
3. **线程安全**：在多线程环境中使用代理时要注意线程安全问题

## 总结

代理模式是一种非常有用的结构型设计模式，它通过引入代理对象来控制对真实对象的访问。这种模式在很多场景下都非常有用，比如远程代理、虚拟代理、保护代理等。Spring AOP、Hibernate延迟加载等知名框架都广泛使用了代理模式。正确使用代理模式可以让系统更加灵活和可扩展，但也需要注意不要过度使用，以免增加系统复杂性。