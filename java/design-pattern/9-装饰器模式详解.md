# 第九章 装饰器模式详解

## 1. 装饰器模式概述

### 1.1 定义
装饰器模式(Decorator Pattern)是一种结构型设计模式，它允许向一个现有的对象添加新的功能，同时又不改变其结构。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

### 1.2 核心思想
装饰器模式的核心思想是"动态地给一个对象添加一些额外的职责"，相比生成子类更为灵活。它通过创建一个包装对象，也就是装饰器，来包裹真实的对象，从而在不修改原有对象的基础上扩展其功能。

## 2. 装饰器模式结构

装饰器模式包含以下角色：

1. **组件(Component)**：定义一个对象接口，可以给这些对象动态地添加职责
2. **具体组件(ConcreteComponent)**：定义一个对象，可以给这个对象添加一些职责
3. **装饰器(Decorator)**：维持一个指向Component对象的引用，并定义一个与Component接口一致的接口
4. **具体装饰器(ConcreteDecorator)**：向组件添加职责

## 3. 装饰器模式实现

### 3.1 基本实现
```java
// 组件接口 - 咖啡
interface Coffee {
    String getDescription();
    double getCost();
}

// 具体组件 - 简单咖啡
class SimpleCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "Simple coffee";
    }
    
    @Override
    public double getCost() {
        return 2.0;
    }
}

// 装饰器抽象类
abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;
    
    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription();
    }
    
    @Override
    public double getCost() {
        return coffee.getCost();
    }
}

// 具体装饰器 - 牛奶
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription() + ", milk";
    }
    
    @Override
    public double getCost() {
        return coffee.getCost() + 0.5;
    }
}

// 具体装饰器 - 糖
class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription() + ", sugar";
    }
    
    @Override
    public double getCost() {
        return coffee.getCost() + 0.3;
    }
}

// 具体装饰器 - 奶油
class WhipDecorator extends CoffeeDecorator {
    public WhipDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription() + ", whip";
    }
    
    @Override
    public double getCost() {
        return coffee.getCost() + 0.7;
    }
}
```

### 3.2 多层装饰示例
```java
// 组件接口 - 通知服务
interface Notifier {
    void send(String message);
}

// 具体组件 - 基础邮件通知
class EmailNotifier implements Notifier {
    @Override
    public void send(String message) {
        System.out.println("Sending email with message: " + message);
    }
}

// 装饰器抽象类
abstract class NotifierDecorator implements Notifier {
    protected Notifier notifier;
    
    public NotifierDecorator(Notifier notifier) {
        this.notifier = notifier;
    }
    
    @Override
    public void send(String message) {
        notifier.send(message);
    }
}

// 具体装饰器 - 短信通知
class SMSDecorator extends NotifierDecorator {
    public SMSDecorator(Notifier notifier) {
        super(notifier);
    }
    
    @Override
    public void send(String message) {
        super.send(message);
        sendSMS(message);
    }
    
    private void sendSMS(String message) {
        System.out.println("Sending SMS with message: " + message);
    }
}

// 具体装饰器 - Facebook通知
class FacebookDecorator extends NotifierDecorator {
    public FacebookDecorator(Notifier notifier) {
        super(notifier);
    }
    
    @Override
    public void send(String message) {
        super.send(message);
        sendFacebook(message);
    }
    
    private void sendFacebook(String message) {
        System.out.println("Sending Facebook message with message: " + message);
    }
}

// 具体装饰器 - Slack通知
class SlackDecorator extends NotifierDecorator {
    public SlackDecorator(Notifier notifier) {
        super(notifier);
    }
    
    @Override
    public void send(String message) {
        super.send(message);
        sendSlack(message);
    }
    
    private void sendSlack(String message) {
        System.out.println("Sending Slack message with message: " + message);
    }
}
```

## 4. 实际应用示例

### 4.1 Java I/O流中的装饰器模式
Java I/O库是装饰器模式最经典的实现之一：

```java
// FileInputStream是具体组件
// BufferedInputStream、DataInputStream等是具体装饰器

/*
// 创建一个文件输入流
FileInputStream fis = new FileInputStream("test.txt");

// 用缓冲装饰器包装
BufferedInputStream bis = new BufferedInputStream(fis);

// 用数据输入装饰器再包装
DataInputStream dis = new DataInputStream(bis);

// 现在可以读取不同类型的数据
int num = dis.readInt();
String str = dis.readUTF();
*/
```

### 4.2 Web请求处理示例
```java
// 组件接口 - 请求处理器
interface RequestHandler {
    String handle(String request);
}

// 具体组件 - 基础处理器
class BasicHandler implements RequestHandler {
    @Override
    public String handle(String request) {
        return "Basic handling: " + request;
    }
}

// 装饰器抽象类
abstract class HandlerDecorator implements RequestHandler {
    protected RequestHandler handler;
    
    public HandlerDecorator(RequestHandler handler) {
        this.handler = handler;
    }
    
    @Override
    public String handle(String request) {
        return handler.handle(request);
    }
}

// 具体装饰器 - 日志装饰器
class LoggingDecorator extends HandlerDecorator {
    public LoggingDecorator(RequestHandler handler) {
        super(handler);
    }
    
    @Override
    public String handle(String request) {
        System.out.println("LOG: Handling request: " + request);
        String result = super.handle(request);
        System.out.println("LOG: Request handled with result: " + result);
        return result;
    }
}

// 具体装饰器 - 认证装饰器
class AuthDecorator extends HandlerDecorator {
    public AuthDecorator(RequestHandler handler) {
        super(handler);
    }
    
    @Override
    public String handle(String request) {
        // 简化的认证检查
        if (!request.contains("auth_token")) {
            return "ERROR: Authentication required";
        }
        return super.handle(request);
    }
}

// 具体装饰器 - 缓存装饰器
class CacheDecorator extends HandlerDecorator {
    private Map<String, String> cache = new HashMap<>();
    
    public CacheDecorator(RequestHandler handler) {
        super(handler);
    }
    
    @Override
    public String handle(String request) {
        if (cache.containsKey(request)) {
            System.out.println("CACHE: Returning cached result for: " + request);
            return cache.get(request);
        }
        
        String result = super.handle(request);
        cache.put(request, result);
        System.out.println("CACHE: Caching result for: " + request);
        return result;
    }
}

// 具体装饰器 - 压缩装饰器
class CompressionDecorator extends HandlerDecorator {
    public CompressionDecorator(RequestHandler handler) {
        super(handler);
    }
    
    @Override
    public String handle(String request) {
        String result = super.handle(request);
        String compressed = compress(result);
        System.out.println("COMPRESS: Compressed result from " + result.length() + " to " + compressed.length() + " characters");
        return compressed;
    }
    
    private String compress(String data) {
        // 简化的压缩实现
        return data.replaceAll("\\s+", " ");
    }
}
```

### 4.3 图形界面组件示例
```java
// 组件接口 - 图形组件
interface Graphic {
    void draw();
}

// 具体组件 - 简单文本
class TextView implements Graphic {
    private String text;
    
    public TextView(String text) {
        this.text = text;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing text: " + text);
    }
}

// 具体组件 - 简单图片
class ImageView implements Graphic {
    private String imageFile;
    
    public ImageView(String imageFile) {
        this.imageFile = imageFile;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing image: " + imageFile);
    }
}

// 装饰器抽象类
abstract class GraphicDecorator implements Graphic {
    protected Graphic graphic;
    
    public GraphicDecorator(Graphic graphic) {
        this.graphic = graphic;
    }
    
    @Override
    public void draw() {
        graphic.draw();
    }
}

// 具体装饰器 - 边框装饰器
class BorderDecorator extends GraphicDecorator {
    public BorderDecorator(Graphic graphic) {
        super(graphic);
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing border");
        super.draw();
        System.out.println("Border drawn");
    }
}

// 具体装饰器 - 滚动条装饰器
class ScrollDecorator extends GraphicDecorator {
    public ScrollDecorator(Graphic graphic) {
        super(graphic);
    }
    
    @Override
    public void draw() {
        System.out.println("Adding scroll bar");
        super.draw();
        System.out.println("Scroll bar added");
    }
}

// 具体装饰器 - 颜色装饰器
class ColorDecorator extends GraphicDecorator {
    private String color;
    
    public ColorDecorator(Graphic graphic, String color) {
        super(graphic);
        this.color = color;
    }
    
    @Override
    public void draw() {
        System.out.println("Setting color to " + color);
        super.draw();
        System.out.println("Color " + color + " applied");
    }
}
```

## 5. 开源框架中的应用

### 5.1 Spring框架中的装饰器模式
Spring框架中的AOP(面向切面编程)大量使用了装饰器模式的思想：

```java
// Spring AOP代理就是装饰器模式的体现
// 原始Bean被代理对象装饰，添加了事务、安全等横切关注点

/*
@Service
@Transactional  // 装饰器：添加事务功能
@Secured        // 装饰器：添加安全功能
public class UserService {
    public void saveUser(User user) {
        // 业务逻辑
    }
}
*/
```

### 5.2 Servlet Filter中的装饰器模式
Servlet规范中的Filter也是装饰器模式的应用：

```java
// Filter装饰HttpServletRequest和HttpServletResponse
/*
public class LoggingFilter implements Filter {
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        // 装饰原始请求和响应对象
        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse res = (HttpServletResponse) response;
        
        // 添加日志功能
        System.out.println("Request received: " + req.getRequestURI());
        
        // 继续处理链
        chain.doFilter(request, response);
        
        System.out.println("Response sent");
    }
}
*/
```

## 6. 优缺点分析

### 6.1 优点
1. **扩展性强**：比继承更加灵活，可以在运行时动态地给对象添加或撤销功能
2. **符合开闭原则**：可以通过装饰类来扩展对象的功能，而无需修改原始类的代码
3. **组合代替继承**：可以使用多个装饰器来装饰同一个对象，创造出不同行为的组合
4. **单一职责原则**：每个装饰类只负责一个特定的功能，职责清晰

### 6.2 缺点
1. **产生很多小对象**：大量使用装饰器会产生许多细粒度的对象，增加系统复杂性
2. **调试困难**：由于多层次的装饰，调试时可能难以定位问题所在
3. **容易出错**：对于初次接触的开发者来说，理解和正确使用装饰器模式有一定难度

## 7. 与其他模式的比较

### 7.1 与适配器模式的区别
- **装饰器模式**：不改变接口，但添加责任
- **适配器模式**：改变接口以匹配客户端需求

### 7.2 与代理模式的区别
- **装饰器模式**：目的是增强对象的功能
- **代理模式**：目的是控制对对象的访问

### 7.3 与策略模式的区别
- **装饰器模式**：扩展对象的行为，保持原有接口
- **策略模式**：定义一系列算法，封装起来并使它们可以互相替换

## 8. 最佳实践建议

### 8.1 适用场景
1. 需要动态地给一个对象添加功能，这些功能也可以动态地撤销
2. 不适合使用继承来扩展功能的情况
3. 当不能采用生成子类的方法进行扩充时
4. 系统中存在大量独立的扩展，每种组合都可能用到

### 8.2 设计要点
1. **保持接口一致性**：装饰器和被装饰的组件必须实现相同的接口
2. **透明性**：客户端应该能够以统一的方式使用装饰器和原始对象
3. **组合优于继承**：通过组合而非继承来实现功能扩展
4. **职责分离**：每个装饰器应该只负责一项特定的功能

### 8.3 注意事项
1. **避免过度使用**：不要为了使用模式而使用模式，只有在确实需要动态添加功能时才使用
2. **注意性能影响**：多层装饰可能会影响性能，特别是在频繁调用的情况下
3. **简化客户端代码**：提供工厂方法或建造者模式来简化装饰器的创建过程

## 总结

装饰器模式是一种强大的结构型设计模式，它提供了一种比继承更加灵活的方式来扩展对象的功能。通过将对象包装在装饰器对象中，我们可以在运行时动态地添加新功能，而不会影响其他对象。这种模式在Java I/O库、Web框架和其他许多场景中都有广泛应用。正确使用装饰器模式可以大大提高代码的灵活性和可维护性，但也要注意避免过度设计和性能问题。