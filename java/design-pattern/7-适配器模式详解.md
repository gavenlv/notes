# 第七章 适配器模式详解

## 1. 适配器模式概述

### 1.1 定义
适配器模式(Adapter Pattern)是一种结构型设计模式，它允许不兼容的接口协同工作。适配器模式将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

### 1.2 核心思想
适配器模式的核心思想是"转换"，即通过增加一个适配器类来解决接口不兼容的问题，无需修改原有类的代码。

## 2. 适配器模式结构

适配器模式包含以下角色：

1. **目标接口(Target)**：客户端期望的接口
2. **适配者类(Adaptee)**：需要被适配的类，通常是一个已存在的类
3. **适配器类(Adapter)**：连接目标接口和适配者类的桥梁
4. **客户端(Client)**：使用目标接口的类

## 3. 适配器模式实现

### 3.1 类适配器模式
类适配器通过继承来实现适配，适配器类同时继承适配者类并实现目标接口。

```java
// 目标接口
interface MediaPlayer {
    void play(String audioType, String fileName);
}

// 高级媒体播放器接口
interface AdvancedMediaPlayer {
    void playVlc(String fileName);
    void playMp4(String fileName);
}

// 适配者类 - VLC播放器
class VlcPlayer implements AdvancedMediaPlayer {
    @Override
    public void playVlc(String fileName) {
        System.out.println("Playing vlc file. Name: " + fileName);
    }
    
    @Override
    public void playMp4(String fileName) {
        // 不支持MP4格式
    }
}

// 适配者类 - MP4播放器
class Mp4Player implements AdvancedMediaPlayer {
    @Override
    public void playVlc(String fileName) {
        // 不支持VLC格式
    }
    
    @Override
    public void playMp4(String fileName) {
        System.out.println("Playing mp4 file. Name: " + fileName);
    }
}

// 类适配器 - 继承适配者类并实现目标接口
class MediaAdapter extends VlcPlayer implements MediaPlayer {
    AdvancedMediaPlayer advancedMusicPlayer;
    
    public MediaAdapter(String audioType) {
        if (audioType.equalsIgnoreCase("vlc")) {
            advancedMusicPlayer = new VlcPlayer();
        } else if (audioType.equalsIgnoreCase("mp4")) {
            advancedMusicPlayer = new Mp4Player();
        }
    }
    
    @Override
    public void play(String audioType, String fileName) {
        if (audioType.equalsIgnoreCase("vlc")) {
            advancedMusicPlayer.playVlc(fileName);
        } else if (audioType.equalsIgnoreCase("mp4")) {
            advancedMusicPlayer.playMp4(fileName);
        }
    }
}

// 客户端类
class AudioPlayer implements MediaPlayer {
    MediaAdapter mediaAdapter;
    
    @Override
    public void play(String audioType, String fileName) {
        // 播放mp3音乐文件的内置支持
        if (audioType.equalsIgnoreCase("mp3")) {
            System.out.println("Playing mp3 file. Name: " + fileName);
        }
        // mediaAdapter提供了播放其他文件格式的支持
        else if (audioType.equalsIgnoreCase("vlc") || audioType.equalsIgnoreCase("mp4")) {
            mediaAdapter = new MediaAdapter(audioType);
            mediaAdapter.play(audioType, fileName);
        } else {
            System.out.println("Invalid media. " + audioType + " format not supported");
        }
    }
}
```

### 3.2 对象适配器模式
对象适配器通过组合/聚合来实现适配，适配器类持有适配者类的实例。

```java
// 对象适配器 - 持有适配者类的实例
class MediaAdapterObject implements MediaPlayer {
    AdvancedMediaPlayer advancedMusicPlayer;
    
    public MediaAdapterObject(String audioType) {
        if (audioType.equalsIgnoreCase("vlc")) {
            advancedMusicPlayer = new VlcPlayer();
        } else if (audioType.equalsIgnoreCase("mp4")) {
            advancedMusicPlayer = new Mp4Player();
        }
    }
    
    @Override
    public void play(String audioType, String fileName) {
        if (audioType.equalsIgnoreCase("vlc")) {
            advancedMusicPlayer.playVlc(fileName);
        } else if (audioType.equalsIgnoreCase("mp4")) {
            advancedMusicPlayer.playMp4(fileName);
        }
    }
}

// 使用对象适配器的音频播放器
class AudioPlayerWithObjectAdapter implements MediaPlayer {
    MediaAdapterObject mediaAdapter;
    
    @Override
    public void play(String audioType, String fileName) {
        // 播放mp3音乐文件的内置支持
        if (audioType.equalsIgnoreCase("mp3")) {
            System.out.println("Playing mp3 file. Name: " + fileName);
        }
        // mediaAdapter提供了播放其他文件格式的支持
        else if (audioType.equalsIgnoreCase("vlc") || audioType.equalsIgnoreCase("mp4")) {
            mediaAdapter = new MediaAdapterObject(audioType);
            mediaAdapter.play(audioType, fileName);
        } else {
            System.out.println("Invalid media. " + audioType + " format not supported");
        }
    }
}
```

### 3.3 接口适配器模式
接口适配器用于解决接口中定义的方法过多，但实现类只需要其中部分方法的情况。

```java
// 定义一个多功能接口
interface RobotActions {
    void walk();
    void talk();
    void grab();
    void sense();
    void compute();
}

// 接口适配器 - 提供默认空实现
abstract class RobotAdapter implements RobotActions {
    @Override
    public void walk() {}
    
    @Override
    public void talk() {}
    
    @Override
    public void grab() {}
    
    @Override
    public void sense() {}
    
    @Override
    public void compute() {}
}

// 具体机器人 - 只需要行走和感知功能
class SimpleRobot extends RobotAdapter {
    @Override
    public void walk() {
        System.out.println("Simple robot is walking");
    }
    
    @Override
    public void sense() {
        System.out.println("Simple robot is sensing environment");
    }
}

// 复杂机器人 - 需要所有功能
class AdvancedRobot extends RobotAdapter {
    @Override
    public void walk() {
        System.out.println("Advanced robot is walking");
    }
    
    @Override
    public void talk() {
        System.out.println("Advanced robot is talking");
    }
    
    @Override
    public void grab() {
        System.out.println("Advanced robot is grabbing objects");
    }
    
    @Override
    public void sense() {
        System.out.println("Advanced robot is sensing environment");
    }
    
    @Override
    public void compute() {
        System.out.println("Advanced robot is computing");
    }
}
```

## 4. 实际应用示例

### 4.1 电源适配器示例
```java
// 目标接口 - 中国标准插座
interface ChinaSocket {
    void provideElectricity();
}

// 适配者类 - 美国插座
class USSocket {
    public void provideElectricity110V() {
        System.out.println("提供110V电压");
    }
}

// 适配器 - 电源适配器
class PowerAdapter implements ChinaSocket {
    private USSocket usSocket;
    
    public PowerAdapter(USSocket usSocket) {
        this.usSocket = usSocket;
    }
    
    @Override
    public void provideElectricity() {
        System.out.print("电源适配器转换: ");
        usSocket.provideElectricity110V();
        System.out.println("转换为220V电压");
    }
}

// 中国电器
class ChinaDevice {
    public void charge(ChinaSocket socket) {
        System.out.print("中国电器充电中... ");
        socket.provideElectricity();
    }
}
```

### 4.2 数据库驱动适配器示例
```java
// 目标接口 - 统一数据库操作接口
interface DatabaseDriver {
    void connect();
    void executeQuery(String sql);
    void close();
}

// 适配者类 - MySQL驱动
class MySQLDriver {
    public void mysqlConnect() {
        System.out.println("连接MySQL数据库");
    }
    
    public void mysqlExecute(String sql) {
        System.out.println("MySQL执行SQL: " + sql);
    }
    
    public void mysqlClose() {
        System.out.println("关闭MySQL连接");
    }
}

// 适配者类 - PostgreSQL驱动
class PostgreSQLDriver {
    public void pgConnect() {
        System.out.println("连接PostgreSQL数据库");
    }
    
    public void pgExecute(String sql) {
        System.out.println("PostgreSQL执行SQL: " + sql);
    }
    
    public void pgClose() {
        System.out.println("关闭PostgreSQL连接");
    }
}

// MySQL适配器
class MySQLAdapter implements DatabaseDriver {
    private MySQLDriver mySQLDriver;
    
    public MySQLAdapter() {
        this.mySQLDriver = new MySQLDriver();
    }
    
    @Override
    public void connect() {
        mySQLDriver.mysqlConnect();
    }
    
    @Override
    public void executeQuery(String sql) {
        mySQLDriver.mysqlExecute(sql);
    }
    
    @Override
    public void close() {
        mySQLDriver.mysqlClose();
    }
}

// PostgreSQL适配器
class PostgreSQLAdapter implements DatabaseDriver {
    private PostgreSQLDriver postgreSQLDriver;
    
    public PostgreSQLAdapter() {
        this.postgreSQLDriver = new PostgreSQLDriver();
    }
    
    @Override
    public void connect() {
        postgreSQLDriver.pgConnect();
    }
    
    @Override
    public void executeQuery(String sql) {
        postgreSQLDriver.pgExecute(sql);
    }
    
    @Override
    public void close() {
        postgreSQLDriver.pgClose();
    }
}
```

## 5. 开源框架中的应用

### 5.1 Spring框架中的适配器模式
Spring MVC中的HandlerAdapter就是典型的适配器模式应用：

```java
// HandlerAdapter接口
interface HandlerAdapter {
    boolean supports(Object handler);
    ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;
}

// 具体的适配器实现
class SimpleControllerHandlerAdapter implements HandlerAdapter {
    public boolean supports(Object handler) {
        return (handler instanceof Controller);
    }
    
    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        return ((Controller) handler).handleRequest(request, response);
    }
}

// 另一个适配器实现
class HttpRequestHandlerAdapter implements HandlerAdapter {
    public boolean supports(Object handler) {
        return (handler instanceof HttpRequestHandler);
    }
    
    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        ((HttpRequestHandler) handler).handleRequest(request, response);
        return null;
    }
}
```

### 5.2 日志框架中的适配器模式
SLF4J作为日志门面，通过适配器模式适配各种具体的日志实现：

```java
// SLF4J的Logger接口 - 目标接口
interface Logger {
    void info(String msg);
    void error(String msg);
    void debug(String msg);
}

// Log4j的具体实现 - 适配者
class Log4jLogger {
    public void logInfo(String msg) {
        System.out.println("[Log4j INFO] " + msg);
    }
    
    public void logError(String msg) {
        System.err.println("[Log4j ERROR] " + msg);
    }
    
    public void logDebug(String msg) {
        System.out.println("[Log4j DEBUG] " + msg);
    }
}

// Log4j适配器
class Log4jAdapter implements Logger {
    private Log4jLogger log4jLogger;
    
    public Log4jAdapter() {
        this.log4jLogger = new Log4jLogger();
    }
    
    @Override
    public void info(String msg) {
        log4jLogger.logInfo(msg);
    }
    
    @Override
    public void error(String msg) {
        log4jLogger.logError(msg);
    }
    
    @Override
    public void debug(String msg) {
        log4jLogger.logDebug(msg);
    }
}
```

## 6. 优缺点分析

### 6.1 优点
1. **单一职责原则**：将接口转换逻辑封装在适配器中，符合单一职责原则
2. **开闭原则**：无需修改原有代码即可增加新的适配器
3. **提高复用性**：可以让任何两个不相关的类一起运行
4. **灵活性好**：可以灵活地替换适配器或添加新的适配器

### 6.2 缺点
1. **增加复杂度**：引入适配器会增加系统的复杂性
2. **性能损耗**：适配过程可能存在一定的性能损耗
3. **额外对象**：需要额外编写适配器类，增加代码量

## 7. 与其他模式的比较

### 7.1 与装饰器模式的区别
- **适配器模式**：改变接口以匹配客户端需求
- **装饰器模式**：保持接口不变，增强对象的功能

### 7.2 与代理模式的区别
- **适配器模式**：解决接口不兼容问题
- **代理模式**：控制对对象的访问，可能延迟创建或添加额外处理

### 7.3 与外观模式的区别
- **适配器模式**：使不同接口能够协同工作
- **外观模式**：为复杂的子系统提供简化的统一接口

## 8. 最佳实践建议

### 8.1 适用场景
1. 系统需要使用现有的类，但其接口不符合需求
2. 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的类协同工作
3. 需要在多个不同的数据库系统之间切换，但不想修改现有代码

### 8.2 设计要点
1. **明确角色划分**：清晰区分目标接口、适配者和适配器的角色
2. **选择合适的适配器类型**：根据具体情况选择类适配器或对象适配器
3. **避免过度设计**：不要为了使用适配器而强行创造适配场景

### 8.3 注意事项
1. **适配器不应改变业务逻辑**：适配器只负责接口转换，不应改变原有的业务逻辑
2. **考虑性能影响**：过多的适配层可能会影响系统性能
3. **文档说明**：对于复杂的适配关系，应提供清晰的文档说明

## 总结

适配器模式是一种非常实用的设计模式，特别适用于集成第三方库或遗留系统。通过适配器模式，我们可以让原本不兼容的接口协同工作，提高了系统的灵活性和可扩展性。在实际开发中，适配器模式经常被用来解决接口不匹配的问题，是结构型设计模式中的重要成员。