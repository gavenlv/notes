# 第6章 原型模式详解

## 6.1 原型模式概述

### 6.1.1 定义

原型模式（Prototype Pattern）是一种创建型设计模式，它允许你通过复制现有实例来创建新的实例，而无需知道其具体类。原型模式通过给出一个原型对象来指明所要创建的对象类型，然后用复制这个原型对象的办法创建出更多同类型的对象。

### 6.1.2 特点

1. 通过复制现有对象实例来创建新对象
2. 无需知道对象的具体类即可创建对象
3. 提高性能，避免重复初始化过程
4. 简化对象创建过程，特别是当创建过程比较复杂时

### 6.1.3 应用场景

1. 当一个系统应该独立于它的产品创建、构成和表示时
2. 当要实例化的类是在运行时刻指定时，例如通过动态装载
3. 为了避免创建一个与产品类层次平行的工厂类层次时
4. 当一个类的实例只能有几个不同状态组合中的一种时

## 6.2 原型模式的结构

原型模式包含以下角色：

1. **抽象原型（Prototype）**：声明克隆自身的接口
2. **具体原型（ConcretePrototype）**：实现克隆自身的操作
3. **客户端（Client）**：让一个原型克隆自身从而创建一个新的对象

## 6.3 原型模式的实现

### 6.3.1 基本实现

让我们通过一个简单的例子来理解原型模式：

```java
// 抽象原型类
interface Prototype {
    Prototype clone();
}

// 具体原型类
class Sheep implements Prototype {
    private String name;
    private String color;
    private int age;
    
    public Sheep(String name, String color, int age) {
        this.name = name;
        this.color = color;
        this.age = age;
    }
    
    // 实现克隆方法
    @Override
    public Prototype clone() {
        return new Sheep(this.name, this.color, this.age);
    }
    
    // Getter和Setter方法
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getColor() { return color; }
    public void setColor(String color) { this.color = color; }
    
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
    
    @Override
    public String toString() {
        return "Sheep{name='" + name + "', color='" + color + "', age=" + age + "}";
    }
}
```

### 6.3.2 使用Java内置Cloneable接口

Java提供了Cloneable接口和clone()方法来支持原型模式：

```java
// 使用Java内置Cloneable接口的原型模式
class Employee implements Cloneable {
    private String name;
    private int age;
    private String department;
    private Address address; // 引用类型字段
    
    public Employee(String name, int age, String department) {
        this.name = name;
        this.age = age;
        this.department = department;
        this.address = new Address(); // 初始化地址
    }
    
    // 深拷贝实现
    @Override
    protected Object clone() throws CloneNotSupportedException {
        Employee cloned = (Employee) super.clone();
        // 对引用类型进行深拷贝
        cloned.address = (Address) this.address.clone();
        return cloned;
    }
    
    // 浅拷贝实现
    public Employee shallowCopy() throws CloneNotSupportedException {
        return (Employee) super.clone();
    }
    
    // Getter和Setter方法
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
    
    public String getDepartment() { return department; }
    public void setDepartment(String department) { this.department = department; }
    
    public Address getAddress() { return address; }
    public void setAddress(Address address) { this.address = address; }
    
    @Override
    public String toString() {
        return "Employee{name='" + name + "', age=" + age + 
               ", department='" + department + "', address=" + address + "}";
    }
}

// 地址类
class Address implements Cloneable {
    private String street;
    private String city;
    private String zipCode;
    
    public Address() {
        this.street = "";
        this.city = "";
        this.zipCode = "";
    }
    
    public Address(String street, String city, String zipCode) {
        this.street = street;
        this.city = city;
        this.zipCode = zipCode;
    }
    
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
    
    // Getter和Setter方法
    public String getStreet() { return street; }
    public void setStreet(String street) { this.street = street; }
    
    public String getCity() { return city; }
    public void setCity(String city) { this.city = city; }
    
    public String getZipCode() { return zipCode; }
    public void setZipCode(String zipCode) { this.zipCode = zipCode; }
    
    @Override
    public String toString() {
        return "Address{street='" + street + "', city='" + city + "', zipCode='" + zipCode + "'}";
    }
}
```

### 6.3.3 原型管理器

为了更好地管理原型对象，我们可以创建一个原型管理器：

```java
import java.util.HashMap;
import java.util.Map;

// 原型管理器
class PrototypeManager {
    private Map<String, Prototype> prototypes = new HashMap<>();
    
    // 注册原型
    public void registerPrototype(String key, Prototype prototype) {
        prototypes.put(key, prototype);
    }
    
    // 获取原型并克隆
    public Prototype createPrototype(String key) {
        Prototype prototype = prototypes.get(key);
        if (prototype != null) {
            return prototype.clone();
        }
        return null;
    }
    
    // 取消注册
    public void unregisterPrototype(String key) {
        prototypes.remove(key);
    }
    
    // 获取所有注册的原型键
    public String[] getPrototypeKeys() {
        return prototypes.keySet().toArray(new String[0]);
    }
}
```

## 6.4 原型模式的实际应用

### 6.4.1 图形编辑器示例

```java
// 图形接口
interface Shape extends Cloneable {
    void draw();
    Shape clone();
    String getType();
}

// 具体图形类 - 矩形
class Rectangle implements Shape {
    private int width;
    private int height;
    private String color;
    
    public Rectangle() {
        this.width = 0;
        this.height = 0;
        this.color = "white";
    }
    
    public Rectangle(Rectangle rectangle) {
        this.width = rectangle.width;
        this.height = rectangle.height;
        this.color = rectangle.color;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing Rectangle[width=" + width + ", height=" + height + ", color=" + color + "]");
    }
    
    @Override
    public Shape clone() {
        return new Rectangle(this);
    }
    
    @Override
    public String getType() {
        return "Rectangle";
    }
    
    // Getter和Setter方法
    public int getWidth() { return width; }
    public void setWidth(int width) { this.width = width; }
    
    public int getHeight() { return height; }
    public void setHeight(int height) { this.height = height; }
    
    public String getColor() { return color; }
    public void setColor(String color) { this.color = color; }
}

// 具体图形类 - 圆形
class Circle implements Shape {
    private int radius;
    private String color;
    
    public Circle() {
        this.radius = 0;
        this.color = "white";
    }
    
    public Circle(Circle circle) {
        this.radius = circle.radius;
        this.color = circle.color;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing Circle[radius=" + radius + ", color=" + color + "]");
    }
    
    @Override
    public Shape clone() {
        return new Circle(this);
    }
    
    @Override
    public String getType() {
        return "Circle";
    }
    
    // Getter和Setter方法
    public int getRadius() { return radius; }
    public void setRadius(int radius) { this.radius = radius; }
    
    public String getColor() { return color; }
    public void setColor(String color) { this.color = color; }
}
```

### 6.4.2 文档模板系统

```java
// 文档模板类
class DocumentTemplate implements Cloneable {
    private String title;
    private String content;
    private String author;
    private String[] tags;
    
    public DocumentTemplate(String title, String content, String author, String[] tags) {
        this.title = title;
        this.content = content;
        this.author = author;
        this.tags = tags != null ? tags.clone() : new String[0];
    }
    
    // 深拷贝实现
    @Override
    protected Object clone() throws CloneNotSupportedException {
        DocumentTemplate cloned = (DocumentTemplate) super.clone();
        // 对数组进行深拷贝
        cloned.tags = this.tags != null ? this.tags.clone() : null;
        return cloned;
    }
    
    // 创建基于模板的新文档
    public DocumentTemplate createNewDocument(String newTitle, String newAuthor) {
        try {
            DocumentTemplate newDoc = (DocumentTemplate) this.clone();
            newDoc.setTitle(newTitle);
            newDoc.setAuthor(newAuthor);
            return newDoc;
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("无法克隆文档模板", e);
        }
    }
    
    // Getter和Setter方法
    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }
    
    public String getContent() { return content; }
    public void setContent(String content) { this.content = content; }
    
    public String getAuthor() { return author; }
    public void setAuthor(String author) { this.author = author; }
    
    public String[] getTags() { return tags != null ? tags.clone() : null; }
    public void setTags(String[] tags) { this.tags = tags != null ? tags.clone() : null; }
    
    @Override
    public String toString() {
        return "DocumentTemplate{title='" + title + "', author='" + author + 
               "', tags=" + java.util.Arrays.toString(tags) + "}";
    }
}
```

## 6.5 原型模式在开源框架中的应用

### 6.5.1 Spring框架中的应用

Spring框架中的Bean作用域为prototype就是原型模式的应用：

```java
// Spring中的原型Bean示例（伪代码）
/*
@Configuration
public class AppConfig {
    @Bean
    @Scope("prototype")  // 原型作用域
    public MyService myService() {
        return new MyService();
    }
}

// 每次从Spring容器获取时都会创建新的实例
MyService service1 = applicationContext.getBean(MyService.class);
MyService service2 = applicationContext.getBean(MyService.class);
// service1 和 service2 是不同的实例
*/
```

### 6.5.2 Java标准库中的应用

Java标准库中的许多类都实现了Cloneable接口：

```java
// ArrayList的clone方法示例
/*
ArrayList<String> originalList = new ArrayList<>();
originalList.add("item1");
originalList.add("item2");

// 浅拷贝
ArrayList<String> clonedList = (ArrayList<String>) originalList.clone();
// clonedList 包含与 originalList 相同的元素
*/
```

## 6.6 浅拷贝与深拷贝

### 6.6.1 浅拷贝

浅拷贝只复制对象本身和对象中的基本数据类型字段，而不复制对象中的引用类型字段。引用类型字段仍然指向原来的对象。

### 6.6.2 深拷贝

深拷贝不仅复制对象本身，还复制对象中的所有引用类型字段，使得新对象与原对象完全独立。

```java
// 深拷贝示例
class Department implements Cloneable {
    private String name;
    private Employee[] employees;
    
    public Department(String name, Employee[] employees) {
        this.name = name;
        this.employees = employees != null ? employees.clone() : new Employee[0];
    }
    
    // 深拷贝实现
    @Override
    protected Object clone() throws CloneNotSupportedException {
        Department cloned = (Department) super.clone();
        // 对员工数组进行深拷贝
        if (this.employees != null) {
            cloned.employees = new Employee[this.employees.length];
            for (int i = 0; i < this.employees.length; i++) {
                cloned.employees[i] = (Employee) this.employees[i].clone();
            }
        }
        return cloned;
    }
    
    // Getter方法
    public String getName() { return name; }
    public Employee[] getEmployees() { 
        return employees != null ? employees.clone() : null; 
    }
    
    @Override
    public String toString() {
        return "Department{name='" + name + "', employeesCount=" + 
               (employees != null ? employees.length : 0) + "}";
    }
}
```

## 6.7 原型模式的优缺点

### 6.7.1 优点

1. **性能提升**：对于创建复杂对象，原型模式比直接new一个对象性能要好
2. **逃避构造函数的约束**：可以直接复制现有对象的状态，无需调用构造函数
3. **简化对象创建**：隐藏了对象创建的细节，客户端只需要知道原型即可
4. **动态配置**：可以在运行时动态增加或减少产品类

### 6.7.2 缺点

1. **深拷贝实现复杂**：对于包含引用类型的对象，需要正确实现深拷贝
2. **违背开闭原则**：需要为每一个类配备一个克隆方法
3. **可能产生不可预知的结果**：如果对象内部包含循环引用或其他复杂结构

## 6.8 原型模式与其他创建型模式的比较

| 比较项 | 原型模式 | 工厂方法模式 | 抽象工厂模式 | 建造者模式 |
|--------|----------|-------------|-------------|-----------|
| 创建方式 | 复制现有对象 | 子类决定实例化哪个类 | 创建产品族 | 分步骤构建复杂对象 |
| 性能 | 高（避免构造函数） | 中等 | 中等 | 低（步骤多） |
| 适用场景 | 复杂对象的复制 | 单一产品创建 | 产品族创建 | 复杂对象构建 |

## 6.9 最佳实践建议

1. **正确实现深拷贝**：对于包含引用类型的对象，要确保正确实现深拷贝
2. **异常处理**：处理CloneNotSupportedException异常
3. **原型管理**：使用原型管理器来统一管理原型对象
4. **文档说明**：明确说明哪些字段是浅拷贝，哪些是深拷贝

## 6.10 本章小结

本章详细介绍了原型模式的概念、结构、实现方式以及应用场景。原型模式通过复制现有对象来创建新对象，可以提高性能并简化对象创建过程。在实际开发中，原型模式常用于需要频繁创建相似对象的场景，特别是在对象创建成本较高的情况下。

下一章我们将介绍适配器模式，它是一种结构型模式，用于解决接口不兼容的问题。