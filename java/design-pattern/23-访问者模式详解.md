# 第二十三章 访问者模式详解

## 本章概要
- 访问者模式的定义和概念
- 访问者模式的结构和组成
- 访问者模式的实现方式
- 实际应用场景分析
- 开源框架中的应用
- 访问者模式的优缺点
- 与其他设计模式的比较
- 最佳实践和注意事项

## 访问者模式概述

访问者模式（Visitor Pattern）是一种行为型设计模式，它允许在不改变元素类的前提下，为元素类添加新的操作。通过访问者模式，可以将相关的操作集中到一个访问者对象中，从而分离对象结构和操作。

### 核心思想
访问者模式的核心思想是将数据结构与数据操作分离。它允许你在不修改已有元素类的情况下，为元素类添加新的操作。访问者模式将有关行为集中到一个访问者对象中，而不是分散在一个个的元素类中。

### 应用场景
1. **对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作**
2. **需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类**
3. **当被操作的对象结构比较稳定，不会经常发生变化，而操作却经常变化时**
4. **当需要对一个复杂的对象结构进行遍历时，可以使用访问者模式来封装遍历算法**
5. **当需要对不同类型的对象执行不同的操作，而且操作之间没有关联时**

## 访问者模式结构

访问者模式包含以下角色：
1. **Visitor（访问者）**：为对象结构中每一个ConcreteElement声明一个visit操作
2. **ConcreteVisitor（具体访问者）**：实现每个由Visitor声明的操作，每个操作实现算法的一部分，而该算法片段乃是对应于结构中对象的类
3. **Element（元素）**：定义一个accept方法，它以一个访问者为参数
4. **ConcreteElement（具体元素）**：实现accept方法，通过调用访问者的visit方法来实现对元素的访问
5. **ObjectStructure（对象结构）**：能枚举它的元素，同时提供一个高层的接口以允许访问者访问它的元素

## 访问者模式实现

### 基本实现

```java
// 访问者接口
interface Visitor {
    void visit(ConcreteElementA element);
    void visit(ConcreteElementB element);
}

// 具体访问者 - 显示访问者
class ConcreteVisitor1 implements Visitor {
    @Override
    public void visit(ConcreteElementA element) {
        System.out.println("ConcreteVisitor1 访问 " + element.operationA());
    }
    
    @Override
    public void visit(ConcreteElementB element) {
        System.out.println("ConcreteVisitor1 访问 " + element.operationB());
    }
}

// 具体访问者 - 执行访问者
class ConcreteVisitor2 implements Visitor {
    @Override
    public void visit(ConcreteElementA element) {
        System.out.println("ConcreteVisitor2 访问 " + element.operationA());
    }
    
    @Override
    public void visit(ConcreteElementB element) {
        System.out.println("ConcreteVisitor2 访问 " + element.operationB());
    }
}

// 元素接口
interface Element {
    void accept(Visitor visitor);
}

// 具体元素A
class ConcreteElementA implements Element {
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
    
    public String operationA() {
        return "ConcreteElementA 的操作";
    }
}

// 具体元素B
class ConcreteElementB implements Element {
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
    
    public String operationB() {
        return "ConcreteElementB 的操作";
    }
}
```

### 更复杂的实现示例

让我们通过一个文档编辑器的例子来展示更复杂的实现。

## 实际应用示例

### 1. 文档编辑器

```java
// 访问者接口
interface DocumentVisitor {
    void visit(TextElement text);
    void visit(ImageElement image);
    void visit(TableElement table);
}

// 具体访问者 - 导出为HTML
class HtmlExportVisitor implements DocumentVisitor {
    @Override
    public void visit(TextElement text) {
        System.out.println("<p>" + text.getContent() + "</p>");
    }
    
    @Override
    public void visit(ImageElement image) {
        System.out.println("<img src=\"" + image.getSource() + "\" alt=\"" + image.getCaption() + "\">");
    }
    
    @Override
    public void visit(TableElement table) {
        System.out.println("<table>");
        for (String row : table.getRows()) {
            System.out.println("  <tr><td>" + row + "</td></tr>");
        }
        System.out.println("</table>");
    }
}

// 具体访问者 - 导出为纯文本
class PlainTextExportVisitor implements DocumentVisitor {
    @Override
    public void visit(TextElement text) {
        System.out.println(text.getContent());
    }
    
    @Override
    public void visit(ImageElement image) {
        System.out.println("[图片: " + image.getCaption() + "]");
    }
    
    @Override
    public void visit(TableElement table) {
        System.out.println("表格:");
        for (String row : table.getRows()) {
            System.out.println("  " + row);
        }
    }
}

// 具体访问者 - 统计字数
class WordCountVisitor implements DocumentVisitor {
    private int wordCount = 0;
    
    @Override
    public void visit(TextElement text) {
        wordCount += text.getContent().split("\\s+").length;
    }
    
    @Override
    public void visit(ImageElement image) {
        // 图片不计算字数
    }
    
    @Override
    public void visit(TableElement table) {
        for (String row : table.getRows()) {
            wordCount += row.split("\\s+").length;
        }
    }
    
    public int getWordCount() {
        return wordCount;
    }
}

// 文档元素接口
interface DocumentElement {
    void accept(DocumentVisitor visitor);
}

// 文本元素
class TextElement implements DocumentElement {
    private String content;
    
    public TextElement(String content) {
        this.content = content;
    }
    
    @Override
    public void accept(DocumentVisitor visitor) {
        visitor.visit(this);
    }
    
    public String getContent() {
        return content;
    }
}

// 图片元素
class ImageElement implements DocumentElement {
    private String source;
    private String caption;
    
    public ImageElement(String source, String caption) {
        this.source = source;
        this.caption = caption;
    }
    
    @Override
    public void accept(DocumentVisitor visitor) {
        visitor.visit(this);
    }
    
    public String getSource() {
        return source;
    }
    
    public String getCaption() {
        return caption;
    }
}

// 表格元素
class TableElement implements DocumentElement {
    private List<String> rows;
    
    public TableElement(List<String> rows) {
        this.rows = new ArrayList<>(rows);
    }
    
    @Override
    public void accept(DocumentVisitor visitor) {
        visitor.visit(this);
    }
    
    public List<String> getRows() {
        return new ArrayList<>(rows);
    }
}

// 文档类 - 对象结构
class Document {
    private List<DocumentElement> elements = new ArrayList<>();
    
    public void addElement(DocumentElement element) {
        elements.add(element);
    }
    
    public void removeElement(DocumentElement element) {
        elements.remove(element);
    }
    
    public void accept(DocumentVisitor visitor) {
        for (DocumentElement element : elements) {
            element.accept(visitor);
        }
    }
}
```

### 2. 电商平台商品系统

```java
// 访问者接口
interface ShoppingCartVisitor {
    double visit(Book book);
    double visit(Fruit fruit);
    double visit(Electronics electronics);
}

// 具体访问者 - 普通客户价格计算
class RegularCustomerVisitor implements ShoppingCartVisitor {
    @Override
    public double visit(Book book) {
        double cost = book.getPrice();
        // 普通客户书籍打9折
        if (book.getPrice() > 50) {
            cost *= 0.9;
        }
        System.out.println("书籍: " + book.getName() + ", 原价: " + book.getPrice() + ", 折扣价: " + cost);
        return cost;
    }
    
    @Override
    public double visit(Fruit fruit) {
        double cost = fruit.getPricePerKg() * fruit.getWeight();
        System.out.println("水果: " + fruit.getName() + ", 重量: " + fruit.getWeight() + "kg, 总价: " + cost);
        return cost;
    }
    
    @Override
    public double visit(Electronics electronics) {
        double cost = electronics.getPrice();
        // 普通客户电子产品打9.5折
        cost *= 0.95;
        System.out.println("电子产品: " + electronics.getName() + ", 原价: " + electronics.getPrice() + ", 折扣价: " + cost);
        return cost;
    }
}

// 具体访问者 - VIP客户价格计算
class VIPCustomerVisitor implements ShoppingCartVisitor {
    @Override
    public double visit(Book book) {
        double cost = book.getPrice();
        // VIP客户书籍打8折
        cost *= 0.8;
        System.out.println("书籍: " + book.getName() + ", 原价: " + book.getPrice() + ", VIP价: " + cost);
        return cost;
    }
    
    @Override
    public double visit(Fruit fruit) {
        double cost = fruit.getPricePerKg() * fruit.getWeight();
        // VIP客户水果打9折
        cost *= 0.9;
        System.out.println("水果: " + fruit.getName() + ", 重量: " + fruit.getWeight() + "kg, VIP价: " + cost);
        return cost;
    }
    
    @Override
    public double visit(Electronics electronics) {
        double cost = electronics.getPrice();
        // VIP客户电子产品打8.5折
        cost *= 0.85;
        System.out.println("电子产品: " + electronics.getName() + ", 原价: " + electronics.getPrice() + ", VIP价: " + cost);
        return cost;
    }
}

// 商品接口
interface ItemElement {
    double accept(ShoppingCartVisitor visitor);
}

// 书籍类
class Book implements ItemElement {
    private double price;
    private String name;
    
    public Book(double price, String name) {
        this.price = price;
        this.name = name;
    }
    
    @Override
    public double accept(ShoppingCartVisitor visitor) {
        return visitor.visit(this);
    }
    
    public double getPrice() {
        return price;
    }
    
    public String getName() {
        return name;
    }
}

// 水果类
class Fruit implements ItemElement {
    private double pricePerKg;
    private double weight;
    private String name;
    
    public Fruit(double pricePerKg, double weight, String name) {
        this.pricePerKg = pricePerKg;
        this.weight = weight;
        this.name = name;
    }
    
    @Override
    public double accept(ShoppingCartVisitor visitor) {
        return visitor.visit(this);
    }
    
    public double getPricePerKg() {
        return pricePerKg;
    }
    
    public double getWeight() {
        return weight;
    }
    
    public String getName() {
        return name;
    }
}

// 电子产品类
class Electronics implements ItemElement {
    private double price;
    private String name;
    
    public Electronics(double price, String name) {
        this.price = price;
        this.name = name;
    }
    
    @Override
    public double accept(ShoppingCartVisitor visitor) {
        return visitor.visit(this);
    }
    
    public double getPrice() {
        return price;
    }
    
    public String getName() {
        return name;
    }
}

// 购物车类
class ShoppingCart {
    private List<ItemElement> items = new ArrayList<>();
    
    public void addItem(ItemElement item) {
        items.add(item);
    }
    
    public void removeItem(ItemElement item) {
        items.remove(item);
    }
    
    public double calculateTotal(ShoppingCartVisitor visitor) {
        double sum = 0;
        for (ItemElement item : items) {
            sum += item.accept(visitor);
        }
        return sum;
    }
}
```

## 开源框架中的应用

1. **Java编译器**：Java编译器使用访问者模式来遍历和处理抽象语法树(AST)节点
2. **ANTLR解析器生成器**：ANTLR生成的解析器使用访问者模式来遍历解析树
3. **XML解析库**：DOM解析器使用访问者模式来遍历XML文档节点
4. **Lint工具**：代码检查工具如Checkstyle、PMD使用访问者模式来遍历代码结构并执行检查规则
5. **序列化框架**：如Jackson、Gson等JSON序列化库使用访问者模式来处理不同类型的对象

## 访问者模式的优缺点

### 优点
1. **符合单一职责原则**：可以通过访问者将相关的操作集中到一个类中，使得类的职责更加清晰
2. **优秀的扩展性**：可以在不修改对象结构的前提下定义作用于这些元素的新操作
3. **灵活性好**：访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可以相对自由地演化
4. **符合开闭原则**：增加新的访问操作很方便，只需要增加一个新的访问者类即可

### 缺点
1. **增加新的元素类很困难**：每增加一个新的元素类，都要在每一个访问者类中增加相应的操作，违背了开闭原则
2. **破坏封装**：访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态
3. **违反依赖倒置原则**：访问者模式依赖于具体类，而不是抽象类或接口
4. **难以理解**：访问者模式比较复杂，理解和使用都相对困难

## 与其他设计模式的比较

1. **与迭代器模式的区别**：迭代器模式用于遍历集合中的元素，而访问者模式用于对集合中的元素执行某种操作
2. **与策略模式的区别**：策略模式封装的是算法，而访问者模式封装的是对不同对象的操作
3. **与命令模式的区别**：命令模式封装的是请求，而访问者模式封装的是对元素的操作
4. **与观察者模式的区别**：观察者模式是一对多的通知机制，而访问者模式是对对象结构中每个元素执行操作

## 最佳实践和注意事项

1. **谨慎使用**：访问者模式适用于对象结构相对稳定的系统，如果对象结构经常变化，则不适合使用访问者模式
2. **访问者应该了解元素**：访问者需要了解各种元素对象的内部结构，这可能破坏封装性
3. **合理设计访问者接口**：访问者接口应该包含对所有具体元素的访问方法
4. **注意性能问题**：对于大型对象结构，访问者模式可能会影响性能
5. **文档化访问者的作用**：应该清楚地文档化每个访问者的作用和用途
6. **考虑使用双重分发**：访问者模式实际上是一种双重分发技术，利用了多态特性
7. **避免过度设计**：如果对象结构不稳定或者操作不多，使用访问者模式可能是过度设计