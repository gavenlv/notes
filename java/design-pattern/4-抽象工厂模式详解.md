# 第4章 抽象工厂模式详解

## 4.1 抽象工厂模式概述

### 4.1.1 定义

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂的创建型模式。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

### 4.1.2 特点

1. 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口
2. 无需指定它们具体的类
3. 强调产品族的概念

### 4.1.3 应用场景

1. 系统要独立于产品的创建、组合和表示时
2. 系统要由多个产品系列中的一个来配置时
3. 需要强调一系列相关的产品对象的设计以便进行联合使用时
4. 提供一个产品类库，而只想显示它们的接口而不是实现时

## 4.2 抽象工厂模式的结构

抽象工厂模式包含以下角色：

1. **抽象产品（AbstractProduct）**：为一类产品对象声明接口
2. **具体产品（ConcreteProduct）**：定义具体工厂创建的具体产品对象，实现抽象产品接口
3. **抽象工厂（AbstractFactory）**：声明一个创建抽象产品对象的操作接口
4. **具体工厂（ConcreteFactory）**：实现创建具体产品对象的操作

## 4.3 抽象工厂模式的实现

### 4.3.1 基本实现

让我们通过一个跨平台UI组件的例子来理解抽象工厂模式：

```java
// 抽象产品：按钮
interface Button {
    void paint();
}

// 抽象产品：文本框
interface TextBox {
    void paint();
}

// 具体产品：Windows按钮
class WindowsButton implements Button {
    @Override
    public void paint() {
        System.out.println("渲染Windows风格按钮");
    }
}

// 具体产品：Mac按钮
class MacButton implements Button {
    @Override
    public void paint() {
        System.out.println("渲染Mac风格按钮");
    }
}

// 具体产品：Windows文本框
class WindowsTextBox implements TextBox {
    @Override
    public void paint() {
        System.out.println("渲染Windows风格文本框");
    }
}

// 具体产品：Mac文本框
class MacTextBox implements TextBox {
    @Override
    public void paint() {
        System.out.println("渲染Mac风格文本框");
    }
}

// 抽象工厂
interface GUIFactory {
    Button createButton();
    TextBox createTextBox();
}

// 具体工厂：Windows工厂
class WindowsFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new WindowsButton();
    }
    
    @Override
    public TextBox createTextBox() {
        return new WindowsTextBox();
    }
}

// 具体工厂：Mac工厂
class MacFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new MacButton();
    }
    
    @Override
    public TextBox createTextBox() {
        return new MacTextBox();
    }
}
```

### 4.3.2 更复杂的示例

让我们看一个更复杂的例子，涉及不同品牌的电子产品家族：

```java
// 抽象产品：手机
interface Phone {
    void assemble();
}

// 抽象产品：平板
interface Tablet {
    void assemble();
}

// 抽象产品：笔记本
interface Laptop {
    void assemble();
}

// 具体产品：苹果手机
class ApplePhone implements Phone {
    @Override
    public void assemble() {
        System.out.println("组装苹果手机");
    }
}

// 具体产品：三星手机
class SamsungPhone implements Phone {
    @Override
    public void assemble() {
        System.out.println("组装三星手机");
    }
}

// 具体产品：苹果平板
class AppleTablet implements Tablet {
    @Override
    public void assemble() {
        System.out.println("组装苹果平板");
    }
}

// 具体产品：三星平板
class SamsungTablet implements Tablet {
    @Override
    public void assemble() {
        System.out.println("组装三星平板");
    }
}

// 具体产品：苹果笔记本
class AppleLaptop implements Laptop {
    @Override
    public void assemble() {
        System.out.println("组装苹果笔记本");
    }
}

// 具体产品：三星笔记本
class SamsungLaptop implements Laptop {
    @Override
    public void assemble() {
        System.out.println("组装三星笔记本");
    }
}

// 抽象工厂
interface ElectronicsFactory {
    Phone createPhone();
    Tablet createTablet();
    Laptop createLaptop();
}

// 具体工厂：苹果工厂
class AppleFactory implements ElectronicsFactory {
    @Override
    public Phone createPhone() {
        return new ApplePhone();
    }
    
    @Override
    public Tablet createTablet() {
        return new AppleTablet();
    }
    
    @Override
    public Laptop createLaptop() {
        return new AppleLaptop();
    }
}

// 具体工厂：三星工厂
class SamsungFactory implements ElectronicsFactory {
    @Override
    public Phone createPhone() {
        return new SamsungPhone();
    }
    
    @Override
    public Tablet createTablet() {
        return new SamsungTablet();
    }
    
    @Override
    public Laptop createLaptop() {
        return new SamsungLaptop();
    }
}
```

## 4.4 抽象工厂模式的扩展

### 4.4.1 使用配置文件动态选择工厂

```java
import java.io.InputStream;
import java.util.Properties;

class FactoryProducer {
    public static ElectronicsFactory getFactory(String factoryType) {
        switch (factoryType.toLowerCase()) {
            case "apple":
                return new AppleFactory();
            case "samsung":
                return new SamsungFactory();
            default:
                throw new IllegalArgumentException("未知的工厂类型: " + factoryType);
        }
    }
    
    // 从配置文件读取工厂类型
    public static ElectronicsFactory getFactoryFromConfig() {
        try {
            Properties props = new Properties();
            InputStream input = FactoryProducer.class.getClassLoader()
                .getResourceAsStream("factory.properties");
            props.load(input);
            String factoryType = props.getProperty("factory.type", "apple");
            return getFactory(factoryType);
        } catch (Exception e) {
            e.printStackTrace();
            return new AppleFactory(); // 默认工厂
        }
    }
}
```

### 4.4.2 单例抽象工厂

```java
// 单例抽象工厂实现
class SingletonElectronicsFactory {
    private static volatile SingletonElectronicsFactory instance;
    private ElectronicsFactory factory;
    
    private SingletonElectronicsFactory() {
        // 默认使用苹果工厂
        this.factory = new AppleFactory();
    }
    
    public static SingletonElectronicsFactory getInstance() {
        if (instance == null) {
            synchronized (SingletonElectronicsFactory.class) {
                if (instance == null) {
                    instance = new SingletonElectronicsFactory();
                }
            }
        }
        return instance;
    }
    
    public void setFactory(ElectronicsFactory factory) {
        this.factory = factory;
    }
    
    public Phone createPhone() {
        return factory.createPhone();
    }
    
    public Tablet createTablet() {
        return factory.createTablet();
    }
    
    public Laptop createLaptop() {
        return factory.createLaptop();
    }
}
```

## 4.5 抽象工厂模式在开源框架中的应用

### 4.5.1 Spring框架中的应用

Spring框架中的BeanFactory就是抽象工厂模式的一个典型应用：

```java
// Spring中的BeanFactory接口（简化版）
interface BeanFactory {
    Object getBean(String name);
    <T> T getBean(String name, Class<T> requiredType);
    Object getBean(String name, Object... args);
}

// ApplicationContext接口扩展了BeanFactory
interface ApplicationContext extends BeanFactory {
    // 更多方法...
}
```

### 4.5.2 数据库连接池中的应用

```java
// 数据库工厂接口
interface DatabaseConnectionFactory {
    Connection createConnection();
    Statement createStatement();
    PreparedStatement createPreparedStatement(String sql);
}

// MySQL连接工厂
class MySQLConnectionFactory implements DatabaseConnectionFactory {
    private String url;
    private String username;
    private String password;
    
    public MySQLConnectionFactory(String url, String username, String password) {
        this.url = url;
        this.username = username;
        this.password = password;
    }
    
    @Override
    public Connection createConnection() {
        // 创建MySQL连接的实现
        System.out.println("创建MySQL数据库连接");
        return null; // 简化示例
    }
    
    @Override
    public Statement createStatement() {
        System.out.println("创建MySQL Statement");
        return null;
    }
    
    @Override
    public PreparedStatement createPreparedStatement(String sql) {
        System.out.println("创建MySQL PreparedStatement: " + sql);
        return null;
    }
}

// PostgreSQL连接工厂
class PostgreSQLConnectionFactory implements DatabaseConnectionFactory {
    private String url;
    private String username;
    private String password;
    
    public PostgreSQLConnectionFactory(String url, String username, String password) {
        this.url = url;
        this.username = username;
        this.password = password;
    }
    
    @Override
    public Connection createConnection() {
        // 创建PostgreSQL连接的实现
        System.out.println("创建PostgreSQL数据库连接");
        return null; // 简化示例
    }
    
    @Override
    public Statement createStatement() {
        System.out.println("创建PostgreSQL Statement");
        return null;
    }
    
    @Override
    public PreparedStatement createPreparedStatement(String sql) {
        System.out.println("创建PostgreSQL PreparedStatement: " + sql);
        return null;
    }
}
```

## 4.6 抽象工厂模式的优缺点

### 4.6.1 优点

1. **产品族的一致性**：确保客户端始终只使用同一个产品族中的对象
2. **易于交换产品系列**：只需改变具体的工厂即可改变整个产品系列
3. **有利于产品的一致性**：同一产品族中的产品会一起工作，易于保证产品的一致性
4. **符合开闭原则**：增加新的产品族很方便，只需增加新的具体工厂类

### 4.6.2 缺点

1. **不易扩展新产品等级结构**：增加新的产品等级结构很麻烦，需要修改抽象工厂接口及其所有实现
2. **代码复杂度高**：引入了多个抽象层，增加了系统的抽象性和理解难度
3. **类的数量众多**：每增加一个产品族，就需要增加一批新的类

## 4.7 抽象工厂模式与工厂方法模式的比较

| 比较项 | 工厂方法模式 | 抽象工厂模式 |
|--------|-------------|-------------|
| 关注点 | 创建单一产品 | 创建产品族 |
| 扩展性 | 易于增加新产品 | 易于增加产品族 |
| 复杂度 | 相对简单 | 相对复杂 |
| 应用场景 | 单一产品创建 | 产品族创建 |

## 4.8 最佳实践建议

1. **明确产品族概念**：在使用抽象工厂模式前，要清楚什么是产品族
2. **合理设计产品等级结构**：产品等级结构不宜经常变动
3. **结合配置文件使用**：可以通过配置文件动态切换不同的产品族
4. **考虑使用单例**：工厂对象通常可以设计为单例模式

## 4.9 本章小结

本章详细介绍了抽象工厂模式的概念、结构、实现方式以及应用场景。抽象工厂模式是工厂方法模式的进一步扩展，它关注的是产品族的创建，能够确保客户端始终使用同一个产品族中的对象。在实际开发中，抽象工厂模式常用于需要创建一系列相关或依赖对象的场景，特别是在需要支持多平台或多品牌的情况下。

下一章我们将介绍建造者模式，它是另一种重要的创建型模式。