# 第5章 建造者模式详解

## 5.1 建造者模式概述

### 5.1.1 定义

建造者模式（Builder Pattern）是一种创建型设计模式，它允许你分步骤创建复杂对象。该模式让你能够使用相同的创建代码生成不同类型和形式的对象。

### 5.1.2 特点

1. 将一个复杂对象的构建与其表示分离
2. 使得同样的构建过程可以创建不同的表示
3. 客户端不必知道产品内部组成的细节

### 5.1.3 应用场景

1. 需要生成的对象具有复杂的内部结构
2. 需要生成的对象的属性相互依赖，需要指定其生成顺序
3. 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品

## 5.2 建造者模式的结构

建造者模式包含以下角色：

1. **产品（Product）**：表示被构造的复杂对象
2. **抽象建造者（Builder）**：为创建一个产品对象的各个部件指定抽象接口
3. **具体建造者（ConcreteBuilder）**：实现Builder的接口以构造和装配该产品的各个部件
4. **指挥者（Director）**：构造一个使用Builder接口的对象

## 5.3 建造者模式的实现

### 5.3.1 基本实现

让我们通过一个计算机配置的例子来理解建造者模式：

```java
// 产品类：计算机
class Computer {
    private String cpu;
    private String ram;
    private String storage;
    private String graphicsCard;
    private String motherboard;
    
    // 私有构造方法，只能通过建造者创建
    private Computer() {}
    
    // Getter方法
    public String getCpu() { return cpu; }
    public String getRam() { return ram; }
    public String getStorage() { return storage; }
    public String getGraphicsCard() { return graphicsCard; }
    public String getMotherboard() { return motherboard; }
    
    // Setter方法（包级私有，只允许同包的建造者访问）
    void setCpu(String cpu) { this.cpu = cpu; }
    void setRam(String ram) { this.ram = ram; }
    void setStorage(String storage) { this.storage = storage; }
    void setGraphicsCard(String graphicsCard) { this.graphicsCard = graphicsCard; }
    void setMotherboard(String motherboard) { this.motherboard = motherboard; }
    
    @Override
    public String toString() {
        return "Computer{" +
                "cpu='" + cpu + '\'' +
                ", ram='" + ram + '\'' +
                ", storage='" + storage + '\'' +
                ", graphicsCard='" + graphicsCard + '\'' +
                ", motherboard='" + motherboard + '\'' +
                '}';
    }
}

// 抽象建造者
abstract class ComputerBuilder {
    protected Computer computer;
    
    public ComputerBuilder() {
        this.computer = new Computer();
    }
    
    public abstract ComputerBuilder buildCpu(String cpu);
    public abstract ComputerBuilder buildRam(String ram);
    public abstract ComputerBuilder buildStorage(String storage);
    public abstract ComputerBuilder buildGraphicsCard(String graphicsCard);
    public abstract ComputerBuilder buildMotherboard(String motherboard);
    
    public Computer build() {
        return this.computer;
    }
}

// 具体建造者：游戏电脑建造者
class GamingComputerBuilder extends ComputerBuilder {
    @Override
    public ComputerBuilder buildCpu(String cpu) {
        computer.setCpu(cpu);
        return this;
    }
    
    @Override
    public ComputerBuilder buildRam(String ram) {
        computer.setRam(ram);
        return this;
    }
    
    @Override
    public ComputerBuilder buildStorage(String storage) {
        computer.setStorage(storage);
        return this;
    }
    
    @Override
    public ComputerBuilder buildGraphicsCard(String graphicsCard) {
        computer.setGraphicsCard(graphicsCard);
        return this;
    }
    
    @Override
    public ComputerBuilder buildMotherboard(String motherboard) {
        computer.setMotherboard(motherboard);
        return this;
    }
}

// 具体建造者：办公电脑建造者
class OfficeComputerBuilder extends ComputerBuilder {
    @Override
    public ComputerBuilder buildCpu(String cpu) {
        computer.setCpu(cpu);
        return this;
    }
    
    @Override
    public ComputerBuilder buildRam(String ram) {
        computer.setRam(ram);
        return this;
    }
    
    @Override
    public ComputerBuilder buildStorage(String storage) {
        computer.setStorage(storage);
        return this;
    }
    
    @Override
    public ComputerBuilder buildGraphicsCard(String graphicsCard) {
        // 办公电脑不需要独立显卡
        computer.setGraphicsCard("集成显卡");
        return this;
    }
    
    @Override
    public ComputerBuilder buildMotherboard(String motherboard) {
        computer.setMotherboard(motherboard);
        return this;
    }
}

// 指挥者
class ComputerDirector {
    public Computer constructGamingComputer(ComputerBuilder builder) {
        return builder.buildCpu("Intel i9-12900K")
                     .buildRam("32GB DDR4")
                     .buildStorage("1TB NVMe SSD")
                     .buildGraphicsCard("RTX 3080")
                     .buildMotherboard("Z690")
                     .build();
    }
    
    public Computer constructOfficeComputer(ComputerBuilder builder) {
        return builder.buildCpu("Intel i5-12400")
                     .buildRam("16GB DDR4")
                     .buildStorage("512GB SSD")
                     .buildMotherboard("B660")
                     .build();
    }
}
```

### 5.3.2 链式调用的建造者模式

```java
// 支持链式调用的产品类
class Car {
    private String brand;
    private String model;
    private String color;
    private int doors;
    private String engine;
    private boolean gps;
    private boolean sunroof;
    
    private Car() {}
    
    // Getter方法
    public String getBrand() { return brand; }
    public String getModel() { return model; }
    public String getColor() { return color; }
    public int getDoors() { return doors; }
    public String getEngine() { return engine; }
    public boolean hasGps() { return gps; }
    public boolean hasSunroof() { return sunroof; }
    
    // 静态内部类作为建造者
    public static class Builder {
        private Car car;
        
        public Builder() {
            this.car = new Car();
        }
        
        public Builder brand(String brand) {
            car.brand = brand;
            return this;
        }
        
        public Builder model(String model) {
            car.model = model;
            return this;
        }
        
        public Builder color(String color) {
            car.color = color;
            return this;
        }
        
        public Builder doors(int doors) {
            car.doors = doors;
            return this;
        }
        
        public Builder engine(String engine) {
            car.engine = engine;
            return this;
        }
        
        public Builder gps(boolean gps) {
            car.gps = gps;
            return this;
        }
        
        public Builder sunroof(boolean sunroof) {
            car.sunroof = sunroof;
            return this;
        }
        
        public Car build() {
            // 可以在这里添加验证逻辑
            if (car.brand == null || car.model == null) {
                throw new IllegalStateException("品牌和型号是必需的");
            }
            return car;
        }
    }
    
    @Override
    public String toString() {
        return "Car{" +
                "brand='" + brand + '\'' +
                ", model='" + model + '\'' +
                ", color='" + color + '\'' +
                ", doors=" + doors +
                ", engine='" + engine + '\'' +
                ", gps=" + gps +
                ", sunroof=" + sunroof +
                '}';
    }
}
```

## 5.4 建造者模式的实际应用

### 5.4.1 StringBuilder的实现

Java中的StringBuilder就是建造者模式的一个经典应用：

```java
// StringBuilder的简化实现示例
class SimpleStringBuilder {
    private StringBuilder builder;
    
    public SimpleStringBuilder() {
        this.builder = new StringBuilder();
    }
    
    public SimpleStringBuilder append(String str) {
        builder.append(str);
        return this;
    }
    
    public SimpleStringBuilder append(int num) {
        builder.append(num);
        return this;
    }
    
    public SimpleStringBuilder append(char ch) {
        builder.append(ch);
        return this;
    }
    
    public String build() {
        return builder.toString();
    }
}
```

### 5.4.2 HTTP请求构建器

```java
// HTTP请求构建器示例
class HttpRequest {
    private String method;
    private String url;
    private Map<String, String> headers;
    private String body;
    
    private HttpRequest() {
        this.headers = new HashMap<>();
    }
    
    // Getter方法
    public String getMethod() { return method; }
    public String getUrl() { return url; }
    public Map<String, String> getHeaders() { return headers; }
    public String getBody() { return body; }
    
    public static class Builder {
        private HttpRequest request;
        
        public Builder() {
            this.request = new HttpRequest();
        }
        
        public Builder method(String method) {
            request.method = method;
            return this;
        }
        
        public Builder url(String url) {
            request.url = url;
            return this;
        }
        
        public Builder addHeader(String key, String value) {
            request.headers.put(key, value);
            return this;
        }
        
        public Builder body(String body) {
            request.body = body;
            return this;
        }
        
        public HttpRequest build() {
            if (request.method == null || request.url == null) {
                throw new IllegalStateException("HTTP方法和URL是必需的");
            }
            return request;
        }
    }
    
    @Override
    public String toString() {
        return "HttpRequest{" +
                "method='" + method + '\'' +
                ", url='" + url + '\'' +
                ", headers=" + headers +
                ", body='" + body + '\'' +
                '}';
    }
}
```

## 5.5 建造者模式在开源框架中的应用

### 5.5.1 Lombok的@Builder注解

Lombok库提供了@Builder注解，可以自动生成建造者模式的代码：

```java
// 使用Lombok的@Builder注解
// @Builder
// public class Person {
//     private String name;
//     private int age;
//     private String email;
//     
//     // Lombok会自动生成建造者代码
// }

// 等价的手动实现
class Person {
    private String name;
    private int age;
    private String email;
    
    private Person() {}
    
    public static class Builder {
        private Person person;
        
        public Builder() {
            this.person = new Person();
        }
        
        public Builder name(String name) {
            person.name = name;
            return this;
        }
        
        public Builder age(int age) {
            person.age = age;
            return this;
        }
        
        public Builder email(String email) {
            person.email = email;
            return this;
        }
        
        public Person build() {
            return person;
        }
    }
    
    // Getter方法
    public String getName() { return name; }
    public int getAge() { return age; }
    public String getEmail() { return email; }
}
```

### 5.5.2 Apache HttpClient中的应用

Apache HttpClient库中也广泛使用了建造者模式：

```java
// Apache HttpClient RequestConfig.Builder示例
class RequestConfig {
    private int connectTimeout;
    private int socketTimeout;
    private boolean redirectsEnabled;
    
    private RequestConfig() {}
    
    public static class Builder {
        private RequestConfig config;
        
        public Builder() {
            this.config = new RequestConfig();
        }
        
        public Builder setConnectTimeout(int timeout) {
            config.connectTimeout = timeout;
            return this;
        }
        
        public Builder setSocketTimeout(int timeout) {
            config.socketTimeout = timeout;
            return this;
        }
        
        public Builder setRedirectsEnabled(boolean enabled) {
            config.redirectsEnabled = enabled;
            return this;
        }
        
        public RequestConfig build() {
            return config;
        }
    }
    
    // Getter方法
    public int getConnectTimeout() { return connectTimeout; }
    public int getSocketTimeout() { return socketTimeout; }
    public boolean isRedirectsEnabled() { return redirectsEnabled; }
}
```

## 5.6 建造者模式的优缺点

### 5.6.1 优点

1. **良好的封装性**：客户端不必知道产品内部组成的细节
2. **建造者独立**：容易扩展，便于控制细节风险
3. **便于控制风险**：具体的建造者类之间是相互独立的，对系统的扩展非常有利
4. **支持链式调用**：可以写出流畅的API

### 5.6.2 缺点

1. **产品必须有共同点**：建造者模式所创建的产品一般具有较多的共同点
2. **建造者模式一般用在产品结构较为复杂的地方**：如果产品之间的差异性很大，则不适合使用建造者模式
3. **如果产品的内部变化复杂**：可能会导致需要定义很多具体建造者类来实现这种变化

## 5.7 建造者模式与其他创建型模式的比较

| 比较项 | 建造者模式 | 工厂方法模式 | 抽象工厂模式 |
|--------|-----------|-------------|-------------|
| 关注点 | 分步骤构建复杂对象 | 创建单一产品 | 创建产品族 |
| 复杂度 | 较高 | 较低 | 中等 |
| 扩展性 | 易于增加新的建造者 | 易于增加新产品 | 易于增加产品族 |
| 应用场景 | 复杂对象的构建 | 单一产品创建 | 产品族创建 |

## 5.8 最佳实践建议

1. **适用于复杂对象的创建**：当对象的创建算法独立于组成对象的部件及装配方式时
2. **支持链式调用**：建造者模式天然支持链式调用，可以让API更加流畅
3. **添加验证逻辑**：在build()方法中添加必要的验证逻辑
4. **合理使用指挥者**：对于复杂的构建过程，可以使用指挥者来封装构建逻辑

## 5.9 本章小结

本章详细介绍了建造者模式的概念、结构、实现方式以及应用场景。建造者模式通过将复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。在实际开发中，建造者模式常用于需要创建具有复杂结构的对象，特别是在需要支持链式调用的场景下。

下一章我们将介绍原型模式，它是另一种重要的创建型模式。