# 第十七章 中介者模式详解

## 本章概要
- 中介者模式的定义和概念
- 中介者模式的结构和组成
- 中介者模式的实现方式
- 实际应用场景分析
- 开源框架中的应用
- 中介者模式的优缺点
- 与其他设计模式的比较
- 最佳实践和注意事项

## 中介者模式概述

中介者模式（Mediator Pattern）是一种行为型设计模式，它定义一个中介对象来封装一系列对象之间的交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

### 核心思想
中介者模式的核心思想是将多对多的对象交互关系转换为一对多的关系，通过引入中介者对象来集中处理对象间的复杂交互，从而降低系统的耦合度，提高系统的可维护性和可扩展性。

### 应用场景
1. 系统中对象之间存在复杂的引用关系，导致结构混乱且难以理解
2. 一个对象由于引用了其他很多对象并且直接与这些对象通信，导致难以复用该对象
3. 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类
4. 多个类相互耦合，形成了网状结构

## 中介者模式结构

中介者模式包含以下角色：
1. **Mediator（抽象中介者）**：定义一个接口用于与各同事对象通信
2. **ConcreteMediator（具体中介者）**：实现抽象中介者接口，协调各同事对象实现协作行为
3. **Colleague（抽象同事类）**：定义各同事类的公有方法，并声明依赖中介者对象
4. **ConcreteColleague（具体同事类）**：抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互

## 中介者模式实现

### 基本实现

```java
// 抽象中介者
abstract class Mediator {
    public abstract void sendMessage(String message, Colleague colleague);
}

// 抽象同事类
abstract class Colleague {
    protected Mediator mediator;
    
    public Colleague(Mediator mediator) {
        this.mediator = mediator;
    }
    
    public abstract void receiveMessage(String message);
    public abstract void sendMessage(String message);
}

// 具体中介者
class ConcreteMediator extends Mediator {
    private Colleague colleague1;
    private Colleague colleague2;
    
    public void setColleague1(Colleague colleague1) {
        this.colleague1 = colleague1;
    }
    
    public void setColleague2(Colleague colleague2) {
        this.colleague2 = colleague2;
    }
    
    @Override
    public void sendMessage(String message, Colleague colleague) {
        if (colleague == colleague1) {
            colleague2.receiveMessage(message);
        } else {
            colleague1.receiveMessage(message);
        }
    }
}

// 具体同事类1
class ConcreteColleague1 extends Colleague {
    public ConcreteColleague1(Mediator mediator) {
        super(mediator);
    }
    
    @Override
    public void receiveMessage(String message) {
        System.out.println("ConcreteColleague1收到消息: " + message);
    }
    
    @Override
    public void sendMessage(String message) {
        System.out.println("ConcreteColleague1发送消息: " + message);
        mediator.sendMessage(message, this);
    }
}

// 具体同事类2
class ConcreteColleague2 extends Colleague {
    public ConcreteColleague2(Mediator mediator) {
        super(mediator);
    }
    
    @Override
    public void receiveMessage(String message) {
        System.out.println("ConcreteColleague2收到消息: " + message);
    }
    
    @Override
    public void sendMessage(String message) {
        System.out.println("ConcreteColleague2发送消息: " + message);
        mediator.sendMessage(message, this);
    }
}
```

### 更复杂的实现示例

让我们通过一个聊天室系统来展示更复杂的实现。

## 实际应用示例

### 1. 聊天室系统

```java
// 用户类
class User {
    private String name;
    private ChatRoom chatRoom;
    
    public User(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
    
    public void setChatRoom(ChatRoom chatRoom) {
        this.chatRoom = chatRoom;
    }
    
    // 发送消息给所有人
    public void sendMessage(String message) {
        if (chatRoom != null) {
            chatRoom.sendMessage(this, message);
        }
    }
    
    // 发送私信
    public void sendPrivateMessage(User toUser, String message) {
        if (chatRoom != null) {
            chatRoom.sendPrivateMessage(this, toUser, message);
        }
    }
    
    // 接收消息
    public void receiveMessage(User fromUser, String message) {
        System.out.println("[" + name + "] 收到来自 [" + fromUser.getName() + "] 的消息: " + message);
    }
    
    // 接收私信
    public void receivePrivateMessage(User fromUser, String message) {
        System.out.println("[" + name + "] 收到来自 [" + fromUser.getName() + "] 的私信: " + message);
    }
}

// 聊天室中介者
class ChatRoom {
    private List<User> users;
    
    public ChatRoom() {
        this.users = new ArrayList<>();
    }
    
    // 添加用户
    public void addUser(User user) {
        users.add(user);
        user.setChatRoom(this);
    }
    
    // 发送消息给所有用户
    public void sendMessage(User fromUser, String message) {
        System.out.println("[聊天室] " + fromUser.getName() + ": " + message);
        for (User user : users) {
            if (user != fromUser) {
                user.receiveMessage(fromUser, message);
            }
        }
    }
    
    // 发送私信
    public void sendPrivateMessage(User fromUser, User toUser, String message) {
        System.out.println("[私信] " + fromUser.getName() + " -> " + toUser.getName() + ": " + message);
        toUser.receivePrivateMessage(fromUser, message);
    }
}
```

### 2. GUI组件交互系统

```java
// GUI组件基类
abstract class Component {
    protected MediatorGUI mediator;
    
    public Component(MediatorGUI mediator) {
        this.mediator = mediator;
    }
    
    public abstract void update();
    public abstract void click();
}

// 按钮组件
class Button extends Component {
    private String text;
    private boolean enabled;
    
    public Button(MediatorGUI mediator, String text) {
        super(mediator);
        this.text = text;
        this.enabled = true;
    }
    
    public void setText(String text) {
        this.text = text;
    }
    
    public String getText() {
        return text;
    }
    
    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }
    
    public boolean isEnabled() {
        return enabled;
    }
    
    @Override
    public void update() {
        System.out.println("按钮 [" + text + "] 状态更新");
    }
    
    @Override
    public void click() {
        if (enabled) {
            System.out.println("点击按钮 [" + text + "]");
            mediator.buttonClicked(this);
        } else {
            System.out.println("按钮 [" + text + "] 已禁用，无法点击");
        }
    }
}

// 文本框组件
class TextBox extends Component {
    private String text;
    private boolean enabled;
    
    public TextBox(MediatorGUI mediator) {
        super(mediator);
        this.text = "";
        this.enabled = true;
    }
    
    public void setText(String text) {
        if (enabled) {
            this.text = text;
            System.out.println("文本框内容设置为: " + text);
            mediator.textBoxChanged(this);
        }
    }
    
    public String getText() {
        return text;
    }
    
    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }
    
    public boolean isEnabled() {
        return enabled;
    }
    
    @Override
    public void update() {
        System.out.println("文本框内容更新");
    }
    
    @Override
    public void click() {
        System.out.println("点击文本框");
        mediator.textBoxClicked(this);
    }
}

// 标签组件
class Label extends Component {
    private String text;
    
    public Label(MediatorGUI mediator, String text) {
        super(mediator);
        this.text = text;
    }
    
    public void setText(String text) {
        this.text = text;
        System.out.println("标签内容更新为: " + text);
    }
    
    public String getText() {
        return text;
    }
    
    @Override
    public void update() {
        System.out.println("标签 [" + text + "] 更新");
    }
    
    @Override
    public void click() {
        System.out.println("点击标签 [" + text + "]");
        mediator.labelClicked(this);
    }
}

// GUI中介者
class MediatorGUI {
    private Button loginButton;
    private Button logoutButton;
    private TextBox usernameTextBox;
    private TextBox passwordTextBox;
    private Label statusLabel;
    
    public void setLoginButton(Button loginButton) {
        this.loginButton = loginButton;
    }
    
    public void setLogoutButton(Button logoutButton) {
        this.logoutButton = logoutButton;
    }
    
    public void setUsernameTextBox(TextBox usernameTextBox) {
        this.usernameTextBox = usernameTextBox;
    }
    
    public void setPasswordTextBox(TextBox passwordTextBox) {
        this.passwordTextBox = passwordTextBox;
    }
    
    public void setStatusLabel(Label statusLabel) {
        this.statusLabel = statusLabel;
    }
    
    // 按钮点击事件处理
    public void buttonClicked(Button button) {
        if (button == loginButton) {
            handleLogin();
        } else if (button == logoutButton) {
            handleLogout();
        }
    }
    
    // 文本框内容变化事件处理
    public void textBoxChanged(TextBox textBox) {
        if (textBox == usernameTextBox || textBox == passwordTextBox) {
            // 检查用户名和密码是否为空来启用/禁用登录按钮
            boolean hasUsername = usernameTextBox.getText() != null && !usernameTextBox.getText().isEmpty();
            boolean hasPassword = passwordTextBox.getText() != null && !passwordTextBox.getText().isEmpty();
            loginButton.setEnabled(hasUsername && hasPassword);
        }
    }
    
    // 文本框点击事件处理
    public void textBoxClicked(TextBox textBox) {
        // 文本框被点击时的处理逻辑
        System.out.println("文本框被点击");
    }
    
    // 标签点击事件处理
    public void labelClicked(Label label) {
        // 标签被点击时的处理逻辑
        System.out.println("标签被点击");
    }
    
    // 登录处理
    private void handleLogin() {
        String username = usernameTextBox.getText();
        String password = passwordTextBox.getText();
        
        // 简单的登录验证
        if ("admin".equals(username) && "123456".equals(password)) {
            statusLabel.setText("登录成功");
            loginButton.setEnabled(false);
            logoutButton.setEnabled(true);
            usernameTextBox.setEnabled(false);
            passwordTextBox.setEnabled(false);
        } else {
            statusLabel.setText("登录失败：用户名或密码错误");
        }
    }
    
    // 登出处理
    private void handleLogout() {
        statusLabel.setText("已登出");
        loginButton.setEnabled(true);
        logoutButton.setEnabled(false);
        usernameTextBox.setEnabled(true);
        passwordTextBox.setEnabled(true);
        usernameTextBox.setText("");
        passwordTextBox.setText("");
    }
}
```

### 3. 飞机管制系统

```java
// 飞机类
class Aircraft {
    private String callSign;
    private int altitude;
    private int speed;
    private AirTrafficControl atc;
    
    public Aircraft(String callSign, AirTrafficControl atc) {
        this.callSign = callSign;
        this.atc = atc;
        this.altitude = 0;
        this.speed = 0;
    }
    
    public String getCallSign() {
        return callSign;
    }
    
    public int getAltitude() {
        return altitude;
    }
    
    public void setAltitude(int altitude) {
        this.altitude = altitude;
        // 通知ATC高度变化
        atc.notifyAltitudeChange(this);
    }
    
    public int getSpeed() {
        return speed;
    }
    
    public void setSpeed(int speed) {
        this.speed = speed;
        // 通知ATC速度变化
        atc.notifySpeedChange(this);
    }
    
    // 接收来自其他飞机的消息
    public void receiveMessage(Aircraft from, String message) {
        System.out.println("[" + callSign + "] 收到来自 [" + from.getCallSign() + "] 的消息: " + message);
    }
    
    // 发送消息给其他飞机
    public void sendMessage(Aircraft to, String message) {
        atc.sendMessage(this, to, message);
    }
    
    // 接收ATC指令
    public void receiveATCInstruction(String instruction) {
        System.out.println("[" + callSign + "] 收到ATC指令: " + instruction);
    }
}

// 空中交通管制中心
class AirTrafficControl {
    private List<Aircraft> aircrafts;
    private Map<Aircraft, Integer> altitudes;
    private Map<Aircraft, Integer> speeds;
    
    public AirTrafficControl() {
        this.aircrafts = new ArrayList<>();
        this.altitudes = new HashMap<>();
        this.speeds = new HashMap<>();
    }
    
    // 注册飞机
    public void registerAircraft(Aircraft aircraft) {
        aircrafts.add(aircraft);
        altitudes.put(aircraft, aircraft.getAltitude());
        speeds.put(aircraft, aircraft.getSpeed());
        System.out.println("ATC: 飞机 [" + aircraft.getCallSign() + "] 已注册");
    }
    
    // 高度变化通知
    public void notifyAltitudeChange(Aircraft aircraft) {
        int newAltitude = aircraft.getAltitude();
        Integer oldAltitude = altitudes.get(aircraft);
        
        if (oldAltitude != null && oldAltitude != newAltitude) {
            System.out.println("ATC: 飞机 [" + aircraft.getCallSign() + "] 高度从 " + oldAltitude + " 变更为 " + newAltitude);
            
            // 检查是否有冲突风险
            checkAltitudeConflict(aircraft, newAltitude);
            
            altitudes.put(aircraft, newAltitude);
        }
    }
    
    // 速度变化通知
    public void notifySpeedChange(Aircraft aircraft) {
        int newSpeed = aircraft.getSpeed();
        Integer oldSpeed = speeds.get(aircraft);
        
        if (oldSpeed != null && oldSpeed != newSpeed) {
            System.out.println("ATC: 飞机 [" + aircraft.getCallSign() + "] 速度从 " + oldSpeed + " 变更为 " + newSpeed);
            speeds.put(aircraft, newSpeed);
        }
    }
    
    // 检查高度冲突
    private void checkAltitudeConflict(Aircraft aircraft, int newAltitude) {
        for (Aircraft otherAircraft : aircrafts) {
            if (otherAircraft != aircraft) {
                int otherAltitude = altitudes.get(otherAircraft);
                // 如果高度差小于1000英尺，发出警告
                if (Math.abs(newAltitude - otherAltitude) < 1000) {
                    String warning = "警告：与飞机 [" + otherAircraft.getCallSign() + 
                                   "] 高度接近，当前高度差: " + Math.abs(newAltitude - otherAltitude) + " 英尺";
                    aircraft.receiveATCInstruction(warning);
                }
            }
        }
    }
    
    // 发送消息
    public void sendMessage(Aircraft from, Aircraft to, String message) {
        System.out.println("ATC: 转发消息 [" + from.getCallSign() + "] -> [" + to.getCallSign() + "]");
        to.receiveMessage(from, message);
    }
    
    // 发送广播消息
    public void broadcastMessage(Aircraft from, String message) {
        System.out.println("ATC: 广播消息 [" + from.getCallSign() + "]: " + message);
        for (Aircraft aircraft : aircrafts) {
            if (aircraft != from) {
                aircraft.receiveMessage(from, message);
            }
        }
    }
}
```

## 开源框架中的应用

### 1. Java Swing

Java Swing中的事件处理机制大量使用了中介者模式：

```java
// Swing中的中介者模式示例
import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class SwingMediatorExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("中介者模式示例");
        JPanel panel = new JPanel();
        
        JTextField textField = new JTextField(20);
        JButton button = new JButton("点击我");
        JLabel label = new JLabel("状态：待命");
        
        // 通过中介者（JFrame、JPanel）协调组件交互
        button.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                String text = textField.getText();
                label.setText("输入内容：" + text);
            }
        });
        
        panel.add(textField);
        panel.add(button);
        panel.add(label);
        frame.add(panel);
        
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.pack();
        frame.setVisible(true);
    }
}
```

### 2. Spring框架

Spring框架中的事件机制也体现了中介者模式的思想：

```java
// Spring事件机制示例
/*
@Component
public class CustomEventPublisher {
    @Autowired
    private ApplicationEventPublisher applicationEventPublisher;
    
    public void publishCustomEvent(final String message) {
        CustomEvent customEvent = new CustomEvent(this, message);
        applicationEventPublisher.publishEvent(customEvent);
    }
}

@Component
public class CustomEventHandler {
    @EventListener
    public void handleCustomEvent(CustomEvent event) {
        System.out.println("Received custom event - " + event.getMessage());
    }
}
*/
```

## 中介者模式的优缺点

### 优点
1. **降低复杂性**：将一对多的交互转换为一对一的交互，简化了对象之间的交互关系
2. **降低耦合度**：各个同事对象之间解耦，它们不再需要直接引用其他对象
3. **提高可维护性**：集中管理对象间的交互，便于维护和修改交互逻辑
4. **符合开闭原则**：增加新的中介者和同事类都比较方便，无须修改原有代码

### 缺点
1. **中介者类可能变得复杂**：中介者类可能变得非常复杂，难以维护
2. **中介者类可能成为性能瓶颈**：如果中介者类处理逻辑过于复杂，可能会影响系统性能
3. **违反单一职责原则**：中介者类可能承担过多的职责

## 与其他模式的比较

### 1. 与观察者模式的关系
- 中介者模式和观察者模式都可用于处理对象间的交互
- 中介者模式集中处理交互逻辑，而观察者模式是发布-订阅模式
- 中介者模式适用于复杂的多对象交互，观察者模式适用于一对多的依赖关系

### 2. 与外观模式的关系
- 外观模式为子系统提供一个简化的接口，但不增加新的功能
- 中介者模式不仅简化了接口，还封装了对象间的交互逻辑

## 最佳实践和注意事项

### 1. 合理使用
只在对象间的交互确实复杂时才使用中介者模式，避免过度设计。

### 2. 职责分离
中介者类应该只负责协调交互，具体的业务逻辑应该放在同事类中。

### 3. 避免中介者类过于复杂
当中介者类变得过于复杂时，可以考虑将其拆分为多个中介者类。

### 4. 灵活性考虑
设计中介者接口时要考虑扩展性，为将来可能增加的交互提供支持。

## 总结

中介者模式是一种非常有用的设计模式，特别适用于处理复杂的对象间交互。通过引入中介者对象，可以有效地降低系统的耦合度，提高系统的可维护性和可扩展性。

在实际开发中，中介者模式广泛应用于GUI系统、聊天系统、飞机管制系统等需要协调多个对象交互的场景。合理使用中介者模式可以显著改善系统的结构，但也要注意避免中介者类变得过于复杂。