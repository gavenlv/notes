# 第十四章 命令模式详解

## 本章概要
- 命令模式的定义和概念
- 命令模式的结构和组成
- 命令模式的实现方式
- 实际应用场景分析
- 开源框架中的应用
- 命令模式的优缺点
- 与其他设计模式的比较
- 最佳实践和注意事项

## 命令模式概述

命令模式（Command Pattern）是一种行为型设计模式，它将请求封装成对象，从而使你可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

### 核心思想
命令模式的核心思想是将"请求"封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。

### 应用场景
1. GUI菜单和按钮操作
2. 撤销/重做功能
3. 事务处理系统
4. 宏命令系统
5. 异步任务处理
6. 日志记录和恢复系统

## 命令模式结构

命令模式包含以下角色：
1. **Command（抽象命令类）**：声明执行操作的接口
2. **ConcreteCommand（具体命令类）**：将一个接收者对象绑定于一个动作，调用接收者相应的操作
3. **Invoker（调用者）**：要求该命令执行这个请求
4. **Receiver（接收者）**：知道如何实施与执行一个请求相关的操作
5. **Client（客户端）**：创建一个具体命令对象并设定它的接收者

## 命令模式实现

### 基本实现

```java
// 抽象命令接口
interface Command {
    void execute();
}

// 接收者类
class Receiver {
    public void action() {
        System.out.println("执行具体操作");
    }
}

// 具体命令类
class ConcreteCommand implements Command {
    private Receiver receiver;
    
    public ConcreteCommand(Receiver receiver) {
        this.receiver = receiver;
    }
    
    @Override
    public void execute() {
        receiver.action();
    }
}

// 调用者类
class Invoker {
    private Command command;
    
    public void setCommand(Command command) {
        this.command = command;
    }
    
    public void call() {
        command.execute();
    }
}
```

### 支持撤销操作的实现

```java
// 支持撤销的命令接口
interface UndoableCommand extends Command {
    void undo();
}

// 文本编辑器接收者
class TextEditor {
    private StringBuilder text = new StringBuilder();
    
    public void append(String str) {
        text.append(str);
        System.out.println("文本已追加: " + str);
    }
    
    public void delete(int start, int end) {
        String deleted = text.substring(start, end);
        text.delete(start, end);
        System.out.println("文本已删除: " + deleted);
    }
    
    public String getText() {
        return text.toString();
    }
    
    public int length() {
        return text.length();
    }
}

// 追加文本命令
class AppendTextCommand implements UndoableCommand {
    private TextEditor editor;
    private String text;
    private int startPosition;
    
    public AppendTextCommand(TextEditor editor, String text) {
        this.editor = editor;
        this.text = text;
    }
    
    @Override
    public void execute() {
        startPosition = editor.length();
        editor.append(text);
    }
    
    @Override
    public void undo() {
        editor.delete(startPosition, startPosition + text.length());
    }
}

// 删除文本命令
class DeleteTextCommand implements UndoableCommand {
    private TextEditor editor;
    private String deletedText;
    private int startPosition;
    private int endPosition;
    
    public DeleteTextCommand(TextEditor editor, int start, int end) {
        this.editor = editor;
        this.startPosition = start;
        this.endPosition = end;
    }
    
    @Override
    public void execute() {
        deletedText = editor.getText().substring(startPosition, endPosition);
        editor.delete(startPosition, endPosition);
    }
    
    @Override
    public void undo() {
        editor.append(deletedText);
    }
}
```

## 实际应用示例

### 1. 遥控器系统

```java
// 电器接口
interface Appliance {
    void on();
    void off();
}

// 电视类
class Television implements Appliance {
    @Override
    public void on() {
        System.out.println("电视机已打开");
    }
    
    @Override
    public void off() {
        System.out.println("电视机已关闭");
    }
}

// 音响类
class Stereo implements Appliance {
    @Override
    public void on() {
        System.out.println("音响已打开");
    }
    
    @Override
    public void off() {
        System.out.println("音响已关闭");
    }
}

// 打开电器命令
class TurnOnCommand implements Command {
    private Appliance appliance;
    
    public TurnOnCommand(Appliance appliance) {
        this.appliance = appliance;
    }
    
    @Override
    public void execute() {
        appliance.on();
    }
}

// 关闭电器命令
class TurnOffCommand implements Command {
    private Appliance appliance;
    
    public TurnOffCommand(Appliance appliance) {
        this.appliance = appliance;
    }
    
    @Override
    public void execute() {
        appliance.off();
    }
}

// 遥控器类
class RemoteControl {
    private Command[] onCommands;
    private Command[] offCommands;
    
    public RemoteControl() {
        onCommands = new Command[5];
        offCommands = new Command[5];
        
        Command noCommand = new Command() {
            public void execute() {}
        };
        
        for (int i = 0; i < 5; i++) {
            onCommands[i] = noCommand;
            offCommands[i] = noCommand;
        }
    }
    
    public void setCommand(int slot, Command onCommand, Command offCommand) {
        onCommands[slot] = onCommand;
        offCommands[slot] = offCommand;
    }
    
    public void onButtonWasPushed(int slot) {
        onCommands[slot].execute();
    }
    
    public void offButtonWasPushed(int slot) {
        offCommands[slot].execute();
    }
}
```

### 2. 计算器命令系统

```java
// 计算器类（接收者）
class Calculator {
    private double currentValue = 0;
    
    public void add(double value) {
        currentValue += value;
        System.out.println("加上 " + value + "，结果为: " + currentValue);
    }
    
    public void subtract(double value) {
        currentValue -= value;
        System.out.println("减去 " + value + "，结果为: " + currentValue);
    }
    
    public void multiply(double value) {
        currentValue *= value;
        System.out.println("乘以 " + value + "，结果为: " + currentValue);
    }
    
    public void divide(double value) {
        if (value != 0) {
            currentValue /= value;
            System.out.println("除以 " + value + "，结果为: " + currentValue);
        }
    }
    
    public double getCurrentValue() {
        return currentValue;
    }
    
    public void setCurrentValue(double value) {
        this.currentValue = value;
    }
}

// 抽象计算器命令
abstract class CalculatorCommand implements UndoableCommand {
    protected Calculator calculator;
    protected double value;
    
    public CalculatorCommand(Calculator calculator, double value) {
        this.calculator = calculator;
        this.value = value;
    }
}

// 加法命令
class AddCommand extends CalculatorCommand {
    private double previousValue;
    
    public AddCommand(Calculator calculator, double value) {
        super(calculator, value);
    }
    
    @Override
    public void execute() {
        previousValue = calculator.getCurrentValue();
        calculator.add(value);
    }
    
    @Override
    public void undo() {
        calculator.setCurrentValue(previousValue);
    }
}

// 减法命令
class SubtractCommand extends CalculatorCommand {
    private double previousValue;
    
    public SubtractCommand(Calculator calculator, double value) {
        super(calculator, value);
    }
    
    @Override
    public void execute() {
        previousValue = calculator.getCurrentValue();
        calculator.subtract(value);
    }
    
    @Override
    public void undo() {
        calculator.setCurrentValue(previousValue);
    }
}

// 乘法命令
class MultiplyCommand extends CalculatorCommand {
    private double previousValue;
    
    public MultiplyCommand(Calculator calculator, double value) {
        super(calculator, value);
    }
    
    @Override
    public void execute() {
        previousValue = calculator.getCurrentValue();
        calculator.multiply(value);
    }
    
    @Override
    public void undo() {
        calculator.setCurrentValue(previousValue);
    }
}

// 除法命令
class DivideCommand extends CalculatorCommand {
    private double previousValue;
    
    public DivideCommand(Calculator calculator, double value) {
        super(calculator, value);
    }
    
    @Override
    public void execute() {
        previousValue = calculator.getCurrentValue();
        calculator.divide(value);
    }
    
    @Override
    public void undo() {
        calculator.setCurrentValue(previousValue);
    }
}

// 计算器调用者
class CalculatorInvoker {
    private java.util.Stack<UndoableCommand> commandHistory = new java.util.Stack<>();
    
    public void executeCommand(UndoableCommand command) {
        command.execute();
        commandHistory.push(command);
    }
    
    public void undo() {
        if (!commandHistory.isEmpty()) {
            UndoableCommand command = commandHistory.pop();
            command.undo();
            System.out.println("执行撤销操作");
        } else {
            System.out.println("没有可撤销的操作");
        }
    }
    
    public void redo() {
        // 简化实现，实际应用中需要保存redo历史
        System.out.println("执行重做操作");
    }
}
```

### 3. 宏命令系统

```java
// 宏命令类
class MacroCommand implements Command {
    private java.util.List<Command> commands;
    
    public MacroCommand() {
        commands = new java.util.ArrayList<>();
    }
    
    public void addCommand(Command command) {
        commands.add(command);
    }
    
    public void removeCommand(Command command) {
        commands.remove(command);
    }
    
    @Override
    public void execute() {
        for (Command command : commands) {
            command.execute();
        }
    }
}

// 启动系统命令
class StartSystemCommand implements Command {
    @Override
    public void execute() {
        System.out.println("启动系统...");
    }
}

// 打开网络连接命令
class OpenNetworkCommand implements Command {
    @Override
    public void execute() {
        System.out.println("打开网络连接...");
    }
}

// 启动应用程序命令
class StartApplicationCommand implements Command {
    private String appName;
    
    public StartApplicationCommand(String appName) {
        this.appName = appName;
    }
    
    @Override
    public void execute() {
        System.out.println("启动应用程序: " + appName);
    }
}
```

## 开源框架中的应用

### 1. Swing中的Action接口

Java Swing中的Action接口就是命令模式的应用：

```java
// Swing Action示例
import javax.swing.*;
import java.awt.event.ActionEvent;

public class SwingActionExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame();
        JButton button = new JButton(new AbstractAction("点击我") {
            @Override
            public void actionPerformed(ActionEvent e) {
                System.out.println("按钮被点击了");
            }
        });
        frame.add(button);
        frame.pack();
        frame.setVisible(true);
    }
}
```

### 2. Spring Framework中的Command Objects

Spring MVC中的表单处理也体现了命令模式的思想，将用户的请求封装成命令对象进行处理。

## 命令模式的优缺点

### 优点
1. **降低系统耦合度**：将调用操作的对象与知道如何实现该操作的对象解耦
2. **易于扩展新命令**：增加新的命令类非常容易，符合开闭原则
3. **支持撤销操作**：可以很容易地设计一个命令的撤销操作
4. **支持宏命令**：可以将多个命令组合成一个复合命令
5. **便于记录日志**：可以在执行命令前后记录日志信息

### 缺点
1. **可能导致系统中存在过多的具体命令类**：增加了系统的复杂性
2. **系统性能可能会受到影响**：每个命令都是一个对象，可能占用较多内存

## 与其他模式的比较

### 1. 与策略模式的区别
- 策略模式关注的是算法的替换，而命令模式关注的是请求的封装
- 策略模式中的算法通常是独立的，而命令模式中的命令通常涉及接收者

### 2. 与备忘录模式的结合
- 命令模式可以与备忘录模式结合实现撤销操作
- 备忘录模式用于保存状态，命令模式用于执行和撤销操作

## 最佳实践和注意事项

### 1. 合理设计命令接口
根据需求决定是否需要支持撤销操作，不是所有的命令都需要撤销功能。

### 2. 使用命令队列
可以将命令放入队列中，实现异步处理或批量处理。

### 3. 记录命令日志
对于重要的操作，可以通过记录命令日志来实现系统的恢复功能。

### 4. 避免过度设计
不要为了使用模式而使用模式，只有在确实需要的时候才考虑使用命令模式。

## 总结

命令模式是一种非常实用的行为型设计模式，特别是在需要支持撤销操作、宏命令、异步处理等功能的系统中。通过将请求封装成对象，命令模式实现了请求发送者和接收者的解耦，提高了系统的灵活性和可扩展性。

在实际开发中，命令模式广泛应用于GUI系统、事务处理系统、日志记录系统等场景。掌握这一模式有助于我们构建更加灵活和可维护的软件系统。