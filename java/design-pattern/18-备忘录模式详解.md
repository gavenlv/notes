# 第十八章 备忘录模式详解

## 本章概要
- 备忘录模式的定义和概念
- 备忘录模式的结构和组成
- 备忘录模式的实现方式
- 实际应用场景分析
- 开源框架中的应用
- 备忘录模式的优缺点
- 与其他设计模式的比较
- 最佳实践和注意事项

## 备忘录模式概述

备忘录模式（Memento Pattern），又称快照模式（Snapshot Pattern），是一种行为型设计模式。该模式的主要目的是在不破坏对象封装性的前提下，捕获并保存一个对象的内部状态，以便在将来可以将该对象恢复到原先保存的状态。

### 核心思想
备忘录模式的核心思想是将对象的状态保存到一个外部对象中，在需要时可以从这个外部对象恢复原始对象的状态。这种模式简化了原发器对象，因为Memento只保存原发器的状态。

### 应用场景
1. 需要保存对象在某一时刻的状态，以便在适当的时候恢复到该状态
2. 对象的状态信息对外部来说是私有的，不能直接暴露给外部对象
3. 类希望方便地创建自身状态的快照，防止状态在其他地方被修改
4. 数据库事务回滚操作的实现

## 备忘录模式结构

备忘录模式包含以下角色：
1. **Originator（发起人）**：负责创建一个备忘录Memento，用以记录当前时刻自身的内部状态，并可使用备忘录恢复内部状态
2. **Memento（备忘录）**：负责存储Originator对象的内部状态，在需要的时候提供这些内部状态给Originator
3. **Caretaker（管理者）**：负责存储备忘录，但不能对备忘录的内容进行访问或者操作

## 备忘录模式实现

### 基本实现

```java
// 备忘录类
class Memento {
    private String state;
    
    public Memento(String state) {
        this.state = state;
    }
    
    public String getState() {
        return state;
    }
}

// 发起人类
class Originator {
    private String state;
    
    public void setState(String state) {
        this.state = state;
    }
    
    public String getState() {
        return state;
    }
    
    // 创建备忘录
    public Memento createMemento() {
        return new Memento(state);
    }
    
    // 从备忘录恢复状态
    public void restoreMemento(Memento memento) {
        this.state = memento.getState();
    }
    
    public void showState() {
        System.out.println("当前状态: " + state);
    }
}

// 管理者类
class Caretaker {
    private Memento memento;
    
    public void setMemento(Memento memento) {
        this.memento = memento;
    }
    
    public Memento getMemento() {
        return memento;
    }
}
```

### 更复杂的实现示例

让我们通过一个文本编辑器来展示更复杂的实现。

## 实际应用示例

### 1. 文本编辑器

```java
// 文本编辑器状态备忘录
class TextEditorMemento {
    private String content;
    private int cursorPosition;
    
    public TextEditorMemento(String content, int cursorPosition) {
        this.content = content;
        this.cursorPosition = cursorPosition;
    }
    
    public String getContent() {
        return content;
    }
    
    public int getCursorPosition() {
        return cursorPosition;
    }
}

// 文本编辑器
class TextEditor {
    private String content;
    private int cursorPosition;
    
    public TextEditor() {
        this.content = "";
        this.cursorPosition = 0;
    }
    
    public void setContent(String content) {
        this.content = content;
    }
    
    public String getContent() {
        return content;
    }
    
    public void setCursorPosition(int cursorPosition) {
        this.cursorPosition = cursorPosition;
    }
    
    public int getCursorPosition() {
        return cursorPosition;
    }
    
    // 输入文本
    public void inputText(String text) {
        content = content.substring(0, cursorPosition) + text + content.substring(cursorPosition);
        cursorPosition += text.length();
    }
    
    // 删除文本
    public void deleteText(int count) {
        if (cursorPosition >= count) {
            content = content.substring(0, cursorPosition - count) + content.substring(cursorPosition);
            cursorPosition -= count;
        } else {
            content = content.substring(cursorPosition);
            cursorPosition = 0;
        }
    }
    
    // 移动光标
    public void moveCursor(int position) {
        if (position >= 0 && position <= content.length()) {
            cursorPosition = position;
        }
    }
    
    // 创建备忘录
    public TextEditorMemento createMemento() {
        return new TextEditorMemento(content, cursorPosition);
    }
    
    // 从备忘录恢复状态
    public void restoreMemento(TextEditorMemento memento) {
        this.content = memento.getContent();
        this.cursorPosition = memento.getCursorPosition();
    }
    
    public void showContent() {
        System.out.println("内容: \"" + content + "\"");
        System.out.println("光标位置: " + cursorPosition);
    }
}

// 历史记录管理器
class HistoryManager {
    private Stack<TextEditorMemento> history;
    
    public HistoryManager() {
        this.history = new Stack<>();
    }
    
    public void saveState(TextEditorMemento memento) {
        history.push(memento);
    }
    
    public TextEditorMemento undo() {
        if (!history.isEmpty()) {
            return history.pop();
        }
        return null;
    }
    
    public boolean isEmpty() {
        return history.isEmpty();
    }
}
```

### 2. 游戏角色存档系统

```java
// 游戏角色状态备忘录
class GameRoleMemento {
    private int life;
    private int magic;
    private int attack;
    private int defense;
    
    public GameRoleMemento(int life, int magic, int attack, int defense) {
        this.life = life;
        this.magic = magic;
        this.attack = attack;
        this.defense = defense;
    }
    
    public int getLife() {
        return life;
    }
    
    public int getMagic() {
        return magic;
    }
    
    public int getAttack() {
        return attack;
    }
    
    public int getDefense() {
        return defense;
    }
}

// 游戏角色类
class GameRole {
    private int life;
    private int magic;
    private int attack;
    private int defense;
    
    public GameRole() {
        this.life = 100;
        this.magic = 100;
        this.attack = 50;
        this.defense = 30;
    }
    
    // 显示角色状态
    public void displayState() {
        System.out.println("角色状态:");
        System.out.println("生命值: " + life);
        System.out.println("魔法值: " + magic);
        System.out.println("攻击力: " + attack);
        System.out.println("防御力: " + defense);
    }
    
    // 战斗
    public void fight() {
        life -= 10;
        magic -= 5;
        System.out.println("战斗后状态:");
        displayState();
    }
    
    // 使用魔法
    public void useMagic() {
        magic -= 20;
        attack += 10;
        System.out.println("使用魔法后状态:");
        displayState();
    }
    
    // 休息恢复
    public void rest() {
        life += 20;
        magic += 30;
        if (life > 100) life = 100;
        if (magic > 100) magic = 100;
        System.out.println("休息后状态:");
        displayState();
    }
    
    // 创建备忘录
    public GameRoleMemento createMemento() {
        return new GameRoleMemento(life, magic, attack, defense);
    }
    
    // 从备忘录恢复状态
    public void restoreMemento(GameRoleMemento memento) {
        this.life = memento.getLife();
        this.magic = memento.getMagic();
        this.attack = memento.getAttack();
        this.defense = memento.getDefense();
    }
    
    // 获取生命值
    public int getLife() {
        return life;
    }
}

// 存档管理器
class SaveGameManager {
    private Stack<GameRoleMemento> saves;
    
    public SaveGameManager() {
        this.saves = new Stack<>();
    }
    
    public void saveGame(GameRoleMemento memento) {
        saves.push(memento);
        System.out.println("游戏已保存");
    }
    
    public GameRoleMemento loadGame() {
        if (!saves.isEmpty()) {
            GameRoleMemento memento = saves.pop();
            System.out.println("游戏已加载");
            return memento;
        }
        System.out.println("没有可加载的存档");
        return null;
    }
}
```

## 开源框架中的应用

### Java中的应用
虽然Java标准库中没有直接提供备忘录模式的实现，但在一些第三方库中有相关应用：

1. **Apache Commons Lang** - 在某些工具类中使用了类似备忘录的思想来保存对象状态
2. **Swing中的Undo/Redo机制** - 使用了备忘录模式来实现撤销和重做功能

### 示例：Swing中的UndoManager
```java
// Swing中的UndoManager使用备忘录模式实现撤销功能
/*
UndoManager undoManager = new UndoManager();
document.addUndoableEditListener(new UndoableEditListener() {
    public void undoableEditHappened(UndoableEditEvent e) {
        undoManager.addEdit(e.getEdit());
    }
});

// 撤销操作
try {
    undoManager.undo();
} catch (CannotUndoException ex) {
    System.out.println("无法撤销");
}
*/
```

## 备忘录模式的优缺点

### 优点
1. **封装性好**：只有发起人角色对备忘录角色的内部状态进行访问，有效地保护了封装性
2. **简化发起人类**：发起人不需要管理和保存其内部状态的各个版本，这些工作由管理者类负责
3. **提供状态恢复机制**：提供了容易实现的恢复机制，可以方便地将对象的状态恢复到某个历史状态
4. **符合单一职责原则**：建立状态的封装，使得状态的保存和恢复都集中在备忘录类中

### 缺点
1. **资源消耗大**：如果需要保存的内部状态信息过多或者保存频率过高，将会占用较大的内存资源
2. **可能违反封装原则**：为了保存对象的内部状态，备忘录模式可能会暴露一些不应该暴露的细节
3. **管理复杂**：当需要保存多个备忘录对象时，如何管理这些备忘录对象需要额外考虑

## 与其他设计模式的比较

### 与命令模式
- **相同点**：两者都可以用于实现撤销操作
- **不同点**：
  - 命令模式通过保存操作本身来实现撤销，而备忘录模式通过保存对象状态来实现撤销
  - 命令模式更适合于操作简单的情况，备忘录模式更适合于状态复杂的情况

### 与原型模式
- **相同点**：两者都涉及对象的复制
- **不同点**：
  - 原型模式关注的是对象本身的克隆，而备忘录模式关注的是对象状态的保存和恢复
  - 原型模式通常用于创建新对象，备忘录模式用于保存和恢复已有对象的状态

## 最佳实践和注意事项

### 最佳实践
1. **合理控制备忘录数量**：避免创建过多的备忘录对象，可以通过限制历史记录的数量来控制内存使用
2. **使用栈结构管理备忘录**：对于需要支持撤销操作的场景，使用栈结构来管理备忘录更加合适
3. **考虑线程安全**：在多线程环境中使用备忘录模式时，需要考虑线程安全问题
4. **选择合适的可见性**：合理设置备忘录类的可见性，避免过度暴露内部状态

### 注意事项
1. **性能影响**：频繁创建备忘录对象会影响系统性能，特别是在状态数据较大时
2. **内存泄漏**：如果忘记清理不再使用的备忘录对象，可能导致内存泄漏
3. **深拷贝vs浅拷贝**：在创建备忘录时要注意使用深拷贝还是浅拷贝，确保状态的正确保存
4. **状态一致性**：在恢复状态时要确保对象的一致性，避免出现非法状态

## 总结

备忘录模式是一种非常实用的行为型设计模式，特别适用于需要保存和恢复对象状态的场景。通过将状态的保存和恢复操作封装起来，备忘录模式既保护了对象的封装性，又提供了灵活的状态管理机制。在实际开发中，我们可以根据具体需求选择合适的实现方式，并注意控制资源消耗，确保系统的性能和稳定性。