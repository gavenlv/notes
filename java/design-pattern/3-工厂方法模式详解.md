# 第3章 工厂方法模式详解

## 3.1 工厂方法模式概述

### 3.1.1 定义

工厂方法模式（Factory Method Pattern）又称为工厂模式，属于创建型设计模式。它定义了一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。

### 3.1.2 特点

1. 工厂方法模式的核心是一个抽象工厂类
2. 具体的工厂类实现工厂接口，负责创建具体的产品对象
3. 客户端不直接创建产品对象，而是通过工厂来创建

### 3.1.3 应用场景

1. 当一个类不知道它所需要的对象的类时
2. 当一个类希望由它的子类来指定它所创建的对象时
3. 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化时

## 3.2 工厂方法模式的结构

工厂方法模式包含以下角色：

1. **抽象产品（Product）**：定义产品的接口
2. **具体产品（ConcreteProduct）**：实现抽象产品接口的具体产品类
3. **抽象工厂（Creator）**：声明工厂方法，返回一个产品对象
4. **具体工厂（ConcreteCreator）**：实现工厂方法，返回一个具体产品实例

## 3.3 工厂方法模式的实现

### 3.3.1 基本实现

```java
// 抽象产品
abstract class Product {
    public abstract void use();
}

// 具体产品A
class ConcreteProductA extends Product {
    @Override
    public void use() {
        System.out.println("使用产品A");
    }
}

// 具体产品B
class ConcreteProductB extends Product {
    @Override
    public void use() {
        System.out.println("使用产品B");
    }
}

// 抽象工厂
abstract class Creator {
    // 工厂方法
    public abstract Product factoryMethod();
    
    // 业务方法
    public void someOperation() {
        Product product = factoryMethod();
        product.use();
    }
}

// 具体工厂A
class ConcreteCreatorA extends Creator {
    @Override
    public Product factoryMethod() {
        return new ConcreteProductA();
    }
}

// 具体工厂B
class ConcreteCreatorB extends Creator {
    @Override
    public Product factoryMethod() {
        return new ConcreteProductB();
    }
}
```

### 3.3.2 实际应用示例

让我们通过一个更实际的例子来理解工厂方法模式——图形绘制系统：

```java
// 抽象产品：图形接口
interface Shape {
    void draw();
}

// 具体产品：圆形
class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("绘制圆形");
    }
}

// 具体产品：矩形
class Rectangle implements Shape {
    @Override
    public void draw() {
        System.out.println("绘制矩形");
    }
}

// 具体产品：正方形
class Square implements Shape {
    @Override
    public void draw() {
        System.out.println("绘制正方形");
    }
}

// 抽象工厂
abstract class ShapeFactory {
    // 工厂方法
    public abstract Shape createShape();
    
    // 通用方法
    public void displayShapeInfo() {
        Shape shape = createShape();
        shape.draw();
    }
}

// 具体工厂：圆形工厂
class CircleFactory extends ShapeFactory {
    @Override
    public Shape createShape() {
        return new Circle();
    }
}

// 具体工厂：矩形工厂
class RectangleFactory extends ShapeFactory {
    @Override
    public Shape createShape() {
        return new Rectangle();
    }
}

// 具体工厂：正方形工厂
class SquareFactory extends ShapeFactory {
    @Override
    public Shape createShape() {
        return new Square();
    }
}
```

## 3.4 工厂方法模式的变体

### 3.4.1 参数化工厂方法

```java
// 抽象产品
abstract class Animal {
    public abstract void makeSound();
}

// 具体产品
class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("汪汪叫");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("喵喵叫");
    }
}

// 抽象工厂
abstract class AnimalFactory {
    public abstract Animal createAnimal(String type);
}

// 具体工厂
class SimpleAnimalFactory extends AnimalFactory {
    @Override
    public Animal createAnimal(String type) {
        switch (type.toLowerCase()) {
            case "dog":
                return new Dog();
            case "cat":
                return new Cat();
            default:
                throw new IllegalArgumentException("未知的动物类型: " + type);
        }
    }
}
```

### 3.4.2 静态工厂方法

```java
class LoggerFactory {
    public static Logger getLogger(String type) {
        switch (type.toLowerCase()) {
            case "console":
                return new ConsoleLogger();
            case "file":
                return new FileLogger();
            case "database":
                return new DatabaseLogger();
            default:
                throw new IllegalArgumentException("未知的日志类型: " + type);
        }
    }
}

interface Logger {
    void log(String message);
}

class ConsoleLogger implements Logger {
    @Override
    public void log(String message) {
        System.out.println("控制台日志: " + message);
    }
}

class FileLogger implements Logger {
    @Override
    public void log(String message) {
        System.out.println("文件日志: " + message);
    }
}

class DatabaseLogger implements Logger {
    @Override
    public void log(String message) {
        System.out.println("数据库日志: " + message);
    }
}
```

## 3.5 工厂方法模式与其他创建型模式的结合

### 3.5.1 与单例模式结合

```java
// 单例工厂
class SingletonShapeFactory {
    private static volatile SingletonShapeFactory instance;
    
    private SingletonShapeFactory() {}
    
    public static SingletonShapeFactory getInstance() {
        if (instance == null) {
            synchronized (SingletonShapeFactory.class) {
                if (instance == null) {
                    instance = new SingletonShapeFactory();
                }
            }
        }
        return instance;
    }
    
    public Shape createShape(String type) {
        switch (type.toLowerCase()) {
            case "circle":
                return new Circle();
            case "rectangle":
                return new Rectangle();
            case "square":
                return new Square();
            default:
                throw new IllegalArgumentException("未知的图形类型: " + type);
        }
    }
}
```

## 3.6 工厂方法模式在开源框架中的应用

### 3.6.1 Spring框架中的应用

Spring框架大量使用了工厂方法模式，例如BeanFactory就是典型的工厂方法模式应用：

```java
// 简化的Spring BeanFactory示例
interface BeanFactory {
    Object getBean(String name);
}

class SimpleBeanFactory implements BeanFactory {
    private Map<String, Object> beans = new HashMap<>();
    
    @Override
    public Object getBean(String name) {
        return beans.get(name);
    }
    
    public void registerBean(String name, Object bean) {
        beans.put(name, bean);
    }
}
```

### 3.6.2 JDBC中的应用

JDBC驱动管理也是工厂方法模式的经典应用：

```java
// JDBC驱动管理示例
class JdbcDriverManager {
    public static Connection getConnection(String url, String username, String password) 
            throws SQLException {
        // 根据URL选择合适的驱动创建连接
        // 这是工厂方法模式的体现
        return DriverManager.getConnection(url, username, password);
    }
}
```

## 3.7 工厂方法模式的优缺点

### 3.7.1 优点

1. **符合开闭原则**：新增产品时，只需增加具体产品类和对应的工厂类，无需修改原有代码
2. **符合单一职责原则**：每个工厂类只负责创建对应的产品
3. **良好的封装性**：客户端不需要知道所创建具体产品的类名，只需要知道对应的工厂即可
4. **扩展性好**：当需要增加新产品时，只需增加具体产品类和对应的工厂类

### 3.7.2 缺点

1. **类的数量增加**：每增加一个产品类，就需要增加一个对应的工厂类
2. **增加了系统的抽象性和复杂度**：引入了抽象层，增加了理解和使用难度
3. **需要Creator和相应的子类**

## 3.8 工厂方法模式与抽象工厂模式的区别

| 比较项 | 工厂方法模式 | 抽象工厂模式 |
|--------|-------------|-------------|
| 产品族 | 只考虑一种产品 | 考虑多种产品 |
| 扩展性 | 新增产品方便 | 新增产品族方便 |
| 复杂度 | 相对简单 | 相对复杂 |

## 3.9 最佳实践建议

1. **明确使用场景**：当创建对象的逻辑比较复杂或者需要根据不同条件创建不同对象时使用
2. **遵循开闭原则**：通过继承来扩展新的产品类和工厂类
3. **合理使用参数化工厂**：当产品种类较多时，可以考虑使用参数化工厂来减少类的数量
4. **结合其他模式**：可以与单例模式、原型模式等结合使用

## 3.10 本章小结

本章详细介绍了工厂方法模式的概念、结构、实现方式以及应用场景。工厂方法模式通过将对象的创建延迟到子类中实现，使得系统具有更好的扩展性和维护性。在实际开发中，工厂方法模式常用于创建复杂的对象或者需要根据不同条件创建不同对象的场景。

下一章我们将介绍抽象工厂模式，它是工厂方法模式的进一步扩展。