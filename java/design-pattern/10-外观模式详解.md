# 第十章 外观模式详解

## 1. 外观模式概述

### 1.1 定义
外观模式(Facade Pattern)是一种结构型设计模式，它为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

### 1.2 核心思想
外观模式的核心思想是"为复杂的子系统提供一个简单的接口"。它通过创建一个外观类来隐藏一个复杂子系统的复杂性，使得客户端只需要与外观类交互，而不需要直接与复杂的子系统打交道。

## 2. 外观模式结构

外观模式包含以下角色：

1. **外观(Facade)**：知道哪些子系统类负责处理请求，将客户的请求代理给适当的子系统对象
2. **子系统类(SubSystem Classes)**：实现子系统的功能，处理由Facade对象指派的任务，注意子系统类没有Facade的任何信息，即没有指向Facade的指针

## 3. 外观模式实现

### 3.1 基本实现
```java
// 子系统类 - CPU
class CPU {
    public void freeze() {
        System.out.println("CPU: Freezing processor.");
    }
    
    public void jump(long position) {
        System.out.println("CPU: Jumping to position " + position);
    }
    
    public void execute() {
        System.out.println("CPU: Executing instructions.");
    }
}

// 子系统类 - 内存
class Memory {
    public void load(long position, byte[] data) {
        System.out.println("Memory: Loading data at position " + position);
    }
}

// 子系统类 - 硬盘
class HardDrive {
    public byte[] read(long lba, int size) {
        System.out.println("HardDrive: Reading " + size + " bytes from LBA " + lba);
        return new byte[size];
    }
}

// 外观类 - 计算机启动器
class ComputerFacade {
    private CPU cpu;
    private Memory memory;
    private HardDrive hardDrive;
    
    public ComputerFacade() {
        this.cpu = new CPU();
        this.memory = new Memory();
        this.hardDrive = new HardDrive();
    }
    
    public void start() {
        System.out.println("ComputerFacade: Starting computer...");
        cpu.freeze();
        memory.load(0, hardDrive.read(0, 1024));
        cpu.jump(0);
        cpu.execute();
        System.out.println("ComputerFacade: Computer started successfully.");
    }
    
    public void shutdown() {
        System.out.println("ComputerFacade: Shutting down computer...");
        // 关闭逻辑
        System.out.println("ComputerFacade: Computer shut down successfully.");
    }
}
```

### 3.2 多层次外观示例
```java
// 子系统类 - DVD播放器
class DvdPlayer {
    public void on() {
        System.out.println("DVD Player is on");
    }
    
    public void play(String movie) {
        System.out.println("DVD Player playing \"" + movie + "\"");
    }
    
    public void stop() {
        System.out.println("DVD Player stopped");
    }
    
    public void eject() {
        System.out.println("DVD Player eject");
    }
    
    public void off() {
        System.out.println("DVD Player is off");
    }
}

// 子系统类 - 投影仪
class Projector {
    public void on() {
        System.out.println("Projector is on");
    }
    
    public void wideScreenMode() {
        System.out.println("Projector in widescreen mode (16x9 aspect ratio)");
    }
    
    public void off() {
        System.out.println("Projector is off");
    }
}

// 子系统类 - 音响功放
class Amplifier {
    public void on() {
        System.out.println("Amplifier is on");
    }
    
    public void setDvd(DvdPlayer dvd) {
        System.out.println("Amplifier setting DVD player");
    }
    
    public void setSurroundSound() {
        System.out.println("Amplifier setting surround sound");
    }
    
    public void setVolume(int level) {
        System.out.println("Amplifier setting volume to " + level);
    }
    
    public void off() {
        System.out.println("Amplifier is off");
    }
}

// 子系统类 - 屏幕
class Screen {
    public void down() {
        System.out.println("Screen is going down");
    }
    
    public void up() {
        System.out.println("Screen is going up");
    }
}

// 子系统类 - 灯光
class TheaterLights {
    public void dim(int level) {
        System.out.println("Theater Ceiling Lights dimming to " + level + "%");
    }
    
    public void on() {
        System.out.println("Theater Ceiling Lights on");
    }
    
    public void off() {
        System.out.println("Theater Ceiling Lights off");
    }
}

// 子系统类 - 爆米花机
class PopcornPopper {
    public void on() {
        System.out.println("Popcorn Popper is on");
    }
    
    public void pop() {
        System.out.println("Popcorn Popper popping popcorn!");
    }
    
    public void off() {
        System.out.println("Popcorn Popper is off");
    }
}

// 外观类 - 家庭影院外观
class HomeTheaterFacade {
    private Amplifier amp;
    private Tuner tuner;
    private DvdPlayer dvd;
    private Projector projector;
    private Screen screen;
    private TheaterLights lights;
    private PopcornPopper popper;
    
    public HomeTheaterFacade(Amplifier amp,
                           Tuner tuner,
                           DvdPlayer dvd,
                           Projector projector,
                           Screen screen,
                           TheaterLights lights,
                           PopcornPopper popper) {
        this.amp = amp;
        this.tuner = tuner;
        this.dvd = dvd;
        this.projector = projector;
        this.screen = screen;
        this.lights = lights;
        this.popper = popper;
    }
    
    public void watchMovie(String movie) {
        System.out.println("Get ready to watch a movie...");
        popper.on();
        popper.pop();
        lights.dim(10);
        screen.down();
        projector.on();
        projector.wideScreenMode();
        amp.on();
        amp.setDvd(dvd);
        amp.setSurroundSound();
        amp.setVolume(5);
        dvd.on();
        dvd.play(movie);
    }
    
    public void endMovie() {
        System.out.println("Shutting movie theater down...");
        popper.off();
        lights.on();
        screen.up();
        projector.off();
        amp.off();
        dvd.stop();
        dvd.eject();
        dvd.off();
    }
}
```

## 4. 实际应用示例

### 4.1 数据库访问外观模式
```java
// 子系统类 - 连接管理器
class ConnectionManager {
    public void connect() {
        System.out.println("Connecting to database...");
    }
    
    public void disconnect() {
        System.out.println("Disconnecting from database...");
    }
}

// 子系统类 - 查询构建器
class QueryBuilder {
    public String buildSelectQuery(String table, String[] columns, String condition) {
        StringBuilder query = new StringBuilder("SELECT ");
        for (int i = 0; i < columns.length; i++) {
            query.append(columns[i]);
            if (i < columns.length - 1) {
                query.append(", ");
            }
        }
        query.append(" FROM ").append(table);
        if (condition != null && !condition.isEmpty()) {
            query.append(" WHERE ").append(condition);
        }
        return query.toString();
    }
}

// 子系统类 - 结果集处理器
class ResultSetProcessor {
    public void processResults(String queryResult) {
        System.out.println("Processing query results: " + queryResult);
    }
}

// 子系统类 - 事务管理器
class TransactionManager {
    public void beginTransaction() {
        System.out.println("Beginning transaction...");
    }
    
    public void commitTransaction() {
        System.out.println("Committing transaction...");
    }
    
    public void rollbackTransaction() {
        System.out.println("Rolling back transaction...");
    }
}

// 外观类 - 数据库访问外观
class DatabaseFacade {
    private ConnectionManager connectionManager;
    private QueryBuilder queryBuilder;
    private ResultSetProcessor resultSetProcessor;
    private TransactionManager transactionManager;
    
    public DatabaseFacade() {
        this.connectionManager = new ConnectionManager();
        this.queryBuilder = new QueryBuilder();
        this.resultSetProcessor = new ResultSetProcessor();
        this.transactionManager = new TransactionManager();
    }
    
    public void executeQuery(String table, String[] columns, String condition) {
        System.out.println("Executing database query through facade...");
        connectionManager.connect();
        transactionManager.beginTransaction();
        
        String query = queryBuilder.buildSelectQuery(table, columns, condition);
        System.out.println("Executing query: " + query);
        
        // 模拟查询执行和结果处理
        String result = "Sample query result";
        resultSetProcessor.processResults(result);
        
        transactionManager.commitTransaction();
        connectionManager.disconnect();
        System.out.println("Query executed successfully.\n");
    }
}
```

### 4.2 订单处理系统示例
```java
// 子系统类 - 库存管理
class InventoryService {
    public boolean checkStock(String productId, int quantity) {
        System.out.println("Checking stock for product " + productId + ": " + quantity + " units");
        // 模拟库存检查
        return true;
    }
    
    public void reserveStock(String productId, int quantity) {
        System.out.println("Reserving " + quantity + " units of product " + productId);
    }
    
    public void releaseStock(String productId, int quantity) {
        System.out.println("Releasing " + quantity + " units of product " + productId);
    }
}

// 子系统类 - 支付处理
class PaymentService {
    public boolean processPayment(double amount, String paymentMethod) {
        System.out.println("Processing payment of $" + amount + " using " + paymentMethod);
        // 模拟支付处理
        return true;
    }
    
    public void refundPayment(double amount) {
        System.out.println("Refunding $" + amount);
    }
}

// 子系统类 - 订单管理
class OrderService {
    public String createOrder(String customerId, String[] products) {
        System.out.println("Creating order for customer " + customerId);
        // 模拟订单创建
        return "ORDER-" + System.currentTimeMillis();
    }
    
    public void confirmOrder(String orderId) {
        System.out.println("Confirming order " + orderId);
    }
    
    public void cancelOrder(String orderId) {
        System.out.println("Canceling order " + orderId);
    }
}

// 子系统类 - 物流配送
class ShippingService {
    public String arrangeShipping(String orderId, String address) {
        System.out.println("Arranging shipping for order " + orderId + " to " + address);
        // 模拟物流安排
        return "SHIPPING-" + System.currentTimeMillis();
    }
    
    public void trackShipment(String trackingId) {
        System.out.println("Tracking shipment " + trackingId);
    }
}

// 外观类 - 订单处理外观
class OrderProcessingFacade {
    private InventoryService inventoryService;
    private PaymentService paymentService;
    private OrderService orderService;
    private ShippingService shippingService;
    
    public OrderProcessingFacade() {
        this.inventoryService = new InventoryService();
        this.paymentService = new PaymentService();
        this.orderService = new OrderService();
        this.shippingService = new ShippingService();
    }
    
    public String placeOrder(String customerId, String[] products, 
                            int[] quantities, double amount, 
                            String paymentMethod, String shippingAddress) {
        System.out.println("=== Placing Order ===");
        
        // 1. 检查库存
        for (int i = 0; i < products.length; i++) {
            if (!inventoryService.checkStock(products[i], quantities[i])) {
                System.out.println("Insufficient stock for product " + products[i]);
                return null;
            }
        }
        
        // 2. 预留库存
        for (int i = 0; i < products.length; i++) {
            inventoryService.reserveStock(products[i], quantities[i]);
        }
        
        // 3. 创建订单
        String orderId = orderService.createOrder(customerId, products);
        
        // 4. 处理支付
        if (!paymentService.processPayment(amount, paymentMethod)) {
            System.out.println("Payment failed, canceling order");
            orderService.cancelOrder(orderId);
            // 释放预留的库存
            for (int i = 0; i < products.length; i++) {
                inventoryService.releaseStock(products[i], quantities[i]);
            }
            return null;
        }
        
        // 5. 确认订单
        orderService.confirmOrder(orderId);
        
        // 6. 安排物流
        String trackingId = shippingService.arrangeShipping(orderId, shippingAddress);
        
        System.out.println("Order placed successfully!");
        System.out.println("Order ID: " + orderId);
        System.out.println("Tracking ID: " + trackingId);
        System.out.println("=====================\n");
        
        return orderId;
    }
}
```

## 5. 开源框架中的应用

### 5.1 Spring框架中的外观模式
Spring框架中的ApplicationContext就是外观模式的典型应用：

```java
// ApplicationContext作为外观，隐藏了BeanFactory、ResourceLoader、MessageSource等多个子系统的复杂性
/*
ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");

// 通过外观访问各种功能
MyBean bean = context.getBean(MyBean.class);
Resource resource = context.getResource("config.properties");
String message = context.getMessage("welcome.message", null, Locale.getDefault());
*/
```

### 5.2 SLF4J日志框架中的外观模式
SLF4J作为日志门面，为各种具体的日志实现提供了统一的接口：

```java
// SLF4J作为外观，隐藏了Logback、Log4j等具体实现的复杂性
/*
Logger logger = LoggerFactory.getLogger(MyClass.class);
logger.info("This is an info message");
logger.error("This is an error message");
*/
```

## 6. 优缺点分析

### 6.1 优点
1. **简化客户端使用**：客户端不需要了解子系统的复杂性，只需要与外观类交互
2. **松耦合**：客户端与子系统之间松耦合，子系统的改变不会影响客户端
3. **更好的层次结构**：可以为复杂的子系统提供多个不同级别的外观
4. **符合迪米特法则**：减少了客户端与子系统的依赖关系

### 6.2 缺点
1. **不符合开闭原则**：增加新的子系统可能需要修改外观类
2. **可能造成性能损失**：外观类可能包含客户端不需要的功能
3. **增加了系统层级**：虽然简化了客户端，但增加了系统的层级结构

## 7. 与其他模式的比较

### 7.1 与适配器模式的区别
- **外观模式**：目的是简化复杂子系统的使用，提供统一接口
- **适配器模式**：目的是让不兼容的接口能够协同工作

### 7.2 与中介者模式的区别
- **外观模式**：对子系统进行封装，客户端不知道子系统的存在
- **中介者模式**：封装了对象之间的交互，对象知道中介者的存在

### 7.3 与单例模式的结合
外观类通常可以设计为单例模式，因为整个系统通常只需要一个外观实例：

```java
class FacadeSingleton {
    private static FacadeSingleton instance;
    private SubSystemA subsystemA;
    private SubSystemB subsystemB;
    
    private FacadeSingleton() {
        subsystemA = new SubSystemA();
        subsystemB = new SubSystemB();
    }
    
    public static synchronized FacadeSingleton getInstance() {
        if (instance == null) {
            instance = new FacadeSingleton();
        }
        return instance;
    }
    
    public void operation() {
        subsystemA.operationA();
        subsystemB.operationB();
    }
}
```

## 8. 最佳实践建议

### 8.1 适用场景
1. 当你要为一个复杂子系统提供一个简单接口时
2. 客户程序与抽象类的实现部分之间存在着很大的依赖性
3. 当你需要构建一个层次结构的子系统时，使用外观模式定义子系统中每层的入口点

### 8.2 设计要点
1. **合理的职责划分**：外观类应该只负责协调子系统的调用，不应该包含业务逻辑
2. **保持子系统的可见性**：不应阻止客户端使用子系统类，外观类只是提供了一个额外的入口
3. **弱依赖性**：外观类与子系统类之间应该是弱依赖关系，尽量减少相互依赖

### 8.3 注意事项
1. **避免外观类过于臃肿**：外观类不应该包含过多的业务逻辑，否则会违背单一职责原则
2. **合理暴露子系统**：虽然提供了外观接口，但不应屏蔽客户端直接使用子系统类的能力
3. **考虑扩展性**：当增加新的子系统时，要考虑对外观类的影响

## 总结

外观模式是一种非常实用的结构型设计模式，它通过为复杂的子系统提供一个简化的接口，大大降低了客户端使用的复杂性。这种模式在各种框架和系统中都有广泛应用，如Spring框架、SLF4J日志框架等。正确使用外观模式可以让系统结构更加清晰，降低模块间的耦合度，提高系统的可维护性和可扩展性。