# 第十九章 观察者模式详解

## 本章概要
- 观察者模式的定义和概念
- 观察者模式的结构和组成
- 观察者模式的实现方式
- 实际应用场景分析
- 开源框架中的应用
- 观察者模式的优缺点
- 与其他设计模式的比较
- 最佳实践和注意事项

## 观察者模式概述

观察者模式（Observer Pattern），也被称为发布-订阅模式（Publish-Subscribe Pattern），是一种行为型设计模式。该模式定义了一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。

### 核心思想
观察者模式的核心思想是定义对象间的一对多依赖关系，使得当一个对象改变状态时，其所有依赖者都会收到通知并自动更新。这种模式将观察目标和观察者解耦，使得它们可以独立地变化。

### 应用场景
1. 当一个对象的改变需要同时改变其他对象，而且不知道具体有多少对象有待改变时
2. 当一个抽象模型有两个方面，其中一个方面依赖于另一方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用
3. GUI事件处理系统，如按钮点击、鼠标移动等
4. MVC架构模式中的视图更新机制
5. 消息订阅系统，如新闻订阅、邮件通知等
6. 事件驱动系统

## 观察者模式结构

观察者模式包含以下角色：
1. **Subject（主题/被观察者）**：也称为目标，它是指被观察的对象。在主题中定义了一个观察者集合，一个主题可以接受任意数量的观察者。主题提供一系列方法来增加和删除观察者对象
2. **Observer（观察者）**：为那些在主题发生改变时需获得通知的对象定义一个更新接口
3. **ConcreteSubject（具体主题）**：将有关状态存入各ConcreteObserver对象；当它的状态发生改变时，向它的各个观察者发出通知
4. **ConcreteObserver（具体观察者）**：维护一个指向ConcreteSubject对象的引用；存储有关状态，这些状态应与主题的状态保持一致；实现Observer的更新接口以使自身状态与主题的状态保持一致

## 观察者模式实现

### 基本实现

```java
import java.util.*;

// 抽象观察者
interface Observer {
    void update(String message);
}

// 抽象主题
abstract class Subject {
    protected List<Observer> observers = new ArrayList<>();
    
    // 添加观察者
    public void addObserver(Observer observer) {
        observers.add(observer);
    }
    
    // 删除观察者
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }
    
    // 通知所有观察者
    protected void notifyObservers(String message) {
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}

// 具体主题
class ConcreteSubject extends Subject {
    private String state;
    
    public String getState() {
        return state;
    }
    
    public void setState(String state) {
        this.state = state;
        // 状态改变时通知所有观察者
        notifyObservers("状态已更新为: " + state);
    }
}

// 具体观察者
class ConcreteObserver implements Observer {
    private String name;
    
    public ConcreteObserver(String name) {
        this.name = name;
    }
    
    @Override
    public void update(String message) {
        System.out.println(name + " 收到通知: " + message);
    }
}
```

### 更复杂的实现示例

让我们通过一个新闻发布系统来展示更复杂的实现。

## 实际应用示例

### 1. 新闻发布系统

```java
import java.util.*;

// 新闻观察者接口
interface NewsObserver {
    void updateNews(String category, String news);
}

// 抽象新闻主题
abstract class NewsSubject {
    protected List<NewsObserver> observers = new ArrayList<>();
    
    // 订阅
    public void subscribe(NewsObserver observer) {
        observers.add(observer);
    }
    
    // 取消订阅
    public void unsubscribe(NewsObserver observer) {
        observers.remove(observer);
    }
    
    // 通知观察者
    protected void notifyObservers(String category, String news) {
        for (NewsObserver observer : observers) {
            observer.updateNews(category, news);
        }
    }
}

// 新闻发布者
class NewsPublisher extends NewsSubject {
    private Map<String, List<String>> newsCategories;
    
    public NewsPublisher() {
        this.newsCategories = new HashMap<>();
    }
    
    // 发布新闻
    public void publishNews(String category, String news) {
        newsCategories.computeIfAbsent(category, k -> new ArrayList<>()).add(news);
        System.out.println("发布[" + category + "]新闻: " + news);
        // 通知所有订阅者
        notifyObservers(category, news);
    }
    
    // 获取某类别的所有新闻
    public List<String> getNewsByCategory(String category) {
        return newsCategories.getOrDefault(category, new ArrayList<>());
    }
}

// 新闻订阅者 - 用户
class User implements NewsObserver {
    private String name;
    private Set<String> subscribedCategories;
    
    public User(String name) {
        this.name = name;
        this.subscribedCategories = new HashSet<>();
    }
    
    // 订阅类别
    public void subscribeCategory(String category) {
        subscribedCategories.add(category);
        System.out.println(name + " 订阅了 [" + category + "] 类别");
    }
    
    // 取消订阅类别
    public void unsubscribeCategory(String category) {
        subscribedCategories.remove(category);
        System.out.println(name + " 取消订阅了 [" + category + "] 类别");
    }
    
    @Override
    public void updateNews(String category, String news) {
        // 只接收订阅类别的新闻
        if (subscribedCategories.contains(category)) {
            System.out.println(name + " 收到 [" + category + "] 新闻: " + news);
        }
    }
}
```

### 2. 股票价格监控系统

```java
import java.util.*;

// 股票观察者接口
interface StockObserver {
    void update(String stockSymbol, double price);
}

// 股票主题抽象类
abstract class StockSubject {
    protected List<StockObserver> observers = new ArrayList<>();
    
    public void addObserver(StockObserver observer) {
        observers.add(observer);
    }
    
    public void removeObserver(StockObserver observer) {
        observers.remove(observer);
    }
    
    protected void notifyObservers(String stockSymbol, double price) {
        for (StockObserver observer : observers) {
            observer.update(stockSymbol, price);
        }
    }
}

// 股票价格监控系统
class StockPriceMonitor extends StockSubject {
    private Map<String, Double> stockPrices;
    
    public StockPriceMonitor() {
        this.stockPrices = new HashMap<>();
    }
    
    // 更新股票价格
    public void updateStockPrice(String stockSymbol, double price) {
        Double oldPrice = stockPrices.get(stockSymbol);
        stockPrices.put(stockSymbol, price);
        
        if (oldPrice == null || oldPrice != price) {
            System.out.println("股票 " + stockSymbol + " 价格更新为: " + price);
            notifyObservers(stockSymbol, price);
        }
    }
    
    // 获取股票当前价格
    public Double getStockPrice(String stockSymbol) {
        return stockPrices.get(stockSymbol);
    }
}

// 股票投资者
class Investor implements StockObserver {
    private String name;
    private Map<String, Double> watchedStocks; // 关注的股票及阈值
    
    public Investor(String name) {
        this.name = name;
        this.watchedStocks = new HashMap<>();
    }
    
    // 添加关注的股票及预警价格
    public void watchStock(String stockSymbol, double alertPrice) {
        watchedStocks.put(stockSymbol, alertPrice);
        System.out.println(name + " 开始关注股票: " + stockSymbol + ", 预警价格: " + alertPrice);
    }
    
    @Override
    public void update(String stockSymbol, double price) {
        Double alertPrice = watchedStocks.get(stockSymbol);
        if (alertPrice != null) {
            if (price >= alertPrice) {
                System.out.println("【警告】" + name + ": 股票 " + stockSymbol + " 当前价格 " + price + 
                                 " 已达到或超过预警价格 " + alertPrice + "，建议卖出！");
            } else if (price <= alertPrice * 0.9) { // 价格下跌超过10%
                System.out.println("【提醒】" + name + ": 股票 " + stockSymbol + " 当前价格 " + price + 
                                 " 较预警价格 " + alertPrice + " 下跌超过10%，可考虑买入！");
            }
        }
    }
}
```

## 开源框架中的应用

1. **Java Swing/AWT**：事件处理机制大量使用了观察者模式，各种UI组件的事件监听器就是观察者模式的应用
2. **Spring Framework**：Spring的事件驱动模型（ApplicationEvent和ApplicationListener）采用了观察者模式
3. **RxJava**：响应式编程库，基于观察者模式实现了异步数据流处理
4. **Vue.js**：前端框架的数据绑定和响应式系统使用了观察者模式的思想

## 观察者模式的优缺点

### 优点
1. **松耦合**：观察者模式实现了主题和观察者之间的松耦合，主题不需要知道观察者的具体类型，只需要通过一个通用的接口进行通知
2. **支持广播通信**：观察者模式支持广播通信，类似于消息广播，如果需要接收消息，只需要注册一下即可
3. **符合开闭原则**：增加新的具体观察者无须修改原有代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便
4. **动态关联**：观察者模式建立了触发机制，可以在运行时动态地建立和解除观察者与主题之间的联系

### 缺点
1. **依赖过多**：观察者之间细节依赖过多，会增加时间和空间开销，如果观察者和主题之间存在循环依赖，可能导致系统崩溃
2. **通知顺序不确定**：观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化，且通知顺序无法保证
3. **内存泄漏风险**：如果没有正确地移除观察者，可能会导致内存泄漏问题，特别是在长时间运行的应用中

## 与其他设计模式的比较

1. **与中介者模式的区别**：中介者模式用于封装一系列对象的交互，使对象之间不再显式地相互引用，从而使其耦合松散；而观察者模式定义了一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新
2. **与责任链模式的区别**：责任链模式主要解决请求的发送者和接收者之间的耦合，让多个对象都有机会处理这个请求；而观察者模式则是解决对象之间一对多的依赖关系

## 最佳实践和注意事项

1. **避免循环依赖**：确保观察者和主题之间不存在循环依赖，否则可能引发无限递归调用导致栈溢出
2. **及时清理观察者**：在观察者不再需要接收通知时，应及时将其从主题中移除，避免内存泄漏
3. **考虑通知顺序**：如果观察者之间有依赖关系，需要考虑通知的顺序，必要时可以对观察者进行排序
4. **异常处理**：在通知观察者时应该进行异常处理，避免一个观察者的异常影响其他观察者的执行
5. **线程安全**：在多线程环境中使用观察者模式时，需要考虑线程安全问题，对观察者列表的操作应该同步