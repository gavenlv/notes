# 第二十二章 模板方法模式详解

## 本章概要
- 模板方法模式的定义和概念
- 模板方法模式的结构和组成
- 模板方法模式的实现方式
- 实际应用场景分析
- 开源框架中的应用
- 模板方法模式的优缺点
- 与其他设计模式的比较
- 最佳实践和注意事项

## 模板方法模式概述

模板方法模式（Template Method Pattern）是一种行为型设计模式，它定义了一个操作中的算法骨架，而将一些步骤延迟到子类中实现。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些特定步骤。

### 核心思想
模板方法模式的核心思想是定义一个操作中的算法骨架，而将一些步骤延迟到子类中实现。这样可以让子类在不改变算法结构的情况下重新定义算法的某些特定步骤。模板方法模式是基于继承的代码复用技术，它使得算法的骨架在父类中定义，而具体步骤的实现在子类中定义。

### 应用场景
1. 当需要一次性实现一个算法的不变部分，并将可变的行为留给子类来实现时
2. 当各个子类中拥有公共行为，应该抽取出来集中到一个公共父类中以避免代码重复时
3. 当需要控制子类的扩展时，模板方法只在特定点调用"钩子"操作，这样就只允许在这些点进行扩展
4. 当多个子类中有共同的行为时，可以将这些共同的行为提取到一个公共的父类中，避免代码重复
5. 当需要通过父类来控制子类的执行顺序时

## 模板方法模式结构

模板方法模式包含以下角色：
1. **AbstractClass（抽象类）**：实现一个模板方法，定义了算法的骨架，通常还会包含一些基本操作、模板方法、钩子方法等
2. **ConcreteClass（具体类）**：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤

## 模板方法模式实现

### 基本实现

```java
// 抽象模板类
abstract class Game {
    // 模板方法，定义游戏的流程
    public final void play() {
        // 初始化游戏
        initialize();
        
        // 开始游戏
        startPlay();
        
        // 进行游戏
        endPlay();
    }
    
    // 基本方法 - 初始化游戏
    abstract void initialize();
    
    // 基本方法 - 开始游戏
    abstract void startPlay();
    
    // 基本方法 - 结束游戏
    abstract void endPlay();
    
    // 钩子方法 - 默认实现
    void endPlay() {
        System.out.println("Game Finished!");
    }
}

// 具体游戏类 - 板球游戏
class Cricket extends Game {
    @Override
    void initialize() {
        System.out.println("Cricket Game Initialized! Start playing.");
    }
    
    @Override
    void startPlay() {
        System.out.println("Cricket Game Started. Enjoy the game!");
    }
    
    @Override
    void endPlay() {
        System.out.println("Cricket Game Finished!");
    }
}

// 具体游戏类 - 足球游戏
class Football extends Game {
    @Override
    void initialize() {
        System.out.println("Football Game Initialized! Start playing.");
    }
    
    @Override
    void startPlay() {
        System.out.println("Football Game Started. Enjoy the game!");
    }
    
    @Override
    void endPlay() {
        System.out.println("Football Game Finished!");
    }
}
```

### 更复杂的实现示例

让我们通过一个制作饮料的例子来展示更复杂的实现。

## 实际应用示例

### 1. 制作咖啡和茶

```java
// 抽象模板类 - 饮料制作
abstract class BeverageMaker {
    // 模板方法 - 定义制作饮料的流程
    public final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }
    
    // 基本方法 - 煮水（通用步骤）
    void boilWater() {
        System.out.println("Boiling water");
    }
    
    // 抽象方法 - 冲泡（由子类实现）
    abstract void brew();
    
    // 基本方法 - 倒入杯中（通用步骤）
    void pourInCup() {
        System.out.println("Pouring into cup");
    }
    
    // 抽象方法 - 添加调料（由子类实现）
    abstract void addCondiments();
}

// 具体类 - 制作咖啡
class Coffee extends BeverageMaker {
    @Override
    void brew() {
        System.out.println("Dripping Coffee through filter");
    }
    
    @Override
    void addCondiments() {
        System.out.println("Adding Sugar and Milk");
    }
}

// 具体类 - 制作茶
class Tea extends BeverageMaker {
    @Override
    void brew() {
        System.out.println("Steeping the tea");
    }
    
    @Override
    void addCondiments() {
        System.out.println("Adding Lemon");
    }
}
```

### 2. 数据处理流程

```java
// 抽象模板类 - 数据处理器
abstract class DataProcessor {
    // 模板方法 - 定义数据处理流程
    public final void processData() {
        readData();
        processDataSteps();
        saveData();
        if (isPostProcessingNeeded()) {
            postProcess();
        }
    }
    
    // 基本方法 - 读取数据
    abstract void readData();
    
    // 基本方法 - 处理数据步骤
    private void processDataSteps() {
        validateData();
        transformData();
        aggregateData();
    }
    
    // 基本方法 - 验证数据
    void validateData() {
        System.out.println("Validating data");
    }
    
    // 基本方法 - 转换数据
    void transformData() {
        System.out.println("Transforming data");
    }
    
    // 基本方法 - 聚合数据
    void aggregateData() {
        System.out.println("Aggregating data");
    }
    
    // 基本方法 - 保存数据
    abstract void saveData();
    
    // 钩子方法 - 是否需要后处理
    boolean isPostProcessingNeeded() {
        return false; // 默认不需要后处理
    }
    
    // 钩子方法 - 后处理
    void postProcess() {
        System.out.println("Performing post-processing");
    }
}

// 具体类 - XML数据处理器
class XMLDataProcessor extends DataProcessor {
    @Override
    void readData() {
        System.out.println("Reading data from XML file");
    }
    
    @Override
    void saveData() {
        System.out.println("Saving data to XML file");
    }
    
    @Override
    boolean isPostProcessingNeeded() {
        return true; // XML数据需要后处理
    }
    
    @Override
    void postProcess() {
        System.out.println("Performing XML-specific post-processing");
    }
}

// 具体类 - JSON数据处理器
class JSONDataProcessor extends DataProcessor {
    @Override
    void readData() {
        System.out.println("Reading data from JSON file");
    }
    
    @Override
    void saveData() {
        System.out.println("Saving data to JSON file");
    }
}
```

## 开源框架中的应用

1. **Servlet框架**：HttpServlet类中的service()方法就是一个模板方法，它定义了处理HTTP请求的流程，而doGet()、doPost()等方法由子类实现
2. **Spring框架**：在Spring的JdbcTemplate、HibernateTemplate等类中使用了模板方法模式，提供了数据库操作的通用流程
3. **JUnit测试框架**：TestCase类中的run()方法是模板方法，定义了测试执行的流程
4. **Android开发**：Activity类中的生命周期方法如onCreate()、onStart()、onResume()等都是模板方法模式的应用

## 模板方法模式的优缺点

### 优点
1. **封装不变部分，扩展可变部分**：把认为是不变的行为抽取到父类中实现，而可变的行为由子类来实现，便于子类的扩展
2. **提取公共代码，便于维护**：将公共的行为抽取到父类中，提高了代码的复用率，减少了代码冗余
3. **行为由父类控制，子类实现**：通过父类调用子类实现的效果，通过对子类的扩展增加新的行为，符合开闭原则
4. **便于控制子类扩展**：父类定义好了模板方法，只允许子类在特定的位置进行扩展，而不允许覆盖模板方法

### 缺点
1. **继承强耦合**：子类必须依赖父类的抽象方法定义，存在继承关系的强耦合
2. **算法复杂度高**：如果父类的方法过多，可能会导致类的层次结构变得复杂
3. **违反里氏替换原则**：在添加新的子类时，可能需要修改父类的代码
4. **增加了类的数量**：每一个不同的实现都需要一个子类来实现，这会增加系统的复杂度

## 与其他设计模式的比较

1. **与策略模式的区别**：模板方法模式使用继承来改变算法的一部分，而策略模式使用委托来改变整个算法
2. **与工厂方法模式的区别**：工厂方法模式是模板方法模式的一个特殊应用，父类定义创建产品对象的算法骨架，而具体创建工作由子类实现
3. **与建造者模式的区别**：建造者模式关注的是如何一步步构建一个复杂对象，而模板方法模式关注的是定义算法的骨架
4. **与状态模式的区别**：状态模式允许对象在内部状态改变时改变其行为，而模板方法模式是在子类中实现算法的不同部分

## 最佳实践和注意事项

1. **合理使用钩子方法**：钩子方法可以让子类有机会参与到父类的算法执行过程中，增加了灵活性
2. **模板方法应使用final修饰**：为了防止子类重写模板方法，破坏算法的执行流程
3. **抽象方法数量要适中**：抽象方法过多会导致子类实现复杂，过少则不能发挥模板方法模式的优势
4. **命名规范**：模板方法通常以do开头，如doProcess()，以便区分普通方法和模板方法
5. **文档注释**：在抽象类中要清楚地标明哪些方法是模板方法，哪些是基本方法，哪些是钩子方法
6. **避免过度设计**：如果算法步骤较少或者变化不大，使用模板方法模式可能是过度设计
7. **考虑使用回调**：在某些情况下，可以使用回调代替继承来实现类似的效果