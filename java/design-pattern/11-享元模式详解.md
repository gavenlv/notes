# 第十一章 享元模式详解

## 1. 享元模式概述

### 1.1 定义
享元模式(Flyweight Pattern)是一种结构型设计模式，它运用共享技术有效地支持大量细粒度的对象。享元模式通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统效率。

### 1.2 核心思想
享元模式的核心思想是"共享"。它将对象的状态分为内部状态和外部状态：
- **内部状态(Intrinsic State)**：存储在享元对象内部，不会随环境改变而变化，这些是可以共享的信息
- **外部状态(Extrinsic State)**：随环境改变而改变，不可以共享，需要由客户端保存并在使用享元对象时传递给它

## 2. 享元模式结构

享元模式包含以下角色：

1. **Flyweight(抽象享元类)**：声明一个接口，通过它可以接受并作用于外部状态
2. **ConcreteFlyweight(具体享元类)**：实现抽象享元接口，为内部状态提供存储空间
3. **UnsharedConcreteFlyweight(非共享具体享元类)**：指出那些不需要共享的Flyweight子类
4. **FlyweightFactory(享元工厂类)**：用来创建并管理Flyweight对象，确保合理地共享Flyweight

## 3. 享元模式实现

### 3.1 基本实现
```java
import java.util.HashMap;
import java.util.Map;

// 抽象享元类
interface Shape {
    void draw(int x, int y, String color);
}

// 具体享元类
class Circle implements Shape {
    private String color;
    
    public Circle(String color) {
        this.color = color;
        System.out.println("Creating circle of color : " + color);
    }
    
    @Override
    public void draw(int x, int y, String color) {
        System.out.println("Circle: Draw() [Color : " + color + ", x : " + x + ", y :" + y + "]");
    }
}

// 享元工厂类
class ShapeFactory {
    private static final Map<String, Shape> circleMap = new HashMap<>();
    
    public static Shape getCircle(String color) {
        Circle circle = (Circle)circleMap.get(color);
        
        if(circle == null) {
            circle = new Circle(color);
            circleMap.put(color, circle);
            System.out.println("Creating circle of color : " + color);
        }
        return circle;
    }
}
```

### 3.2 完整示例 - 森林绘制系统
```java
import java.awt.*;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

// 抽象享元类 - 树类型
class TreeType {
    private String name;
    private Color color;
    private String otherTreeData;
    
    public TreeType(String name, Color color, String otherTreeData) {
        this.name = name;
        this.color = color;
        this.otherTreeData = otherTreeData;
    }
    
    public void draw(Graphics g, int x, int y) {
        g.setColor(Color.BLACK);
        g.fillRect(x - 1, y, 3, 5);
        g.setColor(color);
        g.fillOval(x - 5, y - 10, 10, 10);
    }
    
    public String getName() {
        return name;
    }
    
    public Color getColor() {
        return color;
    }
}

// 享元工厂类
class TreeFactory {
    static Map<String, TreeType> treeTypes = new HashMap<>();
    
    public static TreeType getTreeType(String name, Color color, String otherTreeData) {
        TreeType result = treeTypes.get(name);
        if (result == null) {
            result = new TreeType(name, color, otherTreeData);
            treeTypes.put(name, result);
            System.out.println("Created tree type: " + name);
        }
        return result;
    }
}

// 树类 - 包含外部状态
class Tree {
    private int x, y;
    private TreeType type;
    
    public Tree(int x, int y, TreeType type) {
        this.x = x;
        this.y = y;
        this.type = type;
    }
    
    public void draw(Graphics g) {
        type.draw(g, x, y);
    }
}

// 森林类
class Forest {
    private java.util.List<Tree> trees = new java.util.ArrayList<>();
    
    public void plantTree(int x, int y, String name, Color color, String otherTreeData) {
        TreeType type = TreeFactory.getTreeType(name, color, otherTreeData);
        Tree tree = new Tree(x, y, type);
        trees.add(tree);
    }
    
    public void draw(Graphics g) {
        for (Tree tree : trees) {
            tree.draw(g);
        }
    }
}
```

## 4. 实际应用示例

### 4.1 文档编辑器字符格式化
```java
import java.awt.*;
import java.util.HashMap;
import java.util.Map;

// 字符格式类 - 享元对象
class CharacterFormat {
    private Font font;
    private Color color;
    private boolean bold;
    
    public CharacterFormat(Font font, Color color, boolean bold) {
        this.font = font;
        this.color = color;
        this.bold = bold;
    }
    
    public void format(char character, Graphics g, int x, int y) {
        // 应用格式到字符
        System.out.println("Formatting character '" + character + "' with font " + 
                          font.getName() + ", color " + color.toString() + 
                          ", bold: " + bold + " at (" + x + ", " + y + ")");
    }
    
    // Getters
    public Font getFont() { return font; }
    public Color getColor() { return color; }
    public boolean isBold() { return bold; }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        CharacterFormat that = (CharacterFormat) obj;
        return bold == that.bold &&
               java.util.Objects.equals(font, that.font) &&
               java.util.Objects.equals(color, that.color);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(font, color, bold);
    }
}

// 字符格式工厂
class FormatFactory {
    private static final Map<CharacterFormat, CharacterFormat> formats = new HashMap<>();
    
    public static CharacterFormat getFormat(Font font, Color color, boolean bold) {
        CharacterFormat key = new CharacterFormat(font, color, bold);
        CharacterFormat format = formats.get(key);
        
        if (format == null) {
            format = new CharacterFormat(font, color, bold);
            formats.put(format, format);
            System.out.println("Created new character format: " + font.getName() + 
                             ", " + color.toString() + ", bold=" + bold);
        }
        return format;
    }
}

// 文档字符类 - 包含外部状态
class DocumentCharacter {
    private char character;
    private int x, y;
    private CharacterFormat format;
    
    public DocumentCharacter(char character, int x, int y, CharacterFormat format) {
        this.character = character;
        this.x = x;
        this.y = y;
        this.format = format;
    }
    
    public void draw(Graphics g) {
        format.format(character, g, x, y);
    }
}
```

### 4.2 游戏单位系统
```java
// 单位类型 - 享元对象
class UnitType {
    private String name;
    private int health;
    private int attackPower;
    private String texture;
    private String sound;
    
    public UnitType(String name, int health, int attackPower, String texture, String sound) {
        this.name = name;
        this.health = health;
        this.attackPower = attackPower;
        this.texture = texture;
        this.sound = sound;
    }
    
    public void render(Graphics g, int x, int y) {
        System.out.println("Rendering " + name + " at (" + x + ", " + y + ") with texture: " + texture);
    }
    
    public void playSound() {
        System.out.println("Playing sound: " + sound);
    }
    
    // Getters
    public String getName() { return name; }
    public int getHealth() { return health; }
    public int getAttackPower() { return attackPower; }
}

// 单位类型工厂
class UnitTypeFactory {
    private static Map<String, UnitType> unitTypes = new HashMap<>();
    
    public static UnitType getUnitType(String name, int health, int attackPower, 
                                      String texture, String sound) {
        UnitType type = unitTypes.get(name);
        if (type == null) {
            type = new UnitType(name, health, attackPower, texture, sound);
            unitTypes.put(name, type);
            System.out.println("Created unit type: " + name);
        }
        return type;
    }
}

// 游戏单位类 - 包含外部状态
class GameUnit {
    private int x, y;
    private UnitType type;
    private int currentHealth;
    
    public GameUnit(int x, int y, UnitType type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.currentHealth = type.getHealth();
    }
    
    public void move(int newX, int newY) {
        this.x = newX;
        this.y = newY;
        System.out.println(type.getName() + " moved to (" + x + ", " + y + ")");
    }
    
    public void render(Graphics g) {
        type.render(g, x, y);
    }
    
    public void attack(GameUnit target) {
        System.out.println(type.getName() + " attacks " + target.type.getName() + 
                          " with " + type.getAttackPower() + " damage");
        type.playSound();
    }
}
```

## 5. 开源框架中的应用

### 5.1 Java String常量池
Java中的String常量池就是享元模式的经典应用：

```java
// String常量池示例
public class StringPoolExample {
    public static void main(String[] args) {
        String s1 = "Hello";
        String s2 = "Hello";
        String s3 = new String("Hello");
        String s4 = s3.intern();
        
        System.out.println(s1 == s2);  // true - 指向同一个对象
        System.out.println(s1 == s3);  // false - 不同的对象
        System.out.println(s1 == s4);  // true - intern()返回常量池中的引用
    }
}
```

### 5.2 Integer缓存机制
Java的Integer类也使用了享元模式：

```java
// Integer缓存示例
public class IntegerCacheExample {
    public static void main(String[] args) {
        Integer i1 = 127;
        Integer i2 = 127;
        Integer i3 = 128;
        Integer i4 = 128;
        
        System.out.println(i1 == i2);  // true - 在缓存范围内(-128到127)
        System.out.println(i3 == i4);  // false - 超出缓存范围
    }
}
```

## 6. 优缺点分析

### 6.1 优点
1. **节省内存空间**：通过共享对象，大幅减少对象数量，节省内存
2. **提高性能**：减少创建和销毁对象的开销，提高系统性能
3. **集中管理**：享元工厂可以集中管理对象的创建和复用

### 6.2 缺点
1. **增加系统复杂性**：需要区分内部状态和外部状态，增加了系统复杂性
2. **外部状态开销**：需要维护外部状态，可能会带来额外的开销
3. **线程安全问题**：在多线程环境下需要考虑享元对象的线程安全

## 7. 与其他模式的比较

### 7.1 与单例模式的区别
- **享元模式**：关注的是通过共享来减少对象数量
- **单例模式**：确保一个类只有一个实例

### 7.2 与状态模式的区别
- **享元模式**：通过共享减少对象数量
- **状态模式**：允许对象在其内部状态改变时改变其行为

### 7.3 与组合模式的结合
享元模式经常与组合模式一起使用，在组合模式的叶子节点上应用享元模式：

```java
// 组合模式与享元模式结合示例
abstract class Graphic {
    public abstract void draw(Graphics g);
}

// 享元叶子节点
class Glyph extends Graphic {
    private char character;
    private CharacterFormat format;  // 享元对象
    
    public Glyph(char character, CharacterFormat format) {
        this.character = character;
        this.format = format;
    }
    
    @Override
    public void draw(Graphics g) {
        // 使用享元的格式来绘制字符
        format.format(character, g, 0, 0);
    }
}
```

## 8. 最佳实践建议

### 8.1 适用场景
1. 系统中有大量相似对象
2. 需要缓冲池的场景
3. 对象的大多数状态都可以外部化
4. 按需多次创建大量对象导致内存占用过大

### 8.2 设计要点
1. **正确识别内外部状态**：这是享元模式的关键，必须准确区分哪些状态可以共享，哪些不能
2. **合理设计工厂类**：工厂类负责创建和管理享元对象，需要保证线程安全
3. **考虑线程安全**：如果在多线程环境中使用，需要考虑享元对象的线程安全问题

### 8.3 注意事项
1. **不要过度使用**：只有在确实需要大量相似对象且内存成为瓶颈时才使用
2. **外部状态管理**：客户端需要负责管理和传递外部状态，增加了复杂性
3. **性能权衡**：虽然节省了内存，但可能增加了CPU开销用于管理外部状态

## 总结

享元模式是一种重要的结构型设计模式，特别适用于需要创建大量相似对象的场景。通过区分内部状态和外部状态，并共享内部状态相同的对象，可以显著减少内存占用和提高系统性能。Java中的String常量池和Integer缓存都是享元模式的经典应用。正确使用享元模式需要仔细分析对象的状态，合理设计工厂类，并注意线程安全问题。