# 第2章 单例模式详解

## 2.1 单例模式概述

### 2.1.1 定义

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

单例模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

### 2.1.2 特点

1. 单例类只能有一个实例
2. 单例类必须自己创建自己的唯一实例
3. 单例类必须给所有其他对象提供这一实例

### 2.1.3 应用场景

1. 需要频繁实例化然后销毁的对象
2. 创建对象时耗时过多或耗资源过多，但又经常用到的对象
3. 系统只需要一个实例对象，如系统中的序列号生成器
4. 工具类对象，如日志工具、数据库连接池等

## 2.2 单例模式的实现方式

### 2.2.1 饿汉式（线程安全）

饿汉式是在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快，是线程安全的。

```java
public class EagerSingleton {
    // 在类加载时就完成实例化
    private static final EagerSingleton INSTANCE = new EagerSingleton();
    
    // 私有构造方法，防止外部实例化
    private EagerSingleton() {}
    
    // 提供全局访问点
    public static EagerSingleton getInstance() {
        return INSTANCE;
    }
    
    public void showMessage() {
        System.out.println("这是饿汉式单例模式");
    }
}
```

**优点**：
- 线程安全
- 获取对象速度快

**缺点**：
- 类加载时就实例化对象，可能造成内存浪费

### 2.2.2 懒汉式（线程不安全）

懒汉式是最基本的实现方式，延迟加载，只有在使用的时候才会实例化。

```java
public class LazySingleton {
    private static LazySingleton instance;
    
    private LazySingleton() {}
    
    public static LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }
    
    public void showMessage() {
        System.out.println("这是懒汉式单例模式（线程不安全）");
    }
}
```

**优点**：
- 实现简单
- 延迟加载

**缺点**：
- 线程不安全，在多线程环境下可能会创建多个实例

### 2.2.3 懒汉式（线程安全，同步方法）

为了解决线程不安全问题，可以在getInstance方法上加synchronized关键字。

```java
public class ThreadSafeLazySingleton {
    private static ThreadSafeLazySingleton instance;
    
    private ThreadSafeLazySingleton() {}
    
    // 同步方法，保证线程安全
    public static synchronized ThreadSafeLazySingleton getInstance() {
        if (instance == null) {
            instance = new ThreadSafeLazySingleton();
        }
        return instance;
    }
    
    public void showMessage() {
        System.out.println("这是线程安全的懒汉式单例模式");
    }
}
```

**优点**：
- 线程安全
- 延迟加载

**缺点**：
- 效率低，每次调用getInstance方法都需要进行同步

### 2.2.4 双重检查锁定（推荐）

采用双重检查锁定，在getSingleton()方法中，进行两次null检查，这样可以极大提升并发度，进而提升性能。

```java
public class DoubleCheckLockingSingleton {
    // volatile关键字确保多线程环境下的可见性
    private static volatile DoubleCheckLockingSingleton instance;
    
    private DoubleCheckLockingSingleton() {}
    
    public static DoubleCheckLockingSingleton getInstance() {
        // 第一次检查
        if (instance == null) {
            synchronized (DoubleCheckLockingSingleton.class) {
                // 第二次检查
                if (instance == null) {
                    instance = new DoubleCheckLockingSingleton();
                }
            }
        }
        return instance;
    }
    
    public void showMessage() {
        System.out.println("这是双重检查锁定单例模式");
    }
}
```

**优点**：
- 线程安全
- 延迟加载
- 效率较高

**缺点**：
- 实现稍复杂

### 2.2.5 静态内部类（推荐）

这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。

```java
public class StaticInnerClassSingleton {
    
    private StaticInnerClassSingleton() {}
    
    // 静态内部类
    private static class SingletonHolder {
        private static final StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton();
    }
    
    public static StaticInnerClassSingleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
    
    public void showMessage() {
        System.out.println("这是静态内部类单例模式");
    }
}
```

**优点**：
- 线程安全
- 延迟加载
- 实现简单

**原理**：
- 利用了ClassLoader机制，保证了线程安全
- 只有在调用getInstance方法时，才会装载SingletonHolder类，从而完成实例化

### 2.2.6 枚举实现（推荐）

这是实现单例模式的最佳方法，简洁，自动支持序列化机制，绝对防止多次实例化。

```java
public enum EnumSingleton {
    INSTANCE;
    
    public void showMessage() {
        System.out.println("这是枚举单例模式");
    }
    
    public void doSomething() {
        System.out.println("执行某些操作");
    }
}
```

**优点**：
- 线程安全
- 防止反序列化重新创建新的对象
- 实现简单

**缺点**：
- 不支持延迟加载

## 2.3 单例模式的破坏及防范

### 2.3.1 反射破坏及防范

通过反射可以破坏单例模式，可以通过在构造方法中添加判断来防止：

```java
public class ReflectionSafeSingleton {
    private static volatile ReflectionSafeSingleton instance;
    
    private ReflectionSafeSingleton() {
        // 防止反射破坏单例
        if (instance != null) {
            throw new RuntimeException("不能通过反射创建实例！");
        }
    }
    
    public static ReflectionSafeSingleton getInstance() {
        if (instance == null) {
            synchronized (ReflectionSafeSingleton.class) {
                if (instance == null) {
                    instance = new ReflectionSafeSingleton();
                }
            }
        }
        return instance;
    }
}
```

### 2.3.2 序列化破坏及防范

序列化和反序列化也会破坏单例，可以通过添加readResolve方法来防止：

```java
public class SerializationSafeSingleton implements Serializable {
    private static final long serialVersionUID = 1L;
    private static volatile SerializationSafeSingleton instance;
    
    private SerializationSafeSingleton() {}
    
    public static SerializationSafeSingleton getInstance() {
        if (instance == null) {
            synchronized (SerializationSafeSingleton.class) {
                if (instance == null) {
                    instance = new SerializationSafeSingleton();
                }
            }
        }
        return instance;
    }
    
    // 防止序列化破坏单例
    private Object readResolve() {
        return instance;
    }
}
```

## 2.4 单例模式的实际应用

### 2.4.1 日志记录器

```java
public class Logger {
    private static volatile Logger instance;
    private StringBuilder logContent;
    
    private Logger() {
        logContent = new StringBuilder();
    }
    
    public static Logger getInstance() {
        if (instance == null) {
            synchronized (Logger.class) {
                if (instance == null) {
                    instance = new Logger();
                }
            }
        }
        return instance;
    }
    
    public void log(String message) {
        logContent.append(new java.util.Date()).append(": ").append(message).append("\n");
        System.out.println("LOG: " + message);
    }
    
    public String getLogContent() {
        return logContent.toString();
    }
}
```

### 2.4.2 数据库连接池

```java
import java.util.LinkedList;
import java.sql.Connection;
import java.sql.DriverManager;

public class DatabaseConnectionPool {
    private static volatile DatabaseConnectionPool instance;
    private LinkedList<Connection> connectionPool;
    private static final int POOL_SIZE = 10;
    
    private DatabaseConnectionPool() {
        initializePool();
    }
    
    public static DatabaseConnectionPool getInstance() {
        if (instance == null) {
            synchronized (DatabaseConnectionPool.class) {
                if (instance == null) {
                    instance = new DatabaseConnectionPool();
                }
            }
        }
        return instance;
    }
    
    private void initializePool() {
        connectionPool = new LinkedList<>();
        try {
            // 初始化连接池
            for (int i = 0; i < POOL_SIZE; i++) {
                // 注意：这里简化了数据库连接的创建过程
                Connection conn = DriverManager.getConnection(
                    "jdbc:mysql://localhost:3306/test", "user", "password");
                connectionPool.add(conn);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    public synchronized Connection getConnection() {
        if (!connectionPool.isEmpty()) {
            return connectionPool.removeFirst();
        }
        return null; // 连接池为空
    }
    
    public synchronized void releaseConnection(Connection conn) {
        if (conn != null) {
            connectionPool.addLast(conn);
        }
    }
}
```

## 2.5 单例模式的优缺点

### 2.5.1 优点

1. **内存节约**：由于在系统内存中只存在一个对象，因此可以节约系统资源
2. **避免频繁创建和销毁**：对于频繁使用的对象，可以省略创建对象所花费的时间
3. **全局访问点**：提供了对唯一实例的受控访问
4. **允许对操作和表示的精化**：可以通过子类化单例类来配置单例实例

### 2.5.2 缺点

1. **违背单一职责原则**：一个类应该只关心内部逻辑，而不关心外面怎么样来实例化
2. **难以扩展**：单例模式一般不会作为父类被继承
3. **调试困难**：单例模式的代码通常比较难以调试
4. **可能引发内存泄漏**：如果单例对象持有外部对象的引用，那么这个外部对象将不能被JVM正常回收

## 2.6 最佳实践建议

1. **考虑使用静态内部类实现**：既保证了线程安全，又能实现延迟加载
2. **考虑使用枚举实现**：对于不需要延迟加载的场景，枚举实现是最简单的
3. **注意防止反射和序列化破坏**：在必要时添加相应的防护措施
4. **谨慎使用单例**：单例模式虽然有很多优点，但也容易被滥用，应根据实际需求选择

## 2.7 本章小结

本章详细介绍了单例模式的概念、多种实现方式及其优缺点。单例模式是创建型模式中最简单的一种，但在实际应用中需要注意线程安全、反射破坏、序列化破坏等问题。在实际开发中，推荐使用静态内部类或枚举的方式来实现单例模式。

下一章我们将介绍工厂方法模式，它是另一种重要的创建型模式。