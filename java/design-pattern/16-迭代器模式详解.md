# 第十六章 迭代器模式详解

## 本章概要
- 迭代器模式的定义和概念
- 迭代器模式的结构和组成
- 迭代器模式的实现方式
- 实际应用场景分析
- 开源框架中的应用
- 迭代器模式的优缺点
- 与其他设计模式的比较
- 最佳实践和注意事项

## 迭代器模式概述

迭代器模式（Iterator Pattern）是一种行为型设计模式，它提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。

### 核心思想
迭代器模式的核心思想是将集合对象的遍历操作从集合类中分离出来，放入专门的迭代器类中，这样可以做到不暴露集合内部结构的情况下，提供一种统一的方式来遍历集合中的所有元素。

### 应用场景
1. 访问一个聚合对象的内容而无需暴露它的内部表示
2. 支持对聚合对象的多种遍历方式
3. 为遍历不同的聚合结构提供一个统一的接口
4. 简化聚合类的接口，让聚合类只需要专注存储数据，而不必关心遍历逻辑

## 迭代器模式结构

迭代器模式包含以下角色：
1. **Iterator（抽象迭代器）**：定义访问和遍历元素的接口
2. **ConcreteIterator（具体迭代器）**：实现抽象迭代器接口，完成对聚合对象的遍历，并记录遍历的当前位置
3. **Aggregate（抽象聚合类）**：定义创建相应迭代器对象的接口
4. **ConcreteAggregate（具体聚合类）**：实现创建相应迭代器的接口，返回相应的具体迭代器实例

## 迭代器模式实现

### 基本实现

```java
// 抽象迭代器接口
interface Iterator<T> {
    boolean hasNext();
    T next();
    void remove();
}

// 抽象聚合接口
interface Aggregate<T> {
    Iterator<T> createIterator();
}

// 具体聚合类 - 字符串列表
class StringList implements Aggregate<String> {
    private String[] items;
    private int size;
    private int capacity;
    
    public StringList() {
        this.capacity = 10;
        this.items = new String[capacity];
        this.size = 0;
    }
    
    public StringList(int capacity) {
        this.capacity = capacity;
        this.items = new String[capacity];
        this.size = 0;
    }
    
    public void add(String item) {
        if (size >= capacity) {
            resize();
        }
        items[size++] = item;
    }
    
    public String get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
        return items[index];
    }
    
    public int size() {
        return size;
    }
    
    private void resize() {
        capacity *= 2;
        String[] newItems = new String[capacity];
        System.arraycopy(items, 0, newItems, 0, size);
        items = newItems;
    }
    
    @Override
    public Iterator<String> createIterator() {
        return new StringListIterator();
    }
    
    // 具体内迭代器
    private class StringListIterator implements Iterator<String> {
        private int currentIndex = 0;
        
        @Override
        public boolean hasNext() {
            return currentIndex < size;
        }
        
        @Override
        public String next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            return items[currentIndex++];
        }
        
        @Override
        public void remove() {
            if (currentIndex <= 0) {
                throw new IllegalStateException();
            }
            // 简单实现，实际应该更复杂
            for (int i = currentIndex - 1; i < size - 1; i++) {
                items[i] = items[i + 1];
            }
            items[--size] = null;
            currentIndex--;
        }
    }
}
```

### 更复杂的实现示例

让我们通过一个双向迭代器来展示更复杂的实现。

## 实际应用示例

### 1. 双向迭代器

```java
// 双向迭代器接口
interface BidirectionalIterator<T> extends Iterator<T> {
    boolean hasPrevious();
    T previous();
    int nextIndex();
    int previousIndex();
}

// 双向列表实现
class BidirectionalList<T> implements Iterable<T> {
    private Object[] elements;
    private int size;
    private int capacity;
    
    public BidirectionalList() {
        this.capacity = 10;
        this.elements = new Object[capacity];
        this.size = 0;
    }
    
    public void add(T element) {
        if (size >= capacity) {
            resize();
        }
        elements[size++] = element;
    }
    
    @SuppressWarnings("unchecked")
    public T get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
        return (T) elements[index];
    }
    
    public int size() {
        return size;
    }
    
    private void resize() {
        capacity *= 2;
        Object[] newElements = new Object[capacity];
        System.arraycopy(elements, 0, newElements, 0, size);
        elements = newElements;
    }
    
    @Override
    public java.util.Iterator<T> iterator() {
        return new BidirectionalListIterator(0);
    }
    
    public BidirectionalIterator<T> bidirectionalIterator() {
        return new BidirectionalListIterator(0);
    }
    
    public BidirectionalIterator<T> bidirectionalIterator(int index) {
        return new BidirectionalListIterator(index);
    }
    
    // 双向迭代器实现
    private class BidirectionalListIterator implements BidirectionalIterator<T> {
        private int currentIndex;
        
        public BidirectionalListIterator(int index) {
            this.currentIndex = index;
        }
        
        @Override
        public boolean hasNext() {
            return currentIndex < size;
        }
        
        @Override
        @SuppressWarnings("unchecked")
        public T next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            return (T) elements[currentIndex++];
        }
        
        @Override
        public boolean hasPrevious() {
            return currentIndex > 0;
        }
        
        @Override
        @SuppressWarnings("unchecked")
        public T previous() {
            if (!hasPrevious()) {
                throw new java.util.NoSuchElementException();
            }
            return (T) elements[--currentIndex];
        }
        
        @Override
        public int nextIndex() {
            return currentIndex;
        }
        
        @Override
        public int previousIndex() {
            return currentIndex - 1;
        }
        
        @Override
        public void remove() {
            if (currentIndex <= 0) {
                throw new IllegalStateException();
            }
            for (int i = currentIndex - 1; i < size - 1; i++) {
                elements[i] = elements[i + 1];
            }
            elements[--size] = null;
            currentIndex--;
        }
    }
}
```

### 2. 树结构迭代器

```java
// 树节点定义
class TreeNode<T> {
    T data;
    TreeNode<T> left;
    TreeNode<T> right;
    
    public TreeNode(T data) {
        this.data = data;
    }
}

// 树的迭代器接口
interface TreeIterator<T> extends Iterator<T> {
    // 前序遍历
    void setPreOrder();
    // 中序遍历
    void setInOrder();
    // 后序遍历
    void setPostOrder();
}

// 二叉树实现
class BinaryTree<T> {
    private TreeNode<T> root;
    
    public void setRoot(TreeNode<T> root) {
        this.root = root;
    }
    
    public TreeNode<T> getRoot() {
        return root;
    }
    
    public TreeIterator<T> createIterator() {
        return new BinaryTreeIterator();
    }
    
    // 二叉树迭代器实现
    private class BinaryTreeIterator implements TreeIterator<T> {
        private java.util.List<T> traversalResult;
        private int currentIndex;
        private int traversalType; // 0: pre-order, 1: in-order, 2: post-order
        
        public BinaryTreeIterator() {
            this.traversalResult = new java.util.ArrayList<>();
            this.currentIndex = 0;
            this.traversalType = 1; // 默认中序遍历
            performTraversal();
        }
        
        private void performTraversal() {
            traversalResult.clear();
            switch (traversalType) {
                case 0: // 前序遍历
                    preOrderTraversal(root);
                    break;
                case 1: // 中序遍历
                    inOrderTraversal(root);
                    break;
                case 2: // 后序遍历
                    postOrderTraversal(root);
                    break;
            }
        }
        
        private void preOrderTraversal(TreeNode<T> node) {
            if (node != null) {
                traversalResult.add(node.data);
                preOrderTraversal(node.left);
                preOrderTraversal(node.right);
            }
        }
        
        private void inOrderTraversal(TreeNode<T> node) {
            if (node != null) {
                inOrderTraversal(node.left);
                traversalResult.add(node.data);
                inOrderTraversal(node.right);
            }
        }
        
        private void postOrderTraversal(TreeNode<T> node) {
            if (node != null) {
                postOrderTraversal(node.left);
                postOrderTraversal(node.right);
                traversalResult.add(node.data);
            }
        }
        
        @Override
        public void setPreOrder() {
            this.traversalType = 0;
            currentIndex = 0;
            performTraversal();
        }
        
        @Override
        public void setInOrder() {
            this.traversalType = 1;
            currentIndex = 0;
            performTraversal();
        }
        
        @Override
        public void setPostOrder() {
            this.traversalType = 2;
            currentIndex = 0;
            performTraversal();
        }
        
        @Override
        public boolean hasNext() {
            return currentIndex < traversalResult.size();
        }
        
        @Override
        public T next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            return traversalResult.get(currentIndex++);
        }
        
        @Override
        public void remove() {
            throw new UnsupportedOperationException("Remove operation is not supported");
        }
    }
}
```

### 3. 过滤迭代器

```java
// 过滤器接口
interface Filter<T> {
    boolean accept(T item);
}

// 过滤迭代器实现
class FilterIterator<T> implements Iterator<T> {
    private Iterator<T> iterator;
    private Filter<T> filter;
    private T nextItem;
    private boolean hasNextItem;
    
    public FilterIterator(Iterator<T> iterator, Filter<T> filter) {
        this.iterator = iterator;
        this.filter = filter;
        findNext();
    }
    
    private void findNext() {
        hasNextItem = false;
        while (iterator.hasNext()) {
            nextItem = iterator.next();
            if (filter.accept(nextItem)) {
                hasNextItem = true;
                break;
            }
        }
    }
    
    @Override
    public boolean hasNext() {
        return hasNextItem;
    }
    
    @Override
    public T next() {
        if (!hasNextItem) {
            throw new java.util.NoSuchElementException();
        }
        T result = nextItem;
        findNext();
        return result;
    }
    
    @Override
    public void remove() {
        iterator.remove();
    }
}

// 跳过迭代器
class SkipIterator<T> implements Iterator<T> {
    private Iterator<T> iterator;
    private int skipCount;
    private int currentSkip;
    
    public SkipIterator(Iterator<T> iterator, int skipCount) {
        this.iterator = iterator;
        this.skipCount = skipCount;
        this.currentSkip = 0;
    }
    
    @Override
    public boolean hasNext() {
        return iterator.hasNext();
    }
    
    @Override
    public T next() {
        while (iterator.hasNext() && currentSkip < skipCount) {
            iterator.next();
            currentSkip++;
        }
        
        if (!iterator.hasNext()) {
            throw new java.util.NoSuchElementException();
        }
        
        currentSkip = 0;
        return iterator.next();
    }
    
    @Override
    public void remove() {
        iterator.remove();
    }
}
```

## 开源框架中的应用

### 1. Java集合框架

Java集合框架广泛使用了迭代器模式：

```java
// Java集合框架中的迭代器使用示例
import java.util.*;

public class JavaCollectionsIteratorExample {
    public static void main(String[] args) {
        // List迭代器
        List<String> list = Arrays.asList("Apple", "Banana", "Cherry");
        Iterator<String> listIterator = list.iterator();
        
        System.out.println("List Iterator:");
        while (listIterator.hasNext()) {
            System.out.println(listIterator.next());
        }
        
        // Set迭代器
        Set<Integer> set = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
        Iterator<Integer> setIterator = set.iterator();
        
        System.out.println("\nSet Iterator:");
        while (setIterator.hasNext()) {
            System.out.println(setIterator.next());
        }
        
        // Map迭代器（通过entrySet）
        Map<String, Integer> map = new HashMap<>();
        map.put("One", 1);
        map.put("Two", 2);
        map.put("Three", 3);
        
        Iterator<Map.Entry<String, Integer>> mapIterator = map.entrySet().iterator();
        
        System.out.println("\nMap Iterator:");
        while (mapIterator.hasNext()) {
            Map.Entry<String, Integer> entry = mapIterator.next();
            System.out.println(entry.getKey() + " = " + entry.getValue());
        }
    }
}
```

### 2. 数据库ResultSet

JDBC中的ResultSet也是迭代器模式的一种体现：

```java
// JDBC ResultSet迭代示例
/*
try (Connection conn = DriverManager.getConnection(url, username, password);
     Statement stmt = conn.createStatement();
     ResultSet rs = stmt.executeQuery("SELECT * FROM users")) {
    
    while (rs.next()) {
        String name = rs.getString("name");
        int age = rs.getInt("age");
        System.out.println("Name: " + name + ", Age: " + age);
    }
} catch (SQLException e) {
    e.printStackTrace();
}
*/
```

## 迭代器模式的优缺点

### 优点
1. **简化聚合类**：聚合类只需要关注数据存储，遍历逻辑交给迭代器处理
2. **支持多种遍历方式**：可以在同一个聚合对象上实现多种遍历方式
3. **隐藏聚合对象的内部结构**：客户端无须知道聚合对象的内部结构
4. **符合开闭原则**：增加新的聚合类和迭代器类都很方便，无须修改原有代码
5. **统一接口**：为遍历不同类型的聚合结构提供了统一的接口

### 缺点
1. **增加类的数量**：每个聚合类都需要配备一个迭代器类，类的个数成对增加
2. **间接访问影响性能**：由于迭代器模式将存储和遍历的职责分离，可能会增加系统的复杂性和间接访问的开销

## 与其他模式的比较

### 1. 与组合模式的关系
- 组合模式定义了对象的层次结构，而迭代器模式可以用来遍历这些层次结构
- 两者经常一起使用，迭代器可以透明地遍历组合对象的各个部分

### 2. 与工厂方法模式的关系
- 迭代器的创建可以使用工厂方法模式
- 聚合类通过工厂方法创建具体的迭代器实例

## 最佳实践和注意事项

### 1. 迭代器的状态管理
确保迭代器能正确维护当前遍历的位置，在并发环境下要注意线程安全问题。

### 2. 异常处理
在迭代过程中可能遇到的各种异常情况要有适当的处理机制。

### 3. 内存管理
对于大型集合，要考虑迭代器的内存使用情况，避免一次性加载过多数据。

### 4. 性能优化
对于频繁遍历的场景，可以考虑缓存遍历结果或者使用更高效的遍历算法。

## 总结

迭代器模式是一种非常实用的设计模式，它将集合对象的遍历操作封装在独立的迭代器对象中，使得我们能够以不同的方式遍历集合，同时又不暴露集合的内部结构。在现代编程语言和框架中，迭代器模式得到了广泛应用，如Java集合框架、C#的IEnumerable接口等。

通过合理运用迭代器模式，我们可以写出更加清晰、灵活和可维护的代码。特别是在处理复杂数据结构时，迭代器模式能帮助我们更好地组织代码结构，实现关注点分离。