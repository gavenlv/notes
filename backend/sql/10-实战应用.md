# 第10章：SQL实战应用

## 10.1 实战项目概述

在前面的章节中，我们已经学习了SQL的基础知识、高级特性以及性能优化技巧。本章将通过几个实际项目案例，展示如何将这些知识应用到真实场景中，帮助读者更好地理解SQL在实际工作中的应用。

我们将涵盖以下几个实战项目：
1. 电商系统数据库设计与查询
2. 社交媒体数据分析
3. 企业人力资源管理系统
4. 财务数据分析与报表
5. 物流与库存管理系统

## 10.2 电商系统数据库设计与查询

### 10.2.1 数据库设计

电商系统通常包含用户、商品、订单、购物车、支付等核心模块。下面是一个简化的电商系统数据库设计：

```sql
-- 用户表
CREATE TABLE users (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    phone VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE
);

-- 用户地址表
CREATE TABLE user_addresses (
    address_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    address_type ENUM('billing', 'shipping') NOT NULL,
    street_address VARCHAR(255) NOT NULL,
    city VARCHAR(100) NOT NULL,
    state VARCHAR(100),
    postal_code VARCHAR(20) NOT NULL,
    country VARCHAR(100) NOT NULL,
    is_default BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- 商品分类表
CREATE TABLE categories (
    category_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    parent_category_id INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (parent_category_id) REFERENCES categories(category_id)
);

-- 商品表
CREATE TABLE products (
    product_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    price DECIMAL(10, 2) NOT NULL,
    cost_price DECIMAL(10, 2),
    sku VARCHAR(100) NOT NULL UNIQUE,
    stock_quantity INT DEFAULT 0,
    min_stock_level INT DEFAULT 0,
    category_id INT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (category_id) REFERENCES categories(category_id)
);

-- 商品图片表
CREATE TABLE product_images (
    image_id INT AUTO_INCREMENT PRIMARY KEY,
    product_id INT NOT NULL,
    image_url VARCHAR(500) NOT NULL,
    alt_text VARCHAR(255),
    sort_order INT DEFAULT 0,
    is_primary BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);

-- 购物车表
CREATE TABLE shopping_cart (
    cart_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    UNIQUE KEY (user_id)
);

-- 购物车商品表
CREATE TABLE cart_items (
    cart_item_id INT AUTO_INCREMENT PRIMARY KEY,
    cart_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL DEFAULT 1,
    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (cart_id) REFERENCES shopping_cart(cart_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id),
    UNIQUE KEY (cart_id, product_id)
);

-- 订单表
CREATE TABLE orders (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    order_number VARCHAR(50) NOT NULL UNIQUE,
    user_id INT NOT NULL,
    status ENUM('pending', 'processing', 'shipped', 'delivered', 'cancelled') DEFAULT 'pending',
    subtotal DECIMAL(10, 2) NOT NULL,
    tax_amount DECIMAL(10, 2) DEFAULT 0,
    shipping_amount DECIMAL(10, 2) DEFAULT 0,
    discount_amount DECIMAL(10, 2) DEFAULT 0,
    total_amount DECIMAL(10, 2) NOT NULL,
    shipping_address_id INT,
    billing_address_id INT,
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    shipped_date TIMESTAMP NULL,
    delivered_date TIMESTAMP NULL,
    notes TEXT,
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    FOREIGN KEY (shipping_address_id) REFERENCES user_addresses(address_id),
    FOREIGN KEY (billing_address_id) REFERENCES user_addresses(address_id)
);

-- 订单商品表
CREATE TABLE order_items (
    order_item_id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    unit_price DECIMAL(10, 2) NOT NULL,
    total_price DECIMAL(10, 2) NOT NULL,
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);

-- 支付记录表
CREATE TABLE payments (
    payment_id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT NOT NULL,
    payment_method ENUM('credit_card', 'paypal', 'bank_transfer', 'cash_on_delivery') NOT NULL,
    amount DECIMAL(10, 2) NOT NULL,
    status ENUM('pending', 'completed', 'failed', 'refunded') DEFAULT 'pending',
    transaction_id VARCHAR(100),
    payment_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
);

-- 评价表
CREATE TABLE reviews (
    review_id INT AUTO_INCREMENT PRIMARY KEY,
    product_id INT NOT NULL,
    user_id INT NOT NULL,
    rating INT NOT NULL CHECK (rating >= 1 AND rating <= 5),
    title VARCHAR(255),
    comment TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_verified BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (product_id) REFERENCES products(product_id),
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    UNIQUE KEY (product_id, user_id)
);
```

### 10.2.2 常用查询示例

#### 1. 获取商品详情及评价信息

```sql
SELECT 
    p.product_id,
    p.name AS product_name,
    p.description,
    p.price,
    p.stock_quantity,
    c.name AS category_name,
    AVG(r.rating) AS average_rating,
    COUNT(r.review_id) AS review_count,
    pi.image_url AS primary_image_url
FROM 
    products p
LEFT JOIN 
    categories c ON p.category_id = c.category_id
LEFT JOIN 
    reviews r ON p.product_id = r.product_id
LEFT JOIN 
    product_images pi ON p.product_id = pi.product_id AND pi.is_primary = TRUE
WHERE 
    p.product_id = 1
GROUP BY 
    p.product_id;
```

#### 2. 获取用户订单历史

```sql
SELECT 
    o.order_id,
    o.order_number,
    o.order_date,
    o.status,
    o.total_amount,
    COUNT(oi.order_item_id) AS item_count,
    GROUP_CONCAT(
        CONCAT(p.name, ' (', oi.quantity, ' x ', oi.unit_price, ')')
        SEPARATOR ', '
    ) AS items
FROM 
    orders o
JOIN 
    order_items oi ON o.order_id = oi.order_id
JOIN 
    products p ON oi.product_id = p.product_id
WHERE 
    o.user_id = 1
GROUP BY 
    o.order_id
ORDER BY 
    o.order_date DESC;
```

#### 3. 获取热门商品

```sql
SELECT 
    p.product_id,
    p.name AS product_name,
    p.price,
    c.name AS category_name,
    SUM(oi.quantity) AS total_sold,
    SUM(oi.total_price) AS total_revenue,
    COUNT(DISTINCT o.order_id) AS order_count,
    AVG(r.rating) AS average_rating
FROM 
    products p
JOIN 
    order_items oi ON p.product_id = oi.product_id
JOIN 
    orders o ON oi.order_id = o.order_id
JOIN 
    categories c ON p.category_id = c.category_id
LEFT JOIN 
    reviews r ON p.product_id = r.product_id
WHERE 
    o.status IN ('delivered', 'shipped')
    AND o.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
GROUP BY 
    p.product_id
ORDER BY 
    total_sold DESC
LIMIT 10;
```

#### 4. 获取用户购物车内容

```sql
SELECT 
    p.product_id,
    p.name AS product_name,
    p.price,
    ci.quantity,
    (p.price * ci.quantity) AS subtotal,
    p.stock_quantity,
    pi.image_url
FROM 
    shopping_cart sc
JOIN 
    cart_items ci ON sc.cart_id = ci.cart_id
JOIN 
    products p ON ci.product_id = p.product_id
LEFT JOIN 
    product_images pi ON p.product_id = pi.product_id AND pi.is_primary = TRUE
WHERE 
    sc.user_id = 1;
```

#### 5. 获取销售统计报表

```sql
SELECT 
    DATE(o.order_date) AS order_date,
    COUNT(DISTINCT o.order_id) AS order_count,
    COUNT(DISTINCT o.user_id) AS customer_count,
    SUM(o.total_amount) AS total_revenue,
    AVG(o.total_amount) AS average_order_value
FROM 
    orders o
WHERE 
    o.status IN ('delivered', 'shipped')
    AND o.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
GROUP BY 
    DATE(o.order_date)
ORDER BY 
    order_date DESC;
```

## 10.3 社交媒体数据分析

### 10.3.1 数据库设计

```sql
-- 用户表
CREATE TABLE users (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    display_name VARCHAR(100),
    bio TEXT,
    profile_image_url VARCHAR(500),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE
);

-- 关注关系表
CREATE TABLE follows (
    follower_id INT NOT NULL,
    following_id INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (follower_id, following_id),
    FOREIGN KEY (follower_id) REFERENCES users(user_id),
    FOREIGN KEY (following_id) REFERENCES users(user_id)
);

-- 帖子表
CREATE TABLE posts (
    post_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    content TEXT NOT NULL,
    image_url VARCHAR(500),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    like_count INT DEFAULT 0,
    comment_count INT DEFAULT 0,
    share_count INT DEFAULT 0,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- 点赞表
CREATE TABLE likes (
    like_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    post_id INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    FOREIGN KEY (post_id) REFERENCES posts(post_id),
    UNIQUE KEY (user_id, post_id)
);

-- 评论表
CREATE TABLE comments (
    comment_id INT AUTO_INCREMENT PRIMARY KEY,
    post_id INT NOT NULL,
    user_id INT NOT NULL,
    parent_comment_id INT,
    content TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    like_count INT DEFAULT 0,
    FOREIGN KEY (post_id) REFERENCES posts(post_id),
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    FOREIGN KEY (parent_comment_id) REFERENCES comments(comment_id)
);

-- 话题标签表
CREATE TABLE hashtags (
    hashtag_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 帖子标签关联表
CREATE TABLE post_hashtags (
    post_id INT NOT NULL,
    hashtag_id INT NOT NULL,
    PRIMARY KEY (post_id, hashtag_id),
    FOREIGN KEY (post_id) REFERENCES posts(post_id),
    FOREIGN KEY (hashtag_id) REFERENCES hashtags(hashtag_id)
);
```

### 10.3.2 数据分析查询

#### 1. 获取用户动态流

```sql
SELECT 
    p.post_id,
    p.content,
    p.image_url,
    p.created_at,
    p.like_count,
    p.comment_count,
    p.share_count,
    u.user_id,
    u.username,
    u.display_name,
    u.profile_image_url,
    CASE 
        WHEN l.user_id IS NOT NULL THEN TRUE 
        ELSE FALSE 
    END AS is_liked_by_current_user
FROM 
    posts p
JOIN 
    users u ON p.user_id = u.user_id
LEFT JOIN 
    follows f ON f.following_id = p.user_id AND f.follower_id = 1
LEFT JOIN 
    likes l ON l.post_id = p.post_id AND l.user_id = 1
WHERE 
    p.user_id = 1 OR f.follower_id IS NOT NULL
ORDER BY 
    p.created_at DESC
LIMIT 20;
```

#### 2. 获取热门话题

```sql
SELECT 
    h.hashtag_id,
    h.name AS hashtag_name,
    COUNT(ph.post_id) AS post_count,
    COUNT(DISTINCT p.user_id) AS user_count,
    SUM(p.like_count) AS total_likes
FROM 
    hashtags h
JOIN 
    post_hashtags ph ON h.hashtag_id = ph.hashtag_id
JOIN 
    posts p ON ph.post_id = p.post_id
WHERE 
    p.created_at >= DATE_SUB(CURRENT_DATE(), INTERVAL 7 DAY)
GROUP BY 
    h.hashtag_id
ORDER BY 
    post_count DESC
LIMIT 10;
```

#### 3. 获取用户影响力分析

```sql
SELECT 
    u.user_id,
    u.username,
    u.display_name,
    COUNT(DISTINCT f1.following_id) AS following_count,
    COUNT(DISTINCT f2.follower_id) AS follower_count,
    COUNT(DISTINCT p.post_id) AS post_count,
    SUM(p.like_count) AS total_likes_received,
    SUM(p.comment_count) AS total_comments_received,
    AVG(p.like_count) AS avg_likes_per_post,
    CASE 
        WHEN COUNT(DISTINCT f2.follower_id) > 0 
        THEN (COUNT(DISTINCT f2.follower_id) / NULLIF(COUNT(DISTINCT f1.following_id), 0)) 
        ELSE 0 
    END AS follower_to_following_ratio
FROM 
    users u
LEFT JOIN 
    follows f1 ON u.user_id = f1.follower_id
LEFT JOIN 
    follows f2 ON u.user_id = f2.following_id
LEFT JOIN 
    posts p ON u.user_id = p.user_id
GROUP BY 
    u.user_id
ORDER BY 
    follower_count DESC
LIMIT 10;
```

#### 4. 获取用户活跃度分析

```sql
SELECT 
    DATE(p.created_at) AS activity_date,
    COUNT(DISTINCT p.user_id) AS active_users,
    COUNT(p.post_id) AS posts_created,
    COUNT(l.like_id) AS likes_given,
    COUNT(c.comment_id) AS comments_posted
FROM 
    posts p
LEFT JOIN 
    likes l ON DATE(l.created_at) = DATE(p.created_at)
LEFT JOIN 
    comments c ON DATE(c.created_at) = DATE(p.created_at)
WHERE 
    p.created_at >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
GROUP BY 
    DATE(p.created_at)
ORDER BY 
    activity_date DESC;
```

## 10.4 企业人力资源管理系统

### 10.4.1 数据库设计

```sql
-- 部门表
CREATE TABLE departments (
    department_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    manager_id INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 员工表
CREATE TABLE employees (
    employee_id INT AUTO_INCREMENT PRIMARY KEY,
    employee_number VARCHAR(20) NOT NULL UNIQUE,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE,
    phone VARCHAR(20),
    hire_date DATE NOT NULL,
    job_title VARCHAR(100) NOT NULL,
    salary DECIMAL(10, 2),
    department_id INT,
    manager_id INT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (department_id) REFERENCES departments(department_id),
    FOREIGN KEY (manager_id) REFERENCES employees(employee_id)
);

-- 考勤记录表
CREATE TABLE attendance (
    attendance_id INT AUTO_INCREMENT PRIMARY KEY,
    employee_id INT NOT NULL,
    attendance_date DATE NOT NULL,
    check_in TIME,
    check_out TIME,
    break_duration INT DEFAULT 0, -- 休息时间（分钟）
    work_hours DECIMAL(4, 2), -- 实际工作小时数
    overtime_hours DECIMAL(4, 2) DEFAULT 0, -- 加班小时数
    status ENUM('present', 'absent', 'late', 'early_leave', 'holiday', 'sick_leave', 'annual_leave') NOT NULL,
    notes TEXT,
    FOREIGN KEY (employee_id) REFERENCES employees(employee_id),
    UNIQUE KEY (employee_id, attendance_date)
);

-- 请假申请表
CREATE TABLE leave_requests (
    leave_request_id INT AUTO_INCREMENT PRIMARY KEY,
    employee_id INT NOT NULL,
    leave_type ENUM('annual_leave', 'sick_leave', 'personal_leave', 'maternity_leave', 'paternity_leave') NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    days_count DECIMAL(3, 1) NOT NULL,
    reason TEXT,
    status ENUM('pending', 'approved', 'rejected') DEFAULT 'pending',
    approver_id INT,
    approver_comments TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (employee_id) REFERENCES employees(employee_id),
    FOREIGN KEY (approver_id) REFERENCES employees(employee_id)
);

-- 绩效评估表
CREATE TABLE performance_reviews (
    review_id INT AUTO_INCREMENT PRIMARY KEY,
    employee_id INT NOT NULL,
    reviewer_id INT NOT NULL,
    review_period_start DATE NOT NULL,
    review_period_end DATE NOT NULL,
    overall_rating DECIMAL(3, 2) CHECK (overall_rating >= 1 AND overall_rating <= 5),
    strengths TEXT,
    areas_for_improvement TEXT,
    goals TEXT,
    comments TEXT,
    status ENUM('draft', 'submitted', 'approved') DEFAULT 'draft',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (employee_id) REFERENCES employees(employee_id),
    FOREIGN KEY (reviewer_id) REFERENCES employees(employee_id)
);

-- 培训课程表
CREATE TABLE training_courses (
    course_id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    description TEXT,
    duration_hours DECIMAL(4, 2),
    instructor VARCHAR(100),
    start_date DATE,
    end_date DATE,
    max_participants INT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 员工培训记录表
CREATE TABLE employee_training (
    training_id INT AUTO_INCREMENT PRIMARY KEY,
    employee_id INT NOT NULL,
    course_id INT NOT NULL,
    enrollment_date DATE NOT NULL,
    completion_date DATE,
    status ENUM('enrolled', 'in_progress', 'completed', 'dropped') DEFAULT 'enrolled',
    score DECIMAL(5, 2),
    certificate_url VARCHAR(500),
    notes TEXT,
    FOREIGN KEY (employee_id) REFERENCES employees(employee_id),
    FOREIGN KEY (course_id) REFERENCES training_courses(course_id),
    UNIQUE KEY (employee_id, course_id)
);
```

### 10.4.2 常用查询示例

#### 1. 获取员工详细信息

```sql
SELECT 
    e.employee_id,
    e.employee_number,
    CONCAT(e.first_name, ' ', e.last_name) AS full_name,
    e.email,
    e.phone,
    e.hire_date,
    e.job_title,
    e.salary,
    d.name AS department_name,
    CONCAT(m.first_name, ' ', m.last_name) AS manager_name,
    TIMESTAMPDIFF(YEAR, e.hire_date, CURDATE()) AS years_of_service,
    CASE 
        WHEN e.is_active THEN '在职'
        ELSE '离职'
    END AS employment_status
FROM 
    employees e
LEFT JOIN 
    departments d ON e.department_id = d.department_id
LEFT JOIN 
    employees m ON e.manager_id = m.employee_id
WHERE 
    e.employee_id = 1;
```

#### 2. 获取部门员工列表

```sql
SELECT 
    e.employee_id,
    e.employee_number,
    CONCAT(e.first_name, ' ', e.last_name) AS full_name,
    e.job_title,
    e.email,
    e.hire_date,
    TIMESTAMPDIFF(YEAR, e.hire_date, CURDATE()) AS years_of_service,
    CASE 
        WHEN e.is_active THEN '在职'
        ELSE '离职'
    END AS employment_status
FROM 
    employees e
WHERE 
    e.department_id = 1 AND e.is_active = TRUE
ORDER BY 
    e.hire_date DESC;
```

#### 3. 获取员工月度考勤统计

```sql
SELECT 
    e.employee_id,
    CONCAT(e.first_name, ' ', e.last_name) AS full_name,
    COUNT(a.attendance_id) AS total_days,
    SUM(CASE WHEN a.status = 'present' THEN 1 ELSE 0 END) AS present_days,
    SUM(CASE WHEN a.status = 'absent' THEN 1 ELSE 0 END) AS absent_days,
    SUM(CASE WHEN a.status = 'late' THEN 1 ELSE 0 END) AS late_days,
    SUM(CASE WHEN a.status = 'early_leave' THEN 1 ELSE 0 END) AS early_leave_days,
    SUM(CASE WHEN a.status IN ('sick_leave', 'annual_leave') THEN 1 ELSE 0 END) AS leave_days,
    SUM(a.work_hours) AS total_work_hours,
    SUM(a.overtime_hours) AS total_overtime_hours
FROM 
    employees e
LEFT JOIN 
    attendance a ON e.employee_id = a.employee_id
WHERE 
    e.is_active = TRUE
    AND a.attendance_date >= DATE_FORMAT(CURDATE(), '%Y-%m-01')
    AND a.attendance_date < DATE_ADD(DATE_FORMAT(CURDATE(), '%Y-%m-01'), INTERVAL 1 MONTH)
GROUP BY 
    e.employee_id
ORDER BY 
    e.employee_id;
```

#### 4. 获取部门薪资统计

```sql
SELECT 
    d.department_id,
    d.name AS department_name,
    COUNT(e.employee_id) AS employee_count,
    MIN(e.salary) AS min_salary,
    MAX(e.salary) AS max_salary,
    AVG(e.salary) AS avg_salary,
    SUM(e.salary) AS total_salary
FROM 
    departments d
LEFT JOIN 
    employees e ON d.department_id = e.department_id AND e.is_active = TRUE
GROUP BY 
    d.department_id
ORDER BY 
    avg_salary DESC;
```

#### 5. 获取员工培训完成情况

```sql
SELECT 
    e.employee_id,
    CONCAT(e.first_name, ' ', e.last_name) AS full_name,
    d.name AS department_name,
    COUNT(et.training_id) AS total_courses_enrolled,
    SUM(CASE WHEN et.status = 'completed' THEN 1 ELSE 0 END) AS completed_courses,
    SUM(CASE WHEN et.status = 'in_progress' THEN 1 ELSE 0 END) AS in_progress_courses,
    AVG(et.score) AS average_score,
    SUM(tc.duration_hours) AS total_training_hours
FROM 
    employees e
LEFT JOIN 
    employee_training et ON e.employee_id = et.employee_id
LEFT JOIN 
    training_courses tc ON et.course_id = tc.course_id
LEFT JOIN 
    departments d ON e.department_id = d.department_id
WHERE 
    e.is_active = TRUE
GROUP BY 
    e.employee_id
ORDER BY 
    completed_courses DESC;
```

## 10.5 财务数据分析与报表

### 10.5.1 数据库设计

```sql
-- 账户表
CREATE TABLE accounts (
    account_id INT AUTO_INCREMENT PRIMARY KEY,
    account_number VARCHAR(50) NOT NULL UNIQUE,
    account_name VARCHAR(100) NOT NULL,
    account_type ENUM('asset', 'liability', 'equity', 'revenue', 'expense') NOT NULL,
    parent_account_id INT,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (parent_account_id) REFERENCES accounts(account_id)
);

-- 交易表
CREATE TABLE transactions (
    transaction_id INT AUTO_INCREMENT PRIMARY KEY,
    transaction_date DATE NOT NULL,
    description VARCHAR(255) NOT NULL,
    reference_number VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 交易明细表
CREATE TABLE transaction_entries (
    entry_id INT AUTO_INCREMENT PRIMARY KEY,
    transaction_id INT NOT NULL,
    account_id INT NOT NULL,
    debit_amount DECIMAL(15, 2) DEFAULT 0,
    credit_amount DECIMAL(15, 2) DEFAULT 0,
    description TEXT,
    FOREIGN KEY (transaction_id) REFERENCES transactions(transaction_id),
    FOREIGN KEY (account_id) REFERENCES accounts(account_id)
);

-- 预算表
CREATE TABLE budgets (
    budget_id INT AUTO_INCREMENT PRIMARY KEY,
    account_id INT NOT NULL,
    fiscal_year INT NOT NULL,
    period_type ENUM('monthly', 'quarterly', 'yearly') NOT NULL,
    period_value INT NOT NULL, -- 月份(1-12)或季度(1-4)
    budgeted_amount DECIMAL(15, 2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (account_id) REFERENCES accounts(account_id),
    UNIQUE KEY (account_id, fiscal_year, period_type, period_value)
);

-- 发票表
CREATE TABLE invoices (
    invoice_id INT AUTO_INCREMENT PRIMARY KEY,
    invoice_number VARCHAR(50) NOT NULL UNIQUE,
    customer_id INT NOT NULL,
    invoice_date DATE NOT NULL,
    due_date DATE NOT NULL,
    total_amount DECIMAL(15, 2) NOT NULL,
    tax_amount DECIMAL(15, 2) DEFAULT 0,
    status ENUM('draft', 'sent', 'paid', 'overdue', 'cancelled') DEFAULT 'draft',
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 发票明细表
CREATE TABLE invoice_items (
    item_id INT AUTO_INCREMENT PRIMARY KEY,
    invoice_id INT NOT NULL,
    description VARCHAR(255) NOT NULL,
    quantity DECIMAL(10, 2) NOT NULL,
    unit_price DECIMAL(10, 2) NOT NULL,
    total_price DECIMAL(15, 2) NOT NULL,
    tax_rate DECIMAL(5, 2) DEFAULT 0,
    tax_amount DECIMAL(15, 2) DEFAULT 0,
    FOREIGN KEY (invoice_id) REFERENCES invoices(invoice_id)
);
```

### 10.5.2 财务报表查询

#### 1. 生成试算平衡表

```sql
SELECT 
    a.account_id,
    a.account_number,
    a.account_name,
    a.account_type,
    SUM(te.debit_amount) AS total_debits,
    SUM(te.credit_amount) AS total_credits,
    (SUM(te.debit_amount) - SUM(te.credit_amount)) AS balance
FROM 
    accounts a
LEFT JOIN 
    transaction_entries te ON a.account_id = te.account_id
LEFT JOIN 
    transactions t ON te.transaction_id = t.transaction_id
WHERE 
    t.transaction_date BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY 
    a.account_id
ORDER BY 
    a.account_type, a.account_number;
```

#### 2. 生成损益表

```sql
SELECT 
    a.account_type,
    a.account_name,
    SUM(te.debit_amount - te.credit_amount) AS amount
FROM 
    accounts a
JOIN 
    transaction_entries te ON a.account_id = te.account_id
JOIN 
    transactions t ON te.transaction_id = t.transaction_id
WHERE 
    a.account_type IN ('revenue', 'expense')
    AND t.transaction_date BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY 
    a.account_id, a.account_type, a.account_name
ORDER BY 
    a.account_type, a.account_name;
```

#### 3. 生成资产负债表

```sql
-- 资产部分
SELECT 
    'Assets' AS section,
    a.account_name,
    SUM(te.debit_amount - te.credit_amount) AS amount
FROM 
    accounts a
JOIN 
    transaction_entries te ON a.account_id = te.account_id
JOIN 
    transactions t ON te.transaction_id = t.transaction_id
WHERE 
    a.account_type = 'asset'
    AND t.transaction_date <= '2023-12-31'
GROUP BY 
    a.account_id, a.account_name
ORDER BY 
    a.account_name

UNION ALL

-- 负债部分
SELECT 
    'Liabilities' AS section,
    a.account_name,
    SUM(te.credit_amount - te.debit_amount) AS amount
FROM 
    accounts a
JOIN 
    transaction_entries te ON a.account_id = te.account_id
JOIN 
    transactions t ON te.transaction_id = t.transaction_id
WHERE 
    a.account_type = 'liability'
    AND t.transaction_date <= '2023-12-31'
GROUP BY 
    a.account_id, a.account_name
ORDER BY 
    a.account_name

UNION ALL

-- 所有者权益部分
SELECT 
    'Equity' AS section,
    a.account_name,
    SUM(te.credit_amount - te.debit_amount) AS amount
FROM 
    accounts a
JOIN 
    transaction_entries te ON a.account_id = te.account_id
JOIN 
    transactions t ON te.transaction_id = t.transaction_id
WHERE 
    a.account_type = 'equity'
    AND t.transaction_date <= '2023-12-31'
GROUP BY 
    a.account_id, a.account_name
ORDER BY 
    a.account_name;
```

#### 4. 生成现金流量表

```sql
SELECT 
    CASE 
        WHEN a.account_name LIKE '%Cash%' OR a.account_name LIKE '%Bank%' THEN 'Cash and Cash Equivalents'
        WHEN a.account_name LIKE '%Accounts Receivable%' THEN 'Operating Activities'
        WHEN a.account_name LIKE '%Inventory%' THEN 'Operating Activities'
        WHEN a.account_name LIKE '%Accounts Payable%' THEN 'Operating Activities'
        WHEN a.account_name LIKE '%Equipment%' OR a.account_name LIKE '%Property%' THEN 'Investing Activities'
        WHEN a.account_name LIKE '%Loan%' OR a.account_name LIKE '%Debt%' THEN 'Financing Activities'
        ELSE 'Other'
    END AS activity_type,
    a.account_name,
    SUM(te.debit_amount - te.credit_amount) AS amount
FROM 
    accounts a
JOIN 
    transaction_entries te ON a.account_id = te.account_id
JOIN 
    transactions t ON te.transaction_id = t.transaction_id
WHERE 
    t.transaction_date BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY 
    a.account_id, a.account_name
ORDER BY 
    activity_type, a.account_name;
```

#### 5. 预算与实际对比分析

```sql
SELECT 
    a.account_id,
    a.account_name,
    b.fiscal_year,
    b.period_type,
    b.period_value,
    b.budgeted_amount,
    COALESCE(SUM(te.debit_amount - te.credit_amount), 0) AS actual_amount,
    (b.budgeted_amount - COALESCE(SUM(te.debit_amount - te.credit_amount), 0)) AS variance,
    CASE 
        WHEN b.budgeted_amount = 0 THEN 0
        ELSE ((b.budgeted_amount - COALESCE(SUM(te.debit_amount - te.credit_amount), 0)) / b.budgeted_amount) * 100
    END AS variance_percentage
FROM 
    budgets b
JOIN 
    accounts a ON b.account_id = a.account_id
LEFT JOIN 
    transaction_entries te ON a.account_id = te.account_id
LEFT JOIN 
    transactions t ON te.transaction_id = t.transaction_id
WHERE 
    b.fiscal_year = 2023
    AND (
        (b.period_type = 'monthly' AND t.transaction_date BETWEEN 
            DATE(CONCAT(b.fiscal_year, '-', LPAD(b.period_value, 2, '0'), '-01')) AND
            LAST_DAY(DATE(CONCAT(b.fiscal_year, '-', LPAD(b.period_value, 2, '0'), '-01')))
        )
        OR
        (b.period_type = 'quarterly' AND t.transaction_date BETWEEN 
            DATE(CONCAT(b.fiscal_year, '-', ((b.period_value - 1) * 3) + 1, '-01')) AND
            DATE(CONCAT(b.fiscal_year, '-', (b.period_value * 3), '-', DAY(LAST_DAY(DATE(CONCAT(b.fiscal_year, '-', (b.period_value * 3), '-01'))))))
        )
        OR
        (b.period_type = 'yearly' AND t.transaction_date BETWEEN 
            DATE(CONCAT(b.fiscal_year, '-01-01')) AND
            DATE(CONCAT(b.fiscal_year, '-12-31'))
        )
    )
GROUP BY 
    b.budget_id
ORDER BY 
    a.account_name, b.period_type, b.period_value;
```

## 10.6 物流与库存管理系统

### 10.6.1 数据库设计

```sql
-- 仓库表
CREATE TABLE warehouses (
    warehouse_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    address VARCHAR(255) NOT NULL,
    city VARCHAR(100) NOT NULL,
    state VARCHAR(100),
    postal_code VARCHAR(20) NOT NULL,
    country VARCHAR(100) NOT NULL,
    manager_id INT,
    capacity DECIMAL(10, 2), -- 仓库容量（平方米）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 产品表
CREATE TABLE products (
    product_id INT AUTO_INCREMENT PRIMARY KEY,
    sku VARCHAR(50) NOT NULL UNIQUE,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    category VARCHAR(100),
    unit_price DECIMAL(10, 2),
    cost_price DECIMAL(10, 2),
    weight DECIMAL(8, 2), -- 重量（千克）
    dimensions VARCHAR(100), -- 尺寸（长x宽x高）
    min_stock_level INT DEFAULT 0,
    max_stock_level INT DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 库存表
CREATE TABLE inventory (
    inventory_id INT AUTO_INCREMENT PRIMARY KEY,
    product_id INT NOT NULL,
    warehouse_id INT NOT NULL,
    quantity INT NOT NULL DEFAULT 0,
    allocated_quantity INT NOT NULL DEFAULT 0, -- 已分配但未发货的数量
    available_quantity INT GENERATED ALWAYS AS (quantity - allocated_quantity) STORED,
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (product_id) REFERENCES products(product_id),
    FOREIGN KEY (warehouse_id) REFERENCES warehouses(warehouse_id),
    UNIQUE KEY (product_id, warehouse_id)
);

-- 供应商表
CREATE TABLE suppliers (
    supplier_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    contact_person VARCHAR(100),
    email VARCHAR(100),
    phone VARCHAR(20),
    address VARCHAR(255),
    city VARCHAR(100),
    state VARCHAR(100),
    postal_code VARCHAR(20),
    country VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 采购订单表
CREATE TABLE purchase_orders (
    purchase_order_id INT AUTO_INCREMENT PRIMARY KEY,
    order_number VARCHAR(50) NOT NULL UNIQUE,
    supplier_id INT NOT NULL,
    warehouse_id INT NOT NULL,
    order_date DATE NOT NULL,
    expected_delivery_date DATE,
    status ENUM('draft', 'sent', 'partially_received', 'received', 'cancelled') DEFAULT 'draft',
    total_amount DECIMAL(12, 2) DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (supplier_id) REFERENCES suppliers(supplier_id),
    FOREIGN KEY (warehouse_id) REFERENCES warehouses(warehouse_id)
);

-- 采购订单明细表
CREATE TABLE purchase_order_items (
    item_id INT AUTO_INCREMENT PRIMARY KEY,
    purchase_order_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    unit_price DECIMAL(10, 2) NOT NULL,
    total_price DECIMAL(12, 2) NOT NULL,
    received_quantity INT DEFAULT 0,
    FOREIGN KEY (purchase_order_id) REFERENCES purchase_orders(purchase_order_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);

-- 客户表
CREATE TABLE customers (
    customer_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100),
    phone VARCHAR(20),
    billing_address VARCHAR(255),
    shipping_address VARCHAR(255),
    city VARCHAR(100),
    state VARCHAR(100),
    postal_code VARCHAR(20),
    country VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 销售订单表
CREATE TABLE sales_orders (
    sales_order_id INT AUTO_INCREMENT PRIMARY KEY,
    order_number VARCHAR(50) NOT NULL UNIQUE,
    customer_id INT NOT NULL,
    warehouse_id INT NOT NULL,
    order_date DATE NOT NULL,
    shipping_date DATE,
    status ENUM('draft', 'confirmed', 'picked', 'packed', 'shipped', 'delivered', 'cancelled') DEFAULT 'draft',
    total_amount DECIMAL(12, 2) DEFAULT 0,
    shipping_cost DECIMAL(10, 2) DEFAULT 0,
    tax_amount DECIMAL(10, 2) DEFAULT 0,
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id),
    FOREIGN KEY (warehouse_id) REFERENCES warehouses(warehouse_id)
);

-- 销售订单明细表
CREATE TABLE sales_order_items (
    item_id INT AUTO_INCREMENT PRIMARY KEY,
    sales_order_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    unit_price DECIMAL(10, 2) NOT NULL,
    total_price DECIMAL(12, 2) NOT NULL,
    shipped_quantity INT DEFAULT 0,
    FOREIGN KEY (sales_order_id) REFERENCES sales_orders(sales_order_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);

-- 库存交易表
CREATE TABLE inventory_transactions (
    transaction_id INT AUTO_INCREMENT PRIMARY KEY,
    product_id INT NOT NULL,
    warehouse_id INT NOT NULL,
    transaction_type ENUM('purchase', 'sale', 'transfer', 'adjustment', 'return') NOT NULL,
    quantity INT NOT NULL, -- 正数表示入库，负数表示出库
    reference_type ENUM('purchase_order', 'sales_order', 'transfer_order', 'adjustment') NOT NULL,
    reference_id INT NOT NULL,
    transaction_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    notes TEXT,
    FOREIGN KEY (product_id) REFERENCES products(product_id),
    FOREIGN KEY (warehouse_id) REFERENCES warehouses(warehouse_id)
);

-- 库存转移表
CREATE TABLE inventory_transfers (
    transfer_id INT AUTO_INCREMENT PRIMARY KEY,
    transfer_number VARCHAR(50) NOT NULL UNIQUE,
    from_warehouse_id INT NOT NULL,
    to_warehouse_id INT NOT NULL,
    transfer_date DATE NOT NULL,
    status ENUM('draft', 'in_transit', 'completed', 'cancelled') DEFAULT 'draft',
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (from_warehouse_id) REFERENCES warehouses(warehouse_id),
    FOREIGN KEY (to_warehouse_id) REFERENCES warehouses(warehouse_id)
);

-- 库存转移明细表
CREATE TABLE inventory_transfer_items (
    item_id INT AUTO_INCREMENT PRIMARY KEY,
    transfer_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    FOREIGN KEY (transfer_id) REFERENCES inventory_transfers(transfer_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);
```

### 10.6.2 常用查询示例

#### 1. 获取库存概览

```sql
SELECT 
    p.product_id,
    p.sku,
    p.name AS product_name,
    p.unit_price,
    COALESCE(SUM(i.quantity), 0) AS total_quantity,
    COALESCE(SUM(i.allocated_quantity), 0) AS total_allocated,
    COALESCE(SUM(i.available_quantity), 0) AS total_available,
    p.min_stock_level,
    p.max_stock_level,
    CASE 
        WHEN COALESCE(SUM(i.available_quantity), 0) <= p.min_stock_level THEN '需要补货'
        WHEN COALESCE(SUM(i.available_quantity), 0) >= p.max_stock_level THEN '库存过多'
        ELSE '正常'
    END AS stock_status
FROM 
    products p
LEFT JOIN 
    inventory i ON p.product_id = i.product_id
WHERE 
    p.is_active = TRUE
GROUP BY 
    p.product_id
ORDER BY 
    p.name;
```

#### 2. 获取仓库库存详情

```sql
SELECT 
    w.warehouse_id,
    w.name AS warehouse_name,
    p.product_id,
    p.sku,
    p.name AS product_name,
    i.quantity,
    i.allocated_quantity,
    i.available_quantity,
    (i.quantity * p.unit_price) AS inventory_value,
    CASE 
        WHEN i.available_quantity <= p.min_stock_level THEN '需要补货'
        WHEN i.available_quantity >= p.max_stock_level THEN '库存过多'
        ELSE '正常'
    END AS stock_status
FROM 
    warehouses w
JOIN 
    inventory i ON w.warehouse_id = i.warehouse_id
JOIN 
    products p ON i.product_id = p.product_id
WHERE 
    w.warehouse_id = 1 AND p.is_active = TRUE
ORDER BY 
    p.name;
```

#### 3. 获取低库存产品

```sql
SELECT 
    p.product_id,
    p.sku,
    p.name AS product_name,
    p.min_stock_level,
    COALESCE(SUM(i.available_quantity), 0) AS total_available,
    (p.min_stock_level - COALESCE(SUM(i.available_quantity), 0)) AS shortage_quantity,
    (p.min_stock_level - COALESCE(SUM(i.available_quantity), 0)) * p.cost_price AS shortage_value
FROM 
    products p
LEFT JOIN 
    inventory i ON p.product_id = i.product_id
WHERE 
    p.is_active = TRUE
GROUP BY 
    p.product_id
HAVING 
    COALESCE(SUM(i.available_quantity), 0) <= p.min_stock_level
ORDER BY 
    shortage_quantity DESC;
```

#### 4. 获取库存交易历史

```sql
SELECT 
    it.transaction_id,
    it.transaction_type,
    it.quantity,
    it.transaction_date,
    it.notes,
    p.sku,
    p.name AS product_name,
    w.name AS warehouse_name,
    CASE 
        WHEN it.reference_type = 'purchase_order' THEN 
            CONCAT('采购订单 #', (SELECT order_number FROM purchase_orders WHERE purchase_order_id = it.reference_id))
        WHEN it.reference_type = 'sales_order' THEN 
            CONCAT('销售订单 #', (SELECT order_number FROM sales_orders WHERE sales_order_id = it.reference_id))
        WHEN it.reference_type = 'transfer_order' THEN 
            CONCAT('库存转移 #', (SELECT transfer_number FROM inventory_transfers WHERE transfer_id = it.reference_id))
        WHEN it.reference_type = 'adjustment' THEN 
            '库存调整'
        ELSE '其他'
    END AS reference
FROM 
    inventory_transactions it
JOIN 
    products p ON it.product_id = p.product_id
JOIN 
    warehouses w ON it.warehouse_id = w.warehouse_id
WHERE 
    it.product_id = 1
ORDER BY 
    it.transaction_date DESC;
```

#### 5. 获取库存价值报告

```sql
SELECT 
    w.warehouse_id,
    w.name AS warehouse_name,
    COUNT(DISTINCT i.product_id) AS product_count,
    SUM(i.quantity) AS total_quantity,
    SUM(i.quantity * p.cost_price) AS total_cost_value,
    SUM(i.quantity * p.unit_price) AS total_retail_value,
    (SUM(i.quantity * p.unit_price) - SUM(i.quantity * p.cost_price)) AS potential_profit,
    CASE 
        WHEN SUM(i.quantity * p.cost_price) > 0 
        THEN ((SUM(i.quantity * p.unit_price) - SUM(i.quantity * p.cost_price)) / SUM(i.quantity * p.cost_price)) * 100
        ELSE 0
    END AS profit_percentage
FROM 
    warehouses w
LEFT JOIN 
    inventory i ON w.warehouse_id = i.warehouse_id
LEFT JOIN 
    products p ON i.product_id = p.product_id
WHERE 
    p.is_active = TRUE
GROUP BY 
    w.warehouse_id
ORDER BY 
    total_cost_value DESC;
```

## 10.7 本章小结

本章通过五个实际项目案例，展示了SQL在不同业务场景中的应用：

1. **电商系统**：展示了如何设计电商数据库，包括用户、商品、订单、支付等核心模块，以及如何编写常用查询获取商品信息、用户订单历史、热门商品等。

2. **社交媒体数据分析**：展示了如何设计社交媒体数据库，包括用户、帖子、关注关系、评论等模块，以及如何进行用户动态流、热门话题、用户影响力等数据分析。

3. **企业人力资源管理系统**：展示了如何设计HR系统数据库，包括员工、部门、考勤、请假、绩效评估等模块，以及如何进行员工信息、考勤统计、部门薪资等查询。

4. **财务数据分析与报表**：展示了如何设计财务系统数据库，包括账户、交易、预算、发票等模块，以及如何生成试算平衡表、损益表、资产负债表、现金流量表等财务报表。

5. **物流与库存管理系统**：展示了如何设计物流系统数据库，包括产品、仓库、库存、采购、销售等模块，以及如何进行库存概览、低库存预警、库存交易历史等查询。

这些案例涵盖了SQL在实际应用中的各个方面，从基础的数据设计到复杂的查询分析，帮助读者更好地理解SQL在实际工作中的应用价值。通过学习这些案例，读者可以将SQL知识应用到自己的项目中，提高数据处理和分析能力。

## 10.8 思考题

1. 在电商系统中，如何设计一个查询来获取用户购买历史中的相关商品推荐？

2. 在社交媒体数据分析中，如何识别和推荐潜在的关注对象？

3. 在人力资源管理系统中，如何设计一个查询来识别可能离职风险较高的员工？

4. 在财务分析中，如何设计一个查询来预测下个季度的收入趋势？

5. 在库存管理中，如何设计一个查询来优化多个仓库之间的库存分配？

## 10.9 下章预告

在下一章中，我们将总结整个SQL学习旅程，并提供一些SQL学习的进阶资源和职业发展建议。我们将探讨如何持续提升SQL技能，以及SQL在数据科学和大数据领域的应用前景。同时，我们还将提供一些实用的SQL学习资源和认证路径，帮助读者在SQL领域取得更大的成就。