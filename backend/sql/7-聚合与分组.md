# 第7章：SQL聚合与分组

## 7.1 聚合函数概述

### 什么是聚合函数？

聚合函数是对一组值执行计算并返回单一值的函数。它们通常与GROUP BY子句一起使用，对分组后的数据进行汇总计算。聚合函数可以用于SELECT列表、HAVING子句和ORDER BY子句中。

### 常见的聚合函数

| 函数 | 描述 | 示例 |
|------|------|------|
| COUNT() | 计数，返回非NULL值的数量 | COUNT(column) |
| SUM() | 求和，返回数值列的总和 | SUM(column) |
| AVG() | 平均值，返回数值列的平均值 | AVG(column) |
| MIN() | 最小值，返回列中的最小值 | MIN(column) |
| MAX() | 最大值，返回列中的最大值 | MAX(column) |
| GROUP_CONCAT() | 连接字符串，将多行值连接为一个字符串 | GROUP_CONCAT(column) |

### 聚合函数的基本语法

```sql
SELECT aggregate_function(column) AS alias
FROM table
[WHERE condition]
[GROUP BY column]
[HAVING condition];
```

## 7.2 COUNT函数详解

### COUNT函数的用法

COUNT函数用于计算行数或非NULL值的数量。它有三种常见用法：

1. `COUNT(*)` - 计算所有行，包括NULL值
2. `COUNT(column)` - 计算指定列中非NULL值的数量
3. `COUNT(DISTINCT column)` - 计算指定列中不同值的数量

### COUNT(*)示例

```sql
-- 计算员工总数
SELECT COUNT(*) AS total_employees FROM employees;

-- 计算部门总数
SELECT COUNT(*) AS total_departments FROM departments;

-- 计算项目总数
SELECT COUNT(*) AS total_projects FROM projects;
```

### COUNT(column)示例

```sql
-- 计算有邮箱的员工数
SELECT COUNT(email) AS employees_with_email FROM employees;

-- 计算有经理的员工数
SELECT COUNT(manager_id) AS employees_with_manager FROM employees;

-- 计算有预算的部门数
SELECT COUNT(budget) AS departments_with_budget FROM departments;
```

### COUNT(DISTINCT)示例

```sql
-- 计算不同职位的数量
SELECT COUNT(DISTINCT position) AS distinct_positions FROM employees;

-- 计算不同部门的数量
SELECT COUNT(DISTINCT department_id) AS distinct_departments FROM employees;

-- 计算参与不同项目的员工数
SELECT COUNT(DISTINCT employee_id) AS employees_in_projects FROM employee_projects;
```

### 实验验证

让我们使用COUNT函数进行一些查询：

```sql
-- 创建示例数据库
CREATE DATABASE IF NOT EXISTS company_demo CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE company_demo;

-- 创建部门表
CREATE TABLE departments (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    manager_id INT,
    location VARCHAR(100),
    budget DECIMAL(12, 2)
);

-- 创建员工表
CREATE TABLE employees (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    age INT,
    gender VARCHAR(10),
    department_id INT,
    position VARCHAR(50),
    salary DECIMAL(10, 2),
    hire_date DATE,
    email VARCHAR(100),
    phone VARCHAR(20),
    is_active BOOLEAN DEFAULT TRUE,
    manager_id INT,
    FOREIGN KEY (department_id) REFERENCES departments(id),
    FOREIGN KEY (manager_id) REFERENCES employees(id)
);

-- 创建项目表
CREATE TABLE projects (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    start_date DATE,
    end_date DATE,
    budget DECIMAL(12, 2)
);

-- 创建员工项目关联表
CREATE TABLE employee_projects (
    employee_id INT,
    project_id INT,
    role VARCHAR(50),
    hours_worked INT DEFAULT 0,
    PRIMARY KEY (employee_id, project_id),
    FOREIGN KEY (employee_id) REFERENCES employees(id),
    FOREIGN KEY (project_id) REFERENCES projects(id)
);

-- 插入部门数据
INSERT INTO departments (name, location, budget) VALUES
('技术部', '北京', 1000000.00),
('市场部', '上海', 800000.00),
('人事部', '广州', 500000.00),
('财务部', '深圳', 600000.00),
('研发部', '杭州', 1200000.00);

-- 插入员工数据
INSERT INTO employees (name, age, gender, department_id, position, salary, hire_date, email, phone) VALUES
('张三', 30, '男', 1, '高级工程师', 15000.00, '2020-01-15', 'zhangsan@example.com', '13800138001'),
('李四', 28, '女', 1, '工程师', 12000.00, '2020-03-20', 'lisi@example.com', '13800138002'),
('王五', 35, '男', 1, '工程师', 13000.00, '2019-06-10', 'wangwu@example.com', '13800138003'),
('赵六', 25, '女', 1, '初级工程师', 8000.00, '2021-02-28', 'zhaoliu@example.com', '13800138004'),
('钱七', 32, '男', 2, '市场经理', 18000.00, '2019-11-05', 'qianqi@example.com', '13800138005'),
('孙八', 27, '女', 2, '市场专员', 9000.00, '2020-07-12', 'sunba@example.com', '13800138006'),
('周九', 40, '男', 2, '市场专员', 8500.00, '2020-05-20', 'zhoujiu@example.com', '13800138007'),
('吴十', 29, '女', 3, '人事经理', 16000.00, '2018-09-15', 'wushi@example.com', '13800138008'),
('郑十一', 26, '男', 3, '人事专员', 7000.00, '2021-01-10', 'zhengshiyi@example.com', '13800138009'),
('陈十二', 33, '女', 4, '财务经理', 20000.00, '2019-03-15', 'chenshier@example.com', '13800138010'),
('林十三', 28, '男', 4, '会计', 10000.00, '2020-06-20', 'linshisan@example.com', '13800138011'),
('黄十四', 36, '男', 5, '研发经理', 25000.00, '2018-05-10', 'huangshisi@example.com', '13800138012'),
('刘十五', 31, '女', 5, '高级研究员', 18000.00, '2019-08-15', 'liushiwu@example.com', '13800138013'),
('徐十六', 29, '男', 5, '研究员', 14000.00, '2020-02-20', 'xushiliu@example.com', '13800138014');

-- 插入项目数据
INSERT INTO projects (name, start_date, end_date, budget) VALUES
('项目A', '2023-01-01', '2023-12-31', 500000.00),
('项目B', '2023-03-01', '2023-08-31', 200000.00),
('项目C', '2023-04-01', '2023-09-30', 150000.00),
('项目D', '2023-02-15', '2023-11-30', 300000.00),
('项目E', '2023-05-01', '2023-10-31', 250000.00);

-- 插入员工项目关联数据
INSERT INTO employee_projects (employee_id, project_id, role, hours_worked) VALUES
(1, 1, '项目经理', 320),
(2, 1, '开发工程师', 400),
(3, 2, '项目经理', 200),
(4, 2, '市场专员', 300),
(5, 3, '项目经理', 150),
(6, 3, '人事专员', 200),
(7, 4, '项目经理', 250),
(8, 4, '人事专员', 180),
(9, 5, '项目经理', 220),
(10, 5, '财务专员', 160),
(11, 1, '财务专员', 120),
(12, 2, '会计', 140),
(13, 3, '研发主管', 280),
(14, 4, '高级研究员', 350),
(15, 5, '研究员', 300);

-- 设置经理关系
UPDATE employees SET manager_id = 1 WHERE id IN (2, 3);
UPDATE employees SET manager_id = 5 WHERE id IN (6, 7);
UPDATE employees SET manager_id = 8 WHERE id IN (9);
UPDATE employees SET manager_id = 10 WHERE id IN (11, 12);
UPDATE employees SET manager_id = 13 WHERE id IN (14, 15);

-- COUNT函数示例
-- COUNT(*)
SELECT COUNT(*) AS total_employees FROM employees;

-- COUNT(column)
SELECT COUNT(email) AS employees_with_email FROM employees;

-- COUNT(DISTINCT)
SELECT COUNT(DISTINCT position) AS distinct_positions FROM employees;
```

## 7.3 SUM函数详解

### SUM函数的用法

SUM函数用于计算数值列的总和。它忽略NULL值，只对非NULL值进行求和。

### SUM函数示例

```sql
-- 计算所有员工的总薪资
SELECT SUM(salary) AS total_salary FROM employees;

-- 计算各部门的总薪资
SELECT department_id, SUM(salary) AS department_salary
FROM employees
GROUP BY department_id;

-- 计算所有项目的总预算
SELECT SUM(budget) AS total_budget FROM projects;

-- 计算所有员工在所有项目上的总工作小时数
SELECT SUM(hours_worked) AS total_hours FROM employee_projects;
```

### SUM函数与条件表达式结合

```sql
-- 计算技术部员工的总薪资
SELECT SUM(salary) AS tech_department_salary
FROM employees
WHERE department_id = 1;

-- 计算薪资高于10000的员工的总薪资
SELECT SUM(salary) AS high_salary_total
FROM employees
WHERE salary > 10000;

-- 计算每个部门中薪资高于10000的员工的总薪资
SELECT department_id, SUM(CASE WHEN salary > 10000 THEN salary ELSE 0 END) AS high_salary_total
FROM employees
GROUP BY department_id;
```

### 实验验证

让我们使用SUM函数进行一些查询：

```sql
-- SUM函数示例
-- 计算所有员工的总薪资
SELECT SUM(salary) AS total_salary FROM employees;

-- 计算各部门的总薪资
SELECT 
    d.name AS department,
    SUM(e.salary) AS department_salary
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.id, d.name;

-- 计算所有项目的总预算
SELECT SUM(budget) AS total_budget FROM projects;

-- 计算所有员工在所有项目上的总工作小时数
SELECT SUM(hours_worked) AS total_hours FROM employee_projects;

-- SUM函数与条件表达式结合
-- 计算每个部门中薪资高于10000的员工的总薪资
SELECT 
    d.name AS department,
    SUM(e.salary) AS total_salary,
    SUM(CASE WHEN e.salary > 10000 THEN e.salary ELSE 0 END) AS high_salary_total
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.id, d.name;
```

## 7.4 AVG函数详解

### AVG函数的用法

AVG函数用于计算数值列的平均值。它忽略NULL值，只对非NULL值进行计算。

### AVG函数示例

```sql
-- 计算所有员工的平均薪资
SELECT AVG(salary) AS average_salary FROM employees;

-- 计算各部门的平均薪资
SELECT department_id, AVG(salary) AS department_avg_salary
FROM employees
GROUP BY department_id;

-- 计算所有项目的平均预算
SELECT AVG(budget) AS average_budget FROM projects;

-- 计算所有员工在所有项目上的平均工作小时数
SELECT AVG(hours_worked) AS average_hours FROM employee_projects;
```

### AVG函数与条件表达式结合

```sql
-- 计算技术部员工的平均薪资
SELECT AVG(salary) AS tech_department_avg_salary
FROM employees
WHERE department_id = 1;

-- 计算薪资高于10000的员工的平均薪资
SELECT AVG(salary) AS high_salary_average
FROM employees
WHERE salary > 10000;

-- 计算每个部门中薪资高于10000的员工的平均薪资
SELECT department_id, AVG(CASE WHEN salary > 10000 THEN salary ELSE NULL END) AS high_salary_avg
FROM employees
GROUP BY department_id;
```

### 实验验证

让我们使用AVG函数进行一些查询：

```sql
-- AVG函数示例
-- 计算所有员工的平均薪资
SELECT AVG(salary) AS average_salary FROM employees;

-- 计算各部门的平均薪资
SELECT 
    d.name AS department,
    AVG(e.salary) AS department_avg_salary
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.id, d.name;

-- 计算所有项目的平均预算
SELECT AVG(budget) AS average_budget FROM projects;

-- 计算所有员工在所有项目上的平均工作小时数
SELECT AVG(hours_worked) AS average_hours FROM employee_projects;

-- AVG函数与条件表达式结合
-- 计算每个部门中薪资高于10000的员工的平均薪资
SELECT 
    d.name AS department,
    AVG(e.salary) AS total_avg_salary,
    AVG(CASE WHEN e.salary > 10000 THEN e.salary ELSE NULL END) AS high_salary_avg
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.id, d.name;
```

## 7.5 MIN和MAX函数详解

### MIN和MAX函数的用法

MIN函数用于返回列中的最小值，MAX函数用于返回列中的最大值。它们可以用于数值、字符串和日期时间类型的列。

### MIN和MAX函数示例

```sql
-- 查找最低和最高薪资
SELECT MIN(salary) AS min_salary, MAX(salary) AS max_salary FROM employees;

-- 查找最早和最晚入职日期
SELECT MIN(hire_date) AS earliest_hire, MAX(hire_date) AS latest_hire FROM employees;

-- 查找最小和最大年龄
SELECT MIN(age) AS min_age, MAX(age) AS max_age FROM employees;

-- 查找最早开始和最晚结束的项目
SELECT MIN(start_date) AS earliest_start, MAX(end_date) AS latest_end FROM projects;
```

### MIN和MAX函数与GROUP BY结合

```sql
-- 查找各部门的最低和最高薪资
SELECT department_id, MIN(salary) AS min_salary, MAX(salary) AS max_salary
FROM employees
GROUP BY department_id;

-- 查找各部门最早和最晚入职日期
SELECT department_id, MIN(hire_date) AS earliest_hire, MAX(hire_date) AS latest_hire
FROM employees
GROUP BY department_id;
```

### 实验验证

让我们使用MIN和MAX函数进行一些查询：

```sql
-- MIN和MAX函数示例
-- 查找最低和最高薪资
SELECT MIN(salary) AS min_salary, MAX(salary) AS max_salary FROM employees;

-- 查找最早和最晚入职日期
SELECT MIN(hire_date) AS earliest_hire, MAX(hire_date) AS latest_hire FROM employees;

-- 查找最小和最大年龄
SELECT MIN(age) AS min_age, MAX(age) AS max_age FROM employees;

-- 查找最早开始和最晚结束的项目
SELECT MIN(start_date) AS earliest_start, MAX(end_date) AS latest_end FROM projects;

-- MIN和MAX函数与GROUP BY结合
-- 查找各部门的最低和最高薪资
SELECT 
    d.name AS department,
    MIN(e.salary) AS min_salary,
    MAX(e.salary) AS max_salary
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.id, d.name;

-- 查找各部门最早和最晚入职日期
SELECT 
    d.name AS department,
    MIN(e.hire_date) AS earliest_hire,
    MAX(e.hire_date) AS latest_hire
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.id, d.name;
```

## 7.6 GROUP_CONCAT函数详解

### GROUP_CONCAT函数的用法

GROUP_CONCAT函数用于将多行值连接为一个字符串。它常用于将分组后的多行数据合并为一个字符串显示。

### GROUP_CONCAT函数基本语法

```sql
GROUP_CONCAT([DISTINCT] expression [ORDER BY expression] [SEPARATOR separator])
```

### GROUP_CONCAT函数示例

```sql
-- 连接所有员工姓名
SELECT GROUP_CONCAT(name) AS all_employees FROM employees;

-- 连接各部门的员工姓名
SELECT department_id, GROUP_CONCAT(name) AS employees
FROM employees
GROUP BY department_id;

-- 连接各部门的员工姓名，按薪资降序排列
SELECT department_id, GROUP_CONCAT(name ORDER BY salary DESC) AS employees
FROM employees
GROUP BY department_id;

-- 连接各部门的员工姓名，使用自定义分隔符
SELECT department_id, GROUP_CONCAT(name SEPARATOR ' | ') AS employees
FROM employees
GROUP BY department_id;

-- 连接各部门的不同职位
SELECT department_id, GROUP_CONCAT(DISTINCT position) AS positions
FROM employees
GROUP BY department_id;
```

### 实验验证

让我们使用GROUP_CONCAT函数进行一些查询：

```sql
-- GROUP_CONCAT函数示例
-- 连接所有员工姓名
SELECT GROUP_CONCAT(name) AS all_employees FROM employees;

-- 连接各部门的员工姓名
SELECT 
    d.name AS department,
    GROUP_CONCAT(e.name) AS employees
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.id, d.name;

-- 连接各部门的员工姓名，按薪资降序排列
SELECT 
    d.name AS department,
    GROUP_CONCAT(e.name ORDER BY e.salary DESC) AS employees_by_salary
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.id, d.name;

-- 连接各部门的员工姓名，使用自定义分隔符
SELECT 
    d.name AS department,
    GROUP_CONCAT(e.name SEPARATOR ' | ') AS employees_with_separator
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.id, d.name;

-- 连接各部门的不同职位
SELECT 
    d.name AS department,
    GROUP_CONCAT(DISTINCT e.position) AS positions
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.id, d.name;
```

## 7.7 GROUP BY子句详解

### GROUP BY子句的用途

GROUP BY子句用于将具有相同值的行组合为摘要行，通常与聚合函数一起使用，对每个组进行计算。

### GROUP BY子句的基本语法

```sql
SELECT column1, column2, aggregate_function(column3)
FROM table
[WHERE condition]
GROUP BY column1, column2
[HAVING condition]
[ORDER BY column];
```

### 单列分组

```sql
-- 按部门分组，计算每个部门的员工数量
SELECT department_id, COUNT(*) AS employee_count
FROM employees
GROUP BY department_id;

-- 按职位分组，计算每个职位的平均薪资
SELECT position, AVG(salary) AS avg_salary
FROM employees
GROUP BY position;

-- 按性别分组，计算每个性别的员工数量
SELECT gender, COUNT(*) AS employee_count
FROM employees
GROUP BY gender;
```

### 多列分组

```sql
-- 按部门和职位分组，计算每个部门和职位的员工数量和平均薪资
SELECT department_id, position, COUNT(*) AS employee_count, AVG(salary) AS avg_salary
FROM employees
GROUP BY department_id, position;

-- 按部门和性别分组，计算每个部门和性别的员工数量和平均薪资
SELECT department_id, gender, COUNT(*) AS employee_count, AVG(salary) AS avg_salary
FROM employees
GROUP BY department_id, gender;
```

### GROUP BY与表达式

```sql
-- 按薪资范围分组
SELECT 
    CASE 
        WHEN salary < 10000 THEN '低薪'
        WHEN salary < 15000 THEN '中薪'
        ELSE '高薪'
    END AS salary_level,
    COUNT(*) AS employee_count
FROM employees
GROUP BY 
    CASE 
        WHEN salary < 10000 THEN '低薪'
        WHEN salary < 15000 THEN '中薪'
        ELSE '高薪'
    END;

-- 按入职年份分组
SELECT YEAR(hire_date) AS hire_year, COUNT(*) AS employee_count
FROM employees
GROUP BY YEAR(hire_date);

-- 按年龄段分组
SELECT 
    CASE 
        WHEN age < 30 THEN '青年'
        WHEN age < 40 THEN '中年'
        ELSE '老年'
    END AS age_group,
    COUNT(*) AS employee_count
FROM employees
GROUP BY 
    CASE 
        WHEN age < 30 THEN '青年'
        WHEN age < 40 THEN '中年'
        ELSE '老年'
    END;
```

### 实验验证

让我们使用GROUP BY子句进行一些查询：

```sql
-- 单列分组
-- 按部门分组，计算每个部门的员工数量
SELECT 
    d.name AS department,
    COUNT(*) AS employee_count
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.id, d.name;

-- 按职位分组，计算每个职位的平均薪资
SELECT 
    position,
    COUNT(*) AS employee_count,
    AVG(salary) AS avg_salary,
    MIN(salary) AS min_salary,
    MAX(salary) AS max_salary
FROM employees
GROUP BY position
ORDER BY avg_salary DESC;

-- 按性别分组，计算每个性别的员工数量
SELECT 
    gender,
    COUNT(*) AS employee_count,
    AVG(salary) AS avg_salary
FROM employees
GROUP BY gender;

-- 多列分组
-- 按部门和职位分组，计算每个部门和职位的员工数量和平均薪资
SELECT 
    d.name AS department,
    e.position,
    COUNT(*) AS employee_count,
    AVG(e.salary) AS avg_salary
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.id, d.name, e.position
ORDER BY d.name, avg_salary DESC;

-- GROUP BY与表达式
-- 按薪资范围分组
SELECT 
    CASE 
        WHEN e.salary < 10000 THEN '低薪'
        WHEN e.salary < 15000 THEN '中薪'
        ELSE '高薪'
    END AS salary_level,
    COUNT(*) AS employee_count,
    AVG(e.salary) AS avg_salary
FROM employees e
GROUP BY 
    CASE 
        WHEN e.salary < 10000 THEN '低薪'
        WHEN e.salary < 15000 THEN '中薪'
        ELSE '高薪'
    END
ORDER BY avg_salary;

-- 按入职年份分组
SELECT 
    YEAR(e.hire_date) AS hire_year,
    COUNT(*) AS employee_count,
    AVG(e.salary) AS avg_salary
FROM employees e
GROUP BY YEAR(e.hire_date)
ORDER BY hire_year;
```

## 7.8 HAVING子句详解

### HAVING子句的用途

HAVING子句用于过滤GROUP BY子句产生的结果，类似于WHERE子句，但HAVING子句用于聚合函数，而WHERE子句用于单个行。

### HAVING子句与WHERE子句的区别

| 特性 | WHERE子句 | HAVING子句 |
|------|-----------|------------|
| 应用时机 | 分组前 | 分组后 |
| 使用对象 | 单个行 | 分组 |
| 聚合函数 | 不能使用 | 可以使用 |
| 执行顺序 | 在GROUP BY之前 | 在GROUP BY之后 |

### HAVING子句示例

```sql
-- 查询员工数量大于3的部门
SELECT department_id, COUNT(*) AS employee_count
FROM employees
GROUP BY department_id
HAVING COUNT(*) > 3;

-- 查询平均薪资大于10000的部门
SELECT department_id, AVG(salary) AS avg_salary
FROM employees
GROUP BY department_id
HAVING AVG(salary) > 10000;

-- 查询薪资范围大于5000的职位
SELECT position, MIN(salary) AS min_salary, MAX(salary) AS max_salary
FROM employees
GROUP BY position
HAVING MAX(salary) - MIN(salary) > 5000;

-- 查询员工数量大于1且平均薪资大于10000的部门
SELECT department_id, COUNT(*) AS employee_count, AVG(salary) AS avg_salary
FROM employees
GROUP BY department_id
HAVING COUNT(*) > 1 AND AVG(salary) > 10000;
```

### HAVING子句与WHERE子句结合使用

```sql
-- 查询薪资大于10000的员工中，平均薪资大于12000的部门
SELECT department_id, COUNT(*) AS employee_count, AVG(salary) AS avg_salary
FROM employees
WHERE salary > 10000
GROUP BY department_id
HAVING AVG(salary) > 12000;

-- 查询2020年以后入职的员工中，平均薪资大于10000的部门
SELECT department_id, COUNT(*) AS employee_count, AVG(salary) AS avg_salary
FROM employees
WHERE hire_date >= '2020-01-01'
GROUP BY department_id
HAVING AVG(salary) > 10000;
```

### 实验验证

让我们使用HAVING子句进行一些查询：

```sql
-- HAVING子句示例
-- 查询员工数量大于3的部门
SELECT 
    d.name AS department,
    COUNT(*) AS employee_count
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.id, d.name
HAVING COUNT(*) > 3;

-- 查询平均薪资大于10000的部门
SELECT 
    d.name AS department,
    COUNT(*) AS employee_count,
    AVG(e.salary) AS avg_salary
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.id, d.name
HAVING AVG(e.salary) > 10000;

-- 查询薪资范围大于5000的职位
SELECT 
    position,
    COUNT(*) AS employee_count,
    MIN(salary) AS min_salary,
    MAX(salary) AS max_salary,
    MAX(salary) - MIN(salary) AS salary_range
FROM employees
GROUP BY position
HAVING MAX(salary) - MIN(salary) > 5000;

-- HAVING子句与WHERE子句结合使用
-- 查询薪资大于10000的员工中，平均薪资大于12000的部门
SELECT 
    d.name AS department,
    COUNT(*) AS employee_count,
    AVG(e.salary) AS avg_salary
FROM employees e
JOIN departments d ON e.department_id = d.id
WHERE e.salary > 10000
GROUP BY d.id, d.name
HAVING AVG(e.salary) > 12000;

-- 查询2020年以后入职的员工中，平均薪资大于10000的部门
SELECT 
    d.name AS department,
    COUNT(*) AS employee_count,
    AVG(e.salary) AS avg_salary
FROM employees e
JOIN departments d ON e.department_id = d.id
WHERE e.hire_date >= '2020-01-01'
GROUP BY d.id, d.name
HAVING AVG(e.salary) > 10000;
```

## 7.9 高级分组技巧

### ROLLUP分组

ROLLUP生成多级汇总，包括小计和总计。

```sql
-- 使用ROLLUP生成分组汇总
SELECT 
    COALESCE(d.name, '总计') AS department,
    COALESCE(e.position, '小计') AS position,
    COUNT(*) AS employee_count,
    AVG(e.salary) AS avg_salary
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.name, e.position WITH ROLLUP;
```

### CUBE分组

CUBE生成所有可能的组合汇总。

```sql
-- 使用CUBE生成分组汇总
SELECT 
    COALESCE(d.name, '总计') AS department,
    COALESCE(e.gender, '总计') AS gender,
    COUNT(*) AS employee_count,
    AVG(e.salary) AS avg_salary
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.name, e.gender WITH CUBE;
```

### GROUPING SETS分组

GROUPING SETS允许指定多个分组集合。

```sql
-- 使用GROUPING SETS生成分组汇总
SELECT 
    COALESCE(d.name, '总计') AS department,
    COALESCE(e.position, '总计') AS position,
    COUNT(*) AS employee_count,
    AVG(e.salary) AS avg_salary
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY GROUPING SETS (
    (d.name),           -- 按部门分组
    (e.position),        -- 按职位分组
    (d.name, e.position), -- 按部门和职位分组
    ()                   -- 总计
);
```

### 实验验证

让我们使用高级分组技巧进行一些查询：

```sql
-- 使用ROLLUP生成分组汇总
SELECT 
    COALESCE(d.name, '总计') AS department,
    COALESCE(e.position, '小计') AS position,
    COUNT(*) AS employee_count,
    AVG(e.salary) AS avg_salary
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.name, e.position WITH ROLLUP;

-- 使用GROUPING SETS生成分组汇总
SELECT 
    COALESCE(d.name, '总计') AS department,
    COALESCE(e.position, '总计') AS position,
    COUNT(*) AS employee_count,
    AVG(e.salary) AS avg_salary
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY GROUPING SETS (
    (d.name),           -- 按部门分组
    (e.position),        -- 按职位分组
    (d.name, e.position), -- 按部门和职位分组
    ()                   -- 总计
);
```

## 7.10 聚合函数与连接查询结合

### 聚合函数与内连接

```sql
-- 查询各部门的员工数量和平均薪资
SELECT 
    d.name AS department,
    COUNT(e.id) AS employee_count,
    AVG(e.salary) AS avg_salary,
    MIN(e.salary) AS min_salary,
    MAX(e.salary) AS max_salary
FROM departments d
JOIN employees e ON d.id = e.department_id
GROUP BY d.id, d.name
ORDER BY employee_count DESC;

-- 查询每个项目的参与人数和总工作小时数
SELECT 
    p.name AS project,
    COUNT(DISTINCT ep.employee_id) AS employee_count,
    SUM(ep.hours_worked) AS total_hours,
    AVG(ep.hours_worked) AS avg_hours
FROM projects p
JOIN employee_projects ep ON p.id = ep.project_id
GROUP BY p.id, p.name
ORDER BY total_hours DESC;
```

### 聚合函数与左连接

```sql
-- 查询所有部门的员工数量（包括没有员工的部门）
SELECT 
    d.name AS department,
    COUNT(e.id) AS employee_count,
    AVG(e.salary) AS avg_salary
FROM departments d
LEFT JOIN employees e ON d.id = e.department_id
GROUP BY d.id, d.name
ORDER BY employee_count DESC;

-- 查询所有项目的参与人数（包括没有参与者的项目）
SELECT 
    p.name AS project,
    COUNT(DISTINCT ep.employee_id) AS employee_count,
    SUM(ep.hours_worked) AS total_hours
FROM projects p
LEFT JOIN employee_projects ep ON p.id = ep.project_id
GROUP BY p.id, p.name
ORDER BY employee_count DESC;
```

### 聚合函数与多表连接

```sql
-- 查询各部门中不同职位的员工数量和平均薪资
SELECT 
    d.name AS department,
    e.position,
    COUNT(*) AS employee_count,
    AVG(e.salary) AS avg_salary
FROM departments d
JOIN employees e ON d.id = e.department_id
GROUP BY d.id, d.name, e.position
ORDER BY d.name, employee_count DESC;

-- 查询各部门员工参与的项目数量和总工作小时数
SELECT 
    d.name AS department,
    COUNT(DISTINCT p.id) AS project_count,
    SUM(ep.hours_worked) AS total_hours
FROM departments d
JOIN employees e ON d.id = e.department_id
LEFT JOIN employee_projects ep ON e.id = ep.employee_id
LEFT JOIN projects p ON ep.project_id = p.id
GROUP BY d.id, d.name
ORDER BY total_hours DESC;
```

### 实验验证

让我们使用聚合函数与连接查询结合进行一些查询：

```sql
-- 聚合函数与内连接
-- 查询各部门的员工数量和平均薪资
SELECT 
    d.name AS department,
    COUNT(e.id) AS employee_count,
    AVG(e.salary) AS avg_salary,
    MIN(e.salary) AS min_salary,
    MAX(e.salary) AS max_salary
FROM departments d
JOIN employees e ON d.id = e.department_id
GROUP BY d.id, d.name
ORDER BY employee_count DESC;

-- 查询每个项目的参与人数和总工作小时数
SELECT 
    p.name AS project,
    COUNT(DISTINCT ep.employee_id) AS employee_count,
    SUM(ep.hours_worked) AS total_hours,
    AVG(ep.hours_worked) AS avg_hours
FROM projects p
JOIN employee_projects ep ON p.id = ep.project_id
GROUP BY p.id, p.name
ORDER BY total_hours DESC;

-- 聚合函数与左连接
-- 查询所有部门的员工数量（包括没有员工的部门）
SELECT 
    d.name AS department,
    COUNT(e.id) AS employee_count,
    AVG(e.salary) AS avg_salary
FROM departments d
LEFT JOIN employees e ON d.id = e.department_id
GROUP BY d.id, d.name
ORDER BY employee_count DESC;

-- 聚合函数与多表连接
-- 查询各部门中不同职位的员工数量和平均薪资
SELECT 
    d.name AS department,
    e.position,
    COUNT(*) AS employee_count,
    AVG(e.salary) AS avg_salary
FROM departments d
JOIN employees e ON d.id = e.department_id
GROUP BY d.id, d.name, e.position
ORDER BY d.name, employee_count DESC;
```

## 7.11 本章小结

本章介绍了SQL的聚合与分组，包括：

1. **聚合函数**：COUNT、SUM、AVG、MIN、MAX和GROUP_CONCAT等函数的使用
2. **GROUP BY子句**：单列分组、多列分组和表达式分组
3. **HAVING子句**：过滤分组结果，与WHERE子句的区别
4. **高级分组技巧**：ROLLUP、CUBE和GROUPING SETS的使用
5. **聚合函数与连接查询结合**：实现更复杂的数据汇总分析

通过本章的学习，您应该能够：

- 使用各种聚合函数进行数据汇总计算
- 使用GROUP BY子句对数据进行分组
- 使用HAVING子句过滤分组结果
- 理解WHERE子句和HAVING子句的区别
- 使用高级分组技巧生成多级汇总
- 将聚合函数与连接查询结合使用

## 7.12 思考题

1. WHERE子句和HAVING子句有什么区别？在什么情况下应该使用HAVING子句？
2. COUNT(*)、COUNT(column)和COUNT(DISTINCT column)有什么区别？
3. GROUP BY子句中可以使用别名吗？为什么？
4. 如何使用ROLLUP和CUBE生成分组汇总？它们有什么区别？
5. 聚合函数与连接查询结合使用时，应该注意哪些问题？

## 7.13 下章预告

在第8章中，我们将学习SQL的高级特性，包括：

- 视图（View）的创建和使用
- 存储过程（Stored Procedure）的编写和调用
- 触发器（Trigger）的创建和应用
- 事务（Transaction）的处理
- 游标（Cursor）的使用

---

*继续学习，掌握SQL高级特性的应用！*