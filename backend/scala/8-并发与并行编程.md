# 第8章：并发与并行编程

并发与并行编程是现代软件开发中的关键领域，Scala提供了强大的工具和抽象来简化这些复杂的任务。本章将深入探讨Scala的并发和并行编程模型，包括线程、Future、Promise、Actor以及并行集合。

## 8.1 并发与并行的基本概念

### 8.1.1 并发与并行的区别

并发（Concurrency）和并行（Parallelism）是两个经常被混淆的概念：

- **并发**：指系统能够处理多个任务的能力，但不一定同时执行。通过任务切换实现。
- **并行**：指系统真正同时执行多个任务的能力，通常需要多个处理器。

```scala
// 并发示例 - 使用多线程处理任务
import scala.concurrent._
import ExecutionContext.Implicits.global

val future1 = Future { Thread.sleep(1000); "Result 1" }
val future2 = Future { Thread.sleep(1000); "Result 2" }

// 两个任务可以并发执行，但不一定并行

// 并行示例 - 使用并行集合处理数据
val list = (1 to 1000000).toList
val sum = list.par.map(_ * 2).sum  // 使用多个CPU核心并行处理
```

### 8.1.2 Scala中的并发模型

Scala提供了多种并发编程模型：

1. **共享内存并发**：基于锁和同步的传统模型
2. **Actor模型**：基于消息传递的并发模型（通过Akka框架）
3. **Future/Promise**：用于异步计算的高阶抽象
4. **并行集合**：用于数据并行处理

## 8.2 基础并发：线程与同步

### 8.2.1 创建和管理线程

Scala可以直接使用Java的线程API：

```scala
import java.lang.Thread
import java.util.concurrent.{Executors, ExecutorService}

// 1. 直接创建Thread
class SimpleTask extends Runnable {
  def run(): Unit = {
    println(s"Thread ${Thread.currentThread().getName} is running")
    Thread.sleep(1000)
    println(s"Thread ${Thread.currentThread().getName} finished")
  }
}

// 创建并启动线程
val thread1 = new Thread(new SimpleTask)
thread1.setName("Worker-1")
thread1.start()

// 2. 使用线程池
val executor: ExecutorService = Executors.newFixedThreadPool(5)

for (i <- 1 to 10) {
  executor.submit(new Runnable {
    def run(): Unit = {
      println(s"Task $i running on ${Thread.currentThread().getName}")
      Thread.sleep(1000)
    }
  })
}

executor.shutdown()
```

### 8.2.2 同原语

Scala提供了多种同步原语来控制并发访问：

```scala
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.{CountDownLatch, CyclicBarrier, Semaphore}
import scala.collection.mutable
import scala.concurrent._
import ExecutionContext.Implicits.global

// 1. synchronized关键字
class Counter {
  private var value = 0
  
  def increment(): Unit = synchronized {
    value += 1
  }
  
  def get: Int = synchronized {
    value
  }
}

// 2. Atomic变量
class AtomicCounter {
  private val value = new AtomicInteger(0)
  
  def increment(): Int = value.incrementAndGet()
  def get: Int = value.get()
}

// 3. CountDownLatch
object CountDownLatchExample {
  def runTaskWithLatch(latch: CountDownLatch, taskId: Int): Future[Unit] = Future {
    Thread.sleep((math.random() * 1000).toLong)
    println(s"Task $taskId completed")
    latch.countDown()
  }
  
  def demo(): Unit = {
    val taskCount = 5
    val latch = new CountDownLatch(taskCount)
    
    for (i <- 1 to taskCount) {
      runTaskWithLatch(latch, i)
    }
    
    latch.await()  // 等待所有任务完成
    println("All tasks completed!")
  }
}

// 4. Semaphore
object SemaphoreExample {
  def demo(): Unit = {
    val semaphore = new Semaphore(2)  // 最多允许2个并发访问
    
    for (i <- 1 to 5) {
      Future {
        semaphore.acquire()
        try {
          println(s"Thread $i acquired permit")
          Thread.sleep(1000)
        } finally {
          println(s"Thread $i releasing permit")
          semaphore.release()
        }
      }
    }
  }
}
```

### 8.2.3 线程安全集合

```scala
import java.util.concurrent.{ConcurrentHashMap, CopyOnWriteArrayList}
import scala.collection.JavaConverters._
import scala.collection.concurrent
import scala.collection.mutable

// 1. Java线程安全集合的Scala使用
def javaCollectionsExample(): Unit = {
  // ConcurrentHashMap
  val concurrentMap = new ConcurrentHashMap[String, Int]()
  concurrentMap.put("Scala", 1)
  concurrentMap.put("Java", 2)
  
  // 转换为Scala可变Map
  val scalaMap: concurrent.Map[String, Int] = concurrentMap.asScala
  
  // CopyOnWriteArrayList
  val concurrentList = new CopyOnWriteArrayList[String]()
  concurrentList.add("Thread-Safe")
  concurrentList.add("List")
}

// 2. Scala并发集合
def scalaConcurrentCollections(): Unit = {
  // TrieMap - 线程安全的Map
  val concurrentMap = scala.collection.concurrent.TrieMap.empty[String, Int]
  concurrentMap.put("Scala", 1)
  concurrentMap.put("Java", 2)
  
  // 并发修改
  Future {
    concurrentMap.update("Scala", 3)
  }
  
  Future {
    concurrentMap.remove("Java")
  }
}
```

## 8.3 Future和Promise

### 8.3.1 Future简介

Future表示一个可能尚未完成的异步计算的结果：

```scala
import scala.concurrent._
import ExecutionContext.Implicits.global
import scala.util.{Success, Failure}

object FutureBasics {
  // 1. 创建Future
  def createFutures(): Unit = {
    // 使用Future.apply
    val future1 = Future {
      Thread.sleep(1000)
      42
    }
    
    // 使用Future.successful创建已完成的Future
    val future2 = Future.successful("Already done")
    
    // 使用Future.failed创建失败的Future
    val future3 = Future.failed(new RuntimeException("Failed"))
  }
  
  // 2. 组合Future
  def combineFutures(): Future[String] = {
    val future1 = Future {
      Thread.sleep(500)
      "Hello"
    }
    
    val future2 = Future {
      Thread.sleep(1000)
      "World"
    }
    
    // 使用for组合
    val combined = for {
      hello <- future1
      world <- future2
    } yield s"$hello $world"
    
    // 或者使用map和flatMap
    val combinedAlt = future1.flatMap(h => future2.map(w => s"$h $w"))
    
    combined
  }
  
  // 3. 处理Future结果
  def handleFutureResults(): Unit = {
    val future = Future {
      Thread.sleep(500)
      if (math.random() > 0.5) 42 else throw new RuntimeException("Random failure")
    }
    
    // 使用onComplete回调
    future.onComplete {
      case Success(value) => println(s"Success: $value")
      case Failure(exception) => println(s"Failure: ${exception.getMessage}")
    }
    
    // 使用foreach处理成功情况
    future.foreach(value => println(s"Value: $value"))
    
    // 使用recover处理失败情况
    val recovered = future.recover {
      case _: RuntimeException => 0
    }
    
    // 使用recoverWith处理失败并返回另一个Future
    val recoveredWith = future.recoverWith {
      case _: RuntimeException => Future.successful(0)
    }
    
    // 使用fallbackTo提供备选Future
    val fallback = future.fallbackTo(Future.successful(100))
  }
  
  // 4. 等待Future完成
  def waitForFuture(): Unit = {
    val future = Future {
      Thread.sleep(1000)
      42
    }
    
    // 不推荐在生产代码中使用阻塞等待
    import scala.concurrent.duration._
    
    // 阻塞等待结果
    val result = Await.result(future, 2.seconds)
    println(s"Result: $result")
    
    // 阻塞等待第一个Future完成
    val futures = List(Future { 1 }, Future { 2 }, Future { 3 })
    val first = Await.result(Future.firstCompletedOf(futures), 5.seconds)
    println(s"First completed: $first")
  }
}
```

### 8.3.2 Promise

Promise是Future的可写版本，允许手动完成Future：

```scala
import scala.concurrent._
import ExecutionContext.Implicits.global
import scala.util.{Success, Failure}

object PromiseBasics {
  // 1. 创建和使用Promise
  def basicPromise(): Future[String] = {
    val promise = Promise[String]()
    val future = promise.future
    
    // 在另一个线程中完成Promise
    Future {
      Thread.sleep(1000)
      promise.success("Hello from Promise!")
    }
    
    future
  }
  
  // 2. 模拟异步操作
  def simulateAsyncOperation(input: Int): Future[Int] = {
    val promise = Promise[Int]()
    
    Future {
      Thread.sleep((math.random() * 1000).toLong)
      if (input > 0) {
        promise.success(input * 2)
      } else {
        promise.failure(new IllegalArgumentException("Input must be positive"))
      }
    }
    
    promise.future
  }
  
  // 3. Promise与回调
  def promiseWithCallback(): Unit = {
    val promise = Promise[String]()
    
    // 添加回调
    promise.future.onComplete {
      case Success(value) => println(s"Completed with: $value")
      case Failure(exception) => println(s"Failed with: ${exception.getMessage}")
    }
    
    // 完成Promise
    promise.success("Operation completed!")
  }
  
  // 4. 使用Promise协调多个Future
  def coordinateFutures(): Future[(String, Int)] = {
    val stringPromise = Promise[String]()
    val intPromise = Promise[Int]()
    
    Future {
      Thread.sleep(500)
      stringPromise.success("Hello")
    }
    
    Future {
      Thread.sleep(1000)
      intPromise.success(42)
    }
    
    for {
      str <- stringPromise.future
      num <- intPromise.future
    } yield (str, num)
  }
}
```

### 8.3.3 实用并发工具

```scala
import scala.concurrent._
import ExecutionContext.Implicits.global
import scala.concurrent.duration._

object ConcurrentUtils {
  // 1. 限制并发数
  def limitConcurrent[T](tasks: List[() => T], maxConcurrency: Int): List[Future[T]] = {
    val semaphore = new java.util.concurrent.Semaphore(maxConcurrency)
    
    tasks.map { task =>
      Future {
        semaphore.acquire()
        try {
          task()
        } finally {
          semaphore.release()
        }
      }
    }
  }
  
  // 2. 超时处理
  def withTimeout[T](future: Future[T], timeout: FiniteDuration): Future[T] = {
    val timeoutFuture = Future {
      Thread.sleep(timeout.toMillis)
      throw new TimeoutException(s"Operation timed out after $timeout")
    }
    
    Future.firstCompletedOf(List(future, timeoutFuture))
  }
  
  // 3. 重试机制
  def retry[T](operation: () => Future[T], maxRetries: Int): Future[T] = {
    operation().recoverWith {
      case _ if maxRetries > 0 =>
        Thread.sleep(100)
        retry(operation, maxRetries - 1)
    }
  }
  
  // 4. 批量处理
  def batchProcess[T, R](items: List[T], batchSize: Int, 
                         processor: List[T] => Future[List[R]]): Future[List[R]] = {
    val batches = items.grouped(batchSize).toList
    
    val batchFutures = batches.map { batch =>
      processor(batch)
    }
    
    Future.sequence(batchFutures).map(_.flatten)
  }
}
```

## 8.4 Actor模型与Akka简介

### 8.4.1 Actor模型基础

Actor模型是一种基于消息传递的并发模型，其中：

- **Actor**：并发计算的基本单元
- **消息**：Actor之间的通信方式
- **邮箱**：存储待处理消息的队列
- **行为**：Actor如何处理消息

```scala
// Akka Actor基本示例（需要添加Akka依赖）
import akka.actor.{Actor, ActorRef, ActorSystem, Props}

// 定义Actor
class CounterActor extends Actor {
  private var count = 0
  
  def receive: Receive = {
    case "increment" => 
      count += 1
      println(s"Count is now $count")
    case "get" => 
      sender() ! count
    case msg => 
      println(s"Unknown message: $msg")
  }
}

object ActorBasics {
  // 1. 创建Actor系统
  val system = ActorSystem("CounterSystem")
  
  // 2. 创建Actor
  val counterActor: ActorRef = system.actorOf(Props[CounterActor], "counter")
  
  // 3. 发送消息
  def sendMessages(): Unit = {
    counterActor ! "increment"
    counterActor ! "increment"
    counterActor ! "get"
  }
  
  // 4. 优雅关闭
  def shutdown(): Unit = {
    system.terminate()
  }
}
```

### 8.4.2 消息传递模式

```scala
import akka.actor.{Actor, ActorLogging, ActorRef, ActorSystem, Props, Terminated}
import akka.pattern.pipe
import scala.concurrent.Future
import ExecutionContext.Implicits.global

// 1. 请求-响应模式
case class Request(message: String)
case class Response(message: String)

class ResponderActor extends Actor {
  def receive: Receive = {
    case Request(msg) => 
      Thread.sleep(1000)  // 模拟耗时操作
      sender() ! Response(s"Response to: $msg")
  }
}

// 2. 消息转发
case class ForwardMessage(to: ActorRef, message: Any)

class ForwarderActor extends Actor {
  def receive: Receive = {
    case ForwardMessage(to, msg) => to forward msg
    case msg => println(s"Received: $msg")
  }
}

// 3. Ask模式（需要导入akka.pattern.ask）
import akka.pattern.ask
import scala.concurrent.duration._
import scala.util.{Success, Failure}

class AskExample {
  implicit val timeout = 3.seconds
  val system = ActorSystem("AskExample")
  val responder = system.actorOf(Props[ResponderActor], "responder")
  
  def askExample(): Future[String] = {
    (responder ? Request("Hello")).mapTo[Response].map(_.message)
  }
}

// 4. Actor生命周期管理
class LifecycleActor extends Actor with ActorLogging {
  def receive: Receive = {
    case msg => log.info(s"Received: $msg")
  }
  
  override def preStart(): Unit = {
    log.info("Actor starting")
  }
  
  override def postStop(): Unit = {
    log.info("Actor stopped")
  }
  
  override def preRestart(reason: Throwable, message: Option[Any]): Unit = {
    log.info(s"Actor restarting due to ${reason.getMessage}")
    super.preRestart(reason, message)
  }
  
  override def postRestart(reason: Throwable): Unit = {
    log.info("Actor restarted")
    super.postRestart(reason)
  }
}

// 5. Actor监督策略
import akka.actor.SupervisorStrategy._

class SupervisorActor extends Actor {
  import akka.actor.OneForOneStrategy
  import scala.concurrent.duration._

  override val supervisorStrategy = OneForOneStrategy(maxNrOfRetries = 3, withinTimeRange = 1.minute) {
    case _: ArithmeticException => Resume
    case _: NullPointerException => Restart
    case _: IllegalArgumentException => Stop
    case _: Exception => Escalate
  }
  
  def receive: Receive = {
    case msg => println(s"Supervisor received: $msg")
  }
}
```

### 8.4.3 并发模式示例

```scala
import akka.actor.{Actor, ActorRef, ActorSystem, Props, Stash}
import akka.routing.RoundRobinPool
import scala.concurrent.Future
import scala.util.Random

// 1. Master-Worker模式
case class Work(message: String)
case class WorkDone(result: String)
case class StartWork(workItems: List[String])

class WorkerActor extends Actor {
  def receive: Receive = {
    case Work(msg) => 
      val result = processWork(msg)
      sender() ! WorkDone(result)
  }
  
  private def processWork(msg: String): String = {
    Thread.sleep(500)  // 模拟工作
    s"Processed: $msg"
  }
}

class MasterActor extends Actor {
  var results = List.empty[String]
  var workItems = List.empty[String]
  var pending = 0
  
  def receive: Receive = {
    case StartWork(items) =>
      workItems = items
      distributeWork()
      
    case WorkDone(result) =>
      results = result :: results
      pending -= 1
      
      if (pending == 0 && workItems.isEmpty) {
        println(s"All work done: ${results.reverse}")
        context.system.terminate()
      } else if (workItems.nonEmpty) {
        distributeWork()
      }
  }
  
  private def distributeWork(): Unit = {
    if (workItems.nonEmpty) {
      val worker = context.actorOf(Props[WorkerActor])
      worker ! Work(workItems.head)
      workItems = workItems.tail
      pending += 1
    }
  }
}

// 2. 生产者-消费者模式
case class Produce(item: String)
case class Consume()
case class ItemAvailable(item: String)
case class EmptyBuffer()

class ProducerActor(consumer: ActorRef) extends Actor {
  def receive: Receive = {
    case Produce(item) =>
      Thread.sleep(Random.nextInt(1000))
      consumer ! ItemAvailable(item)
  }
}

class ConsumerActor extends Actor {
  private var buffer = List.empty[String]
  
  def receive: Receive = {
    case ItemAvailable(item) =>
      buffer = item :: buffer
      println(s"Buffer now has: ${buffer.mkString(", ")}")
      
    case Consume =>
      if (buffer.nonEmpty) {
        val item = buffer.head
        buffer = buffer.tail
        println(s"Consumed: $item")
      } else {
        sender() ! EmptyBuffer()
      }
  }
}
```

## 8.5 并行集合

### 8.5.1 并行集合基础

Scala集合可以轻松转换为并行版本，利用多核处理器进行并行计算：

```scala
import scala.collection.parallel.CollectionConverters._

object ParallelCollections {
  // 1. 基本并行操作
  def basicParallelOperations(): Unit = {
    val list = (1 to 1000000).toList
    
    // 转换为并行集合
    val parallelList = list.par
    
    // 并行map
    val doubled = parallelList.map(_ * 2)
    
    // 并行filter
    val evenNumbers = parallelList.filter(_ % 2 == 0)
    
    // 并行reduce
    val sum = parallelList.reduce(_ + _)
    
    // 并行fold
    val product = parallelList.fold(1)(_ * _)
    
    println(s"Sum of first million numbers: $sum")
  }
  
  // 2. 并行集合性能比较
  def performanceComparison(): Unit = {
    val data = (1 to 10000000).toArray
    
    // 顺序操作时间
    val sequentialStart = System.nanoTime()
    val sequentialSum = data.map(_ * 2).filter(_ % 3 == 0).sum
    val sequentialTime = System.nanoTime() - sequentialStart
    
    // 并行操作时间
    val parallelStart = System.nanoTime()
    val parallelSum = data.par.map(_ * 2).filter(_ % 3 == 0).sum
    val parallelTime = System.nanoTime() - parallelStart
    
    println(s"Sequential time: ${sequentialTime / 1000000} ms")
    println(s"Parallel time: ${parallelTime / 1000000} ms")
    println(s"Speedup: ${sequentialTime.toDouble / parallelTime}")
    
    // 验证结果一致性
    assert(sequentialSum == parallelSum, "Results should be equal")
  }
  
  // 3. 并行集合陷阱
  def parallelPitfalls(): Unit = {
    // 陷阱1：副作用操作顺序不确定
    val list = (1 to 10).toList
    var sum = 0
    
    // 这种用法有问题，因为操作顺序不确定
    list.par.foreach(x => sum += x)  // 结果可能不正确
    
    // 正确方式：使用reduce或fold
    val correctSum = list.par.reduce(_ + _)
    
    // 陷阱2：共享可变状态
    val mutableSet = scala.collection.mutable.Set[Int]()
    list.par.foreach(mutableSet += _)  // 可能导致数据竞争
    
    // 正确方式：使用不可变操作
    val immutableSet = list.par.toSet
    
    println(s"Correct sum: $correctSum")
    println(s"Immutable set size: ${immutableSet.size}")
  }
}
```

### 8.5.2 并行集合高级用法

```scala
import scala.collection.parallel.CollectionConverters._
import scala.util.Random

object AdvancedParallelCollections {
  // 1. 自定义任务分割
  def customTaskSplitting(): Unit = {
    val data = (1 to 10000).toList
    
    // 调整并行集合的阈值
    val parallelList = data.par
    parallelList.tasksupport = new scala.collection.parallel.ForkJoinTaskSupport(
      new scala.concurrent.forkjoin.ForkJoinPool(4)
    )
    
    // 执行并行操作
    val result = parallelList.map(x => {
      // 模拟计算密集型任务
      Thread.sleep(1)
      x * x
    }).sum
    
    println(s"Custom task splitting result: $result")
  }
  
  // 2. 并行聚合操作
  def parallelAggregation(): Unit = {
    case class Sale(product: String, category: String, amount: Double)
    
    val sales = (1 to 10000).map { i =>
      val products = List("Laptop", "Phone", "Tablet", "Monitor", "Keyboard")
      val categories = List("Electronics", "Accessories", "Peripherals")
      
      Sale(
        products(Random.nextInt(products.length)),
        categories(Random.nextInt(categories.length)),
        Random.nextDouble() * 1000
      )
    }
    
    // 并行聚合：按类别计算总销售额
    val salesByCategory = sales.par.groupBy(_.category).map {
      case (category, categorySales) => 
        category -> categorySales.map(_.amount).sum
    }.seq.toMap  // 转换回顺序Map
    
    salesByCategory.foreach { case (category, total) =>
      println(f"Category: $category, Total: $total%.2f")
    }
  }
  
  // 3. 并行集合与不可变性
  def parallelWithImmutability(): Unit = {
    // 递归函数并行处理树结构
    sealed trait Tree[+A]
    case class Leaf[A](value: A) extends Tree[A]
    case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A]
    
    def sumTree(tree: Tree[Int]): Int = tree match {
      case Leaf(value) => value
      case Branch(left, right) =>
        // 使用并行递归
        val (leftSum, rightSum) = (sumTree(left), sumTree(right)) match {
          case (l, r) => (l, r)  // 在实际应用中可以使用并行版本
        }
        leftSum + rightSum
    }
    
    // 创建一个深度为15的二叉树
    def createTree(depth: Int): Tree[Int] = {
      if (depth <= 0) Leaf(Random.nextInt(100))
      else Branch(createTree(depth - 1), createTree(depth - 1))
    }
    
    val tree = createTree(15)
    val treeSum = sumTree(tree)
    println(s"Tree sum: $treeSum")
  }
}
```

## 8.6 并发编程最佳实践

### 8.6.1 选择合适的并发模型

```scala
import scala.concurrent._
import ExecutionContext.Implicits.global

object ConcurrencyBestPractices {
  // 1. 何时使用Future
  def useFuturesForAsync(): Unit = {
    // 适用于：
    // - 单次异步操作
    // - 组合多个异步操作
    // - 需要异常处理的场景
    
    val result = Future {
      // 调用外部API
      Thread.sleep(1000)
      "API Response"
    }.map(response => {
      // 处理响应
      s"Processed: $response"
    }).recover {
      case ex => s"Error: ${ex.getMessage}"
    }
    
    result.foreach(println)
  }
  
  // 2. 何时使用Actor
  def useActorsForStatefulConcurrency(): Unit = {
    // 适用于：
    // - 需要维护状态的并发组件
    // - 处理高吞吐量消息
    // - 构建分布式系统
    
    // 示例：使用Actor管理状态（伪代码，需要Akka依赖）
    /*
    class StatefulActor extends Actor {
      private var state = 0
      
      def receive: Receive = {
        case UpdateState(newValue) => state = newValue
        case GetState => sender() ! state
      }
    }
    */
  }
  
  // 3. 何时使用并行集合
  def useParallelCollections(): Unit = {
    // 适用于：
    // - 数据并行处理
    // - 无状态的数据转换
    // - 集合操作的并行化
    
    val data = (1 to 1000000).toList
    val result = data.par
      .map(math.sqrt)  // 可以并行执行的操作
      .filter(_ > 10)   // 可以并行执行的操作
      .take(100)        // 注意：take操作有顺序依赖
    
    println(s"Parallel collection result size: ${result.size}")
  }
}
```

### 8.6.2 避免常见并发问题

```scala
import java.util.concurrent.atomic.AtomicReference
import scala.concurrent._
import ExecutionContext.Implicits.global
import scala.concurrent.stm._

object AvoidCommonConcurrencyIssues {
  // 1. 避免共享可变状态
  def avoidSharedMutableState(): Unit = {
    // 问题示例：共享可变状态导致的竞态条件
    class UnsafeCounter {
      private var count = 0
      
      def increment(): Unit = {
        // 非原子操作，存在竞态条件
        val current = count
        Thread.sleep(1)  // 增加竞态条件发生的概率
        count = current + 1
      }
      
      def get: Int = count
    }
    
    // 解决方案1：使用原子变量
    class SafeCounter {
      private val count = new AtomicReference[Int](0)
      
      def increment(): Unit = {
        val oldVal, newVal = count.get()
        while (!count.compareAndSet(oldVal, newVal + 1)) {
          oldVal, newVal = count.get()
        }
      }
      
      def get: Int = count.get()
    }
    
    // 解决方案2：使用软件事务内存（STM）
    /*
    class STMCounter {
      private val count = Ref(0)
      
      def increment(): Unit = {
        atomic { implicit txn =>
          count() = count() + 1
        }
      }
      
      def get: Int = atomic { implicit txn =>
        count()
      }
    }
    */
  }
  
  // 2. 正确处理异常
  def handleExceptions(): Unit = {
    // 在Future中使用recover处理异常
    val safeFuture = Future {
      if (math.random() > 0.5) {
        throw new RuntimeException("Random failure")
      }
      "Success"
    }.recover {
      case ex: RuntimeException => s"Recovered from ${ex.getMessage}"
      case other => s"Unknown error: ${other.getMessage}"
    }
    
    // 使用try-catch处理同步代码中的异常
    def safeOperation(): Future[String] = {
      Future {
        try {
          // 可能抛出异常的操作
          "Operation result"
        } catch {
          case ex: IllegalArgumentException => 
            s"Illegal argument: ${ex.getMessage}"
          case ex: Exception => 
            s"Unexpected error: ${ex.getMessage}"
        }
      }
    }
  }
  
  // 3. 避免死锁
  def avoidDeadlock(): Unit = {
    // 问题：不一致的锁顺序可能导致死锁
    class DeadlockExample {
      private val lock1 = new Object()
      private val lock2 = new Object()
      
      def methodA(): Unit = {
        lock1.synchronized {
          Thread.sleep(10)  // 增加死锁概率
          lock2.synchronized {
            // 临界区代码
          }
        }
      }
      
      def methodB(): Unit = {
        lock2.synchronized {  // 与methodA中的锁顺序不一致
          Thread.sleep(10)
          lock1.synchronized {
            // 临界区代码
          }
        }
      }
    }
    
    // 解决方案：保持一致的锁顺序
    class SafeLocking {
      private val lock1 = new Object()
      private val lock2 = new Object()
      
      private def doWithLocks[T](operation: => T): T = {
        lock1.synchronized {
          lock2.synchronized {
            operation
          }
        }
      }
      
      def methodA(): Unit = doWithLocks {
        // 临界区代码
      }
      
      def methodB(): Unit = doWithLocks {
        // 临界区代码
      }
    }
  }
  
  // 4. 资源管理
  def resourceManagement(): Unit = {
    // 使用Try确保资源释放
    import scala.util.Try
    
    def withResource[T <: AutoCloseable, R](resource: T)(operation: T => R): Try[R] = {
      Try {
        try {
          operation(resource)
        } finally {
          if (resource != null) resource.close()
        }
      }
    }
    
    // 使用Future管理资源
    def resourceWithFuture(): Future[String] = {
      Future {
        // 获取资源
        val connection = java.sql.DriverManager.getConnection("jdbc:example")
        
        try {
          // 使用资源
          "Query result"
        } finally {
          connection.close()
        }
      }
    }
  }
}
```

### 8.6.3 性能优化技巧

```scala
import java.util.concurrent.{Executors, ThreadPoolExecutor, TimeUnit}
import scala.concurrent._
import ExecutionContext.Implicits.global
import scala.concurrent.duration._

object PerformanceOptimization {
  // 1. 线程池优化
  def optimizeThreadPool(): Unit = {
    // 自定义线程池
    val customExecutor = new ThreadPoolExecutor(
      4,  // 核心线程数
      10, // 最大线程数
      60L, TimeUnit.SECONDS, // 空闲线程存活时间
      new java.util.concurrent.LinkedBlockingQueue[Runnable](1000) // 任务队列
    )
    
    val customContext = ExecutionContext.fromExecutor(customExecutor)
    
    // 使用自定义ExecutionContext
    val future = Future {
      Thread.sleep(1000)
      "Completed with custom thread pool"
    }(customContext)
    
    future.foreach(println)
    
    // 记得在应用程序结束时关闭线程池
    customExecutor.shutdown()
  }
  
  // 2. 批处理优化
  def batchProcessing(): Unit = {
    def processBatch[T, R](items: List[T], batchSize: Int, 
                           processor: List[T] => Future[List[R]]): Future[List[R]] = {
      if (items.isEmpty) {
        Future.successful(List.empty[R])
      } else {
        val (batch, remaining) = items.splitAt(batchSize)
        val batchResult = processor(batch)
        val remainingResult = processBatch(remaining, batchSize, processor)
        
        for {
          batchRes <- batchResult
          remainingRes <- remainingResult
        } yield batchRes ::: remainingRes
      }
    }
    
    // 使用示例
    val items = (1 to 10000).toList
    val batchSize = 100
    
    val batchProcessor = (batch: List[Int]) => Future {
      // 批处理逻辑
      batch.map(_ * 2)
    }
    
    val result = processBatch(items, batchSize, batchProcessor)
    result.map(_.size).foreach(size => println(s"Processed $size items"))
  }
  
  // 3. 并行粒度调整
  def adjustParallelGranularity(): Unit = {
    // 粗粒度并行：减少任务创建开销
    def coarseGrainedParallel(): Int = {
      val data = (1 to 10000000).toArray
      
      // 将数据分成4个大的块，每个块处理1/4的数据
      val chunkSize = data.length / 4
      val chunks = data.grouped(chunkSize).toList
      
      val results = chunks.par.map { chunk =>
        chunk.map(_ * 2).filter(_ % 3 == 0).sum
      }
      
      results.sum
    }
    
    // 细粒度并行：每个元素一个任务（开销大）
    def fineGrainedParallel(): Int = {
      val data = (1 to 10000000).toArray
      
      // 为每个元素创建一个任务
      val futures = data.map { x =>
        Future {
          val doubled = x * 2
          if (doubled % 3 == 0) doubled else 0
        }
      }
      
      // 等待所有任务完成并求和
      Future.sequence(futures).map(_.sum)
      // 注意：这会导致Future.sequence内部抛出异常，因为返回类型不匹配
      // 实际应用中应该使用更合适的并行方式
      data.map(_ * 2).filter(_ % 3 == 0).sum
    }
    
    // 性能比较
    val coarseStart = System.nanoTime()
    val coarseResult = coarseGrainedParallel()
    val coarseTime = System.nanoTime() - coarseStart
    
    val fineStart = System.nanoTime()
    val fineResult = fineGrainedParallel()
    val fineTime = System.nanoTime() - fineStart
    
    println(s"Coarse-grained time: ${coarseTime / 1000000} ms, result: $coarseResult")
    println(s"Fine-grained time: ${fineTime / 1000000} ms, result: $fineResult")
    println(s"Speedup: ${fineTime.toDouble / coarseTime}")
  }
  
  // 4. 缓存优化
  def cacheOptimization(): Unit = {
    import scala.collection.mutable
    
    // 简单的内存缓存实现
    class SimpleCache[K, V](maxSize: Int) {
      private val cache = mutable.Map[K, V]()
      private val accessOrder = mutable.ListBuffer[K]()
      
      def get(key: K): Option[V] = {
        cache.get(key).map { value =>
          // 更新访问顺序
          accessOrder -= key
          accessOrder += key
          value
        }
      }
      
      def put(key: K, value: V): Unit = {
        if (cache.contains(key)) {
          accessOrder -= key
        } else if (cache.size >= maxSize) {
          // 移除最久未访问的项
          val oldestKey = accessOrder.remove(0)
          cache.remove(oldestKey)
        }
        
        cache(key) = value
        accessOrder += key
      }
    }
    
    // 使用缓存优化重复计算
    val expensiveCache = new SimpleCache[Int, Int](1000)
    
    def expensiveCalculation(n: Int): Int = {
      expensiveCache.get(n) match {
        case Some(result) => result
        case None =>
          Thread.sleep(10)  // 模拟耗时计算
          val result = n * n  // 简单计算
          expensiveCache.put(n, result)
          result
      }
    }
    
    val numbers = (1 to 100).toList ++ (1 to 100)  // 包含重复数字
    val startTime = System.nanoTime()
    val results = numbers.map(expensiveCalculation)
    val time = System.nanoTime() - startTime
    
    println(s"Cache optimization took ${time / 1000000} ms")
    println(s"Results size: ${results.size}")
  }
}
```

## 总结

Scala提供了丰富的并发和并行编程工具，从基础的线程同步到高级的Actor模型。选择合适的并发模型对于构建高性能、可扩展的应用程序至关重要：

1. **对于简单的异步操作**：使用Future和Promise
2. **对于复杂的状态管理**：考虑使用Actor模型（Akka）
3. **对于数据并行处理**：使用并行集合
4. **对于高性能并发**：考虑使用更底层的并发原语

无论选择哪种模型，都要注意避免共享可变状态、正确处理异常、合理管理资源，并根据实际场景调整并发粒度。

下一章将探讨Scala与Java的互操作性，以及如何利用Java生态系统中的丰富资源。