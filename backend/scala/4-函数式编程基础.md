# 第4章 函数式编程基础

## 目录
- [4.1 函数式编程概述](#41-函数式编程概述)
- [4.2 高阶函数](#42-高阶函数)
- [4.3 纯函数与副作用](#43-纯函数与副作用)
- [4.4 函数组合](#44-函数组合)
- [4.5 柯里化与部分应用](#45-柯里化与部分应用)
- [4.6 闭包](#46-闭包)
- [4.7 递归与尾递归](#47-递归与尾递归)
- [4.8 偏函数](#48-偏函数)
- [4.9 函数式数据结构](#49-函数式数据结构)
- [4.10 函数式设计模式](#410-函数式设计模式)

## 4.1 函数式编程概述

### 什么是函数式编程

函数式编程（Functional Programming, FP）是一种编程范式，它将计算视为数学函数的求值，避免使用可变数据和状态变化。在函数式编程中，函数是一等公民，可以作为参数传递、作为返回值返回，以及存储在数据结构中。

### 函数式编程的核心原则

1. **纯函数**：对于相同的输入，总是返回相同的输出，没有可观察的副作用
2. **不可变性**：数据创建后不可修改，而是创建新的数据
3. **函数组合**：通过组合简单函数构建复杂函数
4. **避免副作用**：副作用（如修改全局状态、I/O操作）被隔离和控制

### Scala中的函数式编程特性

```scala
// 函数作为值
val add: (Int, Int) => Int = (a, b) => a + b
val multiply: (Int, Int) => Int = _ * _

// 函数作为参数
def operate(a: Int, b: Int, operation: (Int, Int) => Int): Int = operation(a, b)
val result = operate(5, 3, add)  // 8

// 函数作为返回值
def createMultiplier(factor: Int): Int => Int = x => x * factor
val double = createMultiplier(2)
val result2 = double(5)  // 10
```

## 4.2 高阶函数

### 什么是高阶函数

高阶函数是接受一个或多个函数作为参数，或返回一个函数的函数。Scala标准库中提供了许多高阶函数。

### 常用的高阶函数

#### map函数

```scala
// 对集合中的每个元素应用函数，返回新集合
val numbers = List(1, 2, 3, 4, 5)
val doubled = numbers.map(x => x * 2)  // List(2, 4, 6, 8, 10)
val strings = numbers.map(x => s"Number: $x")  // List("Number: 1", ..., "Number: 5")

// 更简洁的写法
val doubled2 = numbers.map(_ * 2)  // 使用下划线占位符

val people = List(("Alice", 30), ("Bob", 25), ("Charlie", 35))
val names = people.map(_._1)  // List("Alice", "Bob", "Charlie")
val ages = people.map { case (name, age) => age }  // List(30, 25, 35)
```

#### filter函数

```scala
// 过滤集合中满足条件的元素
val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
val evenNumbers = numbers.filter(_ % 2 == 0)  // List(2, 4, 6, 8, 10)

val words = List("apple", "banana", "cherry", "date")
val longWords = words.filter(_.length > 5)  // List("banana", "cherry")

// 结合map和filter
val longWordsUpper = words
  .filter(_.length > 5)
  .map(_.toUpperCase)  // List("BANANA", "CHERRY")
```

#### reduce和fold函数

```scala
// reduce: 使用二元函数从左到右（或从右到左）归约集合
val numbers = List(1, 2, 3, 4, 5)
val sum = numbers.reduce(_ + _)  // 15 (1+2+3+4+5)
val product = numbers.reduce(_ * _)  // 120 (1*2*3*4*5)

val strings = List("a", "b", "c", "d")
val concatenated = strings.reduce(_ + _)  // "abcd"

// fold: 类似于reduce，但提供初始值
val sumWithInitial = numbers.fold(0)(_ + _)  // 15 (0+1+2+3+4+5)
val productWithInitial = numbers.fold(1)(_ * _)  // 120 (1*1*2*3*4*5)

val foldString = strings.fold("Start")(_ + _ + "End")  // "StartaEndbEndcEnddEnd"

// foldLeft: 显式地从左到右折叠
val sumLeft = numbers.foldLeft(0)(_ + _)  // 15

// foldRight: 显式地从右到左折叠
val sumRight = numbers.foldRight(0)(_ + _)  // 15
```

#### foreach函数

```scala
// 对每个元素执行操作，不返回结果（用于副作用）
val numbers = List(1, 2, 3, 4, 5)

// 打印每个数字
numbers.foreach(println)

// 对每个元素执行多个操作
numbers.foreach { num =>
  val square = num * num
  println(s"$num squared is $square")
}
```

#### flatMap函数

```scala
// 对每个元素应用返回集合的函数，然后将所有集合展平
val sentences = List("Hello world", "Scala is fun", "Functional programming")
val words = sentences.flatMap(_.split(" "))  // List("Hello", "world", "Scala", "is", "fun", "Functional", "programming")

val numbers = List(1, 2, 3)
val numberPairs = numbers.flatMap(x => List(x, x * 10))  // List(1, 10, 2, 20, 3, 30)

// 嵌套集合的展平
val nestedLists = List(List(1, 2), List(3, 4), List(5, 6))
val flattened = nestedLists.flatMap(identity)  // List(1, 2, 3, 4, 5, 6)
val flattened2 = nestedLists.flatten  // 更简洁的写法
```

#### collect函数

```scala
// 类似于map+filter，但使用偏函数
val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

// 只处理偶数，并计算其平方
val evenSquares = numbers.collect {
  case x if x % 2 == 0 => x * x
}  // List(4, 16, 36, 64, 100)

// 类型提取和处理
val mixed = List(1, "hello", 3.14, "world", 42)
val strings = mixed.collect { case s: String => s }  // List("hello", "world")
val numbers = mixed.collect { case i: Int => i }  // List(1, 42)
```

### 自定义高阶函数

```scala
// 自定义高阶函数
def processList[A, B](list: List[A])(f: A => B): List[B] = {
  list.map(f)
}

val numbers = List(1, 2, 3, 4, 5)
val strings = processList(numbers)(x => s"Number: $x")  // List("Number: 1", ..., "Number: 5")

// 条件处理高阶函数
def conditionalProcess[A](list: List[A])(predicate: A => Boolean)(processor: A => A): List[A] = {
  list.map { item =>
    if (predicate(item)) processor(item) else item
  }
}

val processedNumbers = conditionalProcess(numbers)(_ % 2 == 0)(_ * 100)  // List(1, 200, 3, 400, 5)

// 组合多个高阶函数
def compose[A, B, C](f: B => C, g: A => B): A => C = a => f(g(a))

val add5: Int => Int = _ + 5
val multiplyBy2: Int => Int = _ * 2
val add5ThenMultiply = compose(multiplyBy2, add5)  // 先加5再乘以2
val result = add5ThenMultiply(3)  // 16 ((3+5)*2)
```

## 4.3 纯函数与副作用

### 纯函数的定义

纯函数是函数式编程的核心概念，满足以下两个条件：

1. 对于相同的输入，总是返回相同的输出
2. 没有可观察的副作用（如修改全局状态、I/O操作、异常等）

### 纯函数示例

```scala
// 纯函数
def add(a: Int, b: Int): Int = a + b
def length(s: String): Int = s.length
def max(a: Int, b: Int): Int = if (a > b) a else b

// 纯函数的特点
val result1 = add(2, 3)  // 5
val result2 = add(2, 3)  // 总是5，对于相同的输入总是相同的输出
```

### 非纯函数示例

```scala
// 非纯函数：有副作用
var counter = 0

def increment(): Int = {
  counter += 1  // 修改外部状态
  counter
}

val result1 = increment()  // 1
val result2 = increment()  // 2，相同的输入（无参数）返回不同的输出

// 非纯函数：依赖外部状态
def getCurrentTime(): Long = System.currentTimeMillis()  // 每次调用返回不同值

// 非纯函数：I/O操作
def printMessage(msg: String): Unit = println(msg)  // 副作用：控制台输出

// 非纯函数：可能抛出异常
def divide(a: Int, b: Int): Int = a / b  // 可能抛出ArithmeticException
```

### 处理副作用

在函数式编程中，我们不消除副作用，而是将它们隔离和控制。

```scala
// 使用Option替代可能返回null的函数
def safeDivide(a: Int, b: Int): Option[Int] = {
  if (b != 0) Some(a / b)
  else None
}

val result1 = safeDivide(10, 2)  // Some(5)
val result2 = safeDivide(10, 0)  // None

// 使用Either处理可能失败的计算
def divideEither(a: Int, b: Int): Either[String, Int] = {
  if (b != 0) Right(a / b)
  else Left("Division by zero")
}

val result3 = divideEither(10, 2)  // Right(5)
val result4 = divideEither(10, 0)  // Left("Division by zero")

// 使用函数式IO抽象
trait IO[A] {
  def unsafeRun(): A
  
  def map[B](f: A => B): IO[B] = new IO[B] {
    def unsafeRun(): B = f(unsafeRun())
  }
  
  def flatMap[B](f: A => IO[B]): IO[B] = new IO[B] {
    def unsafeRun(): B = f(unsafeRun()).unsafeRun()
  }
}

object IO {
  def apply[A](a: => A): IO[A] = new IO[A] {
    def unsafeRun(): A = a
  }
}

// 使用IO抽象控制副作用
def readLine(): IO[String] = IO(scala.io.StdIn.readLine())
def printLine(s: String): IO[Unit] = IO(println(s))

val program: IO[Unit] = for {
  name <- readLine()
  _ <- printLine(s"Hello, $name!")
} yield ()

// 副作用被延迟到unsafeRun()时执行
// program.unsafeRun()
```

## 4.4 函数组合

### 什么是函数组合

函数组合是将多个简单函数组合成复杂函数的过程，是函数式编程的核心概念之一。

### 基本函数组合

```scala
// 简单的函数组合
def add5: Int => Int = _ + 5
def multiplyBy2: Int => Int = _ * 2
def toString: Int => String = _.toString

// 手动组合
def add5ThenMultiply(x: Int): Int = multiplyBy2(add5(x))
def add5ThenMultiplyThenString(x: Int): String = toString(multiplyBy2(add5(x)))

val result1 = add5ThenMultiply(3)  // 16
val result2 = add5ThenMultiplyThenString(3)  // "16"
```

### 函数组合器

```scala
// 定义函数组合器
def compose[A, B, C](f: B => C, g: A => B): A => C = a => f(g(a))

// 使用compose组合函数
val composed1: Int => Int = compose(multiplyBy2, add5)  // 先加5再乘以2
val composed2: String = compose(toString, composed1)  // 先执行composed1再转字符串

val result3 = composed1(3)  // 16
val result4 = composed2(3)  // "16"

// andThen组合器（与compose相反，先执行左边的函数）
def andThen[A, B, C](f: A => B, g: B => C): A => C = a => g(f(a))

val composed3: Int => String = andThen(add5, andThen(multiplyBy2, toString))
val result5 = composed3(3)  // "16"
```

### Scala内置的函数组合

```scala
// Scala函数有内置的compose和andThen方法
val add5: Int => Int = _ + 5
val multiplyBy2: Int => Int = _ * 2
val toString: Int => String = _.toString

// 使用compose方法
val composed1: Int => Int = multiplyBy2.compose(add5)  // 先执行add5再执行multiplyBy2

// 使用andThen方法
val composed2: Int => String = add5.andThen(multiplyBy2).andThen(toString)

val result1 = composed1(3)  // 16
val result2 = composed2(3)  // "16"
```

### 复杂函数组合

```scala
// 定义更多函数
def isEven: Int => Boolean = _ % 2 == 0
def square: Int => Int = x => x * x
def toWords: Int => String = {
  case 1 => "one"
  case 2 => "two"
  case 3 => "three"
  case 4 => "four"
  case 5 => "five"
  case 6 => "six"
  case 7 => "seven"
  case 8 => "eight"
  case 9 => "nine"
  case 10 => "ten"
  case _ => "many"
}

// 组合函数处理数据
val processNumber: Int => String = square
  .andThen(multiplyBy2)
  .andThen(toWords)

val result = processNumber(3)  // "eighteen" ((3*3)*2=18, 但toWords没有18，所以会返回"many")

// 条件函数组合
def conditionalCompose[A](condition: A => Boolean, ifTrue: A => A, ifFalse: A => A): A => A = {
  a => if (condition(a)) ifTrue(a) else ifFalse(a)
}

val processEvenNumbers: Int => Int = conditionalCompose(
  isEven,    // 条件
  square,    // 条件为真时执行的函数
  add5       // 条件为假时执行的函数
)

val result2 = processEvenNumbers(2)  // 4 (2是偶数，执行square)
val result3 = processEvenNumbers(3)  // 8 (3是奇数，执行add5)

// 多函数列表的组合
def composeAll[A](functions: List[A => A]): A => A = {
  functions.reduce(_ andThen _)
}

val transformations: List[Int => Int] = List(add5, multiplyBy2, square)
val composedAll: Int => Int = composeAll(transformations)

val result4 = composedAll(3)  // 256 ((3+5)*2)^2
```

## 4.5 柯里化与部分应用

### 柯里化（Currying）

柯里化是将接受多个参数的函数转换为一系列接受单个参数的函数的过程。

```scala
// 非柯里化函数
def add(a: Int, b: Int): Int = a + b

// 柯里化函数
def curriedAdd(a: Int)(b: Int): Int = a + b

// 调用方式
val result1 = add(5, 3)  // 8
val result2 = curriedAdd(5)(3)  // 8

// 手动柯里化
def curry[A, B, C](f: (A, B) => C): A => B => C = {
  a => b => f(a, b)
}

// 反柯里化
def uncurry[A, B, C](f: A => B => C): (A, B) => C = {
  (a, b) => f(a)(b)
}

val curriedAdd2: Int => Int => Int = curry(add)
val result3 = curriedAdd2(5)(3)  // 8

val uncurriedAdd: (Int, Int) => Int = uncurry(curriedAdd)
val result4 = uncurriedAdd(5, 3)  // 8
```

### 部分应用（Partial Application）

部分应用是指固定函数的部分参数，返回一个新函数的过程。

```scala
// 部分应用柯里化函数
def curriedAdd(a: Int)(b: Int): Int = a + b

val add5: Int => Int = curriedAdd(5)  // 固定第一个参数为5
val result1 = add5(3)  // 8

// 部分应用非柯里化函数
def multiply(a: Int, b: Int): Int = a * b

val double: Int => Int = multiply(2, _: Int)  // 固定第一个参数为2
val triple: Int => Int = multiply(_: Int, 3)  // 固定第二个参数为3

val result2 = double(5)  // 10
val result3 = triple(5)  // 15

// 实际应用
def formatCurrency(symbol: String, amount: Double): String = 
  f"$symbol$amount%.2f"

val formatUSD: Double => String = formatCurrency("$", _: Double)
val formatEUR: Double => String = formatCurrency("€", _: Double)

val price1 = formatUSD(19.99)  // "$19.99"
val price2 = formatEUR(19.99)  // "€19.99"
```

### 柯里化的实际应用

```scala
// 数据库查询构建器
case class Query(table: String, filters: List[String], limit: Option[Int])

def fromTable(table: String)(filters: List[String] = List.empty)(limit: Option[Int] = None): Query = {
  Query(table, filters, limit)
}

// 使用柯里化构建查询
val usersQuery = fromTable("users") _
val activeUsers = usersQuery(List("active = true"))
val recentActiveUsers = activeUsers(Some(100))

// JSON构建器
case class JsonObject(fields: Map[String, JsonValue])
sealed trait JsonValue
case class JsonString(value: String) extends JsonValue
case class JsonNumber(value: Double) extends JsonValue
case class JsonObjectValue(value: JsonObject) extends JsonValue
case class JsonArray(values: List[JsonValue]) extends JsonValue

def jsonBuilder(): JsonObject = JsonObject(Map.empty)

def addStringField(obj: JsonObject)(key: String)(value: String): JsonObject = {
  obj.copy(fields = obj.fields + (key -> JsonString(value)))
}

def addNumberField(obj: JsonObject)(key: String)(value: Double): JsonObject = {
  obj.copy(fields = obj.fields + (key -> JsonNumber(value)))
}

// 构建JSON对象
val personJson = jsonBuilder()
  .pipe(addStringField("name")("John Doe"))
  .pipe(addStringField("email")("john@example.com"))
  .pipe(addNumberField("age")(30.0))

// 需要定义pipe函数来链式调用
def pipe[A, B](value: A)(func: A => B): B = func(value)
```

### 高阶柯里化与函数组合

```scala
// 多参数柯里化
def process[A, B, C, D](a: A)(b: B)(c: C)(d: D): String = 
  s"Processed: $a, $b, $c, $d"

val partiallyApplied = process(1)(2) _
val morePartial = partiallyApplied("three")
val result = morePartial(4.0)

// 柯里化与函数组合
def mapFilter[A, B](list: List[A])(mapFunc: A => B)(filterFunc: B => Boolean): List[B] = {
  list.map(mapFunc).filter(filterFunc)
}

// 创建特定用途的函数
val numbers = List(1, 2, 3, 4, 5, 6)
val processNumbers: Int => Boolean => List[Int] = mapFilter(numbers)
val squareAndFilterEven = processNumbers(x => x * x)
val evenSquares = squareAndFilterEven(_ % 2 == 0)

// 柯里化与部分应用在DSL中的应用
case class HttpRequest(
  method: String,
  url: String,
  headers: Map[String, String] = Map.empty,
  params: Map[String, String] = Map.empty,
  body: Option[String] = None
)

def request(method: String)(url: String): HttpRequest = 
  HttpRequest(method, url)

def withHeader(req: HttpRequest)(key: String)(value: String): HttpRequest = 
  req.copy(headers = req.headers + (key -> value))

def withParam(req: HttpRequest)(key: String)(value: String): HttpRequest = 
  req.copy(params = req.params + (key -> value))

// 构建HTTP请求
val baseRequest = request("GET")("https://api.example.com/users")
val requestWithAuth = withHeader(withHeader(baseRequest)("Authorization")("Bearer token123"))("Content-Type")("application/json")
val finalRequest = withParam(requestWithAuth)("page")("1")
```

## 4.6 闭包

### 什么是闭包

闭包是一个函数，它引用了其外部作用域中的变量。当函数被创建时，这些变量被"捕获"并随函数一起存在，即使外部作用域已经结束。

### 闭包的基本示例

```scala
// 基本闭包示例
def makeMultiplier(factor: Int): Int => Int = {
  // factor是从外部作用域捕获的变量，形成闭包
  (x: Int) => x * factor
}

val double = makeMultiplier(2)
val triple = makeMultiplier(3)

val result1 = double(5)  // 10
val result2 = triple(5)  // 15

// 闭包捕获多个变量
def makeAdder(initialValue: Int): (String, Int) => String = {
  // 捕获initialValue
  (message: String, increment: Int) => {
    val newValue = initialValue + increment
    s"$message: $newValue"
  }
}

val adder = makeAdder(10)
val result3 = adder("New value", 5)  // "New value: 15"
```

### 闭包与可变状态

```scala
// 闭包与可变变量
def makeCounter(): () => Int = {
  var count = 0  // count被闭包捕获
  
  () => {
    count += 1
    count
  }
}

val counter1 = makeCounter()
val counter2 = makeCounter()

println(counter1())  // 1
println(counter1())  // 2
println(counter2())  // 1 (独立的闭包，有自己的count)
println(counter1())  // 3

// 闭包与集合操作
def createFilter(minValue: Int): List[Int] => List[Int] = {
  // 捕获minValue
  (list: List[Int]) => list.filter(_ > minValue)
}

val filterGreaterThan5 = createFilter(5)
val result4 = filterGreaterThan5(List(1, 3, 5, 7, 9))  // List(7, 9)

val filterGreaterThan10 = createFilter(10)
val result5 = filterGreaterThan10(List(5, 10, 15, 20))  // List(15, 20)
```

### 闭包的实际应用

```scala
// 事件处理器
def createClickHandler(buttonName: String): () => Unit = {
  () => println(s"Button '$buttonName' clicked")
}

val saveButtonHandler = createClickHandler("Save")
val cancelButtonHandler = createClickHandler("Cancel")

// 模拟按钮点击
saveButtonHandler()      // "Button 'Save' clicked"
cancelButtonHandler()    // "Button 'Cancel' clicked"

// 配置驱动的行为
def createProcessor(config: Map[String, String]): String => String = {
  val prefix = config.getOrElse("prefix", "")
  val suffix = config.getOrElse("suffix", "")
  val upperCase = config.get("uppercase").contains("true")
  
  (input: String) => {
    val result = prefix + input + suffix
    if (upperCase) result.toUpperCase else result
  }
}

val jsonProcessor = createProcessor(Map(
  "prefix" -> "{\"message\": \"",
  "suffix" -> "\"}",
  "uppercase" -> "false"
))

val xmlProcessor = createProcessor(Map(
  "prefix" -> "<message>",
  "suffix" -> "</message>",
  "uppercase" -> "true"
))

val result6 = jsonProcessor("Hello")  // "{\"message\": \"Hello\"}"
val result7 = xmlProcessor("Hello")   // "<MESSAGE>HELLO</MESSAGE>"

// 缓存函数结果（记忆化）
def memoize[A, B](f: A => B): A => B = {
  val cache = scala.collection.mutable.Map[A, B]()
  
  (a: A) => {
    if (cache.contains(a)) {
      cache(a)
    } else {
      val result = f(a)
      cache(a) = result
      result
    }
  }
}

def expensiveComputation(n: Int): Int = {
  println(s"Computing for $n")
  (1 to n).sum
}

val memoizedComputation = memoize(expensiveComputation)

println(memoizedComputation(5))  // 计算并打印
println(memoizedComputation(5))  // 从缓存获取，不打印
println(memoizedComputation(3))  // 计算并打印
```

### 闭包与对象

```scala
// 使用对象模拟闭包
class Counter {
  private var count = 0
  
  def increment(): Int = {
    count += 1
    count
  }
  
  def current(): Int = count
}

val counterObj = new Counter()
println(counterObj.increment())  // 1
println(counterObj.increment())  // 2

// 使用闭包替代简单对象
def createCounter(): () => (Int, () => Unit) = {
  var count = 0
  
  def increment(): Unit = {
    count += 1
  }
  
  def current(): Int = count
  
  () => (current(), increment)
}

val (getCurrent, increment) = createCounter()
println(getCurrent())  // 0
increment()
println(getCurrent())  // 1
increment()
println(getCurrent())  // 2

// 闭包与类方法的比较
class Person(val name: String) {
  private var friends = List.empty[String]
  
  def addFriend(friend: String): Unit = {
    friends = friend :: friends
  }
  
  def listFriends(): List[String] = friends
  
  def createGreeter(): () => String = {
    () => s"Hello, my name is $name and I have ${friends.size} friends"
  }
}

val john = new Person("John")
john.addFriend("Alice")
john.addFriend("Bob")

val greetJohn = john.createGreeter()
println(greetJohn())  // "Hello, my name is John and I have 2 friends"
```

## 4.7 递归与尾递归

### 基本递归

递归是指函数调用自身的编程技术。在函数式编程中，递归常用于替代循环结构。

```scala
// 阶乘的递归实现
def factorial(n: Int): Int = {
  if (n <= 1) 1
  else n * factorial(n - 1)
}

val result1 = factorial(5)  // 120

// 斐波那契数列的递归实现
def fibonacci(n: Int): Int = {
  if (n <= 1) n
  else fibonacci(n - 1) + fibonacci(n - 2)
}

val result2 = fibonacci(6)  // 8

// 求最大公约数（欧几里得算法）
def gcd(a: Int, b: Int): Int = {
  if (b == 0) a
  else gcd(b, a % b)
}

val result3 = gcd(48, 18)  // 6

// 列表求和
def sumList(lst: List[Int]): Int = {
  lst match {
    case Nil => 0
    case head :: tail => head + sumList(tail)
  }
}

val result4 = sumList(List(1, 2, 3, 4, 5))  // 15
```

### 尾递归

尾递归是一种特殊的递归形式，其中递归调用是函数的最后一个操作。编译器可以优化尾递归，将其转换为迭代，避免栈溢出。

```scala
// 阶乘的尾递归实现
def factorialTail(n: Int): Int = {
  @annotation.tailrec  // 确保编译器验证这是尾递归
  def loop(n: Int, accumulator: Int): Int = {
    if (n <= 1) accumulator
    else loop(n - 1, n * accumulator)
  }
  
  loop(n, 1)
}

val result5 = factorialTail(5)  // 120

// 斐波那契数列的尾递归实现
def fibonacciTail(n: Int): Int = {
  @annotation.tailrec
  def loop(n: Int, a: Int, b: Int): Int = {
    if (n == 0) a
    else if (n == 1) b
    else loop(n - 1, b, a + b)
  }
  
  loop(n, 0, 1)
}

val result6 = fibonacciTail(6)  // 8

// 列表反转的尾递归实现
def reverseList[T](lst: List[T]): List[T] = {
  @annotation.tailrec
  def loop(remaining: List[T], accumulator: List[T]): List[T] = {
    remaining match {
      case Nil => accumulator
      case head :: tail => loop(tail, head :: accumulator)
    }
  }
  
  loop(lst, Nil)
}

val result7 = reverseList(List(1, 2, 3, 4, 5))  // List(5, 4, 3, 2, 1)

// 列表映射的尾递归实现
def mapList[T, U](lst: List[T])(f: T => U): List[U] = {
  @annotation.tailrec
  def loop(remaining: List[T], accumulator: List[U]): List[U] = {
    remaining match {
      case Nil => accumulator.reverse
      case head :: tail => loop(tail, f(head) :: accumulator)
    }
  }
  
  loop(lst, Nil)
}

val result8 = mapList(List(1, 2, 3, 4, 5))(_ * 2)  // List(2, 4, 6, 8, 10)
```

### 递归与尾递归的比较

```scala
// 比较普通递归和尾递归的性能和栈使用情况

// 普通递归：可能导致栈溢出
def sumRecursive(n: Int): Int = {
  if (n <= 0) 0
  else n + sumRecursive(n - 1)
}

// 尾递归：不会栈溢出
def sumTailRecursive(n: Int): Int = {
  @annotation.tailrec
  def loop(current: Int, accumulator: Int): Int = {
    if (current <= 0) accumulator
    else loop(current - 1, current + accumulator)
  }
  
  loop(n, 0)
}

// 测试大数字
val smallNumber = 1000
val largeNumber = 100000

println(sumRecursive(smallNumber))  // 正常工作
// println(sumRecursive(largeNumber))  // 可能导致栈溢出

println(sumTailRecursive(smallNumber))  // 正常工作
println(sumTailRecursive(largeNumber))  // 正常工作，不会栈溢出

// 计算斐波那契数列的性能比较

// 普通递归：指数级时间复杂度，非常慢
def fibonacciRecursive(n: Int): BigInt = {
  if (n <= 1) n
  else fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2)
}

// 尾递归：线性时间复杂度，快得多
def fibonacciTailRecursive(n: Int): BigInt = {
  @annotation.tailrec
  def loop(n: Int, a: BigInt, b: BigInt): BigInt = {
    if (n == 0) a
    else if (n == 1) b
    else loop(n - 1, b, a + b)
  }
  
  loop(n, 0, 1)
}

// 比较运行时间
val start1 = System.currentTimeMillis()
val fib1 = fibonacciRecursive(30)  // 对于n=30已经比较慢
val time1 = System.currentTimeMillis() - start1

val start2 = System.currentTimeMillis()
val fib2 = fibonacciTailRecursive(30)
val time2 = System.currentTimeMillis() - start2

println(s"fib($n) = $fib1, time: $time1 ms")
println(s"fibTail($n) = $fib2, time: $time2 ms")

// 对于更大的n，差异更明显
val start3 = System.currentTimeMillis()
val fib3 = fibonacciTailRecursive(100)  // 可以处理大得多的n
val time3 = System.currentTimeMillis() - start3

println(s"fibTail(100) = $fib3, time: $time3 ms")
// fibonacciRecursive(100) 会非常慢，几乎无法计算
```

### 递归的实际应用

```scala
// 文件系统遍历
import java.io.File

def listFiles(dir: File): List[File] = {
  def loop(file: File, accumulator: List[File]): List[File] = {
    if (file.isFile) file :: accumulator
    else {
      val files = file.listFiles().toList
      files.foldLeft(accumulator) { (acc, f) => loop(f, acc) }
    }
  }
  
  loop(dir, Nil)
}

// 递归实现快速排序
def quickSort(lst: List[Int]): List[Int] = {
  lst match {
    case Nil | _ :: Nil => lst  // 空列表或单元素列表已排序
    case pivot :: tail =>
      val (less, equal, greater) = partition(tail, pivot)
      quickSort(less) ++ (pivot :: equal) ++ quickSort(greater)
  }
}

def partition(lst: List[Int], pivot: Int): (List[Int], List[Int], List[Int]) = {
  lst.foldLeft((List.empty[Int], List(pivot), List.empty[Int])) {
    case ((less, equal, greater), element) =>
      if (element < pivot) (element :: less, equal, greater)
      else if (element == pivot) (less, element :: equal, greater)
      else (less, equal, element :: greater)
  }
}

val unsortedList = List(5, 3, 8, 1, 9, 2, 7, 4, 6)
val sortedList = quickSort(unsortedList)
println(s"Unsorted: $unsortedList")
println(s"Sorted: $sortedList")

// 二叉树遍历
sealed trait BinaryTree[+A]
case class Empty[A]() extends BinaryTree[A]
case class Node[A](value: A, left: BinaryTree[A], right: BinaryTree[A]) extends BinaryTree[A]

def inOrder[A](tree: BinaryTree[A]): List[A] = {
  tree match {
    case Empty() => Nil
    case Node(value, left, right) => 
      inOrder(left) ++ List(value) ++ inOrder(right)
  }
}

def preOrder[A](tree: BinaryTree[A]): List[A] = {
  tree match {
    case Empty() => Nil
    case Node(value, left, right) => 
      List(value) ++ preOrder(left) ++ preOrder(right)
  }
}

def postOrder[A](tree: BinaryTree[A]): List[A] = {
  tree match {
    case Empty() => Nil
    case Node(value, left, right) => 
      postOrder(left) ++ postOrder(right) ++ List(value)
  }
}

// 构建示例树
val tree = Node(
  5,
  Node(3, Node(1, Empty(), Empty()), Node(4, Empty(), Empty())),
  Node(8, Node(6, Empty(), Empty()), Node(9, Empty(), Empty()))
)

println(s"In-order traversal: ${inOrder(tree)}")
println(s"Pre-order traversal: ${preOrder(tree)}")
println(s"Post-order traversal: ${postOrder(tree)}")
```

## 4.8 偏函数

### 什么是偏函数

偏函数（PartialFunction）是只对输入域的子集定义的函数。它不仅知道如何处理某些输入，还知道它能处理哪些输入。

### 基本偏函数

```scala
// 定义一个偏函数，只处理正整数
val squareRoot: PartialFunction[Int, Double] = {
  case x if x >= 0 => Math.sqrt(x)
}

// 检查偏函数是否定义于特定输入
println(squareRoot.isDefinedAt(9))   // true
println(squareRoot.isDefinedAt(-9))  // false

// 安全调用偏函数
if (squareRoot.isDefinedAt(9)) {
  println(squareRoot(9))  // 3.0
}

// 使用applyOrElse方法：如果定义则应用，否则应用默认函数
val result = squareRoot.applyOrElse(-1, (x: Int) => Double.NaN)
println(result)  // NaN

// 使用lift方法将偏函数转换为普通函数（返回Option）
val lifted = squareRoot.lift
println(lifted(9))    // Some(3.0)
println(lifted(-9))   // None

// 使用orElse组合偏函数
val reciprocal: PartialFunction[Double, Double] = {
  case x if x != 0 => 1.0 / x
}

val combined = squareRoot.orElse(reciprocal)
println(combined(4))   // 2.0 (squareRoot)
println(combined(-4))  // -0.25 (reciprocal，因为squareRoot未定义)
```

### 偏函数的创建方法

```scala
// 方法1：使用case语句创建偏函数
val isEven: PartialFunction[Int, String] = {
  case x if x % 2 == 0 => s"$x is even"
}

// 方法2：从字面量集合创建偏函数
val dayOfWeek: PartialFunction[Int, String] = List(
  1 -> "Monday",
  2 -> "Tuesday",
  3 -> "Wednesday",
  4 -> "Thursday",
  5 -> "Friday",
  6 -> "Saturday",
  7 -> "Sunday"
).toMap

// 方法3：使用collect和模式匹配
val process: PartialFunction[Any, String] = {
  case i: Int if i > 0 => s"Positive integer: $i"
  case s: String => s"String: $s"
  case d: Double if d.isNaN => "Not a Number"
}

// 方法4：使用条件逻辑创建偏函数
def createDivisor(divisor: Int): PartialFunction[Int, Int] = {
  case x if x % divisor == 0 => x / divisor
}
```

### 偏函数在集合操作中的应用

```scala
// 使用collect与偏函数处理集合
val mixed = List(1, "hello", 3.14, "world", 42, true)

// 只提取字符串并转大写
val stringsUpper = mixed.collect {
  case s: String => s.toUpperCase
}
println(stringsUpper)  // List("HELLO", "WORLD")

// 使用偏函数进行条件转换
val numbers = List(-5, -3, 0, 2, 4, 7, 10)

// 只处理正数，计算平方根
val positiveRoots = numbers.collect {
  case x if x > 0 => Math.sqrt(x)
}
println(positiveRoots)  // List(1.414..., 2.0, 2.645..., 3.162...)

// 组合多个转换
val processNumbers = numbers.collect {
  case x if x < 0 => s"Negative: $x"
  case x if x == 0 => "Zero"
  case x if x > 0 && x % 2 == 0 => s"Positive even: $x"
  case x if x > 0 && x % 2 != 0 => s"Positive odd: $x"
}
println(processNumbers)

// 使用偏函数定义专用处理器
val textProcessor: PartialFunction[String, String] = {
  case s if s.startsWith("http") => s"URL: $s"
  case s if s.contains("@") => s"Email: $s"
  case s if s.matches("\\d{3}-\\d{2}-\\d{4}") => s"SSN: $s"
  case s if s.matches("\\d+") => s"Number: $s"
}

val texts = List("hello@example.com", "http://example.com", "123-45-6789", "12345", "just text")
val processed = texts.collect(textProcessor)
println(processed)
```

### 偏函数的高级应用

```scala
// 状态机实现
sealed trait State
case object Start extends State
case object Processing extends State
case object Finished extends State

case class Event(name: String)

// 定义状态转换
val stateTransition: PartialFunction[(State, Event), State] = {
  case (Start, Event("begin")) => Processing
  case (Processing, Event("finish")) => Finished
}

// 使用偏函数实现状态转换逻辑
def transition(current: State, event: Event): State = {
  stateTransition.applyOrElse((current, event), (_: (State, Event)) => current)
}

val state1 = transition(Start, Event("begin"))  // Processing
val state2 = transition(Processing, Event("finish"))  // Finished
val state3 = transition(Finished, Event("begin"))  // Finished (无转换)

// API路由处理
case class Request(path: String, method: String)
case class Response(status: Int, body: String)

val apiHandler: PartialFunction[Request, Response] = {
  case Request("/users", "GET") => Response(200, "List of users")
  case Request("/users", "POST") => Response(201, "User created")
  case Request(Request("/users", method), _) => Response(405, s"Method $method not allowed")
  case Request(path, _) => Response(404, s"Path $path not found")
}

// 使用偏函数链处理请求
val handleRequest = apiHandler.composeOption[Request](Some(_)).map {
  case Some(response) => response
  case None => Response(500, "Internal Server Error")
}

val response1 = handleRequest(Request("/users", "GET"))
val response2 = handleRequest(Request("/unknown", "GET"))

// 配置管理
case class ConfigItem(key: String, value: Any)

val configParser: PartialFunction[ConfigItem, String] = {
  case ConfigItem("timeout", v: Int) => s"Timeout: ${v}ms"
  case ConfigItem("debug", v: Boolean) => s"Debug mode: ${if (v) "enabled" else "disabled"}"
  case ConfigItem("servers", v: List[String]) => s"Servers: ${v.mkString(", ")}"
}

val configItems = List(
  ConfigItem("timeout", 5000),
  ConfigItem("debug", true),
  ConfigItem("servers", List("server1", "server2")),
  ConfigItem("unknown", "value")
)

val parsedConfigs = configItems.collect(configParser)
println(parsedConfigs)
```

## 4.9 函数式数据结构

### 不可变集合

函数式编程强调使用不可变数据结构，这有助于写出更安全、更易于推理的代码。

```scala
// Scala不可变集合
val list1 = List(1, 2, 3)  // 不可变列表

// 添加元素（创建新列表）
val list2 = 0 :: list1  // List(0, 1, 2, 3)
val list3 = list1 :+ 4   // List(1, 2, 3, 4)

// 注意：原列表保持不变
println(list1)  // List(1, 2, 3)
println(list2)  // List(0, 1, 2, 3)
println(list3)  // List(1, 2, 3, 4)

// 不可变映射
val map1 = Map("one" -> 1, "two" -> 2)

// 添加或更新键值对（创建新映射）
val map2 = map1 + ("three" -> 3)        // Map("one" -> 1, "two" -> 2, "three" -> 3)
val map3 = map1 + ("two" -> 22)          // Map("one" -> 1, "two" -> 22) 更新值

// 移除键（创建新映射）
val map4 = map1 - "one"                  // Map("two" -> 2)

// 原映射保持不变
println(map1)  // Map("one" -> 1, "two" -> 2)

// 不可变集合的性能考虑
// 对于频繁的更新操作，考虑使用Vector而不是List
val vector = Vector(1, 2, 3, 4, 5)
val updatedVector = vector.updated(2, 99)  // Vector(1, 2, 99, 4, 5)
```

### 链表实现

```scala
// 自定义不可变链表
sealed trait MyList[+A]
case object MyNil extends MyList[Nothing]
case class MyCons[+A](head: A, tail: MyList[A]) extends MyList[A]

object MyList {
  def apply[A](as: A*): MyList[A] = {
    if (as.isEmpty) MyNil
    else MyCons(as.head, apply(as.tail: _*))
  }
  
  def sum(ints: MyList[Int]): Int = ints match {
    case MyNil => 0
    case MyCons(h, t) => h + sum(t)
  }
  
  def product(ds: MyList[Double]): Double = ds match {
    case MyNil => 1.0
    case MyCons(0.0, _) => 0.0
    case MyCons(h, t) => h * product(t)
  }
  
  def tail[A](l: MyList[A]): MyList[A] = l match {
    case MyNil => sys.error("tail of empty list")
    case MyCons(_, t) => t
  }
  
  def setHead[A](l: MyList[A], h: A): MyList[A] = l match {
    case MyNil => sys.error("setHead on empty list")
    case MyCons(_, t) => MyCons(h, t)
  }
  
  def drop[A](l: MyList[A], n: Int): MyList[A] = {
    if (n <= 0) l
    else l match {
      case MyNil => MyNil
      case MyCons(_, t) => drop(t, n-1)
    }
  }
  
  def dropWhile[A](l: MyList[A])(f: A => Boolean): MyList[A] = l match {
    case MyCons(h, t) if f(h) => dropWhile(t)(f)
    case _ => l
  }
  
  def init[A](l: MyList[A]): MyList[A] = l match {
    case MyNil => sys.error("init of empty list")
    case MyCons(_, MyNil) => MyNil
    case MyCons(h, t) => MyCons(h, init(t))
  }
  
  def foldRight[A, B](as: MyList[A], acc: B)(f: (A, B) => B): B = as match {
    case MyNil => acc
    case MyCons(h, t) => f(h, foldRight(t, acc)(f))
  }
  
  def length[A](l: MyList[A]): Int = foldRight(l, 0)((_, acc) => acc + 1)
  
  def foldLeft[A, B](as: MyList[A], acc: B)(f: (B, A) => B): B = as match {
    case MyNil => acc
    case MyCons(h, t) => foldLeft(t, f(acc, h))(f)
  }
  
  def sum2(ints: MyList[Int]): Int = foldLeft(ints, 0)(_ + _)
  def product2(ds: MyList[Double]): Double = foldLeft(ds, 1.0)(_ * _)
  def length2[A](l: MyList[A]): Int = foldLeft(l, 0)((acc, _) => acc + 1)
  
  def reverse[A](l: MyList[A]): MyList[A] = foldLeft(l, MyList: MyList[A])((acc, h) => MyCons(h, acc))
  
  def append[A](a1: MyList[A], a2: MyList[A]): MyList[A] = foldRight(a1, a2)(MyCons(_, _))
  
  def concat[A](l: MyList[MyList[A]]): MyList[A] = foldRight(l, MyList: MyList[A])(append)
  
  def map[A, B](l: MyList[A])(f: A => B): MyList[B] = foldRight(l, MyNil: MyList[B])((h, t) => MyCons(f(h), t))
  
  def filter[A](l: MyList[A])(f: A => Boolean): MyList[A] = foldRight(l, MyNil: MyList[A])((h, t) => if (f(h)) MyCons(h, t) else t)
  
  def flatMap[A, B](l: MyList[A])(f: A => MyList[B]): MyList[B] = concat(map(l)(f))
  
  def zipWith[A, B, C](a: MyList[A], b: MyList[B])(f: (A, B) => C): MyList[C] = (a, b) match {
    case (MyNil, _) => MyNil
    case (_, MyNil) => MyNil
    case (MyCons(h1, t1), MyCons(h2, t2)) => MyCons(f(h1, h2), zipWith(t1, t2)(f))
  }
}

// 使用自定义链表
val list = MyList(1, 2, 3, 4, 5)
println(MyList.sum(list))      // 15
println(MyList.product(MyList(1.0, 2.0, 3.0)))  // 6.0
println(MyList.tail(list))      // MyList(2, 3, 4, 5)
println(MyList.setHead(list, 0))  // MyList(0, 2, 3, 4, 5)
println(MyList.drop(list, 2))  // MyList(3, 4, 5)
println(MyList.dropWhile(list)(_ < 3))  // MyList(3, 4, 5)
println(MyList.init(list))      // MyList(1, 2, 3, 4)
println(MyList.length(list))    // 5
println(MyList.sum2(list))      // 15
println(MyList.reverse(list))   // MyList(5, 4, 3, 2, 1)
println(MyList.map(list)(_ * 2))  // MyList(2, 4, 6, 8, 10)
println(MyList.filter(list)(_ % 2 == 0))  // MyList(2, 4)
println(MyList.flatMap(list)(x => MyList(x, x * 10)))  // MyList(1, 10, 2, 20, 3, 30, 4, 40, 5, 50)
```

### 二叉树实现

```scala
// 二叉树实现
sealed trait Tree[+A]
case class Leaf[A](value: A) extends Tree[A]
case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A]

object Tree {
  def size[A](t: Tree[A]): Int = t match {
    case Leaf(_) => 1
    case Branch(l, r) => 1 + size(l) + size(r)
  }
  
  def maximum(t: Tree[Int]): Int = t match {
    case Leaf(v) => v
    case Branch(l, r) => maximum(l).max(maximum(r))
  }
  
  def depth[A](t: Tree[A]): Int = t match {
    case Leaf(_) => 0
    case Branch(l, r) => 1 + (depth(l).max(depth(r)))
  }
  
  def map[A, B](t: Tree[A])(f: A => B): Tree[B] = t match {
    case Leaf(v) => Leaf(f(v))
    case Branch(l, r) => Branch(map(l)(f), map(r)(f))
  }
  
  def fold[A, B](t: Tree[A])(f: A => B)(g: (B, B) => B): B = t match {
    case Leaf(v) => f(v)
    case Branch(l, r) => g(fold(l)(f)(g), fold(r)(f)(g))
  }
  
  def sizeViaFold[A](t: Tree[A]): Int = fold(t)(_ => 1)(1 + _ + _)
  def maximumViaFold(t: Tree[Int]): Int = fold(t)(identity)(_ max _)
  def depthViaFold[A](t: Tree[A]): Int = fold(t)(_ => 0)((d1, d2) => 1 + (d1 max d2))
  def mapViaFold[A, B](t: Tree[A])(f: A => B): Tree[B] = fold(t)(a => Leaf(f(a)): Tree[B])((l, r) => Branch(l, r))
}

// 使用二叉树
val tree = Branch(
  Branch(Leaf(1), Leaf(2)),
  Branch(Leaf(3), Branch(Leaf(4), Leaf(5)))
)

println(Tree.size(tree))  // 7
println(Tree.maximum(tree))  // 5
println(Tree.depth(tree))  // 3
println(Tree.map(tree)(_ * 2))  // 树中每个值乘以2
println(Tree.sizeViaFold(tree))  // 7
println(Tree.maximumViaFold(tree))  // 5
println(Tree.depthViaFold(tree))  // 3
```

## 4.10 函数式设计模式

### 函数组合器模式

```scala
// 函数组合器模式：通过组合简单函数创建复杂函数
def compose[A, B, C](f: B => C, g: A => B): A => C = a => f(g(a))

// 创建特定用途的处理器
def toUpperCase: String => String = _.toUpperCase
def addPrefix: String => String = s"PREFIX: $_"
def addSuffix: String => String = s"${_}:SUFFIX"

// 组合函数
val process = addSuffix.compose(toUpperCase).compose(addPrefix)
val result = process("hello")  // "PREFIX: HELLO:SUFFIX"

// 更通用的组合器
def pipe[A, B](value: A)(f: A => B): B = f(value)

def composeN[A](functions: List[A => A]): A => A = {
  functions.reduce((f, g) => f.compose(g))
}

// 创建处理管道
val processingPipeline = composeN(List(
  (x: Int) => x * 2,
  (x: Int) => x + 10,
  (x: Int) => x / 5
))

val pipelineResult = processingPipeline(15)  // 8 (((15 * 2) + 10) / 5)
```

### 记忆化（Memoization）模式

```scala
// 记忆化模式：缓存函数结果避免重复计算
def memoize[A, B](f: A => B): A => B = {
  val cache = scala.collection.mutable.Map[A, B]()
  
  (a: A) => {
    if (cache.contains(a)) {
      cache(a)
    } else {
      val result = f(a)
      cache(a) = result
      result
    }
  }
}

// 记忆化斐波那契数列
def fibonacci(n: Int): BigInt = {
  if (n <= 1) n
  else fibonacci(n - 1) + fibonacci(n - 2)
}

val memoizedFib = memoize(fibonacci)
println(memoizedFib(30))  // 计算并缓存
println(memoizedFib(30))  // 从缓存获取

// 记忆化阶乘
def factorial(n: Int): BigInt = {
  if (n <= 1) 1
  else n * factorial(n - 1)
}

val memoizedFactorial = memoize(factorial)
println(memoizedFactorial(20))
println(memoizedFactorial(20))  // 从缓存获取
```

### 代数数据类型模式

```scala
// 使用密封特质和样例类实现代数数据类型
sealed trait PaymentMethod
case class CreditCard(number: String, expiry: String) extends PaymentMethod
case class PayPal(email: String) extends PaymentMethod
case class BankTransfer(accountNumber: String) extends PaymentMethod

// 处理支付
def processPayment(method: PaymentMethod): String = {
  method match {
    case CreditCard(number, expiry) => s"Processing credit card payment: $number"
    case PayPal(email) => s"Processing PayPal payment: $email"
    case BankTransfer(account) => s"Processing bank transfer: $account"
  }
}

// 订单状态
sealed trait OrderStatus
case object Pending extends OrderStatus
case object Processing extends OrderStatus
case object Shipped extends OrderStatus
case object Delivered extends OrderStatus
case object Cancelled extends OrderStatus

// 状态转换
def nextStatus(status: OrderStatus): Option[OrderStatus] = {
  status match {
    case Pending => Some(Processing)
    case Processing => Some(Shipped)
    case Shipped => Some(Delivered)
    case Delivered | Cancelled => None
  }
}
```

### 函数式错误处理模式

```scala
// 使用Either处理可能失败的操作
def divide(a: Int, b: Int): Either[String, Int] = {
  if (b == 0) Left("Division by zero")
  else Right(a / b)
}

def sqrt(x: Double): Either[String, Double] = {
  if (x < 0) Left("Square root of negative number")
  else Right(Math.sqrt(x))
}

// 组合可能失败的操作
def complexOperation(a: Int, b: Int, x: Double): Either[String, Double] = {
  for {
    quotient <- divide(a, b).right
    root <- sqrt(quotient.toDouble).right
  } yield root
}

val result1 = complexOperation(100, 4, 0)  // Right(5.0)
val result2 = complexOperation(100, 0, 0)  // Left("Division by zero")
val result3 = complexOperation(-100, 4, 0) // Left("Square root of negative number")

// 使用验证累积多个错误
case class User(name: String, age: Int, email: String)

def validateName(name: String): Either[String, String] = {
  if (name.nonEmpty) Right(name)
  else Left("Name cannot be empty")
}

def validateAge(age: Int): Either[String, Int] = {
  if (age >= 0 && age <= 120) Right(age)
  else Left("Age must be between 0 and 120")
}

def validateEmail(email: String): Either[String, String] = {
  if (email.contains("@")) Right(email)
  else Left("Invalid email format")
}

// 使用Either累积错误（使用Applicative）
import cats.data.Validated
import cats.implicits._

type ValidationResult[A] = Validated[List[String], A]

def validateNameV(name: String): ValidationResult[String] = {
  if (name.nonEmpty) Validated.valid(name)
  else Validated.invalid(List("Name cannot be empty"))
}

def validateAgeV(age: Int): ValidationResult[Int] = {
  if (age >= 0 && age <= 120) Validated.valid(age)
  else Validated.invalid(List("Age must be between 0 and 120"))
}

def validateEmailV(email: String): ValidationResult[String] = {
  if (email.contains("@")) Validated.valid(email)
  else Validated.invalid(List("Invalid email format"))
}

def validateUser(name: String, age: Int, email: String): ValidationResult[User] = {
  val validatedName = validateNameV(name)
  val validatedAge = validateAgeV(age)
  val validatedEmail = validateEmailV(email)
  
  (validatedName, validatedAge, validatedEmail).mapN(User)
}

val userValidation = validateUser("", 130, "invalid-email")
println(userValidation)  // Invalid(List("Name cannot be empty", "Age must be between 0 and 120", "Invalid email format"))
```

### 函数式状态管理模式

```scala
// 使用State monad管理状态
case class State[S, A](run: S => (A, S)) {
  def map[B](f: A => B): State[S, B] = State(s => {
    val (a, newState) = run(s)
    (f(a), newState)
  })
  
  def flatMap[B](f: A => State[S, B]): State[S, B] = State(s => {
    val (a, newState) = run(s)
    f(a).run(newState)
  })
}

object State {
  def pure[S, A](a: A): State[S, A] = State(s => (a, s))
  
  def get[S]: State[S, S] = State(s => (s, s))
  
  def set[S](s: S): State[S, Unit] = State(_ => ((), s))
  
  def modify[S](f: S => S): State[S, Unit] = State(s => ((), f(s)))
}

// 示例：使用State管理随机数生成器
type RNGState = Long

def nextInt(rng: RNGState): (Int, RNGState) = {
  val newRng = (rng * 0x5DEECE66DL + 0xBL) & 0xFFFFFFFFFFFFL
  val n = (newRng >>> 16).toInt
  (n, newRng)
}

val nextIntState: State[RNGState, Int] = State(nextInt)

def nextIntBetween(min: Int, max: Int): State[RNGState, Int] = {
  nextIntState.map(n => math.abs(n % (max - min)) + min)
}

def nextBoolean: State[RNGState, Boolean] = {
  nextIntState.map(_ % 2 == 0)
}

// 组合随机操作
def randomPair: State[RNGState, (Int, Boolean)] = {
  for {
    num <- nextIntBetween(1, 100)
    bool <- nextBoolean
  } yield (num, bool)
}

val initialSeed = 42L
val (result, newSeed) = randomPair.run(initialSeed)
println(s"Random pair: $result, new seed: $newSeed")
```

## 总结

本章深入探讨了Scala的函数式编程基础，包括高阶函数、纯函数、函数组合、柯里化、闭包、递归、偏函数、函数式数据结构和函数式设计模式等概念。

函数式编程提供了一种不同的思考问题的方式，通过将计算视为数学函数的求值，强调不可变性和无副作用，帮助我们编写更安全、更模块化、更易于测试和推理的代码。

关键点：
- 高阶函数是函数式编程的基石，允许函数作为值传递和返回
- 纯函数无副作用，对于相同输入总是返回相同输出
- 函数组合通过组合简单函数构建复杂函数
- 柯里化和部分应用提供了灵活的函数参数化机制
- 闭包允许函数捕获和访问外部作用域的变量
- 尾递归提供了一种安全替代循环的方式
- 偏函数处理输入域的子集，与集合操作结合使用非常强大
- 不可变数据结构是函数式编程的核心
- 函数式设计模式提供了处理常见问题的函数式解决方案

下一章将深入探讨Scala的集合框架，了解Scala提供的丰富集合类型及其操作。