# 第5章 集合框架深入

## 目录
- [5.1 集合类型层次结构](#51-集合类型层次结构)
- [5.2 不可变集合](#52-不可变集合)
- [5.3 可变集合](#53-可变集合)
- [5.4 集合操作方法](#54-集合操作方法)
- [5.5 并行集合](#55-并行集合)
- [5.6 集合性能分析](#56-集合性能分析)
- [5.7 自定义集合](#57-自定义集合)
- [5.8 集合视图](#58-集合视图)
- [5.9 集合与隐式转换](#59-集合与隐式转换)
- [5.10 集合最佳实践](#510-集合最佳实践)

## 5.1 集合类型层次结构

### Scala集合框架概述

Scala集合框架分为两大主要类别：不可变集合（immutable）和可变集合（mutable）。每种类别都有自己的类型层次结构，它们都继承自相同的通用特质，使得两种集合类型可以互相转换。

### 不可变集合层次结构

```scala
// 不可变集合层次结构
scala.collection.immutable.Iterable
  ├── Seq
  │   ├── IndexedSeq
  │   │   ├── Vector
  │   │   ├── List
  │   │   └── LazyList
  │   └── LinearSeq
  │       ├── List
  │       └── LazyList
  ├── Set
  │   ├── HashSet
  │   ├── ListSet
  │   └── TreeSet
  └── Map
      ├── HashMap
      ├── ListMap
      └── TreeMap
```

### 可变集合层次结构

```scala
// 可变集合层次结构
scala.collection.mutable.Iterable
  ├── Seq
  │   ├── Buffer
  │   │   ├── ListBuffer
  │   │   └── ArrayBuffer
  │   ├── IndexedSeq
  │   │   ├── Vector
  │   │   └── ArrayBuffer
  │   └── LinearSeq
  │       ├── MutableList
  │       └── LinkedList
  ├── Set
  │   ├── HashSet
  │   └── TreeSet
  └── Map
      ├── HashMap
      └── TreeMap
```

### 基本集合类型

```scala
// 不可变集合（默认导入）
val immutableList = List(1, 2, 3)
val immutableSet = Set(1, 2, 3)
val immutableMap = Map("one" -> 1, "two" -> 2)

// 可变集合（需要显式导入）
import scala.collection.mutable
val mutableBuffer = mutable.Buffer(1, 2, 3)
val mutableSet = mutable.Set(1, 2, 3)
val mutableMap = mutable.Map("one" -> 1, "two" -> 2)
```

### 集合共享特质

```scala
// 所有集合共享的特质
val iterable: Iterable[Int] = List(1, 2, 3)
val seq: Seq[Int] = List(1, 2, 3)
val indexedSeq: IndexedSeq[Int] = Vector(1, 2, 3)

// 使用通用方法
val size = iterable.size
val isEmpty = iterable.isEmpty
val nonEmpty = iterable.nonEmpty
val head = iterable.head
val tail = iterable.tail
```

## 5.2 不可变集合

### 不可变列表（List）

不可变列表是Scala中最常用的集合类型之一，具有高效的前置操作和模式匹配。

```scala
// 创建列表
val list1 = List(1, 2, 3, 4, 5)  // 方法1
val list2 = 1 :: 2 :: 3 :: 4 :: 5 :: Nil  // 方法2（使用cons操作符）
val list3 = List.range(1, 6)  // 方法3

// 基本操作
val emptyList = Nil  // 空列表
val first = list1.head  // 1
val rest = list1.tail  // List(2, 3, 4, 5)
val size = list1.length  // 5

// 列表操作
val prefixed = 0 :: list1  // List(0, 1, 2, 3, 4, 5)
val appended = list1 :+ 6  // List(1, 2, 3, 4, 5, 6)
val concatenated = list1 ++ List(6, 7, 8)  // List(1, 2, 3, 4, 5, 6, 7, 8)
val reversed = list1.reverse  // List(5, 4, 3, 2, 1)

// 列表模式匹配
def processList(list: List[Int]): String = {
  list match {
    case Nil => "Empty list"
    case head :: Nil => s"Single element: $head"
    case head :: tail => s"First: $head, rest: $tail"
  }
}

// 高阶函数
val doubled = list1.map(_ * 2)  // List(2, 4, 6, 8, 10)
val filtered = list1.filter(_ % 2 == 0)  // List(2, 4)
val sum = list1.reduce(_ + _)  // 15
val sum2 = list1.sum  // 15

// 列表操作方法
val take = list1.take(3)  // List(1, 2, 3)
val drop = list1.drop(2)  // List(3, 4, 5)
val takeWhile = list1.takeWhile(_ < 4)  // List(1, 2, 3)
val dropWhile = list1.dropWhile(_ < 3)  // List(3, 4, 5)
val partitioned = list1.partition(_ % 2 == 0)  // (List(2, 4), List(1, 3, 5))
val grouped = list1.groupBy(_ % 2)  // Map(0 -> List(2, 4), 1 -> List(1, 3, 5))
```

### Vector

Vector是高效的不可变索引序列，支持快速随机访问和更新。

```scala
// 创建Vector
val vector1 = Vector(1, 2, 3, 4, 5)
val vector2 = Vector.range(1, 6)

// 基本操作
val first = vector1(0)  // 1
val third = vector1(2)  // 3
val size = vector1.length  // 5

// 更新操作（创建新Vector）
val updated = vector1.updated(2, 99)  // Vector(1, 2, 99, 4, 5)
val prepended = 0 +: vector1  // Vector(0, 1, 2, 3, 4, 5)
val appended = vector1 :+ 6  // Vector(1, 2, 3, 4, 5, 6)

// Vector操作
val sliced = vector1.slice(1, 4)  // Vector(2, 3, 4)
val patched = vector1.patch(1, List(9, 8, 7), 2)  // Vector(1, 9, 8, 7, 4, 5)
val zipped = vector1.zip(List("a", "b", "c", "d", "e"))  // Vector((1,a), (2,b), (3,c), (4,d), (5,e))
```

### 不可变集合（Set）

```scala
// 创建Set
val set1 = Set(1, 2, 3, 4, 5)
val set2 = Set(3, 4, 5, 6, 7)

// 基本操作
val contains = set1(3)  // true
val size = set1.size  // 5

// 集合操作
val union = set1.union(set2)  // Set(1, 2, 3, 4, 5, 6, 7)
val intersection = set1.intersect(set2)  // Set(3, 4, 5)
val difference = set1.diff(set2)  // Set(1, 2)
val subset = set1.subsetOf(Set(1, 2, 3, 4, 5, 6))  // true

// 方法简写
val union2 = set1 ++ set2  // union
val intersection2 = set1 & set2  // intersect
val difference2 = set1 &~ set2  // diff

// 修改操作（创建新集合）
val added = set1 + 6  // Set(1, 2, 3, 4, 5, 6)
val removed = set1 - 3  // Set(1, 2, 4, 5)
val addedMultiple = set1 ++ Set(6, 7, 8)  // Set(1, 2, 3, 4, 5, 6, 7, 8)
val removedMultiple = set1 -- Set(1, 3, 5)  // Set(2, 4)

// 特定类型的Set
val hashSet = HashSet(1, 2, 3)  // 哈希集合
val treeSet = TreeSet(3, 1, 4, 2)  // 有序集合：TreeSet(1, 2, 3, 4)
val listSet = ListSet(3, 1, 4, 2)  // 列表集合：ListSet(3, 1, 4, 2)（插入顺序）

// 有序集合的操作
val rangeSet = RangeSet(1 to 10)
val rangeAdded = rangeSet + 15  // RangeSet(1 to 10, 15)
```

### 不可变映射（Map）

```scala
// 创建Map
val map1 = Map("one" -> 1, "two" -> 2, "three" -> 3)
val map2 = Map(("four", 4), ("five", 5))

// 基本操作
val value = map1("two")  // 2
val optionValue = map1.get("two")  // Some(2)
val contains = map1.contains("two")  // true
val keys = map1.keys  // Set("one", "two", "three")
val values = map1.values  // Iterable(1, 2, 3)

// 安全访问
val defaultValue = map1.getOrElse("four", 0)  // 0
val withDefault = map1.withDefaultValue(0)  // 提供默认值的Map
val withDefaultVal = withDefault("four")  // 0

// 修改操作（创建新Map）
val added = map1 + ("four" -> 4)  // Map("one" -> 1, "two" -> 2, "three" -> 3, "four" -> 4)
val removed = map1 - "two"  // Map("one" -> 1, "three" -> 3)
val addedMultiple = map1 ++ Map("four" -> 4, "five" -> 5)  // 添加多个
val removedMultiple = map1 -- Set("one", "three")  // Map("two" -> 2)

// 更新操作
val updated = map1.updated("two", 22)  // Map("one" -> 1, "two" -> 22, "three" -> 3)

// 高阶函数
val transformed = map1.map { case (k, v) => (k.toUpperCase, v * 2) }
// Map("ONE" -> 2, "TWO" -> 4, "THREE" -> 6)

val filtered = map1.filter { case (k, v) => v > 1 }
// Map("two" -> 2, "three" -> 3)

// 特定类型的Map
val hashMap = HashMap("one" -> 1, "two" -> 2)  // 哈希映射
val treeMap = TreeMap("b" -> 2, "a" -> 1, "c" -> 3)  // 有序映射：Map("a" -> 1, "b" -> 2, "c" -> 3)
val listMap = ListMap("c" -> 3, "a" -> 1, "b" -> 2)  // 列表映射：Map("c" -> 3, "a" -> 1, "b" -> 2)（插入顺序）

// Map的链式操作
val result = Map("a" -> 1, "b" -> 2, "c" -> 3)
  .filter { case (k, v) => k < "c" }
  .map { case (k, v) => (k.toUpperCase, v * 10) }
// Map("A" -> 10, "B" -> 20)
```

### LazyList（惰性列表）

LazyList是惰性计算的列表，只有当需要时才会计算元素。

```scala
// 创建LazyList
val lazyList1 = LazyList(1, 2, 3, 4, 5)
val lazyList2 = LazyList.from(1)  // 从1开始的无限序列
val lazyList3 = LazyList.range(1, 10)  // 1到9的范围
val lazyList4 = LazyList.continually(42)  // 重复42的无限序列

// 基本操作
val first = lazyList1.head  // 1
val rest = lazyList1.tail  // LazyList(2, 3, 4, 5)
val take5 = lazyList2.take(5).toList  // List(1, 2, 3, 4, 5)

// 惰性计算示例
def expensiveCompute(n: Int): Int = {
  println(s"Computing $n")
  n * n
}

val lazyExpensive = LazyList.from(1).map(expensiveCompute)
println("LazyList created, no computation yet")

// 只有在需要时才计算
val firstTwo = lazyExpensive.take(2).toList
// 输出：Computing 1, Computing 2

// 斐波那契数的LazyList实现
def fibLazyList: LazyList[Int] = {
  lazy val fibs: LazyList[Int] = 0 #:: 1 #:: fibs.zip(fibs.tail).map { case (a, b) => a + b }
  fibs
}

val fibNumbers = fibLazyList.take(10).toList  // List(0, 1, 1, 2, 3, 5, 8, 13, 21, 34)

// 素数的LazyList实现
def primes: LazyList[Int] = {
  lazy val primesStream: LazyList[Int] = 2 #:: primesStream.filter {
    p => LazyList.from(3, 2).takeWhile(_ <= math.sqrt(p)).forall(p % _ != 0)
  }
  primesStream
}

val primeNumbers = primes.take(10).toList  // List(2, 3, 5, 7, 11, 13, 17, 19, 23, 29)

// 惰性列表操作
val filtered = lazyList2.filter(_ % 2 == 0).take(5).toList  // List(2, 4, 6, 8, 10)
val transformed = lazyList2.map(_ * 2).take(5).toList  // List(2, 4, 6, 8, 10)
val zipped = lazyList2.zip(lazyList2.map(_ * 2)).take(5).toList
// List((1,2), (2,4), (3,6), (4,8), (5,10))
```

## 5.3 可变集合

### 可变Buffer

Buffer是可变序列，提供高效的元素添加和删除操作。

```scala
import scala.collection.mutable

// 创建Buffer
val buffer1 = mutable.Buffer(1, 2, 3)
val buffer2 = mutable.ListBuffer(1, 2, 3)
val buffer3 = mutable.ArrayBuffer(1, 2, 3)

// 基本操作
buffer1 += 4  // 添加元素：Buffer(1, 2, 3, 4)
buffer1 += (5, 6)  // 添加多个元素：Buffer(1, 2, 3, 4, 5, 6)
buffer1 ++= List(7, 8, 9)  // 添加集合：Buffer(1, 2, 3, 4, 5, 6, 7, 8, 9)

buffer1 -= 3  // 移除元素：Buffer(1, 2, 4, 5, 6, 7, 8, 9)
buffer1 -= (1, 2)  // 移除多个元素：Buffer(4, 5, 6, 7, 8, 9)

// 位置操作
buffer1.insert(2, 99)  // 在索引2插入99
buffer1.insertAll(3, List(98, 97))  // 在索引3插入多个元素
buffer1.remove(4)  // 移除索引4的元素
buffer1.remove(5, 2)  // 从索引5开始移除2个元素

// 转换为不可变集合
val immutableList = buffer1.toList
val immutableVector = buffer1.toVector
val immutableSet = buffer1.toSet

// ListBuffer特定操作
buffer2.prepend(0)  // 在前面添加：ListBuffer(0, 1, 2, 3)
buffer2.trimStart(1)  // 移除第一个元素
buffer2.trimEnd(1)  // 移除最后一个元素

// ArrayBuffer特定操作（数组实现，随机访问快）
buffer3(0) = 10  // 修改索引0的元素
buffer3.update(1, 20)  // 同上，另一种方式
val first = buffer3.head  // 10
val last = buffer3.last  // 3
val length = buffer3.length  // 3
```

### 可变Set

```scala
import scala.collection.mutable

// 创建可变Set
val set1 = mutable.Set(1, 2, 3)
val hashSet = mutable.HashSet(1, 2, 3)
val treeSet = mutable.TreeSet(3, 1, 4, 2)  // 有序集合：TreeSet(1, 2, 3, 4)
val sortedSet = mutable.SortedSet(3, 1, 4, 2)  // 有序集合：TreeSet(1, 2, 3, 4)

// 基本操作
set1 += 4  // 添加元素
set1 += (5, 6)  // 添加多个元素
set1 ++= List(7, 8, 9)  // 添加集合

set1 -= 3  // 移除元素
set1 -= (1, 2)  // 移除多个元素
set1 --= List(5, 6)  // 移除集合

// 清空和检查
val empty = set1.isEmpty
set1.clear()  // 清空集合

// 集合操作
set1.add(10)  // 返回Boolean，是否添加成功
set1.remove(10)  // 返回Boolean，是否移除成功
set1.retain(_ % 2 == 0)  // 只保留偶数

// 转换为不可变集合
val immutableSet = set1.toSet

// 有序集合操作
val first = treeSet.firstKey  // 1
val last = treeSet.lastKey  // 4
val range = treeSet.range(2, 4)  // TreeSet(2, 3)
```

### 可变Map

```scala
import scala.collection.mutable

// 创建可变Map
val map1 = mutable.Map("one" -> 1, "two" -> 2, "three" -> 3)
val hashMap = mutable.HashMap("one" -> 1, "two" -> 2)
val treeMap = mutable.TreeMap("b" -> 2, "a" -> 1, "c" -> 3)  // 有序映射
val linkedMap = mutable.LinkedHashMap("c" -> 3, "a" -> 1, "b" -> 2)  // 插入顺序映射

// 基本操作
map1("four") = 4  // 添加或更新元素
map1 += ("five" -> 5)  // 添加元素
map1 += ("six" -> 6, "seven" -> 7)  // 添加多个元素
map1 ++= Map("eight" -> 8, "nine" -> 9)  // 添加集合

map1 -= "one"  // 移除元素
map1 -= ("two", "three")  // 移除多个元素
map1 --= List("four", "five")  // 移除集合

// 获取和更新
val value = map1("six")  // 6（如果不存在会抛出异常）
val optionValue = map1.get("six")  // Some(6)
val defaultValue = map1.getOrElse("ten", 0)  // 0
val valueOrAdd = map1.getOrElseUpdate("ten", 10)  // 获取或添加
val removedValue = map1.remove("ten")  // 移除并返回值

// 清空和检查
val empty = map1.isEmpty
map1.clear()  // 清空映射

// 转换为不可变集合
val immutableMap = map1.toMap

// 有序映射操作
val firstKey = treeMap.firstKey  // "a"
val lastKey = treeMap.lastKey  // "c"
val range = treeMap.rangeFrom("b")  // TreeMap("b" -> 2, "c" -> 3)

// LinkedHashMap保持插入顺序
val linkedOrder = linkedMap.keys.toList  // List("c", "a", "b")
```

### 可变队列和栈

```scala
import scala.collection.mutable

// 队列（FIFO）
val queue = mutable.Queue(1, 2, 3)
queue.enqueue(4)  // 入队：Queue(1, 2, 3, 4)
queue.enqueueAll(List(5, 6, 7))  // 批量入队

val first = queue.dequeue()  // 出队：1，队列变为Queue(2, 3, 4, 5, 6, 7)
val front = queue.front  // 查看队首元素：2
val back = queue.back  // 查看队尾元素：7

// 栈（LIFO）
val stack = mutable.Stack(1, 2, 3)
stack.push(0)  // 入栈：Stack(0, 1, 2, 3)
stack.pushAll(List(-2, -1))  // 批量入栈

val top = stack.pop()  // 出栈：-1，栈变为Stack(-2, 0, 1, 2, 3)
val peek = stack.top  // 查看栈顶元素：-2

// 双端队列
val deque = mutable.ArrayDeque(1, 2, 3)
deque += 4  // 添加到末尾：ArrayDeque(1, 2, 3, 4)
deque.prepend(0)  // 添加到开头：ArrayDeque(0, 1, 2, 3, 4)

val firstRemoved = deque.removeHead()  // 移除并返回第一个元素：0
val lastRemoved = deque.removeLast()  // 移除并返回最后一个元素：4
```

## 5.4 集合操作方法

### 转换操作（Transformation）

转换操作返回新的集合，不修改原集合。

```scala
val numbers = List(1, 2, 3, 4, 5)
val words = List("scala", "java", "python", "javascript")

// map：对每个元素应用函数
val doubled = numbers.map(_ * 2)  // List(2, 4, 6, 8, 10)
val lengths = words.map(_.length)  // List(5, 4, 6, 10)

// flatMap：应用返回集合的函数并展平
val chars = words.flatMap(_.toList)  // List(s, c, a, l, a, j, a, v, a, p, y, t, h, o, n, j, a, v, a, s, c, r, i, p, t)
val pairs = numbers.flatMap(i => List(i, i * 10))  // List(1, 10, 2, 20, 3, 30, 4, 40, 5, 50)

// collect：类似map+filter，使用偏函数
val evenSquares = numbers.collect {
  case x if x % 2 == 0 => x * x
}  // List(4, 16)

// filter：过滤元素
val evenNumbers = numbers.filter(_ % 2 == 0)  // List(2, 4)
val longWords = words.filter(_.length > 4)  // List("scala", "python", "javascript")

// partition：分区，返回符合条件的和不符合条件的两个集合
val (evens, odds) = numbers.partition(_ % 2 == 0)  // (List(2, 4), List(1, 3, 5))

// groupBy：按条件分组
val groupedByLength = words.groupBy(_.length)
// Map(5 -> List("scala"), 4 -> List("java"), 6 -> List("python"), 10 -> List("javascript"))

// 分割和连接
val taken = numbers.take(3)  // List(1, 2, 3)
val dropped = numbers.drop(3)  // List(4, 5)
val takenWhile = numbers.takeWhile(_ < 4)  // List(1, 2, 3)
val droppedWhile = numbers.dropWhile(_ < 4)  // List(4, 5)
val sliced = numbers.slice(1, 4)  // List(2, 3, 4)

// 补丁操作
val patched = numbers.patch(2, List(99, 98), 2)  // List(1, 2, 99, 98, 5)

// 排序
val sorted = numbers.sorted  // List(1, 2, 3, 4, 5)
val reversed = numbers.reverse  // List(5, 4, 3, 2, 1)
val sortByLength = words.sortBy(_.length)  // List("java", "scala", "python", "javascript")
val sortedWithComparator = words.sortWith((a, b) => a.length < b.length)  // 同上

// 去重
val withDuplicates = List(1, 2, 2, 3, 1, 4, 5)
val distinct = withDuplicates.distinct  // List(1, 2, 3, 4, 5)

// 转换
val asVector = numbers.toVector  // Vector(1, 2, 3, 4, 5)
val asSet = numbers.toSet  // Set(1, 2, 3, 4, 5)
val asMap = words.map(w => w -> w.length).toMap
// Map("scala" -> 5, "java" -> 4, "python" -> 6, "javascript" -> 10)
```

### 聚合操作（Aggregation）

聚合操作将集合元素聚合成单一值。

```scala
val numbers = List(1, 2, 3, 4, 5)

// reduce：使用二元函数归约
val sum = numbers.reduce(_ + _)  // 15
val product = numbers.reduce(_ * _)  // 120
val max = numbers.reduce(_ max _)  // 5

// fold：类似于reduce，但提供初始值
val sumWithInit = numbers.fold(0)(_ + _)  // 15
val productWithInit = numbers.fold(1)(_ * _)  // 120

// foldLeft/foldRight：显式指定方向
val sumLeft = numbers.foldLeft(0)(_ + _)  // 15
val sumRight = numbers.foldRight(0)(_ + _)  // 15

// 聚合特定操作
val sumDirect = numbers.sum  // 15
val productDirect = numbers.product  // 120
val min = numbers.min  // 1
val max = numbers.max  // 5
val count = numbers.count(_ % 2 == 0)  // 2 (偶数个数)
val average = numbers.sum.toDouble / numbers.length  // 3.0

// 字符串聚合
val words = List("hello", "world", "scala")
val concatenated = words.reduce(_ + " " + _)  // "hello world scala"

// mapValues：只对Map的值进行操作
val map = Map("a" -> 1, "b" -> 2, "c" -> 3)
val transformedMap = map.mapValues(_ * 2)  // Map("a" -> 2, "b" -> 4, "c" -> 6)

// 分组聚合
val numbersByParity = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
val sumByParity = numbersByParity.groupBy(_ % 2).mapValues(_.sum)
// Map(0 -> 30, 1 -> 25) (偶数和，奇数和)

// 高级聚合
val data = List("apple", "banana", "cherry", "date")
val longestWord = data.maxBy(_.length)  // "banana"
val shortestWord = data.minBy(_.length)  // "date"

// 使用Option安全聚合
val emptyList = List.empty[Int]
val safeSum = emptyList.reduceOption(_ + _)  // None
val emptyProduct = emptyList.foldOption(1)(_ * _)  // None
```

### 信息操作（Information）

信息操作返回关于集合的信息，不修改集合。

```scala
val numbers = List(1, 2, 3, 4, 5)
val emptyList = List.empty[Int]

// 基本信息
val size = numbers.size  // 5
val length = numbers.length  // 5
val isEmpty = numbers.isEmpty  // false
val nonEmpty = numbers.nonEmpty  // true

// 检查元素
val contains = numbers.contains(3)  // true
val exists = numbers.exists(_ > 4)  // true
val forall = numbers.forall(_ > 0)  // true

// 头尾元素
val head = numbers.head  // 1
val tail = numbers.tail  // List(2, 3, 4, 5)
val last = numbers.last  // 5
val init = numbers.init  // List(1, 2, 3, 4)

// 安全访问（避免空集合异常）
val safeHead = numbers.headOption  // Some(1)
val safeLast = emptyList.lastOption  // None
val safeTail = emptyList.tailOption  // None

// 查找
val findFirstEven = numbers.find(_ % 2 == 0)  // Some(2)
val findFirstGreaterThan10 = numbers.find(_ > 10)  // None

// 索引操作
val indexOf = numbers.indexOf(3)  // 2
val lastIndexOf = numbers.lastIndexOf(3)  // 2 (列表中唯一一个3)
val indexWhere = numbers.indexWhere(_ % 2 == 0)  // 1

// 统计
val countEven = numbers.count(_ % 2 == 0)  // 2
val countGreater = numbers.count(_ > 3)  // 2

// 字符串特定信息
val text = "Hello World Scala"
val words = text.split(" ")
val wordCount = words.length  // 3
val charCount = text.length  // 18
val spaceCount = text.count(_ == ' ')  // 2

// Map特定信息
val map = Map("a" -> 1, "b" -> 2, "c" -> 3)
val keys = map.keys  // Set("a", "b", "c")
val values = map.values  // Iterable(1, 2, 3)
val keySet = map.keySet  // Set("a", "b", "c")
val hasKey = map.contains("b")  // true
val hasValue = map.valuesIterator.contains(2)  // true
```

## 5.5 并行集合

### 并行集合概述

Scala集合库提供了并行集合，可以在多核处理器上并行执行操作，提高处理大型数据集的性能。

```scala
import scala.collection.parallel._

// 创建并行集合
val list = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
val parList = list.par  // 转换为并行集合
val directParList = (1 to 10).toList.par  // 直接创建并行集合

val set = Set(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
val parSet = set.par

val map = Map("one" -> 1, "two" -> 2, "three" -> 3, "four" -> 4, "five" -> 5)
val parMap = map.par

// 基本并行操作
val parallelSum = parList.sum  // 并行计算和
val parallelProduct = parList.product  // 并行计算积
val parallelFiltered = parList.filter(_ % 2 == 0)  // 并行过滤
val parallelMapped = parList.map(_ * 2)  // 并行映射

// 并行归约
val parallelReduce = parList.reduce(_ + _)  // 并行归约
val parallelFold = parList.fold(0)(_ + _)  // 并行折叠

// 并行聚合
val parallelCount = parList.count(_ % 2 == 0)  // 并行计数
val parallelMax = parList.max  // 并行求最大值
val parallelMin = parList.min  // 并行求最小值

// 性能对比
import scala.concurrent.duration._

def timed[T](operation: => T): (T, FiniteDuration) = {
  val start = System.nanoTime()
  val result = operation
  val end = System.nanoTime()
  val duration = FiniteDuration(end - start, NANOSECONDS)
  (result, duration)
}

// 创建大数据集
val largeList = (1 to 10000000).toList
val largeParList = largeList.par

// 比较串行和并行性能
val (serialSum, serialTime) = timed(largeList.map(_ * 2).sum)
val (parallelSum, parallelTime) = timed(largeParList.map(_ * 2).sum)

println(s"Serial sum: $serialSum, time: $serialTime")
println(s"Parallel sum: $parallelSum, time: $parallelTime")
```

### 并行集合配置

```scala
import scala.collection.parallel.ForkJoinTaskSupport
import java.util.concurrent.ForkJoinPool

// 创建并行集合
val parList = (1 to 1000000).toList.par

// 配置并行度（线程数）
val customPool = new ForkJoinPool(4)  // 使用4个线程
parList.tasksupport = new ForkJoinTaskSupport(customPool)

// 执行并行操作
val result = parList.map(_ * 2).sum

// 重置为默认
parList.tasksupport = new ForkJoinTaskSupport(new ForkJoinPool())

// 获取并行度
val parallelism = parList.tasksupport.parallelism
println(s"Current parallelism: $parallelism")

// 任务分解策略
val taskList = (1 to 1000000).toList.par
taskList.tasksupport = new ForkJoinTaskSupport(
  new ForkJoinPool(2, ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, false)
)
```

### 并行集合的注意事项

```scala
import scala.collection.parallel

// 非线程安全的操作
class Counter {
  private var count = 0
  
  def increment(): Unit = count += 1
  def get(): Int = count
}

// 错误示例：并行修改非线程安全对象
val counter = new Counter
val list = (1 to 10000).toList.par
list.foreach(_ => counter.increment())
println(s"Counter value: ${counter.get()}")  // 可能不是10000

// 正确示例：使用线程安全的数据结构
import java.util.concurrent.atomic.AtomicInteger
val atomicCounter = new AtomicInteger(0)
list.foreach(_ => atomicCounter.incrementAndGet())
println(s"Atomic counter value: ${atomicCounter.get()}")  // 应该是10000

// 或者使用集合归约而不是副作用
val count = list.reduce((a, b) => a + 1)
println(s"Count via reduce: $count")

// 避免依赖顺序的操作
val parList = (1 to 10).toList.par
val inOrderResult = parList.foldLeft("")((acc, n) => acc + n)  // 可能产生不同顺序
println(s"foldLeft result: $inOrderResult")

// 使用reduce替代foldLeft（如果操作满足结合律）
val reduceResult = parList.reduce((a, b) => a + b)
println(s"reduce result: $reduceResult")

// 短路操作在并行集合中的问题
val hasLargeNumber = parList.exists(_ > 999999)  // 可能需要检查所有元素，即使已经找到
val serialHasLarge = (1 to 10).toList.exists(_ > 5)  // 短路评估，可能更快

// 并行集合的分割器
val iterator = parList.splitter  // 获取并行分割器
```

## 5.6 集合性能分析

### 性能特征表

不同集合类型在不同操作上的性能特征：

```scala
// List性能特征
// head: O(1)
// tail: O(1)
// apply(i): O(i)
// length: O(1)
// prepend: O(1)
// append: O(n)
// update: O(n)

// Vector性能特征
// head: O(log n)
// tail: O(log n)
// apply(i): O(log n)
// length: O(1)
// prepend: O(log n)
// append: O(log n)
// update: O(log n)

// Array性能特征（可变）
// head: O(1)
// tail: O(n)
// apply(i): O(1)
// length: O(1)
// update: O(1)

// ArrayBuffer性能特征
// head: O(1)
// tail: O(1)
// apply(i): O(1)
// length: O(1)
// update: O(1)
// append: O(1) amortized
// prepend: O(n)
// insert: O(n)

// ListBuffer性能特征
// head: O(1)
// tail: O(1)
// apply(i): O(n)
// length: O(1)
// prepend: O(1)
// append: O(1)
// insert: O(n)
```

### 性能比较示例

```scala
import scala.collection.immutable.{List, Vector}
import scala.collection.mutable.{ArrayBuffer, ListBuffer}
import scala.util.Random

// 生成测试数据
val random = new Random(42)
val dataSize = 100000
val data = List.fill(dataSize)(random.nextInt(1000))

// 测试前置操作
def prependTest[T, Coll <: Seq[T]](factory: Int => T, coll: Coll): (Long, Coll) = {
  val start = System.nanoTime()
  val result = factory(0) +: coll
  val end = System.nanoTime()
  (end - start, result)
}

// 测试追加操作
def appendTest[T, Coll <: Seq[T]](factory: Int => T, coll: Coll): (Long, Coll) = {
  val start = System.nanoTime()
  val result = coll :+ factory(dataSize)
  val end = System.nanoTime()
  (end - start, result)
}

// 测试随机访问
def randomAccessTest[T, Coll <: Seq[T]](coll: Coll): Long = {
  val start = System.nanoTime()
  var sum = 0
  for (i <- 0 until 1000) {
    sum += coll(random.nextInt(coll.length)).hashCode()
  }
  val end = System.nanoTime()
  end - start
}

// 测试前置操作性能
val (listPrependTime, _) = prependTest(identity, data)
val (vectorPrependTime, _) = prependTest(identity, data.toVector)
val (arrayBufferPrependTime, _) = prependTest(identity, ArrayBuffer(data: _*))
val (listBufferPrependTime, _) = prependTest(identity, ListBuffer(data: _*))

// 测试追加操作性能
val (listAppendTime, _) = appendTest(identity, data)
val (vectorAppendTime, _) = appendTest(identity, data.toVector)
val (arrayBufferAppendTime, _) = appendTest(identity, ArrayBuffer(data: _*))
val (listBufferAppendTime, _) = appendTest(identity, ListBuffer(data: _*))

// 测试随机访问性能
val listRandomAccessTime = randomAccessTest(data)
val vectorRandomAccessTime = randomAccessTest(data.toVector)
val arrayBufferRandomAccessTime = randomAccessTest(ArrayBuffer(data: _*))
val listBufferRandomAccessTime = randomAccessTest(ListBuffer(data: _*))

// 输出结果
println("Prepend operation (ns):")
println(s"List: $listPrependTime")
println(s"Vector: $vectorPrependTime")
println(s"ArrayBuffer: $arrayBufferPrependTime")
println(s"ListBuffer: $listBufferPrependTime")

println("\nAppend operation (ns):")
println(s"List: $listAppendTime")
println(s"Vector: $vectorAppendTime")
println(s"ArrayBuffer: $arrayBufferAppendTime")
println(s"ListBuffer: $listBufferAppendTime")

println("\nRandom access (ns):")
println(s"List: $listRandomAccessTime")
println(s"Vector: $vectorRandomAccessTime")
println(s"ArrayBuffer: $arrayBufferRandomAccessTime")
println(s"ListBuffer: $listBufferRandomAccessTime")
```

### 内存使用分析

```scala
import scala.collection.immutable.{List, Vector, Queue}
import scala.collection.mutable.{ArrayBuffer, ListBuffer, Queue as MutableQueue}

// 内存使用分析工具
def estimateSize[T](coll: Traversable[T]): Long = {
  // 简化估计，实际应使用更精确的方法
  coll.size * 8L  // 假设每个元素8字节
}

// 创建相同数据的不同集合类型
val data = (1 to 100000).toList

val list = data
val vector = data.toVector
val queue = Queue(data: _*)

val arrayBuffer = ArrayBuffer(data: _*)
val listBuffer = ListBuffer(data: _*)
val mutableQueue = MutableQueue(data: _*)

// 估计内存使用
val listSize = estimateSize(list)
val vectorSize = estimateSize(vector)
val queueSize = estimateSize(queue)

val arrayBufferSize = estimateSize(arrayBuffer)
val listBufferSize = estimateSize(listBuffer)
val mutableQueueSize = estimateSize(mutableQueue)

println("Estimated memory usage (bytes):")
println(s"List: $listSize")
println(s"Vector: $vectorSize")
println(s"Queue: $queueSize")
println(s"ArrayBuffer: $arrayBufferSize")
println(s"ListBuffer: $listBufferSize")
println(s"MutableQueue: $mutableQueueSize")
```

### 性能优化建议

```scala
// 使用Vector替代频繁随机访问的List
val listData = (1 to 10000).toList
val vectorData = listData.toVector

// List在随机访问时性能较差
def listSum(list: List[Int]): Int = {
  var sum = 0
  for (i <- list.indices) {
    sum += list(i)  // O(i) 操作
  }
  sum
}

// Vector在随机访问时性能较好
def vectorSum(vector: Vector[Int]): Int = {
  var sum = 0
  for (i <- vector.indices) {
    sum += vector(i)  // O(log n) 操作
  }
  sum
}

// 对于大量元素，使用并行集合
val largeData = (1 to 1000000).toList
val serialSum = largeData.sum
val parallelSum = largeData.par.sum

// 避免频繁创建中间集合
val data = (1 to 10000).toList

// 不好的做法：创建多个中间集合
val result1 = data.map(_ * 2).filter(_ % 3 == 0).map(_ * 4)

// 更好的做法：使用view避免中间集合
val result2 = data.view.map(_ * 2).filter(_ % 3 == 0).map(_ * 4).toList

// 或者组合操作
val result3 = data.collect {
  case x if (x * 2) % 3 == 0 => x * 8
}

// 根据操作选择合适的集合类型
// 频繁头部操作：List
val frontOperations = List(1, 2, 3, 4, 5)
val newList = 0 :: frontOperations  // 高效

// 频繁随机访问：Vector
val randomAccess = Vector(1, 2, 3, 4, 5)
val element = randomAccess(3)  // 高效

// 频繁尾部操作：ListBuffer或ArrayBuffer
val backOperations = ListBuffer(1, 2, 3, 4, 5)
backOperations += 6  // 高效
```

## 5.7 自定义集合

### 实现基本集合接口

```scala
// 自定义不可变集合
class MyList[+A](val head: A, val tail: MyList[A]) {
  def isEmpty: Boolean = false
  
  def ::[B >: A](elem: B): MyList[B] = new MyList(elem, this)
  
  def map[B](f: A => B): MyList[B] = {
    if (isEmpty) MyNil
    else new MyList(f(head), tail.map(f))
  }
  
  def filter(p: A => Boolean): MyList[A] = {
    if (isEmpty) MyNil
    else if (p(head)) new MyList(head, tail.filter(p))
    else tail.filter(p)
  }
  
  def foldLeft[B](z: B)(op: (B, A) => B): B = {
    tail.foldLeft(op(z, head))(op)
  }
  
  override def toString: String = {
    def loop(list: MyList[A], acc: String): String = {
      if (list.isEmpty) acc
      else loop(list.tail, if (acc.isEmpty) list.head.toString else s"$acc, ${list.head}")
    }
    s"[${loop(this, "")}]"
  }
}

object MyNil extends MyList[Nothing](null.asInstanceOf[Nothing], null.asInstanceOf[Nothing]) {
  override def isEmpty: Boolean = true
  override def toString: String = "[]"
}

object MyList {
  def empty[A]: MyList[A] = MyNil
  def apply[A](xs: A*): MyList[A] = {
    if (xs.isEmpty) MyNil
    else xs.foldRight(MyNil: MyList[A])((elem, acc) => new MyList(elem, acc))
  }
}

// 使用自定义集合
val myList = MyList(1, 2, 3, 4, 5)
println(myList)  // [1, 2, 3, 4, 5]

val doubled = myList.map(_ * 2)  // MyList(2, 4, 6, 8, 10)
val filtered = myList.filter(_ % 2 == 0)  // MyList(2, 4)
val sum = myList.foldLeft(0)(_ + _)  // 15
```

### 实现Iterable接口

```scala
import scala.collection.{IterableFactory, IterableOps, IterableOnce, Iterator}

// 自定义可迭代集合
class MyRange(val start: Int, val end: Int, val step: Int = 1) 
  extends Iterable[Int] with IterableOps[Int, MyRange, MyRange] {
  
  override def iterator: Iterator[Int] = new Iterator[Int] {
    private var current = start
    
    override def hasNext: Boolean = (step > 0 && current < end) || (step < 0 && current > end)
    
    override def next(): Int = {
      if (!hasNext) Iterator.empty.next()
      val result = current
      current += step
      result
    }
  }
  
  override def iterableFactory: IterableFactory[MyRange] = MyRange
  
  override def fromSpecific(coll: IterableOnce[Int]): MyRange = {
    val seq = coll.iterator.toSeq
    if (seq.isEmpty) new MyRange(start, end, step)
    else new MyRange(seq.head, seq.last, step)
  }
  
  override def newSpecificBuilder: scala.collection.mutable.Builder[Int, MyRange] = 
    new scala.collection.mutable.Builder[Int, MyRange] {
      private var elements = List.empty[Int]
      
      override def addOne(elem: Int): this.type = {
        elements = elem :: elements
        this
      }
      
      override def clear(): Unit = elements = Nil
      
      override def result(): MyRange = {
        val sorted = elements.sorted
        if (sorted.isEmpty) new MyRange(start, end, step)
        else new MyRange(sorted.head, sorted.last, step)
      }
    }
  
  override def toString: String = s"MyRange($start, $end, $step)"
}

object MyRange extends IterableFactory[MyRange] {
  def empty: MyRange = new MyRange(0, 0, 1)
  
  def fromSpecific(it: IterableOnce[Int]): MyRange = {
    val seq = it.iterator.toSeq
    if (seq.isEmpty) empty
    else new MyRange(seq.head, seq.last, 1)
  }
  
  def newBuilder: scala.collection.mutable.Builder[Int, MyRange] = new MyRange(0, 0, 1).newSpecificBuilder
}

// 使用自定义集合
val myRange = MyRange(1, 10)
println(myRange)  // MyRange(1, 10, 1)

val doubled = myRange.map(_ * 2)
println(doubled)  // MyRange(2, 20, 2)

val filtered = myRange.filter(_ % 2 == 0)
println(filtered)  // MyRange(2, 10, 2)

val sum = myRange.sum
println(s"Sum: $sum")  // Sum: 55
```

### 实现集合构建器

```scala
import scala.collection.mutable.Builder

// 自定义集合构建器
class MyListBuilder[A] extends Builder[A, MyList[A]] {
  private var elems: List[A] = Nil
  
  override def addOne(elem: A): this.type = {
    elems = elem :: elems
    this
  }
  
  override def clear(): Unit = {
    elems = Nil
  }
  
  override def result(): MyList[A] = {
    val reversed = elems.reverse
    reversed.foldLeft(MyNil: MyList[A])((acc, elem) => new MyList(elem, acc))
  }
}

// 使用构建器创建集合
val builder = new MyListBuilder[Int]
builder += 1
builder += 2
builder += 3
val myList = builder.result()
println(myList)  // [1, 2, 3]

// 在map操作中使用构建器
implicit class MyListOps[A](list: MyList[A]) {
  def map2[B](f: A => B): MyList[B] = {
    val builder = new MyListBuilder[B]()
    
    def loop(current: MyList[A]): Unit = {
      if (current.isEmpty) ()
      else {
        builder += f(current.head)
        loop(current.tail)
      }
    }
    
    loop(list)
    builder.result()
  }
}

val mapped = myList.map2(_ * 2)
println(mapped)  // [2, 4, 6]
```

## 5.8 集合视图

### 集合视图概述

集合视图（View）是一种惰性集合操作的方式，它不立即计算结果，而是创建一个中间表示，在需要时才计算元素。这可以避免创建中间集合，提高内存效率。

```scala
// 使用视图避免中间集合
val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

// 传统方式：创建多个中间集合
val result1 = numbers
  .map(_ * 2)        // 创建新集合: List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)
  .filter(_ % 3 == 0) // 创建新集合: List(6, 12, 18)
  .map(_ * 10)       // 创建新集合: List(60, 120, 180)

// 使用视图：避免创建中间集合
val result2 = numbers
  .view                // 创建视图
  .map(_ * 2)          // 惰性操作，不创建集合
  .filter(_ % 3 == 0)  // 惰性操作，不创建集合
  .map(_ * 10)         // 惰性操作，不创建集合
  .toList              // 强制计算，创建最终集合

// 强制计算视图
val forced = numbers
  .view
  .map(_ * 2)
  .filter(_ % 3 == 0)
  .map(_ * 10)
  .force  // 等同于toList，但不改变类型
```

### 视图类型

```scala
import scala.collection.View

// 不同类型的视图
val listView = List(1, 2, 3).view      // IndexedSeqView[Int]
val vectorView = Vector(1, 2, 3).view  // IndexedSeqView[Int]
val setView = Set(1, 2, 3).view          // SetView[Int]
val mapView = Map("a" -> 1, "b" -> 2).view  // MapView[String, Int]

// 遍历视图
val view = List(1, 2, 3, 4, 5).view.map(_ * 2)

// 转换为具体集合
val list = view.toList
val vector = view.toVector
val array = view.toArray

// 转换为其他视图
val filterView = view.filter(_ % 3 == 0)
val mapView = filterView.map(_ * 10)

// 视图操作
val numbers = (1 to 1000000).view

// 查找前10个偶数的平方
val first10EvenSquares = numbers
  .filter(_ % 2 == 0)
  .map(_ * _)
  .take(10)
  .toList

println(first10EvenSquares)  // List(4, 16, 36, 64, 100, 144, 196, 256, 324, 400)
```

### 视图与性能

```scala
import scala.collection.View
import scala.util.Random

// 生成大型数据集
val largeData = List.fill(1000000)(Random.nextInt(100))

// 传统方式
def traditionalApproach(): List[Int] = {
  val start = System.nanoTime()
  
  val result = largeData
    .map(_ * 2)
    .filter(_ % 3 == 0)
    .map(_ * 10)
    .take(100)
  
  val end = System.nanoTime()
  println(s"Traditional approach: ${(end - start) / 1000000} ms")
  result
}

// 视图方式
def viewApproach(): List[Int] = {
  val start = System.nanoTime()
  
  val result = largeData
    .view
    .map(_ * 2)
    .filter(_ % 3 == 0)
    .map(_ * 10)
    .take(100)
    .toList
  
  val end = System.nanoTime()
  println(s"View approach: ${(end - start) / 1000000} ms")
  result
}

// 比较性能
val traditionalResult = traditionalApproach()
val viewResult = viewApproach()

println(s"Results match: ${traditionalResult == viewResult}")

// 内存使用情况
def memoryUsage[T](operation: => T): Unit = {
  val runtime = Runtime.getRuntime
  System.gc()  // 强制垃圾回收
  
  val beforeMemory = runtime.totalMemory - runtime.freeMemory
  val result = operation
  System.gc()  // 强制垃圾回收
  
  val afterMemory = runtime.totalMemory - runtime.freeMemory
  println(s"Memory used: ${(afterMemory - beforeMemory) / 1024 / 1024} MB")
}

println("Traditional approach memory usage:")
memoryUsage(traditionalApproach())

println("View approach memory usage:")
memoryUsage(viewApproach())
```

### 自定义视图

```scala
import scala.collection.View
import scala.collection.immutable.IndexedSeq
import scala.collection.IndexedSeqView

// 自定义视图
class FibonacciView extends IndexedSeqView[BigInt] {
  private def fib(n: Int): BigInt = {
    if (n <= 1) BigInt(n)
    else {
      @annotation.tailrec
      def loop(n: Int, a: BigInt, b: BigInt): BigInt = {
        if (n == 0) a
        else loop(n - 1, b, a + b)
      }
      loop(n, 0, 1)
    }
  }
  
  override def length: Int = Int.MaxValue  // 虚拟无限
  override def apply(idx: Int): BigInt = fib(idx)
  
  override def iterator: Iterator[BigInt] = new Iterator[BigInt] {
    private var a = BigInt(0)
    private var b = BigInt(1)
    private var index = 0
    
    override def hasNext: Boolean = true
    override def next(): BigInt = {
      if (index == 0) {
        index += 1
        a
      } else if (index == 1) {
        index += 1
        b
      } else {
        val next = a + b
        a = b
        b = next
        index += 1
        a
      }
    }
  }
  
  override def toString: String = "FibonacciView"
}

// 使用自定义视图
val fibonacci = new FibonacciView()

// 取前20个斐波那契数
val first20 = fibonacci.take(20).toList
println(s"First 20 Fibonacci numbers: $first20")

// 找出前10个3位数的斐波那契数
val threeDigits = fibonacci.filter(_.toString.length == 3).take(10).toList
println(s"First 10 three-digit Fibonacci numbers: $threeDigits")
```

## 5.9 集合与隐式转换

### 隐式转换增强集合

```scala
import scala.language.implicitConversions

// 自定义类型
class MyString(val s: String) {
  def isPalindrome: Boolean = s == s.reverse
  
  def wordCount: Int = s.split("\\s+").filter(_.nonEmpty).length
  
  def shout: String = s.toUpperCase + "!"
}

// 隐式转换
implicit def stringToMyString(s: String): MyString = new MyString(s)

// 使用隐式转换
val text = "hello world"
println(text.isPalindrome)  // false
println(text.wordCount)     // 2
println(text.shout)          // "HELLO WORLD!"

// 集合中使用隐式转换
val texts = List("hello", "world", "madam")
val palindromes = texts.filter(_.isPalindrome)
val wordsCount = texts.map(_.wordCount)
val shoutedTexts = texts.map(_.shout)

println(s"Palindromes: $palindromes")      // List("madam")
println(s"Word counts: $wordsCount")      // List(1, 1, 1)
println(s"Shouted texts: $shoutedTexts")  // List("HELLO!", "WORLD!", "MADAM!")

// 自定义数字类型
class RichInt(val value: Int) {
  def isPrime: Boolean = {
    if (value <= 1) false
    else if (value <= 3) true
    else if (value % 2 == 0 || value % 3 == 0) false
    else {
      @tailrec
      def check(i: Int): Boolean = {
        if (i * i > value) true
        else if (value % i == 0 || value % (i + 2) == 0) false
        else check(i + 6)
      }
      check(5)
    }
  }
  
  def factorial: BigInt = {
    @tailrec
    def loop(n: Int, acc: BigInt): BigInt = {
      if (n <= 1) acc
      else loop(n - 1, acc * n)
    }
    loop(value, 1)
  }
  
  def power(exponent: Int): BigInt = {
    @tailrec
    def loop(exp: Int, acc: BigInt): BigInt = {
      if (exp == 0) acc
      else if (exp % 2 == 0) loop(exp / 2, acc * acc)
      else loop(exp - 1, acc * value)
    }
    loop(exponent, 1)
  }
}

implicit def intToRichInt(x: Int): RichInt = new RichInt(x)

// 集合中使用增强数字类型
val numbers = (1 to 20).toList
val primes = numbers.filter(_.isPrime)
val factorials = numbers.map(_.factorial)
val powers = numbers.map(_.power(2))

println(s"Primes up to 20: $primes")
println(s"Factorials: ${factorials.take(10)}")
println(s"Squares: ${powers.take(10)}")
```

### 隐式类和集合操作

```scala
import scala.language.implicitConversions

// 隐式类增强集合
implicit class RichSeqOps[A](seq: Seq[A]) {
  def rotate(n: Int): Seq[A] = {
    val len = seq.length
    if (len == 0) seq
    else {
      val shift = ((n % len) + len) % len  // 处理负数和大于长度的情况
      seq.drop(shift) ++ seq.take(shift)
    }
  }
  
  def shuffle: Seq[A] = scala.util.Random.shuffle(seq)
  
  def groupByConsecutive(predicate: (A, A) => Boolean): Seq[Seq[A]] = {
    if (seq.isEmpty) Seq.empty
    else {
      @tailrec
      def loop(remaining: Seq[A], current: Seq[A], result: Seq[Seq[A]]): Seq[Seq[A]] = {
        if (remaining.isEmpty) result :+ current
        else if (current.isEmpty || predicate(current.last, remaining.head)) {
          loop(remaining.tail, current :+ remaining.head, result)
        } else {
          loop(remaining.tail, Seq(remaining.head), result :+ current)
        }
      }
      loop(seq.tail, Seq(seq.head), Seq.empty)
    }
  }
  
  def slidingPairs: Seq[(A, A)] = seq.sliding(2).map { case Seq(a, b) => (a, b) }.toSeq
}

// 使用增强的集合操作
val numbers = (1 to 10).toList
val rotated = numbers.rotate(3)
val rotatedNegative = numbers.rotate(-2)
val shuffled = numbers.shuffle

println(s"Original: $numbers")
println(s"Rotated by 3: $rotated")
println(s"Rotated by -2: $rotatedNegative")
println(s"Shuffled: $shuffled")

// 连续数字分组
val grouped = numbers.groupByConsecutive((a, b) => a + 1 == b)
println(s"Consecutive groups: $grouped")

// 滑动对
val pairs = numbers.slidingPairs
println(s"Sliding pairs: $pairs")

// 隐式类增强Map
implicit class RichMapOps[K, V](map: Map[K, V]) {
  def mapKeys[L](f: K => L): Map[L, V] = map.map { case (k, v) => (f(k), v) }
  
  def mapValues[W](f: V => W): Map[K, W] = map.map { case (k, v) => (k, f(v)) }
  
  def getOrThrow(key: K): V = map.getOrElse(key, throw new NoSuchElementException(s"Key not found: $key"))
  
  def pickRandom: Option[(K, V)] = {
    if (map.isEmpty) None
    else Some(map.toSeq(scala.util.Random.nextInt(map.size)))
  }
}

// 使用增强的Map操作
val capitals = Map(
  "USA" -> "Washington D.C.",
  "France" -> "Paris",
  "Japan" -> "Tokyo",
  "Germany" -> "Berlin"
)

val countryCodes = capitals.mapKeys(_.toUpperCase)
val cityLengths = capitals.mapValues(_.length)

println(s"Country codes: $countryCodes")
println(s"City name lengths: $cityLengths")
println(s"Random capital: ${capitals.pickRandom.getOrElse(("None", "None"))}")
```

### 类型类与集合

```scala
// 定义类型类
trait Show[A] {
  def show(a: A): String
}

object Show {
  // 基本类型的实例
  implicit val intShow: Show[Int] = _.toString
  implicit val doubleShow: Show[Double] = d => f"$d%.2f"
  implicit val stringShow: Show[String] = s => s""""$s""""
  
  // 复合类型的实例
  implicit def optionShow[A](implicit ev: Show[A]): Show[Option[A]] = {
    case None => "None"
    case Some(a) => s"Some(${ev.show(a)})"
  }
  
  implicit def listShow[A](implicit ev: Show[A]): Show[List[A]] = 
    list => s"[${list.map(ev.show).mkString(", ")}]"
  
  implicit def mapShow[K, V](implicit 
    keyShow: Show[K], 
    valueShow: Show[V]
  ): Show[Map[K, V]] = 
    map => s"{${map.map { case (k, v) => s"${keyShow.show(k)} -> ${valueShow.show(v)}" }.mkString(", ")}}"
  
  // 便捷方法
  def show[A](a: A)(implicit ev: Show[A]): String = ev.show(a)
}

// 使用类型类
val int = 42
val double = 3.14159
val string = "hello"
val optionInt = Some(42)
val listInt = List(1, 2, 3)
val mapStringInt = Map("one" -> 1, "two" -> 2)

println(Show.show(int))          // 42
println(Show.show(double))       // 3.14
println(Show.show(string))      // "hello"
println(Show.show(optionInt))   // Some(42)
println(Show.show(listInt))     // [1, 2, 3]
println(Show.show(mapStringInt)) // {"one" -> 1, "two" -> 2}

// 集合中使用类型类
implicit class ShowOps[A](a: A) {
  def show(implicit ev: Show[A]): String = ev.show(a)
}

val data = List(42, 3.14, "hello", Some("world"))
val shown = data.map(_.show)
println(s"Shown data: $shown")

// 自定义类型的类型类实例
case class Person(name: String, age: Int)

object Person {
  implicit val personShow: Show[Person] = p => s"${p.name} (${p.age})"
}

val people = List(
  Person("Alice", 30),
  Person("Bob", 25),
  Person("Charlie", 35)
)

val shownPeople = people.map(_.show)
println(s"Shown people: $shownPeople")
```

## 5.10 集合最佳实践

### 选择合适的集合类型

```scala
// 1. 频繁头部操作 - 使用List
val frequentHeadOps = List(1, 2, 3, 4, 5)
val result1 = 0 :: frequentHeadOps  // 高效

// 2. 频繁尾部操作 - 使用ListBuffer
import scala.collection.mutable.ListBuffer
val frequentTailOps = ListBuffer(1, 2, 3, 4, 5)
frequentTailOps += 6  // 高效

// 3. 频繁随机访问 - 使用Vector
val randomAccess = Vector(1, 2, 3, 4, 5)
val element = randomAccess(3)  // 高效

// 4. 需要插入和删除 - 使用ArrayBuffer
import scala.collection.mutable.ArrayBuffer
val mutableArray = ArrayBuffer(1, 2, 3, 4, 5)
mutableArray.insert(2, 99)  // 中间插入
mutableArray.remove(3)      // 中间删除

// 5. 需要快速查找 - 使用Set
val fastLookup = Set(1, 2, 3, 4, 5)
val contains = fastLookup(3)  // 高效

// 6. 需要键值映射 - 使用Map
val keyMapping = Map("one" -> 1, "two" -> 2, "three" -> 3)
val value = keyMapping("two")  // 高效
```

### 性能优化建议

```scala
// 1. 避免不必要的集合创建
val data = (1 to 100000).toList

// 不好的做法
val badResult = data.map(_ * 2).filter(_ % 3 == 0).map(_ * 4).take(100)

// 更好的做法：使用视图
val betterResult = data.view
  .map(_ * 2)
  .filter(_ % 3 == 0)
  .map(_ * 4)
  .take(100)
  .toList

// 或者使用单一函数
val bestResult = data.collect {
  case x if (x * 2) % 3 == 0 => x * 8
}.take(100)

// 2. 使用适当的数据结构
val words = "hello world scala programming language".split(" ")

// 不好的做法：List.contains是O(n)
val badCheck = words.contains("scala")

// 好的做法：转换为Set.contains是O(1)
val goodCheck = words.toSet.contains("scala")

// 3. 并行处理大型数据集
val largeData = (1 to 10000000).toList
val serialSum = largeData.map(_ * 2).sum
val parallelSum = largeData.par.map(_ * 2).sum

// 4. 避免在循环中修改集合
val numbers = (1 to 100).toList

// 不好的做法：创建多个中间集合
var result1 = List.empty[Int]
for (n <- numbers) {
  result1 = result1 :+ n * 2
}

// 好的做法：使用高阶函数
val result2 = numbers.map(_ * 2)

// 5. 使用可变集合进行构建，然后转换为不可变集合
import scala.collection.mutable

def buildLargeList(size: Int): List[Int] = {
  val builder = mutable.ListBuffer[Int]()
  for (i <- 1 to size) {
    builder += i * i
  }
  builder.toList  // 转换为不可变集合
}

val largeList = buildLargeList(100000)
```

### 代码风格与可读性

```scala
// 1. 使用有意义的方法链
val data = (1 to 10).toList

// 可读性好的方法链
val processedData = data
  .filter(_ % 2 == 0)        // 过滤偶数
  .map(_ * 2)                // 乘以2
  .filter(_ > 5)             // 大于5
  .sorted                    // 排序

// 2. 使用模式匹配提高可读性
val pairs = List((1, "one"), (2, "two"), (3, "three"))

// 使用模式匹配处理元组
val strings = pairs.map {
  case (num, name) => s"$num -> $name"
}

// 3. 避免嵌套过深
val numbers = (1 to 100).toList

// 不好的做法：嵌套过深
val nestedResult = numbers.map(n => 
  if (n % 2 == 0) {
    if (n % 3 == 0) {
      n * 2
    } else {
      n * 3
    }
  } else {
    if (n % 5 == 0) {
      n * 5
    } else {
      n
    }
  }
)

// 好的做法：使用辅助函数
def processNumber(n: Int): Int = {
  if (n % 2 == 0) {
    if (n % 3 == 0) n * 2 else n * 3
  } else {
    if (n % 5 == 0) n * 5 else n
  }
}

val flatResult = numbers.map(processNumber)

// 4. 使用有意义的变量名
val evenNumbers = (1 to 20).filter(_ % 2 == 0)
val squares = evenNumbers.map(n => n * n)
val sumOfSquares = squares.sum

// 5. 注释复杂逻辑
// 计算从1到n的所有整数的平方和
def sumOfSquaresToN(n: Int): Int = {
  (1 to n).map(i => i * i).sum  // 先计算平方，再求和
}
```

### 错误处理与防御性编程

```scala
// 1. 使用Option处理可能的空集合
def findFirst[T](list: List[T])(predicate: T => Boolean): Option[T] = {
  list.find(predicate)
}

val emptyList = List.empty[Int]
val result = findFirst(emptyList)(_ > 5)  // 返回None，而不是抛出异常

// 2. 使用Either处理计算错误
def safeDivide(a: Int, b: Int): Either[String, Int] = {
  if (b == 0) Left("Division by zero")
  else Right(a / b)
}

val numbers = List((10, 2), (10, 0), (20, 5))
val results = numbers.map { case (a, b) => safeDivide(a, b) }
// List(Right(5), Left("Division by zero"), Right(4))

// 3. 使用Try处理可能抛出异常的操作
import scala.util.Try
import scala.util.Success
import scala.util.Failure

def parseInt(s: String): Try[Int] = {
  Try(s.toInt)
}

val strings = List("123", "abc", "456", "def")
val parsed = strings.map(parseInt)
// List(Success(123), Failure(NumberFormatException), Success(456), Failure(NumberFormatException))

// 4. 使用集合安全方法避免异常
val list = List(1, 2, 3)

// 不好的做法：可能抛出异常
// val first = list.head
// val second = list(1)

// 好的做法：使用安全方法
val safeFirst = list.headOption     // Option[Int]
val safeSecond = list.lift(1)       // Option[Int]
val safeNth = list.drop(1).headOption // 安全地获取第二个元素

// 5. 使用默认值处理空集合
def getFirstOrDefault[T](list: List[T], default: T): T = {
  list.headOption.getOrElse(default)
}

val empty = List.empty[Int]
val firstOrZero = getFirstOrDefault(empty, 0)  // 0
```

## 总结

本章深入探讨了Scala集合框架的各个方面，从集合类型层次结构到具体集合类型的使用，再到性能优化和最佳实践。Scala集合框架设计精良，提供了丰富的API，同时保持了高度的一致性。

关键点：
- Scala集合分为不可变集合和可变集合两大类
- 不同集合类型有不同的性能特征，应根据使用场景选择
- 高阶函数如map、filter、reduce等是集合操作的核心
- 并行集合可以提高大型数据集的处理性能
- 集合视图可以避免创建中间集合，提高内存效率
- 隐式转换和类型类可以增强集合的功能
- 选择合适的集合类型和操作方法是编写高效代码的关键

下一章将探讨Scala的模式匹配机制和正则表达式，这是Scala强大的模式匹配能力的核心组成部分。