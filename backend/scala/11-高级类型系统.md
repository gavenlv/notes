# 第11章：高级类型系统

Scala的类型系统是其最强大的特性之一，提供了许多其他语言没有的高级类型概念。本章将深入探讨Scala的高级类型系统，包括类型成员、路径依赖类型、抽象类型成员、高阶类型、类型类、Phantom类型等概念。

## 11.1 路径依赖类型

### 11.1.1 内部类与路径依赖

在Scala中，内部类的类型与外部类的实例相关联，这被称为路径依赖类型：

```scala
// 外部类
class OuterClass {
  // 内部类
  class InnerClass {
    def innerMethod(): String = "Inner method"
  }
  
  def createInner(): InnerClass = new InnerClass
}

// 路径依赖类型示例
object PathDependentTypes {
  def demonstrate(): Unit = {
    val outer1 = new OuterClass
    val outer2 = new OuterClass
    
    // 创建内部类实例
    val inner1 = outer1.createInner()
    val inner2 = outer1.createInner()
    val inner3 = outer2.createInner()
    
    // inner1和inner2的类型是 outer1.InnerClass
    // inner3的类型是 outer2.InnerClass
    
    // 这两个类型是不同的，即使它们有相同的结构
    // inner1: outer1.InnerClass
    // inner3: outer2.InnerClass
    
    // 下面的赋值是合法的，因为它们是相同的外部实例
    val sameOuterInner: outer1.InnerClass = inner2
    
    // 下面的赋值是不合法的，因为它们来自不同的外部实例
    // val diffOuterInner: outer1.InnerClass = inner3  // 编译错误
    
    println("Path dependent types demonstrated")
  }
}
```

### 11.1.2 类型投影

类型投影允许我们忽略路径依赖，只关注内部类型：

```scala
object TypeProjections {
  def demonstrate(): Unit = {
    val outer1 = new OuterClass
    val outer2 = new OuterClass
    
    val inner1 = outer1.createInner()
    val inner2 = outer2.createInner()
    
    // 使用类型投影 OuterClass#InnerClass
    // 这允许来自不同外部实例的内部类实例之间的赋值
    val projectedInner: OuterClass#InnerClass = inner1
    
    // 现在这个赋值是合法的
    val anotherProjectedInner: OuterClass#InnerClass = inner2
    
    println("Type projections demonstrated")
  }
}
```

### 11.1.3 抽象类型成员

抽象类型成员允许在抽象类或特质中定义类型，而不指定具体类型：

```scala
// 使用抽象类型成员的特质
trait Repository {
  // 抽象类型成员
  type ID
  type Entity
  
  // 使用这些类型的方法
  def findById(id: ID): Option[Entity]
  def save(entity: Entity): Entity
  def delete(id: ID): Boolean
}

// 具体实现
class UserRepository extends Repository {
  type ID = Long
  type Entity = User
  
  case class User(id: Long, name: String, email: String)
  
  private var users = Map[Long, User]()
  
  def findById(id: Long): Option[User] = users.get(id)
  
  def save(user: User): User = {
    users = users + (user.id -> user)
    user
  }
  
  def delete(id: Long): Boolean = {
    if (users.contains(id)) {
      users = users - id
      true
    } else {
      false
    }
  }
}

// 另一个实现
class BookRepository extends Repository {
  type ID = String  // ISBN作为ID
  type Entity = Book
  
  case class Book(isbn: String, title: String, author: String)
  
  private var books = Map[String, Book]()
  
  def findById(isbn: String): Option[Book] = books.get(isbn)
  
  def save(book: Book): Book = {
    books = books + (book.isbn -> book)
    book
  }
  
  def delete(isbn: String): Boolean = {
    if (books.contains(isbn)) {
      books = books - isbn
      true
    } else {
      false
    }
  }
}

// 使用抽象类型成员的函数
object AbstractTypeMembers {
  def addEntity[T <: Repository](repo: T, id: T#ID, entity: T#Entity): T#Entity = {
    repo.save(entity)
  }
  
  def demonstrate(): Unit = {
    val userRepo = new UserRepository
    val bookRepo = new BookRepository
    
    // 添加用户
    val user = userRepo.User(1L, "Alice", "alice@example.com")
    val savedUser = addEntity(userRepo, user.id, user)
    println(s"Saved user: $savedUser")
    
    // 添加图书
    val book = bookRepo.Book("978-3-16-148410-0", "Scala Programming", "Martin Odersky")
    val savedBook = addEntity(bookRepo, book.isbn, book)
    println(s"Saved book: $savedBook")
  }
}
```

## 11.2 高阶类型（Higher-Kinded Types）

### 11.2.1 类型构造器

类型构造器是指需要类型参数才能形成具体类型的类型：

```scala
// 普通类型（零阶类型）
type IntType = Int
type StringType = String

// 一阶类型构造器（需要一个类型参数形成具体类型）
type ListOfString = List[String]
type MapIntToString = Map[Int, String]

// 二阶类型构造器（需要一个类型构造器参数形成具体类型）
trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}

// Functor实现
object ListFunctor extends Functor[List] {
  def map[A, B](fa: List[A])(f: A => B): List[B] = fa.map(f)
}

object OptionFunctor extends Functor[Option] {
  def map[A, B](fa: Option[A])(f: A => B): Option[B] = fa.map(f)
}

// 使用Functor
def processWithFunctor[F[_], A, B](container: F[A], f: A => B)
                                (implicit functor: Functor[F]): F[B] = {
  functor.map(container)(f)
}

// 高阶类型示例
object HigherKindedTypes {
  def demonstrate(): Unit = {
    val numbers = List(1, 2, 3, 4, 5)
    val squared = processWithFunctor(numbers, (x: Int) => x * x)
    println(s"Squared numbers: $squared")
    
    val maybeNumber: Option[Int] = Some(42)
    val maybeSquared = processWithFunctor(maybeNumber, (x: Int) => x * x)
    println(s"Maybe squared: $maybeSquared")
  }
}
```

### 11.2.2 高阶类型约束

```scala
// 类型类，表示容器类型可以被遍历
trait Traverse[F[_]] {
  def traverse[G[_], A, B](fa: F[A])(f: A => G[B])
                         (implicit applicative: Applicative[G]): G[F[B]]
}

// Applicative类型类
trait Applicative[F[_]] extends Functor[F] {
  def pure[A](a: A): F[A]
  def ap[A, B](ff: F[A => B])(fa: F[A]): F[B]
  
  // 从Functor继承的map实现
  def map[A, B](fa: F[A])(f: A => B): F[B] = ap(pure(f))(fa)
}

// List的Traverse实现
object ListTraverse extends Traverse[List] {
  def traverse[G[_], A, B](fa: List[A])(f: A => G[B])
                          (implicit applicative: Applicative[G]): G[List[B]] = {
    fa.foldRight(applicative.pure(List.empty[B])) { (a, acc) =>
      applicative.map2(f(a), acc)(_ :: _)
    }
  }
}

// 高阶类型约束的函数
def sequence[F[_], G[_], A](fga: F[G[A]])
                           (implicit traverse: Traverse[F], 
                                     applicative: Applicative[G]): G[F[A]] = {
  traverse.traverse(fga)(identity)
}

// 使用示例
object HigherKindedConstraints {
  def demonstrate(): Unit = {
    // 使用Option作为G，List作为F
    val maybeNumbers: List[Option[Int]] = List(Some(1), Some(2), None, Some(4))
    
    // 将List[Option[Int]]转换为Option[List[Int]]
    val maybeList: Option[List[Int]] = sequence(maybeNumbers)
    println(s"Sequenced result: $maybeList")
    
    // 使用List作为G，Option作为F
    val listMaybe: Option[List[Int]] = Some(List(1, 2, 3, 4))
    
    // 将Option[List[Int]]转换为List[Option[Int]]
    val listMaybes: List[Option[Int]] = sequence(listMaybe)
    println(s"Reversed sequence result: $listMaybes")
  }
}
```

## 11.3 类型类（Type Classes）

### 11.3.1 基本类型类

类型类是一种将功能添加到现有数据类型的方式，而无需修改这些类型的定义：

```scala
// 定义一个可比较的类型类
trait Equal[T] {
  def equal(x: T, y: T): Boolean
}

// 为Int类型提供Equal实例
object EqualInstances {
  implicit val intEqual: Equal[Int] = new Equal[Int] {
    def equal(x: Int, y: Int): Boolean = x == y
  }
  
  implicit val stringEqual: Equal[String] = new Equal[String] {
    def equal(x: String, y: String): Boolean = x == y
  }
  
  implicit def listEqual[T](implicit equalT: Equal[T]): Equal[List[T]] = new Equal[List[T]] {
    def equal(x: List[T], y: List[T]): Boolean = {
      if (x.length != y.length) false
      else x.zip(y).forall { case (a, b) => equalT.equal(a, b) }
    }
  }
  
  implicit def optionEqual[T](implicit equalT: Equal[T]): Equal[Option[T]] = new Equal[Option[T]] {
    def equal(x: Option[T], y: Option[T]): Boolean = (x, y) match {
      case (None, None) => true
      case (Some(a), Some(b)) => equalT.equal(a, b)
      case _ => false
    }
  }
}

// 使用类型类的函数
object TypeClassUsage {
  // 使用隐式参数
  def checkEqual[T](x: T, y: T)(implicit equal: Equal[T]): Boolean = {
    equal.equal(x, y)
  }
  
  // 使用上下文界定
  def checkEqualContext[T: Equal](x: T, y: T): Boolean = {
    implicitly[Equal[T]].equal(x, y)
  }
  
  // 扩展方法语法
  implicit class EqualOps[T](x: T)(implicit equal: Equal[T]) {
    def ===(y: T): Boolean = equal.equal(x, y)
  }
  
  def demonstrate(): Unit = {
    import EqualInstances._
    
    // 使用隐式参数
    println(s"5 === 3: ${checkEqual(5, 3)}")
    println(s"5 === 5: ${checkEqual(5, 5)}")
    
    // 使用上下文界定
    println(s"\"hello\" === \"world\": ${checkEqualContext("hello", "world")}")
    println(s"\"hello\" === \"hello\": ${checkEqualContext("hello", "hello")}")
    
    // 使用扩展方法语法
    println(s"5 === 5: ${5 === 5}")
    println(s"List(1,2,3) === List(1,2,3): ${List(1, 2, 3) === List(1, 2, 3)}")
    println(s"List(1,2,3) === List(1,2,4): ${List(1, 2, 3) === List(1, 2, 4)}")
    println(s"Some(5) === Some(5): ${Some(5) === Some(5)}")
    println(s"Some(5) === None: ${Some(5) === None}")
  }
}
```

### 11.3.2 高级类型类模式

```scala
// Monoid类型类：表示一个有结合律和单位元的操作
trait Monoid[T] {
  def empty: T
  def combine(x: T, y: T): T
}

// Monoid实例
object MonoidInstances {
  implicit val intAdditionMonoid: Monoid[Int] = new Monoid[Int] {
    def empty: Int = 0
    def combine(x: Int, y: Int): Int = x + y
  }
  
  implicit val intMultiplicationMonoid: Monoid[Int] = new Monoid[Int] {
    def empty: Int = 1
    def combine(x: Int, y: Int): Int = x * y
  }
  
  implicit val stringMonoid: Monoid[String] = new Monoid[String] {
    def empty: String = ""
    def combine(x: String, y: String): String = x + y
  }
  
  implicit def listMonoid[T]: Monoid[List[T]] = new Monoid[List[T]] {
    def empty: List[T] = List.empty
    def combine(x: List[T], y: List[T]): List[T] = x ::: y
  }
  
  implicit def optionMonoid[T](implicit monoidT: Monoid[T]): Monoid[Option[T]] = new Monoid[Option[T]] {
    def empty: Option[T] = None
    def combine(x: Option[T], y: Option[T]): Option[T] = (x, y) match {
      case (None, None) => None
      case (Some(a), None) => Some(a)
      case (None, Some(b)) => Some(b)
      case (Some(a), Some(b)) => Some(monoidT.combine(a, b))
    }
  }
}

// 使用Monoid的函数
object MonoidUsage {
  import MonoidInstances._
  
  // 组合列表中的所有元素
  def combineAll[T](list: List[T])(implicit monoid: Monoid[T]): T = {
    list.foldLeft(monoid.empty)(monoid.combine)
  }
  
  // 组合两个Option值
  def combineOptions[T](opt1: Option[T], opt2: Option[T])(implicit monoid: Monoid[T]): Option[T] = {
    implicitly[Monoid[Option[T]]].combine(opt1, opt2)
  }
  
  def demonstrate(): Unit = {
    // 使用Int加法Monoid
    println(s"Sum of List(1,2,3,4,5): ${combineAll(List(1, 2, 3, 4, 5))}")
    
    // 使用Int乘法Monoid（需要显式指定）
    val multiplicationMonoid = MonoidInstances.intMultiplicationMonoid
    println(s"Product of List(1,2,3,4,5): ${combineAll(List(1, 2, 3, 4, 5))(multiplicationMonoid)}")
    
    // 使用String Monoid
    println(s"Concatenation of List(\"Hello\", \" \", \"World\"): ${combineAll(List("Hello", " ", "World"))}")
    
    // 使用List Monoid
    println(s"Concatenation of List(List(1,2), List(3,4), List(5)): ${combineAll(List(List(1, 2), List(3, 4), List(5)))}")
    
    // 使用Option Monoid
    println(s"Combine Some(5) and Some(3): ${combineOptions(Some(5), Some(3))}")
    println(s"Combine Some(5) and None: ${combineOptions(Some(5), None)}")
    println(s"Combine None and None: ${combineOptions(None, None)}")
  }
}
```

### 11.3.3 串联类型类（Type Class Composition）

```scala
// Show类型类：表示类型可以被转换为字符串
trait Show[T] {
  def show(value: T): String
}

// Show实例
object ShowInstances {
  implicit val intShow: Show[Int] = new Show[Int] {
    def show(value: Int): String = s"Int($value)"
  }
  
  implicit val stringShow: Show[String] = new Show[String] {
    def show(value: String): String = s"String($value)"
  }
  
  implicit def optionShow[T](implicit showT: Show[T]): Show[Option[T]] = new Show[Option[T]] {
    def show(value: Option[T]): String = value match {
      case None => "None"
      case Some(a) => s"Some(${showT.show(a)})"
    }
  }
  
  implicit def listShow[T](implicit showT: Show[T]): Show[List[T]] = new Show[List[T]] {
    def show(value: List[T]): String = {
      val elements = value.map(showT.show).mkString(", ")
      s"List($elements)"
    }
  }
}

// 同时使用Equal和Show的类型类
trait EqualShow[T] {
  val equal: Equal[T]
  val show: Show[T]
  
  def showEquality(x: T, y: T): String = {
    val eq = if (equal.equal(x, y)) "==" else "!="
    s"${show.show(x)} $eq ${show.show(y)}"
  }
}

// EqualShow实例
object EqualShowInstances {
  implicit def intEqualShow(implicit 
    intEqual: Equal[Int], 
    intShow: Show[Int]): EqualShow[Int] = new EqualShow[Int] {
    val equal = intEqual
    val show = intShow
  }
  
  implicit def optionEqualShow[T](implicit 
    equalT: Equal[T], 
    showT: Show[T],
    optionEqual: Equal[Option[T]],
    optionShow: Show[Option[T]]): EqualShow[Option[T]] = new EqualShow[Option[T]] {
    val equal = optionEqual
    val show = optionShow
  }
}

object TypeClassComposition {
  import EqualInstances._
  import ShowInstances._
  import EqualShowInstances._
  
  def demonstrate(): Unit = {
    // 使用EqualShow
    println(s"5 and 3: ${implicitly[EqualShow[Int]].showEquality(5, 3)}")
    println(s"5 and 5: ${implicitly[EqualShow[Int]].showEquality(5, 5)}")
    
    println(s"Some(5) and Some(5): ${implicitly[EqualShow[Option[Int]]].showEquality(Some(5), Some(5))}")
    println(s"Some(5) and None: ${implicitly[EqualShow[Option[Int]]].showEquality(Some(5), None)}")
  }
}
```

## 11.4 高级类型操作

### 11.4.1 类型成员与类型投影

```scala
// 包含类型成员的特质
trait Container {
  type Content
  def content: Content
}

// 具体实现
class StringContainer(val content: String) extends Container {
  type Content = String
}

class IntContainer(val content: Int) extends Container {
  type Content = Int
}

// 使用类型投影
object TypeMembers {
  // 获取容器内容的函数
  def getContent(c: Container): c.Content = c.content
  
  // 使用类型投影创建通用的容器操作
  def containersEqual(c1: Container, c2: Container): Boolean = {
    (c1.content, c2.content) match {
      case (x: String, y: String) => x == y
      case (x: Int, y: Int) => x == y
      case _ => false
    }
  }
  
  // 更通用的类型相等比较
  def containersEqualWithType[T](c1: Container { type Content = T }, 
                                 c2: Container { type Content = T })
                                 (implicit equal: Equal[T]): Boolean = {
    equal.equal(c1.content, c2.content)
  }
  
  def demonstrate(): Unit = {
    val stringContainer = new StringContainer("hello")
    val intContainer = new IntContainer(42)
    val anotherStringContainer = new StringContainer("world")
    val equalStringContainer = new StringContainer("hello")
    
    println(s"String container content: ${getContent(stringContainer)}")
    println(s"Int container content: ${getContent(intContainer)}")
    
    // 比较不同类型内容的容器
    println(s"String containers equal: ${containersEqual(stringContainer, anotherStringContainer)}")
    println(s"Equal string containers equal: ${containersEqual(stringContainer, equalStringContainer)}")
    
    // 使用更通用的比较
    import EqualInstances.intEqual
    println(s"Equal int containers equal: ${containersEqualWithType(intContainer, intContainer)}")
  }
}
```

### 11.4.2 依赖方法类型

依赖方法类型允许方法的返回类型依赖于参数的值：

```scala
// 使用依赖方法类型的特质
trait Factory {
  type Product
  def create(): Product
}

// 具体实现
class CarFactory extends Factory {
  type Product = Car
  
  case class Car(make: String, model: String)
  
  def create(): Car = Car("Toyota", "Camry")
}

class BikeFactory extends Factory {
  type Product = Bike
  
  case class Bike(brand: String, gears: Int)
  
  def create(): Bike = Bike("Giant", 21)
}

// 使用依赖方法类型的函数
object DependentMethodTypes {
  def createAndUse(f: Factory): f.Product = {
    val product = f.create()
    println(s"Created product of type: ${product.getClass.getSimpleName}")
    product
  }
  
  def demonstrate(): Unit = {
    val carFactory = new CarFactory
    val bikeFactory = new BikeFactory
    
    val car = createAndUse(carFactory)
    val bike = createAndUse(bikeFactory)
    
    println(s"Car: $car")
    println(s"Bike: $bike")
  }
}
```

### 11.4.3 存在类型（Existential Types）

存在类型允许我们忽略某些类型参数的具体信息：

```scala
// 使用存在类型的示例
object ExistentialTypes {
  // 存在类型：一个包含某种类型元素的容器，但我们不知道具体类型
  def processContainer(container: Container forSome { type Content }): String = {
    container.content match {
      case s: String => s"String content: $s"
      case i: Int => s"Int content: $i"
      case _ => s"Unknown content: ${container.content}"
    }
  }
  
  // 使用类型投影的等效写法
  def processContainerAlt(container: Container): String = {
    processContainer(container)
  }
  
  // 处理任意类型的列表
  def processList(list: List[_]): String = {
    val types = list.map(_.getClass.getSimpleName).mkString(", ")
    s"List with elements of types: $types"
  }
  
  // 使用存在类型变量
  def extractFirst[T](list: List[T]): T = list.head
  
  def demonstrate(): Unit = {
    val stringContainer = new StringContainer("hello world")
    val intContainer = new IntContainer(42)
    
    println(processContainer(stringContainer))
    println(processContainer(intContainer))
    
    val mixedList = List("hello", 42, true, 3.14)
    println(processList(mixedList))
    
    val intList = List(1, 2, 3, 4, 5)
    val firstElement = extractFirst(intList)
    println(s"First element of int list: $firstElement")
  }
}
```

## 11.5 Phantom类型（幻影类型）

Phantom类型是指在运行时不存在的类型参数，只在编译时提供类型安全：

```scala
// 使用Phantom类型表示状态
sealed trait FileState
trait Closed extends FileState
trait Open extends FileState
trait Reading extends FileState
trait Writing extends FileState

// 带有Phantom类型的文件类
class File[S <: FileState] private (private val path: String, private var handle: Option[Any]) {
  // 文件打开操作，从Closed状态变为Open状态
  def open(implicit ev: S =:= Closed): File[Open] = {
    // 模拟打开文件
    println(s"Opening file: $path")
    val handle = s"handle for $path"  // 实际应用中是真实的文件句柄
    new File(path, Some(handle)).asInstanceOf[File[Open]]
  }
  
  // 文件关闭操作，从Open状态变为Closed状态
  def close(implicit ev: S =:= Open): File[Closed] = {
    // 模拟关闭文件
    println(s"Closing file: $path")
    handle = None
    this.asInstanceOf[File[Closed]]
  }
  
  // 文件读取操作，从Open状态变为Reading状态
  def read(implicit ev: S =:= Open): (File[Reading], String) = {
    // 模拟读取文件
    println(s"Reading from file: $path")
    val content = s"Content of $path"
    (new File(path, handle).asInstanceOf[File[Reading]], content)
  }
  
  // 文件写入操作，从Open状态变为Writing状态
  def write(content: String)(implicit ev: S =:= Open): File[Writing] = {
    // 模拟写入文件
    println(s"Writing to file: $path: $content")
    new File(path, handle).asInstanceOf[File[Writing]]
  }
  
  // 完成读取操作，返回到Open状态
  def doneReading(implicit ev: S =:= Reading): File[Open] = {
    println(s"Finished reading from file: $path")
    this.asInstanceOf[File[Open]]
  }
  
  // 完成写入操作，返回到Open状态
  def doneWriting(implicit ev: S =:= Writing): File[Open] = {
    println(s"Finished writing to file: $path")
    this.asInstanceOf[File[Open]]
  }
}

// 伴生对象提供工厂方法
object File {
  def apply(path: String): File[Closed] = new File(path, None)
}

// 使用Phantom类型的示例
object PhantomTypes {
  def fileOperations(): Unit = {
    // 创建一个关闭的文件
    val closedFile = File("/tmp/example.txt")
    println(s"Created closed file")
    
    // 打开文件
    val openFile = closedFile.open()
    println(s"Opened file")
    
    // 读取文件
    val (readingFile, content) = openFile.read()
    println(s"Read content: $content")
    
    // 完成读取
    val openFileAgain = readingFile.doneReading()
    
    // 写入文件
    val writingFile = openFileAgain.write("New content")
    
    // 完成写入
    val openFileFinal = writingFile.doneWriting()
    
    // 关闭文件
    val closedFileFinal = openFileFinal.close()
    println(s"Closed file")
    
    // 下面的代码会导致编译错误，因为类型不匹配：
    // val error = closedFile.read()  // 编译错误：File[Closed]不能read
    
    // 这提供了编译时的状态安全性
    println("File operations completed safely with phantom types")
  }
  
  def demonstrate(): Unit = {
    fileOperations()
  }
}
```

## 11.6 类型级编程

### 11.6.1 类型级自然数

使用类型和类型类在类型级别表示自然数：

```scala
// 类型级自然数的表示
sealed trait Nat {
  type Plus[M <: Nat] <: Nat
}

// 零
final class _0 extends Nat {
  type Plus[M <: Nat] = M
}

// 后继
final class Succ[N <: Nat] extends Nat {
  type Plus[M <: Nat] = Succ[N#Plus[M]]
}

// 类型别名，便于使用
type _1 = Succ[_0]
type _2 = Succ[_1]
type _3 = Succ[_2]
type _4 = Succ[_3]
type _5 = Succ[_4]

// 类型类：将类型级自然数转换为值级自然数
trait ToValue[N <: Nat] {
  def value: Int
}

// ToValue实例
object ToValueInstances {
  implicit val zeroToValue: ToValue[_0] = new ToValue[_0] {
    def value: Int = 0
  }
  
  implicit def succToValue[N <: Nat](implicit toValueN: ToValue[N]): ToValue[Succ[N]] = 
    new ToValue[Succ[N]] {
      def value: Int = 1 + toValueN.value
    }
}

// 类型级加法的结果类型
trait Plus[N <: Nat, M <: Nat] {
  type Out <: Nat
}

// Plus实例
object PlusInstances {
  implicit def plusZero[M <: Nat]: Plus[_0, M] = new Plus[_0, M] {
    type Out = M
  }
  
  implicit def plusSucc[N <: Nat, M <: Nat, PM <: Nat]
    (implicit pm: Plus[N, M]): Plus[Succ[N], M] = 
    new Plus[Succ[N], M] {
      type Out = Succ[pm.Out]
    }
}

// 类型级乘法的结果类型
trait Times[N <: Nat, M <: Nat] {
  type Out <: Nat
}

// Times实例
object TimesInstances {
  implicit def timesZero[M <: Nat]: Times[_0, M] = new Times[_0, M] {
    type Out = _0
  }
  
  implicit def timesSucc[N <: Nat, M <: Nat, TM <: Nat]
    (implicit tm: Times[N, M]): Times[Succ[N], M] = 
    new Times[Succ[N], M] {
      type Out = M#Plus[tm.Out]
    }
}

object TypeLevelNumbers {
  // 将类型级自然数转换为值
  def toValue[N <: Nat](implicit toValue: ToValue[N]): Int = toValue.value
  
  // 类型级加法
  type Plus[N <: Nat, M <: Nat] = N#Plus[M]
  
  // 类型级乘法
  def typeLevelAddition(): Unit = {
    // 类型1 + 2 = 3
    type OnePlusTwo = Plus[_1, _2]  // 结果是 Succ[Succ[Succ[_0]]] 即 _3
    
    // 验证类型级计算结果
    val three = toValue[_3]  // 3
    val onePlusTwoValue = toValue[OnePlusTwo]  // 也应该是3
    
    println(s"Value of _3: $three")
    println(s"Value of _1 + _2: $onePlusTwoValue")
    println(s"Type-level addition works: ${three == onePlusTwoValue}")
  }
  
  def typeLevelMultiplication(): Unit = {
    // 类型2 * 3 = 6
    type TwoTimesThree = Times[_2, _3]#Out  // 结果应该是 _6
    
    // _6的定义
    type _6 = Succ[_5]
    
    val six = toValue[_6]  // 6
    val twoTimesThreeValue = toValue[TwoTimesThree]  // 也应该是6
    
    println(s"Value of _6: $six")
    println(s"Value of _2 * _3: $twoTimesThreeValue")
    println(s"Type-level multiplication works: ${six == twoTimesThreeValue}")
  }
  
  def demonstrate(): Unit = {
    typeLevelAddition()
    typeLevelMultiplication()
  }
}
```

### 11.6.2 类型级布尔运算

```scala
// 类型级布尔值
sealed trait Bool {
  type Not <: Bool
  type And[That <: Bool] <: Bool
  type Or[That <: Bool] <: Bool
}

// 真
final class True extends Bool {
  type Not = False
  type And[That <: Bool] = That
  type Or[That <: Bool] = True
}

// 假
final class False extends Bool {
  type Not = True
  type And[That <: Bool] = False
  type Or[That <: Bool] = That
}

// 类型类：将类型级布尔转换为值
trait ToBool[B <: Bool] {
  def value: Boolean
}

// ToBool实例
object ToBoolInstances {
  implicit val trueToBool: ToBool[True] = new ToBool[True] {
    def value: Boolean = true
  }
  
  implicit val falseToBool: ToBool[False] = new ToBool[False] {
    def value: Boolean = false
  }
}

object TypeLevelBooleans {
  def toBool[B <: Bool](implicit toBool: ToBool[B]): Boolean = toBool.value
  
  // 类型级NOT
  type Not[B <: Bool] = B#Not
  
  // 类型级AND
  type And[A <: Bool, B <: Bool] = A#And[B]
  
  // 类型级OR
  type Or[A <: Bool, B <: Bool] = A#Or[B]
  
  def typeLevelBooleanOps(): Unit = {
    // Not[True] = False
    val notTrue = toBool[Not[True]]
    
    // Not[False] = True
    val notFalse = toBool[Not[False]]
    
    // And[True, False] = False
    val trueAndFalse = toBool[And[True, False]]
    
    // And[True, True] = True
    val trueAndTrue = toBool[And[True, True]]
    
    // Or[True, False] = True
    val trueOrFalse = toBool[Or[True, False]]
    
    // Or[False, False] = False
    val falseOrFalse = toBool[Or[False, False]]
    
    println(s"NOT True: $notTrue")
    println(s"NOT False: $notFalse")
    println(s"True AND False: $trueAndFalse")
    println(s"True AND True: $trueAndTrue")
    println(s"True OR False: $trueOrFalse")
    println(s"False OR False: $falseOrFalse")
  }
  
  def demonstrate(): Unit = {
    typeLevelBooleanOps()
  }
}
```

## 11.7 类型约束验证

### 11.7.1 编译时验证

```scala
// 类型级验证：检查类型列表是否包含特定类型
sealed trait Contains[L, T]

object Contains {
  implicit def containsHead[H, T <: HList, Type](implicit ev: H =:= Type): Contains[H :: T, Type] = 
    new Contains[H :: T, Type] {}
  
  implicit def containsTail[H, T <: HList, Type](implicit ev: Contains[T, Type]): Contains[H :: T, Type] = 
    new Contains[H :: T, Type] {}
}

// HList (异构列表)的简化定义
sealed trait HList
final case class HCons[H, T <: HList](head: H, tail: T) extends HList
final case class HNil() extends HList

// 类型约束验证
object TypeConstraintValidation {
  // 验证函数，如果编译通过则表示约束满足
  def validateContains[L, T](implicit ev: Contains[L, T]): Unit = {}
  
  // 验证类型列表Int :: String :: Boolean :: HNil是否包含String
  type TestList = Int :: String :: Boolean :: HNil
  
  // 下面这行应该编译通过，因为TestList包含String
  // validateContains[TestList, String]
  
  // 下面这行会导致编译错误，因为TestList不包含Double
  // validateContains[TestList, Double]
  
  def demonstrate(): Unit = {
    println("Type constraint validation examples (see commented code)")
  }
}
```

### 11.7.2 Shapeless库简介

Shapeless是一个提供通用编程和类型级编程功能的Scala库：

```scala
// 注意：下面的代码需要添加Shapeless依赖才能编译和运行
// libraryDependencies += "com.chuusai" %% "shapeless" % "2.3.9"

/*
import shapeless._
import shapeless.ops.hlist._

// 使用Shapeless进行类型级编程
object ShapelessExamples {
  // HList操作
  def hlistOperations(): Unit = {
    val hlist = 23 :: "hello" :: true :: HNil
    
    // 获取HList的第1个元素（索引从0开始）
    val first = hlist.head
    println(s"First element: $first")  // 23
    
    // 获取HList的第2个元素
    val second = hlist(1)
    println(s"Second element: $second")  // "hello"
    
    // 添加元素到HList
    val extended = 3.14 :: hlist
    println(s"Extended HList: $extended")  // 3.14 :: 23 :: "hello" :: true :: HNil
    
    // 映射HList中的每个元素
    val doubled = hlist.map {
      case i: Int => i * 2
      case s: String => s * 2
      case b: Boolean => !b
    }
    println(s"Doubled HList: $doubled")  // 46 :: "hellohello" :: false :: HNil
  }
  
  // Generic和HList之间的转换
  case class Person(name: String, age: Int, isStudent: Boolean)
  
  def genericConversion(): Unit = {
    val person = Person("Alice", 25, true)
    
    // 将case class转换为HList
    val generic = Generic[Person].to(person)
    println(s"Person as HList: $generic")  // "Alice" :: 25 :: true :: HNil
    
    // 从HList创建case class
    val newPerson = Generic[Person].from("Bob" :: 30 :: false :: HNil)
    println(s"New person: $newPerson")  // Person("Bob", 30, false)
  }
  
  // 记录类型（类型安全的键值对）
  def recordTypes(): Unit = {
    val record = ('name ->> "Alice") :: ('age ->> 25) :: HNil
    
    // 通过键获取值
    val name = record.get('name)
    println(s"Name from record: $name")  // "Alice"
    
    val age = record.get('age)
    println(s"Age from record: $age")  // 25
    
    // 更新记录中的值
    val updated = record.updateWith('age)(_ + 5)
    val updatedAge = updated.get('age)
    println(s"Updated age: $updatedAge")  // 30
  }
  
  // 类型级编程示例：检查HList是否包含特定类型
  def containsType(): Unit = {
    val hlist = 23 :: "hello" :: true :: HNil
    
    // 检查HList是否包含Int类型
    val containsInt = implicitly[Contains[hlist.type, Int]]
    println(s"HList contains Int: $containsInt")  // 某个实例对象
    
    // 检查HList是否包含String类型
    val containsString = implicitly[Contains[hlist.type, String]]
    println(s"HList contains String: $containsString")  // 某个实例对象
    
    // 下面的代码会导致编译错误，因为HList不包含Double类型
    // val containsDouble = implicitly[Contains[hlist.type, Double]]
  }
  
  def demonstrate(): Unit = {
    hlistOperations()
    genericConversion()
    recordTypes()
    containsType()
  }
}
*/

object ShapelessIntroduction {
  def demonstrate(): Unit = {
    println("Shapeless library provides advanced type-level programming capabilities.")
    println("See commented code for examples of:")
    println("- HList operations")
    println("- Generic and case class conversion")
    println("- Record types")
    println("- Type-level programming")
    println("To run these examples, add Shapeless dependency to your build.sbt:")
    println("""libraryDependencies += "com.chuusai" %% "shapeless" % "2.3.9"""")
  }
}
```

## 11.8 高级类型系统应用

### 11.8.1 状态机类型安全

```scala
// 使用类型构建类型安全的状态机
sealed trait DoorState
trait Closed extends DoorState
trait Open extends DoorState
trait Locked extends DoorState

// 带状态的门类
class Door[S <: DoorState] private () {
  // 开门操作
  def open(implicit ev: S =:= Closed): Door[Open] = {
    println("Opening door")
    new Door[Open]()
  }
  
  // 关门操作
  def close(implicit ev: S =:= Open): Door[Closed] = {
    println("Closing door")
    new Door[Closed]()
  }
  
  // 锁门操作
  def lock(implicit ev: S =:= Closed): Door[Locked] = {
    println("Locking door")
    new Door[Locked]()
  }
  
  // 解锁操作
  def unlock(implicit ev: S =:= Locked): Door[Closed] = {
    println("Unlocking door")
    new Door[Closed]()
  }
}

// 伴生对象
object Door {
  def apply(): Door[Closed] = new Door[Closed]()
}

object TypeSafeStateMachine {
  def demonstrate(): Unit = {
    // 创建一个关闭的门
    val closedDoor = Door()
    
    // 关门 -> 开门
    val openDoor = closedDoor.open()
    
    // 开门 -> 关门
    val closedAgain = openDoor.close()
    
    // 关门 -> 锁门
    val lockedDoor = closedAgain.lock()
    
    // 锁门 -> 解锁
    val unlockedDoor = lockedDoor.unlock()
    
    // 下面的代码会导致编译错误，因为状态不匹配：
    // val error = closedDoor.open().close().open().open()  // 开门状态不能再次开门
    // val error2 = lockedDoor.close()  // 锁门状态不能直接关门，必须先解锁
    
    println("State machine operations completed successfully with type safety")
  }
}
```

### 11.8.2 依赖类型注入

```scala
// 使用类型实现的依赖注入容器
trait Service {
  type Dependency
  def dependency: Dependency
}

// 具体服务实现
class DatabaseService extends Service {
  type Dependency = Database
  
  case class Database(url: String, username: String, password: String)
  
  def dependency: Database = Database("jdbc:mysql://localhost/db", "user", "pass")
}

class CacheService extends Service {
  type Dependency = Cache
  
  case class Cache(host: String, port: Int)
  
  def dependency: Cache = Cache("localhost", 6379)
}

// 服务容器
class ServiceContainer {
  private val services = scala.collection.mutable.Map[Class[_], Any]()
  
  def register[S <: Service](service: S): Unit = {
    services(service.getClass) = service
  }
  
  def getDependency[S <: Service](serviceClass: Class[S]): S#Dependency = {
    services(serviceClass).asInstanceOf[S].dependency
  }
}

object DependentTypeInjection {
  def demonstrate(): Unit = {
    val container = new ServiceContainer()
    
    // 注册服务
    val dbService = new DatabaseService()
    val cacheService = new CacheService()
    
    container.register(dbService)
    container.register(cacheService)
    
    // 获取依赖
    val dbDependency = container.getDependency(classOf[DatabaseService])
    val cacheDependency = container.getDependency(classOf[CacheService])
    
    println(s"Database dependency: $dbDependency")
    println(s"Cache dependency: $cacheDependency")
  }
}
```

## 总结

Scala的高级类型系统提供了强大的类型安全保障和编程抽象能力：

1. **路径依赖类型**：允许类型依赖于值，提供了细粒度的类型控制
2. **高阶类型**：支持类型构造器，是构建类型类和抽象的基础
3. **类型类**：提供了不修改类型定义而扩展类型功能的方式
4. **Phantom类型**：在编译时提供状态和安全性验证
5. **类型级编程**：允许在类型级别执行计算，提供了编译时的保证

这些高级类型特性使Scala能够构建高度类型安全、表达力强且可维护的代码。通过掌握这些概念，开发者可以利用Scala的类型系统来防止运行时错误，并创建更加灵活和可扩展的抽象。

下一章将探讨Scala中的宏与元编程，这是另一个强大的代码生成和代码转换机制。