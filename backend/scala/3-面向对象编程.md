# 第3章 面向对象编程

## 目录
- [3.1 类的定义与实例化](#31-类的定义与实例化)
- [3.2 构造器](#32-构造器)
- [3.3 成员访问控制](#33-成员访问控制)
- [3.4 对象](#34-对象)
- [3.5 继承](#35-继承)
- [3.6 抽象类](#36-抽象类)
- [3.7 特质（Trait）](#37-特质trait)
- [3.8 包与导入](#38-包与导入)
- [3.9 样例类（Case Class）](#39-样例类case-class)
- [3.10 最佳实践](#310-最佳实践)

## 3.1 类的定义与实例化

### 基本类定义

在Scala中，类是对象的模板，定义了对象的属性和行为：

```scala
// 基本类定义
class Person {
  // 字段（属性）
  var name: String = "Unknown"
  var age: Int = 0
  
  // 方法
  def greet(): String = s"Hello, I'm $name and I'm $age years old"
  
  // 带参数的方法
  def celebrateBirthday(): Unit = {
    age += 1
    println(s"Happy birthday! Now I'm $age years old")
  }
}

// 创建类的实例（对象）
val person = new Person()
person.name = "Alice"
person.age = 30
println(person.greet())
person.celebrateBirthday()
```

### 类参数

Scala类可以直接在类名后定义参数，这些参数会被自动转换为字段：

```scala
// 带参数的类
class Student(name: String, age: Int, major: String) {
  // 可以在类内部访问参数
  def introduce(): String = s"I'm $name, $age years old, studying $major"
  
  def study(hours: Int): String = s"$name is studying $major for $hours hours"
}

// 创建实例时必须提供参数
val student = new Student("Bob", 20, "Computer Science")
println(student.introduce())
println(student.study(3))
```

### val/var参数

类参数可以使用`val`或`var`修饰，控制它们的可变性：

```scala
// 使用val和var定义类参数
class Employee(val id: Int, var name: String, var department: String) {
  // val参数自动生成公共只读字段
  // var参数自动生成公共读写字段
  
  def promote(newDepartment: String): Unit = {
    department = newDepartment
    println(s"$name has been promoted to $department")
  }
  
  override def toString: String = s"Employee(id=$id, name=$name, department=$department)"
}

val emp = new Employee(1001, "Carol", "Engineering")
println(emp.id)      // 可以访问val字段
// emp.id = 1002     // 编译错误：val字段不可修改

emp.name = "Carol Smith"  // 可以修改var字段
println(emp.name)
```

### 私有字段

使用`private`修饰符可以定义私有字段：

```scala
class BankAccount(initialBalance: Double) {
  // 私有字段，外部无法直接访问
  private var balance = initialBalance
  
  // 公共方法提供受控访问
  def currentBalance: Double = balance
  
  def deposit(amount: Double): Unit = {
    if (amount > 0) {
      balance += amount
      println(s"Deposited $amount. New balance: $balance")
    } else {
      println("Deposit amount must be positive")
    }
  }
  
  def withdraw(amount: Double): Unit = {
    if (amount > 0 && amount <= balance) {
      balance -= amount
      println(s"Withdrew $amount. New balance: $balance")
    } else {
      println("Invalid withdrawal amount")
    }
  }
}

val account = new BankAccount(1000.0)
// account.balance = 2000  // 编译错误：balance是私有的
account.deposit(500)
account.withdraw(200)
println(s"Current balance: ${account.currentBalance}")
```

## 3.2 构造器

### 主构造器

Scala的主构造器与类定义交织在一起，类参数就是主构造器的参数：

```scala
class Coffee(name: String, price: Double, isDecaf: Boolean) {
  // 主构造器体
  println(s"Creating a coffee: $name")
  
  // 字段初始化
  val description: String = if (isDecaf) s"Decaf $name" else name
  var prepared = false
  
  // 方法
  def prepare(): Unit = {
    prepared = true
    println(s"Your $description is ready. Price: $$${price}")
  }
}

// 创建实例时会执行主构造器
val latte = new Coffee("Latte", 4.5, false)
latte.prepare()
```

### 辅助构造器

类可以有多个辅助构造器，使用`this`定义：

```scala
class Pizza(var crustType: String, var toppings: List[String]) {
  // 辅助构造器1：使用默认浇头
  def this(crustType: String) = {
    this(crustType, List("cheese", "tomato sauce"))
  }
  
  // 辅助构造器2：使用默认饼底和浇头
  def this() = {
    this("thin crust")
  }
  
  def addTopping(topping: String): Unit = {
    toppings = topping :: toppings
  }
  
  override def toString: String = s"$crustType pizza with ${toppings.mkString(", ")}"
}

// 使用不同构造器创建实例
val pizza1 = new Pizza("thick crust", List("cheese", "pepperoni"))
val pizza2 = new Pizza("thin crust")  // 使用辅助构造器1
val pizza3 = new Pizza()             // 使用辅助构造器2

println(pizza1)
println(pizza2)
println(pizza3)

pizza2.addTopping("mushrooms")
println(pizza2)
```

### 私有构造器

可以定义私有主构造器，限制类的实例化：

```scala
class Singleton private() {
  def sayHello(): Unit = println("Hello from Singleton!")
}

object Singleton {
  private val instance = new Singleton()
  
  def getInstance(): Singleton = instance
}

// 直接创建实例会出错
// val s = new Singleton()  // 编译错误

// 通过伴生对象获取实例
val s = Singleton.getInstance()
s.sayHello()
```

## 3.3 成员访问控制

### 访问修饰符

Scala提供三种访问修饰符：`public`（默认）、`private`和`protected`：

```scala
class AccessControl {
  // 公共成员（默认，可以省略public关键字）
  val publicField = "I am public"
  def publicMethod(): String = "Public method"
  
  // 私有成员（仅类内部可见）
  private val privateField = "I am private"
  private def privateMethod(): String = "Private method"
  
  // 受保护成员（类及其子类可见）
  protected val protectedField = "I am protected"
  protected def protectedMethod(): String = "Protected method"
  
  // 作用域私有（仅在同一作用域内可见）
  private[AccessControl] val scopedField = "Scoped private"
  
  // 内部使用私有成员
  def usePrivateMembers(): String = {
    privateField + privateMethod()
  }
  
  // 内部使用受保护成员
  def useProtectedMembers(): String = {
    protectedField + protectedMethod()
  }
}

class Child extends AccessControl {
  // 子类可以访问受保护成员
  def useParentProtected(): String = {
    protectedField + protectedMethod()
  }
  
  // 子类不能访问私有成员
  // def useParentPrivate(): String = privateField  // 编译错误
}

val parent = new AccessControl()
println(parent.publicField)      // 可访问
// println(parent.privateField)  // 编译错误
// println(parent.protectedField) // 编译错误

val child = new Child()
println(child.useParentProtected())  // 可访问
```

### getter和setter

Scala自动为公共字段生成getter和setter方法：

```scala
class Person {
  private var _name: String = ""  // 私有字段，使用下划线约定
  private var _age: Int = 0
  
  // 自定义getter
  def name: String = _name
  
  // 自定义setter
  def name_=(newName: String): Unit = {
    if (newName.nonEmpty) _name = newName
  }
  
  // 自定义getter
  def age: Int = _age
  
  // 自定义setter带验证
  def age_=(newAge: Int): Unit = {
    if (newAge >= 0 && newAge <= 120) _age = newAge
    else throw new IllegalArgumentException("Invalid age")
  }
}

val person = new Person()
person.name = "Alice"  // 调用name_=方法
person.age = 30       // 调用age_=方法

println(person.name)  // 调用name方法
println(person.age)   // 调用age方法

// 以下会抛出异常
// person.age = 150  // IllegalArgumentException
```

### Bean属性

为了与Java框架兼容，Scala提供了`@BeanProperty`注解：

```scala
import scala.beans.BeanProperty

class JavaCompatible {
  @BeanProperty var name: String = ""
  @BeanProperty var age: Int = 0
}

val bean = new JavaCompatible()
// Scala风格的访问
bean.name = "Scala"
bean.age = 25

// Java风格的访问（适用于框架）
bean.setName("Java Bean")
bean.setAge(30)

println(s"Name: ${bean.getName}, Age: ${bean.getAge}")
```

## 3.4 对象

### 单例对象

使用`object`关键字定义单例对象，类似于Java中的静态类：

```scala
object MathUtils {
  // 单例对象可以包含字段和方法
  val PI = 3.141592653589793
  
  def add(a: Int, b: Int): Int = a + b
  def multiply(a: Int, b: Int): Int = a * b
  def power(base: Int, exp: Int): Double = math.pow(base, exp)
  
  // 单例对象也可以有主构造器
  println("MathUtils singleton initialized")
}

// 使用单例对象
println(s"PI value: ${MathUtils.PI}")
println(s"5 + 3 = ${MathUtils.add(5, 3)}")
println(s"5 * 3 = ${MathUtils.multiply(5, 3)}")
println(s"2^10 = ${MathUtils.power(2, 10)}")
```

### 伴生对象

当对象和类在同一个源文件中且名称相同时，它们互为伴生：

```scala
class BankAccount private(private var balance: Double) {
  def deposit(amount: Double): Unit = {
    if (amount > 0) balance += amount
  }
  
  def withdraw(amount: Double): Unit = {
    if (amount > 0 && amount <= balance) balance -= amount
  }
  
  def currentBalance: Double = balance
  
  override def toString: String = s"Balance: $$${balance}"
}

// 伴生对象可以访问类的私有成员
object BankAccount {
  // 工厂方法
  def apply(initialBalance: Double): BankAccount = {
    new BankAccount(initialBalance)
  }
  
  // 创建特殊类型的账户
  def empty(): BankAccount = {
    new BankAccount(0.0)
  }
  
  def withMinimumBalance(minimum: Double): BankAccount = {
    new BankAccount(minimum)
  }
}

// 使用伴生对象的工厂方法创建实例
val account1 = BankAccount(1000.0)        // 调用apply方法
val account2 = BankAccount.empty()        // 调用empty方法
val account3 = BankAccount.withMinimumBalance(500.0)  // 调用withMinimumBalance方法

println(account1)
println(account2)
println(account3)

account1.deposit(200)
account2.withdraw(100)
println(account1)
println(account2)
```

### 应用程序对象

带有`main`方法的对象可以作为程序的入口点：

```scala
object HelloWorldApp {
  def main(args: Array[String]): Unit = {
    println("Hello, Scala Application!")
    
    if (args.nonEmpty) {
      println("Arguments provided:")
      args.foreach(println)
    } else {
      println("No arguments provided")
    }
  }
}

// 也可以继承App特质，更简洁
object SimpleApp extends App {
  println("Simple application using App trait")
  
  // args数组自动可用
  if (args.nonEmpty) {
    println("Arguments provided:")
    args.foreach(println)
  }
}
```

## 3.5 继承

### 基本继承

Scala使用`extends`关键字实现继承：

```scala
// 父类（超类）
class Animal(val name: String, val age: Int) {
  def speak(): String = "Some sound"
  
  def eat(): Unit = println(s"$name is eating")
  
  override def toString: String = s"$name ($age years old)"
}

// 子类
class Dog(name: String, age: Int, val breed: String) extends Animal(name, age) {
  // 重写方法
  override def speak(): String = "Woof! Woof!"
  
  // 新方法
  def fetch(): Unit = println(s"$name is fetching the ball")
  
  override def toString: String = s"${super.toString} - $breed breed"
}

// 另一个子类
class Cat(name: String, age: Int, val isIndoor: Boolean) extends Animal(name, age) {
  override def speak(): String = "Meow!"
  
  def scratch(): Unit = println(s"$name is scratching")
  
  override def toString: String = s"${super.toString} - Indoor: $isIndoor"
}

val dog = new Dog("Buddy", 3, "Golden Retriever")
val cat = new Cat("Whiskers", 5, true)

println(dog)
println(dog.speak())
dog.fetch()
dog.eat()

println(cat)
println(cat.speak())
cat.scratch()
cat.eat()
```

### 调用父类构造器

子类可以在其构造器中调用父类的构造器：

```scala
class Vehicle(val brand: String, val model: String, val year: Int) {
  def start(): Unit = println(s"$brand $model is starting")
  
  def stop(): Unit = println(s"$brand $model is stopping")
  
  override def toString: String = s"$year $brand $model"
}

class Car(brand: String, model: String, year: Int, 
          val numDoors: Int, val fuelType: String) 
     extends Vehicle(brand, model, year) {
  
  override def start(): Unit = {
    super.start()  // 调用父类方法
    println(s"Engine running on $fuelType")
  }
  
  def honk(): Unit = println("Beep beep!")
  
  override def toString: String = s"${super.toString} - $numDoors doors, $fuelType"
}

class Motorcycle(brand: String, model: String, year: Int, 
                val hasStorage: Boolean) 
     extends Vehicle(brand, model, year) {
  
  override def start(): Unit = {
    println(s"Kick-starting $brand $model")
    super.start()
  }
  
  def wheelie(): Unit = println("Doing a wheelie!")
  
  override def toString: String = s"${super.toString} - Storage: $hasStorage"
}

val car = new Car("Toyota", "Corolla", 2020, 4, "gasoline")
val motorcycle = new Motorcycle("Harley-Davidson", "Street Glide", 2019, true)

println(car)
car.start()
car.honk()

println(motorcycle)
motorcycle.start()
motorcycle.wheelie()
```

### 类型检查与转换

```scala
class Animal
class Dog extends Animal
class Cat extends Animal
class Bird extends Animal

val dog = new Dog
val cat = new Cat
val bird = new Bird

val animals: List[Animal] = List(dog, cat, bird)

// 类型检查
for (animal <- animals) {
  animal match {
    case d: Dog => println("Found a dog!")
    case c: Cat => println("Found a cat!")
    case b: Bird => println("Found a bird!")
    case _ => println("Unknown animal")
  }
}

// 类型转换
val animal: Animal = new Dog

// 安全转换（使用isInstanceOf和asInstanceOf）
if (animal.isInstanceOf[Dog]) {
  val specificDog = animal.asInstanceOf[Dog]
  println("Safely converted to Dog")
}

// 使用模式匹配进行安全转换
animal match {
  case d: Dog => println("Pattern matched a dog")
  case c: Cat => println("Pattern matched a cat")
  case _ => println("Pattern matched something else")
}
```

### final关键字

使用`final`防止类被继承或方法被重写：

```scala
// final类不能被继承
final class FinalClass {
  def message(): String = "I cannot be extended"
}

// final方法不能被重写
class Parent {
  final def cannotOverride(): String = "This method cannot be overridden"
  
  def canOverride(): String = "This method can be overridden"
}

class Child extends Parent {
  // 以下方法重写会导致编译错误
  // override def cannotOverride(): String = "Trying to override"
  
  override def canOverride(): String = "Successfully overridden"
}
```

## 3.6 抽象类

### 抽象类定义

使用`abstract`关键字定义抽象类，可以包含抽象方法和字段：

```scala
// 抽象类
abstract class Shape {
  // 抽象字段（没有初始值）
  def area: Double
  def perimeter: Double
  
  // 具体方法
  def describe(): String = s"This shape has area $area and perimeter $perimeter"
  
  // 抽象方法
  def draw(): Unit
}

// 具体子类
class Circle(val radius: Double) extends Shape {
  // 实现抽象字段
  def area: Double = Math.PI * radius * radius
  def perimeter: Double = 2 * Math.PI * radius
  
  // 实现抽象方法
  def draw(): Unit = println(s"Drawing a circle with radius $radius")
  
  override def describe(): String = s"Circle - ${super.describe()}"
}

class Rectangle(val width: Double, val height: Double) extends Shape {
  def area: Double = width * height
  def perimeter: Double = 2 * (width + height)
  
  def draw(): Unit = println(s"Drawing a rectangle $width by $height")
  
  override def describe(): String = s"Rectangle - ${super.describe()}"
}

class Triangle(val base: Double, val height: Double, val sideA: Double, val sideB: Double) extends Shape {
  def area: Double = 0.5 * base * height
  def perimeter: Double = base + sideA + sideB
  
  def draw(): Unit = println(s"Drawing a triangle with base $base and height $height")
  
  override def describe(): String = s"Triangle - ${super.describe()}"
}

val shapes: List[Shape] = List(
  new Circle(5.0),
  new Rectangle(4.0, 6.0),
  new Triangle(3.0, 4.0, 5.0, 4.0)
)

shapes.foreach { shape =>
  println(shape.describe())
  shape.draw()
}
```

### 抽象类型成员

抽象类可以定义抽象类型成员：

```scala
abstract class Container {
  // 抽象类型成员
  type A
  
  // 抽象方法使用抽象类型
  def put(element: A): Unit
  def get(): Option[A]
}

class StringContainer extends Container {
  // 具体化抽象类型
  type A = String
  
  private var content: Option[String] = None
  
  def put(element: String): Unit = {
    content = Some(element)
  }
  
  def get(): Option[String] = content
}

class IntContainer extends Container {
  type A = Int
  
  private var content: Option[Int] = None
  
  def put(element: Int): Unit = {
    content = Some(element)
  }
  
  def get(): Option[Int] = content
}

val strContainer = new StringContainer()
strContainer.put("Hello")
println(strContainer.get())

val intContainer = new IntContainer()
intContainer.put(42)
println(intContainer.get())
```

## 3.7 特质（Trait）

### 特质定义与使用

特质类似于Java中的接口，但更强大，可以包含具体实现：

```scala
// 定义特质
trait Swimmer {
  // 抽象方法
  def swim(): Unit
  
  // 具体方法
  def dive(): Unit = println("Diving deep!")
  
  // 字段
  val maxDepth: Int = 100
}

// 定义另一个特质
trait Flyer {
  def fly(): Unit
  
  def takeOff(): Unit = println("Taking off")
  def land(): Unit = println("Landing")
}

// 类可以混入多个特质
class Duck extends Swimmer with Flyer {
  // 实现Swimmer的抽象方法
  def swim(): Unit = println("Swimming like a duck")
  
  // 实现Flyer的抽象方法
  def fly(): Unit = println("Flying like a duck")
  
  def quack(): Unit = println("Quack!")
}

val duck = new Duck()
duck.swim()
duck.dive()
duck.fly()
duck.takeOff()
duck.land()
duck.quack()
```

### 特质构造

特质也可以有构造器，执行顺序有特定规则：

```scala
trait Logger {
  println("Logger trait constructor")
  
  def log(message: String): Unit = println(s"LOG: $message")
}

trait TimestampLogger extends Logger {
  println("TimestampLogger trait constructor")
  
  override def log(message: String): Unit = {
    val timestamp = java.time.Instant.now()
    super.log(s"[$timestamp] $message")
  }
}

class Service extends TimestampLogger {
  println("Service class constructor")
  
  def serve(): Unit = {
    log("Service started")
    println("Service is working...")
    log("Service completed")
  }
}

// 构造顺序：
// 1. 父类构造器
// 2. 特质构造器（从左到右）
// 3. 子类构造器
val service = new Service()
service.serve()
```

### 特质中的具体字段

```scala
trait Validator {
  // 具体字段
  val minLength = 6
  val maxLength = 20
  
  // 抽象字段
  def value: String
  
  // 使用字段的方法
  def validate(): Boolean = {
    value.length >= minLength && value.length <= maxLength
  }
  
  def validationMessage(): String = {
    if (validate()) "Valid"
    else s"Invalid: length must be between $minLength and $maxLength"
  }
}

class Username(val username: String) extends Validator {
  def value: String = username
}

class Password(val password: String) extends Validator {
  def value: String = password
  
  // 重写特质的字段
  override val minLength = 8
  
  override def validationMessage(): String = {
    if (validate()) "Valid password"
    else s"Invalid password: must be at least $minLength characters long"
  }
}

val username = new Username("john_doe")
println(s"Username: ${username.validationMessage()}")

val password = new Password("secret123")
println(s"Password: ${password.validationMessage()}")

val shortPassword = new Password("123")
println(s"Short password: ${shortPassword.validationMessage()}")
```

### 特质中的自身类型

```scala
trait Logged {
  def log(message: String): Unit
}

trait Timestamped {
  def now: java.time.Instant = java.time.Instant.now()
}

trait TimestampLogger extends Logged with Timestamped {
  override def log(message: String): Unit = {
    super.log(s"[${now}] $message")
  }
}

// 自身类型
trait SelfTypeExample { self: Logged =>
  def importantAction(): Unit = {
    log("Starting important action")
    // 执行操作
    log("Finished important action")
  }
}

class ConsoleLogger extends Logged {
  def log(message: String): Unit = println(message)
}

class Service extends ConsoleLogger with SelfTypeExample {
  def execute(): Unit = {
    importantAction()
  }
}

val service = new Service()
service.execute()
```

### 可堆叠特质修改

```scala
trait IntQueue {
  def get(): Int
  def put(x: Int): Unit
}

class BasicIntQueue extends IntQueue {
  private val buf = new scala.collection.mutable.Queue[Int]()
  
  def get(): Int = buf.dequeue()
  def put(x: Int): Unit = buf.enqueue(x)
}

// 可堆叠特质1
trait Doubling extends IntQueue {
  abstract override def put(x: Int): Unit = {
    super.put(2 * x)
  }
}

// 可堆叠特质2
trait Incrementing extends IntQueue {
  abstract override def put(x: Int): Unit = {
    super.put(x + 1)
  }
}

// 可堆叠特质3
trait Filtering extends IntQueue {
  abstract override def put(x: Int): Unit = {
    if (x >= 0) super.put(x)
  }
}

// 基础队列
val queue1 = new BasicIntQueue
queue1.put(10)
queue1.put(20)
println(queue1.get())  // 10
println(queue1.get())  // 20

// 堆叠不同特质
val queue2 = new BasicIntQueue with Incrementing with Filtering
queue2.put(-1)
queue2.put(0)
queue2.put(1)
println(queue2.get())  // 1 (0+1)
println(queue2.get())  // 2 (1+1)

val queue3 = new BasicIntQueue with Doubling with Incrementing with Filtering
queue3.put(-1)
queue3.put(0)
queue3.put(1)
println(queue3.get())  // 2 ((0+1)*2)
println(queue3.get())  // 4 ((1+1)*2)
```

## 3.8 包与导入

### 包定义

Scala使用包来组织代码，类似于Java：

```scala
// 定义包
package com.example.shapes

abstract class Shape {
  def area: Double
  def perimeter: Double
}

package com.example.shapes.circle {
  class Circle(val radius: Double) extends Shape {
    def area: Double = Math.PI * radius * radius
    def perimeter: Double = 2 * Math.PI * radius
  }
}

package com.example.shapes.rectangle {
  class Rectangle(val width: Double, val height: Double) extends Shape {
    def area: Double = width * height
    def perimeter: Double = 2 * (width + height)
  }
}
```

### 包对象

包对象可以包含在整个包中共享的方法和常量：

```scala
// 包对象
package com.example.utils

package object geometry {
  val PI = 3.141592653589793
  
  def degreesToRadians(degrees: Double): Double = degrees * PI / 180.0
  
  def radiansToDegrees(radians: Double): Double = radians * 180.0 / PI
}

// 使用包对象中的成员
package com.example.geometry

import com.example.utils.geometry._

class Angle(val degrees: Double) {
  def radians: Double = degreesToRadians(degrees)
  
  def toDegrees(rad: Double): Double = radiansToDegrees(rad)
  
  def +(other: Angle): Angle = new Angle(degrees + other.degrees)
}

val angle1 = new Angle(90.0)
val angle2 = new Angle(45.0)
val sum = angle1 + angle2

println(s"90 degrees in radians: ${angle1.radians}")
println(s"Sum of angles: ${sum.degrees} degrees")
```

### 导入语句

Scala提供灵活的导入机制：

```scala
// 导入单个成员
import scala.collection.mutable.ListBuffer

// 导入多个成员
import scala.collection.{mutable, immutable}

// 导入包的所有成员（通常不推荐）
import scala.collection.mutable._

// 重命名导入
import java.util.{HashMap => JavaHashMap}

// 隐藏某些成员
import scala.collection.mutable.{Map => _, _}  // 导入除Map外的所有成员

// 相对导入
package com.example {
  package shapes {
    class Circle
  }
  
  package drawing {
    // 可以使用相对路径导入
    import shapes.Circle
    
    class Drawing {
      def draw(): Unit = println("Drawing a circle")
    }
  }
}

// 导入示例
object ImportExample {
  def main(args: Array[String]): Unit = {
    // 使用导入的类
    val list = new ListBuffer[Int]()
    list += 1
    list += 2
    println(list)
    
    // 使用重命名的类
    val javaMap = new JavaHashMap[String, String]()
    javaMap.put("key", "value")
    println(javaMap)
  }
}
```

## 3.9 样例类（Case Class）

### 基本样例类

样例类是特殊的类，主要用于不可变数据：

```scala
// 定义样例类
case class Person(name: String, age: Int, email: String)

// 创建实例（不需要new关键字）
val person1 = Person("Alice", 30, "alice@example.com")
val person2 = Person("Bob", 25, "bob@example.com")

// 自动生成的toString
println(person1)  // Person(Alice,30,alice@example.com)

// 自动生成的equals方法
val person3 = Person("Alice", 30, "alice@example.com")
println(person1 == person3)  // true
println(person1 == person2)  // false

// 自动生成的hashCode方法
println(person1.hashCode() == person3.hashCode())  // true

// 自动生成的copy方法
val olderPerson = person1.copy(age = person1.age + 1)
println(olderPerson)  // Person(Alice,31,alice@example.com)

// 解构
val Person(name, age, email) = person1
println(s"Name: $name, Age: $age, Email: $email")

// 在模式匹配中使用
def describePerson(person: Person): String = {
  person match {
    case Person("Alice", _, _) => "It's Alice!"
    case Person(name, age, _) if age < 18 => s"$name is a minor"
    case Person(name, age, email) => s"$name, $age years old, can be reached at $email"
  }
}

println(describePerson(person1))
println(describePerson(Person("Charlie", 16, "charlie@example.com")))
```

### 样例对象

样例对象是单例对象的特殊形式，常用于枚举或消息传递：

```scala
// 定义样例对象
sealed trait Message
case class TextMessage(content: String) extends Message
case class ImageMessage(url: String, caption: String) extends Message
case object ShutdownMessage extends Message

def processMessage(message: Message): Unit = {
  message match {
    case TextMessage(content) => println(s"Text: $content")
    case ImageMessage(url, caption) => println(s"Image: $url ($caption)")
    case ShutdownMessage => println("Shutting down...")
  }
}

processMessage(TextMessage("Hello, world!"))
processMessage(ImageMessage("http://example.com/image.jpg", "A cat"))
processMessage(ShutdownMessage)
```

### 样例类的高级用法

```scala
// 嵌套样例类
case class Address(street: String, city: String, zipCode: String)
case class Person(name: String, age: Int, address: Address)

val address = Address("123 Main St", "Anytown", "12345")
val person = Person("John Doe", 35, address)

// 深度解构
val Person(name, age, Address(street, city, zipCode)) = person
println(s"$name lives at $street in $city ($zipCode)")

// 嵌套模式匹配
def describePerson(person: Person): String = {
  person match {
    case Person("Alice", _, Address(_, "New York", _)) => 
      "Alice from New York"
    case Person(_, age, Address(_, city, _)) if age >= 65 => 
      s"Senior citizen from $city"
    case Person(name, age, address) => 
      s"$name, $age years old, from ${address.city}"
  }
}

println(describePerson(person))
println(describePerson(Person("Alice", 30, Address("456 Oak Ave", "New York", "10001"))))
println(describePerson(Person("Bob", 70, Address("789 Pine St", "Boston", "02101"))))

// 样例类作为函数参数
def updatePersonAge(person: Person, newAge: Int): Person = {
  person.copy(age = newAge)
}

val updatedPerson = updatePersonAge(person, 36)
println(updatedPerson)
```

### 样例类的限制

```scala
// 样例类参数默认是val，不可变
case class ImmutablePerson(name: String, age: Int)

// 如果需要可变性，必须显式声明为var
case class MutablePerson(name: String, var age: Int)

val mutable = MutablePerson("Sam", 25)
mutable.age = 26  // 可以修改
println(mutable)

// 样例类不能被继承
// case class Parent(name: String)
// case class Child(name: String, age: Int) extends Parent(name)  // 编译错误

// 但是样例类可以继承其他类或特质
trait Printable {
  def print(): Unit
}

case class Document(title: String, content: String) extends Printable {
  def print(): Unit = println(s"Document: $title\n$content")
}

val doc = Document("Scala Guide", "Scala is a powerful language")
doc.print()
```

## 3.10 最佳实践

### 何时使用类与对象

```scala
// 使用类创建多个实例
class Counter(var count: Int = 0) {
  def increment(): Unit = count += 1
  def decrement(): Unit = count -= 1
  def current(): Int = count
}

val counter1 = new Counter()
val counter2 = new Counter(10)

// 使用对象表示单例
object Config {
  private val properties = scala.collection.mutable.Map[String, String]()
  
  def set(key: String, value: String): Unit = {
    properties(key) = value
  }
  
  def get(key: String): Option[String] = {
    properties.get(key)
  }
}

Config.set("app.name", "MyApp")
println(Config.get("app.name"))
```

### 特质与抽象类的选择

```scala
// 使用特质：多个不相关的类需要相同行为
trait Serializable {
  def serialize(): String
}

trait Comparable {
  def compare(other: Any): Int
}

class Product(val name: String, val price: Double) extends Serializable with Comparable {
  def serialize(): String = s"$name:$price"
  
  def compare(other: Any): Int = other match {
    case p: Product => price.compareTo(p.price)
    case _ => -1
  }
}

// 使用抽象类：类之间存在明确的"是一个"关系，且需要共享代码
abstract class Animal(val name: String) {
  def speak(): String
  def eat(): Unit = println(s"$name is eating")  // 共享实现
  
  def sleep(): Unit = println(s"$name is sleeping")  // 共享实现
}

class Dog(name: String) extends Animal(name) {
  def speak(): String = "Woof!"
}
```

### 封装的最佳实践

```scala
class BankAccount(private var _balance: Double) {
  // 提供受控的访问
  def balance: Double = _balance
  
  def deposit(amount: Double): Either[String, Unit] = {
    if (amount <= 0) {
      Left("Deposit amount must be positive")
    } else {
      _balance += amount
      Right(())
    }
  }
  
  def withdraw(amount: Double): Either[String, Unit] = {
    if (amount <= 0) {
      Left("Withdrawal amount must be positive")
    } else if (amount > _balance) {
      Left("Insufficient funds")
    } else {
      _balance -= amount
      Right(())
    }
  }
}

// 使用Either处理可能的错误情况
val account = new BankAccount(100.0)
account.deposit(50.0) match {
  case Right(_) => println("Deposit successful")
  case Left(error) => println(s"Deposit failed: $error")
}

account.withdraw(200.0) match {
  case Right(_) => println("Withdrawal successful")
  case Left(error) => println(s"Withdrawal failed: $error")
}
```

### 不变性的偏好

```scala
// 优先使用不可变数据结构
case class Point(x: Double, y: Double) {
  def move(dx: Double, dy: Double): Point = {
    Point(x + dx, y + dy)  // 返回新实例而不是修改现有实例
  }
  
  def distanceTo(other: Point): Double = {
    val dx = x - other.x
    val dy = y - other.y
    Math.sqrt(dx * dx + dy * dy)
  }
}

val p1 = Point(0.0, 0.0)
val p2 = p1.move(3.0, 4.0)  // p1保持不变，p2是新实例

println(s"Original point: $p1")
println(s"Moved point: $p2")
println(s"Distance: ${p1.distanceTo(p2)}")
```

## 总结

本章深入探讨了Scala的面向对象编程特性，包括类、对象、继承、抽象类和特质等概念。Scala的面向对象特性结合了传统面向对象编程和函数式编程的优点，提供了强大的代码组织和复用机制。

关键点：
- Scala中类和对象的概念及其应用场景
- 继承和多态的实现方式
- 抽象类和特质的使用方法及区别
- 样例类和样例对象的特殊用途
- 合理的访问控制和封装策略
- 面向对象编程的最佳实践

下一章将深入探讨Scala的函数式编程特性，包括高阶函数、函数组合、纯函数等概念。