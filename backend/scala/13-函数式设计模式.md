# 第13章：函数式设计模式

设计模式是软件设计中常见问题的典型解决方案。虽然设计模式最初是为面向对象编程设计的，但许多模式在函数式编程中有不同的实现方式和应用场景。本章将探讨常见的函数式设计模式，以及如何在Scala中应用它们。

## 13.1 函数式编程中的设计模式概述

### 13.1.1 面向对象模式与函数式模式的对比

面向对象设计模式通常关注对象之间的交互和关系，而函数式设计模式更关注函数组合、数据流和不可变性。一些传统的面向对象模式在函数式编程中可能会消失或简化，同时也会出现一些新的模式。

### 13.1.2 Scala中的函数式设计模式

Scala作为一种混合范式语言，既有面向对象的特性，又有函数式编程的特性，因此可以灵活地应用两种范式的设计模式。在本章中，我们将探讨以下函数式设计模式：

1. 高阶函数模式
2. 不可变集合模式
3. 函数组合器模式
4. 类型类模式
5. 单子（Monoid）模式
6. 函子（Functor）和单子（Monad）模式
7. 模式匹配与访问者模式
8. 惰性求值模式
9. 代数数据类型模式
10. 依赖注入的函数式实现

## 13.2 高阶函数模式

### 13.2.1 柯里化（Currying）

柯里化是一种将多参数函数转换为一系列单参数函数的技术，这在函数式编程中是一种基础模式：

```scala
object CurryingPattern {
  // 多参数函数
  def add(x: Int, y: Int): Int = x + y
  
  // 柯里化版本
  def addCurried(x: Int): Int => Int = y => x + y
  
  // 使用Scala的柯里化语法
  def addCurriedSyntax(x: Int)(y: Int): Int = x + y
  
  // 柯里化的应用：部分应用
  def demonstrate(): Unit = {
    // 原始函数
    val sum1 = add(5, 3)
    println(s"add(5, 3) = $sum1")
    
    // 柯里化函数
    val add5 = addCurried(5)
    val sum2 = add5(3)
    println(s"addCurried(5)(3) = $sum2")
    
    // 柯里化语法
    val add5Syntax = addCurriedSyntax(5) _
    val sum3 = add5Syntax(3)
    println(s"addCurriedSyntax(5)(3) = $sum3")
    
    // 部分应用
    val add10 = addCurried(10)
    val numbers = (1 to 5).toList
    val addedNumbers = numbers.map(add10)
    println(s"Add 10 to numbers: $addedNumbers")
  }
  
  // 实际应用示例：配置函数
  def connectToDatabase(driver: String, url: String, username: String, password: String): String = {
    s"Connecting to $url with $driver using $username/$password"
  }
  
  def connectToDatabaseCurried(driver: String): String => String => String => String = 
    url => username => password => connectToDatabase(driver, url, username, password)
  
  def databaseConfigurationExample(): Unit = {
    // 柯里化版本允许部分配置
    val mysqlConnector = connectToDatabaseCurried("mysql")
    val mysqlProduction = mysqlConnector("jdbc:mysql://prod-db:3306/myapp")
    val mysqlProductionUser = mysqlProduction("app_user")
    val mysqlProductionConn = mysqlProductionUser("secure_password")
    
    println(mysqlProductionConn)
    
    // 可以重用部分配置
    val mysqlStaging = mysqlConnector("jdbc:mysql://staging-db:3306/myapp")
    val mysqlStagingConn = mysqlStaging("app_user")("staging_password")
    
    println(mysqlStagingConn)
  }
}
```

### 13.2.2 函数组合

函数组合是一种将简单函数组合成复杂函数的技术：

```scala
object FunctionCompositionPattern {
  // 简单的函数
  def addOne(x: Int): Int = x + 1
  def multiplyByTwo(x: Int): Int = x * 2
  def square(x: Int): Int = x * x
  
  // 函数组合器
  def compose[A, B, C](f: B => C, g: A => B): A => C = x => f(g(x))
  
  def andThen[A, B, C](f: A => B, g: B => C): A => C = x => g(f(x))
  
  def demonstrate(): Unit = {
    // 使用内置的compose和andThen
    val addOneThenSquare = addOne.andThen(square)
    val squareThenAddOne = square.compose(addOne)
    
    println(s"addOne.andThen(square)(3) = ${addOneThenSquare(3)}")
    println(s"square.compose(addOne)(3) = ${squareThenAddOne(3)}")
    
    // 使用自定义组合器
    val addOneThenSquareCustom = compose(square, addOne)
    val squareThenAddOneCustom = andThen(addOne, square)
    
    println(s"compose(square, addOne)(3) = ${addOneThenSquareCustom(3)}")
    println(s"andThen(addOne, square)(3) = ${squareThenAddOneCustom(3)}")
    
    // 多重组合
    val complexOperation = addOne.andThen(multiplyByTwo).andThen(square)
    println(s"Complex operation on 3: ${complexOperation(3)}")
  }
  
  // 实际应用示例：数据管道
  case class User(id: Long, name: String, email: String, age: Int)
  case class UserDTO(id: Long, fullName: String, contact: String)
  
  def userToDTO(user: User): UserDTO = {
    val fullName = s"${user.name} (${user.age})"
    val contact = user.email
    UserDTO(user.id, fullName, contact)
  }
  
  def validateDTO(dto: UserDTO): Option[UserDTO] = {
    if (dto.fullName.nonEmpty && dto.contact.nonEmpty) {
      Some(dto)
    } else {
      None
    }
  }
  
  def serializeDTO(dto: UserDTO): String = {
    s"${dto.id}:${dto.fullName}:${dto.contact}"
  }
  
  def dataPipelineExample(): Unit = {
    // 创建处理管道
    val processUser = userToDTO.andThen(validateDTO).andThen(_.map(serializeDTO))
    
    val user = User(1L, "Alice", "alice@example.com", 30)
    val result = processUser(user)
    
    println(s"Processed user: $result")
    
    val invalidUser = User(2L, "", "", 25)
    val invalidResult = processUser(invalidUser)
    
    println(s"Processed invalid user: $invalidResult")
  }
}
```

### 13.2.3 偏函数应用

偏函数（PartialFunction）是只定义了部分输入域的函数：

```scala
object PartialFunctionPattern {
  // 定义一个偏函数，只处理正数
  val sqrt: PartialFunction[Double, Double] = {
    case x if x >= 0 => math.sqrt(x)
  }
  
  // 另一个偏函数，处理字符串长度
  val stringLength: PartialFunction[String, Int] = {
    case s if s != null => s.length
  }
  
  def demonstrate(): Unit = {
    // 使用偏函数
    val numbers = List(4.0, 9.0, -1.0, 16.0)
    
    // 方法1: collect，只处理定义的输入
    val squareRoots = numbers.collect(sqrt)
    println(s"Square roots: $squareRoots")
    
    // 方法2: andThen，处理定义的输入并转换结果
    val sqrtAndDouble = sqrt.andThen(x => x * 2)
    val doubledSqrt = numbers.collect(sqrtAndDouble)
    println(s"Doubled square roots: $doubledSqrt")
    
    // 方法3: applyOrElse，提供默认值
    val safeSqrt = sqrt.applyOrElse(_: Double, (x: Double) => 0.0)
    val safeSqrtResults = numbers.map(safeSqrt)
    println(s"Safe square roots: $safeSqrtResults")
    
    // 方法4: isDefinedAt，检查输入是否被定义
    val definedNumbers = numbers.filter(sqrt.isDefinedAt)
    println(s"Numbers defined for sqrt: $definedNumbers")
    
    // 组合偏函数
    val strings = List("hello", null, "world", "", "scala")
    
    val stringLengthOrDefault = stringLength.orElse { case null => 0 }
    val lengths = strings.map(stringLengthOrDefault)
    println(s"String lengths: $lengths")
  }
  
  // 实际应用示例：命令处理
  sealed trait Command
  case class AddUser(id: Long, name: String) extends Command
  case class RemoveUser(id: Long) extends Command
  case class UpdateUser(id: Long, name: Option[String]) extends Command
  case object ListUsers extends Command
  
  // 处理添加用户的偏函数
  val handleAddUser: PartialFunction[Command, String] = {
    case AddUser(id, name) => s"Adding user $id with name $name"
  }
  
  // 处理删除用户的偏函数
  val handleRemoveUser: PartialFunction[Command, String] = {
    case RemoveUser(id) => s"Removing user $id"
  }
  
  // 处理更新用户的偏函数
  val handleUpdateUser: PartialFunction[Command, String] = {
    case UpdateUser(id, Some(name)) => s"Updating user $id with new name $name"
    case UpdateUser(id, None) => s"Updating user $id with cleared name"
  }
  
  // 处理列出用户的偏函数
  val handleListUsers: PartialFunction[Command, String] = {
    case ListUsers => "Listing all users"
  }
  
  // 组合所有处理器
  val commandHandler: PartialFunction[Command, String] = 
    handleAddUser orElse handleRemoveUser orElse handleUpdateUser orElse handleListUsers
  
  def commandProcessingExample(): Unit = {
    val commands = List(
      AddUser(1L, "Alice"),
      RemoveUser(2L),
      UpdateUser(3L, Some("Bob")),
      UpdateUser(4L, None),
      ListUsers
    )
    
    // 处理所有命令
    val results = commands.map(commandHandler)
    results.foreach(println)
    
    // 处理未知命令（在这个例子中不存在）
    val unknownCommands = commands :+ new Command {}
    // val unknownResults = unknownCommands.map(commandHandler)  // 会导致 MatchError
  }
}
```

## 13.3 不可变集合模式

### 13.3.1 持久化数据结构

持久化数据结构是指修改后仍保留旧版本的数据结构：

```scala
object PersistentDataStructurePattern {
  // 简单的持久化列表实现
  sealed trait PList[+A] {
    def head: A
    def tail: PList[A]
    def isEmpty: Boolean
    def ::[B >: A](elem: B): PList[B] = PCons(elem, this)
    def length: Int
    def reverse: PList[A]
    def map[B](f: A => B): PList[B]
    def filter(p: A => Boolean): PList[A]
  }
  
  case object PNil extends PList[Nothing] {
    def head: Nothing = throw new NoSuchElementException("head of empty list")
    def tail: PList[Nothing] = throw new NoSuchElementException("tail of empty list")
    def isEmpty: Boolean = true
    def length: Int = 0
    def reverse: PList[Nothing] = this
    def map[B](f: Nothing => B): PList[B] = this
    def filter(p: Nothing => Boolean): PList[Nothing] = this
  }
  
  case class PCons[A](head: A, tail: PList[A]) extends PList[A] {
    def isEmpty: Boolean = false
    def length: Int = 1 + tail.length
    def reverse: PList[A] = {
      def reverseAcc(acc: PList[A], remaining: PList[A]): PList[A] = {
        if (remaining.isEmpty) acc
        else reverseAcc(head :: acc, remaining.tail)
      }
      reverseAcc(PNil, this)
    }
    def map[B](f: A => B): PList[B] = PCons(f(head), tail.map(f))
    def filter(p: A => Boolean): PList[A] = {
      if (p(head)) PCons(head, tail.filter(p))
      else tail.filter(p)
    }
  }
  
  def demonstrate(): Unit = {
    // 创建持久化列表
    val list1 = 1 :: 2 :: 3 :: PNil
    println(s"Original list: ${list1}")
    
    // 修改列表（实际上是创建新列表）
    val list2 = 0 :: list1
    println(s"New list with 0 prepended: ${list2}")
    println(s"Original list unchanged: ${list1}")
    
    // 映射操作
    val list3 = list1.map(_ * 2)
    println(s"Mapped list: ${list3}")
    println(s"Original list still unchanged: ${list1}")
    
    // 过滤操作
    val list4 = list1.filter(_ % 2 == 0)
    println(s"Filtered list: ${list4}")
    
    // 反转操作
    val list5 = list1.reverse
    println(s"Reversed list: ${list5}")
  }
  
  // 持久化二叉搜索树
  sealed trait PTree[+A] {
    def isEmpty: Boolean
    def insert[B >: A](x: B)(implicit ordering: Ordering[B]): PTree[B]
    def contains[B >: A](x: B)(implicit ordering: Ordering[B]): Boolean
    def inorder: List[A]
  }
  
  case object PEmpty extends PTree[Nothing] {
    def isEmpty: Boolean = true
    def insert[B](x: B)(implicit ordering: Ordering[B]): PTree[B] = 
      PNode(PEmpty, x, PEmpty)
    def contains[B](x: B)(implicit ordering: Ordering[B]): Boolean = false
    def inorder: List[Nothing] = List.empty
  }
  
  case class PNode[A](left: PTree[A], value: A, right: PTree[A]) extends PTree[A] {
    def isEmpty: Boolean = false
    
    def insert[B >: A](x: B)(implicit ordering: Ordering[B]): PTree[B] = {
      if (ordering.compare(x, value) < 0) {
        PNode(left.insert(x), value, right)
      } else if (ordering.compare(x, value) > 0) {
        PNode(left, value, right.insert(x))
      } else {
        this // 值已存在，返回原树
      }
    }
    
    def contains[B >: A](x: B)(implicit ordering: Ordering[B]): Boolean = {
      if (ordering.compare(x, value) == 0) {
        true
      } else if (ordering.compare(x, value) < 0) {
        left.contains(x)
      } else {
        right.contains(x)
      }
    }
    
    def inorder: List[A] = left.inorder ++ List(value) ++ right.inorder
  }
  
  def treeExample(): Unit = {
    // 创建持久化二叉搜索树
    val tree1 = List(5, 3, 7, 2, 4, 6, 8).foldLeft(PEmpty: PTree[Int]) { (tree, value) =>
      tree.insert(value)
    }
    
    println(s"Inorder traversal: ${tree1.inorder}")
    println(s"Contains 4: ${tree1.contains(4)}")
    println(s"Contains 9: ${tree1.contains(9)}")
    
    // 插入新元素，创建新树
    val tree2 = tree1.insert(9)
    println(s"Inorder traversal after inserting 9: ${tree2.inorder}")
    println(s"Original tree unchanged: ${tree1.inorder}")
  }
}
```

### 13.3.2 函数式数据更新

```scala
object FunctionalUpdatePattern {
  // 不可变用户类
  case class User(id: Long, name: String, email: String, age: Int, active: Boolean = true)
  
  // 函数式更新：创建新实例而不是修改现有实例
  def updateName(user: User, newName: String): User = {
    user.copy(name = newName)
  }
  
  def updateEmail(user: User, newEmail: String): User = {
    user.copy(email = newEmail)
  }
  
  def incrementAge(user: User): User = {
    user.copy(age = user.age + 1)
  }
  
  def deactivate(user: User): User = {
    user.copy(active = false)
  }
  
  // 组合更新
  def updateUserProfile(user: User, newName: Option[String] = None, 
                         newEmail: Option[String] = None): User = {
    user.copy(
      name = newName.getOrElse(user.name),
      email = newEmail.getOrElse(user.email)
    )
  }
  
  def demonstrate(): Unit = {
    val user = User(1L, "Alice", "alice@example.com", 30)
    println(s"Original user: $user")
    
    // 单一更新
    val user1 = updateName(user, "Alice Smith")
    println(s"After name update: $user1")
    println(s"Original user unchanged: $user")
    
    // 组合更新
    val user2 = updateUserProfile(user, Some("Alice Smith"), Some("alice.smith@example.com"))
    println(s"After profile update: $user2")
    println(s"Original user still unchanged: $user")
    
    // 链式更新
    val user3 = incrementAge(updateName(user, "Alice Smith"))
    println(s"After chained updates: $user3")
  }
  
  // 实际应用示例：状态管理
  case class AppState(users: Map[Long, User] = Map.empty, counter: Long = 0)
  
  def addUser(state: AppState, name: String, email: String, age: Int): AppState = {
    val newId = state.counter + 1
    val newUser = User(newId, name, email, age)
    state.copy(
      users = state.users + (newId -> newUser),
      counter = newId
    )
  }
  
  def updateUser(state: AppState, id: Long, updateFunc: User => User): AppState = {
    state.users.get(id) match {
      case Some(user) =>
        val updatedUser = updateFunc(user)
        state.copy(users = state.users + (id -> updatedUser))
      case None =>
        state // 用户不存在，返回原状态
    }
  }
  
  def removeUser(state: AppState, id: Long): AppState = {
    state.copy(users = state.users - id)
  }
  
  def stateManagementExample(): Unit = {
    var state = AppState()
    
    // 添加用户
    state = addUser(state, "Alice", "alice@example.com", 30)
    state = addUser(state, "Bob", "bob@example.com", 25)
    println(s"After adding users: ${state.users}")
    
    // 更新用户
    state = updateUser(state, 1L, _.copy(age = 31))
    println(s"After updating user: ${state.users}")
    
    // 删除用户
    state = removeUser(state, 2L)
    println(s"After removing user: ${state.users}")
  }
}
```

## 13.4 函子与单子模式

### 13.4.1 函子（Functor）

函子是一种可以被映射的计算上下文：

```scala
object FunctorPattern {
  // 函子类型类
  trait Functor[F[_]] {
    def map[A, B](fa: F[A])(f: A => B): F[B]
  }
  
  // List的Functor实例
  implicit val listFunctor: Functor[List] = new Functor[List] {
    def map[A, B](fa: List[A])(f: A => B): List[B] = fa.map(f)
  }
  
  // Option的Functor实例
  implicit val optionFunctor: Functor[Option] = new Functor[Option] {
    def map[A, B](fa: Option[A])(f: A => B): Option[B] = fa.map(f)
  }
  
  // Either的Functor实例（固定为Right）
  implicit def eitherFunctor[L]: Functor[Either[L, *]] = new Functor[Either[L, *]] {
    def map[A, B](fa: Either[L, A])(f: A => B): Either[L, B] = fa.map(f)
  }
  
  // 函数的Functor实例
  implicit def functionFunctor[E]: Functor[E => *] = new Functor[E => *] {
    def map[A, B](fa: E => A)(f: A => B): E => B = fa.andThen(f)
  }
  
  // 使用Functor的通用函数
  def processWithFunctor[F[_], A, B](value: F[A], processor: A => B)
                               (implicit functor: Functor[F]): F[B] = {
    functor.map(value)(processor)
  }
  
  def demonstrate(): Unit = {
    // 处理List
    val numbers = List(1, 2, 3, 4, 5)
    val doubled = processWithFunctor(numbers, _ * 2)
    println(s"Doubled numbers: $doubled")
    
    // 处理Option
    val maybeNumber: Option[Int] = Some(42)
    val doubledOption = processWithFunctor(maybeNumber, _ * 2)
    println(s"Doubled option: $doubledOption")
    
    // 处理Either
    val eitherNumber: Either[String, Int] = Right(42)
    val doubledEither = processWithFunctor(eitherNumber, _ * 2)
    println(s"Doubled either: $doubledEither")
    
    // 处理函数
    val addFive: Int => Int = _ + 5
    val addFiveThenDouble = processWithFunctor(addFive, _ * 2)
    println(s"addFiveThenDouble(10): ${addFiveThenDouble(10)}")
  }
  
  // 函子组合器
  def composeFunctors[F[_], G[_], A, B, C](value: F[G[A]], 
                                         f1: A => B, 
                                         f2: B => C)
                                        (implicit F: Functor[F], G: Functor[G]): F[G[C]] = {
    F.map(value)(ga => G.map(ga)(f1.andThen(f2)))
  }
  
  def functorCompositionExample(): Unit = {
    val listOptions: List[Option[Int]] = List(Some(1), None, Some(3), Some(4))
    
    // 使用组合器
    val processed = composeFunctors(listOptions, _ * 2, _ + 10)
    println(s"Composed functor processing: $processed")
    
    // 手动实现相同操作
    val manualProcessed = listOptions.map(_.map(_ * 2).map(_ + 10))
    println(s"Manual processing: $manualProcessed")
  }
}
```

### 13.4.2 单子（Monad）

单子是一种扩展了函子的计算上下文，提供了flatMap（也称为bind或>>=）操作：

```scala
object MonadPattern {
  // 单子类型类
  trait Monad[F[_]] extends Functor[F] {
    def pure[A](a: A): F[A]
    def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B]
    
    // 从Functor继承的map可以使用flatMap和pure实现
    def map[A, B](fa: F[A])(f: A => B): F[B] = flatMap(fa)(a => pure(f(a)))
  }
  
  // List的Monad实例
  implicit val listMonad: Monad[List] = new Monad[List] {
    def pure[A](a: A): List[A] = List(a)
    def flatMap[A, B](fa: List[A])(f: A => List[B]): List[B] = fa.flatMap(f)
  }
  
  // Option的Monad实例
  implicit val optionMonad: Monad[Option] = new Monad[Option] {
    def pure[A](a: A): Option[A] = Some(a)
    def flatMap[A, B](fa: Option[A])(f: A => Option[B]): Option[B] = fa.flatMap(f)
  }
  
  // Either的Monad实例（固定为Right）
  implicit def eitherMonad[L]: Monad[Either[L, *]] = new Monad[Either[L, *]] {
    def pure[A](a: A): Either[L, A] = Right(a)
    def flatMap[A, B](fa: Either[L, A])(f: A => Either[L, B]): Either[L, B] = fa.flatMap(f)
  }
  
  // 使用Monad的通用函数
  def processWithMonad[F[_], A, B](value: F[A], processor: A => F[B])
                             (implicit monad: Monad[F]): F[B] = {
    monad.flatMap(value)(processor)
  }
  
  def demonstrate(): Unit = {
    // 处理List
    val numbers = List(1, 2, 3, 4, 5)
    val doubledAndTripled = processWithMonad(numbers, x => List(x * 2, x * 3))
    println(s"Doubled and tripled numbers: $doubledAndTripled")
    
    // 处理Option
    val maybeNumber: Option[Int] = Some(42)
    val maybeDoubled = processWithMonad(maybeNumber, x => Some(x * 2))
    println(s"Maybe doubled: $maybeDoubled")
    
    // 处理Either
    val eitherNumber: Either[String, Int] = Right(42)
    val eitherDoubled = processWithMonad(eitherNumber, x => Right(x * 2))
    println(s"Either doubled: $eitherDoubled")
  }
  
  // Monad组合器：for-comprehension
  def forComprehensionExample(): Unit = {
    // 使用Option的for-comprehension
    def calculateAdultAge(name: String, birthYear: Int, currentYear: Int): Option[Int] = {
      if (name.isEmpty || birthYear <= 0 || currentYear <= 0) {
        None
      } else {
        Some(currentYear - birthYear)
      }
    }
    
    def checkIsAdult(age: Option[Int]): Option[Boolean] = {
      age.map(_ >= 18)
    }
    
    def processPerson(name: String, birthYear: Int, currentYear: Int): Option[String] = {
      for {
        age <- calculateAdultAge(name, birthYear, currentYear)
        isAdult <- checkIsAdult(Some(age))
      } yield {
        if (isAdult) s"$name is an adult ($age years old)"
        else s"$name is not an adult ($age years old)"
      }
    }
    
    val result1 = processPerson("Alice", 1990, 2023)
    val result2 = processPerson("", 1990, 2023)
    val result3 = processPerson("Bob", 2010, 2023)
    
    println(s"Result 1: $result1")
    println(s"Result 2: $result2")
    println(s"Result 3: $result3")
  }
  
  // Monad组合器：sequence
  def sequence[F[_], A](listOfF: List[F[A]])
                       (implicit monad: Monad[F]): F[List[A]] = {
    listOfF.foldRight(monad.pure(List.empty[A])) { (fa, acc) =>
      monad.flatMap(fa)(a => monad.map(acc)(as => a :: as))
    }
  }
  
  def sequenceExample(): Unit = {
    // sequence示例
    val listOptions: List[Option[Int]] = List(Some(1), Some(2), None, Some(4))
    val sequenced = sequence(listOptions)
    println(s"Sequenced options: $sequenced")
    
    val listEithers: List[Either[String, Int]] = List(Right(1), Right(2), Left("Error"), Right(4))
    val sequencedEither = sequence(listEithers)
    println(s"Sequenced eithers: $sequencedEither")
  }
  
  // 实际应用示例：计算管道
  case class Config(serverUrl: String, timeout: Int, retries: Int)
  case class Connection(host: String, port: Int)
  case class Database(connection: Connection)
  case class User(id: Long, name: String)
  
  def loadConfig(): Either[String, Config] = {
    // 模拟加载配置
    Right(Config("localhost:5432", 30000, 3))
  }
  
  def createConnection(config: Config): Either[String, Connection] = {
    // 模拟创建连接
    val Array(host, port) = config.serverUrl.split(":")
    try {
      val portInt = port.toInt
      Right(Connection(host, portInt))
    } catch {
      case _: NumberFormatException => Left(s"Invalid port: $port")
    }
  }
  
  def connectToDatabase(connection: Connection): Either[String, Database] = {
    // 模拟连接数据库
    Right(Database(connection))
  }
  
  def findUser(db: Database, userId: Long): Either[String, User] = {
    // 模拟查找用户
    if (userId > 0) {
      Right(User(userId, s"User$userId"))
    } else {
      Left("Invalid user ID")
    }
  }
  
  def getUserInfo(userId: Long): Either[String, String] = {
    for {
      config <- loadConfig()
      connection <- createConnection(config)
      db <- connectToDatabase(connection)
      user <- findUser(db, userId)
    } yield {
      s"${user.name} (${user.id}) connected via ${connection.host}:${connection.port}"
    }
  }
  
  def pipelineExample(): Unit = {
    val validResult = getUserInfo(1L)
    println(s"Valid result: $validResult")
    
    val invalidResult = getUserInfo(0L)
    println(s"Invalid result: $invalidResult")
  }
}
```

## 13.5 模式匹配与访问者模式

### 13.5.1 代数数据类型与模式匹配

代数数据类型（ADT）是函数式编程中的核心概念，通常与模式匹配结合使用：

```scala
object ADTPattern {
  // 代数数据类型：表达式
  sealed trait Expr {
    def eval: Int
  }
  
  case class Number(value: Int) extends Expr {
    def eval: Int = value
  }
  
  case class Add(left: Expr, right: Expr) extends Expr {
    def eval: Int = left.eval + right.eval
  }
  
  case class Multiply(left: Expr, right: Expr) extends Expr {
    def eval: Int = left.eval * right.eval
  }
  
  case class Negate(expr: Expr) extends Expr {
    def eval: Int = -expr.eval
  }
  
  // 使用模式匹配的求值函数
  def evaluate(expr: Expr): Int = expr match {
    case Number(value) => value
    case Add(left, right) => evaluate(left) + evaluate(right)
    case Multiply(left, right) => evaluate(left) * evaluate(right)
    case Negate(expr) => -evaluate(expr)
  }
  
  // 另一个使用模式匹配的函数：转换为字符串
  def toString(expr: Expr): String = expr match {
    case Number(value) => value.toString
    case Add(left, right) => s"(${toString(left)} + ${toString(right)})"
    case Multiply(left, right) => s"(${toString(left)} * ${toString(right)})"
    case Negate(expr) => s"-${toString(expr)}"
  }
  
  def demonstrate(): Unit = {
    // 构建表达式
    val expr = Add(Number(5), Multiply(Negate(Number(3)), Number(2)))
    
    // 评估表达式
    val result = evaluate(expr)
    println(s"Expression result: $result")
    
    // 转换为字符串
    val exprString = toString(expr)
    println(s"Expression string: $exprString")
    
    // 验证结果：5 + (-3 * 2) = 5 + (-6) = -1
    assert(result == -1)
  }
  
  // 更复杂的ADT示例：文件系统
  sealed trait FileItem {
    def name: String
    def size: Long
  }
  
  case class File(name: String, size: Long) extends FileItem
  
  case class Directory(name: String, items: List[FileItem]) extends FileItem {
    def size: Long = items.map(_.size).sum
  }
  
  // 使用模式匹配的操作
  def findFile(item: FileItem, fileName: String): Option[File] = item match {
    case File(name, _) if name == fileName => Some(item.asInstanceOf[File])
    case Directory(_, items) => 
      items.find(_.name == fileName) match {
        case Some(found) => findFile(found, fileName)
        case None => items.flatMap(findFile(_, fileName)).headOption
      }
    case _ => None
  }
  
  def totalSize(item: FileItem): Long = item match {
    case File(_, size) => size
    case Directory(_, items) => items.map(totalSize).sum
  }
  
  def directoryExample(): Unit = {
    // 构建文件系统结构
    val fileSystem = Directory("root", List(
      File("readme.txt", 1024),
      File("config.yaml", 2048),
      Directory("src", List(
        File("main.scala", 4096),
        File("utils.scala", 2048),
        Directory("models", List(
          File("user.scala", 1024),
          File("product.scala", 1536)
        ))
      ))
    ))
    
    // 查找文件
    val file = findFile(fileSystem, "user.scala")
    println(s"Found file: $file")
    
    // 计算总大小
    val total = totalSize(fileSystem)
    println(s"Total size: $total bytes")
  }
}
```

### 13.5.2 访问者模式的函数式实现

访问者模式在面向对象编程中用于在不修改对象结构的情况下添加新操作。在函数式编程中，模式匹配通常提供了更简洁的替代方案：

```scala
object FunctionalVisitorPattern {
  // 面向对象风格的访问者模式
  // 抽象语法树
  sealed trait ExprAO {
    def accept(visitor: ExprVisitor): Int
  }
  
  case class NumberAO(value: Int) extends ExprAO {
    def accept(visitor: ExprVisitor): Int = visitor.visit(this)
  }
  
  case class AddAO(left: ExprAO, right: ExprAO) extends ExprAO {
    def accept(visitor: ExprVisitor): Int = visitor.visit(this)
  }
  
  case class MultiplyAO(left: ExprAO, right: ExprAO) extends ExprAO {
    def accept(visitor: ExprVisitor): Int = visitor.visit(this)
  }
  
  // 访问者接口
  trait ExprVisitor {
    def visit(expr: NumberAO): Int
    def visit(expr: AddAO): Int
    def visit(expr: MultiplyAO): Int
  }
  
  // 求值访问者
  class EvalVisitor extends ExprVisitor {
    def visit(expr: NumberAO): Int = expr.value
    def visit(expr: AddAO): Int = expr.left.accept(this) + expr.right.accept(this)
    def visit(expr: MultiplyAO): Int = expr.left.accept(this) * expr.right.accept(this)
  }
  
  // 函数式风格的模式匹配
  sealed trait ExprFP {
    def eval: Int
    def toString: String
  }
  
  case class NumberFP(value: Int) extends ExprFP {
    def eval: Int = value
    override def toString: String = value.toString
  }
  
  case class AddFP(left: ExprFP, right: ExprFP) extends ExprFP {
    def eval: Int = left.eval + right.eval
    override def toString: String = s"(${left.toString} + ${right.toString})"
  }
  
  case class MultiplyFP(left: ExprFP, right: ExprFP) extends ExprFP {
    def eval: Int = left.eval * right.eval
    override def toString: String = s"(${left.toString} * ${right.toString})"
  }
  
  def demonstrate(): Unit = {
    // 面向对象风格的访问者
    val exprAO = AddAO(NumberAO(5), MultiplyAO(NumberAO(3), NumberAO(2)))
    val visitor = new EvalVisitor()
    val resultAO = exprAO.accept(visitor)
    println(s"OO Visitor pattern result: $resultAO")
    
    // 函数式风格的模式匹配
    val exprFP = AddFP(NumberFP(5), MultiplyFP(NumberFP(3), NumberFP(2)))
    val resultFP = exprFP.eval
    println(s"Functional pattern result: $resultFP")
    
    // 结果应该相同：5 + (3 * 2) = 11
    assert(resultAO == resultFP)
  }
  
  // 更复杂的函数式访问者：类型安全的访问者模式
  sealed trait Shape {
    def area: Double
    def perimeter: Double
  }
  
  case class Circle(radius: Double) extends Shape {
    def area: Double = math.Pi * radius * radius
    def perimeter: Double = 2 * math.Pi * radius
  }
  
  case class Rectangle(width: Double, height: Double) extends Shape {
    def area: Double = width * height
    def perimeter: Double = 2 * (width + height)
  }
  
  case class Triangle(side1: Double, side2: Double, side3: Double) extends Shape {
    def area: Double = {
      val s = (side1 + side2 + side3) / 2
      math.sqrt(s * (s - side1) * (s - side2) * (s - side3))
    }
    def perimeter: Double = side1 + side2 + side3
  }
  
  // 类型安全的访问者：使用模式匹配的函数
  def shapeDescription(shape: Shape): String = shape match {
    case Circle(r) => s"Circle with radius $r, area ${shape.area.formatted("%.2f")}"
    case Rectangle(w, h) => s"Rectangle ${w}x$h, area ${shape.area.formatted("%.2f")}"
    case Triangle(s1, s2, s3) => s"Triangle with sides $s1, $s2, $s3, area ${shape.area.formatted("%.2f")}"
  }
  
  // 高阶访问者：接受一个函数来处理每种类型
  def visitShape[A](shape: Shape, 
                    circleVisitor: Circle => A,
                    rectangleVisitor: Rectangle => A,
                    triangleVisitor: Triangle => A): A = shape match {
    case c: Circle => circleVisitor(c)
    case r: Rectangle => rectangleVisitor(r)
    case t: Triangle => triangleVisitor(t)
  }
  
  def shapeExample(): Unit = {
    val shapes = List(
      Circle(5.0),
      Rectangle(4.0, 6.0),
      Triangle(3.0, 4.0, 5.0)
    )
    
    // 使用模式匹配
    println("Using pattern matching:")
    shapes.foreach(shape => println(shapeDescription(shape)))
    
    // 使用高阶访问者
    println("\nUsing higher-order visitor:")
    shapes.foreach { shape =>
      val description = visitShape(shape,
        c => s"Circle: radius ${c.radius}",
        r => s"Rectangle: ${r.width}x${r.height}",
        t => s"Triangle: sides ${t.side1}, ${t.side2}, ${t.side3}"
      )
      println(description)
    }
  }
}
```

## 13.6 类型类模式

### 13.6.1 类型类基础

类型类是一种在不修改类定义的情况下为类型添加功能的方式：

```scala
object TypeClassPattern {
  // 定义类型类：可比较的
  trait Equal[T] {
    def equal(x: T, y: T): Boolean
  }
  
  // 类型类实例
  object EqualInstances {
    // Int的Equal实例
    implicit val intEqual: Equal[Int] = new Equal[Int] {
      def equal(x: Int, y: Int): Boolean = x == y
    }
    
    // String的Equal实例
    implicit val stringEqual: Equal[String] = new Equal[String] {
      def equal(x: String, y: String): Boolean = x == y
    }
    
    // Option的Equal实例（需要Option内部类型的Equal实例）
    implicit def optionEqual[T](implicit equalT: Equal[T]): Equal[Option[T]] = new Equal[Option[T]] {
      def equal(x: Option[T], y: Option[T]): Boolean = (x, y) match {
        case (None, None) => true
        case (Some(a), Some(b)) => equalT.equal(a, b)
        case _ => false
      }
    }
    
    // List的Equal实例（需要List元素类型的Equal实例）
    implicit def listEqual[T](implicit equalT: Equal[T]): Equal[List[T]] = new Equal[List[T]] {
      def equal(x: List[T], y: List[T]): Boolean = {
        if (x.length != y.length) false
        else x.zip(y).forall { case (a, b) => equalT.equal(a, b) }
      }
    }
  }
  
  // 使用类型类的函数
  def areEqual[T](x: T, y: T)(implicit equal: Equal[T]): Boolean = {
    equal.equal(x, y)
  }
  
  // 上下文界限的语法糖
  def areEqualContext[T: Equal](x: T, y: T): Boolean = {
    implicitly[Equal[T]].equal(x, y)
  }
  
  // 扩展方法语法
  implicit class EqualOps[T](x: T)(implicit equal: Equal[T]) {
    def ===(y: T): Boolean = equal.equal(x, y)
    def !==(y: T): Boolean = !equal.equal(x, y)
  }
  
  def demonstrate(): Unit = {
    import EqualInstances._
    
    // 使用隐式参数
    println(s"5 === 3: ${areEqual(5, 3)}")
    println(s"5 === 5: ${areEqual(5, 5)}")
    
    // 使用上下文界限
    println(s"\"hello\" === \"world\": ${areEqualContext("hello", "world")}")
    println(s"\"hello\" === \"hello\": ${areEqualContext("hello", "hello")}")
    
    // 使用扩展方法
    println(s"5 === 5: ${5 === 5}")
    println(s"5 !== 3: ${5 !== 3}")
    
    // 使用复杂类型
    println(s"List(1,2,3) === List(1,2,3): ${List(1, 2, 3) === List(1, 2, 3)}")
    println(s"List(1,2,3) === List(1,2,4): ${List(1, 2, 3) === List(1, 2, 4)}")
    println(s"Some(5) === Some(5): ${Some(5) === Some(5)}")
    println(s"Some(5) === None: ${Some(5) === None}")
  }
  
  // 更复杂的类型类：可序列化的
  trait Serializer[T] {
    def serialize(value: T): String
    def deserialize(s: String): T
  }
  
  object SerializerInstances {
    // Int的Serializer实例
    implicit val intSerializer: Serializer[Int] = new Serializer[Int] {
      def serialize(value: Int): String = value.toString
      def deserialize(s: String): Int = s.toInt
    }
    
    // String的Serializer实例
    implicit val stringSerializer: Serializer[String] = new Serializer[String] {
      def serialize(value: String): String = value
      def deserialize(s: String): String = s
    }
    
    // Boolean的Serializer实例
    implicit val booleanSerializer: Serializer[Boolean] = new Serializer[Boolean] {
      def serialize(value: Boolean): String = value.toString
      def deserialize(s: String): Boolean = s.toBoolean
    }
    
    // Option的Serializer实例
    implicit def optionSerializer[T](implicit serializerT: Serializer[T]): Serializer[Option[T]] = 
      new Serializer[Option[T]] {
        def serialize(value: Option[T]): String = value match {
          case None => "None"
          case Some(v) => s"Some(${serializerT.serialize(v)})"
        }
        
        def deserialize(s: String): Option[T] = {
          if (s == "None") None
          else if (s.startsWith("Some(") && s.endsWith(")")) {
            val content = s.substring(5, s.length - 1)
            Some(serializerT.deserialize(content))
          } else {
            throw new IllegalArgumentException(s"Cannot deserialize: $s")
          }
        }
      }
    
    // List的Serializer实例
    implicit def listSerializer[T](implicit serializerT: Serializer[T]): Serializer[List[T]] = 
      new Serializer[List[T]] {
        def serialize(value: List[T]): String = {
          val serializedItems = value.map(serializerT.serialize)
          s"List(${serializedItems.mkString(", ")})"
        }
        
        def deserialize(s: String): List[T] = {
          if (s.startsWith("List(") && s.endsWith(")")) {
            val content = s.substring(5, s.length - 1)
            if (content.isEmpty) List.empty
            else {
              val items = content.split(", ").toList
              items.map(serializerT.deserialize)
            }
          } else {
            throw new IllegalArgumentException(s"Cannot deserialize: $s")
          }
        }
      }
  }
  
  def serializerExample(): Unit = {
    import SerializerInstances._
    
    // 序列化和反序列化
    val int = 42
    val serializedInt = implicitly[Serializer[Int]].serialize(int)
    val deserializedInt = implicitly[Serializer[Int]].deserialize(serializedInt)
    println(s"Int: $int -> '$serializedInt' -> $deserializedInt")
    
    val list = List(1, 2, 3, 4, 5)
    val serializedList = implicitly[Serializer[List[Int]]].serialize(list)
    val deserializedList = implicitly[Serializer[List[Int]]].deserialize(serializedList)
    println(s"List: $list -> '$serializedList' -> $deserializedList")
    
    val option = Some("hello")
    val serializedOption = implicitly[Serializer[Option[String]]].serialize(option)
    val deserializedOption = implicitly[Serializer[Option[String]]].deserialize(serializedOption)
    println(s"Option: $option -> '$serializedOption' -> $deserializedOption")
  }
  
  // 类型类组合
  trait Show[T] {
    def show(value: T): String
  }
  
  object ShowInstances {
    implicit val intShow: Show[Int] = new Show[Int] {
      def show(value: Int): String = s"Int($value)"
    }
    
    implicit val stringShow: Show[String] = new Show[String] {
      def show(value: String): String = s"String($value)"
    }
    
    implicit def optionShow[T](implicit showT: Show[T]): Show[Option[T]] = new Show[Option[T]] {
      def show(value: Option[T]): String = value match {
        case None => "None"
        case Some(a) => s"Some(${showT.show(a)})"
      }
    }
  }
  
  // 同时使用多个类型类
  def showAndEqual[T: Show : Equal](x: T, y: T): (String, Boolean) = {
    val showX = implicitly[Show[T]].show(x)
    val areEqual = implicitly[Equal[T]].equal(x, y)
    (showX, areEqual)
  }
  
  def typeClassCompositionExample(): Unit = {
    import ShowInstances._
    import EqualInstances._
    
    val result = showAndEqual(5, 5)
    println(s"Show and Equal result: $result")
    
    val optionResult = showAndEqual(Some("hello"), Some("hello"))
    println(s"Option Show and Equal result: $optionResult")
  }
}
```

### 13.6.2 类型类的实际应用

```scala
object TypeClassApplications {
  // JSON序列化类型类
  trait JsonEncoder[T] {
    def encode(value: T): String
  }
  
  object JsonEncoderInstances {
    // 基本类型的JSON编码器
    implicit val stringEncoder: JsonEncoder[String] = new JsonEncoder[String] {
      def encode(value: String): String = s""""$value""""
    }
    
    implicit val intEncoder: JsonEncoder[Int] = new JsonEncoder[Int] {
      def encode(value: Int): String = value.toString
    }
    
    implicit val booleanEncoder: JsonEncoder[Boolean] = new JsonEncoder[Boolean] {
      def encode(value: Boolean): String = value.toString
    }
    
    // 复合类型的JSON编码器
    implicit def optionEncoder[T](implicit encoderT: JsonEncoder[T]): JsonEncoder[Option[T]] = 
      new JsonEncoder[Option[T]] {
        def encode(value: Option[T]): String = value match {
          case None => "null"
          case Some(v) => encoderT.encode(v)
        }
      }
    
    implicit def listEncoder[T](implicit encoderT: JsonEncoder[T]): JsonEncoder[List[T]] = 
      new JsonEncoder[List[T]] {
        def encode(value: List[T]): String = {
          val encodedItems = value.map(encoderT.encode)
          s"[${encodedItems.mkString(", ")}]"
        }
      }
    
    implicit def mapEncoder[T](implicit encoderT: JsonEncoder[T]): JsonEncoder[Map[String, T]] = 
      new JsonEncoder[Map[String, T]] {
        def encode(value: Map[String, T]): String = {
          val encodedItems = value.map { case (k, v) => s""""$k": ${encoderT.encode(v)}""" }
          s"{${encodedItems.mkString(", ")}}"
        }
      }
  }
  
  case class Person(name: String, age: Int, email: String)
  
  object PersonInstances {
    implicit val personEncoder: JsonEncoder[Person] = new JsonEncoder[Person] {
      def encode(value: Person): String = {
        val nameJson = JsonEncoderInstances.stringEncoder.encode(value.name)
        val ageJson = JsonEncoderInstances.intEncoder.encode(value.age)
        val emailJson = JsonEncoderInstances.stringEncoder.encode(value.email)
        s"""{"name": $nameJson, "age": $ageJson, "email": $emailJson}"""
      }
    }
  }
  
  def jsonEncode[T](value: T)(implicit encoder: JsonEncoder[T]): String = {
    encoder.encode(value)
  }
  
  def jsonExample(): Unit = {
    import JsonEncoderInstances._
    import PersonInstances._
    
    // 简单类型
    println(jsonEncode("hello"))  // "hello"
    println(jsonEncode(42))       // 42
    println(jsonEncode(true))     // true
    
    // 复合类型
    println(jsonEncode(List(1, 2, 3)))  // [1, 2, 3]
    println(jsonEncode(Map("name" -> "Alice", "age" -> 30)))  // {"name": "Alice", "age": 30}
    println(jsonEncode(Some("hello")))  // "hello"
    println(jsonEncode(None))        // null
    
    // 自定义类型
    val person = Person("Alice", 30, "alice@example.com")
    println(jsonEncode(person))
    // {"name": "Alice", "age": 30, "email": "alice@example.com"}
  }
  
  // 数据验证类型类
  sealed trait ValidationResult[+A]
  case class Valid[A](value: A) extends ValidationResult[A]
  case class Invalid(errors: List[String]) extends ValidationResult[Nothing]
  
  trait Validator[T] {
    def validate(value: T): ValidationResult[T]
  }
  
  object ValidatorInstances {
    implicit val stringValidator: Validator[String] = new Validator[String] {
      def validate(value: String): ValidationResult[String] = {
        if (value.nonEmpty) Valid(value)
        else Invalid(List("String must not be empty"))
      }
    }
    
    implicit val intValidator: Validator[Int] = new Validator[Int] {
      def validate(value: Int): ValidationResult[Int] = {
        if (value >= 0) Valid(value)
        else Invalid(List("Int must be non-negative"))
      }
    }
    
    implicit val emailValidator: Validator[String] = new Validator[String] {
      def validate(value: String): ValidationResult[String] = {
        val emailRegex = """^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$""".r
        if (emailRegex.matches(value)) Valid(value)
        else Invalid(List("Invalid email format"))
      }
    }
    
    // 复合类型的验证器
    implicit def optionValidator[T](implicit validatorT: Validator[T]): Validator[Option[T]] = 
      new Validator[Option[T]] {
        def validate(value: Option[T]): ValidationResult[Option[T]] = value match {
          case None => Valid(None)
          case Some(v) => validatorT.validate(v) match {
            case Valid(_) => Valid(value)
            case Invalid(errors) => Invalid(errors)
          }
        }
      }
    
    implicit def listValidator[T](implicit validatorT: Validator[T]): Validator[List[T]] = 
      new Validator[List[T]] {
        def validate(value: List[T]): ValidationResult[List[T]] = {
          val results = value.zipWithIndex.map { case (item, index) =>
            validatorT.validate(item) match {
              case Valid(_) => None
              case Invalid(errors) => Some(errors.map(e => s"Item $index: $e"))
            }
          }
          
          val allErrors = results.flatten.flatten
          if (allErrors.isEmpty) Valid(value)
          else Invalid(allErrors)
        }
      }
  }
  
  def validate[T](value: T)(implicit validator: Validator[T]): ValidationResult[T] = {
    validator.validate(value)
  }
  
  def validationExample(): Unit = {
    import ValidatorInstances._
    
    // 简单验证
    val validString = validate("hello")
    val invalidString = validate("")
    println(s"String validation: $validString, $invalidString")
    
    val validInt = validate(42)
    val invalidInt = validate(-1)
    println(s"Int validation: $validInt, $invalidInt")
    
    val validEmail = validate("user@example.com")
    val invalidEmail = validate("invalid-email")
    println(s"Email validation: $validEmail, $invalidEmail")
    
    // 复合验证
    val validOption = validate(Some("hello"))
    val invalidOption = validate(Some(""))
    println(s"Option validation: $validOption, $invalidOption")
    
    val validList = validate(List("hello", "world", "scala"))
    val invalidList = validate(List("hello", "", "world"))
    println(s"List validation: $validList, $invalidList")
  }
  
  // 函数组合器：类型类方法
  implicit class ValidatedOps[A](value: A) {
    def validated(implicit validator: Validator[A]): ValidationResult[A] = {
      validator.validate(value)
    }
  }
  
  def validatedExample(): Unit = {
    import ValidatorInstances._
    
    val result = "user@example.com".validated
    println(s"Validated email: $result")
    
    val invalidResult = "".validated
    println(s"Validated empty string: $invalidResult")
  }
  
  def demonstrate(): Unit = {
    jsonExample()
    println("\n" + "="*50 + "\n")
    validationExample()
    println("\n" + "="*50 + "\n")
    validatedExample()
  }
}
```

## 总结

函数式设计模式与传统面向对象设计模式有以下关键区别：

1. **不可变性**：函数式模式强调不可变性，避免副作用
2. **函数组合**：通过组合简单函数来构建复杂功能
3. **高阶函数**：函数作为一等公民，可以作为参数传递和返回值
4. **模式匹配**：提供类型安全的条件分支
5. **类型类**：提供多态性而不修改类定义

在Scala中，这些模式可以利用语言的强大类型系统和函数式特性来实现。通过理解和应用这些模式，开发者可以编写出更简洁、可维护和可测试的代码。

下一章将探讨Scala的性能优化与调优技术，这对于构建高性能的函数式应用至关重要。