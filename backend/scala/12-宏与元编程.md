# 第12章：宏与元编程

元编程是编写能够生成或操作其他代码的代码的能力。Scala提供了强大的元编程能力，包括反射、宏和注解处理。本章将深入探讨Scala中的元编程技术，从基础的反射机制到高级的宏系统。

## 12.1 反射（Reflection）

### 12.1.1 运行时反射基础

Scala的反射API允许在运行时检查和操作类型、方法和字段：

```scala
import scala.reflect.runtime.universe._
import scala.reflect.runtime.{currentMirror => cm}

// 基本反射示例
object BasicReflection {
  // 用于演示的类
  case class Person(name: String, age: Int) {
    def greet(): String = s"Hello, my name is $name and I'm $age years old"
    
    private def secret(): String = "This is a secret method"
  }
  
  def demonstrate(): Unit = {
    // 获取Person的TypeTag
    val personType = typeTag[Person]
    
    // 获取类型信息
    println(s"Type: ${personType.tpe}")
    println(s"TypeSymbol: ${personType.tpe.typeSymbol}")
    println(s"TypeArgs: ${personType.tpe.typeArgs}")
    
    // 获取类的成员
    val members = personType.tpe.members.sorted
    println("\nClass members:")
    members.foreach { member =>
      println(s"- ${member.name}: ${member.typeSignature}")
    }
    
    // 创建实例
    val constructor = personType.tpe.decl(termNames.CONSTRUCTOR).asMethod
    val personMirror = cm.reflect(cm.classTag[Person].runtimeClass)
    val constructorMirror = personMirror.reflectConstructor(constructor)
    
    val person = constructorMirror.apply("Alice", 30).asInstanceOf[Person]
    println(s"\nCreated person: $person")
    
    // 调用方法
    val greetMethod = personType.tpe.decl(TermName("greet")).asMethod
    val instanceMirror = cm.reflect(person)
    val greetMirror = instanceMirror.reflectMethod(greetMethod)
    
    val greeting = greetMirror.apply()
    println(s"Greeting: $greeting")
    
    // 访问字段
    val nameField = personType.tpe.decl(TermName("name")).asTerm.accessed.asTerm
    val nameValue = instanceMirror.reflectField(nameField).get
    println(s"Name field value: $nameValue")
  }
}
```

### 12.1.2 反射的高级用法

```scala
import scala.reflect.runtime.universe._
import scala.reflect.runtime.{currentMirror => cm}
import scala.util.{Try, Success, Failure}

// 高级反射示例
object AdvancedReflection {
  // 用于演示的复杂类
  class ComplexClass {
    private var privateField = "private value"
    
    def publicMethod(input: String): String = s"Processed: $input"
    
    private def privateMethod(input: Int): Int = input * 2
    
    def overloadedMethod(input: String): String = s"String: $input"
    def overloadedMethod(input: Int): Int = input * 3
  }
  
  // 动态方法调用
  def dynamicMethodCall(): Unit = {
    val instance = new ComplexClass()
    val instanceMirror = cm.reflect(instance)
    val classSymbol = instanceMirror.symbol
    
    // 获取所有方法
    val methods = classSymbol.info.decls.filter(_.isMethod)
    println("Available methods:")
    methods.foreach { method =>
      println(s"- ${method.name}: ${method.typeSignature}")
    }
    
    // 动态调用publicMethod
    val method = classSymbol.info.decl(TermName("publicMethod")).asMethod
    val methodMirror = instanceMirror.reflectMethod(method)
    val result = methodMirror.apply("reflection test")
    println(s"\nDynamic method call result: $result")
  }
  
  // 动态字段访问
  def dynamicFieldAccess(): Unit = {
    val instance = new ComplexClass()
    val instanceMirror = cm.reflect(instance)
    val classSymbol = instanceMirror.symbol
    
    // 获取所有字段
    val fields = classSymbol.info.decls.filter(_.isTerm)
    println("Available fields:")
    fields.foreach { field =>
      println(s"- ${field.name}: ${field.typeSignature}")
    }
    
    // 动态访问privateField
    val field = classSymbol.info.decl(TermName("privateField")).asTerm.accessed.asTerm
    val fieldMirror = instanceMirror.reflectField(field)
    val value = fieldMirror.get
    println(s"\nPrivate field value: $value")
    
    // 修改私有字段
    fieldMirror.set("new private value")
    val newValue = fieldMirror.get
    println(s"Modified private field value: $newValue")
  }
  
  // 类型检查和转换
  def typeCheckingAndCasting(): Unit = {
    val values: List[Any] = List("string", 42, 3.14, List(1, 2, 3))
    
    values.foreach { value =>
      val valueType = cm.reflect(value).symbol.toType
      println(s"Value: $value, Type: $valueType")
      
      // 检查是否为字符串
      if (valueType <:< typeOf[String]) {
        val stringValue = value.asInstanceOf[String]
        println(s"  Upper case: ${stringValue.toUpperCase}")
      }
      
      // 检查是否为数字
      if (valueType <:< typeOf[Int]) {
        val intValue = value.asInstanceOf[Int]
        println(s"  Square: ${intValue * intValue}")
      }
      
      // 检查是否为列表
      if (valueType <:< typeOf[List[_]]) {
        val listValue = value.asInstanceOf[List[_]]
        println(s"  List size: ${listValue.size}")
      }
    }
  }
  
  // 处理重载方法
  def overloadedMethods(): Unit = {
    val instance = new ComplexClass()
    val instanceMirror = cm.reflect(instance)
    val classSymbol = instanceMirror.symbol
    
    // 获取重载方法
    val overloadedMethods = classSymbol.info.member(TermName("overloadedMethod")).asTerm.alternatives
    println("Overloaded methods:")
    overloadedMethods.foreach { method =>
      println(s"- ${method.asMethod.typeSignature}")
    }
    
    // 调用字符串版本
    val stringMethod = overloadedMethods.find { method =>
      val params = method.asMethod.paramLists.flatten
      params.nonEmpty && params.head.typeSignature <:< typeOf[String]
    }.get.asMethod
    
    val stringResult = instanceMirror.reflectMethod(stringMethod).apply("overloaded test")
    println(s"String overload result: $stringResult")
    
    // 调用整数版本
    val intMethod = overloadedMethods.find { method =>
      val params = method.asMethod.paramLists.flatten
      params.nonEmpty && params.head.typeSignature <:< typeOf[Int]
    }.get.asMethod
    
    val intResult = instanceMirror.reflectMethod(intMethod).apply(42)
    println(s"Int overload result: $intResult")
  }
  
  def demonstrate(): Unit = {
    println("=== 动态方法调用 ===")
    dynamicMethodCall()
    
    println("\n=== 动态字段访问 ===")
    dynamicFieldAccess()
    
    println("\n=== 类型检查和转换 ===")
    typeCheckingAndCasting()
    
    println("\n=== 处理重载方法 ===")
    overloadedMethods()
  }
}
```

### 12.1.3 泛型类型反射

```scala
import scala.reflect.runtime.universe._
import scala.reflect.runtime.{currentMirror => cm}

// 泛型类型反射示例
object GenericReflection {
  // 泛型类
  class Container[T](private val value: T) {
    def getValue: T = value
    
    def setValue(newValue: T): Unit = {
      val field = this.getClass.getDeclaredField("value")
      field.setAccessible(true)
      field.set(this, newValue)
    }
  }
  
  // 处理泛型类型
  def processGenericType(): Unit = {
    val intContainer = new Container(42)
    val stringContainer = new Container("hello")
    
    // 获取泛型类型信息
    val intContainerType = cm.reflect(intContainer).symbol.toType
    val stringContainerType = cm.reflect(stringContainer).symbol.toType
    
    println(s"Int container type: $intContainerType")
    println(s"String container type: $stringContainerType")
    
    // 获取类型参数
    val intContainerTypeArgs = intContainerType.typeArgs
    val stringContainerTypeArgs = stringContainerType.typeArgs
    
    println(s"Int container type args: $intContainerTypeArgs")
    println(s"String container type args: $stringContainerTypeArgs")
    
    // 根据类型参数执行不同的操作
    processContainer(intContainer)
    processContainer(stringContainer)
  }
  
  def processContainer(container: Any): Unit = {
    val containerType = cm.reflect(container).symbol.toType
    
    if (containerType.typeArgs.nonEmpty) {
      val typeArg = containerType.typeArgs.head
      
      // 使用TypeTag获取类型信息
      typeArg match {
        case t if t <:< typeOf[Int] =>
          val value = container.asInstanceOf[Container[Int]].getValue
          println(s"Int container value doubled: ${value * 2}")
          
        case t if t <:< typeOf[String] =>
          val value = container.asInstanceOf[Container[String]].getValue
          println(s"String container value uppercased: ${value.toUpperCase}")
          
        case t =>
          println(s"Unsupported container type: $t")
      }
    }
  }
  
  def demonstrate(): Unit = {
    processGenericType()
  }
}
```

## 12.2 注解（Annotations）

### 12.2.1 自定义注解

Scala允许创建自定义注解来为代码添加元数据：

```scala
import scala.annotation.{StaticAnnotation, tailrec}
import scala.reflect.runtime.universe._
import scala.reflect.runtime.{currentMirror => cm}

// 自定义注解
class Deprecated(reason: String) extends StaticAnnotation

class Author(name: String, date: String = "") extends StaticAnnotation

class Test extends StaticAnnotation

class PerformanceTest extends StaticAnnotation

class Doc(description: String) extends StaticAnnotation

// 使用注解的类和方法
@Author("John Doe", "2023-01-01")
class AnnotatedClass {
  @Doc("Get the current value")
  def getValue(): Int = 42
  
  @Deprecated("Use newGetValue instead")
  @Author("Jane Smith")
  def oldGetValue(): Int = 42
  
  @Doc("Get the current value using new implementation")
  def newGetValue(): Int = 100
  
  @Test
  def testMethod(): Unit = {
    println("This is a test method")
  }
  
  @PerformanceTest
  @Test
  def performanceTest(): Unit = {
    println("This is a performance test method")
  }
}

object CustomAnnotations {
  // 读取类上的注解
  def readClassAnnotations(): Unit = {
    val classSymbol = typeOf[AnnotatedClass].typeSymbol.asClass
    
    println("Class annotations:")
    classSymbol.annotations.foreach { annotation =>
      println(s"- ${annotation.tree}")
    }
  }
  
  // 读取方法上的注解
  def readMethodAnnotations(): Unit = {
    val classSymbol = typeOf[AnnotatedClass].typeSymbol.asClass
    
    println("\nMethod annotations:")
    classSymbol.decls.foreach { member =>
      if (member.isMethod) {
        val method = member.asMethod
        println(s"${method.name}:")
        method.annotations.foreach { annotation =>
          println(s"  - ${annotation.tree}")
        }
      }
    }
  }
  
  // 处理特定注解
  def processAnnotations(): Unit = {
    val classSymbol = typeOf[AnnotatedClass].typeSymbol.asClass
    
    println("\nProcessing specific annotations:")
    
    // 处理Deprecated注解
    classSymbol.decls.foreach { member =>
      if (member.isMethod) {
        val method = member.asMethod
        
        method.annotations.foreach { annotation =>
          annotation.tree match {
            case Apply(Select(New(Ident(TypeName("Deprecated"))), termNames.CONSTRUCTOR), 
                       List(Literal(Constant(reason)))) =>
              println(s"Method ${method.name} is deprecated: $reason")
              
            case Apply(Select(New(Ident(TypeName("Author"))), termNames.CONSTRUCTOR), args) =>
              val name = args.head match { case Literal(Constant(name)) => name }
              val date = if (args.length > 1) {
                args(1) match { case Literal(Constant(date)) => date }
              } else {
                "unknown"
              }
              println(s"Method ${method.name} author: $name, date: $date")
              
            case _ => // 其他注解
          }
        }
      }
    }
  }
  
  // 检查注解是否存在
  def checkAnnotationExists(): Unit = {
    val classSymbol = typeOf[AnnotatedClass].typeSymbol.asClass
    
    println("\nChecking annotation existence:")
    
    classSymbol.decls.foreach { member =>
      if (member.isMethod) {
        val method = member.asMethod
        
        // 检查是否有Test注解
        val hasTest = method.annotations.exists { annotation =>
          annotation.tree.tpe <:< typeOf[Test]
        }
        
        if (hasTest) {
          println(s"Method ${method.name} has @Test annotation")
        }
        
        // 检查是否有PerformanceTest注解
        val hasPerformanceTest = method.annotations.exists { annotation =>
          annotation.tree.tpe <:< typeOf[PerformanceTest]
        }
        
        if (hasPerformanceTest) {
          println(s"Method ${method.name} has @PerformanceTest annotation")
        }
      }
    }
  }
  
  def demonstrate(): Unit = {
    readClassAnnotations()
    readMethodAnnotations()
    processAnnotations()
    checkAnnotationExists()
  }
}
```

### 12.2.2 注解处理器

```scala
import scala.annotation.{StaticAnnotation, compileTimeOnly}
import scala.language.experimental.macros
import scala.reflect.macros.whitebox.Context

// 编译时注解
@compileTimeOnly("enable macro paradise to expand macro annotations")
class IdGenerator extends StaticAnnotation {
  def macroTransform(annottees: Any*): Any = macro IdGeneratorImpl.impl
}

// 注解处理器实现
object IdGeneratorImpl {
  def impl(c: Context)(annottees: c.Expr[Any]*): c.Expr[Any] = {
    import c.universe._
    
    // 处理输入
    val inputs = annottees.map(_.tree).toList
    
    val outputs = inputs.map {
      case classDef @ q"case class $className(..$fields) extends ..$parents { ..$body }" =>
        // 检查是否已有id字段
        val hasIdField = fields.exists {
          case q"$mods val $name: $tpt = $rhs" => name.toString == "id"
          case _ => false
        }
        
        // 如果没有id字段，则添加
        val newFields = if (!hasIdField) {
          val idField = q"val id: Long = java.util.UUID.randomUUID().getMostSignificantBits"
          idField :: fields
        } else {
          fields
        }
        
        // 生成新的case class
        q"case class $className(..$newFields) extends ..$parents { ..$body }"
        
      case other => other
    }
    
    c.Expr[Any](Block(outputs, Literal(Constant(()))))
  }
}

// 使用注解处理器的示例
object AnnotationProcessorExample {
  // 使用@IdGenerator注解
  @IdGenerator
  case class User(name: String, email: String)
  
  // 这个类在编译后会自动添加id字段
  // 相当于: case class User(id: Long, name: String, email: String)
  
  def demonstrate(): Unit = {
    println("This class should have an id field after macro expansion")
    
    // 下面的代码只有在启用宏扩展后才能编译
    // val user = User("Alice", "alice@example.com")
    // println(s"User ID: ${user.id}")
    
    println("To see the macro in action, enable the scala-paradise plugin")
  }
}
```

## 12.3 Scala宏基础

### 12.3.1 理解宏系统

Scala宏是一种编译时代码生成机制，可以在编译期间分析、转换和生成代码：

```scala
import scala.language.experimental.macros
import scala.reflect.macros.whitebox.Context

// 简单的宏定义
object SimpleMacro {
  // 宏方法声明
  def currentTime(): Long = macro currentTimeImpl
  
  // 宏实现
  def currentTimeImpl(c: Context): c.Expr[Long] = {
    import c.universe._
    
    // 生成当前时间的代码
    c.Expr[Long](q"System.currentTimeMillis()")
  }
}

// 带参数的宏
object ParameterizedMacro {
  // 宏方法声明
  def debug(code: Any): Unit = macro debugImpl
  
  // 宏实现
  def debugImpl(c: Context)(code: c.Expr[Any]): c.Expr[Unit] = {
    import c.universe._
    
    // 获取代码的文本表示
    val codeString = code.tree.toString()
    
    // 生成打印代码和值的代码
    c.Expr[Unit](q"""println($codeString + ": " + $code)""")
  }
}

// 条件编译宏
object ConditionalMacro {
  // 宏方法声明
  def ifDebug(code: Any): Unit = macro ifDebugImpl
  
  // 宏实现
  def ifDebugImpl(c: Context)(code: c.Expr[Any]): c.Expr[Unit] = {
    import c.universe._
    
    // 检查是否为调试模式
    val isDebug = System.getProperty("debug", "false").toBoolean
    
    if (isDebug) {
      // 如果是调试模式，执行代码
      c.Expr[Unit](q"($code)")
    } else {
      // 否则生成空代码
      c.Expr[Unit](q"()")
    }
  }
}

// 使用宏的示例
object MacroExamples {
  def demonstrate(): Unit = {
    // 使用currentTime宏
    val time = SimpleMacro.currentTime()
    println(s"Current time: $time")
    
    // 使用debug宏
    val x = 42
    val y = 13
    val sum = x + y
    ParameterizedMacro.debug(sum)
    
    // 使用ifDebug宏
    ConditionalMacro.ifDebug(println("This is debug output"))
  }
}
```

### 12.3.2 高级宏技术

```scala
import scala.language.experimental.macros
import scala.reflect.macros.whitebox.Context

// 代码分析宏
object CodeAnalysisMacro {
  // 分析表达式类型的宏
  def analyzeType[T](expr: T): String = macro analyzeTypeImpl[T]
  
  def analyzeTypeImpl[T: c.WeakTypeTag](c: Context)(expr: c.Expr[T]): c.Expr[String] = {
    import c.universe._
    
    // 获取表达式类型
    val exprType = expr.actualType
    
    // 生成类型描述
    val typeDescription = s"""
       |Type: ${exprType}
       |TypeSymbol: ${exprType.typeSymbol}
       |Decls: ${exprType.decls}
       |Members: ${exprType.members}
     """.stripMargin
    
    c.Expr[String](q"$typeDescription")
  }
  
  // 分析表达式结构的宏
  def analyzeStructure[T](expr: T): String = macro analyzeStructureImpl[T]
  
  def analyzeStructureImpl[T](c: Context)(expr: c.Expr[T]): c.Expr[String] = {
    import c.universe._
    
    // 获取表达式树
    val tree = expr.tree
    
    // 生成结构描述
    def treeStructure(t: Tree): String = t match {
      case q"$lhs + $rhs" => s"Addition(${treeStructure(lhs)}, ${treeStructure(rhs)})"
      case q"$lhs * $rhs" => s"Multiplication(${treeStructure(lhs)}, ${treeStructure(rhs)})"
      case q"$lhs / $rhs" => s"Division(${treeStructure(lhs)}, ${treeStructure(rhs)})"
      case q"$lhs - $rhs" => s"Subtraction(${treeStructure(lhs)}, ${treeStructure(rhs)})"
      case q"$func(..$args)" => s"FunctionCall($func, args: ${args.map(treeStructure).mkString(", ")})"
      case Literal(Constant(value)) => s"Literal($value)"
      case Ident(name) => s"Identifier($name)"
      case Select(qualifier, name) => s"Select(${treeStructure(qualifier)}, $name)"
      case _ => s"Unknown(${t.productPrefix}[$t])"
    }
    
    val structure = treeStructure(tree)
    c.Expr[String](q"$structure")
  }
}

// 代码生成宏
object CodeGenerationMacro {
  // 生成equals方法的宏
  def generateEquals(): Any = macro generateEqualsImpl
  
  def generateEqualsImpl(c: Context): c.Expr[Any] = {
    import c.universe._
    
    // 获取当前类信息
    val enclosingClass = c.enclosingClass
    val fields = enclosingClass.info.decls.filter(_.isTerm && !_.isMethod && !_.isConstructor)
    
    // 生成equals方法
    val equalsChecks = fields.map { field =>
      val fieldName = field.name.toTermName
      q"if (this.$fieldName != other.$fieldName) return false"
    }
    
    val equalsMethod = q"""
      override def equals(other: Any): Boolean = {
        if (this == other) return true
        if (other == null || getClass != other.getClass) return false
        val otherAsThis = other.asInstanceOf[$enclosingClass]
        ..$equalsChecks
        return true
      }
    """
    
    c.Expr[Any](equalsMethod)
  }
  
  // 生成hashCode方法的宏
  def generateHashCode(): Any = macro generateHashCodeImpl
  
  def generateHashCodeImpl(c: Context): c.Expr[Any] = {
    import c.universe._
    
    // 获取当前类信息
    val enclosingClass = c.enclosingClass
    val fields = enclosingClass.info.decls.filter(_.isTerm && !_.isMethod && !_.isConstructor)
    
    // 生成hashCode方法
    val hashCalculations = fields.map { field =>
      val fieldName = field.name.toTermName
      q"31 * result + $fieldName.hashCode()"
    }
    
    val hashCodeMethod = q"""
      override def hashCode(): Int = {
        var result = 1
        ..$hashCalculations
        return result
      }
    """
    
    c.Expr[Any](hashCodeMethod)
  }
}

// 使用高级宏的示例
object AdvancedMacroExamples {
  // 用于演示的类
  case class Point(x: Int, y: Int)
  
  def demonstrate(): Unit = {
    val point = Point(10, 20)
    val sum = point.x + point.y
    
    // 使用类型分析宏
    println("=== Type Analysis ===")
    println(CodeAnalysisMacro.analyzeType(sum))
    
    // 使用结构分析宏
    println("\n=== Structure Analysis ===")
    println(CodeAnalysisMacro.analyzeStructure(sum))
    
    // 使用代码生成宏
    println("\n=== Code Generation ===")
    println("To see generated code, use the macros in a real Scala project with proper setup")
  }
}
```

## 12.4 宏应用场景

### 12.4.1 类型安全的API构建

```scala
import scala.language.experimental.macros
import scala.reflect.macros.blackbox.Context
import scala.util.{Try, Success, Failure}

// 类型安全的SQL构建器
object TypeSafeSQLBuilder {
  // SQL查询宏
  def SQL(query: String): SQLBuilder = macro SQLImpl
  
  // 宏实现
  def SQLImpl(c: Context)(query: c.Expr[String]): c.Expr[SQLBuilder] = {
    import c.universe._
    
    // 在实际应用中，这里会解析SQL字符串并生成类型安全的查询构建器
    // 这里只是一个简化的示例
    
    c.Expr[SQLBuilder](q"new SQLBuilder($query)")
  }
  
  // SQL构建器类
  class SQLBuilder(query: String) {
    def where(condition: String): SQLBuilder = {
      new SQLBuilder(s"$query WHERE $condition")
    }
    
    def orderBy(field: String): SQLBuilder = {
      new SQLBuilder(s"$query ORDER BY $field")
    }
    
    def limit(count: Int): SQLBuilder = {
      new SQLBuilder(s"$query LIMIT $count")
    }
    
    def execute(): String = {
      // 在实际应用中，这里会执行SQL查询
      s"Executing: $query"
    }
    
    override def toString: String = query
  }
}

// 类型安全的JSON构建器
object TypeSafeJSONBuilder {
  // JSON对象宏
  def json(fields: (String, Any)*): JSONBuilder = macro JSONImpl
  
  // 宏实现
  def JSONImpl(c: Context)(fields: c.Expr[(String, Any)]*): c.Expr[JSONBuilder] = {
    import c.universe._
    
    // 在实际应用中，这里会验证字段类型并生成类型安全的JSON构建器
    // 这里只是一个简化的示例
    
    val fieldList = fields.map(_.tree).toList
    c.Expr[JSONBuilder](q"new JSONBuilder(Map(..$fieldList))")
  }
  
  // JSON构建器类
  class JSONBuilder(fields: Map[String, Any]) {
    def set(field: String, value: Any): JSONBuilder = {
      new JSONBuilder(fields + (field -> value))
    }
    
    def remove(field: String): JSONBuilder = {
      new JSONBuilder(fields - field)
    }
    
    def build(): String = {
      // 在实际应用中，这里会生成实际的JSON
      val fieldStrings = fields.map { case (key, value) => s""""$key": "$value"""" }
      s"{${fieldStrings.mkString(", ")}}"
    }
    
    override def toString: String = build()
  }
}

// 使用类型安全API构建器的示例
object TypeSafeAPIBuilderExamples {
  def demonstrate(): Unit = {
    // 使用类型安全的SQL构建器
    println("=== Type-Safe SQL Builder ===")
    val sqlQuery = TypeSafeSQLBuilder.SQL("SELECT * FROM users")
      .where("age > 18")
      .orderBy("name")
      .limit(10)
    
    println(sqlQuery)
    println(sqlQuery.execute())
    
    // 使用类型安全的JSON构建器
    println("\n=== Type-Safe JSON Builder ===")
    val jsonObject = TypeSafeJSONBuilder.json(
      "name" -> "Alice",
      "age" -> 30,
      "email" -> "alice@example.com"
    ).set("active", true).remove("age")
    
    println(jsonObject)
  }
}
```

### 12.4.2 性能优化宏

```scala
import scala.language.experimental.macros
import scala.reflect.macros.whitebox.Context

// 字符串插值优化宏
object StringInterpolationOptimization {
  // 快速字符串连接宏
  implicit class FastStringContext(sc: StringContext) {
    def fast(args: Any*): String = macro fastStringImpl
  }
  
  def fastStringImpl(c: Context)(args: c.Expr[Any]*): c.Expr[String] = {
    import c.universe._
    
    // 获取字符串片段
    val parts = c.prefix.tree match {
      case Apply(Select(Apply(Ident(TermName("StringContext")), _), TermName("apply")), List(Apply(_, List(litParts)))) =>
        litParts match {
          case List(Apply(_, List(Literal(Constant(constString))))) => List(constString)
          case _ => c.abort(c.enclosingPosition, "Invalid string context")
        }
      case _ => c.abort(c.enclosingPosition, "Invalid string context")
    }
    
    // 在实际应用中，这里会生成更高效的字符串连接代码
    // 这里只是一个简化的示例
    
    // 对于简单的字符串连接，使用StringBuilder
    if (args.size > 3) {
      val sbName = TermName(c.freshName("sb"))
      
      val sbInit = q"val $sbName = new StringBuilder()"
      val sbAppends = parts.zip(args).map { case (part, arg) =>
        q"$sbName.append($part).append($arg)"
      }
      val sbAppendLast = if (parts.size > args.size) {
        q"$sbName.append(${parts.last})"
      } else q""
      
      val code = q"""
        $sbInit
        ..$sbAppends
        $sbAppendLast
        $sbName.toString
      """
      
      c.Expr[String](code)
    } else {
      // 对于少量参数，使用普通的字符串连接
      val strings = parts.zip(args).map { case (part, arg) => 
        q"$part + $arg.toString"
      }
      
      val lastPart = if (parts.size > args.size) {
        q"+ ${parts.last}"
      } else q""
      
      val code = strings.reduceLeft { (acc, expr) => q"$acc + $expr" }
      val finalCode = if (lastPart.isEmpty) code else q"$code $lastPart"
      
      c.Expr[String](finalCode)
    }
  }
}

// 集合操作优化宏
object CollectionOptimization {
  // 优化的map操作
  def optimizedMap[T, U](collection: T*)(f: T => U): List[U] = macro optimizedMapImpl[T, U]
  
  def optimizedMapImpl[T: c.WeakTypeTag, U: c.WeakTypeTag](c: Context)
                       (collection: c.Expr[T]*)(f: c.Expr[T => U]): c.Expr[List[U]] = {
    import c.universe._
    
    // 在实际应用中，这里会根据集合大小和类型生成优化的代码
    // 这里只是一个简化的示例
    
    if (collection.size > 100) {
      // 对于大集合，使用并行处理
      c.Expr[List[U]](q"${collection.toList}.par.map($f).toList")
    } else {
      // 对于小集合，使用顺序处理
      c.Expr[List[U]](q"${collection.toList}.map($f)")
    }
  }
  
  // 优化的filter操作
  def optimizedFilter[T](collection: T*)(predicate: T => Boolean): List[T] = macro optimizedFilterImpl[T]
  
  def optimizedFilterImpl[T: c.WeakTypeTag](c: Context)
                          (collection: c.Expr[T]*)(predicate: c.Expr[T => Boolean]): c.Expr[List[T]] = {
    import c.universe._
    
    // 在实际应用中，这里会根据集合大小和类型生成优化的代码
    // 这里只是一个简化的示例
    
    if (collection.size > 100) {
      // 对于大集合，使用并行处理
      c.Expr[List[T]](q"${collection.toList}.par.filter($predicate).toList")
    } else {
      // 对于小集合，使用顺序处理
      c.Expr[List[T]](q"${collection.toList}.filter($predicate)")
    }
  }
}

// 使用性能优化宏的示例
object PerformanceOptimizationExamples {
  def demonstrate(): Unit = {
    // 使用字符串插值优化宏
    println("=== String Interpolation Optimization ===")
    
    val name = "Alice"
    val age = 30
    val email = "alice@example.com"
    
    // 使用fast字符串插值
    val message = fast"Name: $name, Age: $age, Email: $email, Active: true"
    println(message)
    
    // 使用集合优化宏
    println("\n=== Collection Optimization ===")
    
    val numbers = 1 to 200
    val doubled = CollectionOptimization.optimizedMap(numbers: _*)(_ * 2)
    println(s"Doubled numbers size: ${doubled.size}")
    
    val evenNumbers = CollectionOptimization.optimizedFilter(numbers: _*)(_ % 2 == 0)
    println(s"Even numbers size: ${evenNumbers.size}")
    
    println("Performance optimizations applied at compile time")
  }
}
```

## 12.5 反射与宏的局限性

### 12.5.1 平台限制

```scala
import scala.reflect.runtime.universe._
import scala.util.{Try, Success, Failure}

// 反射与宏的平台限制
object ReflectionAndMacroLimitations {
  // 演示反射的限制
  def reflectionLimitations(): Unit = {
    println("=== Reflection Limitations ===")
    
    // 1. 类型擦除
    val list = List(1, 2, 3)
    val listType = typeOf[List[Int]]
    
    println(s"Type of List[Int]: $listType")
    println(s"Type args: ${listType.typeArgs}")
    
    // 运行时无法获取泛型类型信息
    val runtimeList = List(1, 2, 3)
    val runtimeListType = runtimeList.getClass.getTypeParameters
    println(s"Runtime type parameters: ${runtimeListType.mkString(", ")}")
    
    // 2. 无法获取私有方法的直接引用
    class PrivateMethods {
      private def privateMethod(): String = "private"
    }
    
    val instance = new PrivateMethods()
    val instanceMirror = runtimeMirror(instance.getClass.getClassLoader).reflect(instance)
    val classSymbol = instanceMirror.symbol
    
    // 无法直接调用私有方法
    Try {
      val privateMethod = classSymbol.info.decl(TermName("privateMethod")).asMethod
      val methodMirror = instanceMirror.reflectMethod(privateMethod)
      val result = methodMirror.apply()
      println(s"Private method result: $result")
    } match {
      case Success(result) => println(s"Unexpected success: $result")
      case Failure(exception) => println(s"Expected failure: ${exception.getMessage}")
    }
    
    // 3. 无法修改final类
    Try {
      final class FinalClass(val value: Int)
      
      val finalInstance = new FinalClass(42)
      val finalMirror = runtimeMirror(finalInstance.getClass.getClassLoader).reflect(finalInstance)
      val finalField = finalMirror.symbol.info.decl(TermName("value")).asTerm
      
      // 无法修改final字段
      finalField.asTerm.accessed.asTerm.set(finalInstance, 100)
    } match {
      case Success(result) => println(s"Unexpected success: $result")
      case Failure(exception) => println(s"Expected failure: ${exception.getMessage}")
    }
  }
  
  // 演示宏的限制
  def macroLimitations(): Unit = {
    println("\n=== Macro Limitations ===")
    
    // 1. 宏只在编译时运行
    println("1. Macros only run at compile time")
    println("   They can't analyze runtime values")
    println("   They can't generate code based on runtime conditions")
    
    // 2. 宏需要特殊设置
    println("2. Macros require special setup")
    println("   They need the scala-paradise plugin")
    println("   They need to be in a separate compilation unit")
    println("   They may have IDE support issues")
    
    // 3. 调试困难
    println("3. Debugging is difficult")
    println("   Generated code may not be visible")
    println("   Error messages can be cryptic")
    println("   Step-through debugging is not possible")
    
    // 4. 兼容性问题
    println("4. Compatibility issues")
    println("   Macro API may change between Scala versions")
    println("   Different Scala versions may have different macro systems")
    println("   Cross-compilation may be problematic")
  }
  
  // 安全限制
  def securityLimitations(): Unit = {
    println("\n=== Security Limitations ===")
    
    // 1. 反射可能违反封装
    println("1. Reflection can violate encapsulation")
    println("   Private fields and methods can be accessed")
    println("   Final classes can sometimes be modified")
    println("   This can lead to security vulnerabilities")
    
    // 2. 宏可能生成不安全的代码
    println("2. Macros can generate unsafe code")
    println("   Type safety may be compromised")
    println("   Runtime errors may be introduced")
    println("   Code injection attacks may be possible")
    
    // 3. 性能影响
    println("3. Performance impact")
    println("   Reflection is slower than direct calls")
    println("   Generated code may not be optimized")
    println("   JIT compilation may be affected")
  }
  
  def demonstrate(): Unit = {
    reflectionLimitations()
    macroLimitations()
    securityLimitations()
  }
}
```

### 12.5.2 替代方案

```scala
// 反射与宏的替代方案
object AlternativesToReflectionAndMacros {
  // 1. 使用类型类替代反射
  object TypeClassAlternative {
    trait Show[T] {
      def show(value: T): String
    }
    
    object Show {
      implicit val intShow: Show[Int] = new Show[Int] {
        def show(value: Int): String = s"Int($value)"
      }
      
      implicit val stringShow: Show[String] = new Show[String] {
        def show(value: String): String = s"String($value)"
      }
      
      def apply[T](value: T)(implicit show: Show[T]): String = {
        show.show(value)
      }
    }
    
    def demonstrate(): Unit = {
      println("=== Type Class Alternative ===")
      println(Show(42))
      println(Show("hello"))
    }
  }
  
  // 2. 使用构建器模式替代反射
  object BuilderPatternAlternative {
    case class Person(name: String, age: Int, email: Option[String])
    
    object Person {
      def builder(name: String): PersonBuilder = new PersonBuilder(name)
    }
    
    class PersonBuilder(name: String) {
      private var age: Int = 0
      private var email: Option[String] = None
      
      def withAge(age: Int): PersonBuilder = {
        this.age = age
        this
      }
      
      def withEmail(email: String): PersonBuilder = {
        this.email = Some(email)
        this
      }
      
      def build(): Person = {
        new Person(name, age, email)
      }
    }
    
    def demonstrate(): Unit = {
      println("\n=== Builder Pattern Alternative ===")
      val person = Person.builder("Alice")
        .withAge(30)
        .withEmail("alice@example.com")
        .build()
      
      println(person)
    }
  }
  
  // 3. 使用代码生成替代反射
  object CodeGenerationAlternative {
    // 在实际应用中，可以使用代码生成工具如SBT的sourceGenerator
    // 这里只是一个概念性的示例
    
    // 假设有一个代码生成器，为每个case class生成DAO类
    case class User(id: Long, name: String, email: String)
    
    // 生成的UserDAO类（概念性）
    class UserDAO {
      def findById(id: Long): Option[User] = {
        // 实现查找逻辑
        Some(User(id, "Generated Name", "generated@example.com"))
      }
      
      def save(user: User): User = {
        // 实现保存逻辑
        user
      }
      
      def delete(id: Long): Boolean = {
        // 实现删除逻辑
        true
      }
    }
    
    def demonstrate(): Unit = {
      println("\n=== Code Generation Alternative ===")
      val userDao = new UserDAO()
      val user = userDao.findById(1L)
      println(s"Found user: $user")
    }
  }
  
  // 4. 使用注解处理器替代宏
  object AnnotationProcessorAlternative {
    // 在Java中，可以使用注解处理器
    // 在Scala中，可以使用Meta-Scala或其他类似工具
    
    // 概念性示例：使用注解生成代码
    import scala.annotation.StaticAnnotation
    
    class Entity extends StaticAnnotation
    class Id extends StaticAnnotation
    class Column(name: String) extends StaticAnnotation
    
    @Entity
    case class Product(
      @Id @Column("product_id") id: Long,
      @Column("name") name: String,
      @Column("price") price: Double
    )
    
    // 注解处理器可以生成DAO类、查询对象等
    
    def demonstrate(): Unit = {
      println("\n=== Annotation Processor Alternative ===")
      println("Annotation processors can generate code at compile time")
      println("This can be an alternative to macros for some use cases")
      println("Examples: Lombok in Java, Meta-Scala in Scala")
    }
  }
  
  def demonstrate(): Unit = {
    TypeClassAlternative.demonstrate()
    BuilderPatternAlternative.demonstrate()
    CodeGenerationAlternative.demonstrate()
    AnnotationProcessorAlternative.demonstrate()
  }
}
```

## 12.6 最佳实践

### 12.6.1 反射最佳实践

```scala
import scala.reflect.runtime.universe._
import scala.util.{Try, Success, Failure}

// 反射最佳实践
object ReflectionBestPractices {
  // 1. 缓存反射结果
  object ReflectionCache {
    private val methodCache = scala.collection.mutable.Map[String, MethodSymbol]()
    private val fieldCache = scala.collection.mutable.Map[String, TermSymbol]()
    
    def getMethod(className: String, methodName: String): Option[MethodSymbol] = {
      val key = s"$className.$methodName"
      methodCache.get(key).orElse {
        val classSymbol = runtimeMirror(this.getClass.getClassLoader)
          .staticClass(className)
        
        val method = classSymbol.info.decl(TermName(methodName)).asMethod
        methodCache(key) = method
        Some(method)
      }
    }
    
    def getField(className: String, fieldName: String): Option[TermSymbol] = {
      val key = s"$className.$fieldName"
      fieldCache.get(key).orElse {
        val classSymbol = runtimeMirror(this.getClass.getClassLoader)
          .staticClass(className)
        
        val field = classSymbol.info.decl(TermName(fieldName)).asTerm
        fieldCache(key) = field
        Some(field)
      }
    }
  }
  
  // 2. 使用类型标记
  object TypeTagUsage {
    def processCollection[T: TypeTag](collection: Traversable[T]): Unit = {
      val tpe = typeOf[T]
      
      if (tpe <:< typeOf[Int]) {
        println(s"Processing Int collection: ${collection.sum}")
      } else if (tpe <:< typeOf[String]) {
        println(s"Processing String collection: ${collection.mkString(", ")}")
      } else {
        println(s"Processing unknown collection of type: $tpe")
      }
    }
  }
  
  // 3. 安全的反射操作
  object SafeReflection {
    def safeMethodCall(instance: Any, methodName: String, args: Any*): Option[Any] = {
      Try {
        val instanceMirror = runtimeMirror(instance.getClass.getClassLoader).reflect(instance)
        val classSymbol = instanceMirror.symbol
        
        // 查找匹配参数的方法
        val method = classSymbol.info.decl(TermName(methodName)).asMethod
        
        // 验证参数类型
        val paramTypes = method.paramLists.flatten.map(_.typeSignature)
        val argTypes = args.map(arg => runtimeMirror(arg.getClass.getClassLoader).reflect(arg).symbol.toType)
        
        if (paramTypes.length != argTypes.length) {
          throw new IllegalArgumentException(s"Parameter count mismatch: expected ${paramTypes.length}, got ${argTypes.length}")
        }
        
        if (!paramTypes.zip(argTypes).forall { case (expected, actual) => actual <:< expected }) {
          throw new IllegalArgumentException("Parameter type mismatch")
        }
        
        val methodMirror = instanceMirror.reflectMethod(method)
        methodMirror.apply(args: _*)
      }.toOption
    }
  }
  
  // 4. 限制反射使用范围
  class ReflectionManager private() {
    private val allowedClasses = Set("com.example.User", "com.example.Product")
    
    def isClassAllowed(className: String): Boolean = {
      allowedClasses.contains(className)
    }
    
    def createInstance(className: String): Option[Any] = {
      if (!isClassAllowed(className)) {
        return None
      }
      
      Try {
        val classSymbol = runtimeMirror(this.getClass.getClassLoader)
          .staticClass(className)
        
        val constructor = classSymbol.primaryConstructor.asMethod
        val classMirror = runtimeMirror(this.getClass.getClassLoader)
          .reflectClass(classSymbol)
        
        val constructorMirror = classMirror.reflectConstructor(constructor)
        constructorMirror.apply()
      }.toOption
    }
  }
  
  object ReflectionManager {
    private val instance = new ReflectionManager()
    
    def apply(): ReflectionManager = instance
  }
  
  def demonstrate(): Unit = {
    // 缓存反射结果
    println("=== Reflection Caching ===")
    ReflectionCache.getMethod("java.lang.String", "length").foreach { method =>
      println(s"Method: $method")
    }
    
    // 使用类型标记
    println("\n=== Type Tag Usage ===")
    TypeTagUsage.processCollection(List(1, 2, 3, 4, 5))
    TypeTagUsage.processCollection(List("hello", "world", "scala"))
    
    // 安全的反射操作
    println("\n=== Safe Reflection ===")
    val safeResult = SafeReflection.safeMethodCall("hello", "length")
    println(s"Safe method call result: $safeResult")
    
    val unsafeResult = SafeReflection.safeMethodCall("hello", "nonExistentMethod")
    println(s"Unsafe method call result: $unsafeResult")
    
    // 限制反射使用范围
    println("\n=== Reflection Usage Limits ===")
    val allowedInstance = ReflectionManager().createInstance("java.lang.String")
    println(s"Allowed instance: $allowedInstance")
    
    val disallowedInstance = ReflectionManager().createInstance("java.lang.Object")
    println(s"Disallowed instance: $disallowedInstance")
  }
}
```

### 12.6.2 宏最佳实践

```scala
import scala.language.experimental.macros
import scala.reflect.macros.whitebox.Context

// 宏最佳实践
object MacroBestPractices {
  // 1. 保持宏简单和专注
  object SimpleMacros {
    // 好的示例：简单的日志宏
    def debug(message: String): Unit = macro debugImpl
    
    def debugImpl(c: Context)(message: c.Expr[String]): c.Expr[Unit] = {
      import c.universe._
      
      // 检查是否启用调试
      if (System.getProperty("debug", "false").toBoolean) {
        c.Expr[Unit](q"println($message)")
      } else {
        c.Expr[Unit](q"()")
      }
    }
    
    // 不好的示例：复杂的宏，做了太多事情
    def complexMacro(param1: Int, param2: String): Any = macro complexMacroImpl
    
    def complexMacroImpl(c: Context)(param1: c.Expr[Int], param2: c.Expr[String]): c.Expr[Any] = {
      import c.universe._
      
      // 这个宏做了太多事情：验证、转换、日志记录等
      // 应该分解为多个更小的宏
      c.abort(c.enclosingPosition, "This macro is too complex")
    }
  }
  
  // 2. 提供清晰的错误消息
  object ClearErrorMessages {
    def validate(value: Int): Unit = macro validateImpl
    
    def validateImpl(c: Context)(value: c.Expr[Int]): c.Expr[Unit] = {
      import c.universe._
      
      value.tree match {
        case Literal(Constant(v: Int)) if v < 0 =>
          c.abort(c.enclosingPosition, s"Value must be non-negative, but got $v")
        case _ =>
          c.Expr[Unit](q"if ($value < 0) throw new IllegalArgumentException(\"Value must be non-negative\")")
      }
    }
  }
  
  // 3. 使用明确的类型签名
  object ExplicitTypeSignatures {
    def create[T]: T = macro createImpl[T]
    
    def createImpl[T: c.WeakTypeTag](c: Context): c.Expr[T] = {
      import c.universe._
      
      val tpe = weakTypeOf[T]
      
      // 提供明确的类型信息，而不是使用模糊的类型
      tpe match {
        case t if t <:< typeOf[String] =>
          c.Expr[T](q""" "".asInstanceOf[$tpe] """)
        case t if t <:< typeOf[Int] =>
          c.Expr[T](q""" 0.asInstanceOf[$tpe] """)
        case _ =>
          c.abort(c.enclosingPosition, s"Cannot create instance of type $tpe")
      }
    }
  }
  
  // 4. 测试生成的代码
  object TestedMacros {
    def add(x: Int, y: Int): Int = macro addImpl
    
    def addImpl(c: Context)(x: c.Expr[Int], y: c.Expr[Int]): c.Expr[Int] = {
      import c.universe._
      
      // 生成简单的加法代码
      c.Expr[Int](q"$x + $y")
    }
    
    // 测试宏生成的代码
    def testGeneratedCode(): Unit = {
      val result = add(5, 3)
      assert(result == 8, "Addition macro should work correctly")
      println("Addition macro test passed")
    }
  }
  
  // 5. 文档化宏的行为
  object DocumentedMacros {
    /**
      * 简单的数学宏，执行基本的算术运算
      * 
      * @param x 第一个操作数
      * @param y 第二个操作数
      * @return x和y的和
      * 
      * 示例：
      * {{{
      * val result = add(5, 3)  // 结果: 8
      * }}}
      */
    def add(x: Int, y: Int): Int = macro addImpl
    
    def addImpl(c: Context)(x: c.Expr[Int], y: c.Expr[Int]): c.Expr[Int] = {
      import c.universe._
      
      // 添加注释到生成的代码
      c.Expr[Int](q"""
        // Generated by add macro
        // This performs integer addition
        val temp = $x + $y
        temp
      """)
    }
  }
  
  def demonstrate(): Unit = {
    // 简单宏
    println("=== Simple Macros ===")
    SimpleMacros.debug("Debug message")
    
    // 清晰的错误消息
    println("\n=== Clear Error Messages ===")
    try {
      ClearErrorMessages.validate(-5)
    } catch {
      case e: Exception => println(s"Expected error: ${e.getMessage}")
    }
    
    try {
      ClearErrorMessages.validate(5)
      println("Validation passed for positive value")
    } catch {
      case e: Exception => println(s"Unexpected error: ${e.getMessage}")
    }
    
    // 明确的类型签名
    println("\n=== Explicit Type Signatures ===")
    val stringValue = ExplicitTypeSignatures.create[String]
    val intValue = ExplicitTypeSignatures.create[Int]
    println(s"String: '$stringValue', Int: $intValue")
    
    // 测试生成的代码
    println("\n=== Tested Macros ===")
    TestedMacros.testGeneratedCode()
    
    // 文档化的宏
    println("\n=== Documented Macros ===")
    val sum = DocumentedMacros.add(10, 20)
    println(s"Sum: $sum")
  }
}
```

## 总结

Scala的元编程能力提供了强大的代码分析和生成机制：

1. **反射**：允许在运行时检查和操作类型、方法和字段
2. **注解**：提供了一种向代码添加元数据的方式
3. **宏**：允许在编译时分析、转换和生成代码

这些技术使得Scala能够实现高度灵活和可扩展的代码结构，但也带来了复杂性和潜在的性能问题。在使用这些高级特性时，应该遵循最佳实践，谨慎权衡其带来的收益和成本。

元编程在以下场景中特别有用：
- 生成样板代码
- 实现领域特定语言（DSL）
- 构建类型安全的API
- 实现编译时优化
- 进行代码分析和验证

然而，也要注意反射和宏的局限性，并考虑使用替代方案，如类型类、构建器模式或代码生成工具。