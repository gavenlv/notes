# 第6章 模式匹配与正则表达式

## 目录
- [6.1 模式匹配基础](#61-模式匹配基础)
- [6.2 常量模式与变量模式](#62-常量模式与变量模式)
- [6.3 构造器模式](#63-构造器模式)
- [6.4 序列模式](#64-序列模式)
- [6.5 元组模式](#65-元组模式)
- [6.6 类型模式](#66-类型模式)
- [6.7 模式守卫](#67-模式守卫)
- [6.8 密封类与模式匹配](#68-密封类与模式匹配)
- [6.9 正则表达式](#69-正则表达式)
- [6.10 提取器](#610-提取器)

## 6.1 模式匹配基础

### 什么是模式匹配

模式匹配是Scala中的一个强大特性，它允许我们根据值的结构来检查该值，并相应地执行代码。类似于Java中的switch语句，但功能强大得多。

### 基本match表达式

```scala
// 基本match表达式
def describe(x: Any): String = x match {
  case 1 => "One"
  case 2 => "Two"
  case "hello" => "Greeting"
  case true => "Truth"
  case _ => "Unknown"  // 默认情况，类似于default
}

println(describe(1))      // One
println(describe(3))      // Unknown
println(describe("hello")) // Greeting

// match作为表达式
def classify(n: Int): String = {
  val category = n match {
    case n if n < 0 => "Negative"
    case 0 => "Zero"
    case n if n > 0 => "Positive"
  }
  s"$n is $category"
}

println(classify(-5))  // -5 is Negative
println(classify(0))   // 0 is Zero
println(classify(5))   // 5 is Positive

// 与if-else的比较
def maxUsingIf(a: Int, b: Int): Int = {
  if (a > b) a else b
}

def maxUsingMatch(a: Int, b: Int): Int = {
  (a, b) match {
    case (x, y) if x > y => x
    case (_, y) => y
  }
}

println(maxUsingIf(3, 5))   // 5
println(maxUsingMatch(3, 5)) // 5
```

### 模式匹配的返回值

```scala
// 模式匹配返回不同类型
def process(x: Any): String = x match {
  case s: String => s"String of length ${s.length}"
  case i: Int => s"Integer value $i"
  case d: Double => s"Double value ${d.formatted("%.2f")}"
  case list: List[_] => s"List with ${list.size} elements"
  case _ => s"Unknown type: ${x.getClass.getSimpleName}"
}

println(process("Hello"))                // String of length 5
println(process(42))                      // Integer value 42
println(process(3.14159))                // Double value 3.14
println(process(List(1, 2, 3)))          // List with 3 elements
println(process(Map("key" -> "value")))  // Unknown type: Map

// 模式匹配用于函数定义
val describeNumber: Int => String = {
  case n if n % 2 == 0 => s"$n is even"
  case n => s"$n is odd"
}

println(describeNumber(2))  // 2 is even
println(describeNumber(3))  // 3 is odd
```

### 模式匹配的穷尽性检查

```scala
// 非穷尽匹配（编译器警告）
sealed trait DayOfWeek
case object Monday extends DayOfWeek
case object Tuesday extends DayOfWeek
case object Wednesday extends DayOfWeek
case object Thursday extends DayOfWeek
case object Friday extends DayOfWeek
case object Saturday extends DayOfWeek
case object Sunday extends DayOfWeek

// 非穷尽匹配（缺少一些情况）
def isWeekday(day: DayOfWeek): Boolean = day match {
  case Monday => true
  case Tuesday => true
  case Wednesday => true
  case Thursday => true
  case Friday => true
  // 缺少Saturday和Sunday，编译器会警告
}

// 穷尽匹配（编译器确保覆盖所有情况）
def isWeekdayExhaustive(day: DayOfWeek): Boolean = day match {
  case Monday => true
  case Tuesday => true
  case Wednesday => true
  case Thursday => true
  case Friday => true
  case Saturday => false
  case Sunday => false
}

// 使用@unchecked抑制警告
def isWeekdayUnchecked(day: DayOfWeek): Boolean = (day: @unchecked) match {
  case Monday | Tuesday | Wednesday | Thursday | Friday => true
  // 使用@unchecked告诉编译器我们确认匹配是完整的
}
```

## 6.2 常量模式与变量模式

### 常量模式

```scala
// 常量模式匹配字面量
def matchLiteral(x: Any): String = x match {
  case 1 => "One"
  case 2 => "Two"
  case "hello" => "Hello string"
  case 'a' => "Character a"
  case 3.14 => "Pi"
  case true => "True boolean"
  case false => "False boolean"
  case null => "Null value"
  case _ => "Something else"
}

println(matchLiteral(1))        // One
println(matchLiteral("hello"))   // Hello string
println(matchLiteral('a'))       // Character a
println(matchLiteral(3.14))      // Pi
println(matchLiteral(true))      // True boolean
println(matchLiteral(false))     // False boolean
println(matchLiteral(null))      // Null value

// 常量模式匹配命名常量
object Constants {
  val PI = 3.14159
  val E = 2.71828
  val MAX_VALUE = 100
}

def matchConstant(x: Double): String = x match {
  case Constants.PI => "It's Pi!"
  case Constants.E => "It's E!"
  case _ => s"Unknown value: $x"
}

println(matchConstant(3.14159))  // It's Pi!
println(matchConstant(2.71828))  // It's E!
println(matchConstant(1.618))    // Unknown value: 1.618
```

### 变量模式

```scala
// 变量模式匹配任何值并绑定到变量
def matchVariable(x: Any): String = x match {
  case x => s"Got value: $x"
  case y => s"This case is unreachable"  // 永远不会到达
}

println(matchVariable(42))      // Got value: 42
println(matchVariable("hello")) // Got value: hello

// 变量模式与通配符模式的区别
def comparePatterns(value: Int): Unit = {
  value match {
    case x => println(s"Variable pattern: Got $x")
    case _ => println("Wildcard pattern: Got something")  // 永远不会执行
  }
  
  value match {
    case 1 => println("Constant pattern: Got 1")
    case _ => println("Wildcard pattern: Got something else")
  }
}

comparePatterns(1)  // Variable pattern: Got 1, Constant pattern: Got 1
comparePatterns(2)  // Variable pattern: Got 2, Wildcard pattern: Got something else

// 在复杂模式中使用变量
def describeList(lst: List[Int]): String = lst match {
  case List() => "Empty list"
  case List(x) => s"Single element list: $x"
  case List(x, y) => s"Two element list: $x, $y"
  case x :: y :: rest => s"List starting with $x, $y and ${rest.size} more elements"
}

println(describeList(List()))               // Empty list
println(describeList(List(1)))              // Single element list: 1
println(describeList(List(1, 2)))           // Two element list: 1, 2
println(describeList(List(1, 2, 3, 4, 5)))  // List starting with 1, 2 and 3 more elements
```

### 模式中的变量绑定

```scala
// 使用@符号将匹配结果绑定到变量
def matchWithBinding(x: Any): String = x match {
  case list @ List(1, 2, _*) => s"List starting with 1, 2: $list"
  case tuple @ (a, b, c) => s"3-tuple with values: $a, $b, $c"
  case map @ Map("key" -> value) => s"Map with key 'key' and value $value: $map"
  case other => s"Something else: $other"
}

println(matchWithBinding(List(1, 2, 3, 4)))           // List starting with 1, 2: List(1, 2, 3, 4)
println(matchWithBinding(Tuple3(1, 2, 3)))             // 3-tuple with values: 1, 2, 3
println(matchWithBinding(Map("key" -> "value")))        // Map with key 'key' and value value: Map(key -> value)
println(matchWithBinding("Just a string"))              // Something else: Just a string

// 嵌套模式中的变量绑定
def matchNestedStructure(x: Any): String = x match {
  case List(head @ List(_, _), _*) => s"First element is a list: $head"
  case (first @ (a, b), second) => s"First element is a tuple: $first"
  case person @ Person(name, age) if age > 30 => s"Person over 30: $person"
  case other => s"Other: $other"
}

case class Person(name: String, age: Int)

println(matchNestedStructure(List(List(1, 2), 3, 4)))     // First element is a list: List(1, 2)
println(matchNestedStructure(((1, 2), 3)))                  // First element is a tuple: (1,2)
println(matchNestedStructure(Person("Alice", 35)))        // Person over 30: Person(Alice,35)
println(matchNestedStructure(Person("Bob", 25)))            // Other: Person(Bob,25)
```

## 6.3 构造器模式

### 样例类匹配

```scala
// 定义样例类
case class Point(x: Int, y: Int)
case class Circle(center: Point, radius: Double)
case class Rectangle(topLeft: Point, bottomRight: Point)

// 构造器模式匹配样例类
def describeShape(shape: Any): String = shape match {
  case Point(x, y) => s"Point at ($x, $y)"
  case Circle(Point(x, y), r) => s"Circle centered at ($x, $y) with radius $r"
  case Rectangle(Point(x1, y1), Point(x2, y2)) => 
    s"Rectangle from ($x1, $y1) to ($x2, $y2)"
  case _ => "Unknown shape"
}

val p1 = Point(2, 3)
val c1 = Circle(Point(0, 0), 5.0)
val r1 = Rectangle(Point(0, 10), Point(10, 0))

println(describeShape(p1))  // Point at (2, 3)
println(describeShape(c1))  // Circle centered at (0, 0) with radius 5.0
println(describeShape(r1))  // Rectangle from (0, 10) to (10, 0)

// 嵌套样例类匹配
case class Person(name: String, age: Int, address: Address)
case class Address(street: String, city: String, zipCode: String)

def describePerson(person: Person): String = person match {
  case Person("Alice", age, Address(_, "New York", _)) => 
    s"Alice from New York, age $age"
  case Person(name, age, Address(street, city, zip)) if age >= 18 => 
    s"Adult $name from $city at $street, $zip"
  case Person(name, age, _) => 
    s"$name, age $age"
}

val alice = Person("Alice", 30, Address("123 Main St", "New York", "10001"))
val bob = Person("Bob", 25, Address("456 Oak Ave", "Boston", "02101"))
val charlie = Person("Charlie", 15, Address("789 Pine St", "Chicago", "60601"))

println(describePerson(alice))    // Alice from New York, age 30
println(describePerson(bob))      // Adult Bob from Boston at 456 Oak Ave, 02101
println(describePerson(charlie))   // Charlie, age 15
```

### 非样例类匹配

```scala
// 非样例类需要定义unapply方法
class Account(val id: String, val balance: Double) {
  def deposit(amount: Double): Account = new Account(id, balance + amount)
  def withdraw(amount: Double): Account = new Account(id, balance - amount)
}

object Account {
  // 提取器方法
  def apply(id: String, balance: Double): Account = new Account(id, balance)
  
  // 用于模式匹配
  def unapply(account: Account): Option[(String, Double)] = 
    Some((account.id, account.balance))
}

def describeAccount(account: Account): String = account match {
  case Account(id, balance) if balance > 1000 => 
    s"Premium account $id with balance $balance"
  case Account(id, balance) if balance > 0 => 
    s"Regular account $id with balance $balance"
  case Account(id, 0) => 
    s"Empty account $id"
  case Account(id, balance) => 
    s"Account $id with negative balance $balance"
}

val account1 = new Account("12345", 1500.0)
val account2 = new Account("67890", 500.0)
val account3 = new Account("11111", 0.0)
val account4 = new Account("22222", -100.0)

println(describeAccount(account1))  // Premium account 12345 with balance 1500.0
println(describeAccount(account2))  // Regular account 67890 with balance 500.0
println(describeAccount(account3))  // Empty account 11111
println(describeAccount(account4))  // Account 22222 with negative balance -100.0

// 自定义提取器
object Even {
  def unapply(x: Int): Option[Int] = if (x % 2 == 0) Some(x) else None
}

object Odd {
  def unapply(x: Int): Option[Int] = if (x % 2 != 0) Some(x) else None
}

def describeNumber(num: Int): String = num match {
  case Even(x) => s"$x is even"
  case Odd(x) => s"$x is odd"
}

println(describeNumber(2))  // 2 is even
println(describeNumber(3))  // 3 is odd
```

### 复杂构造器模式

```scala
// 复杂样例类
case class Employee(
  name: String,
  position: String,
  manager: Option[Employee] = None,
  subordinates: List[Employee] = List.empty
)

// 复杂构造器模式匹配
def describeEmployee(emp: Employee): String = emp match {
  case Employee(name, position, None, Nil) => 
    s"$name is a solo $position"
  case Employee(name, position, Some(manager), Nil) => 
    s"$name is a $position reporting to ${manager.name}"
  case Employee(name, position, None, subordinates) => 
    s"$name is a $position managing ${subordinates.size} people"
  case Employee(name, position, Some(manager), subordinates) => 
    s"$name is a $position reporting to ${manager.name} and managing ${subordinates.size} people"
}

// 创建组织结构
val ceo = Employee("Alice", "CEO")
val cto = Employee("Bob", "CTO", Some(ceo))
val dev1 = Employee("Charlie", "Developer", Some(cto))
val dev2 = Employee("David", "Developer", Some(cto))
val cfo = Employee("Eve", "CFO", Some(ceo))

// 更新员工关系
val updatedCTO = cto.copy(subordinates = List(dev1, dev2))
val updatedCEO = ceo.copy(subordinates = List(updatedCTO, cfo))

println(describeEmployee(dev1))      // Charlie is a Developer reporting to Bob
println(describeEmployee(cto))       // Bob is a CTO managing 2 people
println(describeEmployee(ceo))       // Alice is a CEO managing 2 people
println(describeEmployee(cfo))       // Eve is a CFO reporting to Alice

// 使用构造器模式处理数据结构
case class TreeNode(value: Int, left: Option[TreeNode], right: Option[TreeNode])

def treeSum(node: TreeNode): Int = node match {
  case TreeNode(value, None, None) => value
  case TreeNode(value, Some(left), None) => value + treeSum(left)
  case TreeNode(value, None, Some(right)) => value + treeSum(right)
  case TreeNode(value, Some(left), Some(right)) => 
    value + treeSum(left) + treeSum(right)
}

// 创建树结构
val tree = TreeNode(
  5,
  Some(TreeNode(3, Some(TreeNode(1, None, None)), Some(TreeNode(4, None, None)))),
  Some(TreeNode(7, Some(TreeNode(6, None, None)), Some(TreeNode(9, None, None)))
)

println(s"Tree sum: ${treeSum(tree)}")  // Tree sum: 35
```

## 6.4 序列模式

### List模式

```scala
// List模式匹配
def describeList(lst: List[Int]): String = lst match {
  case Nil => "Empty list"
  case List(x) => s"Single element: $x"
  case List(x, y) => s"Two elements: $x, $y"
  case List(x, y, z) => s"Three elements: $x, $y, $z"
  case x :: y :: z :: rest => s"At least three elements: $x, $y, $z and more"
}

println(describeList(List()))               // Empty list
println(describeList(List(1)))              // Single element: 1
println(describeList(List(1, 2)))           // Two elements: 1, 2
println(describeList(List(1, 2, 3)))        // Three elements: 1, 2, 3
println(describeList(List(1, 2, 3, 4, 5)))  // At least three elements: 1, 2, 3 and more

// 使用序列模式处理列表
def processList(lst: List[String]): String = lst match {
  case "start" :: "middle" :: "end" :: Nil => "Exact sequence"
  case "start" :: middle :+ "end" => s"Starts with 'start', ends with 'end', middle: $middle"
  case "start" :: rest => s"Starts with 'start', rest: $rest"
  case prefix :+ "end" => s"Ends with 'end', prefix: $prefix"
  case head :: tail => s"List starts with $head"
  case Nil => "Empty list"
}

println(processList(List("start", "middle", "end")))      // Exact sequence
println(processList(List("start", "a", "b", "end")))     // Starts with 'start', ends with 'end', middle: List(a, b)
println(processList(List("start", "a", "b", "c")))       // Starts with 'start', rest: List(a, b, c)
println(processList(List("a", "b", "c", "end")))         // Ends with 'end', prefix: List(a, b, c)
println(processList(List("hello", "world")))              // List starts with hello
println(processList(List()))                              // Empty list
```

### Vector和数组模式

```scala
// Vector模式
def describeVector(vec: Vector[Int]): String = vec match {
  case Vector() => "Empty vector"
  case Vector(x) => s"Single element: $x"
  case Vector(x, y) => s"Two elements: $x, $y"
  case Vector(x, y, z) => s"Three elements: $x, $y, $z"
  case Vector(x, y, rest @ _*) => s"At least two elements: $x, $y and ${rest.size} more"
}

println(describeVector(Vector()))                   // Empty vector
println(describeVector(Vector(1)))                  // Single element: 1
println(describeVector(Vector(1, 2)))               // Two elements: 1, 2
println(describeVector(Vector(1, 2, 3)))            // Three elements: 1, 2, 3
println(describeVector(Vector(1, 2, 3, 4, 5)))     // At least two elements: 1, 2 and 3 more

// 数组模式
def describeArray(arr: Array[String]): String = arr match {
  case Array() => "Empty array"
  case Array(x) => s"Single element: $x"
  case Array(x, y) => s"Two elements: $x, $y"
  case Array(x, y, z) => s"Three elements: $x, $y, $z"
  case Array("first", rest @ _*) => s"Starts with 'first', rest: ${rest.mkString(", ")}"
  case Array(prefix @ _*, "last") => s"Ends with 'last', prefix: ${prefix.mkString(", ")}"
  case Array(prefix @ _*, "middle", suffix @ _*) => s"Contains 'middle', prefix: ${prefix.mkString(", ")}, suffix: ${suffix.mkString(", ")}"
}

println(describeArray(Array()))                                    // Empty array
println(describeArray(Array("one")))                                // Single element: one
println(describeArray(Array("one", "two")))                         // Two elements: one, two
println(describeArray(Array("first", "second", "third")))           // Starts with 'first', rest: second, third
println(describeArray(Array("a", "b", "c", "last")))                // Ends with 'last', prefix: a, b, c
println(describeArray(Array("a", "b", "middle", "c", "d")))         // Contains 'middle', prefix: a, b, suffix: c, d
```

### 复杂序列模式

```scala
// 复杂序列模式
def analyzeSequence(seq: Seq[Int]): String = seq match {
  case Seq() => "Empty sequence"
  case Seq(x) => s"Single element: $x"
  case Seq(x, y) => s"Two elements: $x, $y"
  case Seq(x, y, z) => s"Three elements: $x, $y, $z"
  case Seq(x, y, rest @ _*) => s"At least two elements: $x, $y and ${rest.size} more"
  case head +: tail if head > tail.sum => s"Head $head is greater than sum of tail"
  case prefix :+ last if last % 2 == 0 => s"Ends with even number $last, prefix: $prefix"
  case pattern if pattern.sum == 0 => "Sum is zero"
  case pattern if pattern.forall(_ % 2 == 0) => "All elements are even"
  case pattern if pattern.forall(_ % 2 != 0) => "All elements are odd"
  case pattern => s"General sequence: $pattern"
}

println(analyzeSequence(Seq()))                       // Empty sequence
println(analyzeSequence(Seq(5)))                      // Single element: 5
println(analyzeSequence(Seq(10, 2, 3)))              // Head 10 is greater than sum of tail
println(analyzeSequence(Seq(1, 2, 3, 4, 6)))          // Ends with even number 6, prefix: List(1, 2, 3, 4)
println(analyzeSequence(Seq(1, -1, 2, -2)))           // Sum is zero
println(analyzeSequence(Seq(2, 4, 6, 8)))             // All elements are even
println(analyzeSequence(Seq(1, 3, 5, 7)))             // All elements are odd
println(analyzeSequence(Seq(1, 2, 3, 4)))             // General sequence: List(1, 2, 3, 4)

// 嵌套序列模式
case class Matrix(rows: Vector[Vector[Int]])

def describeMatrix(matrix: Matrix): String = matrix match {
  case Matrix(Vector()) => "Empty matrix"
  case Matrix(Vector(Vector())) => "Matrix with empty row"
  case Matrix(Vector(Vector(x))) => s"1x1 matrix: $x"
  case Matrix(Vector(Vector(x, y))) => s"1x2 matrix: $x, $y"
  case Matrix(Vector(Vector(x), Vector(y))) => s"2x1 matrix: $x, $y"
  case Matrix(Vector(Vector(x, y), Vector(z, w))) => s"2x2 matrix: $x, $y, $z, $w"
  case Matrix(Vector(firstRow, otherRows @ _*)) => 
    s"Matrix with ${otherRows.size + 1} rows, first row: ${firstRow.mkString(", ")}"
}

val m1 = Matrix(Vector())
val m2 = Matrix(Vector(Vector()))
val m3 = Matrix(Vector(Vector(1)))
val m4 = Matrix(Vector(Vector(1, 2)))
val m5 = Matrix(Vector(Vector(1), Vector(2)))
val m6 = Matrix(Vector(Vector(1, 2), Vector(3, 4)))
val m7 = Matrix(Vector(Vector(1, 2, 3), Vector(4, 5, 6), Vector(7, 8, 9)))

println(describeMatrix(m1))  // Empty matrix
println(describeMatrix(m2))  // Matrix with empty row
println(describeMatrix(m3))  // 1x1 matrix: 1
println(describeMatrix(m4))  // 1x2 matrix: 1, 2
println(describeMatrix(m5))  // 2x1 matrix: 1, 2
println(describeMatrix(m6))  // 2x2 matrix: 1, 2, 3, 4
println(describeMatrix(m7))  // Matrix with 3 rows, first row: 1, 2, 3
```

## 6.5 元组模式

### 基本元组模式

```scala
// 元组模式匹配
def describeTuple(tuple: Any): String = tuple match {
  case () => "Empty tuple"
  case (x, y) => s"2-tuple: $x, $y"
  case (x, y, z) => s"3-tuple: $x, $y, $z"
  case (x, y, z, w) => s"4-tuple: $x, $y, $z, $w"
  case (x, y, rest @ _*) => s"Tuple starting with $x, $y and ${rest.size} more elements"
}

println(describeTuple(()))                              // Empty tuple
println(describeTuple((1, 2)))                           // 2-tuple: 1, 2
println(describeTuple((1, 2, 3)))                        // 3-tuple: 1, 2, 3
println(describeTuple((1, 2, 3, 4)))                     // 4-tuple: 1, 2, 3, 4
println(describeTuple((1, 2, 3, 4, 5, 6)))               // Tuple starting with 1, 2 and 4 more elements

// 元组嵌套模式
def describeNestedTuple(tuple: Any): String = tuple match {
  case ((x, y), z) => s"Nested tuple: ($x, $y), $z"
  case (x, (y, z)) => s"Nested tuple: $x, ($y, $z)"
  case ((x, y), (z, w)) => s"Double nested: ($x, $y), ($z, $w)"
  case (a, b, (c, d)) => s"3-tuple with nested: $a, $b, ($c, $d)"
  case (x, y, z) @ tuple if x + y + z == 0 => s"Tuple with zero sum: $tuple"
  case (x, y, z) => s"Regular 3-tuple: $x, $y, $z"
}

println(describeNestedTuple(((1, 2), 3)))    // Nested tuple: (1, 2), 3
println(describeNestedTuple((1, (2, 3))))    // Nested tuple: 1, (2, 3)
println(describeNestedTuple(((1, 2), (3, 4)))) // Double nested: (1, 2), (3, 4)
println(describeNestedTuple((1, 2, (-3,))))  // Tuple with zero sum: (1,2,-3)
println(describeNestedTuple((1, 2, 3)))       // Regular 3-tuple: 1, 2, 3
```

### 元组模式的实际应用

```scala
// 使用元组模式处理坐标
def distanceFromOrigin(point: Any): String = point match {
  case (x, y) => math.sqrt(x*x + y*y).toString
  case (x, y, z) => math.sqrt(x*x + y*y + z*z).toString
  case _ => "Invalid coordinate"
}

println(distanceFromOrigin((3, 4)))    // 5.0 (3-4-5 triangle)
println(distanceFromOrigin((1, 2, 2))) // 3.0 (1-2-2 triangle, distance = sqrt(1+4+4))

// 使用元组模式处理日期
def formatDate(date: Any): String = date match {
  case (day, month, year) => f"$day%02d/$month%02d/$year"
  case (day, month) => f"$day%02d/$month"
  case _ => "Invalid date"
}

println(formatDate((5, 12, 2023)))   // 05/12/2023
println(formatDate((25, 12)))        // 25/12

// 使用元组模式处理HTTP请求
case class HttpRequest(method: String, url: String, headers: Map[String, String], body: Option[String])

def processRequest(req: HttpRequest): String = req match {
  case HttpRequest("GET", url, _, _) => s"GET request to $url"
  case HttpRequest("POST", url, _, Some(body)) => s"POST to $url with body: $body"
  case HttpRequest("POST", url, _, None) => s"POST to $url with empty body"
  case HttpRequest(method, url, headers, _) => 
    s"$method request to $url with ${headers.size} headers"
}

val getReq = HttpRequest("GET", "/api/users", Map("Accept" -> "application/json"), None)
val postReq = HttpRequest("POST", "/api/users", Map("Content-Type" -> "application/json"), Some("{\"name\":\"John\"}"))
val putReq = HttpRequest("PUT", "/api/users/123", Map(), None)

println(processRequest(getReq))    // GET request to /api/users
println(processRequest(postReq))   // POST to /api/users with body: {"name":"John"}
println(processRequest(putReq))    // PUT request to /api/users/123 with 0 headers

// 使用元组模式处理文件路径
def parsePath(path: String): String = {
  val parts = path.split("/").filter(_.nonEmpty)
  parts match {
    case Array("users", id) => s"User with ID: $id"
    case Array("users", id, "profile") => s"Profile for user $id"
    case Array("users", id, "posts", postId) => s"Post $postId by user $id"
    case Array("api", "v1", rest @ _*) => s"API v1 endpoint: /${rest.mkString("/")}"
    case Array() => "Root path"
    case other => s"Unknown path: /${other.mkString("/")}"
  }
}

println(parsePath("/users/123"))                // User with ID: 123
println(parsePath("/users/123/profile"))        // Profile for user 123
println(parsePath("/users/123/posts/456"))      // Post 456 by user 123
println(parsePath("/api/v1/data/reports"))       // API v1 endpoint: /data/reports
println(parsePath("/"))                          // Root path
println(parsePath("/unknown/path"))              // Unknown path: /unknown/path
```

### 元组模式与高阶函数

```scala
// 元组模式在高阶函数中的应用
val pairs = List((1, "one"), (2, "two"), (3, "three"))

// 使用模式匹配处理元组列表
val result = pairs.map {
  case (num, word) => s"$num -> $word"
}
println(result)  // List(1 -> one, 2 -> two, 3 -> three)

// 使用模式匹配过滤元组
val filtered = pairs.filter {
  case (num, _) => num % 2 == 1
}
println(filtered)  // List((1,one), (3,three))

// 使用模式匹配和foldLeft处理元组列表
val sumOfKeys = pairs.foldLeft(0) {
  case (acc, (num, _)) => acc + num
}
println(sumOfKeys)  // 6

// 元组模式在for comprehension中的使用
val result2 = for {
  (num, word) <- pairs
  if num % 2 == 1
} yield s"$word has $num letters"
println(result2)  // List(one has 1 letters, three has 5 letters)

// 复杂的元组模式处理
val data = List(
  (1, 2, 3),
  (4, 5, 6),
  (7, 8, 9)
)

val transformed = data.map {
  case (a, b, c) => (a + b, b + c, a + c)
}
println(transformed)  // List((3,5,4), (9,11,10), (15,17,16))

// 使用模式匹配计算矩阵的转置
def transpose(matrix: List[List[Int]]): List[List[Int]] = matrix match {
  case Nil => Nil
  case Nil :: _ => Nil
  case rows => rows.map(_.head) :: transpose(rows.map(_.tail))
}

val matrix = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
val transposed = transpose(matrix)
println(transposed)  // List(List(1, 4, 7), List(2, 5, 8), List(3, 6, 9))
```

## 6.6 类型模式

### 基本类型模式

```scala
// 类型模式匹配
def typeMatch(x: Any): String = x match {
  case s: String => s"String: $s"
  case i: Int => s"Int: $i"
  case d: Double => s"Double: $d"
  case b: Boolean => s"Boolean: $b"
  case c: Char => s"Char: $c"
  case l: List[_] => s"List with ${l.size} elements"
  case m: Map[_, _] => s"Map with ${m.size} key-value pairs"
  case a: Array[_] => s"Array with ${a.length} elements"
  case p: Product => s"Product: ${p.productPrefix} with ${p.productArity} elements"
  case _ => s"Unknown type: ${x.getClass.getSimpleName}"
}

println(typeMatch("Hello"))                              // String: Hello
println(typeMatch(42))                                   // Int: 42
println(typeMatch(3.14))                                 // Double: 3.14
println(typeMatch(true))                                  // Boolean: true
println(typeMatch('A'))                                   // Char: A
println(typeMatch(List(1, 2, 3)))                         // List with 3 elements
println(typeMatch(Map("key" -> "value")))                  // Map with 1 key-value pairs
println(typeMatch(Array(1, 2, 3)))                        // Array with 3 elements
println(typeMatch((1, 2, 3)))                             // Product: Tuple3 with 3 elements

// 类型模式与泛型
def describeCollection(collection: Any): String = collection match {
  case list: List[String] => s"String list: $list"
  case list: List[Int] => s"Int list: $list"
  case map: Map[String, Int] => s"String->Int map: $map"
  case map: Map[_, _] => s"Generic map: $map"
  case seq: Seq[_] => s"Sequence: $seq"
  case _ => s"Other collection: $collection"
}

println(describeCollection(List("a", "b", "c")))         // String list: List(a, b, c)
println(describeCollection(List(1, 2, 3)))              // Int list: List(1, 2, 3)
println(describeCollection(Map("one" -> 1, "two" -> 2)))  // String->Int map: Map(one -> 1, two -> 2)
println(describeCollection(Set(1, 2, 3)))                // Sequence: Set(1, 2, 3)
```

### 类型模式与继承

```scala
// 定义继承层次
abstract class Animal(val name: String) {
  def speak(): String
}

class Dog(name: String) extends Animal(name) {
  def speak(): String = "Woof!"
}

class Cat(name: String) extends Animal(name) {
  def speak(): String = "Meow!"
}

class Bird(name: String, canFly: Boolean) extends Animal(name) {
  def speak(): String = "Tweet!"
  def fly(): String = if (canFly) "Flying" else "Cannot fly"
}

// 类型模式匹配继承层次
def animalSound(animal: Animal): String = animal match {
  case dog: Dog => s"${dog.name} says ${dog.speak()}"
  case cat: Cat => s"${cat.name} says ${cat.speak()}"
  case bird: Bird => s"${bird.name} says ${bird.speak()} and ${bird.fly()}"
  case _ => s"${animal.name} makes an unknown sound"
}

val dog = new Dog("Buddy")
val cat = new Cat("Whiskers")
val flyingBird = new Bird("Tweety", canFly = true)
val penguin = new Bird("Pingu", canFly = false)

println(animalSound(dog))        // Buddy says Woof!
println(animalSound(cat))        // Whiskers says Meow!
println(animalSound(flyingBird)) // Tweety says Tweet! and Flying
println(animalSound(penguin))   // Pingu says Tweet! and Cannot fly

// 类型模式与类型擦除
// 由于类型擦除，以下模式匹配会失败
def matchList(collection: Any): String = collection match {
  case list: List[String] => s"String list: $list"  // 实际匹配所有List
  case list: List[Int] => s"Int list: $list"        // 永远不会匹配，已被前面的模式匹配
  case list: List[_] => s"Generic list: $list"     // 匹配所有List
  case _ => "Not a list"
}

println(matchList(List("a", "b", "c")))  // String list: List(a, b, c)
println(matchList(List(1, 2, 3)))        // String list: List(1, 2, 3) - 不正确!

// 解决类型擦除问题的方法：使用Array而不是泛型集合
def matchArray(collection: Any): String = collection match {
  case array: Array[String] => s"String array: ${array.mkString(", ")}"
  case array: Array[Int] => s"Int array: ${array.mkString(", ")}"
  case array: Array[_] => s"Generic array: ${array.mkString(", ")}"
  case _ => "Not an array"
}

println(matchArray(Array("a", "b", "c")))  // String array: a, b, c
println(matchArray(Array(1, 2, 3)))       // Int array: 1, 2, 3
```

### 类型模式与模式守卫

```scala
// 类型模式与守卫结合
def describeObject(obj: Any): String = obj match {
  case s: String if s.length > 10 => s"Long string: $s"
  case s: String if s.length == 0 => "Empty string"
  case s: String => s"Short string: $s"
  
  case i: Int if i > 100 => s"Large number: $i"
  case i: Int if i < 0 => s"Negative number: $i"
  case i: Int => s"Number: $i"
  
  case list: List[_] if list.isEmpty => "Empty list"
  case list: List[_] if list.size > 5 => s"Long list with ${list.size} elements"
  case list: List[_] => s"List with ${list.size} elements"
  
  case map: Map[_, _] if map.isEmpty => "Empty map"
  case map: Map[_, _] if map.size > 10 => s"Large map with ${map.size} entries"
  case map: Map[_, _] => s"Map with ${map.size} entries"
  
  case _ => s"Unknown object: $obj"
}

println(describeObject("This is a very long string"))   // Long string: This is a very long string
println(describeObject(""))                             // Empty string
println(describeObject("Short"))                       // Short string: Short
println(describeObject(150))                            // Large number: 150
println(describeObject(-10))                            // Negative number: -10
println(describeObject(50))                             // Number: 50
println(describeObject(List()))                         // Empty list
println(describeObject(List(1, 2, 3, 4, 5, 6, 7)))     // Long list with 7 elements
println(describeObject(List(1, 2, 3)))                  // List with 3 elements
println(describeObject(Map()))                           // Empty map
println(describeObject(Map((1 to 20).map(i => i -> s"value$i"): _*))) // Large map with 20 entries
println(describeObject(Map(1 -> "one", 2 -> "two")))     // Map with 2 entries
println(describeObject(42.0))                           // Unknown object: 42.0

// 类型模式与instanceOf的比较
def checkWithInstanceOf(obj: Any): String = {
  if (obj.isInstanceOf[String]) {
    val s = obj.asInstanceOf[String]
    s"String of length ${s.length}"
  } else if (obj.isInstanceOf[List[_]]) {
    val list = obj.asInstanceOf[List[_]]
    s"List with ${list.size} elements"
  } else if (obj.isInstanceOf[Map[_, _]]) {
    val map = obj.asInstanceOf[Map[_, _]]
    s"Map with ${map.size} entries"
  } else {
    s"Unknown object: $obj"
  }
}

println("\nComparing type pattern with instanceOf:")
println(describeObject("Hello"))          // Short string: Hello
println(checkWithInstanceOf("Hello"))      // String of length 5
println(describeObject(List(1, 2, 3)))    // List with 3 elements
println(checkWithInstanceOf(List(1, 2, 3)))// List with 3 elements
```

## 6.7 模式守卫

### 基本模式守卫

```scala
// 模式守卫使用if条件
def describeNumber(num: Int): String = num match {
  case n if n > 0 => s"$n is positive"
  case n if n < 0 => s"$n is negative"
  case 0 => "Zero"
}

println(describeNumber(10))   // 10 is positive
println(describeNumber(-5))   // -5 is negative
println(describeNumber(0))    // Zero

// 多重条件守卫
def analyzeAge(age: Int): String = age match {
  case a if a < 0 => "Invalid age"
  case a if a < 13 => "Child"
  case a if a < 18 => "Teenager"
  case a if a < 65 => "Adult"
  case a if a < 120 => "Senior"
  case _ => "Invalid age (too high)"
}

println(analyzeAge(-5))    // Invalid age
println(analyzeAge(10))    // Child
println(analyzeAge(15))    // Teenager
println(analyzeAge(30))    // Adult
println(analyzeAge(70))    // Senior
println(analyzeAge(150))   // Invalid age (too high)
```

### 复杂模式守卫

```scala
// 复杂条件模式守卫
case class Person(name: String, age: Int, address: Address)
case class Address(street: String, city: String, country: String)

def describePerson(person: Person): String = person match {
  case Person("Alice", age, _) if age < 30 => "Young Alice"
  case Person("Bob", age, _) if age >= 30 => "Adult Bob"
  case Person(name, age, Address(_, city, country)) if age >= 18 && country == "USA" => 
    s"Adult $name from $city, USA"
  case Person(name, age, Address(_, city, _)) if age < 18 => 
    s"Minor $name from $city"
  case Person(name, age, _) => s"$name, age $age"
}

val alice1 = Person("Alice", 25, Address("123 Main St", "New York", "USA"))
val bob1 = Person("Bob", 35, Address("456 Oak Ave", "Boston", "USA"))
val charlie = Person("Charlie", 17, Address("789 Pine St", "Chicago", "USA"))
val diana = Person("Diana", 25, Address("321 Elm St", "London", "UK"))

println(describePerson(alice1))  // Young Alice
println(describePerson(bob1))    // Adult Bob
println(describePerson(charlie)) // Minor Charlie from Chicago
println(describePerson(diana))   // Diana, age 25

// 多重条件守卫
def categorizeNumber(num: Int): String = num match {
  case n if n % 2 == 0 && n % 3 == 0 => "Divisible by both 2 and 3"
  case n if n % 2 == 0 => "Even number"
  case n if n % 3 == 0 => "Divisible by 3"
  case n if n % 5 == 0 => "Divisible by 5"
  case n if n > 0 => "Positive number not divisible by 2, 3, or 5"
  case n if n < 0 => "Negative number"
  case 0 => "Zero"
}

println(categorizeNumber(6))   // Divisible by both 2 and 3
println(categorizeNumber(10))  // Divisible by 5
println(categorizeNumber(9))   // Divisible by 3
println(categorizeNumber(8))   // Even number
println(categorizeNumber(7))   // Positive number not divisible by 2, 3, or 5
println(categorizeNumber(-4))  // Negative number
println(categorizeNumber(0))   // Zero
```

### 守卫与提取器结合

```scala
// 提取器与模式守卫结合
object PositiveInt {
  def unapply(x: Int): Option[Int] = if (x > 0) Some(x) else None
}

object NegativeInt {
  def unapply(x: Int): Option[Int] = if (x < 0) Some(x) else None
}

object Prime {
  def unapply(x: Int): Option[Int] = {
    def isPrime(n: Int): Boolean = {
      if (n <= 1) false
      else if (n <= 3) true
      else if (n % 2 == 0 || n % 3 == 0) false
      else {
        var i = 5
        while (i * i <= n && n % i != 0 && n % (i + 2) != 0) {
          i += 6
        }
        i * i > n
      }
    }
    
    if (isPrime(x)) Some(x) else None
  }
}

def analyzeNumberAdvanced(num: Int): String = num match {
  case PositiveInt(n) if Prime.unapply(n).isDefined => s"$n is a positive prime"
  case PositiveInt(n) => s"$n is positive but not prime"
  case NegativeInt(n) if n % 2 == 0 => s"$n is a negative even number"
  case NegativeInt(n) => s"$n is negative and odd"
  case 0 => "Zero"
}

println(analyzeNumberAdvanced(7))   // 7 is a positive prime
println(analyzeNumberAdvanced(9))   // 9 is positive but not prime
println(analyzeNumberAdvanced(-4))  // -4 is a negative even number
println(analyzeNumberAdvanced(-5))  // -5 is negative and odd
println(analyzeNumberAdvanced(0))   // Zero

// 复杂提取器与守卫
case class Email(username: String, domain: String)

object Email {
  def unapply(str: String): Option[(String, String)] = {
    val atIndex = str.indexOf('@')
    if (atIndex > 0 && str.indexOf('.', atIndex) > 0) {
      Some((str.substring(0, atIndex), str.substring(atIndex + 1)))
    } else None
  }
}

def validateEmail(email: String): String = email match {
  case Email(username, domain) if username.length >= 3 && domain.contains(".") => 
    s"Valid email: $username@$domain"
  case Email(_, _) => "Invalid email format"
  case _ => "Not an email"
}

println(validateEmail("user@example.com"))    // Valid email: user@example.com
println(validateEmail("ab@domain.com"))      // Valid email: ab@domain.com
println(validateEmail("a@domain.com"))       // Invalid email format
println(validateEmail("user@domain"))        // Invalid email format
println(validateEmail("not an email"))        // Not an email
```

## 6.8 密封类与模式匹配

### 密封类定义

```scala
// 密封类定义
sealed trait Animal
case class Dog(name: String) extends Animal
case class Cat(name: String) extends Animal
case class Bird(name: String, canFly: Boolean) extends Animal

// 密封类允许编译器检查穷尽性
def animalSound(animal: Animal): String = animal match {
  case Dog(name) => s"$name says Woof!"
  case Cat(name) => s"$name says Meow!"
  case Bird(name, canFly) => s"$name says Tweet! ${if (canFly) "and can fly" else "but cannot fly"}"
  // 编译器会检查是否覆盖所有可能的情况
}

val dog = Dog("Buddy")
val cat = Cat("Whiskers")
val parrot = Bird("Polly", true)
val penguin = Bird("Pingu", false)

println(animalSound(dog))      // Buddy says Woof!
println(animalSound(cat))      // Whiskers says Meow!
println(animalSound(parrot))   // Polly says Tweet! and can fly
println(animalSound(penguin))  // Pingu says Tweet! but cannot fly

// 密封类在递归数据结构中的应用
sealed trait BinaryTree[+A]
case class Leaf[A](value: A) extends BinaryTree[A]
case class Branch[A](left: BinaryTree[A], right: BinaryTree[A]) extends BinaryTree[A]

def treeSize[A](tree: BinaryTree[A]): Int = tree match {
  case Leaf(_) => 1
  case Branch(left, right) => 1 + treeSize(left) + treeSize(right)
}

def treeMax(tree: BinaryTree[Int]): Int = tree match {
  case Leaf(value) => value
  case Branch(left, right) => treeMax(left).max(treeMax(right))
}

val tree = Branch(
  Branch(Leaf(1), Leaf(2)),
  Branch(Leaf(3), Branch(Leaf(4), Leaf(5)))
)

println(s"Tree size: ${treeSize(tree)}")     // Tree size: 5
println(s"Tree max: ${treeMax(tree)}")       // Tree max: 5
```

### 密封类与模式守卫

```scala
// 密封类与模式守卫结合
sealed trait Shape
case class Circle(radius: Double) extends Shape
case class Rectangle(width: Double, height: Double) extends Shape
case class Triangle(side1: Double, side2: Double, side3: Double) extends Shape

def area(shape: Shape): Double = shape match {
  case Circle(r) if r > 0 => math.Pi * r * r
  case Rectangle(w, h) if w > 0 && h > 0 => w * h
  case Triangle(a, b, c) if a > 0 && b > 0 && c > 0 && a + b > c && a + c > b && b + c > a => {
    val s = (a + b + c) / 2
    math.sqrt(s * (s - a) * (s - b) * (s - c))
  }
  case _ => 0.0  // 无效形状
}

def perimeter(shape: Shape): Double = shape match {
  case Circle(r) if r > 0 => 2 * math.Pi * r
  case Rectangle(w, h) if w > 0 && h > 0 => 2 * (w + h)
  case Triangle(a, b, c) if a > 0 && b > 0 && c > 0 && a + b > c && a + c > b && b + c > a => a + b + c
  case _ => 0.0  // 无效形状
}

val circle = Circle(5.0)
val rectangle = Rectangle(4.0, 6.0)
val triangle = Triangle(3.0, 4.0, 5.0)

println(s"Circle area: ${area(circle)}, perimeter: ${perimeter(circle)}")
println(s"Rectangle area: ${area(rectangle)}, perimeter: ${perimeter(rectangle)}")
println(s"Triangle area: ${area(triangle)}, perimeter: ${perimeter(triangle)}")

// 密封枚举
sealed trait DayOfWeek
case object Monday extends DayOfWeek
case object Tuesday extends DayOfWeek
case object Wednesday extends DayOfWeek
case object Thursday extends DayOfWeek
case object Friday extends DayOfWeek
case object Saturday extends DayOfWeek
case object Sunday extends DayOfWeek

def isWeekday(day: DayOfWeek): Boolean = day match {
  case Monday | Tuesday | Wednesday | Thursday | Friday => true
  case Saturday | Sunday => false
}

def nextDay(day: DayOfWeek): DayOfWeek = day match {
  case Monday => Tuesday
  case Tuesday => Wednesday
  case Wednesday => Thursday
  case Thursday => Friday
  case Friday => Saturday
  case Saturday => Sunday
  case Sunday => Monday
}

println(s"Is Friday a weekday? ${isWeekday(Friday)}")    // Is Friday a weekday? true
println(s"Is Sunday a weekday? ${isWeekday(Sunday)}")     // Is Sunday a weekday? false
println(s"Day after Friday: ${nextDay(Friday)}")          // Day after Friday: Saturday
```

### 密封类的扩展与模式匹配

```scala
// 使用密封特质和样例类模拟枚举
sealed trait Status {
  def code: Int
  def message: String
}

case object Success extends Status {
  val code = 200
  val message = "OK"
}

case class NotFound(resource: String) extends Status {
  val code = 404
  val message = s"$resource not found"
}

case class ServerError(error: String) extends Status {
  val code = 500
  val message = s"Server error: $error"
}

case class BadRequest(message: String) extends Status {
  val code = 400
  val message = s"Bad request: $message"
}

def handleStatus(status: Status): String = status match {
  case Success => s"Request succeeded: ${status.message}"
  case NotFound(resource) => s"Error ${status.code}: ${status.message}"
  case ServerError(error) if error.contains("timeout") => 
    s"Error ${status.code}: Server timeout occurred"
  case ServerError(error) => 
    s"Error ${status.code}: Server error - ${error}"
  case BadRequest(msg) if msg.contains("validation") => 
    s"Error ${status.code}: Input validation failed"
  case BadRequest(msg) => 
    s"Error ${status.code}: ${status.message}"
}

println(handleStatus(Success))                                    // Request succeeded: OK
println(handleStatus(NotFound("User")))                             // Error 404: User not found
println(handleStatus(ServerError("Connection timeout")))              // Error 500: Server timeout occurred
println(handleStatus(ServerError("Database error")))                 // Error 500: Server error - Database error
println(handleStatus(BadRequest("Name field validation failed")))    // Error 400: Input validation failed
println(handleStatus(BadRequest("Missing required field")))         // Error 400: Bad request: Missing required field

// 密封类在状态机中的应用
sealed trait TrafficLightState {
  def color: String
  def canProceed: Boolean
  def next: TrafficLightState
}

case object Red extends TrafficLightState {
  val color = "red"
  val canProceed = false
  val next = Green
}

case object Green extends TrafficLightState {
  val color = "green"
  val canProceed = true
  val next = Yellow
}

case object Yellow extends TrafficLightState {
  val color = "yellow"
  val canProceed = false
  val next = Red
}

def trafficLightAction(state: TrafficLightState): String = state match {
  case Red => "Stop"
  case Green => "Go"
  case Yellow => "Prepare to stop"
}

def isSafeToProceed(state: TrafficLightState): Boolean = state match {
  case Red => false
  case Green => true
  case Yellow => false
}

val currentState = Red
println(s"Current color: ${currentState.color}")
println(s"Can proceed: ${currentState.canProceed}")
println(s"Action: ${trafficLightAction(currentState)}")
println(s"Next state color: ${currentState.next.color}")
```

## 6.9 正则表达式

### 基本正则表达式

```scala
import scala.util.matching.Regex

// 创建正则表达式
val emailPattern = """.+@.+\..+""".r
val phonePattern = """\d{3}-\d{3}-\d{4}""".r
val zipCodePattern = """\d{5}(-\d{4})?""".r

// 测试字符串匹配
val email1 = "user@example.com"
val email2 = "invalid.email"
val phone1 = "123-456-7890"
val phone2 = "12-3456-7890"
val zip1 = "12345"
val zip2 = "12345-6789"
val zip3 = "1234"

println(s"$email1 matches email pattern: ${emailPattern.pattern.matcher(email1).matches()}")
println(s"$email2 matches email pattern: ${emailPattern.pattern.matcher(email2).matches()}")
println(s"$phone1 matches phone pattern: ${phonePattern.pattern.matcher(phone1).matches()}")
println(s"$phone2 matches phone pattern: ${phonePattern.pattern.matcher(phone2).matches()}")
println(s"$zip1 matches zip pattern: ${zipCodePattern.pattern.matcher(zip1).matches()}")
println(s"$zip2 matches zip pattern: ${zipCodePattern.pattern.matcher(zip2).matches()}")
println(s"$zip3 matches zip pattern: ${zipCodePattern.pattern.matcher(zip3).matches()}")

// 使用findFirstIn
val text = "Contact us at support@example.com or sales@example.org"
val emails = emailPattern.findAllIn(text).toList
println(s"Found emails: $emails")  // Found emails: List(support@example.com, sales@example.org)

// 使用findFirstMatchIn
val firstEmail = emailPattern.findFirstMatchIn(text)
println(s"First email: ${firstEmail.map(_.matched)}")  // First email: Some(support@example.com)

// 提取匹配组
val detailedEmailPattern = """([^@]+)@([^.]+)\.([^.]*)""".r

def parseEmail(email: String): Option[(String, String, String)] = {
  detailedEmailPattern.findFirstMatchIn(email).map { m =>
    (m.group(1), m.group(2), m.group(3))
  }
}

println(parseEmail("user@example.com"))  // Some((user,example,com))
println(parseEmail("invalid.email"))      // None
```

### 正则表达式与模式匹配

```scala
// 正则表达式在模式匹配中的应用
val datePattern = """(\d{4})-(\d{2})-(\d{2})""".r

def formatDate(dateStr: String): String = dateStr match {
  case datePattern(year, month, day) => 
    f"$day/$month/$year"
  case _ => 
    s"Invalid date format: $dateStr"
}

println(formatDate("2023-12-25"))  // 25/12/2023
println(formatDate("25-12-2023"))  // Invalid date format: 25-12-2023

// 复杂模式匹配与正则表达式
val logPattern = """(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) \[(\w+)\] (.+)""".r

def parseLogEntry(logLine: String): Option[(String, String, String)] = {
  logLine match {
    case logPattern(timestamp, level, message) => 
      Some((timestamp, level, message))
    case _ => 
      None
  }
}

val logLine1 = "2023-12-25 10:30:45 [INFO] Application started"
val logLine2 = "2023-12-25 10:31:00 [ERROR] Connection failed"
val logLine3 = "Invalid log line"

println(parseLogEntry(logLine1))  // Some((2023-12-25 10:30:45,INFO,Application started))
println(parseLogEntry(logLine2))  // Some((2023-12-25 10:31:00,ERROR,Connection failed))
println(parseLogEntry(logLine3))  // None

// 带命名组的正则表达式
val namePattern = """(?<first>\w+)\s+(?<last>\w+)""".r.naive

def parseName(name: String): Option[(String, String)] = {
  namePattern.findFirstMatchIn(name).map { m =>
    (m.group("first"), m.group("last"))
  }
}

println(parseName("John Doe"))     // Some((John,Doe))
println(parseName("Jane Smith"))    // Some((Jane,Smith))
println(parseName("NotAName"))      // None
```

### 正则表达式高级操作

```scala
// 正则表达式高级操作
val wordPattern = """\b\w+\b""".r

// 统计单词数
def countWords(text: String): Int = {
  wordPattern.findAllMatchIn(text).length
}

val text = "This is a sample text with several words"
println(s"Word count: ${countWords(text)}")  // Word count: 8

// 查找并替换
val censoredText = wordPattern.replaceAllIn(text, "REDACTED")
println(s"Censored text: $censoredText")  // Censored text: REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED

// 替换首字母大写
val titleCaseText = wordPattern.replaceAllIn(text, m => {
  val word = m.matched
  word.charAt(0).toUpper + word.substring(1).toLowerCase
})
println(s"Title case: $titleCaseText")  // Title case: This Is A Sample Text With Several Words

// 正则表达式分组和验证
val passwordPattern = """(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=])(?=\S+$).{8,}""".r

def validatePassword(password: String): Boolean = {
  passwordPattern.pattern.matcher(password).matches()
}

println(s"Password123! is valid: ${validatePassword("Password123!")}")    // true
println(s"Pass123! is valid: ${validatePassword("Pass123!")}")           // false (too short)
println(s"Password123 is valid: ${validatePassword("Password123")}")     // false (no special char)
println(s"Password! is valid: ${validatePassword("Password!")}")         // false (no digit)

// 解析URL
val urlPattern = """(https?)://([^/:]+)(:[0-9]+)?(/.*)?""".r

def parseUrl(url: String): Option[(String, String, Option[Int], Option[String])] = {
  url match {
    case urlPattern(protocol, host, port, path) => 
      val portNum = if (port != null) Some(port.substring(1).toInt) else None
      val pathStr = if (path != null) Some(path) else None
      Some((protocol, host, portNum, pathStr))
    case _ => None
  }
}

println(parseUrl("https://example.com"))                                 // Some((https,example.com,None,None))
println(parseUrl("http://example.com:8080/path/to/resource"))         // Some((http,example.com,Some(8080),Some(/path/to/resource)))
println(parseUrl("ftp://invalid.url"))                                // None

// 处理CSV数据
val csvPattern = """([^,]*),([^,]*),([^,]*)""".r

def parseCsvLine(line: String): Option[(String, String, String)] = {
  line match {
    case csvPattern(col1, col2, col3) => Some((col1.trim, col2.trim, col3.trim))
    case _ => None
  }
}

val csvLine = "John Doe, 30, New York"
println(parseCsvLine(csvLine))  // Some((John Doe,30,New York))

val csvLine2 = "Jane Smith, 25"
println(parseCsvLine(csvLine2))  // None (missing column)
```

## 6.10 提取器

### 基本提取器

```scala
// 提取器的基本定义
object Even {
  def unapply(x: Int): Option[Int] = if (x % 2 == 0) Some(x) else None
}

object Odd {
  def unapply(x: Int): Option[Int] = if (x % 2 != 0) Some(x) else None
}

def describeNumber(num: Int): String = num match {
  case Even(x) => s"$x is even"
  case Odd(x) => s"$x is odd"
}

println(describeNumber(2))  // 2 is even
println(describeNumber(3))  // 3 is odd

// 返回多个值的提取器
object NameExtractor {
  def unapply(name: String): Option[(String, Option[String])] = {
    val parts = name.split(" ", 2)
    if (parts.length >= 1) {
      val firstName = parts(0)
      val lastName = if (parts.length == 2) Some(parts(1)) else None
      Some((firstName, lastName))
    } else None
  }
}

def greet(name: String): String = name match {
  case NameExtractor(firstName, Some(lastName)) => 
    s"Hello, Mr./Ms. $lastName"
  case NameExtractor(firstName, None) => 
    s"Hello, $firstName"
}

println(greet("John Doe"))    // Hello, Mr./Ms. Doe
println(greet("Alice"))       // Hello, Alice

// 布尔提取器
object Capitalized {
  def unapply(s: String): Boolean = s.nonEmpty && s.charAt(0).isUpper
}

def checkCapitalization(text: String): String = text match {
  case Capitalized() => s"'$text' starts with a capital letter"
  case _ => s"'$text' does not start with a capital letter"
}

println(checkCapitalization("Hello"))    // 'Hello' starts with a capital letter
println(checkCapitalization("world"))    // 'world' does not start with a capital letter
```

### 序列提取器

```scala
// 序列提取器
object FirstTwo {
  def unapplySeq(list: List[Int]): Option[Seq[Int]] = {
    if (list.length >= 2) Some(Seq(list.head, list(1)))
    else None
  }
}

def extractFirstTwo(list: List[Int]): String = list match {
  case FirstTwo(a, b, _*) => s"First two elements: $a, $b"
  case List(a) => s"Only one element: $a"
  case Nil => "Empty list"
}

println(extractFirstTwo(List(1, 2, 3, 4)))  // First two elements: 1, 2
println(extractFirstTwo(List(5)))           // Only one element: 5
println(extractFirstTwo(List()))             // Empty list

// 自定义序列提取器
object EvenNumbers {
  def unapplySeq(numbers: List[Int]): Option[Seq[Int]] = {
    val evens = numbers.filter(_ % 2 == 0)
    if (evens.nonEmpty) Some(evens) else None
  }
}

def extractEvenNumbers(numbers: List[Int]): String = numbers match {
  case EvenNumbers(evens @ _*) => s"Even numbers: ${evens.mkString(", ")}"
  case _ => "No even numbers found"
}

println(extractEvenNumbers(List(1, 2, 3, 4, 5)))  // Even numbers: 2, 4
println(extractEvenNumbers(List(1, 3, 5)))         // No even numbers found

// 提取器与集合操作结合
object HeadAndTail {
  def unapply[A](list: List[A]): Option[(A, List[A])] = {
    if (list.nonEmpty) Some((list.head, list.tail)) else None
  }
}

def processList[A](list: List[A]): String = list match {
  case HeadAndTail(head, tail) if tail.isEmpty => s"Single element list: $head"
  case HeadAndTail(head, tail) => s"Head: $head, Tail size: ${tail.size}"
  case _ => "Empty list"
}

println(processList(List(1)))                  // Single element list: 1
println(processList(List(1, 2, 3, 4, 5)))     // Head: 1, Tail size: 4
println(processList(List()))                    // Empty list
```

### 复杂提取器

```scala
// 复杂提取器：JSON解析简化版
sealed trait JsonValue
case class JsonObject(fields: Map[String, JsonValue]) extends JsonValue
case class JsonArray(items: List[JsonValue]) extends JsonValue
case class JsonString(value: String) extends JsonValue
case class JsonNumber(value: Double) extends JsonValue
case class JsonBoolean(value: Boolean) extends JsonValue
case object JsonNull extends JsonValue

object JsonString {
  def unapply(json: JsonValue): Option[String] = json match {
    case JsonString(value) => Some(value)
    case _ => None
  }
}

object JsonNumber {
  def unapply(json: JsonValue): Option[Double] = json match {
    case JsonNumber(value) => Some(value)
    case _ => None
  }
}

object JsonObject {
  def unapply(json: JsonValue): Option[Map[String, JsonValue]] = json match {
    case JsonObject(fields) => Some(fields)
    case _ => None
  }
}

object JsonField {
  def unapply(field: (String, JsonValue)): Option[(String, JsonValue)] = Some(field)
}

def extractJson(json: JsonValue): String = json match {
  case JsonString(value) => s"String: $value"
  case JsonNumber(value) => s"Number: $value"
  case JsonBoolean(value) => s"Boolean: $value"
  case JsonNull => "Null"
  case JsonArray(items) => s"Array with ${items.size} elements"
  case JsonObject(fields) => s"Object with ${fields.size} fields"
}

def extractJsonObject(json: JsonValue): String = json match {
  case JsonObject(Map("name" -> JsonString(name), "age" -> JsonNumber(age))) => 
    s"Person: $name, age $age"
  case JsonObject(Map("status" -> JsonString(status), "code" -> JsonNumber(code))) => 
    s"Response: $status, code $code"
  case JsonObject(fields) => 
    s"Object: ${fields.keys.mkString(", ")}"
  case _ => "Not an object"
}

val personJson = JsonObject(Map(
  "name" -> JsonString("John"),
  "age" -> JsonNumber(30),
  "active" -> JsonBoolean(true)
))

val responseJson = JsonObject(Map(
  "status" -> JsonString("success"),
  "code" -> JsonNumber(200)
))

println(extractJson(personJson))       // Object with 3 fields
println(extractJsonObject(personJson))  // Person: John, age 30
println(extractJson(responseJson))     // Object with 2 fields
println(extractJsonObject(responseJson)) // Response: success, code 200

// 自定义提取器：URL解析增强版
object EnhancedUrl {
  def unapply(url: String): Option[(String, String, Option[Int], Option[String], Option[Map[String, String]])] = {
    val urlPattern = """(https?)://([^/:]+)(:[0-9]+)?(/[^?]*)?(\?.*)?""".r
    
    url match {
      case urlPattern(protocol, host, port, path, query) =>
        val portNum = if (port != null) Some(port.substring(1).toInt) else None
        val pathStr = if (path != null) Some(path) else None
        
        val queryParams = if (query != null) {
          val params = query.substring(1).split("&")
          val paramMap = params.map { param =>
            val keyValue = param.split("=", 2)
            if (keyValue.length == 2) (keyValue(0) -> keyValue(1))
            else (keyValue(0) -> "")
          }.toMap
          Some(paramMap)
        } else None
        
        Some((protocol, host, portNum, pathStr, queryParams))
      case _ => None
    }
  }
}

def parseEnhancedUrl(url: String): String = url match {
  case EnhancedUrl(protocol, host, Some(port), Some(path), Some(params)) => 
    s"$protocol://$host:$port$path with params: ${params.mkString(", ")}"
  case EnhancedUrl(protocol, host, Some(port), Some(path), None) => 
    s"$protocol://$host:$port$path"
  case EnhancedUrl(protocol, host, None, Some(path), Some(params)) => 
    s"$protocol://$host$path with params: ${params.mkString(", ")}"
  case EnhancedUrl(protocol, host, None, Some(path), None) => 
    s"$protocol://$host$path"
  case EnhancedUrl(protocol, host, _, None, _) => 
    s"$protocol://$host"
  case _ => "Invalid URL"
}

println(parseEnhancedUrl("https://example.com:8080/path/to/resource?param1=value1&param2=value2"))
  // https://example.com:8080/path/to/resource with params: param1 -> value1, param2 -> value2

println(parseEnhancedUrl("http://example.com/path"))
  // http://example.com/path

println(parseEnhancedUrl("ftp://files.example.com"))
  // ftp://files.example.com
```

## 总结

本章深入探讨了Scala的模式匹配和正则表达式功能，这些是Scala语言中最强大的特性之一。模式匹配不仅限于简单的值匹配，还可以处理复杂的结构、类型和条件，使得代码更加简洁和表达力强。

关键点：
- Scala的模式匹配远比Java的switch语句强大，支持各种复杂的模式
- 可以匹配字面量、变量、构造器、序列、元组和类型
- 模式守卫（if条件）增加了模式匹配的灵活性
- 密封类与模式匹配结合可以实现类型安全的穷尽性检查
- 正则表达式与模式匹配的结合使得字符串处理更加简洁
- 提取器提供了自定义模式匹配的能力，可以增强领域特定语言的灵活性

模式匹配和正则表达式是Scala中表达复杂逻辑的强大工具，熟练掌握这些特性将使代码更加简洁、安全和易于维护。

下一章将探讨Scala的泛型与类型系统，这是Scala类型系统的核心组成部分，提供了强大的类型安全性和抽象能力。