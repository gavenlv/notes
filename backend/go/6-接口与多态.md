# 第6章：接口与多态

## 6.1 接口基础

### 6.1.1 接口的定义与实现

接口是Go语言中实现多态的核心机制。接口定义了一组方法的签名，任何类型只要实现了这些方法，就实现了该接口。

```go
package main

import "fmt"

// 定义接口
type Speaker interface {
    Speak() string
}

// 定义结构体
type Person struct {
    Name string
    Age  int
}

// Person实现Speaker接口
func (p Person) Speak() string {
    return fmt.Sprintf("我是%s，今年%d岁", p.Name, p.Age)
}

// 另一个结构体
type Dog struct {
    Name  string
    Breed string
}

// Dog也实现Speaker接口
func (d Dog) Speak() string {
    return fmt.Sprintf("汪汪！我是%s，一只%s", d.Name, d.Breed)
}

func main() {
    // 创建接口变量
    var speaker Speaker
    
    // 赋值给Person
    person := Person{"张三", 25}
    speaker = person
    fmt.Println(speaker.Speak())
    
    // 赋值给Dog
    dog := Dog{"小黑", "金毛"}
    speaker = dog
    fmt.Println(speaker.Speak())
    
    // 使用接口切片
    speakers := []Speaker{person, dog}
    for _, s := range speakers {
        fmt.Println(s.Speak())
    }
}
```

### 6.1.2 空接口

空接口`interface{}`可以表示任何类型，类似于Java中的Object或TypeScript中的any。

```go
package main

import "fmt"

// 空接口示例
func printAnything(v interface{}) {
    fmt.Printf("值: %v, 类型: %T\n", v, v)
}

func main() {
    // 空接口可以存储任何类型
    var anything interface{}
    
    anything = 42
    printAnything(anything)
    
    anything = "hello"
    printAnything(anything)
    
    anything = 3.14
    printAnything(anything)
    
    anything = []int{1, 2, 3}
    printAnything(anything)
    
    // 类型断言
    if str, ok := anything.(string); ok {
        fmt.Printf("这是一个字符串: %s\n", str)
    } else {
        fmt.Println("这不是字符串")
    }
    
    // 类型switch
    switch v := anything.(type) {
    case int:
        fmt.Printf("整数: %d\n", v)
    case string:
        fmt.Printf("字符串: %s\n", v)
    case []int:
        fmt.Printf("整数切片: %v\n", v)
    default:
        fmt.Printf("未知类型: %T\n", v)
    }
}
```

## 6.2 接口的深入理解

### 6.2.1 接口的值和类型

```go
package main

import (
    "fmt"
    "reflect"
)

type Shape interface {
    Area() float64
    Perimeter() float64
}

type Rectangle struct {
    Width  float64
    Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

func main() {
    var s Shape
    
    // 接口的零值是nil
    fmt.Printf("接口初始值: %v, 是否为nil: %v\n", s, s == nil)
    
    // 赋值后
    rect := Rectangle{Width: 10, Height: 5}
    s = rect
    
    fmt.Printf("接口赋值后: %v, 是否为nil: %v\n", s, s == nil)
    fmt.Printf("接口类型: %T\n", s)
    fmt.Printf("接口值: %v\n", s)
    
    // 调用接口方法
    fmt.Printf("面积: %.2f\n", s.Area())
    fmt.Printf("周长: %.2f\n", s.Perimeter())
    
    // 获取底层值
    if r, ok := s.(Rectangle); ok {
        fmt.Printf("底层值: Width=%.2f, Height=%.2f\n", r.Width, r.Height)
    }
    
    // 使用反射获取类型信息
    fmt.Printf("反射类型: %v\n", reflect.TypeOf(s))
    fmt.Printf("反射值: %v\n", reflect.ValueOf(s))
}
```

### 6.2.2 接口嵌套

Go支持接口嵌套，可以组合多个接口形成新的接口。

```go
package main

import "fmt"

// 基础接口
type Reader interface {
    Read() string
}

type Writer interface {
    Write(data string) error
}

// 组合接口
type ReadWriter interface {
    Reader
    Writer
}

// 实现ReadWriter接口的类型
type File struct {
    content string
}

func (f *File) Read() string {
    return f.content
}

func (f *File) Write(data string) error {
    f.content = data
    return nil
}

// 另一个接口
type Closer interface {
    Close() error
}

// 更复杂的接口组合
type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}

func main() {
    // 创建File实例
    file := &File{""}
    
    // File实现了ReadWriter接口
    var rw ReadWriter = file
    
    // 写入数据
    rw.Write("Hello, World!")
    
    // 读取数据
    content := rw.Read()
    fmt.Printf("读取的内容: %s\n", content)
    
    // 接口断言
    if reader, ok := rw.(Reader); ok {
        fmt.Println("实现了Reader接口:", reader.Read())
    }
    
    if writer, ok := rw.(Writer); ok {
        writer.Write("新的内容")
        fmt.Println("写入成功")
    }
}
```

## 6.3 多态的实现

### 6.3.1 多态示例

```go
package main

import (
    "fmt"
    "math"
)

// 几何图形接口
type Geometry interface {
    Area() float64
    Perimeter() float64
}

// 圆形
type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
    return 2 * math.Pi * c.Radius
}

// 正方形
type Square struct {
    Side float64
}

func (s Square) Area() float64 {
    return s.Side * s.Side
}

func (s Square) Perimeter() float64 {
    return 4 * s.Side
}

// 三角形
type Triangle struct {
    A, B, C float64
}

func (t Triangle) Area() float64 {
    // 海伦公式
    s := t.Perimeter() / 2
    return math.Sqrt(s * (s - t.A) * (s - t.B) * (s - t.C))
}

func (t Triangle) Perimeter() float64 {
    return t.A + t.B + t.C
}

// 通用的几何计算函数
func printGeometryInfo(g Geometry) {
    fmt.Printf("面积: %.2f, 周长: %.2f\n", g.Area(), g.Perimeter())
}

func main() {
    // 创建不同的几何图形
    shapes := []Geometry{
        Circle{Radius: 5},
        Square{Side: 4},
        Triangle{A: 3, B: 4, C: 5},
    }
    
    // 多态调用
    for i, shape := range shapes {
        fmt.Printf("图形%d: ", i+1)
        printGeometryInfo(shape)
    }
    
    // 计算总面积和总周长
    totalArea := 0.0
    totalPerimeter := 0.0
    
    for _, shape := range shapes {
        totalArea += shape.Area()
        totalPerimeter += shape.Perimeter()
    }
    
    fmt.Printf("\n总面积: %.2f\n", totalArea)
    fmt.Printf("总周长: %.2f\n", totalPerimeter)
}
```

### 6.3.2 接口的实践应用

```go
package main

import (
    "fmt"
    "time"
)

// 日志接口
type Logger interface {
    Log(level string, message string)
    LogInfo(message string)
    LogError(message string)
}

// 控制台日志
type ConsoleLogger struct{}

func (c ConsoleLogger) Log(level string, message string) {
    timestamp := time.Now().Format("2006-01-02 15:04:05")
    fmt.Printf("[%s] [%s] %s\n", timestamp, level, message)
}

func (c ConsoleLogger) LogInfo(message string) {
    c.Log("INFO", message)
}

func (c ConsoleLogger) LogError(message string) {
    c.Log("ERROR", message)
}

// 文件日志（模拟）
type FileLogger struct {
    filename string
}

func (f FileLogger) Log(level string, message string) {
    timestamp := time.Now().Format("2006-01-02 15:04:05")
    fmt.Printf("写入文件[%s]: [%s] [%s] %s\n", f.filename, timestamp, level, message)
}

func (f FileLogger) LogInfo(message string) {
    f.Log("INFO", message)
}

func (f FileLogger) LogError(message string) {
    f.Log("ERROR", message)
}

// 业务服务
type UserService struct {
    logger Logger
}

func NewUserService(logger Logger) *UserService {
    return &UserService{logger: logger}
}

func (s *UserService) CreateUser(name string) {
    s.logger.LogInfo(fmt.Sprintf("开始创建用户: %s", name))
    
    // 模拟业务逻辑
    if len(name) < 2 {
        s.logger.LogError("用户名太短")
        return
    }
    
    // 模拟创建用户
    s.logger.LogInfo("用户创建成功")
}

func main() {
    // 使用控制台日志
    consoleLogger := ConsoleLogger{}
    userService1 := NewUserService(consoleLogger)
    userService1.CreateUser("张三")
    
    fmt.Println("\n--- 分隔线 ---\n")
    
    // 使用文件日志
    fileLogger := FileLogger{filename: "app.log"}
    userService2 := NewUserService(fileLogger)
    userService2.CreateUser("李四")
    
    // 测试错误情况
    userService2.CreateUser("a") // 用户名太短
}
```

## 6.4 接口的最佳实践

### 6.4.1 接口设计原则

```go
package main

import (
    "fmt"
    "io"
    "strings"
)

// 1. 接口应该小而专注
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

// 2. 使用标准库接口
type MyReader struct {
    data string
    pos  int
}

func (r *MyReader) Read(p []byte) (n int, err error) {
    if r.pos >= len(r.data) {
        return 0, io.EOF
    }
    
    n = copy(p, r.data[r.pos:])
    r.pos += n
    return n, nil
}

// 3. 接受接口，返回具体类型
func NewStringReader(s string) *MyReader {
    return &MyReader{data: s}
}

// 4. 接口组合优于继承
func processData(reader Reader) {
    buffer := make([]byte, 1024)
    for {
        n, err := reader.Read(buffer)
        if err == io.EOF {
            break
        }
        if err != nil {
            fmt.Printf("读取错误: %v\n", err)
            break
        }
        fmt.Printf("读取到 %d 字节: %s\n", n, string(buffer[:n]))
    }
}

func main() {
    // 测试自定义Reader
    reader := NewStringReader("Hello, World! This is a test string.")
    processData(reader)
    
    // 使用标准库的strings.Reader
    stringsReader := strings.NewReader("Another test string")
    processData(stringsReader)
}
```

### 6.4.2 错误处理和接口

```go
package main

import (
    "errors"
    "fmt"
)

// 错误接口是Go中最常用的接口之一
type error interface {
    Error() string
}

// 自定义错误类型
type ValidationError struct {
    Field   string
    Message string
}

func (v ValidationError) Error() string {
    return fmt.Sprintf("字段 '%s' 验证失败: %s", v.Field, v.Message)
}

type BusinessError struct {
    Code    int
    Message string
}

func (b BusinessError) Error() string {
    return fmt.Sprintf("业务错误[%d]: %s", b.Code, b.Message)
}

// 验证函数
func validateUser(name string, age int) error {
    if name == "" {
        return ValidationError{"name", "用户名不能为空"}
    }
    
    if len(name) < 2 {
        return ValidationError{"name", "用户名至少2个字符"}
    }
    
    if age < 0 || age > 150 {
        return ValidationError{"age", "年龄必须在0-150之间"}
    }
    
    if age < 18 {
        return BusinessError{Code: 1001, Message: "用户未成年"}
    }
    
    return nil
}

func main() {
    // 测试各种错误情况
    testCases := []struct {
        name string
        age  int
    }{
        {"", 25},
        {"a", 25},
        {"张三", -1},
        {"李四", 16},
        {"王五", 25}, // 正常情况
    }
    
    for _, tc := range testCases {
        err := validateUser(tc.name, tc.age)
        if err != nil {
            fmt.Printf("验证失败: %v\n", err)
            
            // 类型判断处理
            switch e := err.(type) {
            case ValidationError:
                fmt.Printf("  这是验证错误，字段: %s\n", e.Field)
            case BusinessError:
                fmt.Printf("  这是业务错误，错误码: %d\n", e.Code)
            default:
                fmt.Printf("  未知错误类型\n")
            }
        } else {
            fmt.Printf("验证成功: %s, %d岁\n", tc.name, tc.age)
        }
        fmt.Println()
    }
}
```

本章详细介绍了Go语言中接口的概念、实现方式以及多态的应用。接口是Go语言实现抽象和模块化的核心机制，通过接口可以编写出灵活、可扩展的代码。下一章我们将学习Go语言的并发编程。