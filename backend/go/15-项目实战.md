# 第15章：项目实战

## 15.1 需求分析

### 15.1.1 项目概述

我们将开发一个完整的博客系统，包含以下功能：
- 用户注册和登录
- 文章发布和管理
- 评论系统
- 文章分类和标签
- 搜索功能
- 管理员后台

### 15.1.2 技术栈选择

- **Web框架**: Gin
- **数据库**: MySQL + GORM
- **认证**: JWT
- **缓存**: Redis
- **文件存储**: 本地文件系统
- **部署**: Docker

## 15.2 项目结构设计

### 15.2.1 目录结构

```
blog-system/
├── cmd/
│   └── server/
│       └── main.go
├── internal/
│   ├── config/
│   ├── models/
│   ├── handlers/
│   ├── middleware/
│   ├── service/
│   └── utils/
├── pkg/
│   ├── database/
│   ├── cache/
│   └── auth/
├── static/
├── templates/
├── uploads/
├── configs/
├── scripts/
├── Dockerfile
├── docker-compose.yml
├── go.mod
└── README.md
```

## 15.3 数据库设计

### 15.3.1 数据模型

```go
package models

import (
    "time"
    "gorm.io/gorm"
)

// User 用户模型
type User struct {
    ID        uint      `gorm:"primaryKey" json:"id"`
    Username  string    `gorm:"uniqueIndex;size:50" json:"username"`
    Email     string    `gorm:"uniqueIndex;size:100" json:"email"`
    Password  string    `gorm:"size:255" json:"-"`
    Avatar    string    `gorm:"size:255" json:"avatar"`
    Role      string    `gorm:"size:20;default:user" json:"role"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
    
    Articles []Article `gorm:"foreignKey:AuthorID" json:"articles,omitempty"`
    Comments []Comment `gorm:"foreignKey:UserID" json:"comments,omitempty"`
}

// Article 文章模型
type Article struct {
    ID        uint      `gorm:"primaryKey" json:"id"`
    Title     string    `gorm:"size:200;not null" json:"title"`
    Content   string    `gorm:"type:text;not null" json:"content"`
    Excerpt   string    `gorm:"size:500" json:"excerpt"`
    Status    string    `gorm:"size:20;default:draft" json:"status"`
    Views     uint      `gorm:"default:0" json:"views"`
    AuthorID  uint      `json:"author_id"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
    
    Author    User      `gorm:"foreignKey:AuthorID" json:"author"`
    Comments  []Comment `gorm:"foreignKey:ArticleID" json:"comments,omitempty"`
    Tags      []Tag     `gorm:"many2many:article_tags;" json:"tags,omitempty"`
    Category  Category  `gorm:"foreignKey:CategoryID" json:"category"`
    CategoryID uint     `json:"category_id"`
}

// Category 分类模型
type Category struct {
    ID        uint      `gorm:"primaryKey" json:"id"`
    Name      string    `gorm:"uniqueIndex;size:50" json:"name"`
    Slug      string    `gorm:"uniqueIndex;size:50" json:"slug"`
    CreatedAt time.Time `json:"created_at"`
    
    Articles []Article `gorm:"foreignKey:CategoryID" json:"articles,omitempty"`
}

// Tag 标签模型
type Tag struct {
    ID        uint      `gorm:"primaryKey" json:"id"`
    Name      string    `gorm:"uniqueIndex;size:50" json:"name"`
    Slug      string    `gorm:"uniqueIndex;size:50" json:"slug"`
    CreatedAt time.Time `json:"created_at"`
    
    Articles []Article `gorm:"many2many:article_tags;" json:"articles,omitempty"`
}

// Comment 评论模型
type Comment struct {
    ID        uint      `gorm:"primaryKey" json:"id"`
    Content   string    `gorm:"type:text;not null" json:"content"`
    Status    string    `gorm:"size:20;default:pending" json:"status"`
    UserID    uint      `json:"user_id"`
    ArticleID uint      `json:"article_id"`
    ParentID  *uint     `json:"parent_id"`
    CreatedAt time.Time `json:"created_at"`
    
    User     User      `gorm:"foreignKey:UserID" json:"user"`
    Article  Article   `gorm:"foreignKey:ArticleID" json:"article"`
    Replies  []Comment `gorm:"foreignKey:ParentID" json:"replies,omitempty"`
}
```

## 15.4 核心功能实现

### 15.4.1 配置管理

```go
package config

import (
    "log"
    "os"
    "strconv"
    "github.com/spf13/viper"
)

type Config struct {
    Server   ServerConfig   `mapstructure:"server"`
    Database DatabaseConfig `mapstructure:"database"`
    Redis    RedisConfig    `mapstructure:"redis"`
    JWT      JWTConfig      `mapstructure:"jwt"`
}

type ServerConfig struct {
    Port         string `mapstructure:"port"`
    Mode         string `mapstructure:"mode"`
    ReadTimeout  int    `mapstructure:"read_timeout"`
    WriteTimeout int    `mapstructure:"write_timeout"`
}

type DatabaseConfig struct {
    Host     string `mapstructure:"host"`
    Port     string `mapstructure:"port"`
    User     string `mapstructure:"user"`
    Password string `mapstructure:"password"`
    DBName   string `mapstructure:"dbname"`
}

type RedisConfig struct {
    Addr     string `mapstructure:"addr"`
    Password string `mapstructure:"password"`
    DB       int    `mapstructure:"db"`
}

type JWTConfig struct {
    Secret string `mapstructure:"secret"`
    Expire int    `mapstructure:"expire"`
}

func LoadConfig() (*Config, error) {
    viper.SetConfigName("config")
    viper.SetConfigType("yaml")
    viper.AddConfigPath("./configs")
    viper.AddConfigPath(".")
    
    // 设置默认值
    viper.SetDefault("server.port", "8080")
    viper.SetDefault("server.mode", "debug")
    viper.SetDefault("database.host", "localhost")
    viper.SetDefault("database.port", "3306")
    
    // 读取环境变量
    viper.AutomaticEnv()
    
    if err := viper.ReadInConfig(); err != nil {
        log.Printf("Warning: 配置文件读取失败: %v", err)
    }
    
    var config Config
    if err := viper.Unmarshal(&config); err != nil {
        return nil, err
    }
    
    // 处理环境变量覆盖
    if port := os.Getenv("SERVER_PORT"); port != "" {
        config.Server.Port = port
    }
    
    return &config, nil
}
```

### 15.4.2 数据库连接

```go
package database

import (
    "fmt"
    "log"
    "time"
    "blog-system/internal/models"
    "gorm.io/driver/mysql"
    "gorm.io/gorm"
    "gorm.io/gorm/logger"
)

type DB struct {
    *gorm.DB
}

func NewDB(config *config.DatabaseConfig) (*DB, error) {
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
        config.User, config.Password, config.Host, config.Port, config.DBName)
    
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
        Logger: logger.Default.LogMode(logger.Info),
    })
    
    if err != nil {
        return nil, fmt.Errorf("数据库连接失败: %v", err)
    }
    
    sqlDB, err := db.DB()
    if err != nil {
        return nil, err
    }
    
    // 配置连接池
    sqlDB.SetMaxOpenConns(25)
    sqlDB.SetMaxIdleConns(10)
    sqlDB.SetConnMaxLifetime(time.Hour)
    
    return &DB{db}, nil
}

func (db *DB) AutoMigrate() error {
    return db.DB.AutoMigrate(
        &models.User{},
        &models.Article{},
        &models.Category{},
        &models.Tag{},
        &models.Comment{},
    )
}

func (db *DB) Close() error {
    sqlDB, err := db.DB.DB()
    if err != nil {
        return err
    }
    return sqlDB.Close()
}
```

### 15.4.3 用户认证

```go
package auth

import (
    "errors"
    "time"
    "blog-system/internal/models"
    "github.com/dgrijalva/jwt-go"
    "golang.org/x/crypto/bcrypt"
)

type Claims struct {
    UserID uint `json:"user_id"`
    jwt.StandardClaims
}

type AuthService struct {
    jwtSecret string
    expireTime time.Duration
}

func NewAuthService(secret string, expire int) *AuthService {
    return &AuthService{
        jwtSecret: secret,
        expireTime: time.Duration(expire) * time.Hour,
    }
}

func (s *AuthService) GenerateToken(user *models.User) (string, error) {
    claims := Claims{
        UserID: user.ID,
        StandardClaims: jwt.StandardClaims{
            ExpiresAt: time.Now().Add(s.expireTime).Unix(),
            IssuedAt:  time.Now().Unix(),
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte(s.jwtSecret))
}

func (s *AuthService) ValidateToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        return []byte(s.jwtSecret), nil
    })
    
    if err != nil {
        return nil, err
    }
    
    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }
    
    return nil, errors.New("无效的token")
}

func (s *AuthService) HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    return string(bytes), err
}

func (s *AuthService) CheckPasswordHash(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}
```

### 15.4.4 文章服务

```go
package service

import (
    "blog-system/internal/models"
    "blog-system/pkg/database"
    "gorm.io/gorm"
)

type ArticleService struct {
    db *database.DB
}

func NewArticleService(db *database.DB) *ArticleService {
    return &ArticleService{db: db}
}

func (s *ArticleService) CreateArticle(article *models.Article) error {
    return s.db.Create(article).Error
}

func (s *ArticleService) GetArticleByID(id uint) (*models.Article, error) {
    var article models.Article
    err := s.db.Preload("Author").Preload("Category").Preload("Tags").
        First(&article, id).Error
    
    if err == nil {
        // 增加阅读量
        s.db.Model(&article).Update("views", gorm.Expr("views + ?", 1))
    }
    
    return &article, err
}

func (s *ArticleService) GetArticles(page, pageSize int, status string) ([]models.Article, int64, error) {
    var articles []models.Article
    var total int64
    
    query := s.db.Preload("Author").Preload("Category").Preload("Tags")
    
    if status != "" {
        query = query.Where("status = ?", status)
    }
    
    err := query.Model(&models.Article{}).Count(&total).Error
    if err != nil {
        return nil, 0, err
    }
    
    offset := (page - 1) * pageSize
    err = query.Offset(offset).Limit(pageSize).
        Order("created_at DESC").Find(&articles).Error
    
    return articles, total, err
}

func (s *ArticleService) UpdateArticle(id uint, article *models.Article) error {
    return s.db.Model(&models.Article{}).Where("id = ?", id).Updates(article).Error
}

func (s *ArticleService) DeleteArticle(id uint) error {
    return s.db.Delete(&models.Article{}, id).Error
}

func (s *ArticleService) SearchArticles(keyword string, page, pageSize int) ([]models.Article, int64, error) {
    var articles []models.Article
    var total int64
    
    query := s.db.Preload("Author").Preload("Category").Preload("Tags")
    
    if keyword != "" {
        likeKeyword := "%" + keyword + "%"
        query = query.Where("title LIKE ? OR content LIKE ?", likeKeyword, likeKeyword)
    }
    
    err := query.Model(&models.Article{}).Count(&total).Error
    if err != nil {
        return nil, 0, err
    }
    
    offset := (page - 1) * pageSize
    err = query.Offset(offset).Limit(pageSize).
        Order("created_at DESC").Find(&articles).Error
    
    return articles, total, err
}
```

## 15.5 API接口实现

### 15.5.1 用户认证接口

```go
package handlers

import (
    "net/http"
    "blog-system/internal/models"
    "blog-system/pkg/auth"
    "github.com/gin-gonic/gin"
)

type AuthHandler struct {
    authService *auth.AuthService
    userService *service.UserService
}

func NewAuthHandler(authService *auth.AuthService, userService *service.UserService) *AuthHandler {
    return &AuthHandler{
        authService: authService,
        userService: userService,
    }
}

func (h *AuthHandler) Register(c *gin.Context) {
    var req struct {
        Username string `json:"username" binding:"required,min=3,max=50"`
        Email    string `json:"email" binding:"required,email"`
        Password string `json:"password" binding:"required,min=6"`
    }
    
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // 检查用户是否已存在
    if h.userService.UserExists(req.Username, req.Email) {
        c.JSON(http.StatusConflict, gin.H{"error": "用户名或邮箱已存在"})
        return
    }
    
    hashedPassword, err := h.authService.HashPassword(req.Password)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "密码加密失败"})
        return
    }
    
    user := &models.User{
        Username: req.Username,
        Email:    req.Email,
        Password: hashedPassword,
    }
    
    if err := h.userService.CreateUser(user); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "用户创建失败"})
        return
    }
    
    c.JSON(http.StatusCreated, gin.H{
        "message": "注册成功",
        "user": gin.H{
            "id":       user.ID,
            "username": user.Username,
            "email":    user.Email,
        },
    })
}

func (h *AuthHandler) Login(c *gin.Context) {
    var req struct {
        Username string `json:"username" binding:"required"`
        Password string `json:"password" binding:"required"`
    }
    
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    user, err := h.userService.GetUserByUsername(req.Username)
    if err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "用户名或密码错误"})
        return
    }
    
    if !h.authService.CheckPasswordHash(req.Password, user.Password) {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "用户名或密码错误"})
        return
    }
    
    token, err := h.authService.GenerateToken(user)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "token生成失败"})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "token": token,
        "user": gin.H{
            "id":       user.ID,
            "username": user.Username,
            "email":    user.Email,
            "role":     user.Role,
        },
    })
}
```

### 15.5.2 文章管理接口

```go
package handlers

import (
    "net/http"
    "strconv"
    "blog-system/internal/models"
    "github.com/gin-gonic/gin"
)

type ArticleHandler struct {
    articleService *service.ArticleService
}

func NewArticleHandler(articleService *service.ArticleService) *ArticleHandler {
    return &ArticleHandler{articleService: articleService}
}

func (h *ArticleHandler) GetArticles(c *gin.Context) {
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "10"))
    status := c.DefaultQuery("status", "published")
    
    articles, total, err := h.articleService.GetArticles(page, pageSize, status)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "articles": articles,
        "total":    total,
        "page":     page,
        "page_size": pageSize,
    })
}

func (h *ArticleHandler) GetArticle(c *gin.Context) {
    id, err := strconv.ParseUint(c.Param("id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "无效的文章ID"})
        return
    }
    
    article, err := h.articleService.GetArticleByID(uint(id))
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "文章不存在"})
        return
    }
    
    c.JSON(http.StatusOK, article)
}

func (h *ArticleHandler) CreateArticle(c *gin.Context) {
    var article models.Article
    if err := c.ShouldBindJSON(&article); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // 从JWT中获取用户ID
    userID, exists := c.Get("userID")
    if !exists {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "未授权"})
        return
    }
    
    article.AuthorID = userID.(uint)
    
    if err := h.articleService.CreateArticle(&article); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusCreated, article)
}

func (h *ArticleHandler) UpdateArticle(c *gin.Context) {
    id, err := strconv.ParseUint(c.Param("id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "无效的文章ID"})
        return
    }
    
    var article models.Article
    if err := c.ShouldBindJSON(&article); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    if err := h.articleService.UpdateArticle(uint(id), &article); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"message": "文章更新成功"})
}

func (h *ArticleHandler) DeleteArticle(c *gin.Context) {
    id, err := strconv.ParseUint(c.Param("id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "无效的文章ID"})
        return
    }
    
    if err := h.articleService.DeleteArticle(uint(id)); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"message": "文章删除成功"})
}
```

## 15.6 部署配置

### 15.6.1 Docker配置

```dockerfile
FROM golang:1.19-alpine AS builder

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN go build -o blog-system ./cmd/server

FROM alpine:latest
RUN apk --no-cache add ca-certificates

WORKDIR /root/

COPY --from=builder /app/blog-system .
COPY --from=builder /app/configs ./configs
COPY --from=builder /app/static ./static
COPY --from=builder /app/templates ./templates

EXPOSE 8080

CMD ["./blog-system"]
```

### 15.6.2 docker-compose.yml

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SERVER_PORT=8080
      - DATABASE_HOST=mysql
      - REDIS_HOST=redis
    depends_on:
      - mysql
      - redis
    volumes:
      - ./uploads:/root/uploads

  mysql:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=rootpassword
      - MYSQL_DATABASE=blog_system
      - MYSQL_USER=bloguser
      - MYSQL_PASSWORD=blogpassword
    volumes:
      - mysql_data:/var/lib/mysql
    ports:
      - "3306:3306"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  mysql_data:
```

## 15.7 项目总结

通过这个完整的博客系统项目，我们实践了：

1. **项目架构设计**：清晰的目录结构和模块划分
2. **数据库设计**：合理的数据模型和关系设计
3. **业务逻辑实现**：用户认证、文章管理、评论系统等核心功能
4. **API设计**：RESTful风格的API接口
5. **安全防护**：JWT认证、密码加密、输入验证
6. **性能优化**：数据库连接池、缓存使用
7. **部署方案**：Docker容器化部署

这个项目展示了Go语言在实际Web开发中的应用，涵盖了从需求分析到部署上线的完整开发流程。