# 第3章：流程控制与函数

## 3.1 条件语句

### 3.1.1 if语句

if语句是最基本的条件控制结构：

```go
package main

import "fmt"

func main() {
    score := 85
    
    // 基本if语句
    if score >= 60 {
        fmt.Println("及格")
    }
    
    // if-else语句
    if score >= 90 {
        fmt.Println("优秀")
    } else if score >= 80 {
        fmt.Println("良好")
    } else if score >= 70 {
        fmt.Println("中等")
    } else if score >= 60 {
        fmt.Println("及格")
    } else {
        fmt.Println("不及格")
    }
    
    // 带初始化语句的if
    if age := 25; age >= 18 {
        fmt.Printf("年龄%d岁，已成年\n", age)
    }
    
    // 条件表达式
    if isEven := score%2 == 0; isEven {
        fmt.Printf("分数%d是偶数\n", score)
    }
}
```

### 3.1.2 switch语句

switch语句用于多分支选择：

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // 基本switch
    day := time.Now().Weekday()
    
    switch day {
    case time.Monday:
        fmt.Println("今天是星期一")
    case time.Tuesday:
        fmt.Println("今天是星期二")
    case time.Wednesday:
        fmt.Println("今天是星期三")
    case time.Thursday:
        fmt.Println("今天是星期四")
    case time.Friday:
        fmt.Println("今天是星期五")
    case time.Saturday, time.Sunday:
        fmt.Println("今天是周末")
    default:
        fmt.Println("日期错误")
    }
    
    // 不带表达式的switch（相当于if-else链）
    hour := time.Now().Hour()
    switch {
    case hour < 12:
        fmt.Println("上午")
    case hour < 18:
        fmt.Println("下午")
    default:
        fmt.Println("晚上")
    }
    
    // fallthrough关键字
    num := 2
    switch num {
    case 1:
        fmt.Println("数字1")
        fallthrough
    case 2:
        fmt.Println("数字2")
        fallthrough
    case 3:
        fmt.Println("数字3")
    default:
        fmt.Println("其他数字")
    }
}
```

## 3.2 循环语句

### 3.2.1 for循环

Go语言只有for循环，但可以模拟多种循环模式：

```go
package main

import "fmt"

func main() {
    // 1. 传统的for循环
    fmt.Println("=== 传统for循环 ===")
    for i := 0; i < 5; i++ {
        fmt.Printf("i = %d\n", i)
    }
    
    // 2. 类似while的循环
    fmt.Println("\n=== 类似while的循环 ===")
    j := 0
    for j < 3 {
        fmt.Printf("j = %d\n", j)
        j++
    }
    
    // 3. 无限循环
    fmt.Println("\n=== 无限循环（有break） ===")
    k := 0
    for {
        if k >= 3 {
            break
        }
        fmt.Printf("k = %d\n", k)
        k++
    }
    
    // 4. 遍历数组/切片
    fmt.Println("\n=== 遍历数组 ===")
    numbers := []int{10, 20, 30, 40}
    for index, value := range numbers {
        fmt.Printf("索引: %d, 值: %d\n", index, value)
    }
    
    // 5. 遍历字符串
    fmt.Println("\n=== 遍历字符串 ===")
    text := "Hello"
    for index, char := range text {
        fmt.Printf("索引: %d, 字符: %c, Unicode: %d\n", index, char, char)
    }
    
    // 6. 遍历map
    fmt.Println("\n=== 遍历map ===")
    scores := map[string]int{
        "张三": 88,
        "李四": 92,
        "王五": 78,
    }
    for name, score := range scores {
        fmt.Printf("姓名: %s, 分数: %d\n", name, score)
    }
}
```

### 3.2.2 break和continue

```go
package main

import "fmt"

func main() {
    // break示例
    fmt.Println("=== break示例 ===")
    for i := 0; i < 10; i++ {
        if i == 5 {
            fmt.Println("遇到5，跳出循环")
            break
        }
        fmt.Printf("i = %d\n", i)
    }
    
    // continue示例
    fmt.Println("\n=== continue示例 ===")
    for i := 0; i < 10; i++ {
        if i%2 == 0 {
            continue // 跳过偶数
        }
        fmt.Printf("i = %d\n", i)
    }
    
    // 带标签的break
    fmt.Println("\n=== 带标签的break ===")
outer:
    for i := 0; i < 3; i++ {
        for j := 0; j < 3; j++ {
            if i == 1 && j == 1 {
                fmt.Println("跳出外层循环")
                break outer
            }
            fmt.Printf("i = %d, j = %d\n", i, j)
        }
    }
    
    // 带标签的continue
    fmt.Println("\n=== 带标签的continue ===")
outer2:
    for i := 0; i < 3; i++ {
        for j := 0; j < 3; j++ {
            if j == 1 {
                fmt.Printf("跳过i=%d时的内层循环剩余部分\n", i)
                continue outer2
            }
            fmt.Printf("i = %d, j = %d\n", i, j)
        }
    }
}
```

## 3.3 函数基础

### 3.3.1 函数定义与调用

```go
package main

import "fmt"

// 无参数无返回值函数
func sayHello() {
    fmt.Println("Hello, World!")
}

// 有参数无返回值函数
func greet(name string) {
    fmt.Printf("你好, %s!\n", name)
}

// 有参数有返回值函数
func add(a, b int) int {
    return a + b
}

// 多返回值函数
func calculate(a, b int) (int, int, int, float64) {
    sum := a + b
    difference := a - b
    product := a * b
    quotient := float64(a) / float64(b)
    return sum, difference, product, quotient
}

// 命名返回值函数
func divide(a, b int) (quotient, remainder int) {
    quotient = a / b
    remainder = a % b
    return // 返回命名返回值
}

func main() {
    // 调用函数
    sayHello()
    greet("张三")
    
    result := add(10, 20)
    fmt.Printf("10 + 20 = %d\n", result)
    
    sum, diff, prod, quot := calculate(15, 4)
    fmt.Printf("15和4的计算结果:\n")
    fmt.Printf("和: %d\n", sum)
    fmt.Printf("差: %d\n", diff)
    fmt.Printf("积: %d\n", prod)
    fmt.Printf("商: %.2f\n", quot)
    
    q, r := divide(17, 5)
    fmt.Printf("17除以5: 商=%d, 余数=%d\n", q, r)
}
```

### 3.3.2 可变参数函数

```go
package main

import "fmt"

// 可变参数函数
func sum(numbers ...int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}

// 混合参数的可变参数函数
func printValues(prefix string, values ...interface{}) {
    fmt.Print(prefix + ": ")
    for _, v := range values {
        fmt.Printf("%v ", v)
    }
    fmt.Println()
}

func main() {
    // 调用可变参数函数
    result1 := sum(1, 2, 3, 4, 5)
    fmt.Printf("1+2+3+4+5 = %d\n", result1)
    
    result2 := sum(10, 20, 30)
    fmt.Printf("10+20+30 = %d\n", result2)
    
    // 传递切片作为可变参数
    nums := []int{1, 3, 5, 7, 9}
    result3 := sum(nums...)
    fmt.Printf("1+3+5+7+9 = %d\n", result3)
    
    // 混合参数调用
    printValues("信息", "张三", 25, 3.14)
}
```

## 3.4 函数进阶

### 3.4.1 匿名函数与闭包

```go
package main

import "fmt"

// 创建计数器闭包
func createCounter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

// 创建加法器闭包
func createAdder(base int) func(int) int {
    return func(x int) int {
        return base + x
    }
}

// 共享状态的闭包
func createSharedCounter() (func() int, func() int) {
    sharedCount := 0
    counter1 := func() int {
        sharedCount++
        return sharedCount
    }
    counter2 := func() int {
        sharedCount++
        return sharedCount
    }
    return counter1, counter2
}

func main() {
    // 1. 匿名函数
    greet := func(name string) {
        fmt.Printf("你好, %s!\n", name)
    }
    
    greet("张三")
    greet("李四")
    
    // 2. 立即执行函数
    func() {
        fmt.Println("这是一个立即执行函数")
    }()
    
    // 3. 闭包示例
    counter := createCounter()
    
    fmt.Println(counter()) // 1
    fmt.Println(counter()) // 2
    fmt.Println(counter()) // 3
    
    // 4. 闭包的实际应用：状态保持
    adder := createAdder(10)
    fmt.Println(adder(5))  // 15
    fmt.Println(adder(3))   // 18
    fmt.Println(adder(7))   // 25
    
    // 5. 多个闭包共享状态
    sharedCounter1, sharedCounter2 := createSharedCounter()
    fmt.Println(sharedCounter1()) // 1
    fmt.Println(sharedCounter2()) // 2
    fmt.Println(sharedCounter1()) // 3
}
```

### 3.4.2 defer语句

defer用于延迟执行，常用于资源清理：

```go
package main

import "fmt"

func main() {
    // defer的基本使用
    defer fmt.Println("第一个defer语句")
    defer fmt.Println("第二个defer语句")
    defer fmt.Println("第三个defer语句")
    
    fmt.Println("主函数开始执行")
    
    // defer的执行顺序：后进先出
    for i := 0; i < 3; i++ {
        defer fmt.Printf("循环中的defer: %d\n", i)
    }
    
    fmt.Println("主函数执行完毕")
    
    // defer的实际应用：文件操作
    deferExample()
}

func deferExample() {
    fmt.Println("=== defer实际应用 ===")
    
    // 模拟文件打开和关闭
    fmt.Println("打开文件")
    defer fmt.Println("关闭文件") // 确保文件被关闭
    
    // 模拟数据库连接
    fmt.Println("连接数据库")
    defer fmt.Println("断开数据库连接")
    
    // 业务逻辑
    fmt.Println("执行业务逻辑...")
    
    // 即使发生panic，defer也会执行
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("捕获到panic:", r)
        }
    }()
    
    // 可能触发panic的操作
    fmt.Println("执行可能出错的操作...")
}
```

## 3.5 实践练习

### 练习1：计算器程序

```go
package main

import "fmt"

func calculator(a, b float64, operator string) (float64, error) {
    switch operator {
    case "+":
        return a + b, nil
    case "-":
        return a - b, nil
    case "*":
        return a * b, nil
    case "/":
        if b == 0 {
            return 0, fmt.Errorf("除数不能为零")
        }
        return a / b, nil
    default:
        return 0, fmt.Errorf("不支持的运算符: %s", operator)
    }
}

func main() {
    tests := []struct {
        a, b     float64
        operator string
    }{
        {10, 5, "+"},
        {10, 5, "-"},
        {10, 5, "*"},
        {10, 5, "/"},
        {10, 0, "/"},
        {10, 5, "%"},
    }
    
    for _, test := range tests {
        result, err := calculator(test.a, test.b, test.operator)
        if err != nil {
            fmt.Printf("%.1f %s %.1f = 错误: %v\n", test.a, test.operator, test.b, err)
        } else {
            fmt.Printf("%.1f %s %.1f = %.2f\n", test.a, test.operator, test.b, result)
        }
    }
}
```

### 练习2：斐波那契数列生成器

```go
package main

import "fmt"

// 使用闭包生成斐波那契数列
func fibonacciGenerator() func() int {
    a, b := 0, 1
    return func() int {
        result := a
        a, b = b, a+b
        return result
    }
}

func main() {
    fib := fibonacciGenerator()
    
    fmt.Println("斐波那契数列前20项:")
    for i := 0; i < 20; i++ {
        fmt.Printf("%d ", fib())
    }
    fmt.Println()
    
    // 重新创建生成器
    fib2 := fibonacciGenerator()
    fmt.Println("\n另一个生成器:")
    for i := 0; i < 10; i++ {
        fmt.Printf("%d ", fib2())
    }
    fmt.Println()
}
```

### 练习3：成绩评级系统

```go
package main

import "fmt"

func gradeSystem(scores []int) map[string]int {
    result := map[string]int{
        "优秀": 0,
        "良好": 0,
        "中等": 0,
        "及格": 0,
        "不及格": 0,
    }
    
    for _, score := range scores {
        switch {
        case score >= 90:
            result["优秀"]++
        case score >= 80:
            result["良好"]++
        case score >= 70:
            result["中等"]++
        case score >= 60:
            result["及格"]++
        default:
            result["不及格"]++
        }
    }
    
    return result
}

func main() {
    scores := []int{85, 92, 78, 45, 67, 91, 58, 76, 82, 95}
    
    fmt.Println("成绩统计:")
    fmt.Printf("原始成绩: %v\n", scores)
    
    statistics := gradeSystem(scores)
    
    fmt.Println("\n评级统计:")
    for grade, count := range statistics {
        fmt.Printf("%s: %d人\n", grade, count)
    }
    
    // 计算平均分
    total := 0
    for _, score := range scores {
        total += score
    }
    average := float64(total) / float64(len(scores))
    fmt.Printf("\n平均分: %.2f\n", average)
}
```

## 3.6 最佳实践

### 函数设计原则
1. **单一职责**：每个函数只做一件事
2. **短小精悍**：函数体不宜过长
3. **明确命名**：函数名应准确描述功能
4. **最少参数**：参数数量尽量少
5. **无副作用**：尽量避免修改外部状态

### 错误处理模式
1. 使用多返回值处理错误
2. defer用于资源清理
3. 合理使用panic和recover

## 3.7 本章总结

本章我们深入学习了：
- 条件语句（if、switch）的使用
- 各种循环模式（for、range）
- 函数的定义、调用和返回值
- 可变参数函数和匿名函数
- 闭包的概念和应用
- defer语句的使用

通过实践练习，我们掌握了计算器、斐波那契数列、成绩评级等实用功能的实现。下一章我们将学习数组、切片和映射等复杂数据结构。

---

**下一章预告**：第4章将详细介绍数组、切片、映射等数据结构的特性和使用方法。