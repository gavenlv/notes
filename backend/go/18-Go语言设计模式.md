# 18. Go语言设计模式

## 18.1 设计模式概述

### 18.1.1 什么是设计模式

设计模式是软件开发中常见问题的可重用解决方案。它们不是可以直接转换为代码的完整设计，而是描述如何解决特定问题的模板。

**设计模式的分类：**
- **创建型模式**：处理对象创建机制
- **结构型模式**：处理类和对象的组合
- **行为型模式**：处理对象间的通信

### 18.1.2 Go语言中的设计模式特点

Go语言的设计模式实现有以下特点：
- 接口优先的设计
- 组合优于继承
- 简洁明了的实现
- 并发友好的设计

```go
// 文件: backend/go/code/chapter18/design-pattern-overview/main.go
package main

import "fmt"

// 基础接口
type Shape interface {
    Draw()
}

// 具体实现
type Circle struct{}

func (c *Circle) Draw() {
    fmt.Println("绘制圆形")
}

type Rectangle struct{}

func (r *Rectangle) Draw() {
    fmt.Println("绘制矩形")
}

// 工厂模式示例
func CreateShape(shapeType string) Shape {
    switch shapeType {
    case "circle":
        return &Circle{}
    case "rectangle":
        return &Rectangle{}
    default:
        return nil
    }
}

func main() {
    // 使用工厂模式创建对象
    circle := CreateShape("circle")
    rectangle := CreateShape("rectangle")
    
    circle.Draw()
    rectangle.Draw()
}
```

## 18.2 创建型模式

### 18.2.1 单例模式（Singleton）

```go
// 文件: backend/go/code/chapter18/singleton/main.go
package main

import (
    "fmt"
    "sync"
)

// 单例结构体
type Singleton struct {
    name string
}

func (s *Singleton) GetName() string {
    return s.name
}

// 单例实例和锁
var (
    instance *Singleton
    once     sync.Once
)

// 获取单例实例
func GetInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{name: "单例实例"}
        fmt.Println("创建单例实例")
    })
    return instance
}

func main() {
    // 多次调用GetInstance，但只创建一次实例
    instance1 := GetInstance()
    instance2 := GetInstance()
    
    fmt.Printf("实例1名称: %s\n", instance1.GetName())
    fmt.Printf("实例2名称: %s\n", instance2.GetName())
    
    // 检查是否为同一个实例
    if instance1 == instance2 {
        fmt.Println("两个实例是同一个对象")
    }
}
```

### 18.2.2 工厂模式（Factory）

```go
// 文件: backend/go/code/chapter18/factory/main.go
package main

import "fmt"

// 数据库连接接口
type DBConnection interface {
    Connect() string
    Close() string
}

// MySQL连接实现
type MySQLConnection struct{}

func (m *MySQLConnection) Connect() string {
    return "MySQL连接已建立"
}

func (m *MySQLConnection) Close() string {
    return "MySQL连接已关闭"
}

// PostgreSQL连接实现
type PostgreSQLConnection struct{}

func (p *PostgreSQLConnection) Connect() string {
    return "PostgreSQL连接已建立"
}

func (p *PostgreSQLConnection) Close() string {
    return "PostgreSQL连接已关闭"
}

// 数据库工厂
type DBFactory struct{}

func (f *DBFactory) CreateConnection(dbType string) DBConnection {
    switch dbType {
    case "mysql":
        return &MySQLConnection{}
    case "postgresql":
        return &PostgreSQLConnection{}
    default:
        return nil
    }
}

func main() {
    factory := &DBFactory{}
    
    mysqlConn := factory.CreateConnection("mysql")
    fmt.Println(mysqlConn.Connect())
    fmt.Println(mysqlConn.Close())
    
    postgresConn := factory.CreateConnection("postgresql")
    fmt.Println(postgresConn.Connect())
    fmt.Println(postgresConn.Close())
}
```

### 18.2.3 建造者模式（Builder）

```go
// 文件: backend/go/code/chapter18/builder/main.go
package main

import "fmt"

// 产品：电脑
type Computer struct {
    CPU     string
    RAM     string
    Storage string
    GPU     string
}

func (c *Computer) String() string {
    return fmt.Sprintf("电脑配置: CPU=%s, RAM=%s, 存储=%s, GPU=%s", 
        c.CPU, c.RAM, c.Storage, c.GPU)
}

// 建造者接口
type ComputerBuilder interface {
    SetCPU(cpu string) ComputerBuilder
    SetRAM(ram string) ComputerBuilder
    SetStorage(storage string) ComputerBuilder
    SetGPU(gpu string) ComputerBuilder
    Build() *Computer
}

// 具体建造者
type GamingComputerBuilder struct {
    computer *Computer
}

func NewGamingComputerBuilder() *GamingComputerBuilder {
    return &GamingComputerBuilder{
        computer: &Computer{},
    }
}

func (b *GamingComputerBuilder) SetCPU(cpu string) ComputerBuilder {
    b.computer.CPU = cpu
    return b
}

func (b *GamingComputerBuilder) SetRAM(ram string) ComputerBuilder {
    b.computer.RAM = ram
    return b
}

func (b *GamingComputerBuilder) SetStorage(storage string) ComputerBuilder {
    b.computer.Storage = storage
    return b
}

func (b *GamingComputerBuilder) SetGPU(gpu string) ComputerBuilder {
    b.computer.GPU = gpu
    return b
}

func (b *GamingComputerBuilder) Build() *Computer {
    return b.computer
}

// 指导者
type ComputerDirector struct {
    builder ComputerBuilder
}

func NewComputerDirector(builder ComputerBuilder) *ComputerDirector {
    return &ComputerDirector{
        builder: builder,
    }
}

func (d *ComputerDirector) ConstructGamingPC() *Computer {
    return d.builder.
        SetCPU("Intel i9").
        SetRAM("32GB DDR5").
        SetStorage("2TB NVMe SSD").
        SetGPU("RTX 4090").
        Build()
}

func (d *ComputerDirector) ConstructOfficePC() *Computer {
    return d.builder.
        SetCPU("Intel i5").
        SetRAM("16GB DDR4").
        SetStorage("512GB SSD").
        SetGPU("集成显卡").
        Build()
}

func main() {
    gamingBuilder := NewGamingComputerBuilder()
    director := NewComputerDirector(gamingBuilder)
    
    gamingPC := director.ConstructGamingPC()
    fmt.Println(gamingPC)
    
    officePC := director.ConstructOfficePC()
    fmt.Println(officePC)
}
```

## 18.3 结构型模式

### 18.3.1 适配器模式（Adapter）

```go
// 文件: backend/go/code/chapter18/adapter/main.go
package main

import "fmt"

// 旧系统接口
type OldSystem interface {
    OldProcess() string
}

// 旧系统实现
type LegacySystem struct{}

func (l *LegacySystem) OldProcess() string {
    return "旧系统处理逻辑"
}

// 新系统接口
type NewSystem interface {
    NewProcess() string
}

// 新系统实现
type ModernSystem struct{}

func (m *ModernSystem) NewProcess() string {
    return "新系统处理逻辑"
}

// 适配器：让旧系统适配新接口
type Adapter struct {
    oldSystem OldSystem
}

func NewAdapter(oldSystem OldSystem) *Adapter {
    return &Adapter{
        oldSystem: oldSystem,
    }
}

func (a *Adapter) NewProcess() string {
    // 调用旧系统的方法，但返回新接口期望的结果
    return "适配后的: " + a.oldSystem.OldProcess()
}

func main() {
    legacy := &LegacySystem{}
    modern := &ModernSystem{}
    
    // 使用适配器让旧系统适配新接口
    adapter := NewAdapter(legacy)
    
    fmt.Println("新系统:", modern.NewProcess())
    fmt.Println("适配后的旧系统:", adapter.NewProcess())
}
```

### 18.3.2 装饰器模式（Decorator）

```go
// 文件: backend/go/code/chapter18/decorator/main.go
package main

import "fmt"

// 组件接口
type Coffee interface {
    GetCost() float64
    GetDescription() string
}

// 具体组件
type SimpleCoffee struct{}

func (s *SimpleCoffee) GetCost() float64 {
    return 2.0
}

func (s *SimpleCoffee) GetDescription() string {
    return "简单咖啡"
}

// 装饰器基类
type CoffeeDecorator struct {
    coffee Coffee
}

func (d *CoffeeDecorator) GetCost() float64 {
    return d.coffee.GetCost()
}

func (d *CoffeeDecorator) GetDescription() string {
    return d.coffee.GetDescription()
}

// 具体装饰器：牛奶
type MilkDecorator struct {
    CoffeeDecorator
}

func NewMilkDecorator(coffee Coffee) *MilkDecorator {
    return &MilkDecorator{
        CoffeeDecorator: CoffeeDecorator{coffee: coffee},
    }
}

func (m *MilkDecorator) GetCost() float64 {
    return m.coffee.GetCost() + 0.5
}

func (m *MilkDecorator) GetDescription() string {
    return m.coffee.GetDescription() + " + 牛奶"
}

// 具体装饰器：糖
type SugarDecorator struct {
    CoffeeDecorator
}

func NewSugarDecorator(coffee Coffee) *SugarDecorator {
    return &SugarDecorator{
        CoffeeDecorator: CoffeeDecorator{coffee: coffee},
    }
}

func (s *SugarDecorator) GetCost() float64 {
    return s.coffee.GetCost() + 0.2
}

func (s *SugarDecorator) GetDescription() string {
    return s.coffee.GetDescription() + " + 糖"
}

func main() {
    coffee := &SimpleCoffee{}
    fmt.Printf("%s: $%.2f\n", coffee.GetDescription(), coffee.GetCost())
    
    // 添加牛奶
    milkCoffee := NewMilkDecorator(coffee)
    fmt.Printf("%s: $%.2f\n", milkCoffee.GetDescription(), milkCoffee.GetCost())
    
    // 添加牛奶和糖
    sugarMilkCoffee := NewSugarDecorator(milkCoffee)
    fmt.Printf("%s: $%.2f\n", sugarMilkCoffee.GetDescription(), sugarMilkCoffee.GetCost())
}
```

### 18.3.3 外观模式（Facade）

```go
// 文件: backend/go/code/chapter18/facade/main.go
package main

import "fmt"

// 子系统A
type SubsystemA struct{}

func (s *SubsystemA) OperationA() string {
    return "子系统A操作"
}

// 子系统B
type SubsystemB struct{}

func (s *SubsystemB) OperationB() string {
    return "子系统B操作"
}

// 子系统C
type SubsystemC struct{}

func (s *SubsystemC) OperationC() string {
    return "子系统C操作"
}

// 外观类
type Facade struct {
    subsystemA *SubsystemA
    subsystemB *SubsystemB
    subsystemC *SubsystemC
}

func NewFacade() *Facade {
    return &Facade{
        subsystemA: &SubsystemA{},
        subsystemB: &SubsystemB{},
        subsystemC: &SubsystemC{},
    }
}

// 简化的操作接口
func (f *Facade) SimpleOperation() string {
    result := "外观模式简化操作:\n"
    result += f.subsystemA.OperationA() + "\n"
    result += f.subsystemB.OperationB() + "\n"
    result += f.subsystemC.OperationC()
    return result
}

func main() {
    facade := NewFacade()
    
    // 使用外观模式简化复杂系统的调用
    fmt.Println(facade.SimpleOperation())
    
    // 如果不使用外观模式，需要分别调用各个子系统
    subsystemA := &SubsystemA{}
    subsystemB := &SubsystemB{}
    subsystemC := &SubsystemC{}
    
    fmt.Println("\n直接调用子系统:")
    fmt.Println(subsystemA.OperationA())
    fmt.Println(subsystemB.OperationB())
    fmt.Println(subsystemC.OperationC())
}
```

## 18.4 行为型模式

### 18.4.1 观察者模式（Observer）

```go
// 文件: backend/go/code/chapter18/observer/main.go
package main

import (
    "fmt"
    "sync"
)

// 观察者接口
type Observer interface {
    Update(message string)
}

// 主题接口
type Subject interface {
    Register(observer Observer)
    Deregister(observer Observer)
    Notify(message string)
}

// 具体主题：新闻发布者
type NewsPublisher struct {
    observers []Observer
    mutex     sync.Mutex
}

func NewNewsPublisher() *NewsPublisher {
    return &NewsPublisher{
        observers: make([]Observer, 0),
    }
}

func (p *NewsPublisher) Register(observer Observer) {
    p.mutex.Lock()
    defer p.mutex.Unlock()
    
    p.observers = append(p.observers, observer)
    fmt.Printf("观察者已注册，当前观察者数量: %d\n", len(p.observers))
}

func (p *NewsPublisher) Deregister(observer Observer) {
    p.mutex.Lock()
    defer p.mutex.Unlock()
    
    for i, obs := range p.observers {
        if obs == observer {
            p.observers = append(p.observers[:i], p.observers[i+1:]...)
            fmt.Printf("观察者已注销，当前观察者数量: %d\n", len(p.observers))
            return
        }
    }
}

func (p *NewsPublisher) Notify(message string) {
    p.mutex.Lock()
    observers := make([]Observer, len(p.observers))
    copy(observers, p.observers)
    p.mutex.Unlock()
    
    for _, observer := range observers {
        observer.Update(message)
    }
}

func (p *NewsPublisher) PublishNews(news string) {
    fmt.Printf("\n发布新闻: %s\n", news)
    p.Notify(news)
}

// 具体观察者：邮件订阅者
type EmailSubscriber struct {
    name string
}

func NewEmailSubscriber(name string) *EmailSubscriber {
    return &EmailSubscriber{
        name: name,
    }
}

func (e *EmailSubscriber) Update(message string) {
    fmt.Printf("邮件订阅者 %s 收到新闻: %s\n", e.name, message)
}

// 具体观察者：短信订阅者
type SMSSubscriber struct {
    phone string
}

func NewSMSSubscriber(phone string) *SMSSubscriber {
    return &SMSSubscriber{
        phone: phone,
    }
}

func (s *SMSSubscriber) Update(message string) {
    fmt.Printf("短信订阅者 %s 收到新闻: %s\n", s.phone, message)
}

func main() {
    publisher := NewNewsPublisher()
    
    // 创建订阅者
    emailSubscriber1 := NewEmailSubscriber("张三")
    emailSubscriber2 := NewEmailSubscriber("李四")
    smsSubscriber := NewSMSSubscriber("13800138000")
    
    // 注册订阅者
    publisher.Register(emailSubscriber1)
    publisher.Register(emailSubscriber2)
    publisher.Register(smsSubscriber)
    
    // 发布新闻
    publisher.PublishNews("Go语言发布新版本!")
    
    // 注销一个订阅者
    publisher.Deregister(emailSubscriber2)
    
    // 再次发布新闻
    publisher.PublishNews("设计模式在Go中的应用")
}
```

### 18.4.2 策略模式（Strategy）

```go
// 文件: backend/go/code/chapter18/strategy/main.go
package main

import "fmt"

// 支付策略接口
type PaymentStrategy interface {
    Pay(amount float64) string
}

// 具体策略：支付宝支付
type AlipayStrategy struct{}

func (a *AlipayStrategy) Pay(amount float64) string {
    return fmt.Sprintf("使用支付宝支付 %.2f 元", amount)
}

// 具体策略：微信支付
type WechatPayStrategy struct{}

func (w *WechatPayStrategy) Pay(amount float64) string {
    return fmt.Sprintf("使用微信支付 %.2f 元", amount)
}

// 具体策略：信用卡支付
type CreditCardStrategy struct {
    cardNumber string
}

func NewCreditCardStrategy(cardNumber string) *CreditCardStrategy {
    return &CreditCardStrategy{
        cardNumber: cardNumber,
    }
}

func (c *CreditCardStrategy) Pay(amount float64) string {
    return fmt.Sprintf("使用信用卡(%s)支付 %.2f 元", c.cardNumber, amount)
}

// 支付上下文
type PaymentContext struct {
    strategy PaymentStrategy
}

func NewPaymentContext(strategy PaymentStrategy) *PaymentContext {
    return &PaymentContext{
        strategy: strategy,
    }
}

func (p *PaymentContext) SetStrategy(strategy PaymentStrategy) {
    p.strategy = strategy
}

func (p *PaymentContext) ExecutePayment(amount float64) string {
    return p.strategy.Pay(amount)
}

func main() {
    amount := 100.50
    
    // 使用支付宝支付
    alipay := &AlipayStrategy{}
    context := NewPaymentContext(alipay)
    fmt.Println(context.ExecutePayment(amount))
    
    // 切换到微信支付
    wechatPay := &WechatPayStrategy{}
    context.SetStrategy(wechatPay)
    fmt.Println(context.ExecutePayment(amount))
    
    // 切换到信用卡支付
    creditCard := NewCreditCardStrategy("1234-5678-9012-3456")
    context.SetStrategy(creditCard)
    fmt.Println(context.ExecutePayment(amount))
}
```

### 18.4.3 命令模式（Command）

```go
// 文件: backend/go/code/chapter18/command/main.go
package main

import "fmt"

// 命令接口
type Command interface {
    Execute()
    Undo()
}

// 接收者：文本编辑器
type TextEditor struct {
    content string
}

func NewTextEditor() *TextEditor {
    return &TextEditor{
        content: "",
    }
}

func (t *TextEditor) GetContent() string {
    return t.content
}

func (t *TextEditor) Append(text string) {
    t.content += text
}

func (t *TextEditor) DeleteLast(n int) {
    if len(t.content) >= n {
        t.content = t.content[:len(t.content)-n]
    }
}

// 具体命令：添加文本
type AppendCommand struct {
    editor   *TextEditor
    text     string
    previous string
}

func NewAppendCommand(editor *TextEditor, text string) *AppendCommand {
    return &AppendCommand{
        editor:   editor,
        text:     text,
        previous: editor.GetContent(),
    }
}

func (a *AppendCommand) Execute() {
    a.editor.Append(a.text)
    fmt.Printf("执行添加命令: %s\n", a.text)
}

func (a *AppendCommand) Undo() {
    a.editor.content = a.previous
    fmt.Printf("撤销添加命令，恢复为: %s\n", a.previous)
}

// 具体命令：删除文本
type DeleteCommand struct {
    editor   *TextEditor
    n        int
    deleted  string
    previous string
}

func NewDeleteCommand(editor *TextEditor, n int) *DeleteCommand {
    return &DeleteCommand{
        editor:   editor,
        n:        n,
        previous: editor.GetContent(),
    }
}

func (d *DeleteCommand) Execute() {
    if len(d.editor.GetContent()) >= d.n {
        d.deleted = d.editor.GetContent()[len(d.editor.GetContent())-d.n:]
        d.editor.DeleteLast(d.n)
        fmt.Printf("执行删除命令: 删除 %d 个字符\n", d.n)
    }
}

func (d *DeleteCommand) Undo() {
    d.editor.content = d.previous
    fmt.Printf("撤销删除命令，恢复为: %s\n", d.previous)
}

// 调用者
type Invoker struct {
    history []Command
}

func NewInvoker() *Invoker {
    return &Invoker{
        history: make([]Command, 0),
    }
}

func (i *Invoker) ExecuteCommand(command Command) {
    command.Execute()
    i.history = append(i.history, command)
}

func (i *Invoker) UndoLast() {
    if len(i.history) > 0 {
        lastCommand := i.history[len(i.history)-1]
        lastCommand.Undo()
        i.history = i.history[:len(i.history)-1]
    }
}

func main() {
    editor := NewTextEditor()
    invoker := NewInvoker()
    
    fmt.Printf("初始内容: %s\n", editor.GetContent())
    
    // 执行一系列命令
    appendCmd1 := NewAppendCommand(editor, "Hello")
    invoker.ExecuteCommand(appendCmd1)
    fmt.Printf("当前内容: %s\n", editor.GetContent())
    
    appendCmd2 := NewAppendCommand(editor, " World")
    invoker.ExecuteCommand(appendCmd2)
    fmt.Printf("当前内容: %s\n", editor.GetContent())
    
    deleteCmd := NewDeleteCommand(editor, 5)
    invoker.ExecuteCommand(deleteCmd)
    fmt.Printf("当前内容: %s\n", editor.GetContent())
    
    // 撤销操作
    fmt.Println("\n执行撤销操作:")
    invoker.UndoLast()
    fmt.Printf("撤销后内容: %s\n", editor.GetContent())
    
    invoker.UndoLast()
    fmt.Printf("再次撤销后内容: %s\n", editor.GetContent())
}
```

## 18.5 Go语言特有的模式

### 18.5.1 函数选项模式（Functional Options）

```go
// 文件: backend/go/code/chapter18/functional-options/main.go
package main

import "fmt"

// 服务器配置
type ServerConfig struct {
    host     string
    port     int
    protocol string
    timeout  int
    maxConn  int
}

// 选项函数类型
type Option func(*ServerConfig)

// 各种选项函数
func WithHost(host string) Option {
    return func(c *ServerConfig) {
        c.host = host
    }
}

func WithPort(port int) Option {
    return func(c *ServerConfig) {
        c.port = port
    }
}

func WithProtocol(protocol string) Option {
    return func(c *ServerConfig) {
        c.protocol = protocol
    }
}

func WithTimeout(timeout int) Option {
    return func(c *ServerConfig) {
        c.timeout = timeout
    }
}

func WithMaxConn(maxConn int) Option {
    return func(c *ServerConfig) {
        c.maxConn = maxConn
    }
}

// 创建服务器配置
func NewServerConfig(options ...Option) *ServerConfig {
    // 默认配置
    config := &ServerConfig{
        host:     "localhost",
        port:     8080,
        protocol: "http",
        timeout:  30,
        maxConn:  100,
    }
    
    // 应用选项
    for _, option := range options {
        option(config)
    }
    
    return config
}

func (c *ServerConfig) String() string {
    return fmt.Sprintf("ServerConfig{host=%s, port=%d, protocol=%s, timeout=%d, maxConn=%d}",
        c.host, c.port, c.protocol, c.timeout, c.maxConn)
}

func main() {
    // 使用默认配置
    defaultConfig := NewServerConfig()
    fmt.Printf("默认配置: %s\n", defaultConfig)
    
    // 使用自定义配置
    customConfig := NewServerConfig(
        WithHost("api.example.com"),
        WithPort(443),
        WithProtocol("https"),
        WithTimeout(60),
        WithMaxConn(500),
    )
    fmt.Printf("自定义配置: %s\n", customConfig)
    
    // 部分自定义
    partialConfig := NewServerConfig(
        WithHost("127.0.0.1"),
        WithMaxConn(200),
    )
    fmt.Printf("部分自定义配置: %s\n", partialConfig)
}
```

### 18.5.2 管道模式（Pipeline）

```go
// 文件: backend/go/code/chapter18/pipeline/main.go
package main

import (
    "fmt"
    "strings"
)

// 管道函数类型
type PipelineFunc func(string) string

// 各种处理函数
func ToUpper(input string) string {
    return strings.ToUpper(input)
}

func TrimSpace(input string) string {
    return strings.TrimSpace(input)
}

func AddPrefix(prefix string) PipelineFunc {
    return func(input string) string {
        return prefix + input
    }
}

func AddSuffix(suffix string) PipelineFunc {
    return func(input string) string {
        return input + suffix
    }
}

func Replace(old, new string) PipelineFunc {
    return func(input string) string {
        return strings.ReplaceAll(input, old, new)
    }
}

// 构建管道
func Pipeline(input string, funcs ...PipelineFunc) string {
    result := input
    for _, f := range funcs {
        result = f(result)
    }
    return result
}

func main() {
    input := "   hello, world!   "
    
    // 构建处理管道
    result := Pipeline(input,
        TrimSpace,
        ToUpper,
        AddPrefix("PREFIX: "),
        AddSuffix(" :SUFFIX"),
        Replace("WORLD", "GOLANG"),
    )
    
    fmt.Printf("原始输入: '%s'\n", input)
    fmt.Printf("管道处理结果: '%s'\n", result)
    
    // 另一个例子：URL处理管道
    url := "  https://example.com/path/to/resource  "
    
    urlResult := Pipeline(url,
        TrimSpace,
        ToUpper,
        Replace("HTTPS", "HTTP"),
        AddPrefix("访问: "),
    )
    
    fmt.Printf("\nURL处理:\n")
    fmt.Printf("原始URL: '%s'\n", url)
    fmt.Printf("处理结果: '%s'\n", urlResult)
}
```

## 18.6 并发模式

### 18.6.1 Worker Pool模式

```go
// 文件: backend/go/code/chapter18/worker-pool/main.go
package main

import (
    "fmt"
    "sync"
    "time"
)

// 任务结构
type Task struct {
    ID   int
    Data interface{}
}

// 工作者
type Worker struct {
    ID       int
    taskChan chan Task
    quit     chan bool
}

func NewWorker(id int, taskChan chan Task) *Worker {
    return &Worker{
        ID:       id,
        taskChan: taskChan,
        quit:     make(chan bool),
    }
}

func (w *Worker) Start(wg *sync.WaitGroup) {
    wg.Add(1)
    go func() {
        defer wg.Done()
        
        for {
            select {
            case task := <-w.taskChan:
                fmt.Printf("工作者 %d 处理任务 %d: %v\n", w.ID, task.ID, task.Data)
                // 模拟处理时间
                time.Sleep(100 * time.Millisecond)
                fmt.Printf("工作者 %d 完成任务 %d\n", w.ID, task.ID)
                
            case <-w.quit:
                fmt.Printf("工作者 %d 停止\n", w.ID)
                return
            }
        }
    }()
}

func (w *Worker) Stop() {
    go func() {
        w.quit <- true
    }()
}

// 工作者池
type WorkerPool struct {
    workers   []*Worker
    taskChan  chan Task
    wg        sync.WaitGroup
}

func NewWorkerPool(numWorkers int) *WorkerPool {
    taskChan := make(chan Task, 100)
    
    workers := make([]*Worker, numWorkers)
    for i := 0; i < numWorkers; i++ {
        workers[i] = NewWorker(i+1, taskChan)
    }
    
    return &WorkerPool{
        workers:  workers,
        taskChan: taskChan,
    }
}

func (p *WorkerPool) Start() {
    for _, worker := range p.workers {
        worker.Start(&p.wg)
    }
}

func (p *WorkerPool) Stop() {
    close(p.taskChan)
    
    for _, worker := range p.workers {
        worker.Stop()
    }
    
    p.wg.Wait()
}

func (p *WorkerPool) Submit(task Task) {
    p.taskChan <- task
}

func main() {
    // 创建包含3个工作者的池
    pool := NewWorkerPool(3)
    pool.Start()
    
    // 提交10个任务
    for i := 1; i <= 10; i++ {
        task := Task{
            ID:   i,
            Data: fmt.Sprintf("任务数据-%d", i),
        }
        pool.Submit(task)
    }
    
    // 等待所有任务完成
    time.Sleep(2 * time.Second)
    
    // 停止工作者池
    pool.Stop()
    fmt.Println("所有工作者已停止")
}
```

### 18.6.2 Pub/Sub模式

```go
// 文件: backend/go/code/chapter18/pubsub/main.go
package main

import (
    "fmt"
    "sync"
    "time"
)

// 消息类型
type Message struct {
    Topic   string
    Content interface{}
}

// 订阅者接口
type Subscriber interface {
    Notify(message Message)
    GetID() string
}

// 具体订阅者
type ConcreteSubscriber struct {
    ID string
}

func NewConcreteSubscriber(id string) *ConcreteSubscriber {
    return &ConcreteSubscriber{
        ID: id,
    }
}

func (s *ConcreteSubscriber) Notify(message Message) {
    fmt.Printf("订阅者 %s 收到消息 [%s]: %v\n", s.ID, message.Topic, message.Content)
}

func (s *ConcreteSubscriber) GetID() string {
    return s.ID
}

// 发布订阅中心
type PubSub struct {
    subscribers map[string][]Subscriber
    mutex       sync.RWMutex
}

func NewPubSub() *PubSub {
    return &PubSub{
        subscribers: make(map[string][]Subscriber),
    }
}

func (p *PubSub) Subscribe(topic string, subscriber Subscriber) {
    p.mutex.Lock()
    defer p.mutex.Unlock()
    
    p.subscribers[topic] = append(p.subscribers[topic], subscriber)
    fmt.Printf("订阅者 %s 订阅了主题 %s\n", subscriber.GetID(), topic)
}

func (p *PubSub) Unsubscribe(topic string, subscriber Subscriber) {
    p.mutex.Lock()
    defer p.mutex.Unlock()
    
    if subscribers, exists := p.subscribers[topic]; exists {
        for i, sub := range subscribers {
            if sub.GetID() == subscriber.GetID() {
                p.subscribers[topic] = append(subscribers[:i], subscribers[i+1:]...)
                fmt.Printf("订阅者 %s 取消订阅主题 %s\n", subscriber.GetID(), topic)
                return
            }
        }
    }
}

func (p *PubSub) Publish(topic string, content interface{}) {
    p.mutex.RLock()
    subscribers := make([]Subscriber, len(p.subscribers[topic]))
    copy(subscribers, p.subscribers[topic])
    p.mutex.RUnlock()
    
    message := Message{
        Topic:   topic,
        Content: content,
    }
    
    for _, subscriber := range subscribers {
        subscriber.Notify(message)
    }
}

func main() {
    pubsub := NewPubSub()
    
    // 创建订阅者
    sub1 := NewConcreteSubscriber("subscriber-1")
    sub2 := NewConcreteSubscriber("subscriber-2")
    sub3 := NewConcreteSubscriber("subscriber-3")
    
    // 订阅主题
    pubsub.Subscribe("news", sub1)
    pubsub.Subscribe("news", sub2)
    pubsub.Subscribe("sports", sub2)
    pubsub.Subscribe("sports", sub3)
    
    // 发布消息
    pubsub.Publish("news", "Go语言发布新版本!")
    pubsub.Publish("sports", "世界杯决赛即将开始!")
    
    // 取消订阅
    time.Sleep(1 * time.Second)
    pubsub.Unsubscribe("news", sub1)
    
    // 再次发布消息
    pubsub.Publish("news", "取消订阅后的测试消息")
    pubsub.Publish("sports", "篮球比赛结果")
}
```

## 18.7 最佳实践

### 18.7.1 Go语言设计模式使用建议

1. **接口优先**：优先定义接口，然后实现具体类型
2. **组合优于继承**：使用组合来构建复杂对象
3. **简洁明了**：避免过度设计，保持代码简洁
4. **并发友好**：考虑并发场景下的线程安全

### 18.7.2 模式选择指南

- **创建型模式**：当需要灵活控制对象创建时使用
- **结构型模式**：当需要处理类或对象之间的关系时使用
- **行为型模式**：当需要处理对象间的通信和职责分配时使用
- **并发模式**：当需要处理高并发场景时使用

## 18.8 总结

本章详细介绍了Go语言中常用的设计模式，包括创建型、结构型、行为型模式以及Go语言特有的模式。通过实际代码示例，展示了如何在Go语言中优雅地实现这些模式。

设计模式是解决特定问题的经验总结，但并不是银弹。在实际开发中，应该根据具体需求选择合适的模式，避免过度设计。掌握这些模式将帮助您编写出更加可维护、可扩展的Go代码。