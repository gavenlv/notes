# 第10章：文件操作与IO

## 10.1 基础文件操作

### 10.1.1 文件读写基础

Go语言提供了丰富的文件操作API，位于`os`和`io`包中。

```go
package main

import (
    "fmt"
    "io"
    "os"
)

func main() {
    // 1. 写入文件
    content := "Hello, World!\n这是第二行\n这是第三行"
    
    err := os.WriteFile("test.txt", []byte(content), 0644)
    if err != nil {
        fmt.Printf("写入文件失败: %v\n", err)
        return
    }
    fmt.Println("文件写入成功")
    
    // 2. 读取整个文件
    data, err := os.ReadFile("test.txt")
    if err != nil {
        fmt.Printf("读取文件失败: %v\n", err)
        return
    }
    fmt.Printf("文件内容:\n%s\n", string(data))
    
    // 3. 逐行读取文件
    fmt.Println("\n逐行读取:")
    file, err := os.Open("test.txt")
    if err != nil {
        fmt.Printf("打开文件失败: %v\n", err)
        return
    }
    defer file.Close()
    
    buffer := make([]byte, 1024)
    for {
        n, err := file.Read(buffer)
        if err == io.EOF {
            break
        }
        if err != nil {
            fmt.Printf("读取错误: %v\n", err)
            break
        }
        fmt.Printf("读取到 %d 字节: %s", n, string(buffer[:n]))
    }
    
    // 4. 检查文件信息
    fileInfo, err := os.Stat("test.txt")
    if err != nil {
        fmt.Printf("获取文件信息失败: %v\n", err)
        return
    }
    
    fmt.Printf("\n文件信息:\n")
    fmt.Printf("名称: %s\n", fileInfo.Name())
    fmt.Printf("大小: %d 字节\n", fileInfo.Size())
    fmt.Printf("修改时间: %v\n", fileInfo.ModTime())
    fmt.Printf("权限: %s\n", fileInfo.Mode())
    
    // 5. 清理文件
    os.Remove("test.txt")
    fmt.Println("\n文件已清理")
}
```

### 10.1.2 文件操作进阶

```go
package main

import (
    "bufio"
    "fmt"
    "io"
    "os"
    "path/filepath"
)

func main() {
    // 1. 使用bufio逐行读取
    fmt.Println("=== 使用bufio逐行读取 ===")
    
    // 创建测试文件
    content := "第一行\n第二行\n第三行\n第四行"
    os.WriteFile("lines.txt", []byte(content), 0644)
    defer os.Remove("lines.txt")
    
    file, err := os.Open("lines.txt")
    if err != nil {
        fmt.Printf("打开文件失败: %v\n", err)
        return
    }
    defer file.Close()
    
    scanner := bufio.NewScanner(file)
    lineNumber := 1
    for scanner.Scan() {
        fmt.Printf("第%d行: %s\n", lineNumber, scanner.Text())
        lineNumber++
    }
    
    if err := scanner.Err(); err != nil {
        fmt.Printf("扫描错误: %v\n", err)
    }
    
    // 2. 使用bufio写入文件
    fmt.Println("\n=== 使用bufio写入文件 ===")
    
    outputFile, err := os.Create("output.txt")
    if err != nil {
        fmt.Printf("创建文件失败: %v\n", err)
        return
    }
    defer outputFile.Close()
    defer os.Remove("output.txt")
    
    writer := bufio.NewWriter(outputFile)
    
    lines := []string{"Apple", "Banana", "Cherry", "Date"}
    for _, line := range lines {
        fmt.Fprintln(writer, line)
    }
    
    writer.Flush() // 确保缓冲区内容写入文件
    fmt.Println("文件写入完成")
    
    // 3. 文件追加
    fmt.Println("\n=== 文件追加操作 ===")
    
    appendFile, err := os.OpenFile("append.txt", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        fmt.Printf("打开文件失败: %v\n", err)
        return
    }
    defer appendFile.Close()
    defer os.Remove("append.txt")
    
    if _, err := appendFile.WriteString("这是追加的内容\n"); err != nil {
        fmt.Printf("追加失败: %v\n", err)
        return
    }
    fmt.Println("内容追加成功")
    
    // 4. 文件路径操作
    fmt.Println("\n=== 文件路径操作 ===")
    
    path := "/home/user/documents/file.txt"
    fmt.Printf("原始路径: %s\n", path)
    fmt.Printf("目录: %s\n", filepath.Dir(path))
    fmt.Printf("文件名: %s\n", filepath.Base(path))
    fmt.Printf("扩展名: %s\n", filepath.Ext(path))
    
    // 5. 检查文件是否存在
    fmt.Println("\n=== 文件存在性检查 ===")
    
    if _, err := os.Stat("nonexistent.txt"); os.IsNotExist(err) {
        fmt.Println("文件不存在")
    } else {
        fmt.Println("文件存在")
    }
}
```

## 10.2 目录操作

### 10.2.1 目录遍历与管理

```go
package main

import (
    "fmt"
    "io/fs"
    "os"
    "path/filepath"
)

func main() {
    // 1. 创建目录
    fmt.Println("=== 目录操作 ===")
    
    err := os.Mkdir("testdir", 0755)
    if err != nil {
        fmt.Printf("创建目录失败: %v\n", err)
    } else {
        fmt.Println("目录创建成功")
    }
    
    // 创建嵌套目录
    err = os.MkdirAll("testdir/subdir1/subdir2", 0755)
    if err != nil {
        fmt.Printf("创建嵌套目录失败: %v\n", err)
    } else {
        fmt.Println("嵌套目录创建成功")
    }
    
    // 2. 遍历目录
    fmt.Println("\n=== 目录遍历 ===")
    
    entries, err := os.ReadDir("testdir")
    if err != nil {
        fmt.Printf("读取目录失败: %v\n", err)
        return
    }
    
    fmt.Println("目录内容:")
    for _, entry := range entries {
        info, _ := entry.Info()
        fmt.Printf("  %s (目录: %v, 大小: %d)\n", 
            entry.Name(), entry.IsDir(), info.Size())
    }
    
    // 3. 递归遍历目录
    fmt.Println("\n=== 递归遍历目录 ===")
    
    err = filepath.WalkDir("testdir", func(path string, d fs.DirEntry, err error) error {
        if err != nil {
            return err
        }
        
        if d.IsDir() {
            fmt.Printf("目录: %s\n", path)
        } else {
            fmt.Printf("文件: %s\n", path)
        }
        return nil
    })
    
    if err != nil {
        fmt.Printf("遍历失败: %v\n", err)
    }
    
    // 4. 删除目录
    fmt.Println("\n=== 清理目录 ===")
    
    err = os.RemoveAll("testdir")
    if err != nil {
        fmt.Printf("删除目录失败: %v\n", err)
    } else {
        fmt.Println("目录清理成功")
    }
    
    // 5. 获取当前工作目录
    fmt.Println("\n=== 工作目录操作 ===")
    
    cwd, err := os.Getwd()
    if err != nil {
        fmt.Printf("获取当前目录失败: %v\n", err)
    } else {
        fmt.Printf("当前工作目录: %s\n", cwd)
    }
    
    // 改变工作目录
    err = os.Chdir("/tmp")
    if err != nil {
        fmt.Printf("改变目录失败: %v\n", err)
    } else {
        newCwd, _ := os.Getwd()
        fmt.Printf("新工作目录: %s\n", newCwd)
        
        // 恢复原目录
        os.Chdir(cwd)
    }
}
```

### 10.2.2 文件监控

```go
package main

import (
    "fmt"
    "log"
    "os"
    "time"
    
    "github.com/fsnotify/fsnotify"
)

func main() {
    // 创建文件监控器
    watcher, err := fsnotify.NewWatcher()
    if err != nil {
        log.Fatal(err)
    }
    defer watcher.Close()
    
    // 创建测试目录和文件
    os.Mkdir("watchdir", 0755)
    defer os.RemoveAll("watchdir")
    
    // 监控目录
    err = watcher.Add("watchdir")
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Println("开始监控目录，5秒内进行文件操作...")
    
    // 在后台进行文件操作
    go func() {
        time.Sleep(1 * time.Second)
        
        // 创建文件
        os.WriteFile("watchdir/file1.txt", []byte("test"), 0644)
        time.Sleep(500 * time.Millisecond)
        
        // 修改文件
        os.WriteFile("watchdir/file1.txt", []byte("modified"), 0644)
        time.Sleep(500 * time.Millisecond)
        
        // 重命名文件
        os.Rename("watchdir/file1.txt", "watchdir/file2.txt")
        time.Sleep(500 * time.Millisecond)
        
        // 删除文件
        os.Remove("watchdir/file2.txt")
    }()
    
    // 处理监控事件
    done := make(chan bool)
    go func() {
        for {
            select {
            case event, ok := <-watcher.Events:
                if !ok {
                    return
                }
                fmt.Printf("事件: %s 文件: %s\n", event.Op, event.Name)
                
            case err, ok := <-watcher.Errors:
                if !ok {
                    return
                }
                log.Println("监控错误:", err)
            }
        }
    }()
    
    // 等待5秒后结束
    time.Sleep(5 * time.Second)
    done <- true
    fmt.Println("监控结束")
}
```

## 10.3 标准输入输出

### 10.3.1 标准IO操作

```go
package main

import (
    "bufio"
    "fmt"
    "os"
    "strings"
)

func main() {
    // 1. 标准输出
    fmt.Println("=== 标准输出 ===")
    fmt.Print("这是Print输出")
    fmt.Println("这是Println输出")
    fmt.Printf("格式化输出: %s %d %.2f\n", "Hello", 42, 3.14159)
    
    // 2. 标准输入
    fmt.Println("\n=== 标准输入 ===")
    
    fmt.Print("请输入您的姓名: ")
    var name string
    fmt.Scanln(&name)
    fmt.Printf("您好, %s!\n", name)
    
    // 3. 使用bufio读取输入
    fmt.Println("\n=== 使用bufio读取输入 ===")
    
    reader := bufio.NewReader(os.Stdin)
    fmt.Print("请输入一段文字: ")
    
    input, err := reader.ReadString('\n')
    if err != nil {
        fmt.Printf("读取输入失败: %v\n", err)
        return
    }
    
    // 去除换行符
    input = strings.TrimSpace(input)
    fmt.Printf("您输入的是: '%s'\n", input)
    
    // 4. 命令行参数
    fmt.Println("\n=== 命令行参数 ===")
    
    fmt.Printf("程序名称: %s\n", os.Args[0])
    
    if len(os.Args) > 1 {
        fmt.Println("命令行参数:")
        for i, arg := range os.Args[1:] {
            fmt.Printf("  %d: %s\n", i+1, arg)
        }
    } else {
        fmt.Println("没有额外的命令行参数")
    }
    
    // 5. 环境变量
    fmt.Println("\n=== 环境变量 ===")
    
    // 获取环境变量
    path := os.Getenv("PATH")
    if path != "" {
        fmt.Printf("PATH环境变量长度: %d\n", len(path))
    } else {
        fmt.Println("PATH环境变量未设置")
    }
    
    // 设置环境变量
    os.Setenv("MY_VAR", "my_value")
    fmt.Printf("MY_VAR: %s\n", os.Getenv("MY_VAR"))
    
    // 获取所有环境变量
    fmt.Println("\n所有环境变量:")
    for _, env := range os.Environ() {
        // 只显示前10个
        if strings.HasPrefix(env, "PATH") || strings.HasPrefix(env, "HOME") || 
           strings.HasPrefix(env, "USER") || strings.HasPrefix(env, "MY_") {
            fmt.Printf("  %s\n", env)
        }
    }
}
```

### 10.3.2 格式化IO

```go
package main

import (
    "bytes"
    "fmt"
    "io"
    "os"
    "strings"
)

func main() {
    // 1. 字符串IO
    fmt.Println("=== 字符串IO ===")
    
    var buffer bytes.Buffer
    
    // 写入缓冲区
    buffer.WriteString("Hello, ")
    buffer.WriteString("World!\n")
    buffer.WriteString("这是缓冲区内容")
    
    fmt.Printf("缓冲区内容:\n%s\n", buffer.String())
    fmt.Printf("缓冲区大小: %d\n", buffer.Len())
    
    // 2. 字符串读取器
    fmt.Println("\n=== 字符串读取器 ===")
    
    reader := strings.NewReader("这是一个测试字符串")
    
    // 读取部分内容
    part := make([]byte, 6)
    n, err := reader.Read(part)
    if err != nil && err != io.EOF {
        fmt.Printf("读取错误: %v\n", err)
        return
    }
    fmt.Printf("读取 %d 字节: %s\n", n, string(part[:n]))
    
    // 3. 多写入器
    fmt.Println("\n=== 多写入器 ===")
    
    var buf1, buf2 bytes.Buffer
    writer := io.MultiWriter(&buf1, &buf2, os.Stdout)
    
    fmt.Fprintln(writer, "这条消息会写入多个目标")
    
    fmt.Printf("缓冲区1: %s", buf1.String())
    fmt.Printf("缓冲区2: %s", buf2.String())
    
    // 4. TeeReader
    fmt.Println("\n=== TeeReader ===")
    
    source := strings.NewReader("原始数据流")
    var teedBuffer bytes.Buffer
    tee := io.TeeReader(source, &teedBuffer)
    
    // 读取数据
    data, _ := io.ReadAll(tee)
    fmt.Printf("读取的数据: %s\n", string(data))
    fmt.Printf("Tee缓冲区: %s\n", teedBuffer.String())
    
    // 5. 限流读取器
    fmt.Println("\n=== 限流读取器 ===")
    
    largeSource := strings.NewReader(strings.Repeat("x", 100))
    limited := io.LimitReader(largeSource, 10)
    
    limitedData, _ := io.ReadAll(limited)
    fmt.Printf("限制读取10字节: %s\n", string(limitedData))
}
```

## 10.4 文件压缩与归档

### 10.4.1 压缩文件操作

```go
package main

import (
    "archive/zip"
    "compress/gzip"
    "fmt"
    "io"
    "os"
    "path/filepath"
)

func main() {
    // 1. GZIP压缩
    fmt.Println("=== GZIP压缩 ===")
    
    // 创建原始文件
    originalContent := strings.Repeat("这是测试数据", 100)
    os.WriteFile("original.txt", []byte(originalContent), 0644)
    defer os.Remove("original.txt")
    
    // 压缩文件
    compressedFile, err := os.Create("compressed.gz")
    if err != nil {
        fmt.Printf("创建压缩文件失败: %v\n", err)
        return
    }
    defer compressedFile.Close()
    defer os.Remove("compressed.gz")
    
    gzipWriter := gzip.NewWriter(compressedFile)
    gzipWriter.Name = "original.txt"
    
    originalFile, _ := os.Open("original.txt")
    io.Copy(gzipWriter, originalFile)
    originalFile.Close()
    
    gzipWriter.Close()
    fmt.Println("GZIP压缩完成")
    
    // 解压缩
    compressedFile, _ = os.Open("compressed.gz")
    gzipReader, err := gzip.NewReader(compressedFile)
    if err != nil {
        fmt.Printf("创建解压缩读取器失败: %v\n", err)
        return
    }
    defer gzipReader.Close()
    
    decompressedContent, _ := io.ReadAll(gzipReader)
    fmt.Printf("解压缩内容长度: %d\n", len(decompressedContent))
    
    // 2. ZIP归档
    fmt.Println("\n=== ZIP归档 ===")
    
    zipFile, err := os.Create("archive.zip")
    if err != nil {
        fmt.Printf("创建ZIP文件失败: %v\n", err)
        return
    }
    defer zipFile.Close()
    defer os.Remove("archive.zip")
    
    zipWriter := zip.NewWriter(zipFile)
    
    // 添加文件到ZIP
    filesToAdd := []string{"original.txt"}
    
    for _, filename := range filesToAdd {
        fileToZip, err := os.Open(filename)
        if err != nil {
            fmt.Printf("打开文件失败: %v\n", err)
            continue
        }
        
        info, _ := fileToZip.Stat()
        header, err := zip.FileInfoHeader(info)
        if err != nil {
            fileToZip.Close()
            continue
        }
        
        header.Name = filename
        header.Method = zip.Deflate
        
        writer, err := zipWriter.CreateHeader(header)
        if err != nil {
            fileToZip.Close()
            continue
        }
        
        io.Copy(writer, fileToZip)
        fileToZip.Close()
    }
    
    zipWriter.Close()
    fmt.Println("ZIP归档完成")
    
    // 读取ZIP文件
    zipReader, err := zip.OpenReader("archive.zip")
    if err != nil {
        fmt.Printf("打开ZIP文件失败: %v\n", err)
        return
    }
    defer zipReader.Close()
    
    fmt.Println("ZIP文件内容:")
    for _, file := range zipReader.File {
        fmt.Printf("  文件: %s, 压缩大小: %d, 未压缩大小: %d\n",
            file.Name, file.CompressedSize64, file.UncompressedSize64)
    }
}
```

## 10.5 临时文件与目录

### 10.5.1 临时文件操作

```go
package main

import (
    "fmt"
    "io"
    "os"
    "path/filepath"
)

func main() {
    // 1. 创建临时文件
    fmt.Println("=== 临时文件操作 ===")
    
    tempFile, err := os.CreateTemp("", "example*.txt")
    if err != nil {
        fmt.Printf("创建临时文件失败: %v\n", err)
        return
    }
    
    fmt.Printf("临时文件: %s\n", tempFile.Name())
    
    // 写入临时文件
    content := "这是临时文件的内容"
    if _, err := tempFile.WriteString(content); err != nil {
        fmt.Printf("写入临时文件失败: %v\n", err)
        return
    }
    
    // 读取临时文件
    tempFile.Seek(0, 0)
    tempContent, _ := io.ReadAll(tempFile)
    fmt.Printf("临时文件内容: %s\n", string(tempContent))
    
    tempFile.Close()
    
    // 程序结束时自动清理
    defer os.Remove(tempFile.Name())
    
    // 2. 创建临时目录
    tempDir, err := os.MkdirTemp("", "exampledir")
    if err != nil {
        fmt.Printf("创建临时目录失败: %v\n", err)
        return
    }
    
    fmt.Printf("临时目录: %s\n", tempDir)
    
    // 在临时目录中创建文件
    tempFilePath := filepath.Join(tempDir, "tempfile.txt")
    os.WriteFile(tempFilePath, []byte("临时目录中的文件"), 0644)
    
    // 列出临时目录内容
    entries, _ := os.ReadDir(tempDir)
    fmt.Println("临时目录内容:")
    for _, entry := range entries {
        fmt.Printf("  %s\n", entry.Name())
    }
    
    // 清理临时目录
    defer os.RemoveAll(tempDir)
    
    fmt.Println("临时文件操作完成")
}
```

## 10.6 最佳实践总结

### 10.6.1 文件操作最佳实践

1. **错误处理**: 始终检查文件操作返回的错误
2. **资源清理**: 使用defer确保文件句柄被正确关闭
3. **路径安全**: 使用filepath包处理跨平台路径问题
4. **缓冲区管理**: 对于大文件使用适当的缓冲区大小

### 10.6.2 性能优化建议

1. **批量操作**: 对于大量小文件，考虑批量处理
2. **内存映射**: 对于大文件考虑使用内存映射文件
3. **异步IO**: 对于IO密集型操作考虑使用goroutine
4. **缓存策略**: 合理使用缓存减少磁盘IO

本章详细介绍了Go语言的文件操作与IO功能，包括基础文件读写、目录操作、标准IO、文件压缩和临时文件处理等。这些功能是构建实际应用程序的基础，熟练掌握这些知识对于开发高质量的Go程序至关重要。下一章我们将学习网络编程。