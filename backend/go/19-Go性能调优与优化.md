# 19. Go性能调优与优化

## 19.1 性能分析基础

### 性能分析工具

```go
// pprof性能分析
import (
    "net/http"
    _ "net/http/pprof"
    "runtime/pprof"
)

func main() {
    // 启动pprof HTTP服务器
    go func() {
        http.ListenAndServe("localhost:6060", nil)
    }()
    
    // 手动性能分析
    f, _ := os.Create("cpu.prof")
    pprof.StartCPUProfile(f)
    defer pprof.StopCPUProfile()
    
    // 内存分析
    pprof.WriteHeapProfile(f)
}
```

### 基准测试

```go
// 基准测试示例
func BenchmarkStringConcatenation(b *testing.B) {
    b.ReportAllocs()
    for i := 0; i < b.N; i++ {
        var s string
        for j := 0; j < 100; j++ {
            s += "a"
        }
    }
}

func BenchmarkStringBuilder(b *testing.B) {
    b.ReportAllocs()
    for i := 0; i < b.N; i++ {
        var sb strings.Builder
        for j := 0; j < 100; j++ {
            sb.WriteString("a")
        }
        _ = sb.String()
    }
}
```

## 19.2 内存优化

### 减少内存分配

```go
// 对象池技术
var pool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 1024)
    },
}

func processData() {
    buf := pool.Get().([]byte)
    defer pool.Put(buf)
    
    // 使用buf处理数据
}

// 预分配内存
func preAllocate() {
    // 不好的做法：频繁分配
    var data []int
    for i := 0; i < 1000; i++ {
        data = append(data, i)
    }
    
    // 好的做法：预分配
    data = make([]int, 0, 1000)
    for i := 0; i < 1000; i++ {
        data = append(data, i)
    }
}
```

### 逃逸分析

```go
// 逃逸分析示例
func noEscape() *int {
    x := 42
    return &x  // x逃逸到堆上
}

func escapeToHeap() {
    data := make([]byte, 1024)
    // data逃逸到堆上
    go func() {
        _ = data
    }()
}

// 避免逃逸的技术
func avoidEscape() {
    // 使用栈分配
    var buf [1024]byte
    processBuffer(buf[:])
}
```

## 19.3 CPU优化

### 并发优化

```go
// 工作池模式
func workerPool() {
    jobs := make(chan int, 100)
    results := make(chan int, 100)
    
    // 创建工作池
    for w := 0; w < runtime.NumCPU(); w++ {
        go func(id int) {
            for job := range jobs {
                results <- job * 2
            }
        }(w)
    }
    
    // 提交任务
    for i := 0; i < 1000; i++ {
        jobs <- i
    }
    close(jobs)
    
    // 收集结果
    for i := 0; i < 1000; i++ {
        <-results
    }
}
```

### 缓存优化

```go
// CPU缓存友好的数据结构
type CacheFriendly struct {
    data [1000]int64 // 连续内存布局
}

// 避免缓存不命中
func cacheOptimized() {
    // 好的做法：顺序访问
    data := make([]int, 1000000)
    for i := range data {
        data[i] = i
    }
    
    // 不好的做法：随机访问
    indices := rand.Perm(1000000)
    for _, idx := range indices {
        _ = data[idx]
    }
}
```

## 19.4 I/O优化

### 文件I/O优化

```go
// 缓冲I/O
func bufferedIO() {
    // 使用bufio提高性能
    file, _ := os.Open("largefile.txt")
    defer file.Close()
    
    reader := bufio.NewReader(file)
    scanner := bufio.NewScanner(reader)
    
    for scanner.Scan() {
        line := scanner.Text()
        _ = line
    }
}

// 批量写入
func batchWrite() {
    file, _ := os.Create("output.txt")
    defer file.Close()
    
    writer := bufio.NewWriter(file)
    defer writer.Flush()
    
    for i := 0; i < 10000; i++ {
        writer.WriteString(fmt.Sprintf("Line %d\n", i))
    }
}
```

### 网络I/O优化

```go
// 连接池
var client = &http.Client{
    Transport: &http.Transport{
        MaxIdleConns:        100,
        MaxIdleConnsPerHost: 10,
        IdleConnTimeout:     90 * time.Second,
    },
    Timeout: 30 * time.Second,
}

// 异步HTTP请求
func asyncHTTP() {
    urls := []string{"url1", "url2", "url3"}
    
    var wg sync.WaitGroup
    results := make(chan string, len(urls))
    
    for _, url := range urls {
        wg.Add(1)
        go func(u string) {
            defer wg.Done()
            resp, _ := client.Get(u)
            if resp != nil {
                defer resp.Body.Close()
                body, _ := io.ReadAll(resp.Body)
                results <- string(body)
            }
        }(url)
    }
    
    go func() {
        wg.Wait()
        close(results)
    }()
    
    for result := range results {
        _ = result
    }
}
```

## 19.5 数据库优化

### SQL优化

```go
// 批量插入
func batchInsert(db *sql.DB) {
    tx, _ := db.Begin()
    stmt, _ := tx.Prepare("INSERT INTO users (name, email) VALUES (?, ?)")
    defer stmt.Close()
    
    // 批量插入1000条记录
    for i := 0; i < 1000; i++ {
        stmt.Exec(fmt.Sprintf("user%d", i), fmt.Sprintf("user%d@example.com", i))
    }
    
    tx.Commit()
}

// 预处理语句
func preparedStatements(db *sql.DB) {
    stmt, _ := db.Prepare("SELECT id, name FROM users WHERE email = ?")
    defer stmt.Close()
    
    // 复用预处理语句
    for _, email := range []string{"a@example.com", "b@example.com"} {
        var id int
        var name string
        stmt.QueryRow(email).Scan(&id, &name)
    }
}
```

## 19.6 编译优化

### 编译器标志

```bash
# 优化编译
GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o app

# 禁用符号表和调试信息
# -s: 省略符号表
# -w: 省略DWARF符号表
```

### 内联优化

```go
// 内联函数示例
//go:noinline
func notInlined(x int) int {
    return x * 2
}

// 可能被内联的函数
func mayInline(x int) int {
    return x + 1
}

func caller() {
    result := mayInline(42) // 可能被内联
    _ = result
}
```

## 19.7 性能监控

### 实时性能监控

```go
// 自定义性能监控
type PerformanceMonitor struct {
    mu          sync.RWMutex
    requestCount int64
    errorCount   int64
    latencySum   time.Duration
}

func (pm *PerformanceMonitor) RecordRequest(latency time.Duration, err error) {
    pm.mu.Lock()
    defer pm.mu.Unlock()
    
    pm.requestCount++
    if err != nil {
        pm.errorCount++
    }
    pm.latencySum += latency
}

func (pm *PerformanceMonitor) Stats() (avgLatency time.Duration, errorRate float64) {
    pm.mu.RLock()
    defer pm.mu.RUnlock()
    
    if pm.requestCount > 0 {
        avgLatency = pm.latencySum / time.Duration(pm.requestCount)
        errorRate = float64(pm.errorCount) / float64(pm.requestCount)
    }
    return
}
```

### 性能指标导出

```go
// Prometheus指标
import "github.com/prometheus/client_golang/prometheus"

var (
    requestCounter = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "status"},
    )
    
    responseTime = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_response_time_seconds",
            Help:    "HTTP response time in seconds",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method"},
    )
)

func init() {
    prometheus.MustRegister(requestCounter, responseTime)
}
```

## 19.8 总结

性能优化是一个持续的过程，需要：
1. 测量而不是猜测
2. 使用合适的工具进行性能分析
3. 关注热点代码
4. 平衡可读性和性能
5. 定期进行性能测试