# 第14章：性能优化与调试

## 14.1 性能分析工具

### 14.1.1 pprof性能分析

```go
package main

import (
    "log"
    "net/http"
    _ "net/http/pprof"
    "runtime"
    "time"
)

func main() {
    // 启动pprof服务器
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    // 模拟内存泄漏
    go leakMemory()
    
    // 模拟CPU密集型任务
    go cpuIntensiveTask()
    
    // 主程序逻辑
    for {
        processRequest()
        time.Sleep(100 * time.Millisecond)
    }
}

func leakMemory() {
    var slice []byte
    for {
        slice = append(slice, make([]byte, 1024*1024)...) // 每次分配1MB
        time.Sleep(time.Second)
    }
}

func cpuIntensiveTask() {
    for {
        // 模拟CPU密集型计算
        for i := 0; i < 1000000; i++ {
            _ = i * i
        }
        time.Sleep(100 * time.Millisecond)
    }
}

func processRequest() {
    // 模拟请求处理
    time.Sleep(50 * time.Millisecond)
}
```

### 14.1.2 使用pprof分析

```go
package main

import (
    "fmt"
    "log"
    "os"
    "runtime/pprof"
    "time"
)

func main() {
    // CPU性能分析
    cpuProfile, err := os.Create("cpu.prof")
    if err != nil {
        log.Fatal(err)
    }
    defer cpuProfile.Close()
    
    pprof.StartCPUProfile(cpuProfile)
    defer pprof.StopCPUProfile()
    
    // 内存性能分析
    defer func() {
        memProfile, err := os.Create("mem.prof")
        if err != nil {
            log.Fatal(err)
        }
        defer memProfile.Close()
        
        pprof.WriteHeapProfile(memProfile)
    }()
    
    // 执行性能测试
    benchmark()
}

func benchmark() {
    fmt.Println("开始性能测试...")
    
    // 测试1: 字符串拼接性能
    start := time.Now()
    concatenateStrings()
    fmt.Printf("字符串拼接耗时: %v\n", time.Since(start))
    
    // 测试2: 切片操作性能
    start = time.Now()
    sliceOperations()
    fmt.Printf("切片操作耗时: %v\n", time.Since(start))
    
    // 测试3: 并发性能
    start = time.Now()
    concurrentOperations()
    fmt.Printf("并发操作耗时: %v\n", time.Since(start))
}

func concatenateStrings() {
    var result string
    for i := 0; i < 10000; i++ {
        result += fmt.Sprintf("Number: %d ", i)
    }
}

func sliceOperations() {
    var slice []int
    for i := 0; i < 100000; i++ {
        slice = append(slice, i)
    }
    
    // 各种切片操作
    for i := 0; i < len(slice); i += 2 {
        slice[i] = slice[i] * 2
    }
}

func concurrentOperations() {
    ch := make(chan int, 100)
    
    // 生产者
    go func() {
        for i := 0; i < 1000; i++ {
            ch <- i
        }
        close(ch)
    }()
    
    // 消费者
    var sum int
    for i := 0; i < 10; i++ {
        go func() {
            for num := range ch {
                sum += num
            }
        }()
    }
}
```

## 14.2 内存优化

### 14.2.1 减少内存分配

```go
package main

import (
    "fmt"
    "strings"
    "time"
)

func main() {
    // 测试不同字符串拼接方式的性能
    testStringConcat()
    testPreAllocatedSlice()
    testBufferUsage()
}

// 低效的字符串拼接
func inefficientConcat() string {
    var result string
    for i := 0; i < 1000; i++ {
        result += fmt.Sprintf("%d", i)
    }
    return result
}

// 使用strings.Builder
func efficientConcat() string {
    var builder strings.Builder
    for i := 0; i < 1000; i++ {
        builder.WriteString(fmt.Sprintf("%d", i))
    }
    return builder.String()
}

// 预分配切片
func preAllocatedSlice() []int {
    // 错误方式：多次重新分配
    var slice []int
    for i := 0; i < 100000; i++ {
        slice = append(slice, i)
    }
    
    // 正确方式：预分配容量
    slice = make([]int, 0, 100000)
    for i := 0; i < 100000; i++ {
        slice = append(slice, i)
    }
    
    return slice
}

func testStringConcat() {
    start := time.Now()
    inefficientConcat()
    fmt.Printf("低效拼接耗时: %v\n", time.Since(start))
    
    start = time.Now()
    efficientConcat()
    fmt.Printf("高效拼接耗时: %v\n", time.Since(start))
}

func testPreAllocatedSlice() {
    start := time.Now()
    preAllocatedSlice()
    fmt.Printf("预分配切片耗时: %v\n", time.Since(start))
}

func testBufferUsage() {
    // 使用字节缓冲池
    start := time.Now()
    
    for i := 0; i < 1000; i++ {
        processWithBuffer()
    }
    
    fmt.Printf("使用缓冲池耗时: %v\n", time.Since(start))
}

func processWithBuffer() {
    // 模拟使用缓冲池的处理
    buffer := make([]byte, 1024)
    // 使用buffer处理数据
    _ = buffer
}
```

### 14.2.2 对象池模式

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type ExpensiveObject struct {
    data []byte
}

func (o *ExpensiveObject) Reset() {
    o.data = o.data[:0] // 重用底层数组
}

var objectPool = sync.Pool{
    New: func() interface{} {
        return &ExpensiveObject{
            data: make([]byte, 0, 1024),
        }
    },
}

func getObject() *ExpensiveObject {
    return objectPool.Get().(*ExpensiveObject)
}

func putObject(obj *ExpensiveObject) {
    obj.Reset()
    objectPool.Put(obj)
}

func main() {
    // 测试对象池性能
    start := time.Now()
    
    var wg sync.WaitGroup
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            obj := getObject()
            defer putObject(obj)
            
            // 使用对象处理数据
            processWithObject(obj)
        }()
    }
    
    wg.Wait()
    fmt.Printf("使用对象池耗时: %v\n", time.Since(start))
    
    // 对比：不使用对象池
    start = time.Now()
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            obj := &ExpensiveObject{
                data: make([]byte, 0, 1024),
            }
            
            processWithObject(obj)
        }()
    }
    
    wg.Wait()
    fmt.Printf("不使用对象池耗时: %v\n", time.Since(start))
}

func processWithObject(obj *ExpensiveObject) {
    // 模拟数据处理
    for i := 0; i < 100; i++ {
        obj.data = append(obj.data, byte(i))
    }
}
```

## 14.3 并发优化

### 14.3.1 避免竞争条件

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)

func main() {
    testMutexPerformance()
    testAtomicPerformance()
    testChannelPerformance()
}

// 使用互斥锁
func mutexCounter() {
    var mutex sync.Mutex
    var count int
    
    var wg sync.WaitGroup
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            mutex.Lock()
            count++
            mutex.Unlock()
        }()
    }
    
    wg.Wait()
    fmt.Printf("互斥锁计数结果: %d\n", count)
}

// 使用原子操作
func atomicCounter() {
    var count int64
    
    var wg sync.WaitGroup
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            atomic.AddInt64(&count, 1)
        }()
    }
    
    wg.Wait()
    fmt.Printf("原子操作计数结果: %d\n", count)
}

func testMutexPerformance() {
    start := time.Now()
    mutexCounter()
    fmt.Printf("互斥锁性能测试耗时: %v\n", time.Since(start))
}

func testAtomicPerformance() {
    start := time.Now()
    atomicCounter()
    fmt.Printf("原子操作性能测试耗时: %v\n", time.Since(start))
}

func testChannelPerformance() {
    start := time.Now()
    
    ch := make(chan int, 100)
    done := make(chan bool)
    
    // 生产者
    go func() {
        for i := 0; i < 1000; i++ {
            ch <- i
        }
        close(ch)
    }()
    
    // 消费者
    var sum int
    for i := 0; i < 10; i++ {
        go func() {
            for num := range ch {
                sum += num
            }
            done <- true
        }()
    }
    
    // 等待所有消费者完成
    for i := 0; i < 10; i++ {
        <-done
    }
    
    fmt.Printf("通道通信性能测试耗时: %v, 结果: %d\n", time.Since(start), sum)
}
```

### 14.3.2 工作池模式

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type Task struct {
    ID   int
    Data string
}

type WorkerPool struct {
    tasks   chan Task
    results chan string
    wg      sync.WaitGroup
}

func NewWorkerPool(numWorkers int) *WorkerPool {
    pool := &WorkerPool{
        tasks:   make(chan Task, 100),
        results: make(chan string, 100),
    }
    
    // 启动工作协程
    for i := 0; i < numWorkers; i++ {
        pool.wg.Add(1)
        go pool.worker(i)
    }
    
    return pool
}

func (p *WorkerPool) worker(id int) {
    defer p.wg.Done()
    
    for task := range p.tasks {
        // 模拟处理任务
        result := fmt.Sprintf("Worker %d processed task %d: %s", 
            id, task.ID, task.Data)
        
        time.Sleep(10 * time.Millisecond) // 模拟处理时间
        
        p.results <- result
    }
}

func (p *WorkerPool) Submit(task Task) {
    p.tasks <- task
}

func (p *WorkerPool) Close() {
    close(p.tasks)
    p.wg.Wait()
    close(p.results)
}

func (p *WorkerPool) GetResults() []string {
    var results []string
    
    for result := range p.results {
        results = append(results, result)
    }
    
    return results
}

func main() {
    // 创建包含4个工作协程的池
    pool := NewWorkerPool(4)
    
    // 提交任务
    for i := 0; i < 100; i++ {
        task := Task{
            ID:   i,
            Data: fmt.Sprintf("Data for task %d", i),
        }
        pool.Submit(task)
    }
    
    // 关闭池并获取结果
    pool.Close()
    
    results := pool.GetResults()
    fmt.Printf("处理了 %d 个任务\n", len(results))
    
    // 显示前5个结果
    for i := 0; i < 5 && i < len(results); i++ {
        fmt.Println(results[i])
    }
}
```

## 14.4 调试技巧

### 14.4.1 使用GDB调试

```go
package main

import (
    "fmt"
    "runtime"
)

func main() {
    // 设置调试信息
    fmt.Println("程序开始执行...")
    
    // 获取goroutine信息
    debugGoroutines()
    
    // 模拟复杂逻辑
    complexFunction()
    
    fmt.Println("程序执行完成")
}

func debugGoroutines() {
    // 打印当前goroutine数量
    num := runtime.NumGoroutine()
    fmt.Printf("当前goroutine数量: %d\n", num)
    
    // 打印堆栈信息
    buf := make([]byte, 1024)
    n := runtime.Stack(buf, false)
    fmt.Printf("当前堆栈信息:\n%s\n", buf[:n])
}

func complexFunction() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("捕获到panic: %v\n", r)
            
            // 打印堆栈跟踪
            buf := make([]byte, 4096)
            n := runtime.Stack(buf, false)
            fmt.Printf("堆栈跟踪:\n%s\n", buf[:n])
        }
    }()
    
    // 模拟可能panic的代码
    riskyOperation()
}

func riskyOperation() {
    var slice []int
    
    // 这里会panic
    slice[0] = 1
}
```

### 14.4.2 日志调试

```go
package main

import (
    "log"
    "os"
    "time"
)

var logger = log.New(os.Stdout, "DEBUG: ", log.Ldate|log.Ltime|log.Lshortfile)

func main() {
    // 设置日志级别
    log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)
    
    logger.Println("程序启动")
    
    // 模拟业务逻辑
    processData()
    
    logger.Println("程序结束")
}

func processData() {
    start := time.Now()
    defer func() {
        logger.Printf("processData 执行耗时: %v\n", time.Since(start))
    }()
    
    logger.Println("开始处理数据")
    
    // 模拟数据处理
    for i := 0; i < 5; i++ {
        logger.Printf("处理第 %d 批数据\n", i+1)
        time.Sleep(100 * time.Millisecond)
    }
    
    logger.Println("数据处理完成")
}
```

## 14.5 性能优化最佳实践

1. **内存管理**：减少不必要的内存分配，使用对象池
2. **并发控制**：合理使用锁和原子操作，避免竞争条件
3. **算法优化**：选择合适的数据结构和算法
4. **I/O优化**：使用缓冲和批量操作减少I/O次数
5. **性能监控**：持续监控应用性能，及时发现瓶颈
6. **代码审查**：定期进行代码审查，优化性能热点
7. **基准测试**：编写基准测试，验证优化效果