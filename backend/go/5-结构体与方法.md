# 第5章：结构体与方法

## 5.1 结构体（Struct）

### 5.1.1 结构体的定义与使用

结构体是Go语言中自定义复合类型的基础：

```go
package main

import "fmt"

// 定义结构体
type Person struct {
    Name    string
    Age     int
    Address string
}

// 嵌套结构体
type Employee struct {
    Person       // 匿名嵌入
    EmployeeID   int
    Department   string
    Salary       float64
}

// 带标签的结构体（用于JSON序列化等）
type User struct {
    ID       int    `json:"id"`
    Username string `json:"username"`
    Email    string `json:"email"`
    Password string `json:"-"` // 不序列化
}

func main() {
    // 1. 声明并初始化结构体
    var p1 Person
    p1.Name = "张三"
    p1.Age = 25
    p1.Address = "北京市"
    
    // 2. 使用字面量初始化
    p2 := Person{
        Name:    "李四",
        Age:     30,
        Address: "上海市",
    }
    
    // 3. 顺序初始化（不推荐，容易出错）
    p3 := Person{"王五", 28, "广州市"}
    
    fmt.Printf("p1: %+v\n", p1)
    fmt.Printf("p2: %+v\n", p2)
    fmt.Printf("p3: %+v\n", p3)
    
    // 4. 嵌套结构体
    emp := Employee{
        Person: Person{
            Name:    "赵六",
            Age:     35,
            Address: "深圳市",
        },
        EmployeeID: 1001,
        Department: "技术部",
        Salary:     15000.0,
    }
    
    fmt.Printf("\n员工信息: %+v\n", emp)
    fmt.Printf("员工姓名: %s\n", emp.Name) // 匿名嵌入字段可直接访问
    
    // 5. 结构体指针
    p4 := &Person{"钱七", 40, "杭州市"}
    fmt.Printf("\n指针访问: %s\n", p4.Name) // 自动解引用
    
    // 6. 结构体比较
    p5 := Person{"张三", 25, "北京市"}
    fmt.Printf("p1 == p5: %t\n", p1 == p5)
    
    // 7. 结构体作为函数参数
    updateAge(&p1, 26)
    fmt.Printf("更新后年龄: %d\n", p1.Age)
}

func updateAge(p *Person, newAge int) {
    p.Age = newAge
}
```

### 5.1.2 结构体的高级特性

```go
package main

import (
    "fmt"
    "reflect"
)

// 私有字段结构体
type privateStruct struct {
    publicField  string
    privateField string // 小写开头，包外不可访问
}

// 空结构体（零字节，用于特殊场景）
type Empty struct{}

// 方法接收器类型
type Counter struct {
    count int
}

func main() {
    // 1. 反射获取结构体信息
    p := Person{"张三", 25, "北京市"}
    t := reflect.TypeOf(p)
    
    fmt.Println("=== 结构体反射信息 ===")
    fmt.Printf("类型名: %s\n", t.Name())
    fmt.Printf("字段数: %d\n", t.NumField())
    
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        fmt.Printf("字段%d: %s (类型: %s)\n", i+1, field.Name, field.Type)
    }
    
    // 2. 空结构体的使用
    fmt.Println("\n=== 空结构体 ===")
    var empty Empty
    fmt.Printf("空结构体大小: %d字节\n", unsafe.Sizeof(empty))
    
    // 用作map值（节省内存）
    set := make(map[string]Empty)
    set["key1"] = Empty{}
    set["key2"] = Empty{}
    fmt.Printf("集合大小: %d\n", len(set))
    
    // 3. 结构体嵌套和方法提升
    fmt.Println("\n=== 方法提升 ===")
    counter := Counter{count: 0}
    counter.Increment()
    counter.Increment()
    fmt.Printf("计数: %d\n", counter.Get())
    
    // 4. 结构体工厂函数
    fmt.Println("\n=== 工厂函数 ===")
    user1 := NewUser(1, "alice", "alice@example.com")
    user2 := NewUser(2, "bob", "bob@example.com")
    
    fmt.Printf("用户1: %+v\n", user1)
    fmt.Printf("用户2: %+v\n", user2)
}

// 工厂函数
func NewUser(id int, username, email string) *User {
    return &User{
        ID:       id,
        Username: username,
        Email:    email,
        Password: "", // 默认空密码
    }
}

// Counter的方法
func (c *Counter) Increment() {
    c.count++
}

func (c *Counter) Get() int {
    return c.count
}
```

## 5.2 方法（Method）

### 5.2.1 方法的定义与使用

方法是与特定类型关联的函数：

```go
package main

import (
    "fmt"
    "math"
)

// 矩形结构体
type Rectangle struct {
    Width  float64
    Height float64
}

// 圆结构体
type Circle struct {
    Radius float64
}

// 点结构体
type Point struct {
    X, Y float64
}

// Rectangle的方法：值接收器
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

// Rectangle的方法：指针接收器
func (r *Rectangle) Scale(factor float64) {
    r.Width *= factor
    r.Height *= factor
}

// Circle的方法
func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

// Point的方法：计算距离
func (p Point) DistanceTo(other Point) float64 {
    dx := p.X - other.X
    dy := p.Y - other.Y
    return math.Sqrt(dx*dx + dy*dy)
}

// 函数（非方法）
func CalculateArea(r Rectangle) float64 {
    return r.Width * r.Height
}

func main() {
    // 1. 值接收器方法
    rect := Rectangle{Width: 10, Height: 5}
    area := rect.Area()
    fmt.Printf("矩形面积: %.2f\n", area)
    
    // 2. 指针接收器方法
    rect.Scale(2)
    fmt.Printf("缩放后矩形: %+v\n", rect)
    fmt.Printf("缩放后面积: %.2f\n", rect.Area())
    
    // 3. 圆的方法
    circle := Circle{Radius: 5}
    fmt.Printf("圆面积: %.2f\n", circle.Area())
    
    // 4. 点的方法
    p1 := Point{X: 0, Y: 0}
    p2 := Point{X: 3, Y: 4}
    distance := p1.DistanceTo(p2)
    fmt.Printf("两点距离: %.2f\n", distance)
    
    // 5. 方法与函数的区别
    fmt.Printf("方法调用: %.2f\n", rect.Area())
    fmt.Printf("函数调用: %.2f\n", CalculateArea(rect))
    
    // 6. 方法集的概念
    fmt.Println("\n=== 方法集演示 ===")
    
    // 值类型的方法集包含值接收器方法
    var r1 Rectangle = Rectangle{Width: 2, Height: 3}
    fmt.Printf("r1.Area(): %.2f\n", r1.Area())
    
    // 指针类型的方法集包含所有方法
    r2 := &Rectangle{Width: 2, Height: 3}
    fmt.Printf("r2.Area(): %.2f\n", r2.Area())
    r2.Scale(2)
    fmt.Printf("缩放后: %+v\n", r2)
}
```

### 5.2.2 接口与方法集

```go
package main

import "fmt"

// 形状接口
type Shape interface {
    Area() float64
    Perimeter() float64
}

// 可缩放接口
type Scalable interface {
    Scale(float64)
}

// 矩形实现Shape接口
func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

// 三角形结构体
type Triangle struct {
    A, B, C float64 // 三边长度
}

// 三角形实现Shape接口
func (t Triangle) Area() float64 {
    // 海伦公式
    s := t.Perimeter() / 2
    return math.Sqrt(s * (s - t.A) * (s - t.B) * (s - t.C))
}

func (t Triangle) Perimeter() float64 {
    return t.A + t.B + t.C
}

// 打印形状信息
func PrintShapeInfo(s Shape) {
    fmt.Printf("面积: %.2f, 周长: %.2f\n", s.Area(), s.Perimeter())
}

// 缩放形状
func ScaleShape(s Scalable, factor float64) {
    s.Scale(factor)
}

func main() {
    // 1. 多态演示
    shapes := []Shape{
        Rectangle{Width: 3, Height: 4},
        Triangle{A: 3, B: 4, C: 5},
        Circle{Radius: 5},
    }
    
    fmt.Println("=== 多态演示 ===")
    for i, shape := range shapes {
        fmt.Printf("形状%d: ", i+1)
        PrintShapeInfo(shape)
    }
    
    // 2. 类型断言
    fmt.Println("\n=== 类型断言 ===")
    for i, shape := range shapes {
        fmt.Printf("形状%d: ", i+1)
        
        // 类型断言
        if rect, ok := shape.(Rectangle); ok {
            fmt.Printf("矩形 (宽:%.1f, 高:%.1f)\n", rect.Width, rect.Height)
        } else if tri, ok := shape.(Triangle); ok {
            fmt.Printf("三角形 (边:%.1f,%.1f,%.1f)\n", tri.A, tri.B, tri.C)
        } else if circle, ok := shape.(Circle); ok {
            fmt.Printf("圆 (半径:%.1f)\n", circle.Radius)
        }
    }
    
    // 3. 类型开关
    fmt.Println("\n=== 类型开关 ===")
    for i, shape := range shapes {
        fmt.Printf("形状%d: ", i+1)
        
        switch s := shape.(type) {
        case Rectangle:
            fmt.Printf("矩形, 面积:%.2f\n", s.Area())
        case Triangle:
            fmt.Printf("三角形, 面积:%.2f\n", s.Area())
        case Circle:
            fmt.Printf("圆, 面积:%.2f\n", s.Area())
        default:
            fmt.Printf("未知形状\n")
        }
    }
    
    // 4. 空接口
    fmt.Println("\n=== 空接口 ===")
    var anything interface{}
    
    anything = "Hello"
    fmt.Printf("字符串: %v\n", anything)
    
    anything = 42
    fmt.Printf("整数: %v\n", anything)
    
    anything = Rectangle{Width: 5, Height: 3}
    fmt.Printf("结构体: %v\n", anything)
}
```

## 5.3 组合与嵌入

### 5.3.1 结构体组合

```go
package main

import "fmt"

// 基础组件
type Engine struct {
    Power     int    // 马力
    FuelType  string // 燃料类型
}

func (e Engine) Start() {
    fmt.Printf("引擎启动，功率%d马力，燃料%s\n", e.Power, e.FuelType)
}

type Wheel struct {
    Size     int    // 尺寸
    Material string // 材质
}

func (w Wheel) Rotate() {
    fmt.Printf("车轮旋转，尺寸%d寸，材质%s\n", w.Size, w.Material)
}

// 汽车组合
type Car struct {
    Brand  string
    Model  string
    Engine Engine  // 组合
    Wheels [4]Wheel // 组合数组
}

func (c Car) Drive() {
    fmt.Printf("%s %s开始行驶\n", c.Brand, c.Model)
    c.Engine.Start()
    for i, wheel := range c.Wheels {
        fmt.Printf("车轮%d: ", i+1)
        wheel.Rotate()
    }
}

// 电动车（嵌入）
type ElectricCar struct {
    Car              // 嵌入Car
    BatteryCapacity int // 电池容量
    Range          int // 续航里程
}

func (ec ElectricCar) Charge() {
    fmt.Printf("充电中，电池容量%dkWh，续航%d公里\n", 
        ec.BatteryCapacity, ec.Range)
}

func main() {
    // 1. 组合演示
    fmt.Println("=== 组合演示 ===")
    car := Car{
        Brand: "Toyota",
        Model: "Camry",
        Engine: Engine{
            Power:    200,
            FuelType: "汽油",
        },
        Wheels: [4]Wheel{
            {Size: 17, Material: "铝合金"},
            {Size: 17, Material: "铝合金"},
            {Size: 17, Material: "铝合金"},
            {Size: 17, Material: "铝合金"},
        },
    }
    
    car.Drive()
    
    // 2. 嵌入演示
    fmt.Println("\n=== 嵌入演示 ===")
    electricCar := ElectricCar{
        Car: Car{
            Brand: "Tesla",
            Model: "Model 3",
            Engine: Engine{
                Power:    283,
                FuelType: "电力",
            },
            Wheels: [4]Wheel{
                {Size: 18, Material: "碳纤维"},
                {Size: 18, Material: "碳纤维"},
                {Size: 18, Material: "碳纤维"},
                {Size: 18, Material: "碳纤维"},
            },
        },
        BatteryCapacity: 75,
        Range:          500,
    }
    
    // 可以直接访问嵌入字段的方法
    electricCar.Drive()
    electricCar.Charge()
    
    // 3. 方法重写（如果需要）
    fmt.Println("\n=== 方法重写 ===")
    // 如果ElectricCar需要重写Drive方法，可以这样定义：
    // func (ec ElectricCar) Drive() {
    //     fmt.Printf("电动车%s %s静音行驶\n", ec.Brand, ec.Model)
    //     ec.Engine.Start()
    //     ec.Charge() // 额外功能
    // }
}
```

## 5.4 实践练习

### 练习1：银行账户系统

```go
package main

import (
    "errors"
    "fmt"
)

type Account struct {
    AccountNumber string
    HolderName    string
    Balance       float64
    Transactions []Transaction
}

type Transaction struct {
    Type   string  // "deposit", "withdraw", "transfer"
    Amount float64
    From   string
    To     string
    Time   string // 简化版，实际应该用time.Time
}

func NewAccount(number, name string, initialBalance float64) *Account {
    return &Account{
        AccountNumber: number,
        HolderName:    name,
        Balance:       initialBalance,
        Transactions:  make([]Transaction, 0),
    }
}

func (a *Account) Deposit(amount float64) error {
    if amount <= 0 {
        return errors.New("存款金额必须大于0")
    }
    
    a.Balance += amount
    a.recordTransaction("deposit", amount, "", a.AccountNumber)
    return nil
}

func (a *Account) Withdraw(amount float64) error {
    if amount <= 0 {
        return errors.New("取款金额必须大于0")
    }
    
    if amount > a.Balance {
        return errors.New("余额不足")
    }
    
    a.Balance -= amount
    a.recordTransaction("withdraw", amount, a.AccountNumber, "")
    return nil
}

func (a *Account) Transfer(to *Account, amount float64) error {
    if amount <= 0 {
        return errors.New("转账金额必须大于0")
    }
    
    if amount > a.Balance {
        return errors.New("余额不足")
    }
    
    // 执行转账
    a.Balance -= amount
    to.Balance += amount
    
    // 记录双方交易
    a.recordTransaction("transfer", amount, a.AccountNumber, to.AccountNumber)
    to.recordTransaction("transfer", amount, a.AccountNumber, to.AccountNumber)
    
    return nil
}

func (a *Account) recordTransaction(tType string, amount float64, from, to string) {
    transaction := Transaction{
        Type:   tType,
        Amount: amount,
        From:   from,
        To:     to,
        Time:   "2024-01-01 10:00:00", // 简化
    }
    
    a.Transactions = append(a.Transactions, transaction)
}

func (a *Account) GetBalance() float64 {
    return a.Balance
}

func (a *Account) PrintStatement() {
    fmt.Printf("=== 账户 %s 对账单 ===\n", a.AccountNumber)
    fmt.Printf("户主: %s\n", a.HolderName)
    fmt.Printf("当前余额: %.2f\n", a.Balance)
    fmt.Println("\n交易记录:")
    
    for i, tx := range a.Transactions {
        fmt.Printf("%d. %s: %.2f", i+1, tx.Type, tx.Amount)
        
        switch tx.Type {
        case "deposit":
            fmt.Printf(" (存入)")
        case "withdraw":
            fmt.Printf(" (取出)")
        case "transfer":
            if tx.From == a.AccountNumber {
                fmt.Printf(" (转出到 %s)", tx.To)
            } else {
                fmt.Printf(" (从 %s 转入)", tx.From)
            }
        }
        fmt.Printf(" - %s\n", tx.Time)
    }
}

func main() {
    // 创建账户
    account1 := NewAccount("1001", "张三", 1000.0)
    account2 := NewAccount("1002", "李四", 500.0)
    
    // 存款
    account1.Deposit(500.0)
    account2.Deposit(200.0)
    
    // 取款
    account1.Withdraw(300.0)
    
    // 转账
    account1.Transfer(account2, 200.0)
    
    // 打印对账单
    account1.PrintStatement()
    fmt.Println()
    account2.PrintStatement()
    
    // 错误处理演示
    fmt.Println("\n=== 错误处理演示 ===")
    
    // 尝试取款超过余额
    if err := account1.Withdraw(2000.0); err != nil {
        fmt.Printf("取款失败: %v\n", err)
    }
    
    // 尝试转账超过余额
    if err := account1.Transfer(account2, 3000.0); err != nil {
        fmt.Printf("转账失败: %v\n", err)
    }
}
```

### 练习2：几何图形计算器

```go
package main

import (
    "fmt"
    "math"
)

// 几何图形接口
type Geometry interface {
    Area() float64
    Perimeter() float64
    Name() string
}

// 点
type Point struct {
    X, Y float64
}

// 线段
type Line struct {
    Start, End Point
}

func (l Line) Length() float64 {
    dx := l.End.X - l.Start.X
    dy := l.End.Y - l.Start.Y
    return math.Sqrt(dx*dx + dy*dy)
}

// 矩形
type Rectangle struct {
    Width, Height float64
    Center        Point
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

func (r Rectangle) Name() string {
    return "矩形"
}

// 圆
type Circle struct {
    Radius float64
    Center Point
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
    return 2 * math.Pi * c.Radius
}

func (c Circle) Name() string {
    return "圆"
}

// 三角形
type Triangle struct {
    A, B, C Point
}

func (t Triangle) Area() float64 {
    // 使用坐标计算面积
    return math.Abs((t.A.X*(t.B.Y-t.C.Y) + t.B.X*(t.C.Y-t.A.Y) + t.C.X*(t.A.Y-t.B.Y)) / 2)
}

func (t Triangle) Perimeter() float64 {
    ab := Line{t.A, t.B}.Length()
    bc := Line{t.B, t.C}.Length()
    ca := Line{t.C, t.A}.Length()
    return ab + bc + ca
}

func (t Triangle) Name() string {
    return "三角形"
}

// 几何计算器
type GeometryCalculator struct {
    Shapes []Geometry
}

func (gc *GeometryCalculator) AddShape(shape Geometry) {
    gc.Shapes = append(gc.Shapes, shape)
}

func (gc *GeometryCalculator) CalculateTotalArea() float64 {
    total := 0.0
    for _, shape := range gc.Shapes {
        total += shape.Area()
    }
    return total
}

func (gc *GeometryCalculator) CalculateTotalPerimeter() float64 {
    total := 0.0
    for _, shape := range gc.Shapes {
        total += shape.Perimeter()
    }
    return total
}

func (gc *GeometryCalculator) PrintReport() {
    fmt.Println("=== 几何图形报告 ===")
    
    for i, shape := range gc.Shapes {
        fmt.Printf("%d. %s\n", i+1, shape.Name())
        fmt.Printf("   面积: %.2f\n", shape.Area())
        fmt.Printf("   周长: %.2f\n", shape.Perimeter())
        fmt.Println()
    }
    
    fmt.Printf("总面积: %.2f\n", gc.CalculateTotalArea())
    fmt.Printf("总周长: %.2f\n", gc.CalculateTotalPerimeter())
}

func main() {
    calculator := &GeometryCalculator{}
    
    // 添加各种图形
    calculator.AddShape(Rectangle{Width: 5, Height: 3, Center: Point{0, 0}})
    calculator.AddShape(Circle{Radius: 4, Center: Point{2, 2}})
    calculator.AddShape(Triangle{
        A: Point{0, 0},
        B: Point{4, 0},
        C: Point{0, 3},
    })
    
    // 生成报告
    calculator.PrintReport()
    
    // 单独计算
    fmt.Println("\n=== 单独计算 ===")
    rect := Rectangle{Width: 10, Height: 6, Center: Point{0, 0}}
    circle := Circle{Radius: 5, Center: Point{0, 0}}
    
    fmt.Printf("矩形面积: %.2f\n", rect.Area())
    fmt.Printf("圆周长: %.2f\n", circle.Perimeter())
}
```

## 5.5 最佳实践

### 结构体设计原则
1. **数据封装**：使用小写字段名实现封装
2. **最小接口**：只暴露必要的方法
3. **组合优于继承**：使用组合和嵌入代替传统继承
4. **不变性**：尽量设计不可变结构体

### 方法设计建议
1. **指针接收器**：当需要修改接收器时使用
2. **值接收器**：当不需要修改接收器时使用
3. **一致性**：同一类型的接收器类型保持一致
4. **接口分离**：接口应该小而专注

## 5.6 本章总结

本章我们深入学习了：
- 结构体的定义、初始化和使用
- 方法的定义和不同类型的接收器
- 接口的概念和实现
- 组合与嵌入的设计模式
- 面向对象编程在Go中的实践

通过银行账户系统和几何图形计算器的实践练习，我们掌握了结构体和方法的实际应用。下一章我们将深入学习接口和多态的高级特性。

---

**下一章预告**：第6章将详细介绍接口的深层概念、类型断言和Go语言的多态机制。