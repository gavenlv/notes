# 第7章：并发编程

## 7.1 Goroutine基础

### 7.1.1 Goroutine的概念与创建

Goroutine是Go语言并发编程的核心，是轻量级的线程，由Go运行时管理。

```go
package main

import (
    "fmt"
    "time"
)

// 简单的函数
func sayHello() {
    for i := 0; i < 5; i++ {
        fmt.Printf("Hello %d\n", i)
        time.Sleep(100 * time.Millisecond)
    }
}

func sayWorld() {
    for i := 0; i < 5; i++ {
        fmt.Printf("World %d\n", i)
        time.Sleep(150 * time.Millisecond)
    }
}

func main() {
    // 1. 顺序执行
    fmt.Println("=== 顺序执行 ===")
    sayHello()
    sayWorld()
    
    fmt.Println("\n=== 并发执行 ===")
    
    // 2. 使用go关键字创建goroutine
    go sayHello()
    go sayWorld()
    
    // 主goroutine等待一段时间
    time.Sleep(2 * time.Second)
    
    fmt.Println("主程序结束")
}
```

### 7.1.2 匿名函数的Goroutine

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // 1. 使用匿名函数创建goroutine
    go func() {
        for i := 0; i < 3; i++ {
            fmt.Printf("匿名函数: %d\n", i)
            time.Sleep(200 * time.Millisecond)
        }
    }()
    
    // 2. 带参数的匿名函数
    message := "Hello from goroutine"
    go func(msg string) {
        for i := 0; i < 3; i++ {
            fmt.Printf("%s: %d\n", msg, i)
            time.Sleep(100 * time.Millisecond)
        }
    }(message)
    
    // 3. 多个goroutine
    for i := 0; i < 3; i++ {
        go func(id int) {
            fmt.Printf("Goroutine %d 开始\n", id)
            time.Sleep(time.Duration(id) * 100 * time.Millisecond)
            fmt.Printf("Goroutine %d 结束\n", id)
        }(i)
    }
    
    time.Sleep(1 * time.Second)
    fmt.Println("主程序结束")
}
```

## 7.2 Channel通信

### 7.2.1 Channel的基本使用

Channel是goroutine之间的通信管道，用于安全地传递数据。

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // 1. 创建无缓冲channel
    ch := make(chan string)
    
    // 生产者goroutine
    go func() {
        fmt.Println("生产者开始发送数据")
        ch <- "Hello"
        ch <- "World"
        ch <- "!"
        close(ch) // 关闭channel
        fmt.Println("生产者完成")
    }()
    
    // 消费者goroutine
    go func() {
        for {
            msg, ok := <-ch
            if !ok {
                fmt.Println("Channel已关闭")
                break
            }
            fmt.Printf("接收到: %s\n", msg)
            time.Sleep(500 * time.Millisecond)
        }
    }()
    
    time.Sleep(3 * time.Second)
    fmt.Println("主程序结束")
}
```

### 7.2.2 有缓冲Channel

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // 创建有缓冲channel（容量为3）
    ch := make(chan int, 3)
    
    // 生产者
    go func() {
        for i := 0; i < 10; i++ {
            ch <- i
            fmt.Printf("生产: %d (channel长度: %d)\n", i, len(ch))
            time.Sleep(100 * time.Millisecond)
        }
        close(ch)
    }()
    
    // 消费者
    go func() {
        for i := range ch {
            fmt.Printf("消费: %d (channel长度: %d)\n", i, len(ch))
            time.Sleep(200 * time.Millisecond)
        }
    }()
    
    time.Sleep(3 * time.Second)
    fmt.Println("主程序结束")
}
```

### 7.2.3 Select多路复用

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    // 第一个goroutine
    go func() {
        for {
            time.Sleep(1 * time.Second)
            ch1 <- "来自channel1"
        }
    }()
    
    // 第二个goroutine
    go func() {
        for {
            time.Sleep(2 * time.Second)
            ch2 <- "来自channel2"
        }
    }()
    
    // 第三个goroutine - 定时器
    timeout := time.After(5 * time.Second)
    
    // 使用select监听多个channel
    for {
        select {
        case msg1 := <-ch1:
            fmt.Printf("收到消息1: %s\n", msg1)
        case msg2 := <-ch2:
            fmt.Printf("收到消息2: %s\n", msg2)
        case <-timeout:
            fmt.Println("超时，程序结束")
            return
        default:
            // 没有消息时执行
            fmt.Println("没有消息，等待中...")
            time.Sleep(500 * time.Millisecond)
        }
    }
}
```

## 7.3 同步机制

### 7.3.1 WaitGroup

WaitGroup用于等待一组goroutine完成。

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done() // 完成后通知WaitGroup
    
    fmt.Printf("Worker %d 开始工作\n", id)
    time.Sleep(time.Duration(id) * time.Second)
    fmt.Printf("Worker %d 完成工作\n", id)
}

func main() {
    var wg sync.WaitGroup
    
    // 启动5个worker
    for i := 1; i <= 5; i++ {
        wg.Add(1) // 增加计数
        go worker(i, &wg)
    }
    
    fmt.Println("等待所有worker完成...")
    wg.Wait() // 等待所有goroutine完成
    fmt.Println("所有worker已完成")
}
```

### 7.3.2 Mutex互斥锁

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// 共享资源
type Counter struct {
    value int
    mutex sync.Mutex
}

func (c *Counter) Increment() {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    c.value++
}

func (c *Counter) GetValue() int {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    return c.value
}

func main() {
    counter := Counter{}
    var wg sync.WaitGroup
    
    // 启动100个goroutine并发增加计数器
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < 1000; j++ {
                counter.Increment()
            }
        }()
    }
    
    wg.Wait()
    fmt.Printf("最终计数: %d\n", counter.GetValue())
}
```

### 7.3.3 RWMutex读写锁

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// 读写安全的数据结构
type SafeMap struct {
    data map[string]string
    rw   sync.RWMutex
}

func NewSafeMap() *SafeMap {
    return &SafeMap{
        data: make(map[string]string),
    }
}

func (sm *SafeMap) Set(key, value string) {
    sm.rw.Lock()
    defer sm.rw.Unlock()
    sm.data[key] = value
}

func (sm *SafeMap) Get(key string) (string, bool) {
    sm.rw.RLock()
    defer sm.rw.RUnlock()
    value, exists := sm.data[key]
    return value, exists
}

func (sm *SafeMap) GetAll() map[string]string {
    sm.rw.RLock()
    defer sm.rw.RUnlock()
    
    // 返回副本，避免外部修改
    result := make(map[string]string)
    for k, v := range sm.data {
        result[k] = v
    }
    return result
}

func main() {
    sm := NewSafeMap()
    var wg sync.WaitGroup
    
    // 写操作
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", id)
            value := fmt.Sprintf("value%d", id)
            sm.Set(key, value)
            fmt.Printf("写入: %s -> %s\n", key, value)
        }(i)
    }
    
    // 读操作（可以并发）
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", id%5)
            if value, exists := sm.Get(key); exists {
                fmt.Printf("读取: %s -> %s\n", key, value)
            }
        }(i)
    }
    
    wg.Wait()
    
    // 获取所有数据
    allData := sm.GetAll()
    fmt.Printf("\n所有数据: %v\n", allData)
}
```

## 7.4 并发模式

### 7.4.1 生产者-消费者模式

```go
package main

import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)

// 任务结构体
type Task struct {
    ID   int
    Data string
}

func main() {
    // 创建任务channel
    taskQueue := make(chan Task, 10)
    
    var wg sync.WaitGroup
    
    // 生产者
    producerCount := 3
    for i := 0; i < producerCount; i++ {
        wg.Add(1)
        go func(producerID int) {
            defer wg.Done()
            
            for j := 0; j < 5; j++ {
                task := Task{
                    ID:   j,
                    Data: fmt.Sprintf("任务 %d-%d", producerID, j),
                }
                
                taskQueue <- task
                fmt.Printf("生产者 %d 生产: %s\n", producerID, task.Data)
                
                // 模拟生产时间
                time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)
            }
        }(i)
    }
    
    // 消费者
    consumerCount := 2
    for i := 0; i < consumerCount; i++ {
        wg.Add(1)
        go func(consumerID int) {
            defer wg.Done()
            
            for task := range taskQueue {
                fmt.Printf("消费者 %d 处理: %s\n", consumerID, task.Data)
                
                // 模拟处理时间
                time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
                
                fmt.Printf("消费者 %d 完成: %s\n", consumerID, task.Data)
            }
        }(i)
    }
    
    // 等待所有生产者完成
    wg.Wait()
    close(taskQueue) // 关闭channel
    
    fmt.Println("所有任务处理完成")
}
```

### 7.4.2 Worker Pool模式

```go
package main

import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)

// 工作池
type WorkerPool struct {
    workerCount int
    taskQueue   chan func()
    wg          sync.WaitGroup
}

func NewWorkerPool(workerCount int) *WorkerPool {
    return &WorkerPool{
        workerCount: workerCount,
        taskQueue:   make(chan func(), 100),
    }
}

func (wp *WorkerPool) Start() {
    for i := 0; i < wp.workerCount; i++ {
        wp.wg.Add(1)
        go wp.worker(i)
    }
}

func (wp *WorkerPool) worker(id int) {
    defer wp.wg.Done()
    
    for task := range wp.taskQueue {
        fmt.Printf("Worker %d 开始执行任务\n", id)
        task()
        fmt.Printf("Worker %d 完成任务\n", id)
    }
}

func (wp *WorkerPool) Submit(task func()) {
    wp.taskQueue <- task
}

func (wp *WorkerPool) Stop() {
    close(wp.taskQueue)
    wp.wg.Wait()
}

func main() {
    // 创建工作池（3个worker）
    pool := NewWorkerPool(3)
    pool.Start()
    
    // 提交任务
    for i := 0; i < 10; i++ {
        taskID := i
        pool.Submit(func() {
            // 模拟任务执行
            duration := time.Duration(rand.Intn(3)+1) * time.Second
            time.Sleep(duration)
            fmt.Printf("任务 %d 完成，耗时 %.1f秒\n", taskID, duration.Seconds())
        })
    }
    
    // 等待所有任务完成
    time.Sleep(5 * time.Second)
    pool.Stop()
    fmt.Println("工作池已关闭")
}
```

### 7.4.3 扇出扇入模式

```go
package main

import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)

// 数据生成器（扇出）
func dataGenerator(count int) <-chan int {
    out := make(chan int)
    
    go func() {
        defer close(out)
        for i := 0; i < count; i++ {
            out <- i
        }
    }()
    
    return out
}

// 工作器（处理数据）
func worker(id int, in <-chan int) <-chan int {
    out := make(chan int)
    
    go func() {
        defer close(out)
        for num := range in {
            // 模拟处理时间
            time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)
            result := num * num
            fmt.Printf("Worker %d 处理: %d -> %d\n", id, num, result)
            out <- result
        }
    }()
    
    return out
}

// 合并器（扇入）
func merge(channels ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    out := make(chan int)
    
    // 从每个channel读取数据
    output := func(c <-chan int) {
        defer wg.Done()
        for n := range c {
            out <- n
        }
    }
    
    wg.Add(len(channels))
    for _, c := range channels {
        go output(c)
    }
    
    // 等待所有读取完成
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}

func main() {
    // 生成数据
    data := dataGenerator(20)
    
    // 创建多个worker并行处理
    workerCount := 4
    workers := make([]<-chan int, workerCount)
    
    for i := 0; i < workerCount; i++ {
        workers[i] = worker(i, data)
    }
    
    // 合并结果
    results := merge(workers...)
    
    // 收集结果
    sum := 0
    count := 0
    for result := range results {
        sum += result
        count++
        fmt.Printf("收到结果: %d\n", result)
    }
    
    fmt.Printf("\n处理完成: 共%d个结果，总和: %d\n", count, sum)
}
```

## 7.5 并发最佳实践

### 7.5.1 Context上下文

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func worker(ctx context.Context, id int) {
    for {
        select {
        case <-ctx.Done():
            fmt.Printf("Worker %d 收到取消信号: %v\n", id, ctx.Err())
            return
        default:
            fmt.Printf("Worker %d 工作中...\n", id)
            time.Sleep(500 * time.Millisecond)
        }
    }
}

func main() {
    // 创建带超时的context
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel() // 确保资源释放
    
    // 启动worker
    go worker(ctx, 1)
    go worker(ctx, 2)
    
    // 等待超时或手动取消
    <-ctx.Done()
    fmt.Println("主程序结束")
}
```

### 7.5.2 错误处理与恢复

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func safeWorker(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("Worker %d 发生panic: %v\n", id, r)
        }
    }()
    
    for i := 0; i < 5; i++ {
        // 模拟可能的panic
        if id == 2 && i == 3 {
            panic("模拟panic")
        }
        
        fmt.Printf("Worker %d: 任务 %d\n", id, i)
        time.Sleep(200 * time.Millisecond)
    }
    
    fmt.Printf("Worker %d 正常完成\n", id)
}

func main() {
    var wg sync.WaitGroup
    
    // 启动多个worker
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go safeWorker(i, &wg)
    }
    
    wg.Wait()
    fmt.Println("所有worker处理完成")
}
```

本章详细介绍了Go语言的并发编程，包括goroutine、channel、同步机制和各种并发模式。并发是Go语言的核心特性之一，正确使用并发可以大大提高程序性能。下一章我们将学习错误处理与测试。