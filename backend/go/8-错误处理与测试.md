# 第8章：错误处理与测试

## 8.1 错误处理基础

### 8.1.1 错误类型与处理

Go语言使用返回值来处理错误，而不是异常机制。

```go
package main

import (
    "errors"
    "fmt"
    "os"
    "strconv"
)

// 基础错误处理
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("除数不能为零")
    }
    return a / b, nil
}

// 使用fmt.Errorf创建格式化错误
func parseNumber(s string) (int, error) {
    num, err := strconv.Atoi(s)
    if err != nil {
        return 0, fmt.Errorf("解析数字失败: %v", err)
    }
    
    if num < 0 {
        return 0, errors.New("数字不能为负数")
    }
    
    return num, nil
}

func main() {
    // 1. 基础错误处理
    result, err := divide(10, 0)
    if err != nil {
        fmt.Printf("除法错误: %v\n", err)
    } else {
        fmt.Printf("结果: %.2f\n", result)
    }
    
    // 2. 成功的例子
    result, err = divide(10, 2)
    if err != nil {
        fmt.Printf("除法错误: %v\n", err)
    } else {
        fmt.Printf("结果: %.2f\n", result)
    }
    
    // 3. 解析数字
    num, err := parseNumber("123")
    if err != nil {
        fmt.Printf("解析错误: %v\n", err)
    } else {
        fmt.Printf("解析成功: %d\n", num)
    }
    
    // 4. 解析负数
    num, err = parseNumber("-5")
    if err != nil {
        fmt.Printf("解析错误: %v\n", err)
    } else {
        fmt.Printf("解析成功: %d\n", num)
    }
    
    // 5. 解析无效字符串
    num, err = parseNumber("abc")
    if err != nil {
        fmt.Printf("解析错误: %v\n", err)
    } else {
        fmt.Printf("解析成功: %d\n", num)
    }
}
```

### 8.1.2 自定义错误类型

```go
package main

import (
    "fmt"
    "time"
)

// 自定义错误类型
type ValidationError struct {
    Field   string
    Message string
    Time    time.Time
}

func (v ValidationError) Error() string {
    return fmt.Sprintf("[%s] 字段 '%s' 验证失败: %s", 
        v.Time.Format("2006-01-02 15:04:05"), v.Field, v.Message)
}

type DatabaseError struct {
    Operation string
    SQL       string
    Err       error
}

func (d DatabaseError) Error() string {
    return fmt.Sprintf("数据库操作 '%s' 失败 (SQL: %s): %v", 
        d.Operation, d.SQL, d.Err)
}

func (d DatabaseError) Unwrap() error {
    return d.Err
}

// 业务函数
func validateUser(username, email string) error {
    if username == "" {
        return ValidationError{
            Field:   "username",
            Message: "用户名不能为空",
            Time:    time.Now(),
        }
    }
    
    if len(username) < 3 {
        return ValidationError{
            Field:   "username",
            Message: "用户名至少3个字符",
            Time:    time.Now(),
        }
    }
    
    if email == "" {
        return ValidationError{
            Field:   "email",
            Message: "邮箱不能为空",
            Time:    time.Now(),
        }
    }
    
    return nil
}

func saveUser(username, email string) error {
    // 先验证
    if err := validateUser(username, email); err != nil {
        return err
    }
    
    // 模拟数据库操作
    // 这里假设发生了数据库错误
    return DatabaseError{
        Operation: "INSERT",
        SQL:       fmt.Sprintf("INSERT INTO users VALUES ('%s', '%s')", username, email),
        Err:       fmt.Errorf("连接超时"),
    }
}

func main() {
    // 测试验证错误
    err := validateUser("", "test@example.com")
    if err != nil {
        fmt.Printf("验证错误: %v\n", err)
        
        // 类型断言
        if ve, ok := err.(ValidationError); ok {
            fmt.Printf("  字段: %s, 时间: %v\n", ve.Field, ve.Time)
        }
    }
    
    fmt.Println()
    
    // 测试数据库错误
    err = saveUser("john", "john@example.com")
    if err != nil {
        fmt.Printf("保存错误: %v\n", err)
        
        // 检查错误链
        if de, ok := err.(DatabaseError); ok {
            fmt.Printf("  底层错误: %v\n", de.Unwrap())
        }
    }
}
```

## 8.2 错误处理模式

### 8.2.1 错误包装与链式错误

```go
package main

import (
    "errors"
    "fmt"
    "io"
    "os"
)

// 模拟文件操作错误
func readConfigFile(filename string) ([]byte, error) {
    file, err := os.Open(filename)
    if err != nil {
        return nil, fmt.Errorf("打开配置文件失败: %w", err)
    }
    defer file.Close()
    
    data, err := io.ReadAll(file)
    if err != nil {
        return nil, fmt.Errorf("读取配置文件失败: %w", err)
    }
    
    return data, nil
}

func parseConfig(data []byte) (map[string]string, error) {
    // 模拟解析错误
    if len(data) == 0 {
        return nil, errors.New("配置文件为空")
    }
    
    // 这里简化处理，实际应该解析JSON等格式
    config := map[string]string{
        "host": "localhost",
        "port": "8080",
    }
    
    return config, nil
}

func loadConfig(filename string) (map[string]string, error) {
    data, err := readConfigFile(filename)
    if err != nil {
        return nil, fmt.Errorf("加载配置失败: %w", err)
    }
    
    config, err := parseConfig(data)
    if err != nil {
        return nil, fmt.Errorf("解析配置失败: %w", err)
    }
    
    return config, nil
}

func main() {
    // 测试不存在的文件
    config, err := loadConfig("nonexistent.config")
    if err != nil {
        fmt.Printf("错误: %v\n", err)
        
        // 检查错误链
        fmt.Println("\n错误链分析:")
        for e := err; e != nil; e = errors.Unwrap(e) {
            fmt.Printf("  - %v\n", e)
        }
        
        // 使用errors.Is检查特定错误
        if errors.Is(err, os.ErrNotExist) {
            fmt.Println("\n文件不存在错误")
        }
    } else {
        fmt.Printf("配置加载成功: %v\n", config)
    }
    
    fmt.Println("\n" + "="*50 + "\n")
    
    // 测试空文件（需要先创建）
    emptyFile, _ := os.Create("empty.config")
    emptyFile.Close()
    
    config, err = loadConfig("empty.config")
    if err != nil {
        fmt.Printf("错误: %v\n", err)
        
        // 检查错误链
        fmt.Println("\n错误链分析:")
        for e := err; e != nil; e = errors.Unwrap(e) {
            fmt.Printf("  - %v\n", e)
        }
    }
    
    // 清理
    os.Remove("empty.config")
}
```

### 8.2.2 错误处理策略

```go
package main

import (
    "errors"
    "fmt"
    "log"
    "time"
)

// 重试策略
type RetryConfig struct {
    MaxAttempts int
    Delay       time.Duration
}

// 带重试的函数
func retryableOperation(operation func() error, config RetryConfig) error {
    var lastErr error
    
    for attempt := 1; attempt <= config.MaxAttempts; attempt++ {
        err := operation()
        if err == nil {
            return nil // 成功
        }
        
        lastErr = err
        log.Printf("尝试 %d/%d 失败: %v", attempt, config.MaxAttempts, err)
        
        if attempt < config.MaxAttempts {
            log.Printf("等待 %.1f秒后重试...", config.Delay.Seconds())
            time.Sleep(config.Delay)
        }
    }
    
    return fmt.Errorf("操作失败，最大重试次数 %d: %w", config.MaxAttempts, lastErr)
}

// 模拟不稳定的操作
func unstableOperation() error {
    // 模拟随机失败
    if time.Now().UnixNano()%3 == 0 {
        return errors.New("随机失败")
    }
    return nil
}

// 错误分类处理
func handleError(err error) {
    switch {
    case errors.Is(err, errors.New("随机失败")):
        fmt.Println("处理随机失败错误")
    case errors.Is(err, errors.New("连接超时")):
        fmt.Println("处理连接超时错误")
    default:
        fmt.Printf("处理未知错误: %v\n", err)
    }
}

func main() {
    // 配置重试策略
    config := RetryConfig{
        MaxAttempts: 3,
        Delay:       1 * time.Second,
    }
    
    // 执行带重试的操作
    err := retryableOperation(unstableOperation, config)
    if err != nil {
        fmt.Printf("最终失败: %v\n", err)
        handleError(err)
    } else {
        fmt.Println("操作成功!")
    }
    
    fmt.Println("\n" + "="*50 + "\n")
    
    // 错误分类示例
    testErrors := []error{
        errors.New("随机失败"),
        errors.New("连接超时"),
        errors.New("其他错误"),
    }
    
    for _, testErr := range testErrors {
        fmt.Printf("测试错误: %v -> ", testErr)
        handleError(testErr)
    }
}
```

## 8.3 单元测试

### 8.3.1 基础单元测试

创建测试文件 `math_test.go`：

```go
package main

import (
    "testing"
)

// 被测试的函数
func Add(a, b int) int {
    return a + b
}

func Multiply(a, b int) int {
    return a * b
}

// 测试函数
func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"正数相加", 2, 3, 5},
        {"负数相加", -2, -3, -5},
        {"正负相加", 5, -3, 2},
        {"零相加", 0, 0, 0},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if got := Add(tt.a, tt.b); got != tt.want {
                t.Errorf("Add(%d, %d) = %d; want %d", tt.a, tt.b, got, tt.want)
            }
        })
    }
}

func TestMultiply(t *testing.T) {
    tests := []struct {
        name string
        a, b int
        want int
    }{
        {"正数相乘", 2, 3, 6},
        {"负数相乘", -2, -3, 6},
        {"正负相乘", 5, -3, -15},
        {"零相乘", 5, 0, 0},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if got := Multiply(tt.a, tt.b); got != tt.want {
                t.Errorf("Multiply(%d, %d) = %d; want %d", tt.a, tt.b, got, tt.want)
            }
        })
    }
}

// 表格驱动测试
func TestAdd_TableDriven(t *testing.T) {
    testCases := []struct {
        a, b int
        want int
    }{
        {1, 1, 2},
        {2, 2, 4},
        {3, 3, 6},
        {10, 20, 30},
        {-1, 1, 0},
        {-5, -5, -10},
    }
    
    for _, tc := range testCases {
        testName := fmt.Sprintf("%d+%d", tc.a, tc.b)
        t.Run(testName, func(t *testing.T) {
            got := Add(tc.a, tc.b)
            if got != tc.want {
                t.Errorf("got %d, want %d", got, tc.want)
            }
        })
    }
}
```

### 8.3.2 错误测试

创建错误测试文件 `error_test.go`：

```go
package main

import (
    "errors"
    "testing"
)

// 被测试的函数
func Divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

func ParsePositiveNumber(s string) (int, error) {
    if s == "" {
        return 0, errors.New("empty string")
    }
    
    // 这里简化处理
    if s == "invalid" {
        return 0, errors.New("invalid format")
    }
    
    // 模拟解析
    return len(s), nil
}

func TestDivide(t *testing.T) {
    t.Run("正常除法", func(t *testing.T) {
        result, err := Divide(10, 2)
        if err != nil {
            t.Fatalf("unexpected error: %v", err)
        }
        if result != 5 {
            t.Errorf("expected 5, got %f", result)
        }
    })
    
    t.Run("除零错误", func(t *testing.T) {
        _, err := Divide(10, 0)
        if err == nil {
            t.Error("expected error, got nil")
        }
        
        expectedErr := "division by zero"
        if err.Error() != expectedErr {
            t.Errorf("expected error '%s', got '%s'", expectedErr, err.Error())
        }
    })
}

func TestParsePositiveNumber(t *testing.T) {
    tests := []struct {
        name    string
        input   string
        want    int
        wantErr bool
        errMsg  string
    }{
        {
            name:    "有效字符串",
            input:   "hello",
            want:    5,
            wantErr: false,
        },
        {
            name:    "空字符串",
            input:   "",
            want:    0,
            wantErr: true,
            errMsg:  "empty string",
        },
        {
            name:    "无效格式",
            input:   "invalid",
            want:    0,
            wantErr: true,
            errMsg:  "invalid format",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := ParsePositiveNumber(tt.input)
            
            if (err != nil) != tt.wantErr {
                t.Errorf("ParsePositiveNumber() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            
            if got != tt.want {
                t.Errorf("ParsePositiveNumber() = %v, want %v", got, tt.want)
            }
            
            if tt.wantErr && err.Error() != tt.errMsg {
                t.Errorf("ParsePositiveNumber() error = %v, want error message %v", err.Error(), tt.errMsg)
            }
        })
    }
}

// 使用errors.Is和errors.As进行测试
func TestErrorWrapping(t *testing.T) {
    baseErr := errors.New("base error")
    wrappedErr := fmt.Errorf("wrapped: %w", baseErr)
    
    if !errors.Is(wrappedErr, baseErr) {
        t.Error("errors.Is should return true for wrapped error")
    }
    
    var target error
    if !errors.As(wrappedErr, &target) {
        t.Error("errors.As should work for wrapped error")
    }
}
```

## 8.4 基准测试

### 8.4.1 性能基准测试

创建基准测试文件 `benchmark_test.go`：

```go
package main

import (
    "testing"
)

// 被测试的函数
func Fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    return Fibonacci(n-1) + Fibonacci(n-2)
}

// 优化的斐波那契函数
func FibonacciOptimized(n int) int {
    if n <= 1 {
        return n
    }
    
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}

// 基准测试
func BenchmarkFibonacci(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Fibonacci(20)
    }
}

func BenchmarkFibonacciOptimized(b *testing.B) {
    for i := 0; i < b.N; i++ {
        FibonacciOptimized(20)
    }
}

// 内存分配基准测试
func createSlice(n int) []int {
    return make([]int, n)
}

func BenchmarkCreateSlice(b *testing.B) {
    b.ReportAllocs() // 报告内存分配
    
    for i := 0; i < b.N; i++ {
        createSlice(1000)
    }
}

// 子基准测试
func BenchmarkFibonacciSeries(b *testing.B) {
    benchmarks := []struct {
        name string
        n    int
    }{
        {"Small", 10},
        {"Medium", 20},
        {"Large", 30},
    }
    
    for _, bm := range benchmarks {
        b.Run(bm.name, func(b *testing.B) {
            for i := 0; i < b.N; i++ {
                FibonacciOptimized(bm.n)
            }
        })
    }
}
```

### 8.4.2 示例测试

创建示例测试文件 `example_test.go`：

```go
package main

import (
    "fmt"
)

func ExampleAdd() {
    sum := Add(2, 3)
    fmt.Println(sum)
    // Output: 5
}

func ExampleMultiply() {
    product := Multiply(4, 5)
    fmt.Println(product)
    // Output: 20
}

func ExampleDivide() {
    result, err := Divide(10, 2)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println(result)
    // Output: 5
}

func ExampleDivide_error() {
    _, err := Divide(10, 0)
    if err != nil {
        fmt.Println("Error:", err)
    }
    // Output: Error: division by zero
}

func ExampleFibonacci() {
    fmt.Println("Fibonacci sequence:")
    for i := 0; i < 10; i++ {
        fmt.Printf("%d ", FibonacciOptimized(i))
    }
    fmt.Println()
    // Output:
    // Fibonacci sequence:
    // 0 1 1 2 3 5 8 13 21 34
}
```

## 8.5 测试最佳实践

### 8.5.1 测试辅助函数与清理

```go
package main

import (
    "os"
    "testing"
)

// 测试辅助函数
func createTestFile(t *testing.T, filename, content string) {
    t.Helper() // 标记为辅助函数
    
    err := os.WriteFile(filename, []byte(content), 0644)
    if err != nil {
        t.Fatalf("创建测试文件失败: %v", err)
    }
}

func cleanupTestFile(t *testing.T, filename string) {
    t.Helper()
    
    err := os.Remove(filename)
    if err != nil && !os.IsNotExist(err) {
        t.Errorf("清理测试文件失败: %v", err)
    }
}

// 带setup和teardown的测试
func TestFileOperations(t *testing.T) {
    // 测试前置条件
    testFile := "test.txt"
    testContent := "Hello, Test!"
    
    // 创建测试文件
    createTestFile(t, testFile, testContent)
    
    // 确保测试后清理
    defer cleanupTestFile(t, testFile)
    
    // 读取文件测试
    data, err := os.ReadFile(testFile)
    if err != nil {
        t.Fatalf("读取文件失败: %v", err)
    }
    
    if string(data) != testContent {
        t.Errorf("文件内容不匹配: got %s, want %s", string(data), testContent)
    }
    
    // 文件存在性测试
    if _, err := os.Stat(testFile); os.IsNotExist(err) {
        t.Error("测试文件应该存在")
    }
}

// 子测试中的setup/teardown
func TestWithSubtests(t *testing.T) {
    // 全局setup
    tempDir := t.TempDir() // 使用临时目录
    t.Logf("使用临时目录: %s", tempDir)
    
    t.Run("测试1", func(t *testing.T) {
        filename := tempDir + "/test1.txt"
        createTestFile(t, filename, "test1")
        
        // 测试逻辑
        // ...
    })
    
    t.Run("测试2", func(t *testing.T) {
        filename := tempDir + "/test2.txt"
        createTestFile(t, filename, "test2")
        
        // 测试逻辑
        // ...
    })
    
    // 临时目录会自动清理
}

// 并行测试
func TestParallel(t *testing.T) {
    t.Run("并行测试1", func(t *testing.T) {
        t.Parallel()
        // 并行测试逻辑
        result := Add(1, 2)
        if result != 3 {
            t.Error("并行测试1失败")
        }
    })
    
    t.Run("并行测试2", func(t *testing.T) {
        t.Parallel()
        // 并行测试逻辑
        result := Multiply(2, 3)
        if result != 6 {
            t.Error("并行测试2失败")
        }
    })
}
```

本章详细介绍了Go语言的错误处理机制和测试框架。错误处理是Go语言的重要特性，通过返回值而不是异常来处理错误。测试框架提供了完善的单元测试、基准测试和示例测试功能，帮助确保代码质量。下一章我们将学习包管理与模块。