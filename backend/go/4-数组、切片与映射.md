# 第4章：数组、切片与映射

## 4.1 数组（Array）

### 4.1.1 数组的基本概念

数组是固定长度的、相同类型元素的集合：

```go
package main

import "fmt"

func main() {
    // 1. 声明并初始化数组
    var arr1 [5]int = [5]int{1, 2, 3, 4, 5}
    
    // 2. 类型推断
    arr2 := [3]string{"Go", "Python", "Java"}
    
    // 3. 自动计算长度
    arr3 := [...]float64{3.14, 2.71, 1.41}
    
    // 4. 指定索引初始化
    arr4 := [5]int{0: 10, 2: 30, 4: 50}
    
    fmt.Printf("arr1: %v, 长度: %d\n", arr1, len(arr1))
    fmt.Printf("arr2: %v, 长度: %d\n", arr2, len(arr2))
    fmt.Printf("arr3: %v, 长度: %d\n", arr3, len(arr3))
    fmt.Printf("arr4: %v, 长度: %d\n", arr4, len(arr4))
    
    // 5. 数组遍历
    fmt.Println("\n=== 数组遍历 ===")
    for i := 0; i < len(arr1); i++ {
        fmt.Printf("arr1[%d] = %d\n", i, arr1[i])
    }
    
    // 6. range遍历
    fmt.Println("\n=== range遍历 ===")
    for index, value := range arr2 {
        fmt.Printf("arr2[%d] = %s\n", index, value)
    }
    
    // 7. 数组是值类型
    fmt.Println("\n=== 数组值类型演示 ===")
    arr5 := [3]int{1, 2, 3}
    arr6 := arr5 // 值拷贝
    arr6[0] = 100
    
    fmt.Printf("arr5: %v\n", arr5)
    fmt.Printf("arr6: %v\n", arr6)
}
```

### 4.1.2 多维数组

```go
package main

import "fmt"

func main() {
    // 1. 二维数组
    var matrix [3][3]int = [3][3]int{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
    }
    
    // 2. 自动推断
    matrix2 := [2][2]string{
        {"A", "B"},
        {"C", "D"},
    }
    
    fmt.Println("=== 二维数组 ===")
    for i := 0; i < len(matrix); i++ {
        for j := 0; j < len(matrix[i]); j++ {
            fmt.Printf("matrix[%d][%d] = %d\n", i, j, matrix[i][j])
        }
    }
    
    fmt.Println("\n=== range遍历二维数组 ===")
    for i, row := range matrix2 {
        for j, value := range row {
            fmt.Printf("matrix2[%d][%d] = %s\n", i, j, value)
        }
    }
    
    // 3. 三维数组
    cube := [2][2][2]int{
        {
            {1, 2},
            {3, 4},
        },
        {
            {5, 6},
            {7, 8},
        },
    }
    
    fmt.Println("\n=== 三维数组 ===")
    for i, plane := range cube {
        for j, row := range plane {
            for k, value := range row {
                fmt.Printf("cube[%d][%d][%d] = %d\n", i, j, k, value)
            }
        }
    }
}
```

## 4.2 切片（Slice）

### 4.2.1 切片的基本概念

切片是动态数组，长度可变：

```go
package main

import "fmt"

func main() {
    // 1. 从数组创建切片
    arr := [5]int{1, 2, 3, 4, 5}
    slice1 := arr[1:3] // [2, 3]
    
    // 2. 直接创建切片
    slice2 := []int{10, 20, 30, 40}
    
    // 3. 使用make创建切片
    slice3 := make([]int, 3)      // 长度3，容量3
    slice4 := make([]int, 3, 5)   // 长度3，容量5
    
    fmt.Printf("slice1: %v, 长度: %d, 容量: %d\n", slice1, len(slice1), cap(slice1))
    fmt.Printf("slice2: %v, 长度: %d, 容量: %d\n", slice2, len(slice2), cap(slice2))
    fmt.Printf("slice3: %v, 长度: %d, 容量: %d\n", slice3, len(slice3), cap(slice3))
    fmt.Printf("slice4: %v, 长度: %d, 容量: %d\n", slice4, len(slice4), cap(slice4))
    
    // 4. 切片是引用类型
    fmt.Println("\n=== 切片引用类型演示 ===")
    slice5 := []int{1, 2, 3}
    slice6 := slice5 // 引用同一个底层数组
    slice6[0] = 100
    
    fmt.Printf("slice5: %v\n", slice5)
    fmt.Printf("slice6: %v\n", slice6)
    
    // 5. 空切片和nil切片
    var slice7 []int        // nil切片
    slice8 := []int{}      // 空切片
    
    fmt.Printf("slice7: %v, 是否为nil: %t\n", slice7, slice7 == nil)
    fmt.Printf("slice8: %v, 是否为nil: %t\n", slice8, slice8 == nil)
}
```

### 4.2.2 切片操作

```go
package main

import "fmt"

func main() {
    // 1. 切片操作
    slice := []int{1, 2, 3, 4, 5}
    
    fmt.Println("=== 切片操作 ===")
    fmt.Printf("原始切片: %v\n", slice)
    fmt.Printf("slice[1:3]: %v\n", slice[1:3])     // [2, 3]
    fmt.Printf("slice[:3]: %v\n", slice[:3])      // [1, 2, 3]
    fmt.Printf("slice[2:]: %v\n", slice[2:])      // [3, 4, 5]
    fmt.Printf("slice[:]: %v\n", slice[:])        // [1, 2, 3, 4, 5]
    
    // 2. 追加元素
    fmt.Println("\n=== 追加元素 ===")
    slice = append(slice, 6)
    fmt.Printf("追加6: %v\n", slice)
    
    slice = append(slice, 7, 8, 9)
    fmt.Printf("追加7,8,9: %v\n", slice)
    
    // 3. 合并切片
    otherSlice := []int{10, 11, 12}
    slice = append(slice, otherSlice...)
    fmt.Printf("合并切片: %v\n", slice)
    
    // 4. 复制切片
    fmt.Println("\n=== 复制切片 ===")
    sliceCopy := make([]int, len(slice))
    copy(sliceCopy, slice)
    sliceCopy[0] = 999
    
    fmt.Printf("原始切片: %v\n", slice)
    fmt.Printf("复制切片: %v\n", sliceCopy)
    
    // 5. 删除元素
    fmt.Println("\n=== 删除元素 ===")
    // 删除索引2的元素
    index := 2
    slice = append(slice[:index], slice[index+1:]...)
    fmt.Printf("删除索引2: %v\n", slice)
    
    // 6. 插入元素
    fmt.Println("\n=== 插入元素 ===")
    // 在索引1处插入100
    insertIndex := 1
    slice = append(slice[:insertIndex], append([]int{100}, slice[insertIndex:]...)...)
    fmt.Printf("在索引1插入100: %v\n", slice)
    
    // 7. 切片容量增长
    fmt.Println("\n=== 切片容量增长 ===")
    var s []int
    for i := 0; i < 10; i++ {
        s = append(s, i)
        fmt.Printf("长度: %d, 容量: %d\n", len(s), cap(s))
    }
}
```

### 4.2.3 切片与数组的性能考虑

```go
package main

import (
    "fmt"
    "time"
)

func benchmarkArray(size int) time.Duration {
    start := time.Now()
    
    var arr [1000000]int
    for i := 0; i < size; i++ {
        arr[i] = i
    }
    
    return time.Since(start)
}

func benchmarkSlice(size int) time.Duration {
    start := time.Now()
    
    slice := make([]int, 0, size)
    for i := 0; i < size; i++ {
        slice = append(slice, i)
    }
    
    return time.Since(start)
}

func main() {
    sizes := []int{1000, 10000, 100000}
    
    fmt.Println("=== 性能比较 ===")
    for _, size := range sizes {
        arrayTime := benchmarkArray(size)
        sliceTime := benchmarkSlice(size)
        
        fmt.Printf("大小: %d\n", size)
        fmt.Printf("  数组耗时: %v\n", arrayTime)
        fmt.Printf("  切片耗时: %v\n", sliceTime)
        fmt.Printf("  性能差异: %.2f倍\n", float64(sliceTime)/float64(arrayTime))
        fmt.Println()
    }
    
    // 预分配容量的优势
    fmt.Println("=== 预分配容量性能 ===")
    
    start1 := time.Now()
    slice1 := make([]int, 0)
    for i := 0; i < 100000; i++ {
        slice1 = append(slice1, i)
    }
    time1 := time.Since(start1)
    
    start2 := time.Now()
    slice2 := make([]int, 0, 100000)
    for i := 0; i < 100000; i++ {
        slice2 = append(slice2, i)
    }
    time2 := time.Since(start2)
    
    fmt.Printf("未预分配: %v\n", time1)
    fmt.Printf("预分配容量: %v\n", time2)
    fmt.Printf("性能提升: %.2f倍\n", float64(time1)/float64(time2))
}
```

## 4.3 映射（Map）

### 4.3.1 映射的基本操作

```go
package main

import "fmt"

func main() {
    // 1. 声明并初始化映射
    var m1 map[string]int = map[string]int{
        "Alice": 25,
        "Bob":   30,
        "Carol": 28,
    }
    
    // 2. 类型推断
    m2 := map[int]string{
        1: "January",
        2: "February",
        3: "March",
    }
    
    // 3. 使用make创建映射
    m3 := make(map[string]float64)
    m3["pi"] = 3.14159
    m3["e"] = 2.71828
    
    fmt.Printf("m1: %v\n", m1)
    fmt.Printf("m2: %v\n", m2)
    fmt.Printf("m3: %v\n", m3)
    
    // 4. 访问和修改映射
    fmt.Println("\n=== 访问和修改 ===")
    fmt.Printf("Alice的年龄: %d\n", m1["Alice"])
    
    m1["David"] = 35 // 添加新元素
    m1["Alice"] = 26 // 修改现有元素
    
    fmt.Printf("修改后的m1: %v\n", m1)
    
    // 5. 删除元素
    delete(m1, "Bob")
    fmt.Printf("删除Bob后: %v\n", m1)
    
    // 6. 检查键是否存在
    fmt.Println("\n=== 检查键是否存在 ===")
    if age, exists := m1["Alice"]; exists {
        fmt.Printf("Alice存在，年龄: %d\n", age)
    } else {
        fmt.Println("Alice不存在")
    }
    
    if age, exists := m1["Eve"]; exists {
        fmt.Printf("Eve存在，年龄: %d\n", age)
    } else {
        fmt.Println("Eve不存在")
    }
    
    // 7. 遍历映射
    fmt.Println("\n=== 遍历映射 ===")
    for key, value := range m1 {
        fmt.Printf("%s: %d\n", key, value)
    }
    
    // 8. 只遍历键或值
    fmt.Println("\n=== 只遍历键 ===")
    for key := range m1 {
        fmt.Printf("键: %s\n", key)
    }
    
    fmt.Println("\n=== 只遍历值 ===")
    for _, value := range m1 {
        fmt.Printf("值: %d\n", value)
    }
}
```

### 4.3.2 映射的高级用法

```go
package main

import (
    "fmt"
    "sort"
)

func main() {
    // 1. 嵌套映射
    students := map[string]map[string]interface{}{
        "Alice": {
            "age":  25,
            "grade": "A",
            "courses": []string{"Math", "Physics"},
        },
        "Bob": {
            "age":  30,
            "grade": "B",
            "courses": []string{"Chemistry", "Biology"},
        },
    }
    
    fmt.Println("=== 嵌套映射 ===")
    for name, info := range students {
        fmt.Printf("%s: 年龄%d, 成绩%s, 课程%v\n", 
            name, info["age"], info["grade"], info["courses"])
    }
    
    // 2. 映射作为函数参数
    fmt.Println("\n=== 映射作为函数参数 ===")
    updateAge(students, "Alice", 26)
    fmt.Printf("更新后Alice的年龄: %d\n", students["Alice"]["age"])
    
    // 3. 映射的排序
    fmt.Println("\n=== 映射排序 ===")
    scores := map[string]int{
        "Alice": 85,
        "Bob":   92,
        "Carol": 78,
        "David": 95,
    }
    
    // 按键排序
    fmt.Println("按姓名排序:")
    var names []string
    for name := range scores {
        names = append(names, name)
    }
    sort.Strings(names)
    
    for _, name := range names {
        fmt.Printf("%s: %d\n", name, scores[name])
    }
    
    // 按值排序
    fmt.Println("\n按分数排序:")
    type ScorePair struct {
        Name  string
        Score int
    }
    
    var pairs []ScorePair
    for name, score := range scores {
        pairs = append(pairs, ScorePair{name, score})
    }
    
    sort.Slice(pairs, func(i, j int) bool {
        return pairs[i].Score > pairs[j].Score
    })
    
    for _, pair := range pairs {
        fmt.Printf("%s: %d\n", pair.Name, pair.Score)
    }
    
    // 4. 映射的零值处理
    fmt.Println("\n=== 零值处理 ===")
    wordCount := make(map[string]int)
    
    text := "hello world hello go world go programming"
    words := splitWords(text)
    
    for _, word := range words {
        wordCount[word]++ // 自动处理零值
    }
    
    fmt.Printf("词频统计: %v\n", wordCount)
}

func updateAge(students map[string]map[string]interface{}, name string, newAge int) {
    if student, exists := students[name]; exists {
        student["age"] = newAge
    }
}

func splitWords(text string) []string {
    // 简化版本，实际应该用strings.Fields
    return []string{"hello", "world", "hello", "go", "world", "go", "programming"}
}
```

## 4.4 实践练习

### 练习1：学生成绩管理系统

```go
package main

import (
    "fmt"
    "sort"
)

type Student struct {
    ID    int
    Name  string
    Score float64
}

type Class struct {
    Students map[int]*Student
}

func NewClass() *Class {
    return &Class{
        Students: make(map[int]*Student),
    }
}

func (c *Class) AddStudent(id int, name string, score float64) {
    c.Students[id] = &Student{
        ID:    id,
        Name:  name,
        Score: score,
    }
}

func (c *Class) GetStudent(id int) (*Student, bool) {
    student, exists := c.Students[id]
    return student, exists
}

func (c *Class) UpdateScore(id int, newScore float64) bool {
    student, exists := c.Students[id]
    if exists {
        student.Score = newScore
    }
    return exists
}

func (c *Class) RemoveStudent(id int) bool {
    _, exists := c.Students[id]
    if exists {
        delete(c.Students, id)
    }
    return exists
}

func (c *Class) GetTopStudents(n int) []*Student {
    var students []*Student
    for _, student := range c.Students {
        students = append(students, student)
    }
    
    sort.Slice(students, func(i, j int) bool {
        return students[i].Score > students[j].Score
    })
    
    if n > len(students) {
        n = len(students)
    }
    
    return students[:n]
}

func (c *Class) GetAverageScore() float64 {
    if len(c.Students) == 0 {
        return 0
    }
    
    total := 0.0
    for _, student := range c.Students {
        total += student.Score
    }
    
    return total / float64(len(c.Students))
}

func main() {
    class := NewClass()
    
    // 添加学生
    class.AddStudent(1, "张三", 85.5)
    class.AddStudent(2, "李四", 92.0)
    class.AddStudent(3, "王五", 78.5)
    class.AddStudent(4, "赵六", 95.0)
    
    // 查询学生
    if student, exists := class.GetStudent(2); exists {
        fmt.Printf("找到学生: %s, 分数: %.1f\n", student.Name, student.Score)
    }
    
    // 更新分数
    class.UpdateScore(3, 88.0)
    
    // 获取平均分
    average := class.GetAverageScore()
    fmt.Printf("班级平均分: %.2f\n", average)
    
    // 获取前三名
    topStudents := class.GetTopStudents(3)
    fmt.Println("\n前三名学生:")
    for i, student := range topStudents {
        fmt.Printf("第%d名: %s (%.1f分)\n", i+1, student.Name, student.Score)
    }
    
    // 删除学生
    class.RemoveStudent(4)
    fmt.Printf("\n删除赵六后学生数量: %d\n", len(class.Students))
}
```

### 练习2：统计单词频率

```go
package main

import (
    "fmt"
    "sort"
    "strings"
    "unicode"
)

func countWords(text string) map[string]int {
    words := strings.Fields(text)
    wordCount := make(map[string]int)
    
    for _, word := range words {
        // 清理单词（转为小写，去除标点）
        cleaned := strings.Map(func(r rune) rune {
            if unicode.IsPunct(r) {
                return -1
            }
            return unicode.ToLower(r)
        }, word)
        
        if cleaned != "" {
            wordCount[cleaned]++
        }
    }
    
    return wordCount
}

func printWordCount(wordCount map[string]int) {
    // 转换为切片用于排序
    type WordFreq struct {
        Word  string
        Count int
    }
    
    var frequencies []WordFreq
    for word, count := range wordCount {
        frequencies = append(frequencies, WordFreq{word, count})
    }
    
    // 按频率排序
    sort.Slice(frequencies, func(i, j int) bool {
        if frequencies[i].Count == frequencies[j].Count {
            return frequencies[i].Word < frequencies[j].Word
        }
        return frequencies[i].Count > frequencies[j].Count
    })
    
    fmt.Println("单词频率统计:")
    for i, freq := range frequencies {
        if i >= 10 { // 只显示前10个
            break
        }
        fmt.Printf("%2d. %-10s : %d\n", i+1, freq.Word, freq.Count)
    }
}

func main() {
    text := `Go is an open source programming language that makes it easy to build simple, 
reliable, and efficient software. Go is a statically typed, compiled programming 
language designed at Google. Go is similar to C, but with memory safety, 
garbage collection, and structural typing.`
    
    wordCount := countWords(text)
    printWordCount(wordCount)
    
    // 统计总单词数
    totalWords := 0
    for _, count := range wordCount {
        totalWords += count
    }
    
    fmt.Printf("\n总单词数: %d\n", totalWords)
    fmt.Printf("不同单词数: %d\n", len(wordCount))
}
```

## 4.5 最佳实践

### 数组使用建议
1. **固定大小**：当元素数量确定时使用
2. **性能优先**：数组比切片性能更好
3. **值语义**：数组是值类型，传递时会被复制

### 切片使用建议
1. **动态大小**：元素数量不确定时使用
2. **预分配容量**：使用make时指定容量避免多次扩容
3. **避免内存泄漏**：大切片不再使用时设置为nil

### 映射使用建议
1. **快速查找**：需要快速查找时使用
2. **检查存在性**：使用双返回值模式检查键是否存在
3. **并发安全**：映射不是并发安全的，需要加锁

## 4.6 本章总结

本章我们深入学习了：
- 数组的声明、初始化和遍历
- 切片的概念、操作和性能特点
- 映射的基本操作和高级用法
- 各种数据结构的实际应用场景

通过实践练习，我们掌握了学生成绩管理系统和单词频率统计等实用功能的实现。下一章我们将学习结构体和方法，这是Go语言面向对象编程的基础。

---

**下一章预告**：第5章将详细介绍结构体的定义、方法和面向对象编程的概念。