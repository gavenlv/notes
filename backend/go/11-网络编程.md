# 第11章：网络编程

## 11.1 HTTP客户端

### 11.1.1 基础HTTP请求

Go语言内置了强大的HTTP客户端功能，可以轻松发送HTTP请求。

```go
package main

import (
    "fmt"
    "io"
    "net/http"
    "net/url"
    "time"
)

func main() {
    // 1. 发送GET请求
    fmt.Println("=== GET请求示例 ===")
    
    resp, err := http.Get("https://httpbin.org/get")
    if err != nil {
        fmt.Printf("GET请求失败: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        fmt.Printf("读取响应失败: %v\n", err)
        return
    }
    
    fmt.Printf("状态码: %d\n", resp.StatusCode)
    fmt.Printf("响应头: %v\n", resp.Header)
    fmt.Printf("响应体: %s\n", string(body))
    
    // 2. 发送带参数的GET请求
    fmt.Println("\n=== 带参数的GET请求 ===")
    
    baseURL := "https://httpbin.org/get"
    params := url.Values{}
    params.Add("name", "张三")
    params.Add("age", "25")
    
    fullURL := baseURL + "?" + params.Encode()
    
    resp, err = http.Get(fullURL)
    if err != nil {
        fmt.Printf("带参数GET请求失败: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    body, _ = io.ReadAll(resp.Body)
    fmt.Printf("响应: %s\n", string(body))
    
    // 3. 发送POST请求
    fmt.Println("\n=== POST请求示例 ===")
    
    postData := url.Values{}
    postData.Add("username", "testuser")
    postData.Add("password", "testpass")
    
    resp, err = http.PostForm("https://httpbin.org/post", postData)
    if err != nil {
        fmt.Printf("POST请求失败: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    body, _ = io.ReadAll(resp.Body)
    fmt.Printf("POST响应: %s\n", string(body))
    
    // 4. 自定义HTTP客户端
    fmt.Println("\n=== 自定义HTTP客户端 ===")
    
    client := &http.Client{
        Timeout: 10 * time.Second,
        Transport: &http.Transport{
            MaxIdleConns:        10,
            IdleConnTimeout:    30 * time.Second,
            DisableCompression: true,
        },
    }
    
    req, err := http.NewRequest("GET", "https://httpbin.org/headers", nil)
    if err != nil {
        fmt.Printf("创建请求失败: %v\n", err)
        return
    }
    
    // 添加请求头
    req.Header.Add("User-Agent", "MyGoClient/1.0")
    req.Header.Add("Authorization", "Bearer token123")
    
    resp, err = client.Do(req)
    if err != nil {
        fmt.Printf("自定义客户端请求失败: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    body, _ = io.ReadAll(resp.Body)
    fmt.Printf("自定义请求响应: %s\n", string(body))
}
```

### 11.1.2 高级HTTP客户端功能

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "net/http/cookiejar"
    "time"
)

// 用户结构体
type User struct {
    ID       int    `json:"id"`
    Username string `json:"username"`
    Email    string `json:"email"`
}

func main() {
    // 1. 发送JSON数据
    fmt.Println("=== 发送JSON数据 ===")
    
    user := User{
        ID:       1,
        Username: "john_doe",
        Email:    "john@example.com",
    }
    
    jsonData, err := json.Marshal(user)
    if err != nil {
        fmt.Printf("JSON序列化失败: %v\n", err)
        return
    }
    
    req, err := http.NewRequest("POST", "https://httpbin.org/post", 
        bytes.NewBuffer(jsonData))
    if err != nil {
        fmt.Printf("创建请求失败: %v\n", err)
        return
    }
    
    req.Header.Set("Content-Type", "application/json")
    
    client := &http.Client{Timeout: 10 * time.Second}
    resp, err := client.Do(req)
    if err != nil {
        fmt.Printf("发送JSON请求失败: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    body, _ := io.ReadAll(resp.Body)
    fmt.Printf("JSON响应: %s\n", string(body))
    
    // 2. 使用CookieJar管理会话
    fmt.Println("\n=== 使用CookieJar ===")
    
    jar, err := cookiejar.New(nil)
    if err != nil {
        fmt.Printf("创建CookieJar失败: %v\n", err)
        return
    }
    
    cookieClient := &http.Client{
        Jar:     jar,
        Timeout: 10 * time.Second,
    }
    
    // 发送请求，Cookie会被自动管理
    resp, err = cookieClient.Get("https://httpbin.org/cookies/set?name=value")
    if err != nil {
        fmt.Printf("带Cookie请求失败: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    body, _ = io.ReadAll(resp.Body)
    fmt.Printf("Cookie响应: %s\n", string(body))
    
    // 3. 文件上传
    fmt.Println("\n=== 文件上传 ===")
    
    // 创建测试文件
    fileContent := "这是测试文件内容"
    
    var requestBody bytes.Buffer
    writer := multipart.NewWriter(&requestBody)
    
    // 添加文件字段
    fileWriter, err := writer.CreateFormFile("file", "test.txt")
    if err != nil {
        fmt.Printf("创建文件字段失败: %v\n", err)
        return
    }
    
    fileWriter.Write([]byte(fileContent))
    
    // 添加文本字段
    writer.WriteField("description", "测试文件")
    
    writer.Close()
    
    req, err = http.NewRequest("POST", "https://httpbin.org/post", &requestBody)
    if err != nil {
        fmt.Printf("创建上传请求失败: %v\n", err)
        return
    }
    
    req.Header.Set("Content-Type", writer.FormDataContentType())
    
    resp, err = client.Do(req)
    if err != nil {
        fmt.Printf("文件上传失败: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    body, _ = io.ReadAll(resp.Body)
    fmt.Printf("上传响应: %s\n", string(body))
    
    // 4. 重试机制
    fmt.Println("\n=== 重试机制 ===")
    
    retryClient := &http.Client{
        Timeout: 5 * time.Second,
    }
    
    maxRetries := 3
    for i := 0; i < maxRetries; i++ {
        resp, err = retryClient.Get("https://httpbin.org/delay/2") // 模拟延迟
        if err != nil {
            fmt.Printf("尝试 %d 失败: %v\n", i+1, err)
            if i == maxRetries-1 {
                fmt.Println("达到最大重试次数")
                break
            }
            time.Sleep(1 * time.Second)
            continue
        }
        
        fmt.Printf("第 %d 次尝试成功\n", i+1)
        resp.Body.Close()
        break
    }
}
```

## 11.2 HTTP服务器

### 11.2.1 基础HTTP服务器

```go
package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "strconv"
    "time"
)

// 用户结构体
type User struct {
    ID       int    `json:"id"`
    Name     string `json:"name"`
    Email    string `json:"email"`
    CreateAt string `json:"create_at"`
}

// 内存中的用户存储
var users = []User{
    {ID: 1, Name: "张三", Email: "zhangsan@example.com", CreateAt: time.Now().Format(time.RFC3339)},
    {ID: 2, Name: "李四", Email: "lisi@example.com", CreateAt: time.Now().Format(time.RFC3339)},
}

// 获取所有用户
func getUsers(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    
    if r.Method != "GET" {
        http.Error(w, "方法不允许", http.StatusMethodNotAllowed)
        return
    }
    
    json.NewEncoder(w).Encode(users)
}

// 根据ID获取用户
func getUserByID(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    
    if r.Method != "GET" {
        http.Error(w, "方法不允许", http.StatusMethodNotAllowed)
        return
    }
    
    // 从URL路径中提取ID
    idStr := r.URL.Path[len("/users/"):]
    id, err := strconv.Atoi(idStr)
    if err != nil {
        http.Error(w, "无效的用户ID", http.StatusBadRequest)
        return
    }
    
    for _, user := range users {
        if user.ID == id {
            json.NewEncoder(w).Encode(user)
            return
        }
    }
    
    http.Error(w, "用户不存在", http.StatusNotFound)
}

// 创建用户
func createUser(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    
    if r.Method != "POST" {
        http.Error(w, "方法不允许", http.StatusMethodNotAllowed)
        return
    }
    
    var newUser User
    err := json.NewDecoder(r.Body).Decode(&newUser)
    if err != nil {
        http.Error(w, "无效的JSON数据", http.StatusBadRequest)
        return
    }
    
    // 生成新ID
    newUser.ID = len(users) + 1
    newUser.CreateAt = time.Now().Format(time.RFC3339)
    
    users = append(users, newUser)
    
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(newUser)
}

// 健康检查端点
func healthCheck(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    
    response := map[string]interface{}{
        "status":    "healthy",
        "timestamp": time.Now().Unix(),
        "version":   "1.0.0",
    }
    
    json.NewEncoder(w).Encode(response)
}

// 中间件：日志记录
func loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // 调用下一个处理器
        next.ServeHTTP(w, r)
        
        // 记录日志
        log.Printf("%s %s %s %v", r.Method, r.URL.Path, r.RemoteAddr, time.Since(start))
    })
}

// 中间件：认证检查
func authMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 简单的API密钥认证
        apiKey := r.Header.Get("X-API-Key")
        if apiKey != "secret123" {
            http.Error(w, "未授权", http.StatusUnauthorized)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}

func main() {
    // 设置路由
    mux := http.NewServeMux()
    
    // 静态文件服务
    fs := http.FileServer(http.Dir("./static"))
    mux.Handle("/static/", http.StripPrefix("/static/", fs))
    
    // API路由
    mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "欢迎使用用户API服务")
    })
    
    mux.HandleFunc("/health", healthCheck)
    mux.HandleFunc("/users", getUsers)
    mux.HandleFunc("/users/", getUserByID)
    mux.HandleFunc("/users/create", createUser)
    
    // 应用中间件
    handler := loggingMiddleware(authMiddleware(mux))
    
    // 启动服务器
    server := &http.Server{
        Addr:         ":8080",
        Handler:      handler,
        ReadTimeout:  10 * time.Second,
        WriteTimeout: 10 * time.Second,
        IdleTimeout:  60 * time.Second,
    }
    
    fmt.Println("服务器启动在 http://localhost:8080")
    fmt.Println("可用端点:")
    fmt.Println("  GET  /health        - 健康检查")
    fmt.Println("  GET  /users         - 获取所有用户")
    fmt.Println("  GET  /users/{id}    - 根据ID获取用户")
    fmt.Println("  POST /users/create  - 创建用户（需要X-API-Key: secret123）")
    
    log.Fatal(server.ListenAndServe())
}
```

### 11.2.2 RESTful API服务器

```go
package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "strconv"
    "sync"
    "time"

    "github.com/gorilla/mux"
)

// 产品结构体
type Product struct {
    ID          int     `json:"id"`
    Name        string  `json:"name"`
    Description string  `json:"description"`
    Price       float64 `json:"price"`
    Stock       int     `json:"stock"`
    CreatedAt   string  `json:"created_at"`
}

// 产品存储（线程安全）
type ProductStore struct {
    sync.RWMutex
    products map[int]*Product
    nextID   int
}

func NewProductStore() *ProductStore {
    return &ProductStore{
        products: make(map[int]*Product),
        nextID:   1,
    }
}

func (ps *ProductStore) Create(product *Product) {
    ps.Lock()
    defer ps.Unlock()
    
    product.ID = ps.nextID
    product.CreatedAt = time.Now().Format(time.RFC3339)
    ps.products[product.ID] = product
    ps.nextID++
}

func (ps *ProductStore) Get(id int) (*Product, bool) {
    ps.RLock()
    defer ps.RUnlock()
    
    product, exists := ps.products[id]
    return product, exists
}

func (ps *ProductStore) GetAll() []*Product {
    ps.RLock()
    defer ps.RUnlock()
    
    products := make([]*Product, 0, len(ps.products))
    for _, product := range ps.products {
        products = append(products, product)
    }
    return products
}

func (ps *ProductStore) Update(id int, updatedProduct *Product) bool {
    ps.Lock()
    defer ps.Unlock()
    
    if _, exists := ps.products[id]; !exists {
        return false
    }
    
    updatedProduct.ID = id
    updatedProduct.CreatedAt = ps.products[id].CreatedAt
    ps.products[id] = updatedProduct
    return true
}

func (ps *ProductStore) Delete(id int) bool {
    ps.Lock()
    defer ps.Unlock()
    
    if _, exists := ps.products[id]; !exists {
        return false
    }
    
    delete(ps.products, id)
    return true
}

// API处理器
type APIHandler struct {
    store *ProductStore
}

func NewAPIHandler() *APIHandler {
    return &APIHandler{
        store: NewProductStore(),
    }
}

func (h *APIHandler) GetProducts(w http.ResponseWriter, r *http.Request) {
    products := h.store.GetAll()
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(products)
}

func (h *APIHandler) GetProduct(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id, err := strconv.Atoi(vars["id"])
    if err != nil {
        http.Error(w, "无效的产品ID", http.StatusBadRequest)
        return
    }
    
    product, exists := h.store.Get(id)
    if !exists {
        http.Error(w, "产品不存在", http.StatusNotFound)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(product)
}

func (h *APIHandler) CreateProduct(w http.ResponseWriter, r *http.Request) {
    var product Product
    
    if err := json.NewDecoder(r.Body).Decode(&product); err != nil {
        http.Error(w, "无效的JSON数据", http.StatusBadRequest)
        return
    }
    
    if product.Name == "" || product.Price <= 0 {
        http.Error(w, "名称和价格是必填项", http.StatusBadRequest)
        return
    }
    
    h.store.Create(&product)
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(product)
}

func (h *APIHandler) UpdateProduct(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id, err := strconv.Atoi(vars["id"])
    if err != nil {
        http.Error(w, "无效的产品ID", http.StatusBadRequest)
        return
    }
    
    var updatedProduct Product
    if err := json.NewDecoder(r.Body).Decode(&updatedProduct); err != nil {
        http.Error(w, "无效的JSON数据", http.StatusBadRequest)
        return
    }
    
    if !h.store.Update(id, &updatedProduct) {
        http.Error(w, "产品不存在", http.StatusNotFound)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(updatedProduct)
}

func (h *APIHandler) DeleteProduct(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id, err := strconv.Atoi(vars["id"])
    if err != nil {
        http.Error(w, "无效的产品ID", http.StatusBadRequest)
        return
    }
    
    if !h.store.Delete(id) {
        http.Error(w, "产品不存在", http.StatusNotFound)
        return
    }
    
    w.WriteHeader(http.StatusNoContent)
}

// 中间件：JSON内容类型检查
func JSONContentTypeMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        if r.Method == "POST" || r.Method == "PUT" {
            contentType := r.Header.Get("Content-Type")
            if contentType != "application/json" {
                http.Error(w, "Content-Type必须是application/json", http.StatusUnsupportedMediaType)
                return
            }
        }
        
        w.Header().Set("Content-Type", "application/json")
        next.ServeHTTP(w, r)
    })
}

func main() {
    // 初始化处理器
    handler := NewAPIHandler()
    
    // 创建路由器
    r := mux.NewRouter()
    
    // API路由
    api := r.PathPrefix("/api/v1").Subrouter()
    api.Use(JSONContentTypeMiddleware)
    
    api.HandleFunc("/products", handler.GetProducts).Methods("GET")
    api.HandleFunc("/products", handler.CreateProduct).Methods("POST")
    api.HandleFunc("/products/{id}", handler.GetProduct).Methods("GET")
    api.HandleFunc("/products/{id}", handler.UpdateProduct).Methods("PUT")
    api.HandleFunc("/products/{id}", handler.DeleteProduct).Methods("DELETE")
    
    // 健康检查
    r.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
        json.NewEncoder(w).Encode(map[string]string{"status": "healthy"})
    }).Methods("GET")
    
    // 文档页面
    r.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, `
        <html>
        <head><title>产品API</title></head>
        <body>
            <h1>产品RESTful API</h1>
            <ul>
                <li>GET /api/v1/products - 获取所有产品</li>
                <li>POST /api/v1/products - 创建新产品</li>
                <li>GET /api/v1/products/{id} - 获取特定产品</li>
                <li>PUT /api/v1/products/{id} - 更新产品</li>
                <li>DELETE /api/v1/products/{id} - 删除产品</li>
            </ul>
        </body>
        </html>
        `)
    })
    
    // 配置服务器
    server := &http.Server{
        Addr:         ":8080",
        Handler:      r,
        ReadTimeout:  15 * time.Second,
        WriteTimeout: 15 * time.Second,
        IdleTimeout:  60 * time.Second,
    }
    
    fmt.Println("RESTful API服务器启动在 http://localhost:8080")
    
    // 添加一些示例数据
    handler.store.Create(&Product{
        Name:        "笔记本电脑",
        Description: "高性能笔记本电脑",
        Price:       5999.99,
        Stock:       50,
    })
    
    handler.store.Create(&Product{
        Name:        "智能手机",
        Description: "最新款智能手机",
        Price:       3999.99,
        Stock:       100,
    })
    
    log.Fatal(server.ListenAndServe())
}
```

## 11.3 TCP/UDP编程

### 11.3.1 TCP服务器与客户端

```go
package main

import (
    "bufio"
    "fmt"
    "log"
    "net"
    "strings"
    "time"
)

// TCP服务器
func startTCPServer() {
    listener, err := net.Listen("tcp", ":8081")
    if err != nil {
        log.Fatal("启动TCP服务器失败:", err)
    }
    defer listener.Close()
    
    fmt.Println("TCP服务器启动在 :8081")
    
    for {
        conn, err := listener.Accept()
        if err != nil {
            log.Printf("接受连接失败: %v", err)
            continue
        }
        
        go handleTCPConnection(conn)
    }
}

func handleTCPConnection(conn net.Conn) {
    defer conn.Close()
    
    clientAddr := conn.RemoteAddr().String()
    fmt.Printf("新的TCP连接: %s\n", clientAddr)
    
    // 发送欢迎消息
    conn.Write([]byte("欢迎连接到TCP服务器!\n"))
    conn.Write([]byte("输入 'quit' 退出连接\n"))
    
    scanner := bufio.NewScanner(conn)
    for scanner.Scan() {
        message := strings.TrimSpace(scanner.Text())
        
        if message == "quit" {
            conn.Write([]byte("再见!\n"))
            break
        }
        
        if message == "time" {
            currentTime := time.Now().Format("2006-01-02 15:04:05")
            conn.Write([]byte("当前时间: " + currentTime + "\n"))
            continue
        }
        
        if message == "echo" {
            conn.Write([]byte("ECHO: 请输入要回显的文本\n"))
            if scanner.Scan() {
                echoText := scanner.Text()
                conn.Write([]byte("ECHO: " + echoText + "\n"))
            }
            continue
        }
        
        // 默认响应
        response := fmt.Sprintf("收到消息: %s (长度: %d)\n", message, len(message))
        conn.Write([]byte(response))
    }
    
    if err := scanner.Err(); err != nil {
        log.Printf("读取错误: %v", err)
    }
    
    fmt.Printf("TCP连接关闭: %s\n", clientAddr)
}

// TCP客户端
func startTCPClient() {
    conn, err := net.Dial("tcp", "localhost:8081")
    if err != nil {
        log.Fatal("连接TCP服务器失败:", err)
    }
    defer conn.Close()
    
    fmt.Println("已连接到TCP服务器")
    
    // 读取服务器欢迎消息
    scanner := bufio.NewScanner(conn)
    if scanner.Scan() {
        fmt.Println("服务器:", scanner.Text())
    }
    if scanner.Scan() {
        fmt.Println("服务器:", scanner.Text())
    }
    
    // 用户输入处理
    userScanner := bufio.NewScanner(os.Stdin)
    
    fmt.Print("请输入命令 (time/echo/quit): ")
    
    for userScanner.Scan() {
        command := strings.TrimSpace(userScanner.Text())
        
        // 发送命令到服务器
        fmt.Fprintln(conn, command)
        
        if command == "quit" {
            break
        }
        
        // 读取服务器响应
        for scanner.Scan() {
            response := scanner.Text()
            fmt.Println("服务器:", response)
            
            // 如果响应以"ECHO:"开头，需要用户输入更多内容
            if strings.HasPrefix(response, "ECHO:") && command == "echo" {
                fmt.Print("请输入要回显的文本: ")
                if userScanner.Scan() {
                    echoText := userScanner.Text()
                    fmt.Fprintln(conn, echoText)
                    continue
                }
            }
            
            break
        }
        
        fmt.Print("请输入命令 (time/echo/quit): ")
    }
    
    fmt.Println("客户端退出")
}

func main() {
    // 在goroutine中启动服务器
    go startTCPServer()
    
    // 等待服务器启动
    time.Sleep(1 * time.Second)
    
    // 启动客户端
    startTCPClient()
}
```

### 11.3.2 UDP服务器与客户端

```go
package main

import (
    "fmt"
    "log"
    "net"
    "time"
)

// UDP服务器
func startUDPServer() {
    addr, err := net.ResolveUDPAddr("udp", ":8082")
    if err != nil {
        log.Fatal("解析UDP地址失败:", err)
    }
    
    conn, err := net.ListenUDP("udp", addr)
    if err != nil {
        log.Fatal("启动UDP服务器失败:", err)
    }
    defer conn.Close()
    
    fmt.Println("UDP服务器启动在 :8082")
    
    buffer := make([]byte, 1024)
    
    for {
        n, clientAddr, err := conn.ReadFromUDP(buffer)
        if err != nil {
            log.Printf("读取UDP数据失败: %v", err)
            continue
        }
        
        message := string(buffer[:n])
        fmt.Printf("收到来自 %s 的消息: %s\n", clientAddr.String(), message)
        
        // 处理不同类型的消息
        response := processUDPMessage(message)
        
        // 发送响应
        _, err = conn.WriteToUDP([]byte(response), clientAddr)
        if err != nil {
            log.Printf("发送UDP响应失败: %v", err)
        }
    }
}

func processUDPMessage(message string) string {
    switch message {
    case "time":
        return time.Now().Format("2006-01-02 15:04:05")
    case "ping":
        return "pong"
    case "hello":
        return "你好! 我是UDP服务器"
    default:
        return fmt.Sprintf("回声: %s", message)
    }
}

// UDP客户端
func startUDPClient() {
    serverAddr, err := net.ResolveUDPAddr("udp", "localhost:8082")
    if err != nil {
        log.Fatal("解析服务器地址失败:", err)
    }
    
    conn, err := net.DialUDP("udp", nil, serverAddr)
    if err != nil {
        log.Fatal("连接UDP服务器失败:", err)
    }
    defer conn.Close()
    
    fmt.Println("UDP客户端已启动")
    
    // 测试消息
    testMessages := []string{
        "hello",
        "time",
        "ping",
        "这是一条测试消息",
    }
    
    for _, message := range testMessages {
        fmt.Printf("发送: %s\n", message)
        
        // 发送消息
        _, err = conn.Write([]byte(message))
        if err != nil {
            log.Printf("发送消息失败: %v", err)
            continue
        }
        
        // 设置读取超时
        conn.SetReadDeadline(time.Now().Add(3 * time.Second))
        
        // 读取响应
        buffer := make([]byte, 1024)
        n, err := conn.Read(buffer)
        if err != nil {
            if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
                fmt.Println("读取超时")
                continue
            }
            log.Printf("读取响应失败: %v", err)
            continue
        }
        
        response := string(buffer[:n])
        fmt.Printf("收到响应: %s\n\n", response)
        
        time.Sleep(1 * time.Second)
    }
    
    fmt.Println("UDP客户端测试完成")
}

func main() {
    // 在goroutine中启动服务器
    go startUDPServer()
    
    // 等待服务器启动
    time.Sleep(1 * time.Second)
    
    // 启动客户端
    startUDPClient()
}
```

## 11.4 WebSocket编程

### 11.4.1 WebSocket聊天室

```go
package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "sync"
    "time"

    "github.com/gorilla/websocket"
)

// 聊天消息
type ChatMessage struct {
    Username string `json:"username"`
    Message  string `json:"message"`
    Time     string `json:"time"`
    Type     string `json:"type"` // "message", "join", "leave"
}

// 客户端连接
type Client struct {
    conn     *websocket.Conn
    username string
    send     chan []byte
}

// 聊天室
type ChatRoom struct {
    clients    map[*Client]bool
    broadcast  chan []byte
    register   chan *Client
    unregister chan *Client
    mutex      sync.RWMutex
}

func NewChatRoom() *ChatRoom {
    return &ChatRoom{
        clients:    make(map[*Client]bool),
        broadcast:  make(chan []byte),
        register:   make(chan *Client),
        unregister: make(chan *Client),
    }
}

func (cr *ChatRoom) run() {
    for {
        select {
        case client := <-cr.register:
            cr.mutex.Lock()
            cr.clients[client] = true
            cr.mutex.Unlock()
            
            // 广播用户加入消息
            joinMessage := ChatMessage{
                Username: client.username,
                Message:  "加入了聊天室",
                Time:     time.Now().Format("15:04:05"),
                Type:     "join",
            }
            cr.broadcastMessage(joinMessage)
            
            // 发送欢迎消息
            welcomeMessage := ChatMessage{
                Username: "系统",
                Message:  "欢迎来到聊天室!",
                Time:     time.Now().Format("15:04:05"),
                Type:     "system",
            }
            client.send <- cr.marshalMessage(welcomeMessage)
            
            fmt.Printf("用户 %s 加入聊天室，当前在线: %d\n", 
                client.username, len(cr.clients))
            
        case client := <-cr.unregister:
            cr.mutex.Lock()
            if _, ok := cr.clients[client]; ok {
                delete(cr.clients, client)
                close(client.send)
            }
            cr.mutex.Unlock()
            
            // 广播用户离开消息
            leaveMessage := ChatMessage{
                Username: client.username,
                Message:  "离开了聊天室",
                Time:     time.Now().Format("15:04:05"),
                Type:     "leave",
            }
            cr.broadcastMessage(leaveMessage)
            
            fmt.Printf("用户 %s 离开聊天室，当前在线: %d\n", 
                client.username, len(cr.clients))
            
        case message := <-cr.broadcast:
            cr.mutex.RLock()
            for client := range cr.clients {
                select {
                case client.send <- message:
                default:
                    close(client.send)
                    delete(cr.clients, client)
                }
            }
            cr.mutex.RUnlock()
        }
    }
}

func (cr *ChatRoom) broadcastMessage(msg ChatMessage) {
    message := cr.marshalMessage(msg)
    cr.broadcast <- message
}

func (cr *ChatRoom) marshalMessage(msg ChatMessage) []byte {
    data, _ := json.Marshal(msg)
    return data
}

// WebSocket升级器
var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool {
        return true // 在生产环境中应该检查来源
    },
}

func (cr *ChatRoom) handleWebSocket(w http.ResponseWriter, r *http.Request) {
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        log.Printf("WebSocket升级失败: %v", err)
        return
    }
    
    // 读取用户名（简化处理）
    username := r.URL.Query().Get("username")
    if username == "" {
        username = "匿名用户"
    }
    
    client := &Client{
        conn:     conn,
        username: username,
        send:     make(chan []byte, 256),
    }
    
    // 注册客户端
    cr.register <- client
    
    // 启动goroutine处理消息
    go client.writePump(cr)
    go client.readPump(cr)
}

func (c *Client) readPump(cr *ChatRoom) {
    defer func() {
        cr.unregister <- c
        c.conn.Close()
    }()
    
    for {
        _, message, err := c.conn.ReadMessage()
        if err != nil {
            if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway) {
                log.Printf("WebSocket错误: %v", err)
            }
            break
        }
        
        // 处理聊天消息
        chatMessage := ChatMessage{
            Username: c.username,
            Message:  string(message),
            Time:     time.Now().Format("15:04:05"),
            Type:     "message",
        }
        
        cr.broadcastMessage(chatMessage)
    }
}

func (c *Client) writePump(cr *ChatRoom) {
    defer c.conn.Close()
    
    for {
        select {
        case message, ok := <-c.send:
            if !ok {
                // 通道关闭
                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                return
            }
            
            err := c.conn.WriteMessage(websocket.TextMessage, message)
            if err != nil {
                return
            }
        }
    }
}

func main() {
    chatRoom := NewChatRoom()
    go chatRoom.run()
    
    // 静态文件服务
    fs := http.FileServer(http.Dir("./static"))
    http.Handle("/", fs)
    
    // WebSocket端点
    http.HandleFunc("/ws", chatRoom.handleWebSocket)
    
    // 健康检查
    http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("OK"))
    })
    
    fmt.Println("聊天室服务器启动在 http://localhost:8080")
    fmt.Println("访问 http://localhost:8080 进入聊天室")
    
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

本章详细介绍了Go语言的网络编程功能，包括HTTP客户端/服务器、TCP/UDP编程和WebSocket编程。网络编程是Go语言的重要应用领域，其并发特性使其在网络服务开发中具有显著优势。下一章我们将学习数据库操作。