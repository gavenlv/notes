# 第12章：数据库操作

## 12.1 数据库基础

### 12.1.1 数据库连接与驱动

Go语言通过database/sql包提供数据库操作接口，需要安装相应的数据库驱动。

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    _ "github.com/go-sql-driver/mysql" // MySQL驱动
)

func main() {
    // 数据库连接配置
    dsn := "root:password@tcp(localhost:3306)/testdb?charset=utf8mb4&parseTime=True"
    
    // 打开数据库连接
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        log.Fatal("数据库连接失败:", err)
    }
    defer db.Close()
    
    // 验证连接
    err = db.Ping()
    if err != nil {
        log.Fatal("数据库连接验证失败:", err)
    }
    
    fmt.Println("数据库连接成功!")
}
```

### 12.1.2 连接池配置

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    "time"
    _ "github.com/go-sql-driver/mysql"
)

func main() {
    dsn := "root:password@tcp(localhost:3306)/testdb?charset=utf8mb4&parseTime=True"
    
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // 配置连接池
    db.SetMaxOpenConns(25)     // 最大连接数
    db.SetMaxIdleConns(10)     // 最大空闲连接数
    db.SetConnMaxLifetime(5 * time.Minute) // 连接最大生存时间
    
    err = db.Ping()
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Println("数据库连接池配置完成!")
}
```

## 12.2 基础CRUD操作

### 12.2.1 创建表

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    _ "github.com/go-sql-driver/mysql"
)

func main() {
    dsn := "root:password@tcp(localhost:3306)/testdb?charset=utf8mb4&parseTime=True"
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // 创建用户表
    createTableSQL := `
        CREATE TABLE IF NOT EXISTS users (
            id INT AUTO_INCREMENT PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            email VARCHAR(100) UNIQUE NOT NULL,
            age INT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    `
    
    _, err = db.Exec(createTableSQL)
    if err != nil {
        log.Fatal("创建表失败:", err)
    }
    
    fmt.Println("用户表创建成功!")
}
```

### 12.2.2 插入数据

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    _ "github.com/go-sql-driver/mysql"
)

func main() {
    dsn := "root:password@tcp(localhost:3306)/testdb?charset=utf8mb4&parseTime=True"
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // 插入单条数据
    result, err := db.Exec(
        "INSERT INTO users (name, email, age) VALUES (?, ?, ?)",
        "张三", "zhangsan@example.com", 25,
    )
    if err != nil {
        log.Fatal("插入数据失败:", err)
    }
    
    id, _ := result.LastInsertId()
    fmt.Printf("插入成功，ID: %d\n", id)
    
    // 批量插入
    users := []struct {
        name  string
        email string
        age   int
    }{
        {"李四", "lisi@example.com", 30},
        {"王五", "wangwu@example.com", 28},
        {"赵六", "zhaoliu@example.com", 35},
    }
    
    for _, user := range users {
        _, err = db.Exec(
            "INSERT INTO users (name, email, age) VALUES (?, ?, ?)",
            user.name, user.email, user.age,
        )
        if err != nil {
            log.Printf("插入用户 %s 失败: %v\n", user.name, err)
        }
    }
    
    fmt.Println("批量插入完成!")
}
```

### 12.2.3 查询数据

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    _ "github.com/go-sql-driver/mysql"
)

type User struct {
    ID        int
    Name      string
    Email     string
    Age       sql.NullInt64
    CreatedAt string
}

func main() {
    dsn := "root:password@tcp(localhost:3306)/testdb?charset=utf8mb4&parseTime=True"
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // 查询单条记录
    var user User
    err = db.QueryRow("SELECT id, name, email, age, created_at FROM users WHERE id = ?", 1).Scan(
        &user.ID, &user.Name, &user.Email, &user.Age, &user.CreatedAt,
    )
    if err != nil {
        if err == sql.ErrNoRows {
            fmt.Println("未找到记录")
        } else {
            log.Fatal("查询失败:", err)
        }
    } else {
        fmt.Printf("用户信息: ID=%d, Name=%s, Email=%s, Age=%v\n", 
            user.ID, user.Name, user.Email, user.Age)
    }
    
    // 查询多条记录
    rows, err := db.Query("SELECT id, name, email, age FROM users WHERE age > ?", 25)
    if err != nil {
        log.Fatal("查询失败:", err)
    }
    defer rows.Close()
    
    var users []User
    for rows.Next() {
        var u User
        err = rows.Scan(&u.ID, &u.Name, &u.Email, &u.Age)
        if err != nil {
            log.Fatal("扫描记录失败:", err)
        }
        users = append(users, u)
    }
    
    if err = rows.Err(); err != nil {
        log.Fatal("遍历记录失败:", err)
    }
    
    fmt.Println("年龄大于25的用户:")
    for _, u := range users {
        fmt.Printf("  ID=%d, Name=%s, Email=%s, Age=%v\n", 
            u.ID, u.Name, u.Email, u.Age)
    }
}
```

### 12.2.4 更新和删除数据

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    _ "github.com/go-sql-driver/mysql"
)

func main() {
    dsn := "root:password@tcp(localhost:3306)/testdb?charset=utf8mb4&parseTime=True"
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // 更新数据
    result, err := db.Exec(
        "UPDATE users SET age = ? WHERE name = ?",
        26, "张三",
    )
    if err != nil {
        log.Fatal("更新失败:", err)
    }
    
    affected, _ := result.RowsAffected()
    fmt.Printf("更新了 %d 条记录\n", affected)
    
    // 删除数据
    result, err = db.Exec("DELETE FROM users WHERE age < ?", 25)
    if err != nil {
        log.Fatal("删除失败:", err)
    }
    
    affected, _ = result.RowsAffected()
    fmt.Printf("删除了 %d 条记录\n", affected)
}
```

## 12.3 事务处理

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    _ "github.com/go-sql-driver/mysql"
)

func main() {
    dsn := "root:password@tcp(localhost:3306)/testdb?charset=utf8mb4&parseTime=True"
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // 开始事务
    tx, err := db.Begin()
    if err != nil {
        log.Fatal("开始事务失败:", err)
    }
    
    // 执行多个操作
    _, err = tx.Exec("INSERT INTO users (name, email, age) VALUES (?, ?, ?)", 
        "钱七", "qianqi@example.com", 40)
    if err != nil {
        tx.Rollback()
        log.Fatal("插入失败，事务回滚:", err)
    }
    
    _, err = tx.Exec("UPDATE users SET age = ? WHERE name = ?", 31, "李四")
    if err != nil {
        tx.Rollback()
        log.Fatal("更新失败，事务回滚:", err)
    }
    
    // 提交事务
    err = tx.Commit()
    if err != nil {
        log.Fatal("提交事务失败:", err)
    }
    
    fmt.Println("事务执行成功!")
}
```

## 12.4 数据库连接管理

### 12.4.1 连接池最佳实践

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    "sync"
    "time"
    _ "github.com/go-sql-driver/mysql"
)

type Database struct {
    db *sql.DB
}

func NewDatabase(dsn string) (*Database, error) {
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        return nil, err
    }
    
    // 连接池配置
    db.SetMaxOpenConns(20)
    db.SetMaxIdleConns(10)
    db.SetConnMaxLifetime(time.Hour)
    
    err = db.Ping()
    if err != nil {
        return nil, err
    }
    
    return &Database{db: db}, nil
}

func (d *Database) Close() {
    d.db.Close()
}

func (d *Database) GetUserByID(id int) (*User, error) {
    var user User
    err := d.db.QueryRow(
        "SELECT id, name, email, age FROM users WHERE id = ?",
        id,
    ).Scan(&user.ID, &user.Name, &user.Email, &user.Age)
    
    if err != nil {
        return nil, err
    }
    
    return &user, nil
}

func main() {
    dsn := "root:password@tcp(localhost:3306)/testdb?charset=utf8mb4&parseTime=True"
    db, err := NewDatabase(dsn)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // 并发测试
    var wg sync.WaitGroup
    for i := 1; i <= 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            user, err := db.GetUserByID(id)
            if err != nil {
                fmt.Printf("查询用户 %d 失败: %v\n", id, err)
            } else {
                fmt.Printf("用户 %d: %s\n", user.ID, user.Name)
            }
        }(i)
    }
    
    wg.Wait()
    fmt.Println("并发查询完成!")
}
```

### 12.4.2 连接重试机制

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    "time"
    _ "github.com/go-sql-driver/mysql"
)

func connectWithRetry(dsn string, maxRetries int) (*sql.DB, error) {
    var db *sql.DB
    var err error
    
    for i := 0; i < maxRetries; i++ {
        db, err = sql.Open("mysql", dsn)
        if err != nil {
            log.Printf("连接尝试 %d 失败: %v\n", i+1, err)
            time.Sleep(time.Second * time.Duration(i+1))
            continue
        }
        
        err = db.Ping()
        if err != nil {
            log.Printf("Ping尝试 %d 失败: %v\n", i+1, err)
            db.Close()
            time.Sleep(time.Second * time.Duration(i+1))
            continue
        }
        
        return db, nil
    }
    
    return nil, fmt.Errorf("连接失败，重试 %d 次后放弃", maxRetries)
}

func main() {
    dsn := "root:password@tcp(localhost:3306)/testdb?charset=utf8mb4&parseTime=True"
    
    db, err := connectWithRetry(dsn, 3)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    fmt.Println("数据库连接成功!")
}
```

## 12.5 数据库迁移

```go
package main

import (
    "database/sql"
    "fmt"
    "log"
    _ "github.com/go-sql-driver/mysql"
)

type Migration struct {
    Version int
    Name    string
    SQL     string
}

var migrations = []Migration{
    {
        Version: 1,
        Name:    "创建用户表",
        SQL: `CREATE TABLE IF NOT EXISTS users (
            id INT AUTO_INCREMENT PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            email VARCHAR(100) UNIQUE NOT NULL,
            age INT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`,
    },
    {
        Version: 2,
        Name:    "创建文章表",
        SQL: `CREATE TABLE IF NOT EXISTS articles (
            id INT AUTO_INCREMENT PRIMARY KEY,
            title VARCHAR(200) NOT NULL,
            content TEXT,
            user_id INT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users(id)
        )`,
    },
    {
        Version: 3,
        Name:    "添加用户状态字段",
        SQL: "ALTER TABLE users ADD COLUMN status VARCHAR(20) DEFAULT 'active'",
    },
}

func main() {
    dsn := "root:password@tcp(localhost:3306)/testdb?charset=utf8mb4&parseTime=True"
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // 创建迁移记录表
    _, err = db.Exec(`
        CREATE TABLE IF NOT EXISTS migrations (
            version INT PRIMARY KEY,
            name VARCHAR(200) NOT NULL,
            applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    `)
    if err != nil {
        log.Fatal("创建迁移记录表失败:", err)
    }
    
    // 执行迁移
    for _, migration := range migrations {
        // 检查是否已执行
        var count int
        err := db.QueryRow(
            "SELECT COUNT(*) FROM migrations WHERE version = ?",
            migration.Version,
        ).Scan(&count)
        
        if err != nil && err != sql.ErrNoRows {
            log.Fatal("查询迁移记录失败:", err)
        }
        
        if count == 0 {
            // 执行迁移
            _, err = db.Exec(migration.SQL)
            if err != nil {
                log.Fatalf("执行迁移 %d (%s) 失败: %v", 
                    migration.Version, migration.Name, err)
            }
            
            // 记录迁移
            _, err = db.Exec(
                "INSERT INTO migrations (version, name) VALUES (?, ?)",
                migration.Version, migration.Name,
            )
            if err != nil {
                log.Fatalf("记录迁移 %d 失败: %v", migration.Version, err)
            }
            
            fmt.Printf("执行迁移 %d: %s\n", migration.Version, migration.Name)
        }
    }
    
    fmt.Println("数据库迁移完成!")
}
```

## 12.6 最佳实践总结

1. **连接管理**：使用连接池，合理配置连接参数
2. **错误处理**：正确处理数据库操作错误，特别是连接错误
3. **事务使用**：对于需要原子性的操作使用事务
4. **SQL注入防护**：使用参数化查询，避免拼接SQL
5. **资源释放**：及时关闭数据库连接和查询结果集
6. **迁移管理**：使用版本控制的数据库迁移方案