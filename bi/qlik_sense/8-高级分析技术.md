# 第8章：高级分析技术

> **学习时长**: 12-15小时  
> **难度**: ⭐⭐⭐⭐⭐  
> **前置知识**: 第1-7章

## 本章目标

学完本章后,你将能够:

- ✅ 深入掌握AGGR函数的高级应用
- ✅ 熟练使用变量和书签进行高级分析
- ✅ 实现替代维度和度量功能
- ✅ 处理复杂的嵌套聚合场景
- ✅ 创建高级图表交互效果
- ✅ 优化复杂分析性能
- ✅ 解决实际业务分析难题

---

## 8.1 AGGR函数深度解析

### 8.1.1 AGGR基础概念

**什么是AGGR**?

AGGR函数是Qlik Sense中最强大的函数之一，用于创建虚拟表格进行分层聚合计算。

```qlik
// AGGR语法结构
AGGR(表达式, 维度1, 维度2, ...)

// 基础示例
AGGR(Sum(销售额), 客户ID)  // 每个客户的销售额
```

**AGGR vs 普通聚合**:

```qlik
// 普通聚合 - 单一层级
Sum(销售额)  // 总销售额

// AGGR - 多层级聚合
AGGR(Sum(销售额), 客户ID)  // 每个客户的销售额
Sum(AGGR(Sum(销售额), 客户ID))  // 等同于Sum(销售额)
```

### 8.1.2 AGGR高级应用

```qlik
// 1. 计算占比
Sum(销售额) / Sum(TOTAL AGGR(Sum(销售额), 客户ID))  // 客户销售额占比

// 2. 排名计算
Rank(AGGR(Sum(销售额), 客户ID))  // 客户销售排名

// 3. 分位数计算
Fractile(AGGR(Sum(销售额), 客户ID), 0.9)  // 客户销售额90%分位数

// 4. 条件聚合
Sum({<客户ID = {"=AGGR(Sum(销售额), 客户ID) > 10000"}>} 销售额)
// 销售额大于1万的客户总销售额
```

### 8.1.3 多维度AGGR

```qlik
// 多维度聚合
AGGR(Sum(销售额), 客户ID, 产品类别)
// 每个客户每类产品的销售额

// 嵌套AGGR
AGGR(
    Sum(AGGR(Sum(数量), 产品ID)), 
    客户ID
)
// 每个客户的总订单数量

// 复杂示例: 客户价值分析
AGGR(
    Sum(销售额) * Count(DISTINCT 订单ID),  // 客户价值公式
    客户ID
)
// 每个客户的价值得分
```

---

## 8.2 变量与书签高级应用

### 8.2.1 高级变量技术

```qlik
// 1. 动态变量
LET vCurrentSelection = GetPossibleCount(客户ID);
LET vFilteredSales = Sum({$} 销售额);

// 2. 条件变量
LET vSalesThreshold = If(Sum(销售额) > 1000000, '高', '低');

// 3. 表达式变量
SET vTopCustomerExpr = 
    "=FirstSortedValue(客户名称, -Aggr(Sum(销售额), 客户名称))";

// 4. 循环变量
FOR i = 1 TO 12
    LET vMonth$(i)Sales = Sum({<月份={'$(i)'}>} 销售额);
NEXT i
```

### 8.2.2 书签高级功能

```qlik
// 1. 动态书签创建
// 在脚本中创建书签
BookmarkCreate('年度分析', '年度销售数据视图');

// 2. 书签状态管理
// 保存当前状态
BookmarkSave('当前分析状态');

// 3. 条件书签应用
IF Sum(销售额) > 1000000 THEN
    BookmarkApply('高销售额视图');
ELSE
    BookmarkApply('标准视图');
END IF
```

### 8.2.3 变量驱动分析

```qlik
// 创建分析控制面板
AnalysisControl:
LOAD * INLINE [
    控制项, 值
    分析维度, 客户
    时间范围, 年度
    度量类型, 销售额
];

// 使用变量驱动分析
SET vAnalysisDimension = $(=Peek('值', 0, 'AnalysisControl'));
SET vTimeRange = $(=Peek('值', 1, 'AnalysisControl'));
SET vMetricType = $(=Peek('值', 2, 'AnalysisControl'));

// 动态图表表达式
Sum({<时间范围={'$(vTimeRange)'}>} $(vMetricType))
```

---

## 8.3 替代维度与度量

### 8.3.1 替代维度

```qlik
// 创建维度映射表
DimensionMapping:
LOAD * INLINE [
    主维度, 替代维度
    客户名称, 客户城市
    客户名称, 客户类型
    产品名称, 产品类别
    产品名称, 产品品牌
];

// 动态维度选择
SET vCurrentDimension = 客户名称;

// 替代维度表达式
$(vCurrentDimension)  // 动态维度

// 维度切换逻辑
IF vCurrentDimension = '客户名称' THEN
    SET vDisplayDimension = 客户城市;
ELSEIF vCurrentDimension = '产品名称' THEN
    SET vDisplayDimension = 产品类别;
END IF
```

### 8.3.2 替代度量

```qlik
// 度量映射表
MetricMapping:
LOAD * INLINE [
    度量名称, 度量表达式
    销售额, Sum(销售额)
    订单数, Count(DISTINCT 订单ID)
    平均订单金额, Sum(销售额)/Count(DISTINCT 订单ID)
    客户数, Count(DISTINCT 客户ID)
];

// 动态度量选择
SET vCurrentMetric = 销售额;
SET vMetricExpression = $(=Peek('度量表达式', 0, 'MetricMapping'));

// 应用动态度量
$(vMetricExpression)
```

### 8.3.3 交互式分析

```qlik
// 创建控制表
AnalysisControls:
LOAD * INLINE [
    控制类型, 选项1, 选项2, 选项3
    维度, 客户名称, 产品名称, 地区
    度量, Sum(销售额), Count(订单ID), Avg(单价)
    时间, 年度, 季度, 月份
];

// 交互式表达式构建
动态分析表达式:
LOAD
    '$(vSelectedDimension)' as 维度,
    '$(vSelectedMetric)' as 度量,
    AGGR($(vSelectedMetric), $(vSelectedDimension)) as 计算结果
RESIDENT 原始数据
GROUP BY $(vSelectedDimension);
```

---

## 8.4 嵌套聚合技术

### 8.4.1 基础嵌套聚合

```qlik
// 一层嵌套
Sum(AGGR(Sum(销售额), 客户ID))

// 二层嵌套
Sum(AGGR(
    Sum(AGGR(Sum(数量), 产品ID)), 
    客户ID
))

// 三层嵌套
Sum(AGGR(
    Sum(AGGR(
        Sum(AGGR(Sum(金额), 订单ID)), 
        产品ID
    )), 
    客户ID
))
```

### 8.4.2 复杂嵌套场景

```qlik
// 客户-产品-订单三层分析
客户产品订单分析:
LOAD
    客户ID,
    产品ID,
    Count(DISTINCT 订单ID) as 订单数,
    Sum(数量) as 总数量,
    Sum(金额) as 总金额
RESIDENT 原始订单数据
GROUP BY 客户ID, 产品ID;

// 基于上述结果的进一步分析
客户层面分析:
LOAD
    客户ID,
    Count(DISTINCT 产品ID) as 购买产品数,
    Sum(订单数) as 总订单数,
    Sum(总金额) as 客户总金额,
    Avg(总金额) as 平均产品金额
RESIDENT 客户产品订单分析
GROUP BY 客户ID;
```

### 8.4.3 性能优化的嵌套聚合

```qlik
// ❌ 低效嵌套
Sum(AGGR(
    Sum(AGGR(Sum(销售额), 产品ID)), 
    客户ID
))

// ✅ 优化嵌套
TempAggregation:
LOAD
    客户ID,
    产品ID,
    Sum(销售额) as 产品销售额
RESIDENT 原始数据
GROUP BY 客户ID, 产品ID;

FinalAggregation:
LOAD
    客户ID,
    Sum(产品销售额) as 客户销售额
RESIDENT TempAggregation
GROUP BY 客户ID;

DROP Table TempAggregation;
```

---

## 8.5 高级图表交互

### 8.5.1 动态钻取

```qlik
// 钻取层次定义
DrillHierarchy:
LOAD * INLINE [
    层级, 维度, 标签
    1, 国家, 国家分布
    2, 省份, 省份分布  
    3, 城市, 城市分布
    4, 区县, 区县分布
];

// 动态钻取表达式
SET vCurrentLevel = 1;
SET vCurrentDimension = $(=Peek('维度', $(vCurrentLevel)-1, 'DrillHierarchy'));

// 钻取按钮逻辑
SUB DrillDown
    LET vCurrentLevel = $(vCurrentLevel) + 1;
    IF vCurrentLevel <= 4 THEN
        SET vCurrentDimension = $(=Peek('维度', $(vCurrentLevel)-1, 'DrillHierarchy'));
    END IF
END SUB

SUB DrillUp
    LET vCurrentLevel = $(vCurrentLevel) - 1;
    IF vCurrentLevel >= 1 THEN
        SET vCurrentDimension = $(=Peek('维度', $(vCurrentLevel)-1, 'DrillHierarchy'));
    END IF
END SUB
```

### 8.5.2 交互式筛选

```qlik
// 创建动态筛选器
DynamicFilters:
LOAD
    '销售额范围' as 筛选类型,
    Dual('0-1000', 1) as 筛选值
AUTOGENERATE 1;

CONCATENATE (DynamicFilters)
LOAD
    '销售额范围' as 筛选类型,
    Dual('1000-5000', 2) as 筛选值
AUTOGENERATE 1;

// 应用动态筛选
SET vSalesRange = 2;  // 选择1000-5000范围

Sum({<销售额={">=$(=If(vSalesRange=1,0,1000))<=$(=If(vSalesRange=1,1000,5000))"}>} 销售额)
```

### 8.5.3 条件可视化

```qlik
// 条件显示对象
IF Sum(销售额) > 1000000 THEN
    // 显示详细分析图表
    显示对象('详细分析');
ELSE
    // 显示汇总信息
    显示对象('汇总信息');
END IF

// 动态颜色编码
Color(
    IF(Sum(增长率) > 0.1, RGB(0,255,0),      // 绿色 >10%
       IF(Sum(增长率) > 0, RGB(255,255,0),   // 黄色 0-10%
          RGB(255,0,0)))                     // 红色 <0%
)
```

---

## 8.6 实际业务场景解决

### 8.6.1 客户生命周期分析

```qlik
///$tab 客户生命周期分析

// 1. 客户首次购买时间
首次购买:
LOAD
    客户ID,
    Min(订单日期) as 首次购买日期
RESIDENT 订单数据
GROUP BY 客户ID;

// 2. 客户最后购买时间
最后购买:
LOAD
    客户ID,
    Max(订单日期) as 最后购买日期
RESIDENT 订单数据
GROUP BY 客户ID;

// 3. 客户生命周期计算
客户生命周期:
LOAD
    f.客户ID,
    f.首次购买日期,
    l.最后购买日期,
    l.最后购买日期 - f.首次购买日期 as 生命周期天数,
    // 客户价值计算
    AGGR(Sum(订单金额), 客户ID) as 客户总价值,
    Count(DISTINCT 订单ID) as 购买次数,
    AGGR(Sum(订单金额), 客户ID) / Count(DISTINCT 订单ID) as 平均订单价值,
    // 客户状态判断
    IF(l.最后购买日期 < Today() - 180, '流失客户',
       IF(l.最后购买日期 < Today() - 90, '睡眠客户', '活跃客户')) as 客户状态
RESIDENT 首次购买 f
JOIN (最后购买 l)
ON f.客户ID = l.客户ID;
```

### 8.6.2 库存周转分析

```qlik
///$tab 库存周转分析

// 1. 库存周转率计算
库存周转分析:
LOAD
    产品ID,
    产品名称,
    // 平均库存
    (期初库存 + 期末库存) / 2 as 平均库存,
    // 销售成本
    Sum(销售数量 * 成本价) as 销售成本,
    // 库存周转率
    Sum(销售数量 * 成本价) / ((期初库存 + 期末库存) / 2) as 库存周转率,
    // 周转天数
    365 / (Sum(销售数量 * 成本价) / ((期初库存 + 期末库存) / 2)) as 周转天数,
    // 库存状态
    IF(
        365 / (Sum(销售数量 * 成本价) / ((期初库存 + 期末库存) / 2)) < 30, '快速周转',
        IF(
            365 / (Sum(销售数量 * 成本价) / ((期初库存 + 期末库存) / 2)) < 90, '正常周转',
            '慢速周转'
        )
    ) as 周转状态
RESIDENT 库存销售数据
GROUP BY 产品ID, 产品名称, 期初库存, 期末库存;
```

---

## 8.7 性能优化技巧

### 8.7.1 AGGR性能优化

```qlik
// ❌ 低效AGGR
Sum(AGGR(
    Sum(AGGR(Sum(销售额), 产品ID)), 
    客户ID
))

// ✅ 优化AGGR
// 预聚合减少计算层级
预聚合:
LOAD
    客户ID,
    产品ID,
    Sum(销售额) as 产品销售额
RESIDENT 原始数据
GROUP BY 客户ID, 产品ID;

客户聚合:
LOAD
    客户ID,
    Sum(产品销售额) as 客户总销售额
RESIDENT 预聚合
GROUP BY 客户ID;

DROP Table 预聚合;
```

### 8.7.2 内存优化

```qlik
// 1. 及时释放临时表
TempAnalysis:
LOAD * FROM 大数据表;

// 处理...
Result:
LOAD ... RESIDENT TempAnalysis;

// 立即释放
DROP Table TempAnalysis;

// 2. 使用字段别名减少内存
优化表:
LOAD
    订单ID as ID,        // 短别名
    客户ID as CustID,
    产品ID as ProdID,
    Num(金额) as Amt     // 数据类型优化
FROM 订单表;
```

### 8.7.3 表达式优化

```qlik
// ❌ 重复计算
If(Sum(销售额) > 1000000, Sum(销售额) * 0.1, Sum(销售额) * 0.05)

// ✅ 变量缓存
LET vTotalSales = Sum(销售额);
If($(vTotalSales) > 1000000, $(vTotalSales) * 0.1, $(vTotalSales) * 0.05)

// ❌ 复杂条件
If(
    Sum({<年份={2024}>} 销售额) > Sum({<年份={2023}>} 销售额) AND
    Sum({<月份={'12'}>} 销售额) > Avg({<月份={'12'}>} 销售额),
    '优秀', '一般'
)

// ✅ 预计算
LET v2024Sales = Sum({<年份={2024}>} 销售额);
LET v2023Sales = Sum({<年份={2023}>} 销售额);
LET vDecSales = Sum({<月份={'12'}>} 销售额);
LET vDecAvg = Avg({<月份={'12'}>} 销售额);

If($(v2024Sales) > $(v2023Sales) AND $(vDecSales) > $(vDecAvg), '优秀', '一般')
```

---

## 8.8 实验:综合高级分析

### 实验1: 智能分析仪表板

```qlik
///$tab 智能分析系统

// 1. 动态分析控制器
AnalysisController:
LOAD * INLINE [
    参数, 值, 说明
    分析维度, 客户名称, 当前分析维度
    时间粒度, 月, 当前时间粒度
    度量类型, 销售额, 当前度量类型
    排序方式, 降序, 当前排序方式
];

// 2. 动态表达式构建器
SET vDimension = $(=Peek('值', 0, 'AnalysisController'));
SET vTimeGrain = $(=Peek('值', 1, 'AnalysisController'));
SET vMetric = $(=Peek('值', 2, 'AnalysisController'));
SET vSortOrder = $(=Peek('值', 3, 'AnalysisController'));

// 3. 智能分析结果
智能分析:
LOAD
    $(vDimension) as 分析维度,
    $(vTimeGrain) as 时间维度,
    $(vMetric) as 度量值,
    // 排名计算
    Rank($(vMetric)) as 排名,
    // 占比计算
    $(vMetric) / Sum(TOTAL $(vMetric)) as 占比,
    // 同比计算
    (
        $(vMetric) / 
        Alt(Above($(vMetric)), $(vMetric))
    ) - 1 as 环比增长,
    // 状态标识
    IF(
        Rank($(vMetric)) <= 10, 'Top10',
        IF(
            $(vMetric) > Avg(TOTAL $(vMetric)), '高于平均',
            '低于平均'
        )
    ) as 状态标识
RESIDENT 原始数据
GROUP BY $(vDimension), $(vTimeGrain)
ORDER BY $(vMetric) $(vSortOrder);
```

### 实验2: 预测分析系统

```qlik
///$tab 预测分析

// 1. 历史数据准备
历史销售:
LOAD
    日期,
    Year(日期) as 年,
    Month(日期) as 月,
    Sum(销售额) as 月销售额
RESIDENT 销售数据
GROUP BY 日期;

// 2. 趋势分析
趋势分析:
LOAD
    *,
    // 移动平均
    RangeAvg(Above(月销售额, 0, 3)) as 三月移动平均,
    RangeAvg(Above(月销售额, 0, 6)) as 六月移动平均,
    // 趋势线
    Linest_M(月销售额, RecNo()) as 趋势斜率,
    Linest_B(月销售额, RecNo()) as 趋势截距,
    // 预测值
    Linest_M(月销售额, RecNo()) * (RecNo() + 1) + Linest_B(月销售额, RecNo()) as 下月预测
RESIDENT 历史销售
ORDER BY 日期;

// 3. 预测准确性评估
预测评估:
LOAD
    *,
    // 绝对误差
    Abs(月销售额 - 下月预测(前移)) as 绝对误差,
    // 相对误差
    Abs(月销售额 - 下月预测(前移)) / 月销售额 as 相对误差,
    // 准确率
    1 - (Abs(月销售额 - 下月预测(前移)) / 月销售额) as 预测准确率
RESIDENT 趋势分析;
```

---

## 8.9 课后练习

### 练习1: AGGR函数应用

**任务**: 使用AGGR函数解决以下问题
- 计算每个客户的购买频次排名
- 找出销售额最高的产品类别
- 分析客户价值分布情况

### 练习2: 动态分析系统

**任务**: 创建一个动态分析系统
- 支持维度、度量、时间粒度切换
- 实现交互式钻取功能
- 添加条件可视化效果

### 练习3: 业务场景分析

**任务**: 解决实际业务分析问题
- 客户流失预警系统
- 库存优化分析
- 销售预测模型

---

## 8.10 本章小结

### 核心知识点

✅ **AGGR函数**: 多层级聚合计算  
✅ **变量应用**: 动态分析和控制  
✅ **替代分析**: 维度和度量切换  
✅ **嵌套聚合**: 复杂业务场景处理  
✅ **交互设计**: 动态钻取和筛选  
✅ **性能优化**: 表达式和内存优化  

### 关键技术

```qlik
// AGGR高级应用
AGGR(Sum(销售额), 客户ID, 产品类别)
Sum(AGGR(Sum(销售额), 客户ID))

// 动态表达式
$(vDimension)  // 动态维度
$(vMetric)     // 动态度量

// 条件分析
IF Rank($(vMetric)) <= 10, 'Top10', 'Other')

// 性能优化
LET vCachedValue = 复杂表达式;
$(vCachedValue)
```

### 最佳实践

1. **合理使用AGGR**: 避免过度嵌套
2. **缓存复杂计算**: 使用变量减少重复计算
3. **优化数据结构**: 预聚合减少运行时计算
4. **交互设计**: 提供灵活的分析界面
5. **性能监控**: 定期检查表达式性能

### 下一章预告

**第9章 - 性能优化与架构**,将学习:
- ⚡ Qlik Sense性能监控
- 📊 数据模型优化技术
- 🚀 脚本性能优化
- 🔧 前端渲染优化
- 🏢 企业级架构设计

---

[← 上一章](./7-表达式与集合分析.md) | [返回目录](./README.md) | [下一章: 性能优化与架构 →](./9-性能优化与架构.md)
