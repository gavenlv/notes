# 第3章：数据模型设计

> **学习时长**: 10-12小时  
> **难度**: ⭐⭐⭐  
> **前置知识**: 第1-2章

## 本章目标

学完本章后,你将能够:

- ✅ 深刻理解Qlik关联数据模型原理
- ✅ 设计标准的星型和雪花模型
- ✅ 掌握数据关联的最佳实践
- ✅ 处理复合键和合成键
- ✅ 解决循环引用问题
- ✅ 优化数据模型性能
- ✅ 使用数据模型查看器分析模型

---

## 3.1 数据模型基础

### 3.1.1 什么是数据模型?

**数据模型**是表与表之间关系的结构化表示:

```
传统BI (预定义查询):
查询1: SELECT sales, products WHERE...
查询2: SELECT sales, customers WHERE...
每个查询独立定义关系

Qlik (关联模型):
一次性建立所有关系
用户自由探索
关联引擎自动计算
```

**Qlik数据模型的独特之处**:

1. **自动关联**: 同名字段自动关联
2. **双向探索**: 从任意维度开始分析
3. **实时计算**: 无需预聚合
4. **内存优化**: 压缩存储,快速访问

### 3.1.2 Qlik关联原理

**关联的三种状态**:

```qlik
示例数据:

订单表:
订单ID | 客户ID | 产品ID | 金额
001    | C001   | P001   | 100
002    | C002   | P002   | 200

客户表:
客户ID | 客户名 | 城市
C001   | 张三   | 北京
C002   | 李四   | 上海
C003   | 王五   | 广州

产品表:
产品ID | 产品名 | 类别
P001   | 电脑   | 电子
P002   | 手机   | 电子
```

**关联结果**:
- 客户ID在两表中同名 → 自动关联
- 产品ID在两表中同名 → 自动关联
- C003没有订单 → 可见但无关联数据

**关联状态示例**:

```
选择"北京"城市:
- 客户"张三" (绿色 - 关联)
- 订单001 (绿色 - 关联)
- 产品"电脑" (绿色 - 关联)
- 客户"李四" (灰色 - 排除)
- 客户"王五" (灰色 - 排除)
```

---

## 3.2 星型模型

### 3.2.1 星型模型概念

**星型模型**是最常用的数据仓库设计模式:

```
星型模型结构:

        [日期维度]
             |
             |
    [客户维度] --- [事实表:销售] --- [产品维度]
             |
             |
        [地区维度]

特点:
✅ 中心事实表 (度量数据)
✅ 周围维度表 (描述性数据)
✅ 一对多关系
✅ 查询性能优秀
```

**事实表 vs 维度表**:

| 类型 | 特征 | 示例 |
|------|------|------|
| **事实表** | 数值度量、大量行、外键 | 销售额、数量、订单ID |
| **维度表** | 描述性、相对少行、主键 | 客户名、产品名、日期 |

### 3.2.2 构建星型模型

**示例:销售分析星型模型**

**步骤1: 识别事实和维度**

```
业务需求: 分析各产品在不同地区、不同时间的销售情况

事实: 销售金额、数量
维度: 产品、客户、地区、日期
```

**步骤2: 创建维度表**

```qlik
///$tab 产品维度
产品维度表:
LOAD
    产品ID as ProductID,
    产品名称 as ProductName,
    产品类别 as Category,
    产品子类别 as SubCategory,
    单价 as UnitPrice
FROM [lib://Data/products.xlsx]
(ooxml, embedded labels);

///$tab 客户维度
客户维度表:
LOAD
    客户ID as CustomerID,
    客户名称 as CustomerName,
    客户类型 as CustomerType,
    城市 as City,
    省份 as Province,
    国家 as Country
FROM [lib://Data/customers.csv]
(txt, utf8, embedded labels);

///$tab 日期维度
日期维度表:
LOAD
    日期 as Date,
    年 as Year,
    季度 as Quarter,
    月 as Month,
    周 as Week,
    星期几 as Weekday,
    是否工作日 as IsWorkday
FROM [lib://Data/calendar.qvd] (qvd);

///$tab 地区维度
地区维度表:
LOAD
    地区ID as RegionID,
    地区名称 as RegionName,
    区域 as Area,
    销售代表 as SalesRep
FROM [lib://Data/regions.csv]
(txt, utf8, embedded labels);
```

**步骤3: 创建事实表**

```qlik
///$tab 销售事实表
销售事实表:
LOAD
    订单ID as OrderID,
    Date(订单日期) as Date,          // 关联日期维度
    客户ID as CustomerID,             // 关联客户维度
    产品ID as ProductID,              // 关联产品维度
    地区ID as RegionID,               // 关联地区维度
    数量 as Quantity,
    销售额 as SalesAmount,
    成本 as Cost,
    销售额 - 成本 as Profit
FROM [lib://Data/sales_fact.csv]
(txt, utf8, embedded labels);
```

**步骤4: 验证模型**

```qlik
// 检查关联
TRACE ===== 数据模型验证 =====;
TRACE 产品维度行数: $(NoOfRows('产品维度表'));
TRACE 客户维度行数: $(NoOfRows('客户维度表'));
TRACE 销售事实表行数: $(NoOfRows('销售事实表'));

// 检查孤立值
Left Join (销售事实表)
LOAD DISTINCT
    ProductID
RESIDENT 产品维度表;

// 标记未关联的产品
销售事实表:
LOAD
    *,
    If(IsNull(ProductID), 1, 0) as 未关联产品标记
RESIDENT 销售事实表;
```

### 3.2.3 星型模型最佳实践

**✅ 推荐做法**:

```qlik
// 1. 一致的命名
// 使用英文别名,避免中文字段名冲突
产品维度表:
LOAD
    产品ID as ProductID,      // 统一使用ID后缀
    产品名称 as ProductName    // 统一使用Name后缀
FROM products.csv;

// 2. 主键唯一性
// 确保维度表主键唯一
产品维度表:
LOAD DISTINCT
    ProductID,
    ProductName
FROM products.csv;

// 检查重复
TempProducts:
LOAD
    ProductID,
    Count(*) as DuplicateCount
RESIDENT 产品维度表
GROUP BY ProductID
HAVING Count(*) > 1;

IF NoOfRows('TempProducts') > 0 THEN
    TRACE 警告: 产品ID存在重复!;
END IF

DROP Table TempProducts;

// 3. 外键完整性
// 确保事实表外键在维度表存在
销售事实表:
LOAD * FROM sales.csv;

// 检查孤立订单
孤立订单:
LOAD
    OrderID,
    ProductID
RESIDENT 销售事实表
WHERE NOT Exists(ProductID, ProductID);
```

**❌ 避免的做法**:

```qlik
// ❌ 不要: 在事实表保留过多描述性字段
销售事实表:
LOAD
    OrderID,
    产品名称,      // ❌ 应该在维度表
    产品类别,      // ❌ 应该在维度表
    客户名称,      // ❌ 应该在维度表
    SalesAmount
FROM sales.csv;

// ✅ 正确: 仅保留键和度量
销售事实表:
LOAD
    OrderID,
    ProductID,    // ✅ 外键
    CustomerID,   // ✅ 外键
    SalesAmount   // ✅ 度量
FROM sales.csv;
```

---

## 3.3 雪花模型

### 3.3.1 雪花模型概念

**雪花模型**是星型模型的规范化版本:

```
雪花模型结构:

[产品类别] --- [产品子类别] --- [产品维度]
                                    |
                                    |
                            [事实表:销售]
                                    |
                                    |
[国家] --- [省份] --- [城市] --- [客户维度]

特点:
✅ 维度表进一步规范化
✅ 减少数据冗余
✅ 更新维护更容易
❌ 查询可能稍慢
❌ 关联更复杂
```

### 3.3.2 构建雪花模型

```qlik
///$tab 产品层次
// 产品类别表
产品类别表:
LOAD
    类别ID as CategoryID,
    类别名称 as CategoryName
FROM categories.csv;

// 产品子类别表
产品子类别表:
LOAD
    子类别ID as SubCategoryID,
    子类别名称 as SubCategoryName,
    类别ID as CategoryID           // 关联到类别表
FROM subcategories.csv;

// 产品表
产品表:
LOAD
    产品ID as ProductID,
    产品名称 as ProductName,
    子类别ID as SubCategoryID      // 关联到子类别表
FROM products.csv;

///$tab 地理层次
// 国家表
国家表:
LOAD
    国家代码 as CountryCode,
    国家名称 as CountryName
FROM countries.csv;

// 省份表
省份表:
LOAD
    省份代码 as ProvinceCode,
    省份名称 as ProvinceName,
    国家代码 as CountryCode
FROM provinces.csv;

// 城市表
城市表:
LOAD
    城市代码 as CityCode,
    城市名称 as CityName,
    省份代码 as ProvinceCode
FROM cities.csv;

// 客户表
客户表:
LOAD
    客户ID as CustomerID,
    客户名称 as CustomerName,
    城市代码 as CityCode
FROM customers.csv;
```

### 3.3.3 星型vs雪花选择

**选择星型模型的场景**:
- ✅ 查询性能优先
- ✅ BI分析应用
- ✅ Qlik Sense(推荐)

**选择雪花模型的场景**:
- ✅ 存储空间受限
- ✅ 数据频繁更新
- ✅ 强制规范化要求

**Qlik建议**: **优先使用星型模型**
```
原因:
1. Qlik内存压缩能力强,冗余影响小
2. 关联层次少,性能更好
3. 模型更简单,易理解
```

---

## 3.4 数据关联

### 3.4.1 自动关联

**Qlik自动关联规则**:

```qlik
// 规则: 同名字段自动关联

客户表:
LOAD
    CustomerID,    // 这个字段...
    CustomerName
FROM customers.csv;

订单表:
LOAD
    OrderID,
    CustomerID,    // ...会自动关联到这个字段
    Amount
FROM orders.csv;

// 结果: CustomerID自动关联
```

**关联状态检查**:

在数据模型查看器中:
- 🟢 绿色箭头: 已关联
- 🔴 红色圆圈: 合成键(见下文)
- ⚪ 无连接: 数据岛

### 3.4.2 重命名避免意外关联

```qlik
// 问题: 不同含义的同名字段会错误关联

产品表:
LOAD
    ID as ProductID,    // 产品ID
    Name
FROM products.csv;

订单表:
LOAD
    ID as OrderID,      // 订单ID (不应该关联)
    ProductID,
    Amount
FROM orders.csv;

// ✅ 解决: 重命名为不同名称
产品表:
LOAD
    ID as ProductID,
    Name as ProductName
FROM products.csv;

订单表:
LOAD
    ID as OrderID,      // 现在不会关联了
    ProductRef as ProductID,  // 这个才关联
    Amount
FROM orders.csv;
```

### 3.4.3 强制关联(Qualify/Unqualify)

```qlik
// Qualify: 给所有字段加表名前缀

Qualify *;  // 启用字段前缀

产品表:
LOAD
    ProductID,    // 实际变成: 产品表.ProductID
    ProductName   // 实际变成: 产品表.ProductName
FROM products.csv;

Unqualify ProductID;  // 除了ProductID,用于关联

订单表:
LOAD
    OrderID,      // 实际变成: 订单表.OrderID
    ProductID,    // 保持ProductID,用于关联
    Amount        // 实际变成: 订单表.Amount
FROM orders.csv;

Unqualify *;  // 禁用前缀
```

---

## 3.5 复合键与合成键

### 3.5.1 什么是复合键?

**复合键**: 多个字段组合才能唯一标识记录

```
示例: 销售明细表

订单ID | 产品ID | 数量 | 单价
001    | P001   | 10   | 100
001    | P002   | 5    | 200
002    | P001   | 3    | 100

复合主键: (订单ID, 产品ID)
```

### 3.5.2 Qlik中的复合键问题

```qlik
// 问题场景

订单明细表:
LOAD
    订单ID,
    产品ID,
    数量
FROM order_details.csv;

发货明细表:
LOAD
    订单ID,
    产品ID,
    发货数量
FROM shipment_details.csv;

// Qlik会自动创建合成键!
// 合成键名称: [$Syn 1 Table]
// 包含: 订单ID, 产品ID
```

**查看合成键**:

在数据模型查看器中,合成键显示为红色的系统表。

### 3.5.3 处理复合键

**方法1: 创建显式复合键**

```qlik
// ✅ 推荐: 创建复合键字段

订单明细表:
LOAD
    订单ID & '|' & 产品ID as 订单产品键,  // 显式复合键
    订单ID,
    产品ID,
    数量
FROM order_details.csv;

发货明细表:
LOAD
    订单ID & '|' & 产品ID as 订单产品键,  // 相同的复合键
    订单ID,
    产品ID,
    发货数量
FROM shipment_details.csv;

// 结果: 通过"订单产品键"关联,无合成键
```

**方法2: 使用AutoNumber()**

```qlik
// 优化: 使用数字键(性能更好)

订单明细表:
LOAD
    AutoNumber(订单ID & '|' & 产品ID, '订单产品') as 订单产品键,
    订单ID,
    产品ID,
    数量
FROM order_details.csv;

发货明细表:
LOAD
    AutoNumber(订单ID & '|' & 产品ID, '订单产品') as 订单产品键,
    订单ID,
    产品ID,
    发货数量
FROM shipment_details.csv;

// AutoNumber优势:
// - 生成整数键
// - 更快的关联
// - 更少的内存
```

**方法3: Concatenate合并表**

```qlik
// 如果两表结构相同,可以合并

订单明细表:
LOAD
    订单ID,
    产品ID,
    数量,
    Null() as 发货数量
FROM order_details.csv;

CONCATENATE (订单明细表)
LOAD
    订单ID,
    产品ID,
    Null() as 数量,
    发货数量
FROM shipment_details.csv;

// 结果: 单一表,无关联问题
```

---

## 3.6 循环引用

### 3.6.1 什么是循环引用?

**循环引用**: 表之间形成闭环关联

```
循环示例:

订单表 --- 客户表
  |           |
  |           |
产品表 -------+

问题: 订单→客户→产品→订单 形成循环
Qlik无法确定关联路径!
```

### 3.6.2 检测循环引用

**Qlik警告**:

加载数据时会提示:
```
"Circular reference detected"
"循环引用: 订单表 -> 客户表 -> 产品表 -> 订单表"
```

**在数据模型查看器中**:
- 循环的表会用红色标记
- 显示警告图标

### 3.6.3 解决循环引用

**方法1: 断开循环(最常用)**

```qlik
// 识别非必要关联并断开

// 假设结构:
// 订单表: 订单ID, 客户ID, 产品ID
// 客户表: 客户ID, 客户名, 地区ID
// 产品表: 产品ID, 产品名, 类别ID
// 地区表: 地区ID, 地区名
// 类别表: 类别ID, 类别名

// 如果地区ID和类别ID同名,会循环!

// ✅ 解决: 重命名避免意外关联
客户表:
LOAD
    客户ID,
    客户名,
    地区ID as 客户地区ID  // 重命名
FROM customers.csv;

产品表:
LOAD
    产品ID,
    产品名,
    类别ID as 产品类别ID  // 重命名
FROM products.csv;
```

**方法2: 使用连接(Join)**

```qlik
// 通过JOIN合并表来消除循环

订单表:
LOAD
    订单ID,
    客户ID,
    产品ID
FROM orders.csv;

// LEFT JOIN客户信息
LEFT JOIN (订单表)
LOAD
    客户ID,
    客户名,
    城市
FROM customers.csv;

// LEFT JOIN产品信息
LEFT JOIN (订单表)
LOAD
    产品ID,
    产品名,
    类别
FROM products.csv;

// 结果: 单一宽表,无循环
```

**方法3: 创建链接表**

```qlik
// 复杂场景: 使用链接表

// 原始循环:
// 订单 - 产品
// 订单 - 促销
// 产品 - 促销

// ✅ 创建链接表
订单产品促销链接:
LOAD
    订单ID & '|' & 产品ID & '|' & 促销ID as LinkKey,
    订单ID,
    产品ID,
    促销ID
FROM order_product_promotion.csv;

订单表:
LOAD
    订单ID,
    订单日期,
    客户ID
FROM orders.csv;

产品表:
LOAD
    产品ID,
    产品名
FROM products.csv;

促销表:
LOAD
    促销ID,
    促销名
FROM promotions.csv;
```

---

## 3.7 数据模型优化

### 3.7.1 减少表数量

```qlik
// ❌ 过多的表
客户基本信息表: (10个字段)
客户联系方式表: (5个字段)
客户地址表: (6个字段)

// ✅ 合并相关表
客户表: (21个字段)
```

### 3.7.2 优化字段数量

```qlik
// ❌ 加载不需要的字段
LOAD * FROM huge_table.csv;  // 100个字段

// ✅ 仅加载需要的
LOAD
    ID,
    Name,
    Amount,
    Date
FROM huge_table.csv;  // 4个字段
```

### 3.7.3 使用QVD分层

```qlik
// 三层QVD架构

// 第一层: 原始数据QVD
RawData:
LOAD * FROM source.csv;
STORE RawData INTO [lib://QVD/L1_Raw/raw_data.qvd] (qvd);

// 第二层: 转换后QVD
TransformedData:
LOAD
    ID,
    Date(DateField) as Date,
    Upper(Name) as Name
FROM [lib://QVD/L1_Raw/raw_data.qvd] (qvd);
STORE TransformedData INTO [lib://QVD/L2_Transform/transformed.qvd] (qvd);

// 第三层: 应用QVD
AppData:
LOAD * FROM [lib://QVD/L2_Transform/transformed.qvd] (qvd);
```

---

## 3.8 数据模型查看器

### 3.8.1 使用模型查看器

**打开方式**:
1. 数据管理器 → 右上角 → [数据模型查看器]
2. 数据加载编辑器 → 加载数据后 → [数据模型查看器]

**界面功能**:

```
数据模型查看器:

┌─────────────────────────────────────┐
│  [内部表视图] [预览]                │
├─────────────────────────────────────┤
│                                     │
│   [客户表]        [订单表]          │
│   CustomerID ──── CustomerID        │
│   CustomerName    OrderID           │
│   City            OrderDate         │
│                   ProductID ───┐    │
│                   Amount       │    │
│                                │    │
│   [产品表]  ←──────────────────┘    │
│   ProductID                         │
│   ProductName                       │
│   Category                          │
│                                     │
└─────────────────────────────────────┘
```

### 3.8.2 表信息查看

点击表可以看到:
- 行数
- 字段数
- 内存占用
- 关联字段(绿色标记)

### 3.8.3 字段统计

点击字段可以看到:
- 唯一值数量
- 数据类型
- 标签(如果有)
- 是否是键字段

---

## 3.9 实验:构建完整星型模型

### 实验目标

构建一个完整的销售分析星型模型

**数据准备**:

创建以下CSV文件在code/chapter03/:

**products.csv**:
```csv
ProductID,ProductName,Category,SubCategory,UnitPrice
P001,笔记本电脑,电子产品,计算机,5000
P002,台式机,电子产品,计算机,4000
P003,智能手机,电子产品,通讯,3000
P004,平板电脑,电子产品,计算机,2000
```

**customers.csv**:
```csv
CustomerID,CustomerName,City,Province,Country
C001,张三,北京,北京,中国
C002,李四,上海,上海,中国
C003,王五,广州,广东,中国
```

**sales_fact.csv**:
```csv
OrderID,OrderDate,CustomerID,ProductID,Quantity,Amount
001,2024-01-01,C001,P001,1,5000
002,2024-01-02,C002,P002,2,8000
003,2024-01-03,C001,P003,1,3000
004,2024-01-05,C003,P004,3,6000
```

**Qlik脚本**:

```qlik
///$tab 产品维度
产品维度:
LOAD
    ProductID,
    ProductName,
    Category,
    SubCategory,
    Num(UnitPrice, '#,##0.00') as UnitPrice
FROM [lib://Chapter03/products.csv]
(txt, utf8, embedded labels);

///$tab 客户维度
客户维度:
LOAD
    CustomerID,
    CustomerName,
    City,
    Province,
    Country
FROM [lib://Chapter03/customers.csv]
(txt, utf8, embedded labels);

///$tab 销售事实
销售事实:
LOAD
    OrderID,
    Date(Date#(OrderDate, 'YYYY-MM-DD')) as OrderDate,
    CustomerID,
    ProductID,
    Num(Quantity) as Quantity,
    Num(Amount, '#,##0.00') as SalesAmount,
    Num(Amount/Quantity, '#,##0.00') as ActualPrice
FROM [lib://Chapter03/sales_fact.csv]
(txt, utf8, embedded labels);

///$tab 验证模型
TRACE ===== 数据模型验证 =====;
TRACE 产品数: $(NoOfRows('产品维度'));
TRACE 客户数: $(NoOfRows('客户维度'));
TRACE 订单数: $(NoOfRows('销售事实'));

// 检查孤立记录
孤立产品:
LOAD DISTINCT
    ProductID
RESIDENT 销售事实
WHERE NOT Exists(ProductID, ProductID);

IF NoOfRows('孤立产品') > 0 THEN
    TRACE 警告: 发现$(NoOfRows('孤立产品'))个未关联的产品;
END IF

DROP Table 孤立产品;
```

---

## 3.10 课后练习

### 练习1: 星型模型设计

**任务**: 为以下场景设计星型模型
- 业务: 在线零售
- 需求: 分析产品、客户、时间维度的销售情况
- 实现: 创建维度表和事实表

### 练习2: 处理复合键

**任务**: 
1. 创建有复合键的数据集
2. 观察Qlik的合成键
3. 用3种方法消除合成键

### 练习3: 解决循环引用

**任务**:
1. 故意创建循环引用
2. 识别循环路径
3. 用2种方法解决循环

---

## 3.11 本章小结

### 核心概念

✅ **星型模型**: 事实表+维度表,BI标准模型

✅ **数据关联**: 同名字段自动关联

✅ **复合键**: 多字段组合键,使用AutoNumber优化

✅ **循环引用**: 断开、JOIN或链接表解决

✅ **模型优化**: 减少表、减少字段、使用QVD

### 最佳实践

```qlik
// 1. 一致命名
ProductID (不是 产品ID, PID, Product_ID)

// 2. 显式复合键
AutoNumber(Key1 & '|' & Key2) as CompositeKey

// 3. 避免循环
重命名或JOIN解决

// 4. 验证模型
TRACE检查行数和孤立记录

// 5. 文档化
注释关键关联和设计决策
```

### 模型设计检查清单

- [ ] 所有表都有明确用途(事实/维度)
- [ ] 主键唯一性验证
- [ ] 外键完整性检查
- [ ] 无循环引用
- [ ] 无不必要的合成键
- [ ] 字段命名一致
- [ ] 模型文档完整

### 下一章预告

**第4章 - 脚本编程深入**,将学习:
- 🔢 变量与参数化
- 🔄 循环与条件
- 📦 子程序与函数
- ⚡ 增量加载实现
- 📊 高级脚本技巧

---

[← 上一章](./2-数据加载基础.md) | [返回目录](./README.md) | [下一章: 脚本编程深入 →](./4-脚本编程深入.md)
