# 第6章：脚本与事件处理

## 6.1 脚本编程概述

### 6.1.1 为什么需要脚本？

虽然BIRT提供了丰富的可视化设计工具，但在某些场景下，脚本编程是必要的：

1. **复杂业务逻辑**：实现复杂的计算和判断
2. **动态行为**：根据数据动态改变报表行为
3. **数据转换**：在展示前对数据进行转换处理
4. **定制化需求**：实现标准组件无法提供的功能
5. **性能优化**：通过脚本优化特定场景性能

### 6.1.2 BIRT脚本语言

BIRT使用JavaScript作为脚本语言，提供：

- **标准JavaScript**：符合ECMAScript标准
- **BIRT扩展API**：访问BIRT对象模型
- **Java互操作**：调用Java类和方法
- **自定义函数**：创建可重用的脚本函数

### 6.1.3 脚本执行环境

脚本在BIRT中有不同的执行环境：

1. **设计时脚本**：在设计器中执行
2. **运行时脚本**：在报表引擎中执行
3. **客户端脚本**：在浏览器中执行
4. **服务器端脚本**：在应用服务器中执行

### 6.1.4 脚本调试

BIRT提供多种脚本调试方法：

- **日志输出**：使用logger对象输出调试信息
- **断点调试**：在Eclipse中设置断点
- **预览验证**：通过预览窗口验证脚本结果
- **错误处理**：使用try-catch捕获异常

## 6.2 事件模型

### 6.2.1 BIRT事件系统

BIRT采用事件驱动模型，主要事件类型包括：

1. **报表生命周期事件**：
   - initialize: 报表初始化
   - beforeFactory: 报表创建前
   - afterFactory: 报表创建后
   - beforeRender: 渲染前
   - afterRender: 渲染后

2. **数据事件**：
   - beforeOpen: 数据集打开前
   - afterOpen: 数据集打开后
   - fetch: 获取数据行
   - beforeClose: 数据集关闭前
   - afterClose: 数据集关闭后

3. **元素事件**：
   - onCreate: 元素创建时
   - onRender: 元素渲染时
   - onPrepare: 准备渲染时
   - onPageBreak: 分页时

### 6.2.2 事件执行顺序

理解事件执行顺序对于正确编写脚本至关重要：

```
报表启动
│
├─ beforeFactory (报表)
│   │
│   ├─ beforeOpen (数据源)
│   │   └─ afterOpen (数据源)
│   │
│   ├─ beforeOpen (数据集)
│   │   ├─ afterOpen (数据集)
│   │   ├─ fetch (数据集) - 重复调用
│   │   ├─ beforeClose (数据集)
│   │   └─ afterClose (数据集)
│   │
│   └─ onCreate (报表元素)
│
├─ beforeRender (报表)
│   ├─ onPrepare (元素)
│   └─ onRender (元素)
│
└─ afterRender (报表)
```

### 6.2.3 事件处理器编写

编写事件处理器的基本模式：

```javascript
// 基本事件处理器结构
function eventName(event) {
    try {
        // 事件处理逻辑
        // 可以访问BIRT API和脚本对象
        
        // 返回值（根据事件类型）
        return true; // 或特定返回值
    } catch (e) {
        // 错误处理
        logger.log("Error in " + eventName + ": " + e.message);
        throw e; // 重新抛出异常
    }
}
```

## 6.3 报表级脚本

### 6.3.1 beforeFactory事件

beforeFactory在报表创建前执行，适合进行全局初始化：

```javascript
// 报表beforeFactory事件
function beforeFactory() {
    // 设置报表全局变量
    reportContext.setPersistentGlobalVariable("company_name", "ACME Corporation");
    reportContext.setPersistentGlobalVariable("current_year", new Date().getFullYear());
    
    // 初始化自定义缓存
    reportContext.setGlobalVariable("product_cache", new HashMap());
    
    // 设置报表参数默认值
    if (params["start_date"] == null) {
        var today = new Date();
        var lastMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1);
        params["start_date"] = lastMonth;
    }
    
    // 设置用户权限
    var userRole = getUserRole(); // 自定义函数
    reportContext.setGlobalVariable("user_role", userRole);
}
```

### 6.3.2 afterFactory事件

afterFactory在报表创建后执行，适合进行清理工作：

```javascript
// 报表afterFactory事件
function afterFactory() {
    // 记录报表执行日志
    var reportName = reportContext.getReportName();
    var executionTime = new Date();
    var user = reportContext.getUserId();
    
    logReportExecution(reportName, user, executionTime);
    
    // 清理临时资源
    cleanupTempFiles();
    
    // 生成报告摘要
    generateReportSummary();
}
```

### 6.3.3 initialize事件

initialize在报表初始化时执行，适合设置初始状态：

```javascript
// 报表initialize事件
function initialize() {
    // 初始化主题
    applyTheme(params["theme"] || "default");
    
    // 初始化国际化资源
    initI18nResources(params["language"] || "en");
    
    // 初始化自定义对象
    reportContext.setGlobalVariable("custom_formatter", new CustomFormatter());
    
    // 设置默认时区
    reportContext.setTimeZone(TimeZone.getTimeZone("UTC"));
}
```

## 6.4 数据集脚本

### 6.4.1 beforeOpen事件

beforeOpen在数据集打开前执行，适合动态修改查询：

```javascript
// 数据集beforeOpen事件
function beforeOpen(dataSet, arg) {
    // 获取原始查询
    var queryText = this.queryText;
    
    // 根据参数动态修改查询
    if (params["include_inactive"] != "true") {
        queryText += " AND status = 'Active'";
    }
    
    // 添加安全过滤
    var userRole = reportContext.getGlobalVariable("user_role");
    if (userRole == "sales_rep") {
        var userId = reportContext.getUserId();
        queryText += " AND sales_rep_id = '" + userId + "'";
    }
    
    // 应用修改后的查询
    this.queryText = queryText;
    
    // 设置查询参数
    if (params["date_range"] == "last_30_days") {
        var endDate = new Date();
        var startDate = new Date(endDate.getTime() - 30 * 24 * 60 * 60 * 1000);
        this.setInputParameterValue(1, startDate);
        this.setInputParameterValue(2, endDate);
    }
}
```

### 6.4.2 fetch事件

fetch在获取每一行数据时执行，适合动态计算和过滤：

```javascript
// 数据集fetch事件
function fetch(dataSet, row) {
    // 获取当前行数据
    var productId = row["product_id"];
    var saleAmount = row["sale_amount"];
    var quantity = row["quantity"];
    
    // 动态计算字段
    row["unit_price"] = saleAmount / quantity;
    
    // 计算利润
    var cost = getProductCost(productId); // 自定义函数
    row["profit"] = saleAmount - (cost * quantity);
    row["profit_margin"] = row["profit"] / saleAmount * 100;
    
    // 应用业务规则
    var discountRate = calculateDiscount(productId, quantity);
    row["discount_amount"] = saleAmount * discountRate;
    row["final_amount"] = saleAmount - row["discount_amount"];
    
    // 格式化显示
    row["sale_amount_formatted"] = formatCurrency(saleAmount);
    row["profit_formatted"] = formatCurrency(row["profit"]);
    
    // 返回true继续处理下一行
    return true;
}
```

### 6.4.3 afterClose事件

afterClose在数据集关闭后执行，适合进行后处理：

```javascript
// 数据集afterClose事件
function afterClose(dataSet) {
    // 记录数据集执行统计
    var stats = {
        dataSetName: this.getDataSource().getName(),
        rowCount: this.getRowCount(),
        executionTime: this.getExecutionTime()
    };
    
    logDataSetExecution(stats);
    
    // 缓存常用数据
    if (this.getName() == "product_master") {
        var cache = reportContext.getGlobalVariable("product_cache");
        cache.put("last_updated", new Date());
        cache.put("record_count", this.getRowCount());
    }
}
```

## 6.5 元素脚本

### 6.5.1 onCreate事件

onCreate在元素创建时执行，适合初始化元素属性：

```javascript
// 表格onCreate事件
function onCreate() {
    // 设置表格初始样式
    this.getStyle().borderCollapse = "collapse";
    this.getStyle().width = "100%";
    
    // 根据数据量设置行高
    if (this.getDataSet().getRowCount() > 100) {
        this.getStyle().setFontSize("9pt"); // 减小字体适应更多数据
    }
    
    // 添加交替行样式
    this.setAlternateRowClass("data-row-alternate");
}

// 图表onCreate事件
function onCreate() {
    // 设置图表标题
    var title = this.getTitle();
    title.getCaption().setValue("Sales Performance - " + params["time_period"]);
    
    // 设置颜色方案
    this.setSeriesPalette(["#2196F3", "#4CAF50", "#FFC107", "#FF5722"]);
    
    // 设置交互
    this.setInteractive(true);
    this.enableAnimation(true);
}
```

### 6.5.2 onRender事件

onRender在元素渲染时执行，适合根据数据动态调整外观：

```javascript
// 数据项onRender事件
function onRender() {
    var value = this.getValue();
    var dataType = this.getDataType();
    
    // 根据数据类型格式化
    if (dataType == "currency") {
        this.setDisplayValue(formatCurrency(value));
    } else if (dataType == "percentage") {
        this.setDisplayValue((value * 100).toFixed(2) + "%");
    } else if (dataType == "date") {
        this.setDisplayValue(formatDate(value));
    }
    
    // 根据值应用条件样式
    if (this.getName() == "profit_margin") {
        if (value > 20) {
            this.getStyle().color = "#2E7D32"; // 深绿色
        } else if (value > 10) {
            this.getStyle().color = "#F57C00"; // 深橙色
        } else {
            this.getStyle().color = "#C62828"; // 深红色
        }
    }
}

// 表格行onRender事件
function onRender() {
    var rowNumber = this.getRowData().getRowNumber();
    
    // 设置斑马纹
    if (rowNumber % 2 == 0) {
        this.getStyle().backgroundColor = "#F5F5F5";
    } else {
        this.getStyle().backgroundColor = "white";
    }
    
    // 高亮特定行
    if (this.getRowData().getExpressionValue("row.urgent_flag") == "Y") {
        this.getStyle().backgroundColor = "#FFEBEE";
        this.getStyle().fontWeight = "bold";
    }
}
```

### 6.5.3 onPrepare事件

onPrepare在准备渲染时执行，适合进行最终调整：

```javascript
// 网格onPrepare事件
function onPrepare() {
    // 根据参数调整网格布局
    var layout = params["layout_mode"];
    
    if (layout == "compact") {
        // 紧凑模式：减少间距
        this.getStyle().padding = "2px";
        this.getStyle().setColumnWidths(["20%", "15%", "15%", "15%", "15%", "20%"]);
    } else if (layout == "detailed") {
        // 详细模式：增加间距
        this.getStyle().padding = "8px";
        this.getStyle().setColumnWidths(["15%", "15%", "20%", "15%", "15%", "20%"]);
    } else {
        // 默认布局
        this.getStyle().padding = "4px";
        this.getStyle().setColumnWidths(["18%", "16%", "16%", "16%", "16%", "18%"]);
    }
    
    // 根据用户权限隐藏某些列
    var userRole = reportContext.getGlobalVariable("user_role");
    if (userRole == "viewer") {
        this.getColumn(5).setVisibility("hidden"); // 隐藏成本列
    }
}
```

## 6.6 高级脚本技巧

### 6.6.1 自定义函数

创建可重用的自定义函数：

```javascript
// 全局脚本区域：创建自定义函数

// 格式化货币
function formatCurrency(amount) {
    var currency = params["currency"] || "USD";
    var locale = params["locale"] || "en-US";
    
    return new Intl.NumberFormat(locale, {
        style: 'currency',
        currency: currency
    }).format(amount);
}

// 计算增长率
function calculateGrowthRate(currentValue, previousValue) {
    if (previousValue == 0) {
        return currentValue > 0 ? 100 : 0;
    }
    return ((currentValue - previousValue) / previousValue) * 100;
}

// 获取产品成本（带缓存）
function getProductCost(productId) {
    var cache = reportContext.getGlobalVariable("product_cache");
    
    // 检查缓存
    if (cache.containsKey(productId)) {
        return cache.get(productId);
    }
    
    // 查询数据库
    var cost = queryProductCost(productId); // 自定义数据库查询函数
    
    // 缓存结果
    cache.put(productId, cost);
    
    return cost;
}

// 安全的数值转换
function toNumber(value, defaultValue) {
    if (value == null || value == "") {
        return defaultValue || 0;
    }
    
    var num = parseFloat(value);
    return isNaN(num) ? (defaultValue || 0) : num;
}
```

### 6.6.2 Java集成

从BIRT脚本调用Java类和方法：

```javascript
// 调用Java类
function callJavaClass() {
    // 创建Java实例
    var dateUtil = new Packages.java.util.Date();
    var dateFormat = new Packages.java.text.SimpleDateFormat("yyyy-MM-dd");
    
    // 调用Java方法
    var today = dateFormat.format(dateUtil);
    
    // 调用自定义Java类
    var myUtils = new Packages.com.mycompany.utils.BirtUtils();
    var encrypted = myUtils.encrypt(params["password"]);
    
    return encrypted;
}

// 处理集合
function processCollection() {
    // 创建Java集合
    var list = new Packages.java.util.ArrayList();
    list.add("Item 1");
    list.add("Item 2");
    list.add("Item 3");
    
    // 遍历集合
    var iterator = list.iterator();
    while (iterator.hasNext()) {
        var item = iterator.next();
        logger.log("Processing item: " + item);
    }
    
    return list.size();
}
```

### 6.6.3 异步处理

实现异步操作提高性能：

```javascript
// 异步数据加载
function loadAsyncData() {
    var asyncLoader = new Packages.com.mycompany.birt.AsyncDataLoader();
    
    // 设置回调函数
    asyncLoader.setCallback(function(result) {
        // 处理返回结果
        reportContext.setGlobalVariable("async_data", result);
        refreshComponent("async_table");
    });
    
    // 启动异步加载
    asyncLoader.loadData(params["async_params"]);
}

// 并行执行多个任务
function executeParallelTasks() {
    var executor = new Packages.java.util.concurrent.Executors.newFixedThreadPool(3);
    
    var tasks = [];
    tasks.push(new Packages.java.util.concurrent.Callable({
        call: function() {
            return loadProductData(); // 自定义函数
        }
    }));
    
    tasks.push(new Packages.java.util.concurrent.Callable({
        call: function() {
            return loadCustomerData(); // 自定义函数
        }
    }));
    
    tasks.push(new Packages.java.util.concurrent.Callable({
        call: function() {
            return loadSalesData(); // 自定义函数
        }
    }));
    
    // 执行任务
    var futures = executor.invokeAll(tasks);
    
    // 收集结果
    var results = [];
    for (var i = 0; i < futures.size(); i++) {
        results.add(futures.get(i).get());
    }
    
    // 关闭线程池
    executor.shutdown();
    
    return results;
}
```

## 6.7 脚本库管理

### 6.7.1 创建脚本库

创建可重用的脚本库：

```javascript
// 文件: birt_script_library.js

/**
 * 格式化工具类
 */
var FormatUtils = {
    /**
     * 格式化货币
     */
    formatCurrency: function(amount, currency, locale) {
        currency = currency || "USD";
        locale = locale || "en-US";
        
        return new Intl.NumberFormat(locale, {
            style: 'currency',
            currency: currency
        }).format(amount);
    },
    
    /**
     * 格式化日期
     */
    formatDate: function(date, format) {
        format = format || "yyyy-MM-dd";
        var dateFormat = new Packages.java.text.SimpleDateFormat(format);
        return dateFormat.format(date);
    },
    
    /**
     * 格式化百分比
     */
    formatPercentage: function(value, decimals) {
        decimals = decimals || 2;
        return (value * 100).toFixed(decimals) + "%";
    }
};

/**
 * 业务逻辑工具类
 */
var BusinessUtils = {
    /**
     * 计算增长率
     */
    calculateGrowthRate: function(current, previous) {
        if (previous == 0) {
            return current > 0 ? 100 : 0;
        }
        return ((current - previous) / previous) * 100;
    },
    
    /**
     * 计算利润率
     */
    calculateProfitMargin: function(revenue, cost) {
        if (revenue == 0) return 0;
        return ((revenue - cost) / revenue) * 100;
    },
    
    /**
     * 应用业务规则
     */
    applyBusinessRules: function(data, rules) {
        for (var i = 0; i < data.length; i++) {
            for (var rule in rules) {
                if (rules.hasOwnProperty(rule)) {
                    data[i] = rules[rule](data[i]);
                }
            }
        }
        return data;
    }
};

/**
 * 数据处理工具类
 */
var DataUtils = {
    /**
     * 数据聚合
     */
    aggregate: function(data, groupBy, aggregations) {
        var groups = {};
        
        // 分组数据
        for (var i = 0; i < data.length; i++) {
            var key = data[i][groupBy];
            if (!groups[key]) {
                groups[key] = [];
            }
            groups[key].push(data[i]);
        }
        
        // 应用聚合
        var result = [];
        for (var key in groups) {
            if (groups.hasOwnProperty(key)) {
                var group = groups[key];
                var aggregated = { group: key };
                
                for (var agg in aggregations) {
                    if (aggregations.hasOwnProperty(agg)) {
                        aggregated[agg] = aggregations[agg](group);
                    }
                }
                
                result.push(aggregated);
            }
        }
        
        return result;
    },
    
    /**
     * 数据排序
     */
    sort: function(data, fields, orders) {
        return data.sort(function(a, b) {
            for (var i = 0; i < fields.length; i++) {
                var field = fields[i];
                var order = orders && orders[i] ? -1 : 1;
                
                if (a[field] < b[field]) return -1 * order;
                if (a[field] > b[field]) return 1 * order;
            }
            return 0;
        });
    },
    
    /**
     * 数据过滤
     */
    filter: function(data, filters) {
        return data.filter(function(item) {
            for (var field in filters) {
                if (filters.hasOwnProperty(field)) {
                    var filter = filters[field];
                    if (typeof filter === 'function') {
                        if (!filter(item[field])) return false;
                    } else if (item[field] !== filter) {
                        return false;
                    }
                }
            }
            return true;
        });
    }
};
```

### 6.7.2 使用脚本库

在报表中使用脚本库：

```javascript
// 在报表的initialize事件中加载脚本库
function initialize() {
    // 读取脚本库文件
    var scriptContent = Packages.java.io.File("birt_script_library.js").getText();
    
    // 执行脚本库
    eval(scriptContent);
    
    // 使脚本库全局可用
    reportContext.setGlobalVariable("FormatUtils", FormatUtils);
    reportContext.setGlobalVariable("BusinessUtils", BusinessUtils);
    reportContext.setGlobalVariable("DataUtils", DataUtils);
}

// 在数据集fetch事件中使用
function fetch(dataSet, row) {
    // 使用格式化工具
    row["formatted_amount"] = FormatUtils.formatCurrency(row["amount"], "USD");
    row["profit_margin_pct"] = FormatUtils.formatPercentage(row["profit_margin"]);
    
    // 使用业务工具
    row["growth_rate"] = BusinessUtils.calculateGrowthRate(
        row["current_sales"], 
        row["previous_sales"]
    );
    
    return true;
}
```

## 6.8 错误处理与调试

### 6.8.1 错误处理最佳实践

实现健壮的错误处理：

```javascript
// 安全的脚本执行函数
function safeExecute(fn, context, defaultValue) {
    try {
        if (typeof fn === 'function') {
            return fn.call(context);
        }
        return defaultValue;
    } catch (e) {
        // 记录详细错误信息
        var errorInfo = {
            message: e.message,
            stack: e.stack,
            context: context ? context.toString() : "unknown",
            timestamp: new Date()
        };
        
        logError(errorInfo);
        return defaultValue;
    }
}

// 包装数据集fetch事件
function safeFetch(dataSet, row) {
    // 验证必要字段
    var requiredFields = ["product_id", "quantity", "sale_amount"];
    for (var i = 0; i < requiredFields.length; i++) {
        var field = requiredFields[i];
        if (row[field] == null || row[field] === "") {
            logger.log("Missing required field: " + field);
            return false; // 跳过这一行
        }
    }
    
    // 安全执行计算
    row["unit_price"] = safeExecute(function() {
        return row["sale_amount"] / row["quantity"];
    }, this, 0);
    
    return true;
}
```

### 6.8.2 调试技巧

有效的调试方法：

```javascript
// 详细日志函数
function debugLog(message, data, level) {
    level = level || "INFO";
    var timestamp = new Date().toISOString();
    var logMessage = "[" + timestamp + "] [" + level + "] " + message;
    
    if (data) {
        logMessage += " - Data: " + JSON.stringify(data);
    }
    
    logger.log(logMessage);
    
    // 在开发环境中输出到控制台
    if (params["debug_mode"] == "true") {
        java.lang.System.out.println(logMessage);
    }
}

// 性能监控
function measureTime(fn, context) {
    var startTime = new Date().getTime();
    var result;
    
    try {
        result = fn.call(context);
    } catch (e) {
        var endTime = new Date().getTime();
        debugLog("Function execution failed", {
            duration: endTime - startTime + "ms",
            error: e.message
        }, "ERROR");
        throw e;
    }
    
    var endTime = new Date().getTime();
    debugLog("Function executed successfully", {
        duration: endTime - startTime + "ms"
    });
    
    return result;
}

// 数据验证
function validateData(data, schema) {
    var errors = [];
    
    for (var field in schema) {
        if (schema.hasOwnProperty(field)) {
            var rules = schema[field];
            var value = data[field];
            
            if (rules.required && (value == null || value === "")) {
                errors.push("Required field missing: " + field);
            }
            
            if (rules.type && value != null && typeof value !== rules.type) {
                errors.push("Invalid type for " + field + ": expected " + rules.type);
            }
            
            if (rules.validate && !rules.validate(value)) {
                errors.push("Validation failed for " + field);
            }
        }
    }
    
    if (errors.length > 0) {
        throw new Error("Data validation failed: " + errors.join(", "));
    }
    
    return true;
}
```

## 6.9 实战案例

### 6.9.1 动态财务报表

创建具有复杂逻辑的动态财务报表：

```javascript
// 报表初始化
function initialize() {
    // 加载财务规则
    var fiscalYear = params["fiscal_year"] || new Date().getFullYear();
    var fiscalRules = loadFiscalRules(fiscalYear);
    reportContext.setGlobalVariable("fiscal_rules", fiscalRules);
    
    // 初始化汇率服务
    var exchangeService = new Packages.com.mycompany.finance.ExchangeService();
    reportContext.setGlobalVariable("exchange_service", exchangeService);
}

// 财务数据计算
function fetchFinancialData(dataSet, row) {
    // 获取财务规则
    var rules = reportContext.getGlobalVariable("fiscal_rules");
    var exchangeService = reportContext.getGlobalVariable("exchange_service");
    
    // 基础字段
    var amount = row["amount"];
    var currency = row["currency"];
    var date = row["transaction_date"];
    
    // 货币转换
    var baseCurrency = params["base_currency"] || "USD";
    if (currency !== baseCurrency) {
        var exchangeRate = exchangeService.getExchangeRate(currency, baseCurrency, date);
        row["base_amount"] = amount * exchangeRate;
    } else {
        row["base_amount"] = amount;
    }
    
    // 应用财务规则
    for (var rule in rules) {
        if (rules.hasOwnProperty(rule)) {
            var ruleFunction = rules[rule];
            row[rule] = ruleFunction(row);
        }
    }
    
    // 计算财务指标
    row["revenue_recognized"] = calculateRevenueRecognition(row);
    row["tax_impact"] = calculateTaxImpact(row, rules);
    row["net_cash_flow"] = calculateNetCashFlow(row);
    
    return true;
}

// 营业收入识别计算
function calculateRevenueRecognition(transaction) {
    var rules = reportContext.getGlobalVariable("fiscal_rules");
    var recognitionMethod = transaction["revenue_recognition_method"];
    
    switch (recognitionMethod) {
        case "immediate":
            return transaction["base_amount"];
            
        case "deferred":
            var months = transaction["service_period_months"] || 12;
            return transaction["base_amount"] / months;
            
        case "percentage_completion":
            var completionPercent = transaction["completion_percent"] || 0;
            return transaction["base_amount"] * (completionPercent / 100);
            
        default:
            return transaction["base_amount"];
    }
}

// 税务影响计算
function calculateTaxImpact(transaction, rules) {
    var taxRate = rules["corporate_tax_rate"] || 0.21;
    var taxBase = transaction["base_amount"];
    
    // 应用特定规则
    if (transaction["tax_exempt"] === "Y") {
        return 0;
    }
    
    if (transaction["region"] === "EU") {
        taxRate = rules["eu_tax_rate"] || 0.20;
    }
    
    return taxBase * taxRate;
}

// 净现金流计算
function calculateNetCashFlow(transaction) {
    var cashIn = 0;
    var cashOut = 0;
    
    // 现金流入
    if (transaction["transaction_type"] === "sale") {
        cashIn = transaction["base_amount"];
    } else if (transaction["transaction_type"] === "receivable") {
        // 应收账款考虑回收率
        var collectionRate = transaction["collection_rate"] || 0.95;
        cashIn = transaction["base_amount"] * collectionRate;
    }
    
    // 现金流出
    if (transaction["transaction_type"] === "expense") {
        cashOut = transaction["base_amount"];
    } else if (transaction["transaction_type"] === "payable") {
        // 应付账款考虑付款周期
        cashOut = transaction["base_amount"];
    }
    
    return cashIn - cashOut;
}
```

### 6.9.2 高级销售仪表板

创建具有高级交互功能的销售仪表板：

```javascript
// 仪表板初始化
function initializeDashboard() {
    // 初始化WebSocket连接（用于实时数据）
    var wsUrl = "ws://sales.example.com/realtime";
    var ws = new Packages.org.java_websocket.client.WebSocketClient(new java.net.URI(wsUrl));
    
    ws.onMessage = function(message) {
        var data = JSON.parse(message);
        processRealtimeData(data);
    };
    
    ws.connect();
    reportContext.setGlobalVariable("websocket", ws);
    
    // 初始化用户偏好
    loadUserPreferences();
}

// 处理实时数据
function processRealtimeData(data) {
    var type = data.type;
    
    switch (type) {
        case "new_sale":
            updateSalesMetrics(data);
            break;
            
        case "inventory_change":
            updateInventoryStatus(data);
            break;
            
        case "customer_activity":
            updateCustomerActivity(data);
            break;
    }
    
    // 刷新相关组件
    refreshDashboardComponents();
}

// 更新销售指标
function updateSalesMetrics(saleData) {
    var currentMetrics = reportContext.getGlobalVariable("sales_metrics") || {};
    
    // 更新总销售额
    currentMetrics.total_sales = (currentMetrics.total_sales || 0) + saleData.amount;
    
    // 更新订单数量
    currentMetrics.order_count = (currentMetrics.order_count || 0) + 1;
    
    // 更新区域销售
    var region = saleData.region;
    if (!currentMetrics.region_sales) {
        currentMetrics.region_sales = {};
    }
    currentMetrics.region_sales[region] = (currentMetrics.region_sales[region] || 0) + saleData.amount;
    
    // 保存更新后的指标
    reportContext.setGlobalVariable("sales_metrics", currentMetrics);
}

// 自定义图表渲染
function renderAdvancedChart(chart, data) {
    // 获取画布
    var canvas = chart.getCanvas();
    var ctx = canvas.getContext("2d");
    
    // 自定义渲染逻辑
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 绘制背景网格
    drawGrid(ctx, canvas.width, canvas.height);
    
    // 绘制数据
    drawChartData(ctx, data);
    
    // 添加交互热点
    addInteractiveHotspots(ctx, data);
}

// 添加交互热点
function addInteractiveHotspots(ctx, data) {
    for (var i = 0; i < data.length; i++) {
        var point = data[i];
        var x = calculateXPosition(point, ctx.canvas.width);
        var y = calculateYPosition(point, ctx.canvas.height);
        
        // 创建隐形热点区域
        var hotspot = {
            x: x - 5,
            y: y - 5,
            width: 10,
            height: 10,
            data: point,
            tooltip: createTooltip(point)
        };
        
        ctx.hotspots = ctx.hotspots || [];
        ctx.hotspots.push(hotspot);
    }
}
```

## 6.10 最佳实践

### 6.10.1 脚本组织

1. **模块化设计**：
   - 按功能分组脚本
   - 创建可重用的函数库
   - 使用命名空间避免冲突

2. **代码规范**：
   - 统一命名约定
   - 添加注释说明
   - 遵循JavaScript最佳实践

3. **版本控制**：
   - 使用版本控制系统管理脚本
   - 记录变更历史
   - 定期备份重要脚本

### 6.10.2 性能优化

1. **减少重复计算**：
   - 使用缓存存储计算结果
   - 避免在事件处理中执行复杂操作

2. **异步处理**：
   - 对耗时操作使用异步处理
   - 避免阻塞UI线程

3. **资源管理**：
   - 及时释放不再使用的资源
   - 避免内存泄漏

### 6.10.3 安全考虑

1. **输入验证**：
   - 验证所有用户输入
   - 防止脚本注入攻击

2. **权限控制**：
   - 基于用户角色限制脚本功能
   - 敏感操作需要额外验证

3. **错误处理**：
   - 不向用户暴露详细错误信息
   - 记录错误但不泄露系统信息

## 6.11 本章小结

本章详细介绍了BIRT的脚本与事件处理功能。我们学习了：

- BIRT脚本编程的基本概念和执行环境
- 事件模型和事件处理机制
- 报表级、数据集和元素级脚本编写
- 高级脚本技巧，包括自定义函数和Java集成
- 脚本库的管理和使用
- 错误处理与调试技巧
- 实战案例展示

掌握脚本与事件处理是BIRT高级开发的重要技能，它使您能够实现复杂业务逻辑和定制化需求，将报表从简单的数据展示工具转变为强大的业务分析平台。在下一章中，我们将学习BIRT的部署与集成，了解如何将开发的报表部署到生产环境中并与其他系统集成。

## 6.12 实践练习

为了巩固本章知识，请完成以下练习：

1. 创建一个带有自定义函数的报表脚本库
2. 实现数据集的事件处理，包括数据计算和验证
3. 编写元素脚本，实现条件样式和动态内容
4. 创建具有实时数据更新功能的交互式仪表板
5. 实现报表的权限控制和用户个性化设置
6. 使用Java集成扩展BIRT的功能
7. 实现一个完整的错误处理和日志记录系统

完成这些练习后，您将掌握BIRT脚本与事件处理的高级技能，能够开发复杂、灵活且可靠的BIRT报表应用。