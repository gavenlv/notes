# 第7章 Doris性能优化

## 学习目标

- 掌握Doris性能优化的基本原则和方法
- 学会分析查询执行计划和性能瓶颈
- 了解Doris的表设计和分区优化策略
- 掌握Doris的查询优化技巧和参数调优
- 学会使用Doris的性能监控和诊断工具

## 1. 性能优化概述

### 1.1 性能优化原则

Doris性能优化应遵循以下原则：

1. **数据局部性优先**：尽可能减少数据传输和扫描量
2. **计算下推**：将计算尽可能推到数据存储层
3. **并行处理**：充分利用集群并行计算能力
4. **资源隔离**：合理分配和管理集群资源
5. **预计算**：使用物化视图等技术预计算常用查询

### 1.2 性能优化流程

Doris性能优化的一般流程：

1. **性能基准测试**：建立性能基准，确定优化目标
2. **性能分析**：使用工具分析性能瓶颈
3. **优化实施**：根据分析结果实施优化措施
4. **效果评估**：评估优化效果，持续改进

### 1.3 性能指标

Doris性能优化的主要指标：

1. **查询延迟**：查询响应时间
2. **吞吐量**：单位时间内处理的查询数量
3. **资源利用率**：CPU、内存、磁盘I/O和网络利用率
4. **并发能力**：同时处理的查询数量

## 2. 表设计优化

### 2.1 数据模型选择

根据业务场景选择合适的数据模型：

```sql
-- Duplicate模型：适合日志、行为等不需要去重的场景
CREATE TABLE demo.user_behavior_duplicate (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
DUPLICATE KEY(user_id, event_time)
DISTRIBUTED BY HASH(user_id) BUCKETS 32
PROPERTIES (
    "replication_num" = "3"
);

-- Aggregate模型：适合指标聚合场景
CREATE TABLE demo.user_behavior_aggregate (
    user_id BIGINT,
    event_date DATE,
    event_type VARCHAR(20),
    event_count BIGINT SUM DEFAULT "0",
    total_stay_time BIGINT SUM DEFAULT "0",
    max_stay_time INT MAX DEFAULT "0",
    min_stay_time INT MIN DEFAULT "0"
)
AGGREGATE KEY(user_id, event_date, event_type)
DISTRIBUTED BY HASH(user_id) BUCKETS 32
PROPERTIES (
    "replication_num" = "3"
);

-- Unique模型：适合需要唯一键的场景
CREATE TABLE demo.user_profile_unique (
    user_id BIGINT,
    user_name VARCHAR(50),
    age INT,
    gender VARCHAR(10),
    city VARCHAR(50),
    register_time DATETIME,
    last_login_time DATETIME
)
UNIQUE KEY(user_id)
DISTRIBUTED BY HASH(user_id) BUCKETS 16
PROPERTIES (
    "replication_num" = "3"
);

-- Primary Key模型：适合需要主键且频繁更新的场景
CREATE TABLE demo.user_profile_primary (
    user_id BIGINT,
    user_name VARCHAR(50),
    age INT,
    gender VARCHAR(10),
    city VARCHAR(50),
    register_time DATETIME,
    last_login_time DATETIME
)
PRIMARY KEY(user_id)
DISTRIBUTED BY HASH(user_id) BUCKETS 16
PROPERTIES (
    "replication_num" = "3"
);
```

### 2.2 分区策略优化

合理设计分区策略，提高查询性能：

```sql
-- 时间分区：按时间范围分区，适合时间序列数据
CREATE TABLE demo.user_behavior_time_partition (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
DUPLICATE KEY(user_id, event_time)
PARTITION BY RANGE(event_time) (
    PARTITION p20231120 VALUES LESS THAN ("2023-11-21"),
    PARTITION p20231121 VALUES LESS THAN ("2023-11-22"),
    PARTITION p20231122 VALUES LESS THAN ("2023-11-23"),
    PARTITION p20231123 VALUES LESS THAN ("2023-11-24"),
    PARTITION p20231124 VALUES LESS THAN ("2023-11-25")
)
DISTRIBUTED BY HASH(user_id) BUCKETS 32
PROPERTIES (
    "replication_num" = "3",
    "dynamic_partition.enable" = "true",
    "dynamic_partition.time_unit" = "DAY",
    "dynamic_partition.start" = "-7",
    "dynamic_partition.end" = "7",
    "dynamic_partition.prefix" = "p"
);

-- 列表分区：按离散值分区，适合分类数据
CREATE TABLE demo.user_behavior_list_partition (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
DUPLICATE KEY(user_id, event_time)
PARTITION BY LIST(event_type) (
    PARTITION p_view VALUES IN ("view"),
    PARTITION p_click VALUES IN ("click"),
    PARTITION p_purchase VALUES IN ("purchase"),
    PARTITION p_other VALUES IN ("favorite", "share", "comment")
)
DISTRIBUTED BY HASH(user_id) BUCKETS 32
PROPERTIES (
    "replication_num" = "3"
);

-- 复合分区：结合多种分区方式
CREATE TABLE demo.user_behavior_composite_partition (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
DUPLICATE KEY(user_id, event_time)
PARTITION BY RANGE(event_time) SUBPARTITION BY LIST(event_type) (
    PARTITION p20231120 VALUES LESS THAN ("2023-11-21") (
        SUBPARTITION s20231120_view VALUES IN ("view"),
        SUBPARTITION s20231120_click VALUES IN ("click"),
        SUBPARTITION s20231120_purchase VALUES IN ("purchase"),
        SUBPARTITION s20231120_other VALUES IN ("favorite", "share", "comment")
    ),
    PARTITION p20231121 VALUES LESS THAN ("2023-11-22") (
        SUBPARTITION s20231121_view VALUES IN ("view"),
        SUBPARTITION s20231121_click VALUES IN ("click"),
        SUBPARTITION s20231121_purchase VALUES IN ("purchase"),
        SUBPARTITION s20231121_other VALUES IN ("favorite", "share", "comment")
    )
)
DISTRIBUTED BY HASH(user_id) BUCKETS 32
PROPERTIES (
    "replication_num" = "3"
);
```

### 2.3 分桶策略优化

合理设计分桶策略，提高数据分布均匀性和查询性能：

```sql
-- 基于用户ID分桶：适合按用户查询的场景
CREATE TABLE demo.user_behavior_user_bucket (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
DUPLICATE KEY(user_id, event_time)
PARTITION BY RANGE(event_time) (
    PARTITION p20231120 VALUES LESS THAN ("2023-11-21"),
    PARTITION p20231121 VALUES LESS THAN ("2023-11-22")
)
DISTRIBUTED BY HASH(user_id) BUCKETS 32
PROPERTIES (
    "replication_num" = "3"
);

-- 基于时间和用户ID复合分桶：适合按时间和用户查询的场景
CREATE TABLE demo.user_behavior_time_user_bucket (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
DUPLICATE KEY(user_id, event_time)
PARTITION BY RANGE(event_time) (
    PARTITION p20231120 VALUES LESS THAN ("2023-11-21"),
    PARTITION p20231121 VALUES LESS THAN ("2023-11-22")
)
DISTRIBUTED BY HASH(user_id, DATE(event_time)) BUCKETS 32
PROPERTIES (
    "replication_num" = "3"
);

-- 调整分桶数量
ALTER TABLE demo.user_behavior_user_bucket SET ("distribution_bucket" = "64");
```

### 2.4 列设计优化

合理设计列结构，提高存储和查询效率：

```sql
-- 使用合适的数据类型
CREATE TABLE demo.user_behavior_column_optimized (
    user_id BIGINT,                    -- 使用BIGINT而不是VARCHAR存储用户ID
    event_time DATETIME,               -- 使用DATETIME而不是VARCHAR存储时间
    event_type TINYINT,                -- 使用TINYINT存储枚举值，通过字典表映射
    page_url VARCHAR(255),             -- 合理设置VARCHAR长度
    stay_time SMALLINT,                -- 使用SMALLINT而不是INT存储停留时间
    client_ip INT,                     -- 使用INT存储IP地址
    referrer_url VARCHAR(255)          -- 合理设置VARCHAR长度
)
DUPLICATE KEY(user_id, event_time)
DISTRIBUTED BY HASH(user_id) BUCKETS 32
PROPERTIES (
    "replication_num" = "3"
);

-- 创建事件类型字典表
CREATE TABLE demo.event_type_dict (
    type_id TINYINT,
    type_name VARCHAR(20)
)
DUPLICATE KEY(type_id)
DISTRIBUTED BY HASH(type_id) BUCKETS 4
PROPERTIES (
    "replication_num" = "3"
);

-- 插入字典数据
INSERT INTO demo.event_type_dict VALUES 
(1, 'view'),
(2, 'click'),
(3, 'purchase'),
(4, 'favorite'),
(5, 'share'),
(6, 'comment');

-- 查询时关联字典表
SELECT 
    b.user_id,
    b.event_time,
    d.type_name AS event_type,
    b.page_url,
    b.stay_time
FROM demo.user_behavior_column_optimized b
JOIN demo.event_type_dict d ON b.event_type = d.type_id
WHERE b.event_time >= '2023-11-20' AND b.event_time < '2023-11-21';
```

## 3. 索引优化

### 3.1 前缀索引优化

合理设置前缀索引长度，平衡索引大小和查询性能：

```sql
-- 创建表时设置前缀索引
CREATE TABLE demo.user_behavior_prefix_index (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
DUPLICATE KEY(user_id, event_time)
PROPERTIES (
    "replication_num" = "3",
    "prefix_index_length" = "64"  -- 根据查询模式调整前缀索引长度
);

-- 修改前缀索引长度
ALTER TABLE demo.user_behavior_prefix_index SET ("prefix_index_length" = "32");
```

### 3.2 布隆过滤器优化

为高频查询列添加布隆过滤器，提高查询性能：

```sql
-- 创建表时添加布隆过滤器
CREATE TABLE demo.user_behavior_bloom_filter (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
DUPLICATE KEY(user_id, event_time)
PROPERTIES (
    "replication_num" = "3",
    "bloom_filter_columns" = "user_id, event_type, client_ip"  -- 为高频查询列添加布隆过滤器
);

-- 为已有表添加布隆过滤器
ALTER TABLE demo.user_behavior SET ("bloom_filter_columns" = "user_id, event_type, client_ip");

-- 查看布隆过滤器效果
EXPLAIN SELECT * FROM demo.user_behavior_bloom_filter WHERE user_id = 1001;
```

### 3.3 位图索引优化

为低基数列添加位图索引，提高过滤性能：

```sql
-- 创建位图索引
CREATE BITMAP INDEX idx_user_behavior_event_type ON demo.user_behavior (event_type);
CREATE BITMAP INDEX idx_user_behavior_gender ON demo.user_profile (gender);
CREATE BITMAP INDEX idx_user_behavior_city ON demo.user_profile (city);

-- 创建复合位图索引
CREATE BITMAP INDEX idx_user_behavior_type_time ON demo.user_behavior (event_type, DATE(event_time));

-- 查看位图索引
SHOW INDEX FROM demo.user_behavior;

-- 使用位图索引查询
SELECT * FROM demo.user_behavior WHERE event_type = 'view';
SELECT * FROM demo.user_profile WHERE gender = 'male' AND city = 'Beijing';
```

### 3.4 倒排索引优化

为文本搜索列添加倒排索引，提高搜索性能：

```sql
-- 创建表时添加倒排索引
CREATE TABLE demo.user_behavior_inverted_index (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
DUPLICATE KEY(user_id, event_time)
PROPERTIES (
    "replication_num" = "3",
    "inverted_index_columns" = "page_url, referrer_url"  -- 为文本搜索列添加倒排索引
);

-- 为已有表添加倒排索引
ALTER TABLE demo.user_behavior SET ("inverted_index_columns" = "page_url, referrer_url");

-- 使用倒排索引进行全文搜索
SELECT * FROM demo.user_behavior WHERE page_url MATCH 'product';
SELECT * FROM demo.user_behavior WHERE referrer_url MATCH 'search';
```

## 4. 查询优化

### 4.1 查询重写优化

优化查询语句，提高执行效率：

```sql
-- 原始查询
SELECT 
    user_id,
    COUNT(*) AS event_count,
    SUM(stay_time) AS total_stay_time,
    AVG(stay_time) AS avg_stay_time
FROM demo.user_behavior 
WHERE event_time >= '2023-11-20 00:00:00' 
  AND event_time < '2023-11-21 00:00:00'
GROUP BY user_id
HAVING COUNT(*) > 10
ORDER BY event_count DESC;

-- 优化后的查询
-- 1. 使用分区裁剪
-- 2. 使用物化视图
-- 3. 减少数据传输量
SELECT 
    user_id,
    event_count,
    total_stay_time,
    total_stay_time / event_count AS avg_stay_time
FROM (
    SELECT 
        user_id,
        COUNT(*) AS event_count,
        SUM(stay_time) AS total_stay_time
    FROM demo.user_behavior PARTITION (p20231120)  -- 使用分区裁剪
    WHERE event_time >= '2023-11-20 00:00:00' 
      AND event_time < '2023-11-21 00:00:00'
    GROUP BY user_id
    HAVING COUNT(*) > 10
) t
ORDER BY event_count DESC;
```

### 4.2 JOIN优化

优化JOIN操作，提高连接查询性能：

```sql
-- 原始JOIN查询
SELECT 
    u.user_id,
    u.user_name,
    b.event_type,
    b.page_url,
    b.event_time
FROM demo.user_info u
JOIN demo.user_behavior b ON u.user_id = b.user_id
WHERE b.event_time >= '2023-11-20' AND b.event_time < '2023-11-21';

-- 优化后的JOIN查询
-- 1. 使用分区裁剪
-- 2. 使用索引
-- 3. 减少数据传输量
SELECT 
    u.user_id,
    u.user_name,
    b.event_type,
    b.page_url,
    b.event_time
FROM demo.user_info u
JOIN (
    SELECT 
        user_id,
        event_type,
        page_url,
        event_time
    FROM demo.user_behavior PARTITION (p20231120)  -- 使用分区裁剪
    WHERE event_time >= '2023-11-20' AND event_time < '2023-11-21'
) b ON u.user_id = b.user_id;

-- 使用COLLATE优化字符串比较
SELECT 
    u.user_id,
    u.user_name,
    b.event_type,
    b.page_url,
    b.event_time
FROM demo.user_info u
JOIN demo.user_behavior b ON u.user_id = b.user_id
WHERE b.event_time >= '2023-11-20' AND b.event_time < '2023-11-21'
  AND u.user_name COLLATE utf8_general_ci = 'John Doe';
```

### 4.3 聚合查询优化

优化聚合查询，提高分组计算性能：

```sql
-- 原始聚合查询
SELECT 
    DATE(event_time) AS event_date,
    event_type,
    COUNT(*) AS event_count,
    SUM(stay_time) AS total_stay_time,
    AVG(stay_time) AS avg_stay_time,
    COUNT(DISTINCT user_id) AS unique_users
FROM demo.user_behavior 
WHERE event_time >= '2023-11-20' AND event_time < '2023-11-21'
GROUP BY DATE(event_time), event_type
ORDER BY event_date, event_count DESC;

-- 优化后的聚合查询
-- 1. 使用物化视图
-- 2. 使用分区裁剪
-- 3. 减少计算量
SELECT 
    event_date,
    event_type,
    event_count,
    total_stay_time,
    total_stay_time / event_count AS avg_stay_time,
    unique_users
FROM demo.user_behavior_daily_stats  -- 使用物化视图
WHERE event_date = '2023-11-20'
ORDER BY event_count DESC;

-- 使用ROLLUP优化多级聚合
SELECT 
    DATE(event_time) AS event_date,
    event_type,
    COUNT(*) AS event_count
FROM demo.user_behavior 
WHERE event_time >= '2023-11-20' AND event_time < '2023-11-21'
GROUP BY ROLLUP(DATE(event_time), event_type)
ORDER BY event_date, event_type;
```

### 4.4 子查询优化

优化子查询，提高嵌套查询性能：

```sql
-- 原始子查询
SELECT 
    user_id,
    user_name
FROM demo.user_info 
WHERE user_id IN (
    SELECT DISTINCT user_id 
    FROM demo.user_behavior 
    WHERE event_time >= '2023-11-20' AND event_time < '2023-11-21'
      AND event_type = 'purchase'
);

-- 优化后的子查询
-- 1. 使用JOIN替代IN
-- 2. 使用EXISTS替代IN
-- 3. 使用分区裁剪
SELECT DISTINCT
    u.user_id,
    u.user_name
FROM demo.user_info u
JOIN demo.user_behavior b ON u.user_id = b.user_id
WHERE b.event_time >= '2023-11-20' AND b.event_time < '2023-11-21'
  AND b.event_type = 'purchase';

-- 使用EXISTS替代IN
SELECT 
    user_id,
    user_name
FROM demo.user_info u
WHERE EXISTS (
    SELECT 1 
    FROM demo.user_behavior b 
    WHERE b.user_id = u.user_id 
      AND b.event_time >= '2023-11-20' AND b.event_time < '2023-11-21'
      AND b.event_type = 'purchase'
);
```

## 5. 物化视图优化

### 5.1 物化视图设计

设计高效的物化视图，预计算常用查询：

```sql
-- 创建日统计物化视图
CREATE MATERIALIZED VIEW demo.user_behavior_daily_stats AS
SELECT 
    DATE(event_time) AS event_date,
    event_type,
    COUNT(*) AS event_count,
    SUM(stay_time) AS total_stay_time,
    AVG(stay_time) AS avg_stay_time,
    COUNT(DISTINCT user_id) AS unique_users,
    MAX(stay_time) AS max_stay_time,
    MIN(stay_time) AS min_stay_time
FROM demo.user_behavior 
GROUP BY DATE(event_time), event_type;

-- 创建小时统计物化视图
CREATE MATERIALIZED VIEW demo.user_behavior_hourly_stats AS
SELECT 
    DATE_FORMAT(event_time, '%Y-%m-%d %H:00:00') AS event_hour,
    event_type,
    COUNT(*) AS event_count,
    SUM(stay_time) AS total_stay_time,
    AVG(stay_time) AS avg_stay_time,
    COUNT(DISTINCT user_id) AS unique_users
FROM demo.user_behavior 
GROUP BY DATE_FORMAT(event_time, '%Y-%m-%d %H:00:00'), event_type;

-- 创建用户行为路径物化视图
CREATE MATERIALIZED VIEW demo.user_behavior_path_stats AS
SELECT 
    b1.user_id,
    b1.event_type AS event_type_1,
    b1.page_url AS page_url_1,
    b2.event_type AS event_type_2,
    b2.page_url AS page_url_2,
    COUNT(*) AS transition_count,
    AVG(TIMESTAMPDIFF(SECOND, b1.event_time, b2.event_time)) AS avg_time_diff
FROM (
    SELECT 
        user_id,
        event_time,
        event_type,
        page_url,
        ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY event_time) AS event_seq
    FROM demo.user_behavior 
) b1
JOIN (
    SELECT 
        user_id,
        event_time,
        event_type,
        page_url,
        ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY event_time) AS event_seq
    FROM demo.user_behavior 
) b2 ON b1.user_id = b2.user_id AND b1.event_seq + 1 = b2.event_seq
GROUP BY b1.user_id, b1.event_type, b1.page_url, b2.event_type, b2.page_url;
```

### 5.2 物化视图管理

有效管理物化视图，确保数据一致性：

```sql
-- 查看物化视图
SHOW MATERIALIZED VIEWS FROM demo;

-- 查看物化视图定义
SHOW CREATE MATERIALIZED VIEW demo.user_behavior_daily_stats;

-- 查看物化视图状态
SHOW MATERIALIZED VIEW STATUS FROM demo;

-- 刷新物化视图
REFRESH MATERIALIZED VIEW demo.user_behavior_daily_stats;

-- 删除物化视图
DROP MATERIALIZED VIEW demo.user_behavior_daily_stats;

-- 查看查询是否使用了物化视图
EXPLAIN 
SELECT 
    DATE(event_time) AS event_date,
    event_type,
    COUNT(*) AS event_count,
    SUM(stay_time) AS total_stay_time,
    AVG(stay_time) AS avg_stay_time,
    COUNT(DISTINCT user_id) AS unique_users
FROM demo.user_behavior 
WHERE event_time >= '2023-11-20' AND event_time < '2023-11-21'
GROUP BY DATE(event_time), event_type;
```

## 6. 参数调优

### 6.1 FE参数调优

优化FE节点参数，提高元数据管理和查询规划性能：

```sql
-- 查看FE参数
SHOW VARIABLES LIKE '%fe_%';

-- 调整FE内存参数
ADMIN SET FRONTEND CONFIG ('max_connection' = '4096');
ADMIN SET FRONTEND CONFIG ('query_timeout' = '300');
ADMIN SET FRONTEND CONFIG ('max_query_retry_time' = '2');

-- 调整FE查询规划参数
ADMIN SET FRONTEND CONFIG ('enable_vectorized_engine' = 'true');
ADMIN SET FRONTEND CONFIG ('enable_fallback_to_original_planner' = 'false');

-- 调整FE缓存参数
ADMIN SET FRONTEND CONFIG ('cache_last_version_interval_second' = '60');
ADMIN SET FRONTEND CONFIG ('storage_flood_stage_usage_percent' = '85');
ADMIN SET FRONTEND CONFIG ('storage_flood_stage_left_capacity_bytes' = '1073741824');
```

### 6.2 BE参数调优

优化BE节点参数，提高数据存储和查询执行性能：

```sql
-- 查看BE参数
SHOW VARIABLES LIKE '%be_%';

-- 调整BE内存参数
ADMIN SET BACKEND CONFIG ('write_buffer_size' = '104857600');
ADMIN SET BACKEND CONFIG ('storage_flood_stage_usage_percent' = '85');
ADMIN SET BACKEND CONFIG ('storage_flood_stage_left_capacity_bytes' = '1073741824');

-- 调整BE查询参数
ADMIN SET BACKEND CONFIG ('disable_storage_page_cache' = 'false');
ADMIN SET BACKEND CONFIG ('storage_page_cache_limit' = '20%');
ADMIN SET BACKEND CONFIG ('disable_storage_compaction' = 'false');

-- 调整BE并发参数
ADMIN SET BACKEND CONFIG ('max_compaction_threads' = '2');
ADMIN SET BACKEND CONFIG ('max_tablet_compaction_threads' = '4');
ADMIN SET BACKEND CONFIG ('max_download_threads_per_task' = '3');
```

### 6.3 查询参数调优

优化查询相关参数，提高查询执行效率：

```sql
-- 设置查询超时时间
SET SESSION query_timeout = 300;

-- 设置查询内存限制
SET SESSION exec_mem_limit = 8589934592;  -- 8GB

-- 启用并行查询
SET SESSION enable_pipeline_engine = 'true';
SET SESSION enable_pipeline_x_engine = 'true';

-- 设置批处理大小
SET SESSION batch_size = 4096;

-- 设置并行度
SET SESSION parallel_fragment_exec_instance_num = 8;
```

## 7. 资源管理优化

### 7.1 资源组优化

合理配置资源组，实现资源隔离和优先级管理：

```sql
-- 创建高优先级资源组
CREATE RESOURCE GROUP rg_high_priority
WITH (
    "cpu_core_limit" = "20",
    "mem_limit" = "30%",
    "soft_mem_limit" = "20%",
    "max_concurrency" = "100",
    "max_queue_size" = "1000",
    "query_timeout" = "300"
);

-- 创建低优先级资源组
CREATE RESOURCE GROUP rg_low_priority
WITH (
    "cpu_core_limit" = "5",
    "mem_limit" = "10%",
    "soft_mem_limit" = "5%",
    "max_concurrency" = "20",
    "max_queue_size" = "200",
    "query_timeout" = "1800"
);

-- 创建用户和角色
CREATE USER 'analyst' IDENTIFIED BY 'password';
CREATE USER 'etl_user' IDENTIFIED BY 'password';

CREATE ROLE 'analyst_role';
CREATE ROLE 'etl_role';

-- 关联资源组和角色
GRANT USAGE_PRIV ON RESOURCE GROUP rg_high_priority TO ROLE 'analyst_role';
GRANT USAGE_PRIV ON RESOURCE GROUP rg_low_priority TO ROLE 'etl_role';

-- 授予权限
GRANT 'analyst_role' TO 'analyst';
GRANT 'etl_role' TO 'etl_user';

-- 查看资源组使用情况
SELECT 
    rg.name,
    rg.cpu_core_limit,
    rg.mem_limit,
    rg.max_concurrency,
    rg.max_queue_size,
    COUNT(q.id) AS current_queries
FROM information_schema.resource_groups rg
LEFT JOIN information_schema.running_queries q ON rg.name = q.resource_group
GROUP BY rg.name, rg.cpu_core_limit, rg.mem_limit, rg.max_concurrency, rg.max_queue_size;
```

### 7.2 工作负载组优化

配置工作负载组，实现基于工作负载的资源管理：

```sql
-- 创建分析工作负载组
CREATE WORKLOAD GROUP wg_analytics
WITH (
    "cpu_core_limit" = "15",
    "mem_limit" = "25%",
    "max_concurrency" = "50",
    "max_queue_size" = "500"
);

-- 创建ETL工作负载组
CREATE WORKLOAD GROUP wg_etl
WITH (
    "cpu_core_limit" = "10",
    "mem_limit" = "15%",
    "max_concurrency" = "20",
    "max_queue_size" = "200"
);

-- 创建工作负载调度策略
CREATE WORKLOAD SCHEDULING POLICY ws_policy_analytics
WITH (
    "workload_group" = "wg_analytics",
    "match_condition" = "query_type='SELECT' AND user='analyst'",
    "priority" = "HIGH"
);

CREATE WORKLOAD SCHEDULING POLICY ws_policy_etl
WITH (
    "workload_group" = "wg_etl",
    "match_condition" = "query_type='INSERT' OR user='etl_user'",
    "priority" = "LOW"
);

-- 查看工作负载组
SHOW WORKLOAD GROUPS;

-- 查看工作负载调度策略
SHOW WORKLOAD SCHEDULING POLICIES;
```

## 8. 性能监控与诊断

### 8.1 查询性能监控

监控查询性能，识别性能瓶颈：

```sql
-- 查看当前运行查询
SHOW PROCESSLIST;

-- 查看查询统计信息
SHOW QUERY_STATS;

-- 查看慢查询
SHOW SLOW_QUERIES;

-- 查看查询历史
SELECT 
    query_id,
    user,
    db,
    query_time,
    scan_bytes,
    scan_rows,
    cpu_time_ms,
    mem_usage_bytes
FROM information_schema.query_log 
WHERE query_time > 1000  -- 查询时间大于1秒
ORDER BY query_time DESC
LIMIT 10;
```

### 8.2 表性能监控

监控表性能，优化表设计：

```sql
-- 查看表大小
SHOW TABLE STATUS FROM demo;

-- 查看表统计信息
SHOW DATA;

-- 查看分区信息
SHOW PARTITIONS FROM demo.user_behavior;

-- 查看 tablet 信息
SHOW TABLETS FROM demo.user_behavior;

-- 查看 tablet 统计信息
SELECT 
    tablet_id,
    replica_id,
    backend_id,
    version,
    data_size,
    row_count,
    state
FROM information_schema.tablets 
WHERE table_name = 'user_behavior'
ORDER BY data_size DESC
LIMIT 10;
```

### 8.3 集群性能监控

监控集群性能，优化集群配置：

```sql
-- 查看集群信息
SHOW BACKENDS;
SHOW FRONTENDS;

-- 查看集群负载
SELECT 
    backend_id,
    host,
    port,
    heartbeat_port,
    alive,
    disk_used,
    disk_total,
    mem_used,
    mem_total,
    cpu_used,
    num_running_queries,
    num_fragments
FROM information_schema.backends;

-- 查看集群统计信息
SELECT 
    cluster_name,
    cluster_id,
    replica_num,
    tablet_num,
    data_size,
    trash_size
FROM information_schema.clusters;
```

### 8.4 执行计划分析

分析查询执行计划，优化查询性能：

```sql
-- 查看执行计划
EXPLAIN SELECT 
    user_id,
    event_type,
    COUNT(*) AS event_count
FROM demo.user_behavior 
WHERE event_time >= '2023-11-20' AND event_time < '2023-11-21'
GROUP BY user_id, event_type;

-- 查看详细执行计划
EXPLAIN VERBOSE SELECT 
    user_id,
    event_type,
    COUNT(*) AS event_count
FROM demo.user_behavior 
WHERE event_time >= '2023-11-20' AND event_time < '2023-11-21'
GROUP BY user_id, event_type;

-- 查看执行计划图
EXPLAIN GRAPHICAL SELECT 
    user_id,
    event_type,
    COUNT(*) AS event_count
FROM demo.user_behavior 
WHERE event_time >= '2023-11-20' AND event_time < '2023-11-21'
GROUP BY user_id, event_type;
```

## 9. 实战案例

### 9.1 用户行为分析性能优化

```sql
-- 优化前的查询
SELECT 
    u.user_id,
    u.user_name,
    u.age,
    u.gender,
    u.city,
    COUNT(DISTINCT DATE(b.event_time)) AS active_days,
    COUNT(*) AS total_events,
    SUM(b.stay_time) AS total_stay_time,
    AVG(b.stay_time) AS avg_stay_time,
    MAX(b.event_time) AS last_event_time
FROM demo.user_info u
LEFT JOIN demo.user_behavior b ON u.user_id = b.user_id
WHERE b.event_time >= '2023-11-01' AND b.event_time < '2023-12-01'
GROUP BY u.user_id, u.user_name, u.age, u.gender, u.city
ORDER BY active_days DESC, total_events DESC
LIMIT 100;

-- 优化后的查询
-- 1. 使用物化视图
-- 2. 使用分区裁剪
-- 3. 优化JOIN顺序
-- 4. 减少数据传输量
WITH user_behavior_stats AS (
    SELECT 
        user_id,
        COUNT(DISTINCT DATE(event_time)) AS active_days,
        COUNT(*) AS total_events,
        SUM(stay_time) AS total_stay_time,
        AVG(stay_time) AS avg_stay_time,
        MAX(event_time) AS last_event_time
    FROM demo.user_behavior PARTITION (p20231101, p20231102, p20231103, p20231104, p20231105,
                                      p20231106, p20231107, p20231108, p20231109, p20231110,
                                      p20231111, p20231112, p20231113, p20231114, p20231115,
                                      p20231116, p20231117, p20231118, p20231119, p20231120,
                                      p20231121, p20231122, p20231123, p20231124, p20231125,
                                      p20231126, p20231127, p20231128, p20231129, p20231130)
    WHERE event_time >= '2023-11-01' AND event_time < '2023-12-01'
    GROUP BY user_id
)
SELECT 
    u.user_id,
    u.user_name,
    u.age,
    u.gender,
    u.city,
    COALESCE(s.active_days, 0) AS active_days,
    COALESCE(s.total_events, 0) AS total_events,
    COALESCE(s.total_stay_time, 0) AS total_stay_time,
    COALESCE(s.avg_stay_time, 0) AS avg_stay_time,
    s.last_event_time
FROM demo.user_info u
LEFT JOIN user_behavior_stats s ON u.user_id = s.user_id
ORDER BY active_days DESC, total_events DESC
LIMIT 100;
```

### 9.2 实时报表性能优化

```sql
-- 创建实时报表物化视图
CREATE MATERIALIZED VIEW demo.realtime_report AS
SELECT 
    DATE_FORMAT(event_time, '%Y-%m-%d %H:00:00') AS event_hour,
    event_type,
    COUNT(*) AS event_count,
    SUM(stay_time) AS total_stay_time,
    AVG(stay_time) AS avg_stay_time,
    COUNT(DISTINCT user_id) AS unique_users,
    COUNT(DISTINCT client_ip) AS unique_ips
FROM demo.user_behavior 
GROUP BY DATE_FORMAT(event_time, '%Y-%m-%d %H:00:00'), event_type;

-- 优化实时报表查询
SELECT 
    event_hour,
    event_type,
    event_count,
    total_stay_time,
    avg_stay_time,
    unique_users,
    unique_ips
FROM demo.realtime_report 
WHERE event_hour >= '2023-11-20 00:00:00' AND event_hour < '2023-11-21 00:00:00'
ORDER BY event_hour, event_count DESC;

-- 定时刷新物化视图
-- 可以通过脚本或调度系统定时执行
REFRESH MATERIALIZED VIEW demo.realtime_report;
```

### 9.3 大数据量查询优化

```sql
-- 优化前的大数据量查询
SELECT 
    DATE(event_time) AS event_date,
    page_url,
    COUNT(*) AS view_count,
    COUNT(DISTINCT user_id) AS unique_users,
    AVG(stay_time) AS avg_stay_time
FROM demo.user_behavior 
WHERE event_time >= '2023-01-01' AND event_time < '2023-12-01'
  AND event_type = 'view'
GROUP BY DATE(event_time), page_url
HAVING view_count > 100
ORDER BY view_count DESC;

-- 优化后的大数据量查询
-- 1. 使用分区裁剪
-- 2. 使用位图索引
-- 3. 分批处理
-- 4. 使用物化视图
-- 创建月度统计物化视图
CREATE MATERIALIZED VIEW demo.monthly_page_stats AS
SELECT 
    DATE_FORMAT(event_time, '%Y-%m-01') AS month,
    page_url,
    COUNT(*) AS view_count,
    COUNT(DISTINCT user_id) AS unique_users,
    AVG(stay_time) AS avg_stay_time
FROM demo.user_behavior 
WHERE event_type = 'view'
GROUP BY DATE_FORMAT(event_time, '%Y-%m-01'), page_url;

-- 优化后的查询
SELECT 
    month,
    page_url,
    view_count,
    unique_users,
    avg_stay_time
FROM demo.monthly_page_stats 
WHERE month >= '2023-01-01' AND month < '2023-12-01'
  AND view_count > 100
ORDER BY view_count DESC;
```

## 10. 常见问题与解决方案

### 10.1 查询性能问题

**问题**：查询执行缓慢

**解决方案**：
1. 分析执行计划，找出性能瓶颈
2. 优化WHERE条件，使用分区裁剪
3. 添加合适的索引
4. 使用物化视图预计算
5. 优化JOIN操作和子查询

### 10.2 内存不足问题

**问题**：查询过程中出现内存不足错误

**解决方案**：
1. 增加查询内存限制
2. 优化查询，减少内存使用
3. 使用分区裁剪减少数据量
4. 调整BE节点内存配置
5. 分批处理大数据量查询

### 10.3 磁盘空间问题

**问题**：磁盘空间不足导致性能下降

**解决方案**：
1. 清理过期数据
2. 调整数据保留策略
3. 优化压缩算法
4. 增加磁盘空间
5. 调整数据分布策略

### 10.4 高并发问题

**问题**：高并发查询导致性能下降

**解决方案**：
1. 使用资源组隔离不同类型查询
2. 优化查询，减少资源消耗
3. 增加BE节点数量
4. 调整并发参数
5. 使用查询队列管理

## 11. 本章小结

本章详细介绍了Doris性能优化的各个方面，包括表设计优化、索引优化、查询优化、物化视图优化、参数调优、资源管理优化和性能监控与诊断等内容，以及实战案例和常见问题解决方案。

### 11.1 关键要点

1. **表设计优化**：合理选择数据模型、分区策略和分桶策略
2. **索引优化**：根据查询模式选择合适的索引类型
3. **查询优化**：优化查询语句，使用分区裁剪和物化视图
4. **参数调优**：根据集群负载调整FE和BE参数
5. **资源管理**：使用资源组和工作负载组实现资源隔离
6. **性能监控**：使用工具监控和分析性能问题

### 11.2 最佳实践

1. 根据业务特点设计合理的表结构
2. 为常用查询创建合适的索引和物化视图
3. 定期监控和分析集群性能
4. 使用资源隔离确保关键查询的性能
5. 持续优化查询和表设计
6. 建立性能基准和监控体系

## 12. 延伸阅读

- [Doris官方文档-性能优化](https://doris.apache.org/docs/admin-manual/query-profile/)
- [Doris官方文档-表设计](https://doris.apache.org/docs/table-design/)
- [Doris官方文档-物化视图](https://doris.apache.org/docs/data-operate/materialized-view/)
- [Doris官方文档-资源管理](https://doris.apache.org/docs/admin-manual/resource-management/)

## 13. 实践练习

1. 设计一个高性能的用户行为分析表
2. 为表创建合适的索引，提高查询性能
3. 创建物化视图，优化常用聚合查询
4. 配置资源组，实现查询资源隔离
5. 分析查询执行计划，优化查询性能
6. 监控集群性能，识别和解决性能瓶颈
7. 设计一个完整的大数据量查询优化方案