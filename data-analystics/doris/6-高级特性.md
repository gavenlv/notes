# 第6章 Doris高级特性

## 学习目标

- 掌握Doris的分区和分桶机制
- 学会使用Doris的物化视图和索引优化
- 了解Doris的动态分区和自动分区功能
- 掌握Doris的资源隔离和查询队列管理
- 学会使用Doris的UDF和外部表功能

## 1. 分区与分桶

### 1.1 分区概述

分区是Doris中数据水平分割的重要机制，可以将大表按照一定规则分割成多个小的物理存储单元，提高查询性能和数据管理效率。

#### 1.1.1 分区类型

Doris支持以下几种分区类型：

1. **RANGE分区**：基于数值范围进行分区
2. **LIST分区**：基于离散值列表进行分区
3. **HASH分区**：基于哈希值进行分区
4. **复合分区**：结合多种分区方式

#### 1.1.2 分区优势

- 提高查询性能：通过分区裁剪减少扫描数据量
- 方便数据管理：可以独立管理各分区数据
- 提高并发性：不同分区可以并行处理
- 简化数据生命周期管理：可以轻松删除过期分区

### 1.2 RANGE分区

```sql
-- 创建RANGE分区表
CREATE TABLE demo.user_behavior_range (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
DUPLICATE KEY(user_id, event_time)
PARTITION BY RANGE(event_time) (
    PARTITION p20231101 VALUES LESS THAN ("2023-11-02"),
    PARTITION p20231102 VALUES LESS THAN ("2023-11-03"),
    PARTITION p20231103 VALUES LESS THAN ("2023-11-04"),
    PARTITION p20231104 VALUES LESS THAN ("2023-11-05"),
    PARTITION p20231105 VALUES LESS THAN ("2023-11-06")
)
PROPERTIES (
    "replication_num" = "3",
    "compression" = "LZ4"
);

-- 添加新分区
ALTER TABLE demo.user_behavior_range ADD PARTITION p20231106 VALUES LESS THAN ("2023-11-07");

-- 删除分区
ALTER TABLE demo.user_behavior_range DROP PARTITION p20231101;

-- 查看分区信息
SHOW PARTITIONS FROM demo.user_behavior_range;

-- 查询特定分区
SELECT * FROM demo.user_behavior_range PARTITION (p20231102) WHERE user_id = 1001;
```

### 1.3 LIST分区

```sql
-- 创建LIST分区表
CREATE TABLE demo.user_behavior_list (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
DUPLICATE KEY(user_id, event_time)
PARTITION BY LIST(event_type) (
    PARTITION p_view VALUES IN ("view"),
    PARTITION p_click VALUES IN ("click"),
    PARTITION p_purchase VALUES IN ("purchase"),
    PARTITION p_other VALUES IN ("favorite", "share", "comment")
)
PROPERTIES (
    "replication_num" = "3",
    "compression" = "LZ4"
);

-- 添加新分区
ALTER TABLE demo.user_behavior_list ADD PARTITION p_cart VALUES IN ("add_to_cart");

-- 查询特定分区
SELECT * FROM demo.user_behavior_list PARTITION (p_view) WHERE user_id = 1001;
```

### 1.4 分桶

分桶是在分区内部进一步将数据分割成更小的存储单元，基于哈希值将数据分布到不同的桶中。

```sql
-- 创建分桶表
CREATE TABLE demo.user_behavior_bucket (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
DUPLICATE KEY(user_id, event_time)
PARTITION BY RANGE(event_time) (
    PARTITION p20231101 VALUES LESS THAN ("2023-11-02"),
    PARTITION p20231102 VALUES LESS THAN ("2023-11-03"),
    PARTITION p20231103 VALUES LESS THAN ("2023-11-04")
)
DISTRIBUTED BY HASH(user_id) BUCKETS 32
PROPERTIES (
    "replication_num" = "3",
    "compression" = "LZ4"
);

-- 修改分桶数量
ALTER TABLE demo.user_behavior_bucket SET ("distribution_type" = "hash", "distribution_bucket" = "64");
```

### 1.5 动态分区

动态分区允许Doris自动创建和管理分区，减少手动维护工作。

```sql
-- 创建动态分区表
CREATE TABLE demo.user_behavior_dynamic (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
DUPLICATE KEY(user_id, event_time)
PARTITION BY RANGE(event_time) ()
DISTRIBUTED BY HASH(user_id) BUCKETS 32
PROPERTIES (
    "replication_num" = "3",
    "compression" = "LZ4",
    "dynamic_partition.enable" = "true",
    "dynamic_partition.time_unit" = "DAY",
    "dynamic_partition.start" = "-7",
    "dynamic_partition.end" = "7",
    "dynamic_partition.prefix" = "p",
    "dynamic_partition.buckets" = "32"
);

-- 查看动态分区属性
SHOW DYNAMIC PARTITION TABLES;

-- 修改动态分区属性
ALTER TABLE demo.user_behavior_dynamic SET (
    "dynamic_partition.enable" = "true",
    "dynamic_partition.time_unit" = "HOUR",
    "dynamic_partition.start" = "-24",
    "dynamic_partition.end" = "48"
);
```

## 2. 物化视图

### 2.1 物化视图概述

物化视图是Doris中用于预计算和存储查询结果的机制，可以显著提高查询性能。

#### 2.1.1 物化视图类型

1. **聚合物化视图**：预计算聚合结果
2. **投影物化视图**：预计算特定列
3. **连接物化视图**：预计算多表连接结果

#### 2.1.2 物化视图优势

- 提高查询性能：避免重复计算
- 简化复杂查询：将复杂查询转换为简单查询
- 减少网络传输：减少数据传输量
- 提高并发性：减少资源竞争

### 2.2 创建物化视图

```sql
-- 创建聚合物化视图
CREATE MATERIALIZED VIEW demo.user_behavior_daily_stats AS
SELECT 
    DATE(event_time) AS event_date,
    event_type,
    COUNT(*) AS event_count,
    SUM(stay_time) AS total_stay_time,
    AVG(stay_time) AS avg_stay_time,
    COUNT(DISTINCT user_id) AS unique_users
FROM demo.user_behavior 
GROUP BY DATE(event_time), event_type;

-- 创建投影物化视图
CREATE MATERIALIZED VIEW demo.user_behavior_projection AS
SELECT 
    user_id,
    event_time,
    event_type,
    stay_time
FROM demo.user_behavior;

-- 创建连接物化视图
CREATE MATERIALIZED VIEW demo.user_behavior_with_info AS
SELECT 
    b.user_id,
    b.event_time,
    b.event_type,
    b.page_url,
    b.stay_time,
    u.user_name,
    u.age,
    u.gender,
    u.city
FROM demo.user_behavior b
JOIN demo.user_info u ON b.user_id = u.user_id;
```

### 2.3 物化视图管理

```sql
-- 查看物化视图
SHOW MATERIALIZED VIEWS FROM demo;

-- 查看物化视图定义
SHOW CREATE MATERIALIZED VIEW demo.user_behavior_daily_stats;

-- 删除物化视图
DROP MATERIALIZED VIEW demo.user_behavior_daily_stats;

-- 刷新物化视图
REFRESH MATERIALIZED VIEW demo.user_behavior_daily_stats;

-- 查看物化视图状态
SHOW MATERIALIZED VIEW STATUS FROM demo;
```

### 2.4 物化视图查询重写

Doris支持自动查询重写，当查询与物化视图匹配时，会自动使用物化视图加速查询。

```sql
-- 原始查询
SELECT 
    DATE(event_time) AS event_date,
    event_type,
    COUNT(*) AS event_count,
    SUM(stay_time) AS total_stay_time,
    AVG(stay_time) AS avg_stay_time,
    COUNT(DISTINCT user_id) AS unique_users
FROM demo.user_behavior 
WHERE event_time >= '2023-11-20' AND event_time < '2023-11-21'
GROUP BY DATE(event_time), event_type;

-- 查看查询计划，确认是否使用了物化视图
EXPLAIN 
SELECT 
    DATE(event_time) AS event_date,
    event_type,
    COUNT(*) AS event_count,
    SUM(stay_time) AS total_stay_time,
    AVG(stay_time) AS avg_stay_time,
    COUNT(DISTINCT user_id) AS unique_users
FROM demo.user_behavior 
WHERE event_time >= '2023-11-20' AND event_time < '2023-11-21'
GROUP BY DATE(event_time), event_type;
```

## 3. 索引

### 3.1 索引概述

索引是Doris中用于加速数据查询的重要机制，可以显著提高查询性能。

#### 3.1.1 索引类型

1. **前缀索引**：默认索引，基于表的前36字节
2. **布隆过滤器索引**：用于快速判断值是否存在
3. **位图索引**：用于低基数列的快速过滤
4. **倒排索引**：用于全文搜索

### 3.2 前缀索引

```sql
-- 创建表时指定前缀索引
CREATE TABLE demo.user_behavior_prefix (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
DUPLICATE KEY(user_id, event_time)
PROPERTIES (
    "replication_num" = "3",
    "compression" = "LZ4",
    "prefix_index_length" = "64"
);

-- 查看前缀索引信息
SHOW INDEX FROM demo.user_behavior_prefix;
```

### 3.3 布隆过滤器索引

```sql
-- 创建表时添加布隆过滤器索引
CREATE TABLE demo.user_behavior_bloom (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
DUPLICATE KEY(user_id, event_time)
PROPERTIES (
    "replication_num" = "3",
    "compression" = "LZ4",
    "bloom_filter_columns" = "user_id, event_type"
);

-- 为已有表添加布隆过滤器索引
ALTER TABLE demo.user_behavior SET ("bloom_filter_columns" = "user_id, event_type");

-- 查看布隆过滤器索引信息
SHOW INDEX FROM demo.user_behavior_bloom;
```

### 3.4 位图索引

```sql
-- 创建位图索引
CREATE BITMAP INDEX idx_user_behavior_event_type ON demo.user_behavior (event_type);

-- 创建复合位图索引
CREATE BITMAP INDEX idx_user_behavior_type_time ON demo.user_behavior (event_type, DATE(event_time));

-- 查看位图索引
SHOW INDEX FROM demo.user_behavior;

-- 删除位图索引
DROP INDEX idx_user_behavior_event_type ON demo.user_behavior;
```

### 3.5 倒排索引

```sql
-- 创建表时添加倒排索引
CREATE TABLE demo.user_behavior_inverted (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
DUPLICATE KEY(user_id, event_time)
PROPERTIES (
    "replication_num" = "3",
    "compression" = "LZ4",
    "inverted_index_columns" = "page_url, referrer_url"
);

-- 为已有表添加倒排索引
ALTER TABLE demo.user_behavior SET ("inverted_index_columns" = "page_url, referrer_url");

-- 使用倒排索引进行全文搜索
SELECT * FROM demo.user_behavior WHERE page_url MATCH 'product';

-- 查看倒排索引信息
SHOW INDEX FROM demo.user_behavior_inverted;
```

## 4. 资源隔离

### 4.1 资源隔离概述

资源隔离是Doris中用于管理和控制集群资源使用的重要机制，可以确保不同查询或用户之间的资源隔离。

#### 4.1.1 资源隔离类型

1. **资源组**：基于用户或查询类型的资源隔离
2. **工作负载组**：基于工作负载的资源隔离
3. **资源标签**：基于物理资源的隔离

### 4.2 资源组

```sql
-- 创建资源组
CREATE RESOURCE GROUP rg_high_priority
WITH (
    "cpu_core_limit" = "10",
    "mem_limit" = "20%",
    "soft_mem_limit" = "10%",
    "max_concurrency" = "100",
    "max_queue_size" = "1000",
    "query_timeout" = "300"
);

CREATE RESOURCE GROUP rg_low_priority
WITH (
    "cpu_core_limit" = "2",
    "mem_limit" = "5%",
    "soft_mem_limit" = "2%",
    "max_concurrency" = "20",
    "max_queue_size" = "100",
    "query_timeout" = "3600"
);

-- 查看资源组
SHOW RESOURCE GROUPS;

-- 修改资源组
ALTER RESOURCE GROUP rg_high_priority SET ("cpu_core_limit" = "12", "mem_limit" = "25%");

-- 删除资源组
DROP RESOURCE GROUP rg_low_priority;

-- 将用户关联到资源组
CREATE USER 'high_priority_user' IDENTIFIED BY 'password' DEFAULT ROLE 'high_priority_role';
CREATE ROLE 'high_priority_role';
GRANT USAGE_PRIV ON RESOURCE GROUP rg_high_priority TO ROLE 'high_priority_role';
GRANT 'high_priority_role' TO 'high_priority_user';

-- 查询当前资源组
SELECT CURRENT_RESOURCE_GROUP();
```

### 4.3 工作负载组

```sql
-- 创建工作负载组
CREATE WORKLOAD GROUP wg_analytics
WITH (
    "cpu_core_limit" = "8",
    "mem_limit" = "15%",
    "max_concurrency" = "50",
    "max_queue_size" = "500"
);

-- 创建工作负载调度策略
CREATE WORKLOAD SCHEDULING POLICY ws_policy_analytics
WITH (
    "workload_group" = "wg_analytics",
    "match_condition" = "query_type='SELECT' AND user='analyst_user'",
    "priority" = "HIGH"
);

-- 查看工作负载组
SHOW WORKLOAD GROUPS;

-- 查看工作负载调度策略
SHOW WORKLOAD SCHEDULING POLICIES;

-- 删除工作负载组
DROP WORKLOAD GROUP wg_analytics;

-- 删除工作负载调度策略
DROP WORKLOAD SCHEDULING POLICY ws_policy_analytics;
```

### 4.4 资源标签

```sql
-- 创建资源标签
CREATE RESOURCE TAG tag_analytics WITH (
    "backend_num" = "3",
    "cpu_core_limit" = "16",
    "mem_limit" = "64G"
);

CREATE RESOURCE TAG tag_etl WITH (
    "backend_num" = "2",
    "cpu_core_limit" = "8",
    "mem_limit" = "32G"
);

-- 查看资源标签
SHOW RESOURCE TAGS;

-- 修改资源标签
ALTER RESOURCE TAG tag_analytics SET ("cpu_core_limit" = "20", "mem_limit" = "80G");

-- 删除资源标签
DROP RESOURCE TAG tag_etl;

-- 将BE节点关联到资源标签
ALTER SYSTEM MODIFY BACKEND "host1:port" SET ("tag" = "tag_analytics");
ALTER SYSTEM MODIFY BACKEND "host2:port" SET ("tag" = "tag_analytics");
ALTER SYSTEM MODIFY BACKEND "host3:port" SET ("tag" = "tag_etl");

-- 将表关联到资源标签
ALTER TABLE demo.user_behavior SET ("default_resource_group" = "rg_analytics");
```

## 5. 用户自定义函数(UDF)

### 5.1 UDF概述

UDF(User Defined Function)是Doris中用于扩展SQL功能的重要机制，允许用户自定义函数来处理特定业务逻辑。

#### 5.1.1 UDF类型

1. **标量UDF**：输入一行，输出一个值
2. **聚合UDF**：输入多行，输出一个值
3. **窗口UDF**：在窗口函数中使用
4. **表值UDF**：返回一个表

### 5.2 创建标量UDF

```java
// Java代码示例：计算字符串相似度的UDF
package com.example.doris.udf;

import org.apache.doris.udf.ScalarFunction;

public class StringSimilarity extends ScalarFunction {
    public StringSimilarity() {
    }
    
    // 计算两个字符串的相似度（0-1之间的浮点数）
    public Double evaluate(String str1, String str2) {
        if (str1 == null || str2 == null) {
            return 0.0;
        }
        
        int maxLength = Math.max(str1.length(), str2.length());
        if (maxLength == 0) {
            return 1.0;
        }
        
        return (maxLength - levenshteinDistance(str1, str2)) / (double) maxLength;
    }
    
    // 计算Levenshtein距离
    private int levenshteinDistance(String str1, String str2) {
        int[][] dp = new int[str1.length() + 1][str2.length() + 1];
        
        for (int i = 0; i <= str1.length(); i++) {
            dp[i][0] = i;
        }
        
        for (int j = 0; j <= str2.length(); j++) {
            dp[0][j] = j;
        }
        
        for (int i = 1; i <= str1.length(); i++) {
            for (int j = 1; j <= str2.length(); j++) {
                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = 1 + Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]);
                }
            }
        }
        
        return dp[str1.length()][str2.length()];
    }
}
```

```sql
-- 创建UDF
CREATE FUNCTION string_similarity(VARCHAR, VARCHAR) RETURNS DOUBLE
PROPERTIES (
    "symbol" = "com.example.doris.udf.StringSimilarity",
    "type" = "ScalarUDF",
    "file" = "http://example.com/udf/string-similarity.jar"
);

-- 使用UDF
SELECT 
    page_url,
    referrer_url,
    string_similarity(page_url, referrer_url) AS similarity_score
FROM demo.user_behavior 
WHERE referrer_url IS NOT NULL AND referrer_url != ''
ORDER BY similarity_score DESC
LIMIT 10;

-- 查看UDF
SHOW FUNCTIONS;

-- 删除UDF
DROP FUNCTION string_similarity;
```

### 5.3 创建聚合UDF

```java
// Java代码示例：计算加权平均的聚合UDF
package com.example.doris.udf;

import org.apache.doris.udf.AggregateFunction;

public class WeightedAverage extends AggregateFunction {
    private double sumWeightedValues;
    private double sumWeights;
    
    public WeightedAverage() {
        sumWeightedValues = 0.0;
        sumWeights = 0.0;
    }
    
    // 添加值和权重
    public void add(Double value, Double weight) {
        if (value != null && weight != null) {
            sumWeightedValues += value * weight;
            sumWeights += weight;
        }
    }
    
    // 合并中间结果
    public void merge(WeightedAverage other) {
        sumWeightedValues += other.sumWeightedValues;
        sumWeights += other.sumWeights;
    }
    
    // 获取最终结果
    public Double getValue() {
        if (sumWeights == 0) {
            return null;
        }
        return sumWeightedValues / sumWeights;
    }
    
    // 重置状态
    public void reset() {
        sumWeightedValues = 0.0;
        sumWeights = 0.0;
    }
}
```

```sql
-- 创建聚合UDF
CREATE AGGREGATE FUNCTION weighted_average(DOUBLE, DOUBLE) RETURNS DOUBLE
PROPERTIES (
    "symbol" = "com.example.doris.udf.WeightedAverage",
    "type" = "AggregateUDF",
    "file" = "http://example.com/udf/weighted-average.jar"
);

-- 使用聚合UDF
SELECT 
    event_type,
    weighted_average(stay_time, 1.0) AS avg_stay_time
FROM demo.user_behavior 
GROUP BY event_type;

-- 删除聚合UDF
DROP AGGREGATE FUNCTION weighted_average;
```

## 6. 外部表

### 6.1 外部表概述

外部表是Doris中用于访问外部数据源的重要机制，可以直接查询存储在HDFS、S3、MySQL等外部系统中的数据。

#### 6.1.1 外部表类型

1. **HDFS外部表**：访问HDFS上的数据
2. **S3外部表**：访问S3上的数据
3. **MySQL外部表**：访问MySQL数据库
4. **Elasticsearch外部表**：访问Elasticsearch
5. **Hive外部表**：访问Hive表

### 6.2 HDFS外部表

```sql
-- 创建HDFS外部表
CREATE EXTERNAL TABLE demo.user_behavior_hdfs (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
ENGINE=HADOOP
PROPERTIES (
    "resource" = "hdfs_resource",
    "table" = "user_behavior",
    "format" = "csv",
    "csv.delimiter" = ",",
    "csv.null_as" = "\\N"
);

-- 创建HDFS资源
CREATE RESOURCE hdfs_resource
PROPERTIES (
    "type" = "hdfs",
    "dfs.nameservices" = "my_ha_cluster",
    "dfs.ha.namenodes.my_ha_cluster" = "nn1,nn2",
    "dfs.namenode.rpc-address.my_ha_cluster.nn1" = "host1:8020",
    "dfs.namenode.rpc-address.my_ha_cluster.nn2" = "host2:8020",
    "dfs.client.failover.proxy.provider.my_ha_cluster" = "org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider"
);

-- 查询HDFS外部表
SELECT * FROM demo.user_behavior_hdfs WHERE user_id = 1001;

-- 删除HDFS外部表
DROP EXTERNAL TABLE demo.user_behavior_hdfs;

-- 删除HDFS资源
DROP RESOURCE hdfs_resource;
```

### 6.3 S3外部表

```sql
-- 创建S3外部表
CREATE EXTERNAL TABLE demo.user_behavior_s3 (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
ENGINE=HADOOP
PROPERTIES (
    "resource" = "s3_resource",
    "table" = "user_behavior",
    "format" = "parquet"
);

-- 创建S3资源
CREATE RESOURCE s3_resource
PROPERTIES (
    "type" = "s3",
    "s3.endpoint" = "s3.amazonaws.com",
    "s3.region" = "us-west-2",
    "s3.bucket" = "my-bucket",
    "s3.root.path" = "/data/user_behavior",
    "s3.access_key" = "your_access_key",
    "s3.secret_key" = "your_secret_key"
);

-- 查询S3外部表
SELECT * FROM demo.user_behavior_s3 WHERE user_id = 1001;
```

### 6.4 MySQL外部表

```sql
-- 创建MySQL外部表
CREATE EXTERNAL TABLE demo.user_behavior_mysql (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
ENGINE=MYSQL
PROPERTIES (
    "host" = "mysql_host",
    "port" = "3306",
    "user" = "mysql_user",
    "password" = "mysql_password",
    "database" = "demo",
    "table" = "user_behavior"
);

-- 查询MySQL外部表
SELECT * FROM demo.user_behavior_mysql WHERE user_id = 1001;

-- 关联查询本地表和MySQL外部表
SELECT 
    b.user_id,
    b.event_type,
    b.page_url,
    u.user_name,
    u.age,
    u.gender
FROM demo.user_behavior b
JOIN demo.user_behavior_mysql m ON b.user_id = m.user_id
JOIN demo.user_info u ON b.user_id = u.user_id
WHERE b.event_time >= '2023-11-20';
```

## 7. 实战案例

### 7.1 使用分区和分桶优化查询

```sql
-- 创建优化后的用户行为表
CREATE TABLE demo.user_behavior_optimized (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(255),
    stay_time INT,
    client_ip VARCHAR(50),
    referrer_url VARCHAR(255)
)
DUPLICATE KEY(user_id, event_time)
PARTITION BY RANGE(event_time) (
    PARTITION p20231120 VALUES LESS THAN ("2023-11-21"),
    PARTITION p20231121 VALUES LESS THAN ("2023-11-22"),
    PARTITION p20231122 VALUES LESS THAN ("2023-11-23"),
    PARTITION p20231123 VALUES LESS THAN ("2023-11-24"),
    PARTITION p20231124 VALUES LESS THAN ("2023-11-25"),
    PARTITION p20231125 VALUES LESS THAN ("2023-11-26")
)
DISTRIBUTED BY HASH(user_id) BUCKETS 32
PROPERTIES (
    "replication_num" = "3",
    "compression" = "LZ4",
    "bloom_filter_columns" = "user_id, event_type",
    "inverted_index_columns" = "page_url, referrer_url"
);

-- 创建物化视图
CREATE MATERIALIZED VIEW demo.user_behavior_hourly_stats AS
SELECT 
    DATE_FORMAT(event_time, '%Y-%m-%d %H:00:00') AS event_hour,
    event_type,
    COUNT(*) AS event_count,
    SUM(stay_time) AS total_stay_time,
    AVG(stay_time) AS avg_stay_time,
    COUNT(DISTINCT user_id) AS unique_users
FROM demo.user_behavior_optimized 
GROUP BY DATE_FORMAT(event_time, '%Y-%m-%d %H:00:00'), event_type;

-- 优化查询
SELECT 
    event_hour,
    event_type,
    event_count,
    total_stay_time,
    avg_stay_time,
    unique_users
FROM demo.user_behavior_hourly_stats 
WHERE event_hour >= '2023-11-20 00:00:00' AND event_hour < '2023-11-21 00:00:00'
ORDER BY event_hour, event_count DESC;
```

### 7.2 使用资源隔离管理查询

```sql
-- 创建资源组
CREATE RESOURCE GROUP rg_analytics
WITH (
    "cpu_core_limit" = "10",
    "mem_limit" = "20%",
    "soft_mem_limit" = "10%",
    "max_concurrency" = "50",
    "max_queue_size" = "500",
    "query_timeout" = "300"
);

CREATE RESOURCE GROUP rg_etl
WITH (
    "cpu_core_limit" = "5",
    "mem_limit" = "10%",
    "soft_mem_limit" = "5%",
    "max_concurrency" = "20",
    "max_queue_size" = "200",
    "query_timeout" = "1800"
);

-- 创建用户和角色
CREATE USER 'analyst' IDENTIFIED BY 'password';
CREATE USER 'etl_user' IDENTIFIED BY 'password';

CREATE ROLE 'analyst_role';
CREATE ROLE 'etl_role';

-- 关联资源组和角色
GRANT USAGE_PRIV ON RESOURCE GROUP rg_analytics TO ROLE 'analyst_role';
GRANT USAGE_PRIV ON RESOURCE GROUP rg_etl TO ROLE 'etl_role';

-- 授予权限
GRANT 'analyst_role' TO 'analyst';
GRANT 'etl_role' TO 'etl_user';

-- 查看资源组使用情况
SELECT 
    rg.name,
    rg.cpu_core_limit,
    rg.mem_limit,
    rg.max_concurrency,
    rg.max_queue_size,
    COUNT(q.id) AS current_queries
FROM information_schema.resource_groups rg
LEFT JOIN information_schema.running_queries q ON rg.name = q.resource_group
GROUP BY rg.name, rg.cpu_core_limit, rg.mem_limit, rg.max_concurrency, rg.max_queue_size;
```

### 7.3 使用UDF进行复杂分析

```java
// Java代码示例：用户行为模式分析UDF
package com.example.doris.udf;

import org.apache.doris.udf.ScalarFunction;

public class UserBehaviorPattern extends ScalarFunction {
    public UserBehaviorPattern() {
    }
    
    // 分析用户行为模式
    public String evaluate(String eventType1, String pageUrl1, String eventType2, String pageUrl2) {
        if (eventType1 == null || pageUrl1 == null || eventType2 == null || pageUrl2 == null) {
            return "unknown";
        }
        
        // 浏览商品页面后点击购买
        if ("view".equals(eventType1) && pageUrl1.contains("/product/") && 
            "click".equals(eventType2) && pageUrl2.contains("/buy")) {
            return "browse_to_buy";
        }
        
        // 浏览商品页面后加入购物车
        if ("view".equals(eventType1) && pageUrl1.contains("/product/") && 
            "click".equals(eventType2) && pageUrl2.contains("/cart")) {
            return "browse_to_cart";
        }
        
        // 浏览首页后浏览商品
        if ("view".equals(eventType1) && pageUrl1.equals("/home") && 
            "view".equals(eventType2) && pageUrl2.contains("/product/")) {
            return "home_to_product";
        }
        
        // 其他模式
        return "other";
    }
}
```

```sql
-- 创建UDF
CREATE FUNCTION user_behavior_pattern(VARCHAR, VARCHAR, VARCHAR, VARCHAR) RETURNS VARCHAR
PROPERTIES (
    "symbol" = "com.example.doris.udf.UserBehaviorPattern",
    "type" = "ScalarUDF",
    "file" = "http://example.com/udf/user-behavior-pattern.jar"
);

-- 使用UDF分析用户行为模式
WITH user_event_sequence AS (
    SELECT 
        user_id,
        event_time,
        event_type,
        page_url,
        ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY event_time) AS event_seq
    FROM demo.user_behavior 
    WHERE event_time >= '2023-11-20' AND event_time < '2023-11-21'
),
user_patterns AS (
    SELECT 
        e1.user_id,
        e1.event_type AS event_type_1,
        e1.page_url AS page_url_1,
        e2.event_type AS event_type_2,
        e2.page_url AS page_url_2,
        user_behavior_pattern(e1.event_type, e1.page_url, e2.event_type, e2.page_url) AS pattern
    FROM user_event_sequence e1
    JOIN user_event_sequence e2 ON e1.user_id = e2.user_id AND e1.event_seq + 1 = e2.event_seq
)
SELECT 
    pattern,
    COUNT(*) AS pattern_count,
    COUNT(DISTINCT user_id) AS unique_users,
    COUNT(*) * 100.0 / (SELECT COUNT(*) FROM user_patterns) AS percentage
FROM user_patterns
GROUP BY pattern
ORDER BY pattern_count DESC;
```

## 8. 常见问题与解决方案

### 8.1 分区相关问题

**问题**：分区过多导致性能下降

**解决方案**：
1. 合理设计分区策略，避免过多小分区
2. 使用动态分区自动管理分区
3. 定期合并或删除过期分区
4. 调整分区粒度，平衡查询性能和管理成本

### 8.2 物化视图相关问题

**问题**：物化视图更新失败或数据不一致

**解决方案**：
1. 检查物化视图定义是否正确
2. 确保基表数据完整性
3. 手动刷新物化视图
4. 查看物化视图更新日志，定位问题

### 8.3 索引相关问题

**问题**：索引未生效或查询性能未提升

**解决方案**：
1. 检查查询条件是否匹配索引
2. 分析执行计划，确认索引使用情况
3. 调整索引列或索引类型
4. 考虑使用组合索引优化查询

### 8.4 资源隔离相关问题

**问题**：资源隔离配置不生效

**解决方案**：
1. 检查资源组配置是否正确
2. 确认用户或查询是否正确关联到资源组
3. 监控资源使用情况，调整资源限制
4. 检查资源组优先级和调度策略

## 9. 本章小结

本章详细介绍了Doris的高级特性，包括分区与分桶、物化视图、索引、资源隔离、UDF和外部表等内容，以及这些特性的实战应用和常见问题解决方案。

### 9.1 关键要点

1. **分区与分桶**：掌握分区和分桶的设计原理和使用方法
2. **物化视图**：了解物化视图的创建、管理和查询重写
3. **索引**：掌握不同类型索引的适用场景和使用方法
4. **资源隔离**：学会使用资源组和工作负载组管理集群资源
5. **UDF**：了解如何创建和使用用户自定义函数
6. **外部表**：掌握如何访问外部数据源

### 9.2 最佳实践

1. 根据业务特点合理设计分区和分桶策略
2. 使用物化视图预计算常用聚合查询
3. 为常用查询条件创建合适的索引
4. 使用资源隔离确保关键查询的性能
5. 开发UDF扩展SQL功能，满足特定业务需求
6. 使用外部表整合多源数据，实现统一分析

## 10. 延伸阅读

- [Doris官方文档-分区和分桶](https://doris.apache.org/docs/table-design/partitioning/)
- [Doris官方文档-物化视图](https://doris.apache.org/docs/data-operate/materialized-view/)
- [Doris官方文档-索引](https://doris.apache.org/docs/table-design/index/)
- [Doris官方文档-资源隔离](https://doris.apache.org/docs/admin-manual/resource-management/)
- [Doris官方文档-UDF](https://doris.apache.org/docs/sql-manual/sql-functions/udf/)
- [Doris官方文档-外部表](https://doris.apache.org/docs/data-operate/external-table/)

## 11. 实践练习

1. 设计一个分区和分桶策略，优化用户行为表的查询性能
2. 创建物化视图，预计算常用的聚合查询
3. 为表创建合适的索引，提高查询性能
4. 配置资源隔离，确保不同类型查询的资源分配
5. 开发一个UDF，实现特定的业务逻辑
6. 创建外部表，访问HDFS或MySQL中的数据
7. 综合使用多种高级特性，设计一个高性能的数据分析方案