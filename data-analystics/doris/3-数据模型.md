# 第3章 Doris数据模型

## 学习目标

- 理解Doris的五种数据模型及其特点
- 掌握不同数据模型的适用场景
- 学会根据业务需求选择合适的数据模型
- 了解数据模型的底层存储原理
- 掌握数据模型的性能优化技巧

## 1. 数据模型概述

Apache Doris提供了多种数据模型，以满足不同业务场景的需求。这些数据模型在数据存储、查询性能、更新方式等方面各有特点。Doris支持以下五种主要数据模型：

1. **Duplicate模型（明细模型）**：保留所有明细数据，不做任何预聚合
2. **Aggregate模型（聚合模型）**：在导入时对数据进行预聚合
3. **Unique模型（唯一模型）**：保证Key的唯一性，支持更新操作
4. **Primary Key模型（主键模型）**：类似Unique模型，但更新语义更明确
5. **分区模型（分区表）**：基于时间或其他维度进行数据分区

### 1.1 数据模型选择原则

选择合适的数据模型需要考虑以下因素：

- **数据更新频率**：是否需要频繁更新数据
- **查询模式**：主要是明细查询还是聚合查询
- **数据量级**：数据规模和增长速度
- **性能要求**：查询延迟和吞吐量要求
- **存储成本**：存储空间和压缩率要求

## 2. Duplicate模型（明细模型）

### 2.1 模型特点

Duplicate模型是Doris中最简单的数据模型，它保留所有导入的明细数据，不做任何预聚合操作。主要特点包括：

- 保留所有明细数据，不做任何聚合
- 支持导入重复数据
- 查询时进行实时聚合计算
- 适合需要保留原始数据的场景

### 2.2 语法结构

```sql
CREATE TABLE [IF NOT EXISTS] [database.]table_name (
    column_definition_list,
    ...
) DUPLICATE KEY(key_column1, key_column2, ...)
[COMMENT "table comment"]
[DISTRIBUTED BY HASH(key_column1, ...) BUCKETS num]
[PROPERTIES ("key"="value", ...)];
```

### 2.3 使用示例

```sql
-- 创建用户行为明细表
CREATE TABLE IF NOT EXISTS demo.user_behavior (
    user_id BIGINT,
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(1024),
    referrer_url VARCHAR(1024),
    client_ip VARCHAR(50),
    user_agent VARCHAR(512),
    stay_time INT
) DUPLICATE KEY(user_id, event_time)
DISTRIBUTED BY HASH(user_id) BUCKETS 32
PROPERTIES (
    "compression"="LZ4",
    "enable_unique_key_merge_on_write"="true"
);

-- 插入数据
INSERT INTO demo.user_behavior VALUES
(1001, '2023-11-20 10:30:00', 'view', '/home', '', '192.168.1.1', 'Mozilla/5.0...', 30),
(1001, '2023-11-20 10:31:00', 'click', '/product/123', '/home', '192.168.1.1', 'Mozilla/5.0...', 5),
(1002, '2023-11-20 10:32:00', 'view', '/home', '', '192.168.1.2', 'Mozilla/5.0...', 15),
(1002, '2023-11-20 10:33:00', 'click', '/product/456', '/home', '192.168.1.2', 'Mozilla/5.0...', 8);

-- 查询数据
SELECT user_id, event_type, COUNT(*) AS event_count, AVG(stay_time) AS avg_stay_time
FROM demo.user_behavior
WHERE event_time >= '2023-11-20 10:00:00' AND event_time < '2023-11-20 11:00:00'
GROUP BY user_id, event_type
ORDER BY event_count DESC;
```

### 2.4 适用场景

- 需要保留原始明细数据的场景
- 数据更新频率较低的场景
- 需要灵活进行多维度分析的场景
- 数据量相对较小的场景

### 2.5 性能优化

- 合理设置分桶键和分桶数量
- 使用合适的压缩算法
- 对查询频繁的列创建物化视图
- 定期进行数据合并操作

## 3. Aggregate模型（聚合模型）

### 3.1 模型特点

Aggregate模型在数据导入时进行预聚合，可以显著提高查询性能。主要特点包括：

- 导入时对数据进行预聚合
- 支持多种聚合函数（SUM、MAX、MIN、REPLACE等）
- 查询性能高，适合报表类场景
- 存储空间占用相对较小

### 3.2 语法结构

```sql
CREATE TABLE [IF NOT EXISTS] [database.]table_name (
    column_definition_list,
    ...
) AGGREGATE KEY(key_column1, key_column2, ...)
[COMMENT "table comment"]
[DISTRIBUTED BY HASH(key_column1, ...) BUCKETS num]
[PROPERTIES ("key"="value", ...)];
```

### 3.3 聚合函数说明

| 聚合函数 | 说明 | 示例 |
|---------|------|------|
| SUM | 求和 | `total_sales BIGINT SUM DEFAULT '0'` |
| MAX | 最大值 | `max_price DECIMAL(18,2) MAX DEFAULT '0.00'` |
| MIN | 最小值 | `min_price DECIMAL(18,2) MIN DEFAULT '999999.99'` |
| REPLACE | 替换 | `latest_update DATETIME REPLACE` |
| REPLACE_IF_NOT_NULL | 非空替换 | `update_time DATETIME REPLACE_IF_NOT_NULL` |
| HLL_UNION | HLL聚合 | `user_ids HLL HLL_UNION` |
| BITMAP_UNION | BITMAP聚合 | `user_flags BITMAP BITMAP_UNION` |

### 3.4 使用示例

```sql
-- 创建用户日统计表
CREATE TABLE IF NOT EXISTS demo.user_daily_stats (
    user_id BIGINT,
    stat_date DATE,
    page_views BIGINT SUM DEFAULT '0',
    total_stay_time BIGINT SUM DEFAULT '0',
    max_stay_time INT MAX DEFAULT '0',
    last_active_time DATETIME REPLACE,
    active_pages BITMAP BITMAP_UNION
) AGGREGATE KEY(user_id, stat_date)
DISTRIBUTED BY HASH(user_id) BUCKETS 16
PROPERTIES (
    "compression"="LZ4",
    "enable_unique_key_merge_on_write"="true"
);

-- 插入数据
INSERT INTO demo.user_daily_stats VALUES
(1001, '2023-11-20', 10, 300, 60, '2023-11-20 18:30:00', bitmap_from_string('1,2,3')),
(1001, '2023-11-20', 5, 150, 45, '2023-11-20 19:15:00', bitmap_from_string('4,5')),
(1002, '2023-11-20', 8, 200, 50, '2023-11-20 17:45:00', bitmap_from_string('1,3,5')),
(1002, '2023-11-20', 3, 90, 30, '2023-11-20 18:20:00', bitmap_from_string('2,4'));

-- 查询数据
SELECT 
    user_id, 
    stat_date, 
    page_views, 
    total_stay_time,
    max_stay_time,
    last_active_time,
    bitmap_count(active_pages) AS unique_pages
FROM demo.user_daily_stats
WHERE stat_date = '2023-11-20'
ORDER BY page_views DESC;
```

### 3.5 适用场景

- 报表类应用
- 实时数据大屏
- 预聚合指标计算
- 数据分析中间表

### 3.6 性能优化

- 合理设计聚合键和聚合函数
- 避免使用过多聚合函数
- 定期进行数据合并操作
- 对高频查询创建物化视图

## 4. Unique模型（唯一模型）

### 4.1 模型特点

Unique模型保证Key的唯一性，支持更新操作，适合需要更新数据的场景。主要特点包括：

- 保证Key的唯一性
- 支持更新操作
- 支持DELETE操作
- 适合需要更新数据的场景

### 4.2 语法结构

```sql
CREATE TABLE [IF NOT EXISTS] [database.]table_name (
    column_definition_list,
    ...
) UNIQUE KEY(key_column1, key_column2, ...)
[COMMENT "table comment"]
[DISTRIBUTED BY HASH(key_column1, ...) BUCKETS num]
[PROPERTIES ("key"="value", ...)];
```

### 4.3 使用示例

```sql
-- 创建用户信息表
CREATE TABLE IF NOT EXISTS demo.user_info (
    user_id BIGINT,
    user_name VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    age INT,
    gender VARCHAR(10),
    city VARCHAR(50),
    register_date DATE,
    last_login_time DATETIME,
    update_time DATETIME
) UNIQUE KEY(user_id)
DISTRIBUTED BY HASH(user_id) BUCKETS 16
PROPERTIES (
    "compression"="LZ4",
    "enable_unique_key_merge_on_write"="true"
);

-- 插入数据
INSERT INTO demo.user_info VALUES
(1001, 'Alice', 'alice@example.com', '13800138001', 25, 'Female', 'Beijing', '2023-01-15', '2023-11-20 10:30:00', '2023-11-20 10:30:00'),
(1002, 'Bob', 'bob@example.com', '13800138002', 30, 'Male', 'Shanghai', '2023-02-20', '2023-11-21 14:45:00', '2023-11-21 14:45:00'),
(1003, 'Charlie', 'charlie@example.com', '13800138003', 35, 'Male', 'Guangzhou', '2023-03-10', '2023-11-22 09:15:00', '2023-11-22 09:15:00');

-- 更新数据
INSERT INTO demo.user_info VALUES
(1001, 'Alice', 'alice_new@example.com', '13800138001', 26, 'Female', 'Shanghai', '2023-01-15', '2023-11-23 16:20:00', '2023-11-23 16:20:00');

-- 查询数据
SELECT user_id, user_name, email, age, city, last_login_time
FROM demo.user_info
WHERE city IN ('Beijing', 'Shanghai')
ORDER BY last_login_time DESC;
```

### 4.4 更新机制

Unique模型支持两种更新机制：

1. **批量更新（Merge on Read）**：
   - 保留所有版本数据
   - 查询时进行合并
   - 适合更新频率较低的场景

2. **实时更新（Merge on Write）**：
   - 导入时立即合并数据
   - 查询性能更好
   - 适合更新频率较高的场景

通过设置`enable_unique_key_merge_on_write`属性来选择更新机制。

### 4.5 适用场景

- 用户画像数据
- 商品信息数据
- 配置信息数据
- 需要频繁更新的维度数据

### 4.6 性能优化

- 启用实时更新机制
- 合理设置分桶键和分桶数量
- 避免频繁小批量更新
- 定期进行数据合并操作

## 5. Primary Key模型（主键模型）

### 5.1 模型特点

Primary Key模型是Doris 1.2版本引入的新模型，与Unique模型类似，但更新语义更明确。主要特点包括：

- 明确的主键定义
- 支持更新操作
- 支持DELETE操作
- 更新语义更明确
- 性能更优

### 5.2 语法结构

```sql
CREATE TABLE [IF NOT EXISTS] [database.]table_name (
    column_definition_list,
    ...
) PRIMARY KEY(key_column1, key_column2, ...)
[COMMENT "table comment"]
[DISTRIBUTED BY HASH(key_column1, ...) BUCKETS num]
[PROPERTIES ("key"="value", ...)];
```

### 5.3 使用示例

```sql
-- 创建订单表
CREATE TABLE IF NOT EXISTS demo.orders (
    order_id BIGINT,
    user_id BIGINT,
    product_id BIGINT,
    quantity INT,
    price DECIMAL(18,2),
    total_amount DECIMAL(18,2),
    order_status VARCHAR(20),
    order_time DATETIME,
    update_time DATETIME
) PRIMARY KEY(order_id)
DISTRIBUTED BY HASH(order_id) BUCKETS 32
PROPERTIES (
    "compression"="LZ4",
    "enable_unique_key_merge_on_write"="true"
);

-- 插入数据
INSERT INTO demo.orders VALUES
(10001, 1001, 2001, 2, 99.99, 199.98, 'pending', '2023-11-20 10:30:00', '2023-11-20 10:30:00'),
(10002, 1002, 2002, 1, 199.99, 199.99, 'confirmed', '2023-11-20 11:45:00', '2023-11-20 11:45:00'),
(10003, 1003, 2003, 3, 49.99, 149.97, 'shipped', '2023-11-20 12:15:00', '2023-11-20 12:15:00');

-- 更新订单状态
INSERT INTO demo.orders VALUES
(10001, 1001, 2001, 2, 99.99, 199.98, 'confirmed', '2023-11-20 10:30:00', '2023-11-20 14:30:00');

-- 删除订单
DELETE FROM demo.orders WHERE order_id = 10003;

-- 查询数据
SELECT 
    o.order_id,
    o.user_id,
    o.product_id,
    o.quantity,
    o.price,
    o.total_amount,
    o.order_status,
    o.order_time,
    u.user_name
FROM demo.orders o
JOIN demo.user_info u ON o.user_id = u.user_id
WHERE o.order_time >= '2023-11-20 10:00:00' AND o.order_time < '2023-11-20 15:00:00'
ORDER BY o.order_time DESC;
```

### 5.4 适用场景

- 订单数据
- 交易数据
- 库存数据
- 需要明确主键的维度数据

### 5.5 性能优化

- 启用实时更新机制
- 合理设置分桶键和分桶数量
- 避免频繁小批量更新
- 定期进行数据合并操作

## 6. 分区模型（分区表）

### 6.1 模型特点

分区模型不是一种独立的数据模型，而是可以与上述任何模型结合使用的分区策略。主要特点包括：

- 基于时间或其他维度进行数据分区
- 提高查询性能
- 方便数据管理
- 支持动态分区

### 6.2 分区类型

Doris支持以下几种分区类型：

1. **Range分区**：基于数值范围进行分区
2. **List分区**：基于离散值列表进行分区
3. **Hash分区**：基于哈希值进行分区

### 6.3 使用示例

```sql
-- 创建按月分区的销售表
CREATE TABLE IF NOT EXISTS demo.monthly_sales (
    sale_date DATE,
    region VARCHAR(20),
    product_id BIGINT,
    product_name VARCHAR(100),
    sales_amount DECIMAL(18,2) SUM DEFAULT '0.00',
    sales_count BIGINT SUM DEFAULT '0'
) AGGREGATE KEY(sale_date, region, product_id, product_name)
DISTRIBUTED BY HASH(sale_date, region) BUCKETS 16
PROPERTIES (
    "compression"="LZ4",
    "dynamic_partition.enable"="true",
    "dynamic_partition.time_unit"="MONTH",
    "dynamic_partition.start"="-12",
    "dynamic_partition.end"="3",
    "dynamic_partition.prefix"="p",
    "dynamic_partition.buckets"="16"
)
PARTITION BY RANGE(sale_date) (
    PARTITION p202301 VALUES [('2023-01-01'), ('2023-02-01')),
    PARTITION p202302 VALUES [('2023-02-01'), ('2023-03-01')),
    PARTITION p202303 VALUES [('2023-03-01'), ('2023-04-01')),
    PARTITION p202304 VALUES [('2023-04-01'), ('2023-05-01')),
    PARTITION p202305 VALUES [('2023-05-01'), ('2023-06-01')),
    PARTITION p202306 VALUES [('2023-06-01'), ('2023-07-01')),
    PARTITION p202307 VALUES [('2023-07-01'), ('2023-08-01')),
    PARTITION p202308 VALUES [('2023-08-01'), ('2023-09-01')),
    PARTITION p202309 VALUES [('2023-09-01'), ('2023-10-01')),
    PARTITION p202310 VALUES [('2023-10-01'), ('2023-11-01')),
    PARTITION p202311 VALUES [('2023-11-01'), ('2023-12-01')),
    PARTITION p202312 VALUES [('2023-12-01'), ('2024-01-01'))
);

-- 插入数据
INSERT INTO demo.monthly_sales VALUES
('2023-11-20', 'North', 1001, 'Product A', 1200.50, 25),
('2023-11-20', 'South', 1002, 'Product B', 800.75, 18),
('2023-11-21', 'East', 1003, 'Product C', 1500.00, 30),
('2023-11-21', 'West', 1004, 'Product D', 950.25, 22),
('2023-11-22', 'North', 1005, 'Product E', 1100.80, 28);

-- 查询数据
SELECT 
    region,
    product_id,
    product_name,
    SUM(sales_amount) AS total_sales,
    SUM(sales_count) AS total_count
FROM demo.monthly_sales
WHERE sale_date >= '2023-11-01' AND sale_date < '2023-12-01'
GROUP BY region, product_id, product_name
ORDER BY total_sales DESC;
```

### 6.4 动态分区

Doris支持动态分区功能，可以自动创建和管理分区：

```sql
-- 创建动态分区表
CREATE TABLE IF NOT EXISTS demo.dynamic_partition_sales (
    sale_date DATE,
    region VARCHAR(20),
    product_id BIGINT,
    sales_amount DECIMAL(18,2) SUM DEFAULT '0.00',
    sales_count BIGINT SUM DEFAULT '0'
) AGGREGATE KEY(sale_date, region, product_id)
DISTRIBUTED BY HASH(sale_date, region) BUCKETS 16
PROPERTIES (
    "compression"="LZ4",
    "dynamic_partition.enable"="true",
    "dynamic_partition.time_unit"="DAY",
    "dynamic_partition.start"="-30",
    "dynamic_partition.end"="7",
    "dynamic_partition.prefix"="p",
    "dynamic_partition.buckets"="16"
);
```

### 6.5 分区管理

```sql
-- 查看分区信息
SHOW PARTITIONS FROM demo.monthly_sales;

-- 添加分区
ALTER TABLE demo.monthly_sales ADD PARTITION p202401 VALUES [('2024-01-01'), ('2024-02-01'));

-- 删除分区
ALTER TABLE demo.monthly_sales DROP PARTITION p202301;

-- 修改分区属性
ALTER TABLE demo.monthly_sales MODIFY PARTITION p202311 SET ("replication_num"="1");
```

### 6.6 适用场景

- 时间序列数据
- 日志数据
- 按地域或业务线划分的数据
- 需要按时间进行生命周期管理的数据

## 7. 数据模型对比

| 特性 | Duplicate | Aggregate | Unique | Primary Key |
|------|-----------|-----------|--------|-------------|
| 数据保留 | 保留所有明细 | 预聚合数据 | 最新版本数据 | 最新版本数据 |
| 更新支持 | 不支持 | 不支持 | 支持 | 支持 |
| 删除支持 | 不支持 | 不支持 | 支持 | 支持 |
| 查询性能 | 一般 | 高 | 高 | 高 |
| 存储空间 | 大 | 小 | 中等 | 中等 |
| 适用场景 | 明细查询 | 报表分析 | 维度更新 | 主键更新 |

## 8. 数据模型选择指南

### 8.1 根据业务场景选择

1. **日志分析场景**：选择Duplicate模型，保留所有明细数据
2. **报表分析场景**：选择Aggregate模型，提高查询性能
3. **用户画像场景**：选择Unique或Primary Key模型，支持更新
4. **订单交易场景**：选择Primary Key模型，明确主键语义
5. **时间序列场景**：结合分区模型，按时间分区

### 8.2 根据数据特征选择

1. **数据更新频率**：
   - 低更新频率：Duplicate或Aggregate模型
   - 高更新频率：Unique或Primary Key模型

2. **查询模式**：
   - 明细查询：Duplicate模型
   - 聚合查询：Aggregate模型
   - 点查：Unique或Primary Key模型

3. **数据量级**：
   - 小数据量：Duplicate模型
   - 大数据量：Aggregate、Unique或Primary Key模型

## 9. 性能优化最佳实践

### 9.1 分桶优化

1. **选择合适的分桶键**：
   - 选择高基数的列作为分桶键
   - 避免使用低基数的列作为分桶键
   - 考虑查询模式，将经常一起查询的列放在同一个分桶

2. **设置合理的分桶数量**：
   - 分桶数量建议为BE节点数量的整数倍
   - 每个分桶大小建议在100MB-1GB之间
   - 避免过多或过少的分桶

### 9.2 压缩优化

1. **选择合适的压缩算法**：
   - LZ4：压缩速度最快，适合实时查询
   - ZSTD：压缩率最高，适合归档数据
   - SNAPPY：平衡压缩速度和压缩率

2. **设置合理的压缩级别**：
   - 实时查询场景：选择低压缩级别
   - 归档存储场景：选择高压缩级别

### 9.3 物化视图优化

1. **创建合适的物化视图**：
   - 针对高频查询创建物化视图
   - 避免创建过多物化视图
   - 定期维护物化视图

2. **选择合适的聚合函数**：
   - 使用SUM、COUNT等简单聚合函数
   - 避免使用复杂计算函数

### 9.4 数据导入优化

1. **批量导入**：
   - 避免频繁小批量导入
   - 使用批量导入方式
   - 合理设置导入批次大小

2. **导入频率控制**：
   - 控制导入频率，避免对查询造成影响
   - 在业务低峰期进行大批量导入

## 10. 实战案例

### 10.1 电商订单分析系统

```sql
-- 订单明细表（Duplicate模型）
CREATE TABLE IF NOT EXISTS ecommerce.order_detail (
    order_id BIGINT,
    user_id BIGINT,
    product_id BIGINT,
    product_name VARCHAR(200),
    product_category VARCHAR(50),
    quantity INT,
    price DECIMAL(18,2),
    discount DECIMAL(18,2),
    order_time DATETIME,
    payment_time DATETIME,
    shipping_time DATETIME,
    receive_time DATETIME
) DUPLICATE KEY(order_id, product_id)
DISTRIBUTED BY HASH(order_id) BUCKETS 32
PARTITION BY RANGE(order_time) (
    PARTITION p202311 VALUES [('2023-11-01'), ('2023-12-01')),
    PARTITION p202312 VALUES [('2023-12-01'), ('2024-01-01'))
);

-- 用户信息表（Primary Key模型）
CREATE TABLE IF NOT EXISTS ecommerce.user_info (
    user_id BIGINT,
    user_name VARCHAR(50),
    gender VARCHAR(10),
    age INT,
    city VARCHAR(50),
    register_date DATE,
    last_login_time DATETIME,
    total_orders INT DEFAULT 0,
    total_amount DECIMAL(18,2) DEFAULT 0.00,
    update_time DATETIME
) PRIMARY KEY(user_id)
DISTRIBUTED BY HASH(user_id) BUCKETS 16;

-- 商品信息表（Primary Key模型）
CREATE TABLE IF NOT EXISTS ecommerce.product_info (
    product_id BIGINT,
    product_name VARCHAR(200),
    product_category VARCHAR(50),
    brand VARCHAR(100),
    price DECIMAL(18,2),
    stock INT,
    status VARCHAR(20),
    create_time DATETIME,
    update_time DATETIME
) PRIMARY KEY(product_id)
DISTRIBUTED BY HASH(product_id) BUCKETS 16;

-- 用户日统计表（Aggregate模型）
CREATE TABLE IF NOT EXISTS ecommerce.user_daily_stats (
    user_id BIGINT,
    stat_date DATE,
    order_count BIGINT SUM DEFAULT '0',
    total_amount DECIMAL(18,2) SUM DEFAULT '0.00',
    avg_order_amount DECIMAL(18,2) REPLACE DEFAULT '0.00',
    max_order_amount DECIMAL(18,2) MAX DEFAULT '0.00',
    last_order_time DATETIME REPLACE,
    active_categories BITMAP BITMAP_UNION
) AGGREGATE KEY(user_id, stat_date)
DISTRIBUTED BY HASH(user_id) BUCKETS 16
PROPERTIES (
    "compression"="LZ4",
    "enable_unique_key_merge_on_write"="true"
);

-- 商品日统计表（Aggregate模型）
CREATE TABLE IF NOT EXISTS ecommerce.product_daily_stats (
    product_id BIGINT,
    stat_date DATE,
    view_count BIGINT SUM DEFAULT '0',
    order_count BIGINT SUM DEFAULT '0',
    sales_quantity BIGINT SUM DEFAULT '0',
    sales_amount DECIMAL(18,2) SUM DEFAULT '0.00',
    avg_price DECIMAL(18,2) REPLACE DEFAULT '0.00',
    last_order_time DATETIME REPLACE
) AGGREGATE KEY(product_id, stat_date)
DISTRIBUTED BY HASH(product_id) BUCKETS 16
PROPERTIES (
    "compression"="LZ4",
    "enable_unique_key_merge_on_write"="true"
);
```

### 10.2 实时数据分析系统

```sql
-- 用户行为日志表（Duplicate模型）
CREATE TABLE IF NOT EXISTS realtime.user_behavior (
    user_id BIGINT,
    session_id VARCHAR(100),
    event_time DATETIME,
    event_type VARCHAR(20),
    page_url VARCHAR(1024),
    referrer_url VARCHAR(1024),
    client_ip VARCHAR(50),
    user_agent VARCHAR(512),
    stay_time INT,
    properties VARCHAR(2048)
) DUPLICATE KEY(user_id, event_time)
DISTRIBUTED BY HASH(user_id) BUCKETS 32
PROPERTIES (
    "compression"="LZ4",
    "dynamic_partition.enable"="true",
    "dynamic_partition.time_unit"="DAY",
    "dynamic_partition.start"="-7",
    "dynamic_partition.end"="3",
    "dynamic_partition.prefix"="p",
    "dynamic_partition.buckets"="32"
);

-- 实时用户状态表（Primary Key模型）
CREATE TABLE IF NOT EXISTS realtime.user_status (
    user_id BIGINT,
    current_session_id VARCHAR(100),
    current_page_url VARCHAR(1024),
    session_start_time DATETIME,
    last_active_time DATETIME,
    total_session_time INT DEFAULT 0,
    page_view_count INT DEFAULT 0,
    bounce_rate DECIMAL(5,2) DEFAULT 0.00,
    update_time DATETIME
) PRIMARY KEY(user_id)
DISTRIBUTED BY HASH(user_id) BUCKETS 16
PROPERTIES (
    "compression"="LZ4",
    "enable_unique_key_merge_on_write"="true"
);

-- 页面实时统计表（Aggregate模型）
CREATE TABLE IF NOT EXISTS realtime.page_stats (
    page_url VARCHAR(1024),
    stat_time DATETIME,
    view_count BIGINT SUM DEFAULT '0',
    unique_users BIGINT REPLACE DEFAULT '0',
    avg_stay_time DECIMAL(10,2) REPLACE DEFAULT '0.00',
    bounce_rate DECIMAL(5,2) REPLACE DEFAULT '0.00',
    update_time DATETIME REPLACE
) AGGREGATE KEY(page_url, stat_time)
DISTRIBUTED BY HASH(page_url) BUCKETS 16
PROPERTIES (
    "compression"="LZ4",
    "enable_unique_key_merge_on_write"="true"
);
```

## 11. 常见问题与解决方案

### 11.1 如何选择合适的数据模型？

根据业务场景和数据特征选择：
- 需要保留明细数据：选择Duplicate模型
- 需要预聚合提高性能：选择Aggregate模型
- 需要更新数据：选择Unique或Primary Key模型
- 需要明确主键语义：选择Primary Key模型

### 11.2 如何优化查询性能？

1. 合理设计分桶键和分桶数量
2. 选择合适的压缩算法
3. 创建物化视图
4. 使用分区表
5. 避免全表扫描

### 11.3 如何处理数据倾斜？

1. 选择高基数的列作为分桶键
2. 使用多列组合作为分桶键
3. 增加分桶数量
4. 使用随机分桶

### 11.4 如何处理热点数据？

1. 增加分桶数量
2. 使用多级分桶
3. 将热点数据分散到多个分桶
4. 使用缓存

## 12. 本章小结

本章详细介绍了Doris的五种数据模型及其特点、适用场景和性能优化方法。通过合理选择数据模型，可以显著提高系统性能和降低存储成本。

### 12.1 关键要点

1. **Duplicate模型**：保留所有明细数据，适合需要原始数据的场景
2. **Aggregate模型**：预聚合数据，提高查询性能，适合报表类场景
3. **Unique模型**：保证Key唯一性，支持更新，适合维度数据
4. **Primary Key模型**：明确主键语义，支持更新，适合交易数据
5. **分区模型**：提高查询性能，方便数据管理

### 12.2 最佳实践

1. 根据业务场景选择合适的数据模型
2. 合理设计分桶键和分桶数量
3. 选择合适的压缩算法
4. 创建物化视图提高查询性能
5. 使用分区表管理大数据量

## 13. 延伸阅读

- [Doris官方文档-数据模型](https://doris.apache.org/docs/data-table/data-model/)
- [Doris数据模型设计最佳实践](https://doris.apache.org/docs/data-table/best-practice/)
- [Doris分区分桶设计](https://doris.apache.org/docs/data-table/partitioning-and-bucketing/)

## 14. 实践练习

1. 创建一个Duplicate模型表，插入重复数据，观察查询结果
2. 创建一个Aggregate模型表，使用不同的聚合函数，观察聚合效果
3. 创建一个Unique模型表，更新数据，观察更新效果
4. 创建一个Primary Key模型表，进行更新和删除操作
5. 创建一个分区表，添加和删除分区，观察分区管理效果
6. 设计一个电商系统的数据模型，包含订单、用户、商品等表
7. 设计一个实时分析系统的数据模型，包含用户行为、页面统计等表
8. 对创建的表进行性能优化，包括分桶、压缩、物化视图等