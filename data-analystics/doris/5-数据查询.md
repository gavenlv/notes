# 第5章 Doris数据查询

## 学习目标

- 掌握Doris的基本查询语法和高级查询功能
- 学会使用Doris的聚合函数、窗口函数和分析函数
- 了解Doris的查询优化技巧和执行计划分析
- 掌握Doris的物化视图和查询缓存机制
- 学会设计高效的查询语句和分析复杂业务场景

## 1. 查询语法概述

Apache Doris兼容MySQL协议和SQL语法，支持标准SQL的大部分功能，同时提供了许多扩展功能，以满足大数据分析的需求。

### 1.1 基本查询结构

```sql
SELECT [DISTINCT] select_expr [, select_expr ...]
FROM table_reference [, table_reference ...]
[WHERE where_condition]
[GROUP BY {col_name | expr | position} [ASC | DESC], ...]
[HAVING where_condition]
[ORDER BY {col_name | expr | position} [ASC | DESC], ...]
[LIMIT {[offset,] row_count | row_count OFFSET offset}]
[INTO OUTFILE 'file_name']
```

### 1.2 查询类型

Doris支持以下几种查询类型：

1. **基本查询**：简单的SELECT查询
2. **聚合查询**：使用GROUP BY和聚合函数
3. **连接查询**：多表连接查询
4. **子查询**：嵌套查询
5. **窗口函数查询**：使用窗口函数的分析查询
6. **CTE查询**：使用WITH子句的公共表表达式查询

## 2. 基本查询

### 2.1 SELECT语句

```sql
-- 基本查询
SELECT * FROM demo.user_behavior;

-- 指定列查询
SELECT user_id, event_type, page_url FROM demo.user_behavior;

-- 使用别名
SELECT 
    user_id AS uid,
    event_type AS type,
    page_url AS url
FROM demo.user_behavior;

-- 去重查询
SELECT DISTINCT user_id, event_type FROM demo.user_behavior;

-- 限制返回行数
SELECT * FROM demo.user_behavior LIMIT 10;

-- 分页查询
SELECT * FROM demo.user_behavior LIMIT 10 OFFSET 20;
```

### 2.2 WHERE条件

```sql
-- 基本条件
SELECT * FROM demo.user_behavior WHERE user_id = 1001;

-- 比较条件
SELECT * FROM demo.user_behavior WHERE stay_time > 30;

-- 逻辑条件
SELECT * FROM demo.user_behavior 
WHERE user_id = 1001 AND event_type = 'view';

SELECT * FROM demo.user_behavior 
WHERE event_type = 'view' OR event_type = 'click';

-- 范围条件
SELECT * FROM demo.user_behavior 
WHERE stay_time BETWEEN 10 AND 60;

-- 列表条件
SELECT * FROM demo.user_behavior 
WHERE event_type IN ('view', 'click', 'purchase');

-- 模糊条件
SELECT * FROM demo.user_behavior 
WHERE page_url LIKE '/product/%';

-- 空值条件
SELECT * FROM demo.user_behavior 
WHERE referrer_url IS NULL OR referrer_url = '';

-- 时间条件
SELECT * FROM demo.user_behavior 
WHERE event_time >= '2023-11-20 10:00:00' 
  AND event_time < '2023-11-20 11:00:00';
```

### 2.3 ORDER BY排序

```sql
-- 单列排序
SELECT * FROM demo.user_behavior ORDER BY event_time;

-- 多列排序
SELECT * FROM demo.user_behavior 
ORDER BY user_id, event_time DESC;

-- 按表达式排序
SELECT 
    user_id, 
    event_type, 
    stay_time
FROM demo.user_behavior 
ORDER BY 
    CASE WHEN event_type = 'view' THEN 1
         WHEN event_type = 'click' THEN 2
         ELSE 3 END,
    stay_time DESC;
```

## 3. 聚合查询

### 3.1 聚合函数

Doris支持以下聚合函数：

| 函数 | 说明 | 示例 |
|------|------|------|
| COUNT | 计数 | COUNT(*), COUNT(column) |
| SUM | 求和 | SUM(column) |
| AVG | 平均值 | AVG(column) |
| MAX | 最大值 | MAX(column) |
| MIN | 最小值 | MIN(column) |
| STDDEV | 标准差 | STDDEV(column) |
| VARIANCE | 方差 | VARIANCE(column) |
| GROUP_CONCAT | 连接字符串 | GROUP_CONCAT(column) |
| BITMAP_UNION | BITMAP并集 | BITMAP_UNION(column) |
| HLL_UNION_AGG | HLL并集 | HLL_UNION_AGG(column) |

### 3.2 GROUP BY分组

```sql
-- 基本分组
SELECT 
    event_type, 
    COUNT(*) AS event_count
FROM demo.user_behavior 
GROUP BY event_type;

-- 多列分组
SELECT 
    user_id, 
    event_type, 
    COUNT(*) AS event_count,
    AVG(stay_time) AS avg_stay_time
FROM demo.user_behavior 
GROUP BY user_id, event_type;

-- 分组后过滤
SELECT 
    user_id, 
    COUNT(*) AS event_count
FROM demo.user_behavior 
GROUP BY user_id 
HAVING COUNT(*) > 10;

-- 按时间分组
SELECT 
    DATE(event_time) AS event_date,
    event_type,
    COUNT(*) AS event_count
FROM demo.user_behavior 
WHERE event_time >= '2023-11-01' AND event_time < '2023-12-01'
GROUP BY DATE(event_time), event_type
ORDER BY event_date, event_count DESC;

-- 按时间窗口分组
SELECT 
    DATE_FORMAT(event_time, '%Y-%m-%d %H:00:00') AS hour,
    COUNT(*) AS event_count
FROM demo.user_behavior 
WHERE event_time >= '2023-11-20 00:00:00' AND event_time < '2023-11-21 00:00:00'
GROUP BY DATE_FORMAT(event_time, '%Y-%m-%d %H:00:00')
ORDER BY hour;
```

### 3.3 高级聚合函数

```sql
-- 窗口函数
SELECT 
    user_id,
    event_time,
    event_type,
    COUNT(*) OVER (PARTITION BY user_id ORDER BY event_time) AS user_event_seq,
    SUM(stay_time) OVER (PARTITION BY user_id ORDER BY event_time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_stay_time
FROM demo.user_behavior;

-- ROLLUP
SELECT 
    DATE(event_time) AS event_date,
    event_type,
    COUNT(*) AS event_count
FROM demo.user_behavior 
WHERE event_time >= '2023-11-20 00:00:00' AND event_time < '2023-11-21 00:00:00'
GROUP BY ROLLUP(DATE(event_time), event_type)
ORDER BY event_date, event_type;

-- CUBE
SELECT 
    DATE(event_time) AS event_date,
    event_type,
    client_ip,
    COUNT(*) AS event_count
FROM demo.user_behavior 
WHERE event_time >= '2023-11-20 00:00:00' AND event_time < '2023-11-21 00:00:00'
GROUP BY CUBE(DATE(event_time), event_type, client_ip)
ORDER BY event_date, event_type, client_ip;

-- GROUPING SETS
SELECT 
    DATE(event_time) AS event_date,
    event_type,
    client_ip,
    COUNT(*) AS event_count
FROM demo.user_behavior 
WHERE event_time >= '2023-11-20 00:00:00' AND event_time < '2023-11-21 00:00:00'
GROUP BY GROUPING SETS (
    (DATE(event_time), event_type, client_ip),
    (DATE(event_time), event_type),
    (DATE(event_time), client_ip),
    (event_type, client_ip),
    (DATE(event_time)),
    (event_type),
    (client_ip),
    ()
)
ORDER BY event_date, event_type, client_ip;
```

## 4. 连接查询

### 4.1 内连接

```sql
-- 基本内连接
SELECT 
    u.user_id,
    u.user_name,
    b.event_type,
    b.page_url,
    b.event_time
FROM demo.user_info u
JOIN demo.user_behavior b ON u.user_id = b.user_id;

-- 多表内连接
SELECT 
    u.user_id,
    u.user_name,
    b.event_type,
    b.page_url,
    b.event_time,
    p.product_name,
    p.price
FROM demo.user_info u
JOIN demo.user_behavior b ON u.user_id = b.user_id
LEFT JOIN demo.product_info p ON b.page_url LIKE CONCAT('%/product/', p.product_id)
WHERE b.event_type = 'click' AND b.page_url LIKE '/product/%';
```

### 4.2 外连接

```sql
-- 左外连接
SELECT 
    u.user_id,
    u.user_name,
    COUNT(b.event_type) AS event_count
FROM demo.user_info u
LEFT JOIN demo.user_behavior b ON u.user_id = b.user_id
GROUP BY u.user_id, u.user_name;

-- 右外连接
SELECT 
    b.user_id,
    b.event_type,
    u.user_name
FROM demo.user_behavior b
RIGHT JOIN demo.user_info u ON b.user_id = u.user_id;

-- 全外连接（Doris不支持FULL OUTER JOIN，可以使用UNION模拟）
SELECT u.user_id, u.user_name, b.event_type
FROM demo.user_info u
LEFT JOIN demo.user_behavior b ON u.user_id = b.user_id
UNION ALL
SELECT u.user_id, u.user_name, b.event_type
FROM demo.user_info u
RIGHT JOIN demo.user_behavior b ON u.user_id = b.user_id
WHERE u.user_id IS NULL;
```

### 4.3 自连接

```sql
-- 用户行为序列分析
SELECT 
    b1.user_id,
    b1.event_time AS first_event_time,
    b1.page_url AS first_page,
    b2.event_time AS second_event_time,
    b2.page_url AS second_page,
    TIMESTAMPDIFF(SECOND, b1.event_time, b2.event_time) AS time_diff
FROM demo.user_behavior b1
JOIN demo.user_behavior b2 ON b1.user_id = b2.user_id 
  AND b1.event_time < b2.event_time
WHERE b1.event_type = 'view' 
  AND b2.event_type = 'click'
  AND TIMESTAMPDIFF(SECOND, b1.event_time, b2.event_time) <= 300
ORDER BY b1.user_id, b1.event_time;
```

## 5. 子查询

### 5.1 标量子查询

```sql
-- 查询用户平均停留时间大于总体平均的用户
SELECT 
    user_id,
    AVG(stay_time) AS avg_stay_time
FROM demo.user_behavior 
GROUP BY user_id
HAVING AVG(stay_time) > (
    SELECT AVG(stay_time) 
    FROM demo.user_behavior
);

-- 查询每个用户最新一次行为
SELECT 
    b.user_id,
    b.event_type,
    b.page_url,
    b.event_time
FROM demo.user_behavior b
WHERE b.event_time = (
    SELECT MAX(event_time) 
    FROM demo.user_behavior b2 
    WHERE b2.user_id = b.user_id
);
```

### 5.2 列表子查询

```sql
-- 查询活跃用户的行为
SELECT 
    user_id,
    event_type,
    page_url,
    event_time
FROM demo.user_behavior 
WHERE user_id IN (
    SELECT user_id 
    FROM demo.user_behavior 
    GROUP BY user_id 
    HAVING COUNT(*) > 10
);

-- 查询没有行为的用户
SELECT 
    user_id,
    user_name
FROM demo.user_info 
WHERE user_id NOT IN (
    SELECT DISTINCT user_id 
    FROM demo.user_behavior
);
```

### 5.3 表子查询

```sql
-- 使用表子查询
SELECT 
    u.user_id,
    u.user_name,
    s.event_count,
    s.avg_stay_time
FROM demo.user_info u
JOIN (
    SELECT 
        user_id,
        COUNT(*) AS event_count,
        AVG(stay_time) AS avg_stay_time
    FROM demo.user_behavior 
    GROUP BY user_id
) s ON u.user_id = s.user_id
ORDER BY s.event_count DESC;

-- 使用EXISTS
SELECT 
    u.user_id,
    u.user_name
FROM demo.user_info u
WHERE EXISTS (
    SELECT 1 
    FROM demo.user_behavior b 
    WHERE b.user_id = u.user_id 
      AND b.event_type = 'purchase'
);
```

## 6. 窗口函数

### 6.1 基本窗口函数

```sql
-- ROW_NUMBER
SELECT 
    user_id,
    event_time,
    event_type,
    page_url,
    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY event_time) AS event_seq
FROM demo.user_behavior;

-- RANK
SELECT 
    user_id,
    COUNT(*) AS event_count,
    RANK() OVER (ORDER BY COUNT(*) DESC) AS user_rank
FROM demo.user_behavior 
GROUP BY user_id
ORDER BY event_count DESC;

-- DENSE_RANK
SELECT 
    user_id,
    COUNT(*) AS event_count,
    DENSE_RANK() OVER (ORDER BY COUNT(*) DESC) AS user_dense_rank
FROM demo.user_behavior 
GROUP BY user_id
ORDER BY event_count DESC;

-- LAG和LEAD
SELECT 
    user_id,
    event_time,
    event_type,
    page_url,
    LAG(event_time, 1) OVER (PARTITION BY user_id ORDER BY event_time) AS prev_event_time,
    LAG(event_type, 1) OVER (PARTITION BY user_id ORDER BY event_time) AS prev_event_type,
    LEAD(event_time, 1) OVER (PARTITION BY user_id ORDER BY event_time) AS next_event_time,
    LEAD(event_type, 1) OVER (PARTITION BY user_id ORDER BY event_time) AS next_event_type
FROM demo.user_behavior;
```

### 6.2 聚合窗口函数

```sql
-- 滑动窗口聚合
SELECT 
    user_id,
    event_time,
    event_type,
    stay_time,
    SUM(stay_time) OVER (PARTITION BY user_id ORDER BY event_time ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_stay_time,
    AVG(stay_time) OVER (PARTITION BY user_id ORDER BY event_time ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS moving_avg_stay_time,
    MAX(stay_time) OVER (PARTITION BY user_id ORDER BY event_time ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS moving_max_stay_time
FROM demo.user_behavior;

-- 窗口范围聚合
SELECT 
    DATE(event_time) AS event_date,
    event_type,
    COUNT(*) AS daily_count,
    SUM(COUNT(*)) OVER (PARTITION BY event_type ORDER BY DATE(event_time) RANGE BETWEEN INTERVAL 2 DAY PRECEDING AND CURRENT ROW) AS rolling_3day_count
FROM demo.user_behavior 
WHERE event_time >= '2023-11-01' AND event_time < '2023-12-01'
GROUP BY DATE(event_time), event_type
ORDER BY event_date, event_type;
```

### 6.3 分析函数

```sql
-- NTILE分桶
SELECT 
    user_id,
    COUNT(*) AS event_count,
    NTILE(4) OVER (ORDER BY COUNT(*) DESC) AS quartile
FROM demo.user_behavior 
GROUP BY user_id
ORDER BY event_count DESC;

-- PERCENT_RANK百分位排名
SELECT 
    user_id,
    COUNT(*) AS event_count,
    PERCENT_RANK() OVER (ORDER BY COUNT(*) DESC) AS percent_rank
FROM demo.user_behavior 
GROUP BY user_id
ORDER BY event_count DESC;

-- CUME_DIST累积分布
SELECT 
    user_id,
    COUNT(*) AS event_count,
    CUME_DIST() OVER (ORDER BY COUNT(*) DESC) AS cume_dist
FROM demo.user_behavior 
GROUP BY user_id
ORDER BY event_count DESC;
```

## 7. 公共表表达式(CTE)

### 7.1 基本CTE

```sql
-- 基本CTE
WITH user_daily_stats AS (
    SELECT 
        user_id,
        DATE(event_time) AS event_date,
        COUNT(*) AS event_count,
        SUM(stay_time) AS total_stay_time
    FROM demo.user_behavior 
    WHERE event_time >= '2023-11-20' AND event_time < '2023-11-21'
    GROUP BY user_id, DATE(event_time)
)
SELECT 
    u.user_id,
    u.user_name,
    d.event_count,
    d.total_stay_time
FROM demo.user_info u
JOIN user_daily_stats d ON u.user_id = d.user_id
ORDER BY d.event_count DESC;

-- 多个CTE
WITH user_daily_stats AS (
    SELECT 
        user_id,
        DATE(event_time) AS event_date,
        COUNT(*) AS event_count,
        SUM(stay_time) AS total_stay_time
    FROM demo.user_behavior 
    WHERE event_time >= '2023-11-20' AND event_time < '2023-11-21'
    GROUP BY user_id, DATE(event_time)
),
user_avg_stats AS (
    SELECT 
        user_id,
        AVG(event_count) AS avg_daily_events,
        AVG(total_stay_time) AS avg_daily_stay_time
    FROM user_daily_stats
    GROUP BY user_id
)
SELECT 
    u.user_id,
    u.user_name,
    a.avg_daily_events,
    a.avg_daily_stay_time
FROM demo.user_info u
JOIN user_avg_stats a ON u.user_id = a.user_id
ORDER BY a.avg_daily_events DESC;
```

### 7.2 递归CTE

```sql
-- 递归CTE（Doris目前不支持递归CTE，可以使用其他方式实现）
-- 例如，构建用户行为路径
WITH RECURSIVE user_paths AS (
    -- 基础查询
    SELECT 
        user_id,
        event_time,
        event_type,
        page_url,
        1 AS step,
        CAST(page_url AS VARCHAR(1000)) AS path
    FROM demo.user_behavior 
    WHERE event_type = 'view' AND page_url = '/home'
    
    UNION ALL
    
    -- 递归查询
    SELECT 
        b.user_id,
        b.event_time,
        b.event_type,
        b.page_url,
        p.step + 1,
        CONCAT(p.path, ' -> ', b.page_url)
    FROM demo.user_behavior b
    JOIN user_paths p ON b.user_id = p.user_id 
      AND b.event_time > p.event_time
      AND TIMESTAMPDIFF(SECOND, p.event_time, b.event_time) <= 1800
    WHERE p.step < 5
)
SELECT * FROM user_paths;
```

## 8. 条件表达式

### 8.1 CASE表达式

```sql
-- 简单CASE
SELECT 
    user_id,
    event_type,
    CASE event_type
        WHEN 'view' THEN '浏览'
        WHEN 'click' THEN '点击'
        WHEN 'purchase' THEN '购买'
        ELSE '其他'
    END AS event_type_cn
FROM demo.user_behavior;

-- 搜索CASE
SELECT 
    user_id,
    stay_time,
    CASE 
        WHEN stay_time < 10 THEN '短停留'
        WHEN stay_time BETWEEN 10 AND 30 THEN '中等停留'
        WHEN stay_time BETWEEN 30 AND 60 THEN '长停留'
        ELSE '超长停留'
    END AS stay_time_category
FROM demo.user_behavior;

-- CASE在聚合中使用
SELECT 
    DATE(event_time) AS event_date,
    COUNT(*) AS total_events,
    SUM(CASE WHEN event_type = 'view' THEN 1 ELSE 0 END) AS view_events,
    SUM(CASE WHEN event_type = 'click' THEN 1 ELSE 0 END) AS click_events,
    SUM(CASE WHEN event_type = 'purchase' THEN 1 ELSE 0 END) AS purchase_events
FROM demo.user_behavior 
WHERE event_time >= '2023-11-20' AND event_time < '2023-11-21'
GROUP BY DATE(event_time)
ORDER BY event_date;
```

### 8.2 IF和IFNULL函数

```sql
-- IF函数
SELECT 
    user_id,
    event_type,
    IF(stay_time > 30, '长停留', '短停留') AS stay_time_category
FROM demo.user_behavior;

-- IFNULL函数
SELECT 
    user_id,
    IFNULL(referrer_url, '直接访问') AS referrer_type
FROM demo.user_behavior;

-- NULLIF函数
SELECT 
    user_id,
    NULLIF(referrer_url, page_url) AS referrer_url_clean
FROM demo.user_behavior;
```

## 9. 物化视图

### 9.1 创建物化视图

```sql
-- 基本物化视图
CREATE MATERIALIZED VIEW demo.user_behavior_daily_stats AS
SELECT 
    DATE(event_time) AS event_date,
    event_type,
    COUNT(*) AS event_count,
    SUM(stay_time) AS total_stay_time,
    AVG(stay_time) AS avg_stay_time
FROM demo.user_behavior 
GROUP BY DATE(event_time), event_type;

-- 聚合物化视图
CREATE MATERIALIZED VIEW demo.user_behavior_hourly_stats AS
SELECT 
    DATE_FORMAT(event_time, '%Y-%m-%d %H:00:00') AS event_hour,
    event_type,
    user_id,
    COUNT(*) AS event_count,
    SUM(stay_time) AS total_stay_time,
    MAX(stay_time) AS max_stay_time
FROM demo.user_behavior 
GROUP BY DATE_FORMAT(event_time, '%Y-%m-%d %H:00:00'), event_type, user_id;

-- 带条件的物化视图
CREATE MATERIALIZED VIEW demo.user_behavior_purchase_stats AS
SELECT 
    user_id,
    DATE(event_time) AS event_date,
    COUNT(*) AS purchase_count,
    SUM(stay_time) AS total_stay_time
FROM demo.user_behavior 
WHERE event_type = 'purchase'
GROUP BY user_id, DATE(event_time);
```

### 9.2 查询物化视图

```sql
-- 直接查询物化视图
SELECT * FROM demo.user_behavior_daily_stats 
WHERE event_date = '2023-11-20' AND event_type = 'view';

-- 查询重写（Doris会自动重写查询使用物化视图）
SELECT 
    DATE(event_time) AS event_date,
    event_type,
    COUNT(*) AS event_count,
    SUM(stay_time) AS total_stay_time,
    AVG(stay_time) AS avg_stay_time
FROM demo.user_behavior 
WHERE event_time >= '2023-11-20' AND event_time < '2023-11-21'
GROUP BY DATE(event_time), event_type;
```

### 9.3 管理物化视图

```sql
-- 查看物化视图
SHOW MATERIALIZED VIEWS FROM demo;

-- 查看物化视图定义
SHOW CREATE MATERIALIZED VIEW demo.user_behavior_daily_stats;

-- 删除物化视图
DROP MATERIALIZED VIEW demo.user_behavior_daily_stats;

-- 刷新物化视图
REFRESH MATERIALIZED VIEW demo.user_behavior_daily_stats;
```

## 10. 查询优化

### 10.1 执行计划分析

```sql
-- 查看执行计划
EXPLAIN SELECT 
    user_id,
    event_type,
    COUNT(*) AS event_count
FROM demo.user_behavior 
WHERE event_time >= '2023-11-20' AND event_time < '2023-11-21'
GROUP BY user_id, event_type;

-- 查看详细执行计划
EXPLAIN VERBOSE SELECT 
    user_id,
    event_type,
    COUNT(*) AS event_count
FROM demo.user_behavior 
WHERE event_time >= '2023-11-20' AND event_time < '2023-11-21'
GROUP BY user_id, event_type;
```

### 10.2 查询优化技巧

1. **合理使用索引**：
   - 在WHERE条件中使用索引列
   - 避免在索引列上使用函数
   - 使用覆盖索引减少回表

2. **优化JOIN操作**：
   - 确保连接列有相同的数据类型
   - 将小表放在JOIN的左边
   - 使用适当的连接类型

3. **优化聚合查询**：
   - 使用物化视图预计算聚合结果
   - 合理使用GROUP BY和HAVING
   - 避免在聚合函数中使用复杂表达式

4. **优化子查询**：
   - 尽量使用JOIN替代子查询
   - 使用EXISTS替代IN
   - 将子查询转换为JOIN

5. **优化WHERE条件**：
   - 使用索引友好的条件
   - 避免使用OR条件
   - 使用范围条件替代多个等值条件

### 10.3 查询缓存

```sql
-- 启用查询缓存（需要在配置文件中设置）
-- 查看缓存状态
SHOW VARIABLES LIKE 'query_cache%';

-- 清空查询缓存
RESET QUERY CACHE;

-- 使用SQL_CACHE提示强制使用缓存
SELECT SQL_CACHE * FROM demo.user_behavior WHERE user_id = 1001;

-- 使用SQL_NO_CACHE提示禁用缓存
SELECT SQL_NO_CACHE * FROM demo.user_behavior WHERE user_id = 1001;
```

## 11. 实战案例

### 11.1 用户行为分析

```sql
-- 1. 用户活跃度分析
WITH user_activity AS (
    SELECT 
        user_id,
        COUNT(*) AS total_events,
        COUNT(DISTINCT DATE(event_time)) AS active_days,
        MIN(event_time) AS first_event_time,
        MAX(event_time) AS last_event_time,
        DATEDIFF(MAX(event_time), MIN(event_time)) AS activity_span_days,
        SUM(stay_time) AS total_stay_time,
        AVG(stay_time) AS avg_stay_time
    FROM demo.user_behavior 
    WHERE event_time >= '2023-11-01' AND event_time < '2023-12-01'
    GROUP BY user_id
),
user_segments AS (
    SELECT 
        user_id,
        total_events,
        active_days,
        activity_span_days,
        total_stay_time,
        avg_stay_time,
        CASE 
            WHEN active_days >= 25 THEN '高活跃用户'
            WHEN active_days >= 15 THEN '中活跃用户'
            WHEN active_days >= 5 THEN '低活跃用户'
            ELSE '流失用户'
        END AS activity_level,
        CASE 
            WHEN total_events >= 100 THEN '高频用户'
            WHEN total_events >= 50 THEN '中频用户'
            WHEN total_events >= 10 THEN '低频用户'
            ELSE '极低频用户'
        END AS frequency_level
    FROM user_activity
)
SELECT 
    activity_level,
    frequency_level,
    COUNT(*) AS user_count,
    AVG(total_events) AS avg_total_events,
    AVG(active_days) AS avg_active_days,
    AVG(total_stay_time) AS avg_total_stay_time,
    AVG(avg_stay_time) AS avg_stay_time_per_event
FROM user_segments
GROUP BY activity_level, frequency_level
ORDER BY activity_level, frequency_level;

-- 2. 用户行为路径分析
WITH user_event_sequence AS (
    SELECT 
        user_id,
        event_time,
        event_type,
        page_url,
        ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY event_time) AS event_seq
    FROM demo.user_behavior 
    WHERE event_time >= '2023-11-20' AND event_time < '2023-11-21'
),
user_paths AS (
    SELECT 
        e1.user_id,
        e1.event_type AS event_type_1,
        e1.page_url AS page_url_1,
        e2.event_type AS event_type_2,
        e2.page_url AS page_url_2,
        TIMESTAMPDIFF(SECOND, e1.event_time, e2.event_time) AS time_diff
    FROM user_event_sequence e1
    JOIN user_event_sequence e2 ON e1.user_id = e2.user_id AND e1.event_seq + 1 = e2.event_seq
)
SELECT 
    event_type_1,
    page_url_1,
    event_type_2,
    page_url_2,
    COUNT(*) AS transition_count,
    AVG(time_diff) AS avg_time_diff
FROM user_paths
GROUP BY event_type_1, page_url_1, event_type_2, page_url_2
ORDER BY transition_count DESC
LIMIT 20;

-- 3. 用户留存分析
WITH user_first_day AS (
    SELECT 
        user_id,
        MIN(DATE(event_time)) AS first_day
    FROM demo.user_behavior 
    GROUP BY user_id
),
user_retention AS (
    SELECT 
        f.user_id,
        f.first_day,
        CASE WHEN DATEDIFF(DATE(b.event_time), f.first_day) = 0 THEN 1 ELSE 0 END AS day_0_retention,
        CASE WHEN DATEDIFF(DATE(b.event_time), f.first_day) = 1 THEN 1 ELSE 0 END AS day_1_retention,
        CASE WHEN DATEDIFF(DATE(b.event_time), f.first_day) = 7 THEN 1 ELSE 0 END AS day_7_retention,
        CASE WHEN DATEDIFF(DATE(b.event_time), f.first_day) = 30 THEN 1 ELSE 0 END AS day_30_retention
    FROM user_first_day f
    LEFT JOIN demo.user_behavior b ON f.user_id = b.user_id
        AND DATEDIFF(DATE(b.event_time), f.first_day) IN (0, 1, 7, 30)
),
retention_summary AS (
    SELECT 
        first_day,
        COUNT(DISTINCT user_id) AS total_users,
        SUM(day_0_retention) AS day_0_users,
        SUM(day_1_retention) AS day_1_users,
        SUM(day_7_retention) AS day_7_users,
        SUM(day_30_retention) AS day_30_users
    FROM user_retention
    GROUP BY first_day
)
SELECT 
    first_day,
    total_users,
    day_0_users,
    day_1_users,
    day_7_users,
    day_30_users,
    day_0_users * 100.0 / total_users AS day_0_retention_rate,
    day_1_users * 100.0 / total_users AS day_1_retention_rate,
    day_7_users * 100.0 / total_users AS day_7_retention_rate,
    day_30_users * 100.0 / total_users AS day_30_retention_rate
FROM retention_summary
ORDER BY first_day;
```

### 11.2 销售数据分析

```sql
-- 1. 销售趋势分析
SELECT 
    DATE(order_time) AS order_date,
    COUNT(*) AS order_count,
    SUM(total_amount) AS total_sales,
    AVG(total_amount) AS avg_order_value,
    COUNT(DISTINCT user_id) AS unique_customers
FROM demo.orders 
WHERE order_time >= '2023-11-01' AND order_time < '2023-12-01'
GROUP BY DATE(order_time)
ORDER BY order_date;

-- 2. 商品销售分析
WITH product_sales AS (
    SELECT 
        p.product_id,
        p.product_name,
        p.product_category,
        p.brand,
        COUNT(o.order_id) AS order_count,
        SUM(o.quantity) AS total_quantity,
        SUM(o.total_amount) AS total_sales,
        AVG(o.price) AS avg_price
    FROM demo.orders o
    JOIN demo.product_info p ON o.product_id = p.product_id
    WHERE o.order_time >= '2023-11-01' AND o.order_time < '2023-12-01'
    GROUP BY p.product_id, p.product_name, p.product_category, p.brand
),
product_ranking AS (
    SELECT 
        *,
        ROW_NUMBER() OVER (ORDER BY total_sales DESC) AS sales_rank,
        ROW_NUMBER() OVER (ORDER BY order_count DESC) AS popularity_rank,
        ROW_NUMBER() OVER (ORDER BY avg_price DESC) AS price_rank
    FROM product_sales
)
SELECT 
    product_id,
    product_name,
    product_category,
    brand,
    order_count,
    total_quantity,
    total_sales,
    avg_price,
    sales_rank,
    popularity_rank,
    price_rank
FROM product_ranking
ORDER BY sales_rank
LIMIT 20;

-- 3. 用户购买行为分析
WITH user_purchase_stats AS (
    SELECT 
        user_id,
        COUNT(*) AS order_count,
        SUM(total_amount) AS total_spent,
        AVG(total_amount) AS avg_order_value,
        MIN(order_time) AS first_order_time,
        MAX(order_time) AS last_order_time,
        DATEDIFF(MAX(order_time), MIN(order_time)) AS purchase_span_days
    FROM demo.orders 
    WHERE order_time >= '2023-01-01' AND order_time < '2024-01-01'
    GROUP BY user_id
),
user_segments AS (
    SELECT 
        user_id,
        order_count,
        total_spent,
        avg_order_value,
        purchase_span_days,
        CASE 
            WHEN total_spent >= 10000 THEN '高价值用户'
            WHEN total_spent >= 5000 THEN '中价值用户'
            WHEN total_spent >= 1000 THEN '低价值用户'
            ELSE '极低价值用户'
        END AS value_segment,
        CASE 
            WHEN order_count >= 20 THEN '高频购买用户'
            WHEN order_count >= 10 THEN '中频购买用户'
            WHEN order_count >= 5 THEN '低频购买用户'
            ELSE '极低频购买用户'
        END AS frequency_segment
    FROM user_purchase_stats
)
SELECT 
    value_segment,
    frequency_segment,
    COUNT(*) AS user_count,
    AVG(order_count) AS avg_order_count,
    AVG(total_spent) AS avg_total_spent,
    AVG(avg_order_value) AS avg_order_value,
    AVG(purchase_span_days) AS avg_purchase_span_days
FROM user_segments
GROUP BY value_segment, frequency_segment
ORDER BY value_segment, frequency_segment;
```

## 12. 常见问题与解决方案

### 12.1 查询性能问题

**问题**：查询执行缓慢

**解决方案**：
1. 分析执行计划，找出性能瓶颈
2. 优化WHERE条件，使用索引
3. 减少返回的数据量
4. 使用物化视图预计算
5. 优化JOIN操作

### 12.2 内存不足问题

**问题**：查询过程中出现内存不足错误

**解决方案**：
1. 减少查询的数据量
2. 使用LIMIT限制返回行数
3. 优化聚合查询
4. 增加查询内存限制
5. 分批处理大数据量查询

### 12.3 结果不准确问题

**问题**：查询结果与预期不符

**解决方案**：
1. 检查WHERE条件是否正确
2. 验证JOIN条件是否准确
3. 确认聚合函数的使用
4. 检查数据类型转换
5. 验证NULL值的处理

### 12.4 复杂查询优化

**问题**：复杂查询难以优化

**解决方案**：
1. 将复杂查询分解为多个简单查询
2. 使用临时表存储中间结果
3. 使用CTE提高查询可读性
4. 合理使用子查询和JOIN
5. 考虑使用物化视图预计算

## 13. 本章小结

本章详细介绍了Doris的数据查询功能，包括基本查询、聚合查询、连接查询、子查询、窗口函数、公共表表达式、条件表达式和物化视图等内容，以及查询优化技巧和实战案例。

### 13.1 关键要点

1. **基本查询**：掌握SELECT、WHERE、ORDER BY等基本语法
2. **聚合查询**：熟练使用GROUP BY和聚合函数
3. **连接查询**：掌握内连接、外连接和自连接
4. **窗口函数**：使用窗口函数进行复杂分析
5. **物化视图**：使用物化视图提高查询性能

### 13.2 最佳实践

1. 合理设计查询语句，避免不必要的复杂操作
2. 使用执行计划分析查询性能
3. 利用物化视图预计算聚合结果
4. 优化JOIN操作和子查询
5. 合理使用查询缓存

## 14. 延伸阅读

- [Doris官方文档-数据查询](https://doris.apache.org/docs/sql-manual/sql-functions/)
- [Doris查询优化指南](https://doris.apache.org/docs/admin-manual/query-profile/)
- [Doris窗口函数详解](https://doris.apache.org/docs/sql-manual/sql-functions/window-functions/)

## 15. 实践练习

1. 编写基本查询语句，包括WHERE、ORDER BY、LIMIT等
2. 使用聚合函数和GROUP BY进行数据分析
3. 编写多表连接查询，包括内连接、外连接和自连接
4. 使用子查询解决复杂查询问题
5. 使用窗口函数进行排名和趋势分析
6. 创建和使用物化视图优化查询性能
7. 分析查询执行计划，优化查询性能
8. 设计一个完整的用户行为分析查询方案