# 物化视图与投影

物化视图(Materialized View)和投影(Projection)是ClickHouse中两个重要的数据预处理和查询优化机制。它们可以显著提高查询性能，减少计算资源消耗，是构建高性能分析系统的重要工具。

## 1. 物化视图概述

### 1.1 什么是物化视图

物化视图是一种特殊的表结构，它会自动将源表的数据按照预定义的规则转换和存储。与普通视图不同，物化视图会实际存储计算结果，而不是每次查询时重新计算。

### 1.2 物化视图的优势

- **查询加速**：预先计算并存储结果，避免重复计算
- **实时更新**：数据插入时自动更新物化视图
- **数据预处理**：可以进行复杂的数据转换和聚合
- **存储优化**：可以选择不同的存储引擎优化存储

### 1.3 物化视图的限制

- **写入放大**：数据需要同时写入源表和物化视图
- **存储开销**：物化视图会额外占用存储空间
- **更新延迟**：物化视图的更新不是实时的，有一定的延迟
- **查询限制**：不能直接更新物化视图中的数据

## 2. 物化视图的基本使用

### 2.1 创建物化视图

```sql
CREATE MATERIALIZED VIEW [IF NOT EXISTS] view_name [TO table_name] [ENGINE = engine] [POPULATE] AS SELECT ...
```

参数说明：
- **TO table_name**：指定目标表，物化视图将数据写入此表
- **ENGINE**：指定物化视图的存储引擎
- **POPULATE**：创建时使用现有数据填充物化视图

### 2.2 简单示例：创建物化视图

```sql
-- 源表
CREATE TABLE sales (
    order_id UInt64,
    product_id UInt64,
    order_time DateTime,
    amount Decimal(10, 2),
    region String,
    channel String
) ENGINE = MergeTree()
PARTITION BY toYYYYMM(order_time)
ORDER BY (order_time, product_id);

-- 目标表
CREATE TABLE sales_daily_summary (
    date Date,
    product_id UInt64,
    total_amount Decimal(15, 2),
    order_count UInt64,
    region String,
    channel String
) ENGINE = SummingMergeTree()
PARTITION BY toYYYYMM(date)
ORDER BY (date, product_id, region, channel);

-- 创建物化视图
CREATE MATERIALIZED VIEW sales_daily_mv TO sales_daily_summary AS
SELECT 
    toDate(order_time) AS date,
    product_id,
    sum(amount) AS total_amount,
    count() AS order_count,
    region,
    channel
FROM sales
GROUP BY date, product_id, region, channel;
```

### 2.3 使用POPULATE选项

```sql
-- 带POPULATE选项的物化视图，会使用现有数据初始化
CREATE MATERIALIZED VIEW sales_daily_mv_populate
TO sales_daily_summary POPULATE AS
SELECT 
    toDate(order_time) AS date,
    product_id,
    sum(amount) AS total_amount,
    count() AS order_count,
    region,
    channel
FROM sales
GROUP BY date, product_id, region, channel;
```

注意：使用POPULATE选项可能会在生产环境中造成问题，因为初始化期间新插入的数据可能会丢失。推荐的做法是手动初始化数据：

```sql
-- 手动初始化数据
INSERT INTO sales_daily_summary 
SELECT 
    toDate(order_time) AS date,
    product_id,
    sum(amount) AS total_amount,
    count() AS order_count,
    region,
    channel
FROM sales
GROUP BY date, product_id, region, channel;

-- 然后创建不带POPULATE的物化视图
CREATE MATERIALIZED VIEW sales_daily_mv TO sales_daily_summary AS
SELECT 
    toDate(order_time) AS date,
    product_id,
    sum(amount) AS total_amount,
    count() AS order_count,
    region,
    channel
FROM sales
GROUP BY date, product_id, region, channel;
```

## 3. 物化视图的高级用法

### 3.1 使用不同引擎的物化视图

```sql
-- 使用AggregatingMergeTree引擎创建物化视图
CREATE TABLE user_activity_daily (
    date Date,
    user_group String,
    page_views AggregateFunction(sum, UInt64),
    unique_users AggregateFunction(uniq, UInt64),
    session_duration AggregateFunction(avg, UInt64)
) ENGINE = AggregatingMergeTree()
PARTITION BY date
ORDER BY (date, user_group);

-- 创建物化视图
CREATE MATERIALIZED VIEW user_activity_mv TO user_activity_daily AS
SELECT
    toDate(event_time) AS date,
    CASE 
        WHEN user_id % 1000 < 500 THEN 'group_a' 
        ELSE 'group_b' 
    END AS user_group,
    sumState(toUInt64(1)) AS page_views,
    uniqState(user_id) AS unique_users,
    avgState(session_duration) AS session_duration
FROM user_events
GROUP BY date, user_group;
```

### 3.2 多级物化视图

```sql
-- 第1级：实时分钟级聚合
CREATE TABLE sales_minute_summary (
    minute DateTime,
    product_id UInt64,
    total_amount Decimal(15, 2),
    order_count UInt64
) ENGINE = SummingMergeTree()
ORDER BY (minute, product_id);

CREATE MATERIALIZED VIEW sales_minute_mv TO sales_minute_summary AS
SELECT 
    toStartOfMinute(order_time) AS minute,
    product_id,
    sum(amount) AS total_amount,
    count() AS order_count
FROM sales
GROUP BY minute, product_id;

-- 第2级：小时级聚合
CREATE TABLE sales_hourly_summary (
    hour DateTime,
    product_id UInt64,
    total_amount Decimal(15, 2),
    order_count UInt64
) ENGINE = SummingMergeTree()
ORDER BY (hour, product_id);

CREATE MATERIALIZED VIEW sales_hourly_mv TO sales_hourly_summary AS
SELECT 
    toStartOfHour(minute) AS hour,
    product_id,
    sum(total_amount) AS total_amount,
    sum(order_count) AS order_count
FROM sales_minute_summary
GROUP BY hour, product_id;

-- 第3级：日级聚合
CREATE TABLE sales_daily_summary (
    date Date,
    product_id UInt64,
    total_amount Decimal(15, 2),
    order_count UInt64
) ENGINE = SummingMergeTree()
ORDER BY (date, product_id);

CREATE MATERIALIZED VIEW sales_daily_mv TO sales_daily_summary AS
SELECT 
    toDate(hour) AS date,
    product_id,
    sum(total_amount) AS total_amount,
    sum(order_count) AS order_count
FROM sales_hourly_summary
GROUP BY date, product_id;
```

### 3.3 使用物化视图实现数据路由

```sql
-- 创建不同的目标表
CREATE TABLE sales_hot (
    order_id UInt64,
    product_id UInt64,
    order_time DateTime,
    amount Decimal(10, 2),
    region String,
    channel String
) ENGINE = MergeTree()
PARTITION BY toYYYYMM(order_time)
ORDER BY (order_time, product_id);

CREATE TABLE sales_cold (
    order_id UInt64,
    product_id UInt64,
    order_time DateTime,
    amount Decimal(10, 2),
    region String,
    channel String
) ENGINE = MergeTree()
PARTITION BY toYYYYMM(order_time)
ORDER BY (order_time, product_id);

-- 创建物化视图实现路由
CREATE MATERIALIZED VIEW sales_router_mv TO sales_hot AS
SELECT * FROM sales WHERE order_time >= today() - INTERVAL 30 DAY;

CREATE MATERIALIZED VIEW sales_cold_router_mv TO sales_cold AS
SELECT * FROM sales WHERE order_time < today() - INTERVAL 30 DAY;
```

## 4. 物化视图的管理与维护

### 4.1 查看物化视图信息

```sql
-- 查看所有物化视图
SHOW TABLES LIKE '%_mv';

-- 查看物化视图定义
SHOW CREATE TABLE view_name;

-- 查看物化视图状态
SELECT * FROM system.parts WHERE table = 'view_name';
```

### 4.2 删除物化视图

```sql
-- 只删除物化视图，保留目标表
DROP VIEW view_name;

-- 删除物化视图和目标表
DROP TABLE view_name;
```

### 4.3 禁用和启用物化视图

```sql
-- 禁用物化视图（删除后保留定义）
DETACH TABLE view_name;

-- 启用物化视图
ATTACH TABLE view_name;
```

### 4.4 物化视图的故障排查

```sql
-- 检查物化视图错误日志
SELECT 
    table,
    query,
    exception,
    exception_stack_trace
FROM system.query_log 
WHERE event_date = today()
  AND query LIKE '%view_name%'
  AND type = 'Exception'
ORDER BY event_time DESC
LIMIT 10;

-- 检查物化视图数据完整性
SELECT 
    source_count,
    view_count,
    source_count - view_count AS diff
FROM (
    SELECT count() AS source_count FROM source_table
) AS src,
(
    SELECT count() AS view_count FROM target_table
) AS tgt;
```

## 5. 投影(Projection)概述

### 5.1 什么是投影

投影是ClickHouse 20.3版本引入的新特性，它是存储在表内的预计算结果，可以显著提高特定查询模式的性能。与物化视图不同，投影是表的一部分，不需要单独维护。

### 5.2 投影的优势

- **自动维护**：投影由ClickHouse自动维护，不需要手动创建和管理
- **透明使用**：查询可以自动使用投影，无需修改SQL语句
- **存储高效**：投影数据与原表数据存储在一起，减少存储开销
- **查询优化**：ClickHouse优化器可以智能选择最优投影

### 5.3 投影的限制

- **只支持MergeTree系列引擎**
- **只支持特定类型的查询**
- **不能包含JOIN和子查询**
- **聚合函数有限制**

## 6. 投影的基本使用

### 6.1 创建投影

```sql
ALTER TABLE table_name ADD PROJECTION projection_name (
    SELECT select_query
);

-- 或者创建表时定义投影
CREATE TABLE table_name (
    column1 Type1,
    column2 Type2,
    ...
    PROJECTION projection_name (
        SELECT select_query
    )
) ENGINE = MergeTree()
...
```

### 6.2 简单示例：聚合投影

```sql
-- 创建基础表
CREATE TABLE sales (
    order_id UInt64,
    product_id UInt64,
    order_time DateTime,
    amount Decimal(10, 2),
    region String,
    channel String
) ENGINE = MergeTree()
PARTITION BY toYYYYMM(order_time)
ORDER BY (order_time, product_id);

-- 添加聚合投影
ALTER TABLE sales ADD PROJECTION daily_summary (
    SELECT 
        toDate(order_time) AS date,
        product_id,
        region,
        channel,
        sum(amount) AS total_amount,
        count() AS order_count
    GROUP BY date, product_id, region, channel
);

-- 查询会自动使用投影
SELECT 
    date,
    product_id,
    region,
    channel,
    sum(amount) AS total_amount,
    count() AS order_count
FROM sales
WHERE date >= '2023-01-01'
GROUP BY date, product_id, region, channel;
```

### 6.3 筛选投影

```sql
-- 添加筛选投影
ALTER TABLE sales ADD PROJECTION recent_sales (
    SELECT 
        order_id,
        product_id,
        order_time,
        amount,
        region,
        channel
    WHERE order_time >= today() - INTERVAL 30 DAY
);

-- 查询最近30天的数据会使用投影
SELECT *
FROM sales
WHERE order_time >= today() - INTERVAL 30 DAY
  AND region = 'North';
```

### 6.4 排序投影

```sql
-- 添加排序投影
ALTER TABLE sales ADD PROJECTION product_summary (
    SELECT 
        product_id,
        order_time,
        amount,
        region,
        channel
    ORDER BY (product_id, order_time DESC)
);

-- 按产品ID和时间倒序查询会使用投影
SELECT *
FROM sales
WHERE product_id = 1001
ORDER BY order_time DESC
LIMIT 100;
```

## 7. 投影的管理与维护

### 7.1 查看投影信息

```sql
-- 查看表中的所有投影
SHOW CREATE TABLE table_name;

-- 查看投影使用情况
SELECT 
    table,
    projection,
    read_rows,
    read_bytes,
    rows
FROM system.projection_parts
WHERE table = 'table_name';
```

### 7.2 删除投影

```sql
-- 删除投影
ALTER TABLE table_name DROP PROJECTION projection_name;
```

### 7.3 强制使用投影

```sql
-- 强制使用特定投影
SELECT * FROM sales USE PROJECTION(daily_summary);

-- 强制不使用投影
SELECT * FROM sales IGNORE PROJECTION(daily_summary);
```

### 7.4 投影优化

```sql
-- 手动构建投影
ALTER TABLE table_name MATERIALIZE PROJECTION projection_name SETTINGS mutations_sync = 1;

-- 修改投影设置
ALTER TABLE table_name MODIFY SETTING optimize_skip_unused_shards = 1;
```

## 8. 物化视图与投影的比较

| 特性 | 物化视图 | 投影 |
|------|---------|------|
| 数据存储 | 独立表 | 表内存储 |
| 维护方式 | 手动维护 | 自动维护 |
| 查询使用 | 需明确指定 | 自动选择 |
| 功能范围 | 支持复杂查询 | 有限制的查询 |
| 适用场景 | 跨表操作、ETL | 单表查询优化 |
| 存储开销 | 独立存储 | 共享存储 |
| 更新机制 | 插入时触发 | 自动触发 |
| 灵活性 | 高 | 中等 |

## 9. 最佳实践

### 9.1 何时使用物化视图

- **跨表操作**：需要关联多个表的结果
- **复杂ETL**：需要进行复杂的数据转换
- **多级聚合**：需要多个层级的聚合数据
- **历史数据**：需要保留不同粒度的历史数据
- **外部系统**：需要将数据提供给外部系统

### 9.2 何时使用投影

- **单表查询优化**：频繁的单一表查询
- **聚合查询**：常见的聚合查询模式
- **筛选查询**：特定的筛选条件组合
- **排序查询**：特定的排序需求
- **资源受限**：有限的存储和维护资源

### 9.3 使用建议

1. **监控资源使用**：定期检查物化视图和投影的资源消耗
2. **评估查询性能**：分析查询执行计划，确认投影或物化视图是否被使用
3. **合理设计键**：选择合适的分区键和排序键
4. **避免过度使用**：不要为所有可能的查询模式创建物化视图或投影
5. **定期维护**：定期检查和更新物化视图和投影

### 9.4 常见陷阱

1. **数据一致性**：物化视图可能存在数据延迟
2. **资源竞争**：大量物化视图可能影响写入性能
3. **投影冲突**：多个投影可能导致优化器选择困难
4. **复杂查询**：投影不支持复杂查询，可能无法满足需求
5. **过度设计**：创建不必要的物化视图和投影浪费资源

## 10. 实际应用案例

### 10.1 实时仪表板

```sql
-- 源表
CREATE TABLE events (
    event_id UInt64,
    user_id UInt64,
    event_type String,
    event_time DateTime,
    properties String
) ENGINE = MergeTree()
PARTITION BY toYYYYMMDD(event_time)
ORDER BY (event_time, event_type);

-- 实时统计投影
ALTER TABLE events ADD PROJECTION real_time_stats (
    SELECT 
        event_type,
        toDate(event_time) AS date,
        count() AS event_count,
        uniqExact(user_id) AS unique_users
    GROUP BY event_type, date
);

-- 日报物化视图
CREATE TABLE daily_events_summary (
    date Date,
    event_type String,
    event_count AggregateFunction(sum, UInt64),
    unique_users AggregateFunction(uniq, UInt64)
) ENGINE = AggregatingMergeTree()
ORDER BY (date, event_type);

CREATE MATERIALIZED VIEW daily_events_mv TO daily_events_summary AS
SELECT 
    toDate(event_time) AS date,
    event_type,
    sumState(toUInt64(1)) AS event_count,
    uniqState(user_id) AS unique_users
FROM events
GROUP BY date, event_type;
```

### 10.2 用户行为分析

```sql
-- 用户行为表
CREATE TABLE user_behavior (
    user_id UInt64,
    session_id String,
    action_type String,
    action_time DateTime,
    page_url String,
    device_type String,
    referrer String
) ENGINE = MergeTree()
PARTITION BY toYYYYMM(action_time)
ORDER BY (user_id, action_time);

-- 用户会话聚合物化视图
CREATE TABLE user_sessions (
    user_id UInt64,
    session_id String,
    session_start DateTime,
    session_end DateTime,
    page_views UInt64,
    duration_seconds UInt32,
    device_type String,
    referrer String
) ENGINE = ReplacingMergeTree(session_end)
ORDER BY (user_id, session_id);

CREATE MATERIALIZED VIEW user_sessions_mv TO user_sessions AS
SELECT 
    user_id,
    session_id,
    min(action_time) AS session_start,
    max(action_time) AS session_end,
    count() AS page_views,
    toUInt32(dateDiff('second', min(action_time), max(action_time))) AS duration_seconds,
    any(device_type) AS device_type,
    any(referrer) AS referrer
FROM user_behavior
GROUP BY user_id, session_id;

-- 设备分析投影
ALTER TABLE user_behavior ADD PROJECTION device_analysis (
    SELECT 
        device_type,
        toDate(action_time) AS date,
        uniqExact(user_id) AS unique_users,
        uniqExact(session_id) AS unique_sessions,
        count() AS total_actions
    GROUP BY device_type, date
);
```

## 11. 总结

物化视图和投影是ClickHouse中两个强大的数据预处理和查询优化工具。物化视图适合跨表操作、复杂ETL和多级聚合场景，而投影更适合单表查询优化和常见的查询模式。

合理使用物化视图和投影可以显著提高查询性能，减少计算资源消耗，但需要注意它们带来的额外开销和维护成本。在实际应用中，应该根据具体的业务需求和查询模式，选择合适的优化策略，并定期评估和调整优化方案。

在下一节中，我们将介绍ClickHouse的分布式引擎和集群管理，了解如何构建高可用、高扩展性的ClickHouse集群。