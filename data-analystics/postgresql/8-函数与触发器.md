# PostgreSQL高级专题：函数与触发器

## 概述

PostgreSQL提供了强大的编程能力，支持多种编程语言创建函数和触发器。本专题深入探讨PostgreSQL的函数系统、触发器机制，以及如何构建高性能的数据处理逻辑。

## 目录

1. [函数系统概览](#函数系统概览)
2. [PL/pgSQL语言基础](#plpgsql语言基础)
3. [函数类型与特性](#函数类型与特性)
4. [高级函数技术](#高级函数技术)
5. [触发器基础概念](#触发器基础概念)
6. [行级触发器](#行级触发器)
7. [语句级触发器](#语句级触发器)
8. [触发器实战应用](#触发器实战应用)
9. [性能优化策略](#性能优化策略)
10. [最佳实践与模式](#最佳实践与模式)

## 函数系统概览

### PostgreSQL支持的编程语言

```sql
-- 查看已安装的编程语言
SELECT * FROM pg_language ORDER BY lanname;

-- 查看语言处理器
SELECT 
    lanplcallf oid,
    lanplcallf::regprocedure AS function_name,
    lanname,
    lanpltrusted,
    lanrtcl
FROM pg_language
WHERE lanpltrusted;

-- 查看函数类型统计
SELECT 
    prosecdef,
    lanname,
    COUNT(*) as function_count
FROM pg_proc p
JOIN pg_language l ON p.prolang = l.oid
GROUP BY prosecdef, lanname
ORDER BY function_count DESC;
```

### 函数类型分类

```sql
-- 1. 解析型函数（immutable）- 总是返回相同结果
CREATE OR REPLACE FUNCTION calculate_tax(amount NUMERIC)
RETURNS NUMERIC AS $$
BEGIN
    RETURN amount * 0.13;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- 2. 稳定型函数（stable）- 事务内返回相同结果
CREATE OR REPLACE FUNCTION get_current_user_id()
RETURNS INTEGER AS $$
BEGIN
    RETURN current_setting('app.current_user_id', true)::INTEGER;
END;
$$ LANGUAGE plpgsql STABLE;

-- 3. 易变型函数（volatile）- 可能返回不同结果
CREATE OR REPLACE FUNCTION random_discount()
RETURNS NUMERIC AS $$
BEGIN
    RETURN (RANDOM() * 0.2)::NUMERIC(3,2); -- 0-20%折扣
END;
$$ LANGUAGE plpgsql VOLATILE;

-- 4. 安全定义函数（SECURITY DEFINER）
CREATE OR REPLACE FUNCTION admin_reset_password(target_user TEXT, new_password TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    -- 临时使用管理员权限执行
    IF current_user != 'admin' THEN
        RAISE EXCEPTION 'Only admin can reset passwords';
    END IF;
    
    UPDATE users SET password_hash = digest(new_password, 'sha256') 
    WHERE username = target_user;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

## PL/pgSQL语言基础

### 基本语法结构

```sql
-- 创建简单的PL/pgSQL函数
CREATE OR REPLACE FUNCTION calculate_total(quantity INTEGER, unit_price NUMERIC)
RETURNS NUMERIC AS $$
DECLARE
    subtotal NUMERIC;
    tax_rate NUMERIC := 0.13;
    total NUMERIC;
BEGIN
    -- 计算小计
    subtotal := quantity * unit_price;
    
    -- 计算总额（含税）
    total := subtotal * (1 + tax_rate);
    
    -- 返回结果
    RETURN total;
END;
$$ LANGUAGE plpgsql;

-- 测试函数
SELECT calculate_total(5, 100.00);
```

### 变量与数据类型

```sql
-- 变量声明和初始化
CREATE OR REPLACE FUNCTION employee_summary(emp_id INTEGER)
RETURNS TABLE(
    employee_id INTEGER,
    employee_name TEXT,
    department_name TEXT,
    salary NUMERIC,
    hire_date DATE
) AS $$
DECLARE
    -- 标量变量
    emp_name TEXT;
    dept_name TEXT;
    current_salary NUMERIC;
    start_date DATE;
    
    -- 复合类型变量
    emp_record employees%ROWTYPE;
    
    -- 集合类型变量
    skill_list TEXT[];
    project_ids INTEGER[];
BEGIN
    -- 赋值方式1：直接查询赋值
    SELECT name, department, salary, hire_date 
    INTO emp_name, dept_name, current_salary, start_date
    FROM employees
    WHERE id = emp_id;
    
    -- 赋值方式2：记录类型赋值
    SELECT * INTO emp_record
    FROM employees
    WHERE id = emp_id;
    
    -- 数组赋值
    skill_list := ARRAY['SQL', 'Python', 'Java'];
    project_ids := ARRAY[1001, 1002, 1003];
    
    -- 返回结果
    employee_id := emp_id;
    employee_name := emp_name;
    department_name := dept_name;
    salary := current_salary;
    hire_date := start_date;
    
    RETURN NEXT;
END;
$$ LANGUAGE plpgsql;
```

### 控制结构

```sql
-- IF-THEN-ELSE结构
CREATE OR REPLACE FUNCTION calculate_discount(customer_type TEXT, order_total NUMERIC)
RETURNS NUMERIC AS $$
DECLARE
    discount_rate NUMERIC := 0;
BEGIN
    -- 简单条件判断
    IF order_total > 1000 THEN
        discount_rate := 0.05;
    END IF;
    
    -- 多重条件判断
    IF customer_type = 'VIP' THEN
        IF order_total > 2000 THEN
            discount_rate := 0.15;
        ELSIF order_total > 1000 THEN
            discount_rate := 0.10;
        ELSE
            discount_rate := 0.05;
        END IF;
    ELSIF customer_type = 'REGULAR' THEN
        IF order_total > 2000 THEN
            discount_rate := 0.08;
        ELSIF order_total > 1000 THEN
            discount_rate := 0.05;
        END IF;
    END IF;
    
    RETURN order_total * discount_rate;
END;
$$ LANGUAGE plpgsql;

-- CASE语句
CREATE OR REPLACE FUNCTION get_tax_rate(region TEXT)
RETURNS NUMERIC AS $$
DECLARE
    rate NUMERIC;
BEGIN
    -- 简单CASE
    CASE region
        WHEN 'BC' THEN rate := 0.12;
        WHEN 'ON' THEN rate := 0.13;
        WHEN 'AB' THEN rate := 0.05;
        ELSE rate := 0.0;
    END CASE;
    
    -- 搜索CASE
    CASE
        WHEN region LIKE '%BC%' THEN rate := 0.12;
        WHEN region LIKE '%ON%' THEN rate := 0.13;
        WHEN region LIKE '%QC%' THEN rate := 0.14975;
        ELSE rate := 0.0;
    END CASE;
    
    RETURN rate;
END;
$$ LANGUAGE plpgsql;

-- 循环结构
CREATE OR REPLACE FUNCTION generate_timeseries(start_date DATE, end_date DATE)
RETURNS TABLE(cal_date DATE) AS $$
DECLARE
    current_date DATE := start_date;
BEGIN
    -- WHILE循环
    WHILE current_date <= end_date LOOP
        cal_date := current_date;
        RETURN NEXT;
        current_date := current_date + INTERVAL '1 day';
    END LOOP;
    
    RETURN;
END;
$$ LANGUAGE plpgsql;

-- FOR循环（查询结果）
CREATE OR REPLACE FUNCTION process_user_orders(user_id INTEGER)
RETURNS TABLE(
    order_id INTEGER,
    total_amount NUMERIC,
    status TEXT
) AS $$
DECLARE
    order_record RECORD;
    total_value NUMERIC;
BEGIN
    -- 遍历查询结果
    FOR order_record IN 
        SELECT id, total_amount, status
        FROM orders
        WHERE user_id = process_user_orders.user_id
        ORDER BY order_date DESC
    LOOP
        -- 计算累计值
        total_value := COALESCE(total_value, 0) + order_record.total_amount;
        
        -- 返回结果
        order_id := order_record.id;
        total_amount := order_record.total_amount;
        status := order_record.status;
        RETURN NEXT;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- 异常处理
CREATE OR REPLACE FUNCTION safe_divide(a NUMERIC, b NUMERIC)
RETURNS NUMERIC AS $$
BEGIN
    -- 可能抛出异常的代码
    RETURN a / b;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'Division by zero occurred';
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Unexpected error: %', SQLERRM;
        RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

## 函数类型与特性

### 标量函数 vs 聚合函数

```sql
-- 标量函数（返回单个值）
CREATE OR REPLACE FUNCTION get_max_order_value(user_id INTEGER)
RETURNS NUMERIC AS $$
DECLARE
    max_value NUMERIC;
BEGIN
    SELECT MAX(total_amount) INTO max_value
    FROM orders
    WHERE user_id = get_max_order_value.user_id;
    
    RETURN COALESCE(max_value, 0);
END;
$$ LANGUAGE plpgsql;

-- 聚合函数（返回多行结果）
CREATE OR REPLACE FUNCTION get_user_orders_summary(user_id INTEGER)
RETURNS TABLE(
    order_id INTEGER,
    total_amount NUMERIC,
    order_date DATE,
    rank INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        o.id,
        o.total_amount,
        o.order_date,
        ROW_NUMBER() OVER (ORDER BY o.order_date DESC) as rank
    FROM orders o
    WHERE o.user_id = get_user_orders_summary.user_id
    ORDER BY o.order_date DESC;
END;
$$ LANGUAGE plpgsql;
```

### 表值函数

```sql
-- 返回表结果的函数
CREATE OR REPLACE FUNCTION get_employee_details(dept_id INTEGER DEFAULT NULL)
RETURNS TABLE(
    employee_id INTEGER,
    employee_name TEXT,
    department TEXT,
    position TEXT,
    salary NUMERIC,
    hire_date DATE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        e.id,
        e.name,
        d.name as department,
        e.position,
        e.salary,
        e.hire_date
    FROM employees e
    JOIN departments d ON e.department_id = d.id
    WHERE (dept_id IS NULL OR e.department_id = dept_id)
    ORDER BY e.salary DESC;
END;
$$ LANGUAGE plpgsql;

-- 使用表值函数
SELECT * FROM get_employee_details(1);
SELECT * FROM get_employee_details(); -- 所有部门
```

### 返回集合的函数

```sql
-- 返回SETOF类型
CREATE OR REPLACE FUNCTION get_recent_orders(days_back INTEGER)
RETURNS SETOF orders AS $$
BEGIN
    RETURN QUERY
    SELECT * FROM orders
    WHERE order_date >= CURRENT_DATE - (days_back || ' days')::INTERVAL
    ORDER BY order_date DESC;
END;
$$ LANGUAGE plpgsql;

-- 返回SETOF自定义类型
CREATE TYPE order_summary AS (
    order_count INTEGER,
    total_value NUMERIC,
    avg_order_value NUMERIC,
    max_order_value NUMERIC
);

CREATE OR REPLACE FUNCTION get_order_statistics(start_date DATE, end_date DATE)
RETURNS SETOF order_summary AS $$
DECLARE
    result order_summary;
BEGIN
    SELECT 
        COUNT(*),
        SUM(total_amount),
        AVG(total_amount),
        MAX(total_amount)
    INTO result.order_count, result.total_value, result.avg_order_value, result.max_order_value
    FROM orders
    WHERE order_date BETWEEN start_date AND end_date;
    
    RETURN NEXT result;
    RETURN;
END;
$$ LANGUAGE plpgsql;
```

## 高级函数技术

### 动态SQL执行

```sql
-- 动态SQL函数
CREATE OR REPLACE FUNCTION execute_dynamic_query(
    table_name TEXT,
    column_name TEXT,
    value_to_filter ANYELEMENT
) RETURNS TABLE(
    result_json JSONB
) AS $$
DECLARE
    sql_query TEXT;
    param_count INTEGER := 1;
BEGIN
    -- 构建动态SQL
    sql_query := format(
        'SELECT jsonb_build_object(%I, %L) as result_json FROM %I WHERE %I = $1',
        column_name, value_to_filter, table_name, column_name
    );
    
    -- 执行动态SQL
    RETURN QUERY EXECUTE sql_query USING value_to_filter;
END;
$$ LANGUAGE plpgsql;

-- 使用动态SQL
SELECT * FROM execute_dynamic_query('employees', 'id', 1001);

-- 批量数据处理
CREATE OR REPLACE FUNCTION bulk_process_orders(
    start_date DATE,
    end_date DATE,
    batch_size INTEGER DEFAULT 100
)
RETURNS INTEGER AS $$
DECLARE
    processed_count INTEGER := 0;
    remaining_count INTEGER;
    sql_query TEXT;
BEGIN
    LOOP
        -- 获取当前批次
        sql_query := format('
            WITH batch AS (
                SELECT id FROM orders 
                WHERE order_date BETWEEN %L AND %L 
                    AND status = ''pending''
                ORDER BY id
                LIMIT %s
            )
            UPDATE orders 
            SET status = ''processed'', processed_at = CURRENT_TIMESTAMP
            WHERE id IN (SELECT id FROM batch)
            RETURNING id', start_date, end_date, batch_size);
        
        -- 执行并统计影响行数
        GET DIAGNOSTICS processed_count = ROW_COUNT;
        
        -- 如果没有更多数据，退出循环
        IF processed_count = 0 THEN
            EXIT;
        END IF;
        
        -- 等待一小段时间，避免过度占用资源
        PERFORM pg_sleep(0.1);
    END LOOP;
    
    RETURN processed_count;
END;
$$ LANGUAGE plpgsql;
```

### 函数重载

```sql
-- 函数重载示例
-- 1. 根据ID查找用户
CREATE OR REPLACE FUNCTION find_user(user_id INTEGER)
RETURNS users AS $$
BEGIN
    RETURN users_find(user_id);
END;
$$ LANGUAGE plpgsql;

-- 2. 根据用户名查找用户
CREATE OR REPLACE FUNCTION find_user(username TEXT)
RETURNS users AS $$
BEGIN
    SELECT * INTO users_find FROM users WHERE name = username LIMIT 1;
    RETURN users_find;
END;
$$ LANGUAGE plpgsql;

-- 3. 根据邮箱查找用户
CREATE OR REPLACE FUNCTION find_user(email_address TEXT)
RETURNS users AS $$
DECLARE
    found_user users;
BEGIN
    SELECT * INTO found_user FROM users WHERE email = email_address LIMIT 1;
    RETURN found_user;
END;
$$ LANGUAGE plpgsql;

-- 4. 通用查找函数（使用联合类型）
CREATE OR REPLACE FUNCTION find_user(search_term TEXT, search_field TEXT DEFAULT 'id')
RETURNS users AS $$
DECLARE
    found_user users;
BEGIN
    -- 使用动态SQL执行不同字段的查找
    CASE search_field
        WHEN 'id' THEN
            SELECT * INTO found_user FROM users WHERE id = search_term::INTEGER;
        WHEN 'username' THEN
            SELECT * INTO found_user FROM users WHERE name = search_term;
        WHEN 'email' THEN
            SELECT * INTO found_user FROM users WHERE email = search_term;
        ELSE
            RAISE EXCEPTION 'Invalid search field: %', search_field;
    END CASE;
    
    RETURN found_user;
END;
$$ LANGUAGE plpgsql;
```

### 递归函数

```sql
-- 递归查询函数
CREATE OR REPLACE FUNCTION get_employee_hierarchy(employee_id INTEGER, max_depth INTEGER DEFAULT 10)
RETURNS TABLE(
    employee_id INTEGER,
    name TEXT,
    manager_id INTEGER,
    level_number INTEGER,
    path TEXT
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE employee_tree AS (
        -- 基础查询：直接下属
        SELECT 
            e.id,
            e.name,
            e.manager_id,
            1 as level_number,
            e.name::TEXT as path
        FROM employees e
        WHERE e.manager_id = get_employee_hierarchy.employee_id
        
        UNION ALL
        
        -- 递归查询：下属的下属
        SELECT 
            e.id,
            e.name,
            e.manager_id,
            et.level_number + 1,
            et.path || ' -> ' || e.name
        FROM employees e
        JOIN employee_tree et ON e.manager_id = et.employee_id
        WHERE et.level_number < max_depth
    )
    SELECT * FROM employee_tree;
END;
$$ LANGUAGE plpgsql;

-- 递归计算阶乘
CREATE OR REPLACE FUNCTION calculate_factorial(n INTEGER)
RETURNS INTEGER AS $$
BEGIN
    -- 递归终止条件
    IF n <= 1 THEN
        RETURN 1;
    END IF;
    
    -- 递归调用
    RETURN n * calculate_factorial(n - 1);
END;
$$ LANGUAGE plpgsql;
```

### 游标操作

```sql
-- 使用游标处理大数据集
CREATE OR REPLACE FUNCTION process_large_dataset()
RETURNS INTEGER AS $$
DECLARE
    customer_cursor CURSOR FOR 
        SELECT * FROM customers WHERE status = 'active';
    
    customer_record customers%ROWTYPE;
    processed_count INTEGER := 0;
    total_revenue NUMERIC := 0;
BEGIN
    -- 打开游标
    OPEN customer_cursor;
    
    LOOP
        -- 获取下一条记录
        FETCH customer_cursor INTO customer_record;
        
        -- 检查是否到达游标末尾
        EXIT WHEN NOT FOUND;
        
        -- 处理每条记录
        -- 这里可以添加具体的业务逻辑
        total_revenue := total_revenue + 
            COALESCE(customer_record.total_purchases, 0);
        processed_count := processed_count + 1;
        
        -- 每处理1000条记录提交一次事务
        IF processed_count % 1000 = 0 THEN
            COMMIT;
            PERFORM pg_sleep(0.1); -- 短暂休息
        END IF;
    END LOOP;
    
    -- 关闭游标
    CLOSE customer_cursor;
    
    -- 返回统计信息
    RAISE NOTICE 'Processed % customers, total revenue: %', 
        processed_count, total_revenue;
    
    RETURN processed_count;
END;
$$ LANGUAGE plpgsql;
```

## 触发器基础概念

### 触发器概述

触发器是数据库管理系统中的特殊存储过程，当特定事件发生时自动执行。PostgreSQL支持多种触发器类型和事件。

### 触发器类型

```sql
-- 查看所有触发器
SELECT 
    tgname AS trigger_name,
    tgtype,
    proname AS function_name,
    tgrelid::regclass AS table_name,
    tgdeferrable,
    tginitdeferred,
    pronamespace::regnamespace AS schema_name
FROM pg_trigger t
JOIN pg_proc p ON t.tgfoid = p.oid
WHERE NOT tgisinternal
ORDER BY tgrelid, tgname;

-- 查看触发器事件信息
SELECT 
    tgname,
    CASE tgtype & 1
        WHEN 1 THEN 'ROW'
        ELSE 'STATEMENT'
    END AS trigger_level,
    CASE 
        WHEN tgtype & 2 THEN 'INSERT'
        WHEN tgtype & 4 THEN 'UPDATE'
        WHEN tgtype & 8 THEN 'DELETE'
        ELSE 'UNKNOWN'
    END AS event_type,
    tgrelid::regclass AS table_name
FROM pg_trigger
WHERE NOT tgisinternal;
```

### 创建基础触发器

```sql
-- 创建审计日志表
CREATE TABLE audit_log (
    id SERIAL PRIMARY KEY,
    table_name TEXT NOT NULL,
    operation TEXT NOT NULL,
    record_id INTEGER,
    old_values JSONB,
    new_values JSONB,
    changed_by TEXT,
    changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建触发器函数
CREATE OR REPLACE FUNCTION audit_trigger_function()
RETURNS TRIGGER AS $$
BEGIN
    -- INSERT操作
    IF TG_OP = 'INSERT' THEN
        INSERT INTO audit_log (table_name, operation, record_id, new_values, changed_by)
        VALUES (TG_TABLE_NAME, TG_OP, NEW.id, row_to_json(NEW), current_user);
        RETURN NEW;
    END IF;
    
    -- UPDATE操作
    IF TG_OP = 'UPDATE' THEN
        INSERT INTO audit_log (table_name, operation, record_id, old_values, new_values, changed_by)
        VALUES (
            TG_TABLE_NAME, 
            TG_OP, 
            NEW.id, 
            row_to_json(OLD), 
            row_to_json(NEW), 
            current_user
        );
        RETURN NEW;
    END IF;
    
    -- DELETE操作
    IF TG_OP = 'DELETE' THEN
        INSERT INTO audit_log (table_name, operation, record_id, old_values, changed_by)
        VALUES (TG_TABLE_NAME, TG_OP, OLD.id, row_to_json(OLD), current_user);
        RETURN OLD;
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器
CREATE TRIGGER audit_trigger
    AFTER INSERT OR UPDATE OR DELETE ON employees
    FOR EACH ROW
    EXECUTE FUNCTION audit_trigger_function();
```

## 行级触发器

### BEFORE触发器

```sql
-- BEFORE INSERT触发器：数据验证
CREATE OR REPLACE FUNCTION validate_user_email()
RETURNS TRIGGER AS $$
BEGIN
    -- 检查邮箱格式
    IF NEW.email !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' THEN
        RAISE EXCEPTION 'Invalid email format: %', NEW.email;
    END IF;
    
    -- 检查邮箱是否已存在
    IF EXISTS (SELECT 1 FROM users WHERE email = NEW.email AND id != COALESCE(NEW.id, 0)) THEN
        RAISE EXCEPTION 'Email already exists: %', NEW.email;
    END IF;
    
    -- 设置默认值
    NEW.created_at := COALESCE(NEW.created_at, CURRENT_TIMESTAMP);
    NEW.updated_at := CURRENT_TIMESTAMP;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建BEFORE INSERT触发器
CREATE TRIGGER validate_user_email_trigger
    BEFORE INSERT ON users
    FOR EACH ROW
    EXECUTE FUNCTION validate_user_email();

-- BEFORE UPDATE触发器：业务规则检查
CREATE OR REPLACE FUNCTION validate_salary_change()
RETURNS TRIGGER AS $$
DECLARE
    salary_change_rate NUMERIC;
    max_increase_rate NUMERIC := 0.5; -- 最大涨幅50%
BEGIN
    -- 计算薪资变更率
    salary_change_rate := (NEW.salary - OLD.salary) / OLD.salary;
    
    -- 检查涨薪幅度
    IF salary_change_rate > max_increase_rate THEN
        RAISE EXCEPTION 'Salary increase rate (%%) exceeds maximum allowed (%%)', 
            (salary_change_rate * 100)::NUMERIC(5,2),
            (max_increase_rate * 100)::NUMERIC(5,2);
    END IF;
    
    -- 更新修改时间
    NEW.updated_at := CURRENT_TIMESTAMP;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建BEFORE UPDATE触发器
CREATE TRIGGER salary_change_validation
    BEFORE UPDATE ON employees
    FOR EACH ROW
    EXECUTE FUNCTION validate_salary_change();
```

### AFTER触发器

```sql
-- AFTER INSERT触发器：自动创建关联记录
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    -- 为新用户创建默认配置
    INSERT INTO user_profiles (user_id, theme, language, email_notifications)
    VALUES (NEW.id, 'default', 'en', true);
    
    -- 初始化用户统计
    INSERT INTO user_statistics (user_id, login_count, total_spent)
    VALUES (NEW.id, 0, 0);
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建AFTER INSERT触发器
CREATE TRIGGER create_user_profile_trigger
    AFTER INSERT ON users
    FOR EACH ROW
    EXECUTE FUNCTION create_user_profile();

-- AFTER UPDATE触发器：维护聚合数据
CREATE OR REPLACE FUNCTION update_order_totals()
RETURNS TRIGGER AS $$
BEGIN
    -- 当订单状态改变时更新总计
    IF OLD.status != NEW.status THEN
        -- 如果订单被取消或完成，更新统计
        IF NEW.status IN ('cancelled', 'completed') THEN
            -- 更新用户统计
            IF OLD.status != 'completed' THEN
                UPDATE user_statistics 
                SET total_spent = total_spent - COALESCE(OLD.total_amount, 0)
                WHERE user_id = OLD.user_id;
            END IF;
        END IF;
        
        -- 如果订单完成，增加统计
        IF NEW.status = 'completed' THEN
            UPDATE user_statistics 
            SET total_spent = total_spent + COALESCE(NEW.total_amount, 0),
                completed_orders = completed_orders + 1
            WHERE user_id = NEW.user_id;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建AFTER UPDATE触发器
CREATE TRIGGER update_order_stats_trigger
    AFTER UPDATE ON orders
    FOR EACH ROW
    EXECUTE FUNCTION update_order_totals();
```

### INSTEAD OF触发器

```sql
-- 创建视图
CREATE VIEW employee_orders_view AS
SELECT 
    e.id as employee_id,
    e.name as employee_name,
    e.department_id,
    o.id as order_id,
    o.total_amount,
    o.order_date,
    o.status
FROM employees e
LEFT JOIN orders o ON e.id = o.assigned_to
ORDER BY e.id, o.order_date;

-- INSTEAD OF触发器：允许通过视图插入数据
CREATE OR REPLACE FUNCTION insert_employee_order()
RETURNS TRIGGER AS $$
DECLARE
    new_order_id INTEGER;
BEGIN
    -- 在视图上插入数据时，实际插入到orders表
    INSERT INTO orders (
        user_id,
        total_amount,
        order_date,
        status,
        assigned_to
    ) VALUES (
        NEW.user_id,
        NEW.total_amount,
        COALESCE(NEW.order_date, CURRENT_DATE),
        COALESCE(NEW.status, 'pending'),
        NEW.employee_id
    ) RETURNING id INTO new_order_id;
    
    -- 返回插入的记录
    NEW.order_id := new_order_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建INSTEAD OF触发器
CREATE TRIGGER insert_employee_order_trigger
    INSTEAD OF INSERT ON employee_orders_view
    FOR EACH ROW
    EXECUTE FUNCTION insert_employee_order();
```

## 语句级触发器

### 语句级触发器基础

```sql
-- 语句级触发器：统计操作数量
CREATE OR REPLACE FUNCTION log_bulk_operations()
RETURNS TRIGGER AS $$
BEGIN
    -- 记录批量操作信息
    INSERT INTO operation_log (
        table_name,
        operation,
        affected_rows,
        executed_by,
        execution_time
    ) VALUES (
        TG_TABLE_NAME,
        TG_OP,
        COALESCE(NEW.id, 0),
        current_user,
        CURRENT_TIMESTAMP
    );
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- 创建语句级触发器
CREATE TRIGGER log_bulk_operations_trigger
    AFTER INSERT OR UPDATE OR DELETE ON orders
    FOR EACH STATEMENT
    EXECUTE FUNCTION log_bulk_operations();

-- 复杂的语句级触发器：数据完整性检查
CREATE OR REPLACE FUNCTION validate_bulk_operations()
RETURNS TRIGGER AS $$
DECLARE
    max_order_amount NUMERIC := 10000;
    affected_count INTEGER;
BEGIN
    -- 检查大批量操作
    GET DIAGNOSTICS affected_count = ROW_COUNT;
    
    IF affected_count > 100 AND TG_OP = 'UPDATE' THEN
        RAISE NOTICE 'Large batch update detected: % rows affected in %', 
            affected_count, TG_TABLE_NAME;
    END IF;
    
    -- 记录敏感操作
    IF TG_OP = 'DELETE' AND affected_count > 10 THEN
        INSERT INTO security_alerts (
            alert_type,
            table_name,
            operation,
            affected_rows,
            executed_by,
            description
        ) VALUES (
            'BULK_DELETE',
            TG_TABLE_NAME,
            TG_OP,
            affected_count,
            current_user,
            format('Large delete operation performed by %s', current_user)
        );
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- 创建复杂语句级触发器
CREATE TRIGGER validate_bulk_ops_trigger
    AFTER INSERT OR UPDATE OR DELETE ON orders
    FOR EACH STATEMENT
    EXECUTE FUNCTION validate_bulk_operations();
```

## 触发器实战应用

### 电商系统触发器

```sql
-- 电商系统库存管理触发器
-- 库存变更记录表
CREATE TABLE inventory_changes (
    id SERIAL PRIMARY KEY,
    product_id INTEGER,
    change_type TEXT, -- 'sale', 'restock', 'adjustment'
    old_quantity INTEGER,
    new_quantity INTEGER,
    quantity_change INTEGER,
    order_id INTEGER,
    reason TEXT,
    changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    changed_by TEXT
);

-- 库存变更触发器
CREATE OR REPLACE FUNCTION update_inventory()
RETURNS TRIGGER AS $$
DECLARE
    old_qty INTEGER;
    new_qty INTEGER;
    qty_change INTEGER;
    change_reason TEXT;
BEGIN
    -- 计算数量变化
    IF TG_OP = 'INSERT' THEN
        -- 新订单，库存减少
        old_qty := COALESCE(inventory.quantity, 0);
        new_qty := old_qty - NEW.quantity;
        qty_change := -NEW.quantity;
        change_reason := 'sale';
    ELSIF TG_OP = 'DELETE' THEN
        -- 订单删除，库存增加
        old_qty := OLD.quantity;
        new_qty := old_qty + OLD.quantity;
        qty_change := OLD.quantity;
        change_reason := 'cancellation';
    ELSE
        -- 更新操作，计算差异
        old_qty := OLD.quantity;
        new_qty := NEW.quantity;
        qty_change := new_qty - old_qty;
        change_reason := 'adjustment';
    END IF;
    
    -- 记录库存变更
    INSERT INTO inventory_changes (
        product_id,
        change_type,
        old_quantity,
        new_quantity,
        quantity_change,
        order_id,
        reason,
        changed_by
    ) VALUES (
        NEW.product_id,
        change_reason,
        old_qty,
        new_qty,
        qty_change,
        COALESCE(NEW.order_id, OLD.order_id),
        'Automatic inventory update',
        current_user
    );
    
    -- 更新主库存表
    INSERT INTO inventory (product_id, quantity, updated_at)
    VALUES (NEW.product_id, new_qty, CURRENT_TIMESTAMP)
    ON CONFLICT (product_id) 
    DO UPDATE SET 
        quantity = new_qty,
        updated_at = CURRENT_TIMESTAMP;
    
    -- 检查库存预警
    IF new_qty < 10 THEN
        INSERT INTO inventory_alerts (
            product_id,
            alert_type,
            current_quantity,
            threshold,
            message,
            created_at
        ) VALUES (
            NEW.product_id,
            'LOW_STOCK',
            new_qty,
            10,
            format('Product %s has low stock: %s units', NEW.product_id, new_qty),
            CURRENT_TIMESTAMP
        );
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- 创建订单项触发器
CREATE TRIGGER order_item_inventory_trigger
    AFTER INSERT OR UPDATE OR DELETE ON order_items
    FOR EACH ROW
    EXECUTE FUNCTION update_inventory();
```

### 数据同步触发器

```sql
-- 跨表数据同步触发器
-- 员工信息变更同步到薪资表
CREATE OR REPLACE FUNCTION sync_employee_salary()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        -- 新员工自动创建薪资记录
        INSERT INTO employee_salaries (
            employee_id,
            base_salary,
            effective_date,
            created_at
        ) VALUES (
            NEW.id,
            COALESCE(NEW.salary, 50000),
            CURRENT_DATE,
            CURRENT_TIMESTAMP
        );
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        -- 薪资变更时更新薪资表
        IF OLD.salary != NEW.salary THEN
            UPDATE employee_salaries 
            SET 
                end_date = CURRENT_DATE - INTERVAL '1 day',
                updated_at = CURRENT_TIMESTAMP
            WHERE employee_id = NEW.id 
                AND end_date IS NULL;
            
            INSERT INTO employee_salaries (
                employee_id,
                base_salary,
                effective_date,
                created_at
            ) VALUES (
                NEW.id,
                NEW.salary,
                CURRENT_DATE,
                CURRENT_TIMESTAMP
            );
        END IF;
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        -- 员工删除时标记薪资记录结束
        UPDATE employee_salaries 
        SET 
            end_date = CURRENT_DATE - INTERVAL '1 day',
            updated_at = CURRENT_TIMESTAMP
        WHERE employee_id = OLD.id 
            AND end_date IS NULL;
        RETURN OLD;
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- 创建员工信息同步触发器
CREATE TRIGGER employee_salary_sync_trigger
    AFTER INSERT OR UPDATE OR DELETE ON employees
    FOR EACH ROW
    EXECUTE FUNCTION sync_employee_salary();
```

## 性能优化策略

### 触发器性能优化

```sql
-- 使用条件触发器减少不必要的执行
CREATE TRIGGER optimized_audit_trigger
    AFTER INSERT OR UPDATE OF status ON orders
    FOR EACH ROW
    WHEN (OLD.status IS DISTINCT FROM NEW.status)
    EXECUTE FUNCTION audit_trigger_function();

-- 分阶段处理大量数据
CREATE OR REPLACE FUNCTION bulk_audit_trigger()
RETURNS TRIGGER AS $$
BEGIN
    -- 批量插入到临时表
    INSERT INTO temp_audit_log (table_name, operation, record_id, data, created_at)
    VALUES (
        TG_TABLE_NAME,
        TG_OP,
        COALESCE(NEW.id, OLD.id),
        COALESCE(row_to_json(NEW), row_to_json(OLD)),
        CURRENT_TIMESTAMP
    );
    
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- 延迟执行大量操作
CREATE OR REPLACE FUNCTION deferred_bulk_operation()
RETURNS TRIGGER AS $$
BEGIN
    -- 提交当前事务后执行
    PERFORM pg_notify('bulk_process', format(
        '{"table": "%s", "operation": "%s", "record_id": %s}',
        TG_TABLE_NAME, TG_OP, COALESCE(NEW.id, OLD.id)
    ));
    
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;
```

### 异步处理触发器

```sql
-- 创建异步通知处理器
CREATE OR REPLACE FUNCTION process_async_notification()
RETURNS TRIGGER AS $$
BEGIN
    -- 发送异步通知，不阻塞主事务
    PERFORM pg_notify('inventory_update', json_build_object(
        'product_id', NEW.product_id,
        'quantity_change', NEW.quantity_change,
        'timestamp', CURRENT_TIMESTAMP
    )::text);
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 使用NOTIFY进行异步通信
-- 在客户端监听通知：
-- LISTEN inventory_update;
```

## 最佳实践与模式

### 触发器设计模式

```sql
-- 1. 审计日志模式
CREATE OR REPLACE FUNCTION create_audit_trigger(
    table_name TEXT,
    columns_to_audit TEXT[] DEFAULT NULL
) RETURNS VOID AS $$
DECLARE
    trigger_function TEXT;
BEGIN
    -- 生成动态触发器函数
    trigger_function := format('
        CREATE OR REPLACE FUNCTION audit_%s_trigger()
        RETURNS TRIGGER AS $$
        BEGIN
            IF TG_OP = ''INSERT'' THEN
                INSERT INTO audit_log (table_name, operation, record_data, created_by)
                VALUES (''%s'', TG_OP, row_to_json(NEW), current_user);
                RETURN NEW;
            ELSIF TG_OP = ''UPDATE'' THEN
                INSERT INTO audit_log (table_name, operation, record_data, old_data, created_by)
                VALUES (''%s'', TG_OP, row_to_json(NEW), row_to_json(OLD), current_user);
                RETURN NEW;
            ELSIF TG_OP = ''DELETE'' THEN
                INSERT INTO audit_log (table_name, operation, record_data, created_by)
                VALUES (''%s'', TG_OP, row_to_json(OLD), current_user);
                RETURN OLD;
            END IF;
            RETURN NULL;
        END;
        $$ LANGUAGE plpgsql', table_name, table_name, table_name, table_name);
    
    -- 执行动态函数创建
    EXECUTE trigger_function;
    
    -- 创建触发器
    EXECUTE format('
        DROP TRIGGER IF EXISTS audit_%s_trigger ON %s;
        CREATE TRIGGER audit_%s_trigger
            AFTER INSERT OR UPDATE OR DELETE ON %s
            FOR EACH ROW
            EXECUTE FUNCTION audit_%s_trigger()', 
        table_name, table_name, table_name, table_name, table_name);
        
END;
$$ LANGUAGE plpgsql;

-- 使用动态触发器创建器
SELECT create_audit_trigger('employees');
SELECT create_audit_trigger('orders');
SELECT create_audit_trigger('products');
```

### 复合触发器

```sql
-- 复合触发器：在一个函数中处理多个操作
CREATE OR REPLACE FUNCTION comprehensive_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        -- 处理插入操作
        NEW.created_at := CURRENT_TIMESTAMP;
        NEW.updated_at := CURRENT_TIMESTAMP;
        
        -- 记录变更历史
        INSERT INTO change_log (table_name, operation, record_id, new_data, timestamp)
        VALUES (TG_TABLE_NAME, TG_OP, NEW.id, row_to_json(NEW), CURRENT_TIMESTAMP);
        
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        -- 处理更新操作
        NEW.updated_at := CURRENT_TIMESTAMP;
        
        -- 检查敏感字段变更
        IF OLD.password_hash IS DISTINCT FROM NEW.password_hash THEN
            INSERT INTO security_log (event_type, user_id, details, timestamp)
            VALUES ('PASSWORD_CHANGE', NEW.id, 'Password has been changed', CURRENT_TIMESTAMP);
        END IF;
        
        -- 记录变更历史
        INSERT INTO change_log (table_name, operation, record_id, old_data, new_data, timestamp)
        VALUES (TG_TABLE_NAME, TG_OP, NEW.id, row_to_json(OLD), row_to_json(NEW), CURRENT_TIMESTAMP);
        
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        -- 处理删除操作
        INSERT INTO change_log (table_name, operation, record_id, old_data, timestamp)
        VALUES (TG_TABLE_NAME, TG_OP, OLD.id, row_to_json(OLD), CURRENT_TIMESTAMP);
        
        RETURN OLD;
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

### 触发器监控和维护

```sql
-- 触发器性能监控视图
CREATE VIEW trigger_performance AS
SELECT 
    schemaname,
    tablename,
    triggername,
    tgfoid::regprocedure AS function_name,
    pg_relation_size(pg_class.oid) AS table_size,
    last_stat_reset
FROM pg_trigger t
JOIN pg_class ON t.tgrelid = pg_class.oid
JOIN pg_namespace ON pg_class.relnamespace = pg_namespace.oid
WHERE NOT tgisinternal
ORDER BY schemaname, tablename;

-- 触发器使用统计
CREATE OR REPLACE FUNCTION analyze_trigger_usage()
RETURNS TABLE(
    trigger_name TEXT,
    table_name TEXT,
    execution_count BIGINT,
    total_time INTERVAL,
    avg_time INTERVAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        t.tgname,
        c.relname::TEXT,
        s.calls,
        s.total_time,
        s.mean_time
    FROM pg_stat_user_tables s
    JOIN pg_class c ON c.oid = s.relid
    JOIN pg_trigger t ON t.tgrelid = s.relid
    WHERE NOT t.tgisinternal
    ORDER BY s.calls DESC;
END;
$$ LANGUAGE plpgsql;
```

## 总结

PostgreSQL的函数和触发器系统提供了强大的编程能力，让我们能够构建复杂的业务逻辑和数据处理流程。本专题的主要收获包括：

### 核心概念掌握
1. **函数系统架构**：了解不同类型的函数和编程语言
2. **PL/pgSQL语法**：掌握过程式编程和控制结构
3. **触发器机制**：理解事件驱动编程和自动执行
4. **性能优化**：学会优化函数和触发器性能

### 实际应用技能
1. **数据验证**：使用触发器确保数据完整性
2. **审计日志**：自动记录数据变更历史
3. **业务逻辑**：实现复杂的业务规则
4. **数据同步**：维护多个表之间的数据一致性

### 最佳实践总结
- 使用BEFORE触发器进行数据验证和修改
- 使用AFTER触发器进行日志记录和统计更新
- 避免在触发器中执行耗时操作
- 使用条件触发器减少不必要的执行
- 实现触发器性能监控和维护

掌握这些高级特性，能够让你构建出更加健壮、高效的数据库应用程序。