# 第4章：数据类型与表设计

在上一章中，我们学习了基本的SQL语法操作。现在我们将深入了解PostgreSQL的数据类型以及如何设计高效的数据库表结构。掌握这些知识对于构建可靠、高性能的数据库应用至关重要。

## 4.1 PostgreSQL数据类型概览

PostgreSQL提供了丰富的数据类型来满足各种应用场景的需求。了解这些数据类型的特点和适用场景，有助于我们设计出更加合理的数据库结构。

### 4.1.1 基本数据类型

#### 数值类型 (Numeric Types)

PostgreSQL支持多种数值类型，适用于不同的精度和范围需求：

| 类型 | 描述 | 范围 | 存储大小 |
|------|------|------|----------|
| SMALLINT | 小范围整数 | -32768 到 32767 | 2字节 |
| INTEGER | 标准整数 | -2147483648 到 2147483647 | 4字节 |
| BIGINT | 大范围整数 | -9223372036854775808 到 9223372036854775807 | 8字节 |
| DECIMAL/NUMERIC | 精确数值 | 用户指定精度 | 可变 |
| REAL | 单精度浮点数 | 6位十进制精度 | 4字节 |
| DOUBLE PRECISION | 双精度浮点数 | 15位十进制精度 | 8字节 |

```sql
-- 示例：不同数值类型的使用
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    price NUMERIC(10,2),     -- 价格精确到分
    quantity INTEGER,        -- 库存数量
    rating REAL             -- 用户评分
);
```

#### 字符串类型 (String Types)

PostgreSQL提供多种字符串类型来处理文本数据：

| 类型 | 描述 | 特点 |
|------|------|------|
| CHAR(n) | 固定长度字符 | 总是占用n个字符空间 |
| VARCHAR(n) | 可变长度字符 | 最多n个字符，只占用实际长度空间 |
| TEXT | 可变长度文本 | 无长度限制 |

```sql
-- 示例：字符串类型的使用
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,   -- 用户名
    email VARCHAR(255) NOT NULL,           -- 邮箱地址
    bio TEXT                               -- 个人简介
);
```

### 4.1.2 时间日期类型

PostgreSQL提供丰富的时间日期类型来处理时间相关的数据：

| 类型 | 描述 | 包含信息 |
|------|------|----------|
| DATE | 日期 | 年、月、日 |
| TIME | 时间 | 时、分、秒 |
| TIMESTAMP | 日期和时间 | 年、月、日、时、分、秒 |
| TIMESTAMPTZ | 带时区的时间戳 | 日期时间+时区信息 |
| INTERVAL | 时间间隔 | 两个时间点之间的差值 |

```sql
-- 示例：时间日期类型的使用
CREATE TABLE events (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    event_date DATE,                    -- 活动日期
    start_time TIME,                   -- 开始时间
    created_at TIMESTAMP DEFAULT NOW(), -- 创建时间
    updated_at TIMESTAMPTZ              -- 更新时间（带时区）
);
```

### 4.1.3 JSON类型

PostgreSQL对JSON格式的支持非常强大，提供了两种JSON类型：

| 类型 | 描述 | 特点 |
|------|------|------|
| JSON | 文本形式存储JSON | 保持原始格式 |
| JSONB | 二进制形式存储JSON | 更快的处理速度，支持索引 |

```sql
-- 示例：JSON类型的使用
CREATE TABLE user_profiles (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    preferences JSON,         -- 用户偏好设置
    metadata JSONB            -- 元数据（推荐使用JSONB）
);

-- 插入JSON数据示例
INSERT INTO user_profiles (user_id, preferences, metadata) VALUES 
(1, '{"theme": "dark", "notifications": true}', 
    '{"last_login": "2023-05-15T10:30:00Z", "device": "mobile"}');
```

## 4.2 表设计最佳实践

良好的表设计是数据库性能和可维护性的基础。以下是几个关键的设计原则：

### 4.2.1 主键设计

主键是表中唯一标识每一行记录的字段或字段组合。设计良好的主键应该具备以下特点：

1. 唯一性：每个表只能有一个主键，且主键值必须唯一
2. 非空性：主键字段不允许为空(NULL)
3. 稳定性：主键值一旦确定就不应更改
4. 简洁性：尽量使用单一字段作为主键

```sql
-- 推荐做法：使用SERIAL自增主键
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,    -- 自动递增主键
    customer_id INTEGER NOT NULL,
    order_date DATE NOT NULL,
    total_amount NUMERIC(10,2)
);

-- 或者使用UUID作为主键（适用于分布式系统）
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE distributed_orders (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),  -- UUID主键
    customer_id INTEGER NOT NULL,
    order_date DATE NOT NULL,
    total_amount NUMERIC(10,2)
);
```

### 4.2.2 外键约束

外键用于建立表与表之间的关联关系，确保数据的一致性和完整性：

```sql
-- 创建父表
CREATE TABLE customers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL
);

-- 创建子表，使用外键关联
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    customer_id INTEGER NOT NULL REFERENCES customers(id) ON DELETE CASCADE,
    order_date DATE NOT NULL,
    total_amount NUMERIC(10,2)
);
```

外键约束选项：
- `ON DELETE CASCADE`：删除父记录时自动删除相关子记录
- `ON DELETE SET NULL`：删除父记录时将外键字段设为NULL
- `ON DELETE RESTRICT`：如果存在相关子记录则禁止删除父记录

### 4.2.3 其他重要约束

除了主键和外键，还有其他几种重要的约束类型：

```sql
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,           -- 非空约束
    sku VARCHAR(50) UNIQUE NOT NULL,      -- 唯一性约束
    price NUMERIC(10,2) CHECK (price > 0), -- 检查约束
    category VARCHAR(50) DEFAULT 'General', -- 默认值约束
    discontinued BOOLEAN DEFAULT false
);
```

## 4.3 实践练习

让我们通过一个完整的示例来巩固所学知识：

```sql
-- 创建一个电子商务系统的数据库表结构

-- 1. 用户表
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    last_login TIMESTAMPTZ
);

-- 2. 分类表
CREATE TABLE categories (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL,
    description TEXT,
    parent_id INTEGER REFERENCES categories(id)
);

-- 3. 产品表
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    price NUMERIC(10,2) CHECK (price >= 0),
    category_id INTEGER REFERENCES categories(id),
    inventory_count INTEGER DEFAULT 0 CHECK (inventory_count >= 0),
    specifications JSONB,  -- 产品规格信息
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 4. 订单表
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id),
    order_date DATE NOT NULL DEFAULT CURRENT_DATE,
    total_amount NUMERIC(12,2) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'confirmed', 'shipped', 'delivered', 'cancelled')),
    shipping_address TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 5. 订单详情表
CREATE TABLE order_items (
    id SERIAL PRIMARY KEY,
    order_id INTEGER NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    product_id INTEGER NOT NULL REFERENCES products(id),
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    unit_price NUMERIC(10,2) NOT NULL,
    total_price NUMERIC(10,2) NOT NULL
);
```

## 4.4 总结

在本章中，我们学习了：

1. PostgreSQL的主要数据类型及其适用场景
2. 如何选择合适的数据类型来优化存储和性能
3. 表设计的基本原则和最佳实践
4. 主键、外键和其他约束的重要性
5. 通过实际案例演示了完整的表结构设计

下一章我们将深入学习PostgreSQL中的高级查询技术，包括连接查询、子查询、窗口函数等内容，帮助您编写更复杂、更高效的SQL查询语句。