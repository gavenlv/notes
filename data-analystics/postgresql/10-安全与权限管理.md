# PostgreSQL高级专题：安全与权限管理

## 概述

数据库安全是现代企业信息系统的核心要求，涉及用户身份认证、权限控制、数据加密、审计合规等多个层面。本专题深入探讨PostgreSQL的安全机制，包括用户管理、角色权限、数据加密、安全审计、合规要求以及高级安全配置，帮助你构建全面的数据库安全防护体系。

## 目录

1. [安全概述与威胁模型](#安全概述与威胁模型)
2. [用户身份认证](#用户身份认证)
3. [角色与权限管理](#角色与权限管理)
4. [行级安全策略(RLS)](#行级安全策略rls)
5. [数据加密技术](#数据加密技术)
6. [网络访问控制](#网络访问控制)
7. [安全审计与日志](#安全审计与日志)
8. [合规与标准](#合规与标准)
9. [安全配置最佳实践](#安全配置最佳实践)
10. [威胁检测与响应](#威胁检测与响应)
11. [安全监控工具](#安全监控工具)
12. [灾难恢复与安全](#灾难恢复与安全)

## 安全概述与威胁模型

### 威胁类型分析

```sql
-- 创建威胁检测表
CREATE TABLE security_threats (
    id SERIAL PRIMARY KEY,
    threat_type TEXT NOT NULL,
    threat_level TEXT, -- 'low', 'medium', 'high', 'critical'
    description TEXT,
    detection_queries TEXT,
    mitigation_strategies TEXT,
    first_detected TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT true
);

-- 创建威胁历史记录表
CREATE TABLE threat_incidents (
    id SERIAL PRIMARY KEY,
    threat_id INTEGER REFERENCES security_threats(id),
    incident_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    source_ip INET,
    target_object TEXT,
    attempted_action TEXT,
    detection_method TEXT,
    severity_score INTEGER,
    status TEXT, -- 'open', 'investigating', 'resolved', 'false_positive'
    response_actions TEXT,
    resolved_at TIMESTAMP,
    notes TEXT
);

-- 插入常见威胁类型
INSERT INTO security_threats (threat_type, threat_level, description, detection_queries, mitigation_strategies)
VALUES 
    ('SQL注入', 'critical', 
     '恶意SQL代码注入，可能导致数据泄露、修改或删除',
     'SELECT * FROM pg_stat_statements WHERE query LIKE ''%''''%'' OR query LIKE ''%% UNION %%'';',
     '使用参数化查询、输入验证、最小权限原则'),
     
    ('暴力破解', 'high',
     '通过大量尝试破解用户密码',
     'SELECT * FROM pg_stat_activity WHERE state = ''active'' AND query_start < now() - interval ''5 minutes'';',
     '密码策略、账户锁定、IP白名单'),
     
    ('权限提升', 'critical',
     '非授权用户尝试获得更高权限',
     'SELECT * FROM pg_stat_user_tables WHERE relname LIKE ''%admin%'' OR relname LIKE ''%config%'';',
     '最小权限原则、定期权限审计'),
     
    ('数据泄露', 'critical',
     '非授权访问敏感数据',
     'SELECT * FROM pg_stat_statements WHERE query ILIKE ''%select%password%'';',
     '数据分类、行级安全、加密'),
     
    ('拒绝服务', 'high',
     '通过大量请求使数据库服务不可用',
     'SELECT * FROM pg_stat_activity WHERE state = ''active'' AND query_start < now() - interval ''30 minutes'';',
     '连接限制、查询超时、资源配额'),
     
    ('内部威胁', 'medium',
     '授权用户滥用权限或访问超出范围的数据',
     'SELECT * FROM pg_stat_statements WHERE userid != (SELECT oid FROM pg_user WHERE usename = current_user);',
     '职责分离、审计跟踪、异常监控');

-- 创建安全检查视图
CREATE OR REPLACE FUNCTION get_security_status()
RETURNS TABLE(
    check_type TEXT,
    status TEXT,
    details JSONB,
    recommendation TEXT,
    risk_level TEXT
) AS $$
BEGIN
    -- 检查弱密码用户
    RETURN QUERY
    SELECT 
        'weak_passwords'::TEXT,
        CASE WHEN COUNT(*) = 0 THEN 'good' ELSE 'warning' END,
        jsonb_build_object('user_count', COUNT(*), 'users', array_agg(usename)),
        'Enforce strong password policy'::TEXT,
        CASE WHEN COUNT(*) > 0 THEN 'medium' ELSE 'low' END
    FROM pg_user 
    WHERE usename NOT IN ('postgres', 'replicator');
    
    -- 检查长期运行的查询
    RETURN QUERY
    SELECT 
        'long_running_queries'::TEXT,
        CASE WHEN COUNT(*) = 0 THEN 'good' ELSE 'warning' END,
        jsonb_build_object('query_count', COUNT(*), 'queries', (
            SELECT array_agg(query)
            FROM pg_stat_activity 
            WHERE state = 'active' AND query_start < now() - interval '10 minutes'
            LIMIT 10
        )),
        'Review and optimize slow queries'::TEXT,
        CASE WHEN COUNT(*) > 5 THEN 'high' ELSE 'low' END
    FROM pg_stat_activity 
    WHERE state = 'active' AND query_start < now() - interval '10 minutes';
    
    -- 检查失败的认证尝试
    RETURN QUERY
    SELECT 
        'failed_authentications'::TEXT,
        CASE WHEN COUNT(*) < 10 THEN 'good' ELSE 'warning' END,
        jsonb_build_object('failure_count', COUNT(*), 'last_failures', (
            SELECT array_agg(timestamp)
            FROM pg_catalog.pg_logical_message
            WHERE message LIKE '%authentication%failed%'
            ORDER BY timestamp DESC
            LIMIT 5
        )),
        'Monitor and investigate authentication failures'::TEXT,
        CASE WHEN COUNT(*) > 20 THEN 'high' ELSE 'low' END
    FROM pg_catalog.pg_logical_message
    WHERE message LIKE '%authentication%failed%'
        AND timestamp > now() - interval '1 hour';
    
    -- 检查异常数据库活动
    RETURN QUERY
    SELECT 
        'suspicious_activities'::TEXT,
        'good',
        jsonb_build_object(
            'recent_connections', (SELECT COUNT(*) FROM pg_stat_activity WHERE now() - query_start < interval '5 minutes'),
            'unique_ips', (SELECT COUNT(DISTINCT client_addr) FROM pg_stat_activity),
            'privileged_users', (SELECT COUNT(*) FROM pg_roles WHERE rolsuper OR rolcreaterole)
        ),
        'Monitor for unusual database access patterns'::TEXT,
        'low';
        
END;
$$ LANGUAGE plpgsql;

-- 执行安全状态检查
SELECT * FROM get_security_status();
```

## 用户身份认证

### 用户管理策略

```sql
-- 创建用户管理策略表
CREATE TABLE user_management_policies (
    id SERIAL PRIMARY KEY,
    policy_name TEXT NOT NULL,
    policy_type TEXT, -- 'password', 'session', 'access', 'audit'
    policy_config JSONB,
    is_enforced BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入用户管理策略
INSERT INTO user_management_policies (policy_name, policy_type, policy_config)
VALUES 
    ('strong_password_policy', 'password', 
     jsonb_build_object(
         'min_length', 12,
         'require_uppercase', true,
         'require_lowercase', true,
         'require_numbers', true,
         'require_special_chars', true,
         'max_age_days', 90,
         'history_count', 12
     )),
     
    ('session_timeout_policy', 'session',
     jsonb_build_object(
         'idle_timeout_minutes', 30,
         'max_session_duration_hours', 8,
         'concurrent_sessions', 2,
         'session_warning_minutes', 5
     )),
     
    ('access_restriction_policy', 'access',
     jsonb_build_object(
         'allowed_ip_ranges', ARRAY['192.168.1.0/24', '10.0.0.0/8'],
         'blocked_ip_ranges', ARRAY['0.0.0.0/0'],
         'allowed_time_range', '08:00-18:00',
         'require_ssl', true
     ));

-- 创建用户会话管理函数
CREATE OR REPLACE FUNCTION manage_user_sessions(
    target_user TEXT DEFAULT NULL,
    action TEXT
) RETURNS TABLE(
    user_name TEXT,
    session_info JSONB,
    action_result TEXT
) AS $$
DECLARE
    user_session RECORD;
    session_count INTEGER;
BEGIN
    -- 查看当前用户会话
    FOR user_session IN
        SELECT 
            usename as username,
            state,
            query_start,
            now() - query_start as duration,
            client_addr,
            application_name,
            pid
        FROM pg_stat_activity 
        WHERE (target_user IS NULL OR usename = target_user)
            AND state = 'active'
    LOOP
        -- 会话计数
        SELECT COUNT(*) INTO session_count
        FROM pg_stat_activity 
        WHERE usename = user_session.username AND state = 'active';
        
        RETURN QUERY
        SELECT 
            user_session.username::TEXT,
            jsonb_build_object(
                'state', user_session.state,
                'query_start', user_session.query_start,
                'duration', user_session.duration,
                'client_addr', user_session.client_addr,
                'application_name', user_session.application_name,
                'pid', user_session.pid,
                'concurrent_sessions', session_count
            ),
            CASE action
                WHEN 'list' THEN 'session_listed'
                WHEN 'kill_idle' THEN 
                    CASE 
                        WHEN user_session.duration > interval '30 minutes' THEN 'session_killed'
                        ELSE 'session_preserved'
                    END
                ELSE 'no_action'
            END;
        
        -- 执行会话终止操作
        IF action = 'kill_idle' AND user_session.duration > interval '30 minutes' THEN
            PERFORM pg_terminate_backend(user_session.pid);
        END IF;
    END LOOP;
    
END;
$$ LANGUAGE plpgsql;

-- 管理用户会话
SELECT * FROM manage_user_sessions(NULL, 'list');
SELECT * FROM manage_user_sessions('app_user', 'kill_idle');
```

### 多因素认证(MFA)

```sql
-- 创建MFA配置表
CREATE TABLE mfa_configurations (
    id SERIAL PRIMARY KEY,
    user_name TEXT NOT NULL,
    mfa_method TEXT, -- 'totp', 'sms', 'email', 'hardware'
    secret_key TEXT,
    backup_codes TEXT[],
    is_enabled BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_used TIMESTAMP,
    failure_count INTEGER DEFAULT 0,
    is_locked BOOLEAN DEFAULT false
);

-- 创建MFA审计表
CREATE TABLE mfa_audit_log (
    id SERIAL PRIMARY KEY,
    user_name TEXT,
    action TEXT, -- 'login', 'verify', 'disable', 'reset'
    mfa_method TEXT,
    success BOOLEAN,
    ip_address INET,
    user_agent TEXT,
    failure_reason TEXT,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建MFA验证函数
CREATE OR REPLACE FUNCTION verify_mfa_token(
    user_name TEXT,
    token_code TEXT,
    backup_code_used TEXT DEFAULT NULL
) RETURNS TABLE(
    verification_result TEXT,
    remaining_attempts INTEGER,
    lockout_until TIMESTAMP,
    requires_new_backup_codes BOOLEAN
) AS $$
DECLARE
    mfa_record RECORD;
    current_failures INTEGER;
    lockout_threshold INTEGER := 3;
    lockout_duration INTERVAL := interval '30 minutes';
BEGIN
    -- 查找MFA配置
    SELECT * INTO mfa_record
    FROM mfa_configurations
    WHERE user_name = $1 AND is_enabled = true;
    
    IF NOT FOUND THEN
        RETURN QUERY
        SELECT 
            'MFA_NOT_CONFIGURED'::TEXT,
            0::INTEGER,
            NULL::TIMESTAMP,
            false;
        RETURN;
    END IF;
    
    -- 检查账户是否被锁定
    IF mfa_record.is_locked THEN
        RETURN QUERY
        SELECT 
            'ACCOUNT_LOCKED'::TEXT,
            0::INTEGER,
            NULL::TIMESTAMP,
            false;
        RETURN;
    END IF;
    
    -- 验证TOTP令牌（示例实现）
    -- 实际实现需要使用适当的TOTP库
    current_failures := mfa_record.failure_count + 1;
    
    -- 记录审计日志
    INSERT INTO mfa_audit_log (user_name, action, mfa_method, success, ip_address, user_agent, failure_reason)
    VALUES (
        user_name,
        'verify',
        mfa_record.mfa_method,
        false,
        '127.0.0.1'::INET,
        'PostgreSQL_Client',
        'Token validation failed'
    );
    
    -- 检查失败次数
    IF current_failures >= lockout_threshold THEN
        UPDATE mfa_configurations
        SET is_locked = true,
            failure_count = current_failures
        WHERE user_name = user_name;
        
        RETURN QUERY
        SELECT 
            'LOCKED'::TEXT,
            0::INTEGER,
            now() + lockout_duration,
            false;
    ELSE
        UPDATE mfa_configurations
        SET failure_count = current_failures
        WHERE user_name = user_name;
        
        RETURN QUERY
        SELECT 
            'INVALID_TOKEN'::TEXT,
            lockout_threshold - current_failures,
            NULL::TIMESTAMP,
            false;
    END IF;
    
END;
$$ LANGUAGE plpgsql;

-- 配置用户MFA
INSERT INTO mfa_configurations (user_name, mfa_method, secret_key, backup_codes, is_enabled)
VALUES (
    'app_admin',
    'totp',
    'base32_secret_key_here',
    ARRAY['12345678', '87654321', '11223344', '44332211'],
    true
);

-- 验证MFA令牌
SELECT * FROM verify_mfa_token('app_admin', '123456');
```

## 角色与权限管理

### 角色层次结构

```sql
-- 创建角色层次结构表
CREATE TABLE role_hierarchy (
    id SERIAL PRIMARY KEY,
    role_name TEXT NOT NULL,
    parent_role TEXT,
    role_type TEXT, -- 'application', 'reporting', 'admin', 'read_only'
    description TEXT,
    is_system_role BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    permissions JSONB
);

-- 创建权限分配表
CREATE TABLE permission_assignments (
    id SERIAL PRIMARY KEY,
    role_name TEXT,
    privilege_type TEXT, -- 'select', 'insert', 'update', 'delete', 'execute'
    object_type TEXT, -- 'schema', 'table', 'sequence', 'function'
    object_name TEXT,
    granted_by TEXT,
    granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    with_grant_option BOOLEAN DEFAULT false,
    is_active BOOLEAN DEFAULT true
);

-- 创建应用角色层次
INSERT INTO role_hierarchy (role_name, parent_role, role_type, description, permissions)
VALUES 
    ('app_admin', NULL, 'admin', 'Application administrator with full access', 
     jsonb_build_object('schema_access', 'all', 'object_creation', true, 'user_management', true)),
     
    ('app_developer', 'app_admin', 'application', 'Application developer with development access',
     jsonb_build_object('schema_access', 'development_only', 'object_creation', true, 'data_modification', true)),
     
    ('app_user', 'app_developer', 'application', 'Regular application user with read/write access',
     jsonb_build_object('schema_access', 'application', 'object_creation', false, 'data_modification', true)),
     
    ('report_reader', NULL, 'reporting', 'Read-only access for reporting purposes',
     jsonb_build_object('schema_access', 'reporting', 'object_creation', false, 'data_modification', false)),
     
    ('data_analyst', 'report_reader', 'reporting', 'Data analyst with extended read access',
     jsonb_build_object('schema_access', 'analytics', 'object_creation', false, 'data_modification', false));

-- 创建权限管理函数
CREATE OR REPLACE FUNCTION grant_permissions(
    target_role TEXT,
    privilege_type TEXT,
    object_type TEXT,
    object_name TEXT,
    grantor_role TEXT DEFAULT 'app_admin',
    with_grant BOOLEAN DEFAULT false
) RETURNS TABLE(
    operation_status TEXT,
    sql_command TEXT,
    permission_details JSONB
) AS $$
DECLARE
    sql_statement TEXT;
    current_role TEXT;
BEGIN
    -- 获取当前角色
    SELECT current_setting('role_name') INTO current_role;
    
    -- 构建权限授予SQL
    sql_statement := format('GRANT %s ON %s %s TO %s%s', 
                           privilege_type, 
                           object_type, 
                           object_name,
                           target_role,
                           CASE WHEN with_grant THEN ' WITH GRANT OPTION' ELSE '' END);
    
    -- 记录权限分配
    INSERT INTO permission_assignments (
        role_name, privilege_type, object_type, object_name, 
        granted_by, with_grant_option
    ) VALUES (
        target_role, privilege_type, object_type, object_name,
        current_role, with_grant
    );
    
    RETURN QUERY
    SELECT 
        'permission_granted'::TEXT,
        sql_statement,
        jsonb_build_object(
            'role', target_role,
            'privilege', privilege_type,
            'object_type', object_type,
            'object_name', object_name,
            'grantor', current_role,
            'with_grant_option', with_grant
        );
        
END;
$$ LANGUAGE plpgsql;

-- 创建权限撤销函数
CREATE OR REPLACE FUNCTION revoke_permissions(
    target_role TEXT,
    privilege_type TEXT,
    object_type TEXT,
    object_name TEXT,
    revoker_role TEXT DEFAULT 'app_admin',
    cascade_option BOOLEAN DEFAULT false
) RETURNS TABLE(
    operation_status TEXT,
    sql_command TEXT,
    revoked_permissions JSONB
) AS $$
DECLARE
    sql_statement TEXT;
    current_role TEXT;
    cascade_option_text TEXT;
BEGIN
    -- 获取当前角色
    SELECT current_setting('role_name') INTO current_role;
    
    -- 处理级联选项
    cascade_option_text := CASE WHEN cascade_option THEN ' CASCADE' ELSE '' END;
    
    -- 构建权限撤销SQL
    sql_statement := format('REVOKE %s ON %s %s FROM %s%s', 
                           privilege_type, 
                           object_type, 
                           object_name,
                           target_role,
                           cascade_option_text);
    
    -- 标记权限为非活跃
    UPDATE permission_assignments
    SET is_active = false
    WHERE role_name = target_role 
        AND privilege_type = privilege_type
        AND object_type = object_type
        AND object_name = object_name;
    
    RETURN QUERY
    SELECT 
        'permission_revoked'::TEXT,
        sql_statement,
        jsonb_build_object(
            'role', target_role,
            'privilege', privilege_type,
            'object_type', object_type,
            'object_name', object_name,
            'revoker', current_role,
            'cascaded', cascade_option
        );
        
END;
$$ LANGUAGE plpgsql;

-- 执行权限管理操作
SELECT * FROM grant_permissions('app_user', 'select', 'table', 'user_profiles');
SELECT * FROM grant_permissions('report_reader', 'select', 'schema', 'reporting');

-- 创建权限审计函数
CREATE OR REPLACE FUNCTION audit_permissions(
    target_object TEXT DEFAULT NULL
) RETURNS TABLE(
    role_name TEXT,
    privilege_type TEXT,
    object_type TEXT,
    object_name TEXT,
    granted_by TEXT,
    granted_at TIMESTAMP,
    with_grant_option BOOLEAN,
    permission_status TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        pa.role_name,
        pa.privilege_type,
        pa.object_type,
        pa.object_name,
        pa.granted_by,
        pa.granted_at,
        pa.with_grant_option,
        CASE WHEN pa.is_active THEN 'active' ELSE 'revoked' END as permission_status
    FROM permission_assignments pa
    WHERE (target_object IS NULL OR pa.object_name = target_object)
        AND pa.is_active = true
    ORDER BY pa.role_name, pa.object_type, pa.object_name;
    
END;
$$ LANGUAGE plpgsql;

-- 审计权限分配
SELECT * FROM audit_permissions();
SELECT * FROM audit_permissions('user_profiles');
```

### 职责分离(Segregation of Duties)

```sql
-- 创建职责分离规则表
CREATE TABLE segregation_rules (
    id SERIAL PRIMARY KEY,
    rule_name TEXT NOT NULL,
    role_involved TEXT[],
    conflict_type TEXT, -- 'data_modification_and_approval', 'user_creation_and_authorization'
    description TEXT,
    enforcement_level TEXT, -- 'strict', 'advisory', 'warning'
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入职责分离规则
INSERT INTO segregation_rules (role_involved, conflict_type, description, enforcement_level)
VALUES 
    (ARRAY['app_admin', 'security_auditor'], 'data_modification_and_approval', 
     'Admin cannot audit their own changes', 'strict'),
     
    (ARRAY['user_creator', 'user_approver'], 'user_creation_and_authorization',
     'User creation and authorization must be separate', 'strict'),
     
    (ARRAY['developer', 'production_deployer'], 'data_modification_and_approval',
     'Development and production deployment must be separate', 'strict'),
     
    (ARRAY['data_analyst', 'data_architect'], 'data_modification_and_approval',
     'Data analysis and data architecture should be separate', 'advisory');

-- 创建职责冲突检查函数
CREATE OR REPLACE FUNCTION check_segregation_compliance(
    user_name TEXT,
    proposed_action TEXT,
    target_object TEXT
) RETURNS TABLE(
    rule_checked TEXT,
    violation_found BOOLEAN,
    violation_details TEXT,
    enforcement_action TEXT
) AS $$
DECLARE
    user_roles TEXT[];
    role_record RECORD;
    rule_record RECORD;
    violation_detected BOOLEAN := false;
BEGIN
    -- 获取用户角色
    SELECT array_agg(rolname) INTO user_roles
    FROM pg_member_role_user_role_role pg_user 
    JOIN pg_roles ON pg_roles.oid = pg_user.role_id
    WHERE pg_user.member_id = (SELECT oid FROM pg_user WHERE usename = user_name);
    
    -- 检查职责分离规则
    FOR rule_record IN
        SELECT * FROM segregation_rules 
        WHERE is_active = true
    LOOP
        -- 检查用户角色是否违反规则
        IF array_to_string(user_roles, ',') = array_to_string(rule_record.role_involved, ',') THEN
            violation_detected := true;
            
            RETURN QUERY
            SELECT 
                rule_record.rule_name::TEXT,
                true,
                format('User %s has conflicting roles: %s', user_name, array_to_string(rule_record.role_involved, ', ')),
                CASE rule_record.enforcement_level
                    WHEN 'strict' THEN 'BLOCK_ACTION'
                    WHEN 'advisory' THEN 'WARN_USER'
                    WHEN 'warning' THEN 'LOG_EVENT'
                    ELSE 'ALLOW_ACTION'
                END;
        END IF;
    END LOOP;
    
    -- 如果没有发现违规，返回通过结果
    IF NOT violation_detected THEN
        RETURN QUERY
        SELECT 
            'segregation_compliance'::TEXT,
            false,
            'No segregation violations detected'::TEXT,
            'ALLOW_ACTION'::TEXT;
    END IF;
    
END;
$$ LANGUAGE plpgsql;

-- 检查职责分离合规性
SELECT * FROM check_segregation_compliance('app_admin', 'modify_table', 'user_data');
```

## 行级安全策略(RLS)

### RLS策略实现

```sql
-- 创建RLS配置表
CREATE TABLE rls_policies (
    id SERIAL PRIMARY KEY,
    table_name TEXT NOT NULL,
    policy_name TEXT NOT NULL,
    policy_type TEXT, -- 'select', 'insert', 'update', 'delete'
    using_expression TEXT,
    with_check_expression TEXT,
    roles TEXT[],
    is_enabled BOOLEAN DEFAULT true,
    created_by TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 启用RLS的示例表
CREATE TABLE employee_salary (
    employee_id INTEGER PRIMARY KEY,
    employee_name TEXT NOT NULL,
    department TEXT NOT NULL,
    salary DECIMAL(10,2),
    salary_grade TEXT,
    hire_date DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 启用行级安全
ALTER TABLE employee_salary ENABLE ROW LEVEL SECURITY;

-- 创建RLS策略
CREATE POLICY employee_salary_select_policy ON employee_salary
    FOR SELECT USING (
        -- HR经理可以查看所有记录
        current_user IN ('hr_manager', 'app_admin') OR
        -- 部门经理可以查看本部门记录
        department IN (
            SELECT department_name 
            FROM department_managers 
            WHERE manager_user = current_user
        ) OR
        -- 员工只能查看自己的记录
        employee_id = (
            SELECT employee_id 
            FROM employee_users 
            WHERE user_name = current_user
        )
    );

CREATE POLICY employee_salary_update_policy ON employee_salary
    FOR UPDATE USING (
        current_user IN ('hr_manager', 'app_admin') OR
        department IN (
            SELECT department_name 
            FROM department_managers 
            WHERE manager_user = current_user
        )
    ) WITH CHECK (
        current_user IN ('hr_manager', 'app_admin') OR
        department IN (
            SELECT department_name 
            FROM department_managers 
            WHERE manager_user = current_user
        )
    );

-- 创建RLS管理函数
CREATE OR REPLACE FUNCTION manage_rls_policies(
    target_table TEXT,
    action TEXT,
    policy_name_param TEXT DEFAULT NULL,
    policy_definition JSONB DEFAULT NULL
) RETURNS TABLE(
    operation_result TEXT,
    policy_details JSONB,
    error_message TEXT
) AS $$
DECLARE
    policy_record RECORD;
    sql_command TEXT;
BEGIN
    CASE action
        WHEN 'list' THEN
            -- 列出表的所有RLS策略
            FOR policy_record IN
                SELECT 
                    pol.*,
                    CASE WHEN pol.polcmd = '*' THEN 'ALL' ELSE pol.polcmd END as policy_type,
                    pol.polqual as using_expression,
                    pol.polwithcheck as with_check_expression
                FROM pg_policy pol
                JOIN pg_class pc ON pol.polrelid = pc.oid
                WHERE pc.relname = target_table
            LOOP
                RETURN QUERY
                SELECT 
                    'policy_listed'::TEXT,
                    jsonb_build_object(
                        'table_name', target_table,
                        'policy_name', policy_record.polname,
                        'policy_type', policy_record.policy_type,
                        'using_expression', policy_record.using_expression,
                        'with_check_expression', policy_record.with_check_expression,
                        'roles', policy_record.polroles
                    ),
                    NULL::TEXT;
            END LOOP;
            
        WHEN 'create' THEN
            -- 创建新的RLS策略
            IF policy_definition IS NULL THEN
                RETURN QUERY
                SELECT 
                    'policy_creation_failed'::TEXT,
                    NULL::JSONB,
                    'Policy definition is required'::TEXT;
                RETURN;
            END IF;
            
            -- 构建CREATE POLICY语句
            sql_command := format(
                'CREATE POLICY %s ON %s FOR %s USING (%s)%s',
                policy_name_param,
                target_table,
                policy_definition->>'type',
                policy_definition->>'using_expression',
                CASE WHEN policy_definition ? 'with_check_expression' 
                     THEN format(' WITH CHECK (%s)', policy_definition->>'with_check_expression')
                     ELSE '' END
            );
            
            RETURN QUERY
            SELECT 
                'policy_created'::TEXT,
                jsonb_build_object(
                    'table_name', target_table,
                    'policy_name', policy_name_param,
                    'sql_command', sql_command
                ),
                NULL::TEXT;
                
        WHEN 'drop' THEN
            -- 删除RLS策略
            sql_command := format('DROP POLICY %s ON %s', policy_name_param, target_table);
            
            RETURN QUERY
            SELECT 
                'policy_dropped'::TEXT,
                jsonb_build_object(
                    'table_name', target_table,
                    'policy_name', policy_name_param,
                    'sql_command', sql_command
                ),
                NULL::TEXT;
    END CASE;
    
END;
$$ LANGUAGE plpgsql;

-- 管理RLS策略
SELECT * FROM manage_rls_policies('employee_salary', 'list');

-- 创建动态RLS策略
CREATE OR REPLACE FUNCTION create_dynamic_rls_policy(
    table_name TEXT,
    policy_name TEXT,
    condition_function TEXT
) RETURNS TABLE(
    policy_created BOOLEAN,
    policy_sql TEXT,
    error_details TEXT
) AS $$
DECLARE
    policy_sql TEXT;
BEGIN
    BEGIN
        policy_sql := format(
            'CREATE POLICY %s ON %s USING (%s)',
            policy_name,
            table_name,
            condition_function
        );
        
        RETURN QUERY
        SELECT 
            true,
            policy_sql,
            NULL::TEXT;
            
    EXCEPTION WHEN OTHERS THEN
        RETURN QUERY
        SELECT 
            false,
            policy_sql,
            SQLERRM::TEXT;
    END;
    
END;
$$ LANGUAGE plpgsql;

-- 创建动态策略示例
SELECT * FROM create_dynamic_rls_policy(
    'employee_salary',
    'department_based_policy',
    'department = current_setting(''user_department'')'
);
```

## 数据加密技术

### 传输层加密

```sql
-- 创建SSL配置管理表
CREATE TABLE ssl_configurations (
    id SERIAL PRIMARY KEY,
    parameter_name TEXT NOT NULL,
    parameter_value TEXT,
    parameter_type TEXT, -- 'server', 'client', 'certificate'
    description TEXT,
    restart_required BOOLEAN DEFAULT false,
    is_active BOOLEAN DEFAULT true,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入SSL配置示例
INSERT INTO ssl_configurations (parameter_name, parameter_value, parameter_type, description, restart_required)
VALUES 
    ('ssl', 'on', 'server', 'Enable SSL connections', true),
    ('ssl_ca_file', '/path/to/ca.crt', 'server', 'Certificate Authority file', true),
    ('ssl_cert_file', '/path/to/server.crt', 'server', 'Server certificate file', true),
    ('ssl_key_file', '/path/to/server.key', 'server', 'Server private key file', true),
    ('ssl_ciphers', 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384', 'server', 'Allowed SSL ciphers', false),
    ('ssl_prefer_server_ciphers', 'on', 'server', 'Prefer server cipher order', false),
    ('ssl_min_protocol_version', 'TLSv1.2', 'server', 'Minimum SSL/TLS protocol version', false);

-- 创建证书管理函数
CREATE OR REPLACE FUNCTION manage_ssl_certificates(
    operation TEXT,
    certificate_type TEXT,
    certificate_path TEXT,
    subject_info JSONB DEFAULT NULL
) RETURNS TABLE(
    operation_status TEXT,
    certificate_info JSONB,
    verification_result TEXT
) AS $$
DECLARE
    cert_details JSONB;
    validation_result TEXT := 'success';
BEGIN
    CASE operation
        WHEN 'generate' THEN
            -- 生成自签名证书（示例）
            cert_details := jsonb_build_object(
                'type', certificate_type,
                'path', certificate_path,
                'subject', subject_info,
                'validity_days', 365,
                'created_at', CURRENT_TIMESTAMP
            );
            
            validation_result := format('Certificate generated at %s with subject: %s', 
                                       certificate_path, subject_info->>'common_name');
                                       
        WHEN 'validate' THEN
            -- 验证证书有效性
            cert_details := jsonb_build_object(
                'type', certificate_type,
                'path', certificate_path,
                'checks', jsonb_build_array(
                    'certificate_exists',
                    'certificate_readable',
                    'private_key_matches'
                )
            );
            
            -- 模拟证书验证
            validation_result := 'Certificate validation passed';
            
        WHEN 'renew' THEN
            -- 续期证书
            cert_details := jsonb_build_object(
                'type', certificate_type,
                'path', certificate_path,
                'renewal_date', CURRENT_TIMESTAMP + INTERVAL '365 days',
                'previous_expiry', CURRENT_TIMESTAMP + INTERVAL '30 days'
            );
            
            validation_result := 'Certificate renewed successfully';
    END CASE;
    
    RETURN QUERY
    SELECT 
        format('%s_%s'::TEXT, operation, certificate_type),
        cert_details,
        validation_result;
        
END;
$$ LANGUAGE plpgsql;

-- 管理SSL证书
SELECT * FROM manage_ssl_certificates('generate', 'server', '/path/to/server.crt', 
                                    jsonb_build_object('common_name', 'db.company.com', 'organization', 'Company Inc.'));
```

### 数据加密

```sql
-- 创建数据加密管理表
CREATE TABLE data_encryption_config (
    id SERIAL PRIMARY KEY,
    table_name TEXT NOT NULL,
    column_name TEXT NOT NULL,
    encryption_method TEXT, -- 'pgp_sym_encrypt', 'aes_encrypt', 'custom'
    encryption_key TEXT,
    key_rotation_date DATE,
    is_enabled BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建敏感数据加密函数
CREATE OR REPLACE FUNCTION encrypt_sensitive_data(
    data_value TEXT,
    encryption_method TEXT DEFAULT 'aes_encrypt'
) RETURNS TABLE(
    encrypted_data TEXT,
    encryption_info JSONB
) AS $$
DECLARE
    encrypted_result TEXT;
    encryption_key TEXT := 'default_encryption_key_256_bit';
BEGIN
    CASE encryption_method
        WHEN 'pgp_sym_encrypt' THEN
            -- 使用PGP对称加密
            encrypted_result := pgp_sym_encrypt(data_value, encryption_key);
            
        WHEN 'aes_encrypt' THEN
            -- 使用AES加密（如果扩展可用）
            -- 实际实现需要pgcrypto扩展
            encrypted_result := encode(encrypt(data_value::bytea, encryption_key, 'aes'), 'base64');
            
        ELSE
            -- 基础Base64编码（不建议用于生产环境）
            encrypted_result := encode(data_value::bytea, 'base64');
    END CASE;
    
    RETURN QUERY
    SELECT 
        encrypted_result,
        jsonb_build_object(
            'method', encryption_method,
            'key_length', length(encryption_key),
            'timestamp', CURRENT_TIMESTAMP
        );
        
END;
$$ LANGUAGE plpgsql;

-- 创建数据解密函数
CREATE OR REPLACE FUNCTION decrypt_sensitive_data(
    encrypted_data TEXT,
    encryption_method TEXT DEFAULT 'aes_encrypt'
) RETURNS TABLE(
    decrypted_data TEXT,
    decryption_info JSONB
) AS $$
DECLARE
    decrypted_result TEXT;
    encryption_key TEXT := 'default_encryption_key_256_bit';
BEGIN
    CASE encryption_method
        WHEN 'pgp_sym_encrypt' THEN
            -- 解密PGP加密数据
            decrypted_result := pgp_sym_decrypt(encrypted_data, encryption_key);
            
        WHEN 'aes_encrypt' THEN
            -- 解密AES加密数据
            decrypted_result := convert_from(
                decrypt(decode(encrypted_data, 'base64'), encryption_key, 'aes'), 
                'UTF8'
            );
            
        ELSE
            -- Base64解码
            decrypted_result := convert_from(decode(encrypted_data, 'base64'), 'UTF8');
    END CASE;
    
    RETURN QUERY
    SELECT 
        decrypted_result,
        jsonb_build_object(
            'method', encryption_method,
            'timestamp', CURRENT_TIMESTAMP
        );
        
END;
$$ LANGUAGE plpgsql;

-- 创建加密列的示例表
CREATE TABLE user_credentials (
    user_id INTEGER PRIMARY KEY,
    username TEXT NOT NULL,
    -- 加密存储的密码字段
    password_hash TEXT,
    password_encrypted TEXT,
    email TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入加密数据示例
INSERT INTO user_credentials (user_id, username, password_hash, password_encrypted, email)
VALUES (
    1,
    'testuser',
    crypt('plain_password', gen_salt('bf')),
    (SELECT encrypted_data FROM encrypt_sensitive_data('plain_password', 'pgp_sym_encrypt')),
    'test@example.com'
);

-- 解密验证
SELECT 
    user_id, 
    username,
    password_hash,
    (SELECT decrypted_data FROM decrypt_sensitive_data(password_encrypted, 'pgp_sym_encrypt')) as decrypted_password
FROM user_credentials;

-- 创建加密审计函数
CREATE OR REPLACE FUNCTION audit_encryption_status(
    target_table TEXT DEFAULT NULL
) RETURNS TABLE(
    table_name TEXT,
    column_name TEXT,
    encryption_method TEXT,
    encryption_enabled BOOLEAN,
    key_rotation_days INTEGER,
    last_updated TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        dec.table_name,
        dec.column_name,
        dec.encryption_method,
        dec.is_enabled,
        COALESCE(CURRENT_DATE - dec.key_rotation_date, 0) as key_rotation_days,
        dec.updated_at
    FROM data_encryption_config dec
    WHERE (target_table IS NULL OR dec.table_name = target_table)
        AND dec.is_enabled = true
    ORDER BY dec.table_name, dec.column_name;
    
END;
$$ LANGUAGE plpgsql;

-- 审计加密状态
SELECT * FROM audit_encryption_status();
```

## 网络访问控制

### 防火墙规则管理

```sql
-- 创建网络访问控制表
CREATE TABLE network_access_control (
    id SERIAL PRIMARY KEY,
    rule_name TEXT NOT NULL,
    rule_type TEXT, -- 'allow', 'deny', 'rate_limit'
    source_ip INET,
    source_netmask INET,
    target_ip INET,
    target_port INTEGER,
    protocol TEXT, -- 'tcp', 'udp', 'icmp'
    database_name TEXT,
    connection_limit INTEGER,
    rate_limit_per_hour INTEGER,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP
);

-- 插入网络访问控制规则
INSERT INTO network_access_control (rule_name, rule_type, source_ip, source_netmask, database_name, is_active)
VALUES 
    ('allow_internal_network', 'allow', '192.168.1.0'::INET, '255.255.255.0'::INET, NULL, true),
    ('allow_office_vpn', 'allow', '10.0.1.0'::INET, '255.255.255.0'::INET, NULL, true),
    ('deny_external_access', 'deny', '0.0.0.0'::INET, '0.0.0.0'::INET, NULL, true),
    ('rate_limit_public', 'rate_limit', '0.0.0.0'::INET, '0.0.0.0'::INET, NULL, true),
    ('allow_monitoring_system', 'allow', '172.16.0.10'::INET, '255.255.255.255'::INET, NULL, true);

-- 创建连接监控函数
CREATE OR REPLACE FUNCTION monitor_database_connections(
    time_window_minutes INTEGER DEFAULT 60
) RETURNS TABLE(
    source_ip INET,
    connection_count BIGINT,
    connection_rate_per_hour NUMERIC,
    last_connection_time TIMESTAMP,
    active_connections INTEGER,
    blocked_attempts INTEGER,
    risk_level TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        sa.client_addr,
        COUNT(*) as connection_count,
        COUNT(*) * 60 / time_window_minutes as connection_rate_per_hour,
        MAX(sa.query_start) as last_connection_time,
        COUNT(*) FILTER (WHERE sa.state = 'active') as active_connections,
        0 as blocked_attempts, -- 需要实际防火墙日志
        CASE 
            WHEN COUNT(*) * 60 / time_window_minutes > 100 THEN 'critical'
            WHEN COUNT(*) * 60 / time_window_minutes > 50 THEN 'high'
            WHEN COUNT(*) * 60 / time_window_minutes > 20 THEN 'medium'
            ELSE 'low'
        END as risk_level
    FROM pg_stat_activity sa
    WHERE sa.query_start >= CURRENT_TIMESTAMP - (time_window_minutes || ' minutes')::INTERVAL
        AND sa.client_addr IS NOT NULL
    GROUP BY sa.client_addr
    ORDER BY connection_count DESC;
    
END;
$$ LANGUAGE plpgsql;

-- 监控连接
SELECT * FROM monitor_database_connections(60);

-- 创建IP白名单管理函数
CREATE OR REPLACE FUNCTION manage_ip_whitelist(
    action TEXT,
    ip_address TEXT,
    netmask TEXT DEFAULT '255.255.255.255',
    description TEXT DEFAULT NULL
) RETURNS TABLE(
    operation_result TEXT,
    ip_rule JSONB,
    total_allowed_ips INTEGER
) AS $$
DECLARE
    ip_cidr TEXT;
    rule_id INTEGER;
BEGIN
    ip_cidr := ip_address || '/' || netmask;
    
    CASE action
        WHEN 'add' THEN
            INSERT INTO network_access_control (
                rule_name, rule_type, source_ip, source_netmask, 
                description, is_active
            ) VALUES (
                format('whitelist_%s', replace(ip_address, '.', '_')),
                'allow',
                ip_address::INET,
                netmask::INET,
                description,
                true
            ) RETURNING id INTO rule_id;
            
            RETURN QUERY
            SELECT 
                'ip_added_to_whitelist'::TEXT,
                jsonb_build_object(
                    'ip_address', ip_address,
                    'netmask', netmask,
                    'cidr', ip_cidr,
                    'rule_id', rule_id,
                    'description', description
                ),
                (SELECT COUNT(*) FROM network_access_control WHERE rule_type = 'allow' AND is_active);
                
        WHEN 'remove' THEN
            DELETE FROM network_access_control 
            WHERE source_ip = ip_address::INET 
                AND source_netmask = netmask::INET 
                AND rule_type = 'allow';
                
            RETURN QUERY
            SELECT 
                'ip_removed_from_whitelist'::TEXT,
                jsonb_build_object(
                    'ip_address', ip_address,
                    'netmask', netmask,
                    'cidr', ip_cidr
                ),
                (SELECT COUNT(*) FROM network_access_control WHERE rule_type = 'allow' AND is_active);
                
        WHEN 'list' THEN
            RETURN QUERY
            SELECT 
                'whitelist_displayed'::TEXT,
                jsonb_build_object(
                    'rules', (
                        SELECT jsonb_agg(jsonb_build_object(
                            'rule_name', rule_name,
                            'source_ip', source_ip,
                            'netmask', source_netmask,
                            'cidr', source_ip || '/' || source_netmask,
                            'description', description,
                            'created_at', created_at
                        ))
                        FROM network_access_control 
                        WHERE rule_type = 'allow' AND is_active
                    )
                ),
                (SELECT COUNT(*) FROM network_access_control WHERE rule_type = 'allow' AND is_active);
    END CASE;
    
END;
$$ LANGUAGE plpgsql;

-- 管理IP白名单
SELECT * FROM manage_ip_whitelist('add', '203.0.113.5', '255.255.255.255', 'Monitoring server');
SELECT * FROM manage_ip_whitelist('list');
```

## 安全审计与日志

### 审计日志配置

```sql
-- 创建审计日志配置表
CREATE TABLE audit_log_config (
    id SERIAL PRIMARY KEY,
    audit_type TEXT NOT NULL, -- 'connection', 'query', 'ddl', 'privilege'
    event_category TEXT,
    enabled BOOLEAN DEFAULT true,
    log_level TEXT, -- 'info', 'warning', 'error'
    retention_days INTEGER DEFAULT 90,
    alert_on_high_volume BOOLEAN DEFAULT true,
    threshold_per_hour INTEGER DEFAULT 1000,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建审计日志表
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    event_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    event_type TEXT NOT NULL,
    event_category TEXT,
    user_name TEXT,
    database_name TEXT,
    schema_name TEXT,
    table_name TEXT,
    query_text TEXT,
    affected_rows INTEGER,
    source_ip INET,
    application_name TEXT,
    session_id UUID,
    transaction_id BIGINT,
    severity TEXT,
    additional_info JSONB
);

-- 插入审计配置
INSERT INTO audit_log_config (audit_type, event_category, log_level, retention_days, threshold_per_hour)
VALUES 
    ('connection', 'authentication', 'info', 30, 100),
    ('connection', 'authorization_failure', 'warning', 90, 10),
    ('query', 'data_access', 'info', 60, 5000),
    ('query', 'privileged_access', 'warning', 365, 100),
    ('ddl', 'schema_changes', 'info', 365, 50),
    ('ddl', 'privilege_changes', 'warning', 365, 10),
    ('privilege', 'role_changes', 'warning', 365, 20),
    ('privilege', 'permission_grants', 'info', 180, 200);

-- 创建审计日志函数
CREATE OR REPLACE FUNCTION log_audit_event(
    event_type TEXT,
    event_category TEXT DEFAULT NULL,
    database_name TEXT DEFAULT NULL,
    schema_name TEXT DEFAULT NULL,
    table_name TEXT DEFAULT NULL,
    query_text TEXT DEFAULT NULL,
    affected_rows INTEGER DEFAULT NULL,
    source_ip INET DEFAULT NULL,
    application_name TEXT DEFAULT NULL,
    severity TEXT DEFAULT 'info',
    additional_info JSONB DEFAULT NULL
) RETURNS BIGINT AS $$
DECLARE
    audit_id BIGINT;
BEGIN
    INSERT INTO audit_logs (
        event_type, event_category, database_name, schema_name, table_name,
        query_text, affected_rows, source_ip, application_name, severity, additional_info
    ) VALUES (
        event_type, event_category, COALESCE(database_name, current_database()),
        schema_name, table_name, query_text, affected_rows, source_ip, 
        application_name, severity, additional_info
    ) RETURNING id INTO audit_id;
    
    -- 检查是否需要告警
    IF severity IN ('warning', 'error') THEN
        -- 这里可以添加告警逻辑
        -- 例如：发送邮件、写入专门的告警表等
    END IF;
    
    RETURN audit_id;
END;
$$ LANGUAGE plpgsql;

-- 创建审计查询函数
CREATE OR REPLACE FUNCTION query_audit_logs(
    start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP - INTERVAL '24 hours',
    end_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    event_type_filter TEXT DEFAULT NULL,
    user_name_filter TEXT DEFAULT NULL,
    severity_filter TEXT DEFAULT NULL,
    limit_count INTEGER DEFAULT 100
) RETURNS TABLE(
    event_id BIGINT,
    event_time TIMESTAMP,
    event_type TEXT,
    event_category TEXT,
    user_name TEXT,
    database_name TEXT,
    source_ip INET,
    query_preview TEXT,
    severity TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        al.id,
        al.event_time,
        al.event_type,
        al.event_category,
        al.user_name,
        al.database_name,
        al.source_ip,
        left(al.query_text, 100) as query_preview,
        al.severity
    FROM audit_logs al
    WHERE al.event_time BETWEEN start_time AND end_time
        AND (event_type_filter IS NULL OR al.event_type = event_type_filter)
        AND (user_name_filter IS NULL OR al.user_name = user_name_filter)
        AND (severity_filter IS NULL OR al.severity = severity_filter)
    ORDER BY al.event_time DESC
    LIMIT limit_count;
    
END;
$$ LANGUAGE plpgsql;

-- 查询审计日志
SELECT * FROM query_audit_logs(
    CURRENT_TIMESTAMP - INTERVAL '7 days',
    CURRENT_TIMESTAMP,
    NULL,
    NULL,
    'warning',
    50
);

-- 创建自动审计触发器
CREATE OR REPLACE FUNCTION audit_trigger_function()
RETURNS TRIGGER AS $$
DECLARE
    affected_rows INTEGER;
    query_info JSONB;
BEGIN
    -- 计算影响的行数
    CASE TG_OP
        WHEN 'INSERT' THEN affected_rows := 1;
        WHEN 'UPDATE' THEN affected_rows := 1;
        WHEN 'DELETE' THEN affected_rows := 1;
        ELSE affected_rows := 0;
    END CASE;
    
    -- 构建查询信息
    query_info := jsonb_build_object(
        'operation', TG_OP,
        'table_name', TG_TABLE_SCHEMA || '.' || TG_TABLE_NAME,
        'new_values', CASE WHEN TG_OP != 'DELETE' THEN row_to_json(NEW) ELSE NULL END,
        'old_values', CASE WHEN TG_OP != 'INSERT' THEN row_to_json(OLD) ELSE NULL END
    );
    
    -- 记录审计日志
    PERFORM log_audit_event(
        'table_operation',
        'data_modification',
        current_database(),
        TG_TABLE_SCHEMA,
        TG_TABLE_NAME,
        TG_OP || ' on ' || TG_TABLE_SCHEMA || '.' || TG_TABLE_NAME,
        affected_rows,
        inet_client_addr(),
        current_setting('application_name', true),
        CASE 
            WHEN TG_TABLE_NAME LIKE '%security%' OR TG_TABLE_NAME LIKE '%permission%' THEN 'warning'
            ELSE 'info'
        END,
        query_info
    );
    
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- 创建审计触发器示例
CREATE TRIGGER audit_employee_changes
    AFTER INSERT OR UPDATE OR DELETE ON employee_salary
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

-- 创建敏感操作检测函数
CREATE OR REPLACE FUNCTION detect_sensitive_operations(
    time_window_hours INTEGER DEFAULT 24
) RETURNS TABLE(
    operation_type TEXT,
    operation_count BIGINT,
    unique_users INTEGER,
    unique_ips INTEGER,
    risk_score NUMERIC,
    latest_occurrence TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        al.event_category,
        COUNT(*) as operation_count,
        COUNT(DISTINCT al.user_name) as unique_users,
        COUNT(DISTINCT al.source_ip) as unique_ips,
        -- 计算风险评分
        (COUNT(*) * COUNT(DISTINCT al.user_name) * COUNT(DISTINCT al.source_ip))::NUMERIC as risk_score,
        MAX(al.event_time) as latest_occurrence
    FROM audit_logs al
    WHERE al.event_time >= CURRENT_TIMESTAMP - (time_window_hours || ' hours')::INTERVAL
        AND al.event_category IN (
            'privilege_changes', 'schema_changes', 'privileged_access', 
            'authorization_failure', 'data_access'
        )
        AND al.severity IN ('warning', 'error')
    GROUP BY al.event_category
    ORDER BY risk_score DESC;
    
END;
$$ LANGUAGE plpgsql;

-- 检测敏感操作
SELECT * FROM detect_sensitive_operations(48);
```

### 合规报告生成

```sql
-- 创建合规报告配置表
CREATE TABLE compliance_reports (
    id SERIAL PRIMARY KEY,
    report_name TEXT NOT NULL,
    compliance_standard TEXT, -- 'SOC2', 'HIPAA', 'PCI-DSS', 'GDPR'
    report_type TEXT, -- 'access_review', 'data_handling', 'audit_trail'
    parameters JSONB,
    last_generated TIMESTAMP,
    next_generation TIMESTAMP,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入合规报告配置
INSERT INTO compliance_reports (report_name, compliance_standard, report_type, parameters, next_generation)
VALUES 
    ('Monthly Access Review', 'SOC2', 'access_review', 
     jsonb_build_object('include_roles', ARRAY['app_admin', 'app_user'], 'review_period_days', 30),
     CURRENT_TIMESTAMP + INTERVAL '30 days'),
     
    ('Data Access Audit', 'GDPR', 'data_handling',
     jsonb_build_object('sensitive_tables', ARRAY['employee_salary', 'user_credentials']),
     CURRENT_TIMESTAMP + INTERVAL '7 days'),
     
    ('Privileged User Review', 'HIPAA', 'access_review',
     jsonb_build_object('privileged_roles', ARRAY['app_admin'], 'review_period_days', 90),
     CURRENT_TIMESTAMP + INTERVAL '90 days');

-- 生成访问审查报告
CREATE OR REPLACE FUNCTION generate_access_review_report(
    report_id INTEGER,
    start_date DATE DEFAULT CURRENT_DATE - INTERVAL '30 days',
    end_date DATE DEFAULT CURRENT_DATE
) RETURNS TABLE(
    section_name TEXT,
    report_data JSONB,
    summary_statistics JSONB
) AS $$
DECLARE
    report_config RECORD;
    user_access_summary JSONB;
    role_assignment_summary JSONB;
    permission_changes_summary JSONB;
    failed_access_summary JSONB;
BEGIN
    -- 获取报告配置
    SELECT * INTO report_config 
    FROM compliance_reports 
    WHERE id = report_id AND is_active = true;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Report configuration not found or inactive';
    END IF;
    
    -- 用户访问摘要
    SELECT jsonb_build_object(
        'total_users', COUNT(DISTINCT al.user_name),
        'active_users', COUNT(DISTINCT al.user_name) FILTER (WHERE al.event_time >= CURRENT_TIMESTAMP - INTERVAL '7 days'),
        'user_activity', (
            SELECT jsonb_agg(jsonb_build_object(
                'user_name', user_activity.user_name,
                'login_count', user_activity.login_count,
                'last_login', user_activity.last_login,
                'risk_level', CASE 
                    WHEN user_activity.login_count > 100 THEN 'high'
                    WHEN user_activity.login_count > 50 THEN 'medium'
                    ELSE 'low'
                END
            ))
            FROM (
                SELECT 
                    al.user_name,
                    COUNT(*) as login_count,
                    MAX(al.event_time) as last_login
                FROM audit_logs al
                WHERE al.event_time BETWEEN start_date AND end_date
                    AND al.event_type = 'connection'
                GROUP BY al.user_name
            ) user_activity
        )
    ) INTO user_access_summary;
    
    RETURN QUERY
    SELECT 
        'user_access_summary'::TEXT,
        user_access_summary,
        jsonb_build_object(
            'total_sections', 4,
            'generated_at', CURRENT_TIMESTAMP
        );
    
    -- 角色分配摘要
    SELECT jsonb_build_object(
        'total_roles', (
            SELECT COUNT(DISTINCT role_name) 
            FROM permission_assignments 
            WHERE is_active = true
        ),
        'role_assignments', (
            SELECT jsonb_agg(jsonb_build_object(
                'role_name', role_assignment.role_name,
                'assigned_users', role_assignment.assigned_users,
                'privileges', role_assignment.privileges,
                'last_assigned', role_assignment.last_assigned
            ))
            FROM (
                SELECT 
                    pa.role_name,
                    COUNT(DISTINCT pa.role_name) as assigned_users,
                    array_agg(DISTINCT pa.privilege_type) as privileges,
                    MAX(pa.granted_at) as last_assigned
                FROM permission_assignments pa
                WHERE pa.is_active = true
                GROUP BY pa.role_name
            ) role_assignment
        )
    ) INTO role_assignment_summary;
    
    RETURN QUERY
    SELECT 
        'role_assignment_summary'::TEXT,
        role_assignment_summary,
        jsonb_build_object('section_type', 'access_control');
    
    -- 权限变更摘要
    SELECT jsonb_build_object(
        'total_changes', COUNT(*),
        'change_summary', (
            SELECT jsonb_agg(jsonb_build_object(
                'change_type', permission_change.change_type,
                'frequency', permission_change.frequency,
                'recent_changes', permission_change.recent_changes
            ))
            FROM (
                SELECT 
                    al.event_category as change_type,
                    COUNT(*) as frequency,
                    array_agg(DISTINCT al.user_name) as recent_changes
                FROM audit_logs al
                WHERE al.event_time BETWEEN start_date AND end_date
                    AND al.event_category IN ('privilege_changes', 'permission_grants')
                GROUP BY al.event_category
            ) permission_change
        )
    ) INTO permission_changes_summary;
    
    RETURN QUERY
    SELECT 
        'permission_changes_summary'::TEXT,
        permission_changes_summary,
        jsonb_build_object('review_period', format('%s to %s', start_date, end_date));
    
    -- 失败访问摘要
    SELECT jsonb_build_object(
        'total_failures', COUNT(*),
        'failure_analysis', (
            SELECT jsonb_agg(jsonb_build_object(
                'failure_type', failed_access.failure_type,
                'occurrence_count', failed_access.occurrence_count,
                'affected_ips', failed_access.affected_ips,
                'risk_assessment', failed_access.risk_assessment
            ))
            FROM (
                SELECT 
                    al.event_category as failure_type,
                    COUNT(*) as occurrence_count,
                    array_agg(DISTINCT al.source_ip) as affected_ips,
                    CASE 
                        WHEN COUNT(*) > 100 THEN 'high'
                        WHEN COUNT(*) > 50 THEN 'medium'
                        ELSE 'low'
                    END as risk_assessment
                FROM audit_logs al
                WHERE al.event_time BETWEEN start_date AND end_date
                    AND al.severity IN ('warning', 'error')
                GROUP BY al.event_category
            ) failed_access
        )
    ) INTO failed_access_summary;
    
    RETURN QUERY
    SELECT 
        'failed_access_summary'::TEXT,
        failed_access_summary,
        jsonb_build_object('alert_threshold', 10);
        
END;
$$ LANGUAGE plpgsql;

-- 生成合规报告
SELECT * FROM generate_access_review_report(1);
```

## 安全配置最佳实践

### 配置文件安全化

```sql
-- 创建安全配置检查函数
CREATE OR REPLACE FUNCTION security_configuration_audit()
RETURNS TABLE(
    configuration_item TEXT,
    current_value TEXT,
    recommended_value TEXT,
    security_risk TEXT,
    remediation_action TEXT,
    priority TEXT
) AS $$
DECLARE
    setting_record RECORD;
BEGIN
    -- 检查关键安全配置
    FOR setting_record IN
        SELECT 
            name,
            setting,
            context,
            short_desc
        FROM pg_settings
        WHERE name IN (
            'ssl',
            'password_encryption',
            'log_connections',
            'log_disconnections',
            'log_statement',
            'shared_preload_libraries',
            'max_connections',
            'shared_buffers',
            'wal_level',
            'archive_mode'
        )
        ORDER BY name
    LOOP
        RETURN QUERY
        SELECT 
            setting_record.name,
            setting_record.setting,
            CASE setting_record.name
                WHEN 'ssl' THEN 'on'
                WHEN 'password_encryption' THEN 'scram-sha-256'
                WHEN 'log_connections' THEN 'on'
                WHEN 'log_disconnections' THEN 'on'
                WHEN 'log_statement' THEN 'all'
                ELSE 'review_based_on_requirements'
            END,
            CASE setting_record.name
                WHEN 'ssl' THEN 'Disabled SSL connections expose data in transit'
                WHEN 'password_encryption' THEN 'Weak password encryption method'
                WHEN 'log_connections' THEN 'Not logging connections for audit'
                WHEN 'log_disconnections' THEN 'Not logging disconnections for audit'
                WHEN 'log_statement' THEN 'Not logging SQL statements for audit'
                ELSE 'May need adjustment based on security requirements'
            END,
            CASE setting_record.name
                WHEN 'ssl' THEN 'Enable SSL in postgresql.conf and provide certificates'
                WHEN 'password_encryption' THEN 'Set password_encryption = scram-sha-256'
                WHEN 'log_connections' THEN 'Set log_connections = on'
                WHEN 'log_disconnections' THEN 'Set log_disconnections = on'
                WHEN 'log_statement' THEN 'Set log_statement = all for comprehensive logging'
                ELSE 'Review and adjust based on specific requirements'
            END,
            CASE setting_record.name
                WHEN 'ssl' THEN 'critical'
                WHEN 'password_encryption' THEN 'high'
                WHEN 'log_connections' THEN 'medium'
                WHEN 'log_disconnections' THEN 'medium'
                WHEN 'log_statement' THEN 'medium'
                ELSE 'low'
            END;
    END LOOP;
    
END;
$$ LANGUAGE plpgsql;

-- 执行安全配置审计
SELECT * FROM security_configuration_audit();

-- 创建安全基线检查函数
CREATE OR REPLACE FUNCTION security_baseline_check()
RETURNS TABLE(
    check_category TEXT,
    check_name TEXT,
    status TEXT,
    current_state TEXT,
    recommended_state TEXT,
    risk_level TEXT,
    compliance_mapping TEXT
) AS $$
BEGIN
    -- SSL/TLS配置检查
    RETURN QUERY
    SELECT 
        'encryption'::TEXT,
        'SSL/TLS Configuration'::TEXT,
        CASE WHEN current_setting('ssl', true) = 'on' THEN 'pass' ELSE 'fail' END,
        current_setting('ssl', true),
        'on'::TEXT,
        CASE WHEN current_setting('ssl', true) = 'on' THEN 'low' ELSE 'critical' END,
        'SOC2: CC6.1, PCI-DSS: 4.1'::TEXT;
    
    -- 密码加密检查
    RETURN QUERY
    SELECT 
        'authentication'::TEXT,
        'Password Encryption'::TEXT,
        CASE WHEN current_setting('password_encryption', true) = 'scram-sha-256' THEN 'pass' ELSE 'warning' END,
        current_setting('password_encryption', true),
        'scram-sha-256'::TEXT,
        CASE WHEN current_setting('password_encryption', true) = 'scram-sha-256' THEN 'low' ELSE 'high' END,
        'SOC2: CC6.1, PCI-DSS: 8.2'::TEXT;
    
    -- 连接日志检查
    RETURN QUERY
    SELECT 
        'audit'::TEXT,
        'Connection Logging'::TEXT,
        CASE WHEN current_setting('log_connections', true) = 'on' THEN 'pass' ELSE 'fail' END,
        current_setting('log_connections', true),
        'on'::TEXT,
        CASE WHEN current_setting('log_connections', true) = 'on' THEN 'low' ELSE 'medium' END,
        'SOC2: CC7.2, HIPAA: 164.312(b)'::TEXT;
    
    -- 数据库用户数量检查
    RETURN QUERY
    SELECT 
        'user_management'::TEXT,
        'User Account Management'::TEXT,
        CASE WHEN (SELECT COUNT(*) FROM pg_user WHERE usename NOT IN ('postgres', 'replicator')) <= 10 
             THEN 'pass' ELSE 'warning' END,
        format('Total users: %s', (SELECT COUNT(*) FROM pg_user WHERE usename NOT IN ('postgres', 'replicator'))),
        'Minimize user accounts'::TEXT,
        CASE WHEN (SELECT COUNT(*) FROM pg_user WHERE usename NOT IN ('postgres', 'replicator')) <= 10 
             THEN 'low' ELSE 'medium' END,
        'SOC2: CC6.1, PCI-DSS: 8.1'::TEXT;
    
    -- RLS启用检查
    RETURN QUERY
    SELECT 
        'data_protection'::TEXT,
        'Row Level Security'::TEXT,
        CASE WHEN (SELECT COUNT(*) FROM pg_class WHERE relrowsecurity = true) > 0 
             THEN 'pass' ELSE 'info' END,
        format('Tables with RLS: %s', (SELECT COUNT(*) FROM pg_class WHERE relrowsecurity = true)),
        'Enable RLS for sensitive tables'::TEXT,
        CASE WHEN (SELECT COUNT(*) FROM pg_class WHERE relrowsecurity = true) > 0 
             THEN 'low' ELSE 'medium' END,
        'GDPR: Article 32, SOC2: CC6.6'::TEXT;
    
END;
$$ LANGUAGE plpgsql;

-- 执行安全基线检查
SELECT * FROM security_baseline_check();
```

## 威胁检测与响应

### 实时威胁检测

```sql
-- 创建威胁检测规则表
CREATE TABLE threat_detection_rules (
    id SERIAL PRIMARY KEY,
    rule_name TEXT NOT NULL,
    threat_category TEXT, -- 'brute_force', 'sql_injection', 'privilege_escalation', 'data_exfiltration'
    detection_query TEXT,
    threshold_value INTEGER,
    time_window INTERVAL,
    severity_level TEXT, -- 'low', 'medium', 'high', 'critical'
    response_actions TEXT[], -- 'log', 'alert', 'block', 'quarantine'
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入威胁检测规则
INSERT INTO threat_detection_rules (rule_name, threat_category, detection_query, threshold_value, time_window, severity_level, response_actions)
VALUES 
    ('brute_force_detection', 'brute_force',
     'SELECT COUNT(*) FROM pg_stat_activity WHERE state = ''active'' AND query_start < now() - interval ''5 minutes''', 
     50, INTERVAL '5 minutes', 'high', ARRAY['log', 'alert']),
     
    ('sql_injection_attempt', 'sql_injection',
     'SELECT COUNT(*) FROM pg_stat_statements WHERE query LIKE ''%''''%'' OR query LIKE ''%% UNION %%''', 
     5, INTERVAL '10 minutes', 'critical', ARRAY['log', 'alert', 'block']),
     
    ('privilege_escalation', 'privilege_escalation',
     'SELECT COUNT(*) FROM pg_stat_statements WHERE query ILIKE ''%create role%'' OR query ILIKE ''%grant%admin%''', 
     3, INTERVAL '15 minutes', 'critical', ARRAY['log', 'alert']),
     
    ('mass_data_access', 'data_exfiltration',
     'SELECT COUNT(*) FROM pg_stat_statements WHERE calls > 1000 AND query ILIKE ''%select%from%sensitive%''', 
     10, INTERVAL '1 hour', 'medium', ARRAY['log', 'alert']);

-- 创建威胁检测执行函数
CREATE OR REPLACE FUNCTION execute_threat_detection()
RETURNS TABLE(
    rule_name TEXT,
    threat_category TEXT,
    detection_count INTEGER,
    threshold_value INTEGER,
    threat_detected BOOLEAN,
    severity_level TEXT,
    recommended_actions TEXT[]
) AS $$
DECLARE
    rule_record RECORD;
    detection_count INTEGER;
BEGIN
    -- 执行每个活跃的威胁检测规则
    FOR rule_record IN
        SELECT * FROM threat_detection_rules WHERE is_active = true
    LOOP
        BEGIN
            -- 执行检测查询（示例实现）
            -- 实际环境中需要根据具体规则动态执行查询
            EXECUTE rule_record.detection_query INTO detection_count;
            
            -- 简化示例：随机生成检测数量
            detection_count := floor(random() * rule_record.threshold_value * 2)::INTEGER;
            
            RETURN QUERY
            SELECT 
                rule_record.rule_name,
                rule_record.threat_category,
                detection_count,
                rule_record.threshold_value,
                detection_count > rule_record.threshold_value,
                rule_record.severity_level,
                rule_record.response_actions;
            
            -- 如果检测到威胁，记录到威胁事件表
            IF detection_count > rule_record.threshold_value THEN
                INSERT INTO threat_incidents (
                    threat_id, incident_time, attempted_action, 
                    detection_method, severity_score, status
                ) VALUES (
                    rule_record.id,
                    CURRENT_TIMESTAMP,
                    format('Threshold exceeded: %s (limit: %s)', detection_count, rule_record.threshold_value),
                    'automated_detection',
                    CASE rule_record.severity_level
                        WHEN 'critical' THEN 4
                        WHEN 'high' THEN 3
                        WHEN 'medium' THEN 2
                        ELSE 1
                    END,
                    'open'
                );
            END IF;
            
        EXCEPTION WHEN OTHERS THEN
            -- 记录检测失败
            RETURN QUERY
            SELECT 
                rule_record.rule_name,
                rule_record.threat_category,
                0,
                rule_record.threshold_value,
                false,
                'error'::TEXT,
                ARRAY['investigate'::TEXT];
        END;
    END LOOP;
    
END;
$$ LANGUAGE plpgsql;

-- 执行威胁检测
SELECT * FROM execute_threat_detection();

-- 创建威胁响应函数
CREATE OR REPLACE FUNCTION respond_to_threat(
    incident_id INTEGER,
    response_action TEXT,
    response_details JSONB DEFAULT NULL
) RETURNS TABLE(
    action_taken TEXT,
    response_result TEXT,
    additional_steps TEXT[]
) AS $$
DECLARE
    incident_record RECORD;
    threat_rule RECORD;
    action_result TEXT;
    next_steps TEXT[] := ARRAY[]::TEXT[];
BEGIN
    -- 获取威胁事件详情
    SELECT ti.*, tdr.rule_name, tdr.threat_category, tdr.severity_level 
    INTO incident_record
    FROM threat_incidents ti
    JOIN threat_detection_rules tdr ON ti.threat_id = tdr.id
    WHERE ti.id = incident_id;
    
    IF NOT FOUND THEN
        RETURN QUERY
        SELECT 
            'response_failed'::TEXT,
            'Incident not found'::TEXT,
            ARRAY['verify_incident_id'::TEXT];
        RETURN;
    END IF;
    
    -- 执行响应操作
    CASE response_action
        WHEN 'block_ip' THEN
            -- 阻止IP地址访问
            action_result := format('IP %s blocked for 1 hour', incident_record.source_ip);
            next_steps := array_append(next_steps, 'Monitor blocked IP activity');
            
        WHEN 'quarantine_user' THEN
            -- 隔离用户账户
            action_result := format('User %s temporarily disabled', incident_record.user_name);
            next_steps := array_append(next_steps, 'Review user permissions');
            next_steps := array_append(next_steps, 'Enable account after investigation');
            
        WHEN 'alert_security_team' THEN
            -- 发送安全团队告警
            action_result := format('Security team alerted about %s threat', incident_record.threat_category);
            next_steps := array_append(next_steps, 'Assign security analyst');
            next_steps := array_append(next_steps, 'Prepare incident report');
            
        WHEN 'increase_logging' THEN
            -- 增加日志记录级别
            action_result := 'Logging level increased to verbose';
            next_steps := array_append(next_steps, 'Monitor for additional suspicious activity');
            next_steps := array_append(next_steps, 'Review enhanced logs');
            
        ELSE
            action_result := format('Unknown response action: %s', response_action);
    END CASE;
    
    -- 更新威胁事件状态
    UPDATE threat_incidents 
    SET status = CASE response_action
                   WHEN 'alert_security_team' THEN 'investigating'
                   WHEN 'block_ip' THEN 'mitigated'
                   ELSE status
                 END,
        response_actions = format('%s: %s', response_action, action_result),
        resolved_at = CASE 
                       WHEN response_action IN ('block_ip', 'quarantine_user') 
                       THEN CURRENT_TIMESTAMP 
                       ELSE resolved_at 
                     END
    WHERE id = incident_id;
    
    RETURN QUERY
    SELECT 
        response_action,
        action_result,
        next_steps;
        
END;
$$ LANGUAGE plpgsql;

-- 响应威胁事件
SELECT * FROM respond_to_threat(1, 'alert_security_team');
SELECT * FROM respond_to_threat(1, 'block_ip');
```

### 安全事件响应流程

```sql
-- 创建安全事件响应流程表
CREATE TABLE security_incident_response (
    id SERIAL PRIMARY KEY,
    incident_id INTEGER REFERENCES threat_incidents(id),
    response_stage TEXT, -- 'detection', 'analysis', 'containment', 'eradication', 'recovery', 'lessons_learned'
    response_actions TEXT,
    assigned_to TEXT,
    status TEXT, -- 'pending', 'in_progress', 'completed', 'escalated'
    start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    end_time TIMESTAMP,
    completion_notes TEXT,
    next_action TEXT
);

-- 创建事件升级函数
CREATE OR REPLACE FUNCTION escalate_security_incident(
    incident_id INTEGER,
    escalation_reason TEXT,
    escalate_to_role TEXT,
    escalation_priority TEXT
) RETURNS TABLE(
    escalation_status TEXT,
    incident_details JSONB,
    escalation_actions TEXT
) AS $$
DECLARE
    incident_record RECORD;
BEGIN
    -- 获取事件详情
    SELECT ti.*, tdr.rule_name, tdr.severity_level 
    INTO incident_record
    FROM threat_incidents ti
    JOIN threat_detection_rules tdr ON ti.threat_id = tdr.id
    WHERE ti.id = incident_id;
    
    IF NOT FOUND THEN
        RETURN QUERY
        SELECT 
            'escalation_failed'::TEXT,
            NULL::JSONB,
            'Incident not found'::TEXT;
        RETURN;
    END IF;
    
    -- 记录升级
    INSERT INTO security_incident_response (
        incident_id, response_stage, response_actions, status, assigned_to
    ) VALUES (
        incident_id,
        'analysis',
        format('Escalated to %s due to: %s', escalate_to_role, escalation_reason),
        'escalated',
        escalate_to_role
    );
    
    -- 更新事件严重性
    UPDATE threat_incidents 
    SET status = 'escalated'
    WHERE id = incident_id;
    
    RETURN QUERY
    SELECT 
        'incident_escalated'::TEXT,
        jsonb_build_object(
            'incident_id', incident_id,
            'severity_level', incident_record.sever