# 第5章：高级查询技术

在前面的章节中，我们学习了PostgreSQL的基础知识和基本SQL操作。现在我们将深入探讨一些更高级的查询技术，这些技术能够帮助我们处理复杂的业务场景，从多个表中提取有价值的信息，并进行深度数据分析。

## 5.1 连接查询 (JOIN)

在实际的业务场景中，数据通常分散在多个相关的表中。连接查询允许我们将这些相关表中的数据组合在一起，形成更有意义的结果集。

### 5.1.1 内连接 (INNER JOIN)

内连接返回两个表中满足连接条件的记录。这是最常用的连接类型之一。

```sql
-- 示例：查询员工及其所属部门信息
SELECT 
    e.name AS employee_name,
    e.salary,
    d.name AS department_name
FROM employees e
INNER JOIN departments d ON e.department_id = d.id;
```

### 5.1.2 左连接 (LEFT JOIN)

左连接返回左表中的所有记录，以及右表中满足连接条件的记录。如果右表中没有匹配的记录，则对应字段为NULL。

```sql
-- 示例：查询所有员工及其部门信息（包括未分配部门的员工）
SELECT 
    e.name AS employee_name,
    e.salary,
    d.name AS department_name
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id;
```

### 5.1.3 右连接 (RIGHT JOIN)

右连接与左连接相反，返回右表中的所有记录，以及左表中满足连接条件的记录。

```sql
-- 示例：查询所有部门及其员工信息（包括没有员工的部门）
SELECT 
    e.name AS employee_name,
    e.salary,
    d.name AS department_name
FROM employees e
RIGHT JOIN departments d ON e.department_id = d.id;
```

### 5.1.4 全外连接 (FULL OUTER JOIN)

全外连接返回两个表中的所有记录，无论是否满足连接条件。

```sql
-- 示例：查询所有员工和部门信息
SELECT 
    e.name AS employee_name,
    e.salary,
    d.name AS department_name
FROM employees e
FULL OUTER JOIN departments d ON e.department_id = d.id;
```

### 5.1.5 交叉连接 (CROSS JOIN)

交叉连接返回两个表的笛卡尔积，即左表的每一行与右表的每一行组合。

```sql
-- 示例：生成产品和颜色的所有可能组合
SELECT 
    p.name AS product_name,
    c.color_name
FROM products p
CROSS JOIN colors c;
```

## 5.2 子查询 (Subqueries)

子查询是嵌套在另一个查询中的查询语句。它可以出现在SELECT、FROM、WHERE或HAVING子句中。

### 5.2.1 非关联子查询

非关联子查询独立于外部查询执行，其结果被外部查询使用。

```sql
-- 示例：查询薪资高于平均薪资的员工
SELECT name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);
```

### 5.2.2 关联子查询

关联子查询引用外部查询中的列，因此对于外部查询的每一行都会执行一次。

```sql
-- 示例：查询每个部门薪资最高的员工
SELECT 
    e1.name,
    e1.salary,
    d.name AS department_name
FROM employees e1
INNER JOIN departments d ON e1.department_id = d.id
WHERE e1.salary = (
    SELECT MAX(e2.salary)
    FROM employees e2
    WHERE e2.department_id = e1.department_id
);
```

### 5.2.3 EXISTS 和 NOT EXISTS

EXISTS用于检查子查询是否返回至少一行记录。

```sql
-- 示例：查询有员工的部门
SELECT name
FROM departments d
WHERE EXISTS (
    SELECT 1
    FROM employees e
    WHERE e.department_id = d.id
);

-- 示例：查询没有员工的部门
SELECT name
FROM departments d
WHERE NOT EXISTS (
    SELECT 1
    FROM employees e
    WHERE e.department_id = d.id
);
```

## 5.3 集合操作 (Set Operations)

集合操作允许我们将多个查询的结果组合在一起。

### 5.3.1 UNION

UNION操作符合并两个或多个查询的结果集，并去除重复记录。

```sql
-- 示例：查询所有经理和高薪员工
SELECT name, 'Manager' AS role
FROM employees
WHERE position = 'Manager'
UNION
SELECT name, 'High Earner' AS role
FROM employees
WHERE salary > 80000;
```

### 5.3.2 UNION ALL

UNION ALL与UNION类似，但保留重复记录。

```sql
-- 示例：查询所有员工的姓名（包括重复）
SELECT name
FROM employees
WHERE department_id = 1
UNION ALL
SELECT name
FROM employees
WHERE salary > 70000;
```

### 5.3.3 INTERSECT

INTERSECT返回两个查询结果集的交集。

```sql
-- 示例：查询既是经理又薪资超过80000的员工
SELECT name
FROM employees
WHERE position = 'Manager'
INTERSECT
SELECT name
FROM employees
WHERE salary > 80000;
```

### 5.3.4 EXCEPT

EXCEPT返回第一个查询结果集中存在但第二个查询结果集中不存在的记录。

```sql
-- 示例：查询不是经理的员工
SELECT name
FROM employees
EXCEPT
SELECT name
FROM employees
WHERE position = 'Manager';
```

## 5.4 窗口函数 (Window Functions)

窗口函数允许我们在查询结果的某个分组或窗口中执行计算，而不会对数据进行分组（保留原始行）。

### 5.4.1 基本语法

窗口函数的基本语法如下：
```sql
function_name(expression) OVER (
    [PARTITION BY partition_expression, ...]
    [ORDER BY sort_expression [ASC | DESC], ...]
    [frame_clause]
)
```

### 5.4.2 常用窗口函数

#### 排名函数

```sql
-- 示例：按部门对员工薪资进行排名
SELECT 
    name,
    department_id,
    salary,
    ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) AS row_num,
    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS rank,
    DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS dense_rank
FROM employees;
```

#### 聚合函数作为窗口函数

```sql
-- 示例：计算每个员工薪资占部门总薪资的比例
SELECT 
    name,
    department_id,
    salary,
    SUM(salary) OVER (PARTITION BY department_id) AS dept_total,
    ROUND(
        salary * 100.0 / SUM(salary) OVER (PARTITION BY department_id), 
        2
    ) AS salary_percentage
FROM employees;
```

#### 前后行函数

```sql
-- 示例：比较员工薪资与部门平均薪资及前后员工薪资
SELECT 
    name,
    department_id,
    salary,
    LAG(salary) OVER (PARTITION BY department_id ORDER BY salary) AS prev_salary,
    LEAD(salary) OVER (PARTITION BY department_id ORDER BY salary) AS next_salary,
    AVG(salary) OVER (PARTITION BY department_id) AS avg_dept_salary
FROM employees
ORDER BY department_id, salary;
```

### 5.4.3 窗口框架

窗口框架允许我们进一步限定窗口函数操作的数据范围。

```sql
-- 示例：计算移动平均薪资（当前员工及前后各一位员工）
SELECT 
    name,
    salary,
    AVG(salary) OVER (
        ORDER BY salary 
        ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
    ) AS moving_avg
FROM employees;
```

## 5.5 实践练习

让我们通过一个综合示例来巩固所学的高级查询技术：

```sql
-- 创建示例表和数据
CREATE TABLE departments (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    department_id INTEGER REFERENCES departments(id),
    salary DECIMAL(10,2),
    hire_date DATE
);

CREATE TABLE projects (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    department_id INTEGER REFERENCES departments(id)
);

CREATE TABLE employee_projects (
    employee_id INTEGER REFERENCES employees(id),
    project_id INTEGER REFERENCES projects(id),
    hours_worked INTEGER,
    PRIMARY KEY (employee_id, project_id)
);

-- 插入示例数据
INSERT INTO departments (name) VALUES 
('Engineering'), ('Marketing'), ('Sales'), ('HR');

INSERT INTO employees (name, department_id, salary, hire_date) VALUES
('John Doe', 1, 75000, '2020-01-15'),
('Jane Smith', 1, 80000, '2019-03-20'),
('Bob Johnson', 2, 65000, '2021-05-10'),
('Alice Brown', 1, 85000, '2018-07-01'),
('Charlie Wilson', 3, 70000, '2020-11-28'),
('Diana Prince', 2, 68000, '2019-09-15');

INSERT INTO projects (name, department_id) VALUES
('Project Alpha', 1),
('Project Beta', 1),
('Project Gamma', 2),
('Project Delta', 3);

INSERT INTO employee_projects (employee_id, project_id, hours_worked) VALUES
(1, 1, 120),
(1, 2, 80),
(2, 1, 100),
(3, 3, 90),
(4, 1, 150),
(5, 4, 110);

-- 练习1：查询每个部门的员工数量和平均薪资
SELECT 
    d.name AS department_name,
    COUNT(e.id) AS employee_count,
    ROUND(AVG(e.salary), 2) AS avg_salary
FROM departments d
LEFT JOIN employees e ON d.id = e.department_id
GROUP BY d.id, d.name
ORDER BY avg_salary DESC;

-- 练习2：查询参与项目的员工及其总工时
SELECT 
    e.name AS employee_name,
    d.name AS department_name,
    SUM(ep.hours_worked) AS total_hours
FROM employees e
JOIN employee_projects ep ON e.id = ep.employee_id
JOIN departments d ON e.department_id = d.id
GROUP BY e.id, e.name, d.name
ORDER BY total_hours DESC;

-- 练习3：使用窗口函数查询每个部门薪资排名前三的员工
SELECT 
    name,
    department_name,
    salary,
    salary_rank
FROM (
    SELECT 
        e.name,
        d.name AS department_name,
        e.salary,
        ROW_NUMBER() OVER (PARTITION BY d.id ORDER BY e.salary DESC) AS salary_rank
    FROM employees e
    JOIN departments d ON e.department_id = d.id
) ranked_employees
WHERE salary_rank <= 3
ORDER BY department_name, salary_rank;

-- 练习4：查询各部门薪资最高的员工（使用子查询）
SELECT 
    e.name,
    d.name AS department_name,
    e.salary
FROM employees e
JOIN departments d ON e.department_id = d.id
WHERE e.salary = (
    SELECT MAX(e2.salary)
    FROM employees e2
    WHERE e2.department_id = e.department_id
)
ORDER BY e.salary DESC;

-- 练习5：使用集合操作查询高薪员工和项目负责人
WITH high_earners AS (
    SELECT name, 'High Earner' AS category
    FROM employees
    WHERE salary > 75000
),
project_leads AS (
    SELECT DISTINCT e.name, 'Project Lead' AS category
    FROM employees e
    JOIN employee_projects ep ON e.id = ep.employee_id
)
SELECT * FROM high_earners
UNION
SELECT * FROM project_leads
ORDER BY name;
```

## 5.6 性能优化建议

1. **合理使用索引**：在经常用于连接和WHERE条件的列上创建索引
2. **避免不必要的子查询**：可以用JOIN替代的子查询应优先考虑JOIN
3. **优化窗口函数**：为PARTITION BY和ORDER BY子句创建复合索引
4. **限制结果集**：使用LIMIT和OFFSET来控制返回的数据量
5. **分析执行计划**：使用EXPLAIN ANALYZE来分析查询性能

## 5.7 总结

在本章中，我们学习了：

1. 各种类型的连接查询及其应用场景
2. 子查询的使用方法，包括关联和非关联子查询
3. 集合操作符UNION、INTERSECT、EXCEPT的使用
4. 窗口函数的强大功能和实际应用
5. 通过综合示例巩固了这些高级查询技术

下一章我们将探讨PostgreSQL中的索引和性能优化技术，帮助您构建更高效的数据查询系统。