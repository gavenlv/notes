# PostgreSQL高级专题：事务与并发控制

## 概述

事务是数据库系统的核心概念之一，PostgreSQL提供了强大的事务处理能力，支持ACID特性和多版本并发控制(MVCC)。本专题深入探讨PostgreSQL的事务机制、并发控制策略和最佳实践。

## 目录

1. [事务基础概念](#事务基础概念)
2. [ACID特性详解](#acid特性详解)
3. [事务管理语句](#事务管理语句)
4. [多版本并发控制(MVCC)](#多版本并发控制mvcc)
5. [隔离级别详解](#隔离级别详解)
6. [锁机制与死锁处理](#锁机制与死锁处理)
7. [事务隔离级别实践](#事务隔离级别实践)
8. [性能优化策略](#性能优化策略)
9. [故障处理与恢复](#故障处理与恢复)
10. [实战案例](#实战案例)

## 事务基础概念

### 什么是事务

事务是一组原子性的SQL操作序列，要么全部执行成功，要么全部回滚失败。事务将一组操作打包成一个逻辑单元，确保数据库状态的一致性。

### 事务的四大特性(ACID)

1. **原子性(Atomicity)**: 事务中的操作要么全部成功，要么全部失败
2. **一致性(Consistency)**: 事务执行前后数据库状态保持一致
3. **隔离性(Isolation)**: 并发执行的事务相互隔离
4. **持久性(Durability)**: 事务一旦提交，结果永久保存

### PostgreSQL事务特点

- 自动提交模式（默认每条SQL语句为一个事务）
- 支持嵌套事务（保存点）
- 读写分离并发控制
- 完整的ACID支持

```sql
-- 基本的BEGIN/COMMIT/ROLLBACK操作
BEGIN;
-- 事务操作
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
-- 检查操作
IF balance_check_ok() THEN
    COMMIT;
ELSE
    ROLLBACK;
END IF;
```

## ACID特性详解

### 原子性实现机制

PostgreSQL通过WAL（Write-Ahead Logging）实现原子性：
- 所有修改操作先写入日志
- 故障时通过日志恢复
- 保证操作的原子性

### 一致性保障

- 约束检查（外键、唯一性、检查约束）
- 触发器验证
- 业务规则执行
- 数据类型验证

### 隔离性技术

MVCC（多版本并发控制）是PostgreSQL隔离性的核心：
- 读操作不阻塞写操作
- 写操作不阻塞读操作
- 通过版本号实现快照隔离

### 持久性机制

- WAL日志写入
- 检查点机制
- 归档日志
- 异步提交优化

## 事务管理语句

### 基本事务语句

```sql
-- 开始事务
BEGIN;
-- 或者使用START TRANSACTION
START TRANSACTION;

-- 提交事务
COMMIT;
-- 或者END

-- 回滚事务
ROLLBACK;
-- 或者ABORT
```

### 保存点管理

```sql
-- 创建保存点
SAVEPOINT savepoint_name;

-- 回滚到指定保存点
ROLLBACK TO SAVEPOINT savepoint_name;

-- 删除保存点
RELEASE SAVEPOINT savepoint_name;

-- 实际应用示例
BEGIN;
    INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com');
    SAVEPOINT user_inserted;
    
    INSERT INTO orders (user_id, amount) VALUES (1, 100.00);
    
    -- 如果订单插入失败，回滚到用户插入点
    IF error_detected THEN
        ROLLBACK TO SAVEPOINT user_inserted;
    END IF;
    
    -- 继续其他操作
    INSERT INTO payments (order_id, amount) VALUES (1, 100.00);
    
COMMIT;
```

### 事务模式设置

```sql
-- 设置事务隔离级别
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 设置读写模式
SET TRANSACTION READ ONLY;
SET TRANSACTION READ WRITE;

-- 设置延迟提交
SET TRANSACTION DEFERRABLE; -- 仅对SERIALIZABLE级别有效

-- 一条语句设置多个选项
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

## 多版本并发控制(MVCC)

### MVCC基本原理

PostgreSQL使用MVCC解决并发控制问题：
- 每行数据包含多个隐藏字段：
  - `xmin`: 创建该行版本的事务ID
  - `xmax`: 删除该行版本的事务ID
  - `cmin/cmax`: 命令标识符
  - `ctid`: 行版本指针

### 可见性判断规则

```sql
-- 查看表的隐藏字段
SELECT 
    ctid,
    xmin,
    xmax,
    cmin,
    cmax,
    name
FROM users;
```

### 快照机制

```sql
-- 获取当前事务快照
SELECT pg_current_snapshot();

-- 快照包含信息：
-- xmin: 最早的活跃事务ID
-- xmax: 下一个事务ID
-- xip_list: 活跃事务ID列表

-- 示例快照：'13:14:1,2,3,4,5'
-- xmin=13, xmax=14, 活跃事务ID=1,2,3,4,5
```

### 不同隔离级别下的MVCC

| 隔离级别 | 读取数据 | 写入阻塞 | 并发性能 |
|---------|---------|---------|---------|
| READ UNCOMMITTED | 最新提交数据 | 不阻塞 | 最优 |
| READ COMMITTED | 当前语句开始时的快照 | 不阻塞 | 很好 |
| REPEATABLE READ | 事务开始时的快照 | 不阻塞 | 好 |
| SERIALIZABLE | 事务开始时的快照 + 序列化检查 | 可能阻塞其他事务 | 中等 |

## 隔离级别详解

### READ COMMITTED（默认级别）

```sql
-- 设置为READ COMMITTED
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 特性：
-- - 每个语句开始时获取新快照
-- - 避免脏读
-- - 可能出现不可重复读

-- 示例：不可重复读情况
BEGIN;
-- 会话1：插入新记录
INSERT INTO products (id, name) VALUES (999, 'New Product');

-- 会话2：在READ COMMITTED级别下
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
BEGIN;
-- 第一次查询：可能看到新产品（如果会话1已提交）
SELECT COUNT(*) FROM products; -- 102

-- 等待一段时间
-- 如果会话1已提交，新产品可见
SELECT COUNT(*) FROM products; -- 103
COMMIT;
```

### REPEATABLE READ

```sql
-- 设置为REPEATABLE READ
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 特性：
-- - 整个事务使用同一个快照
-- - 避免不可重复读
-- - 可能出现幻读
-- - PostgreSQL会自动检测序列化冲突

-- 示例：幻读情况
BEGIN;
-- 会话1：插入新记录
INSERT INTO products (id, name) VALUES (1000, 'Another Product');

-- 会话2：在REPEATABLE READ级别下
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN;
-- 第一次查询
SELECT COUNT(*) FROM products; -- 103

-- 尝试插入相同产品
INSERT INTO products (id, name) VALUES (1000, 'Duplicate');
-- 如果会话1已提交，这将失败，因为违反唯一约束

-- 第二次查询：幻读，新产品可见
SELECT COUNT(*) FROM products; -- 104
COMMIT;
```

### SERIALIZABLE

```sql
-- 设置为SERIALIZABLE
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 特性：
-- - 最高隔离级别
-- - 完全避免幻读和不可重复读
-- - 可能导致序列化错误
-- - 最严格的并发控制

-- 示例：序列化错误
BEGIN;
-- 会话1：检查产品数量并插入
SELECT COUNT(*) FROM products; -- 104
INSERT INTO products (id, name) VALUES (1001, 'Product 1001');

-- 会话2：在SERIALIZABLE级别下
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN;
-- 尝试类似的操作
SELECT COUNT(*) FROM products; -- 104
INSERT INTO products (id, name) VALUES (1002, 'Product 1002');

-- 如果两个事务同时提交：
-- 后提交的事务会收到序列化错误
-- ERROR: could not serialize access due to concurrent update
```

## 锁机制与死锁处理

### 锁的类型

```sql
-- 查看当前锁信息
SELECT 
    locktype,
    mode,
    granted,
    relation::regclass as table_name,
    virtualtransaction,
    pid,
    query
FROM pg_locks 
ORDER BY locktype, relation;

-- 查看锁等待关系
SELECT 
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_statement,
    blocking_activity.query AS current_statement_in_blocking_process
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks ON blocking_locks.relation = blocked_locks.relation
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;
```

### 行级锁

```sql
-- SELECT FOR UPDATE：获取行锁
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;

-- SELECT FOR UPDATE NOWAIT：不等待锁释放
SELECT * FROM accounts WHERE id = 1 FOR UPDATE NOWAIT;

-- SELECT FOR UPDATE SKIP LOCKED：跳过被锁的行
SELECT * FROM accounts WHERE balance > 1000 FOR UPDATE SKIP LOCKED;

-- SELECT FOR SHARE：共享锁
SELECT * FROM accounts WHERE id = 1 FOR SHARE;

-- SELECT FOR KEY SHARE：键共享锁
SELECT * FROM accounts WHERE id = 1 FOR KEY SHARE;
```

### 表级锁

```sql
-- 表锁类型
LOCK TABLE users IN ACCESS SHARE MODE;     -- SELECT
LOCK TABLE users IN ROW SHARE MODE;        -- SELECT FOR UPDATE
LOCK TABLE users IN ROW EXCLUSIVE MODE;    -- INSERT/UPDATE/DELETE
LOCK TABLE users IN SHARE UPDATE EXCLUSIVE MODE;  -- CREATE INDEX/VACUUM
LOCK TABLE users IN SHARE MODE;            -- CREATE INDEX
LOCK TABLE users IN SHARE ROW EXCLUSIVE MODE;     -- INSERT (需要额外检查)
LOCK TABLE users IN EXCLUSIVE MODE;        -- SELECT (阻塞写操作)
LOCK TABLE users IN ACCESS EXCLUSIVE MODE; -- ALTER TABLE/DROP TABLE

-- 实际应用示例
BEGIN;
LOCK TABLE users IN SHARE MODE;  -- 防止表结构修改
ALTER TABLE users ADD COLUMN last_login_at TIMESTAMP;
COMMIT;
```

### 死锁检测与处理

```sql
-- 配置死锁检测
-- 在postgresql.conf中设置
-- deadlock_timeout = 1s
-- log_lock_waits = on

-- 死锁检测配置
SHOW deadlock_timeout;
SHOW log_lock_waits;

-- 手动检测死锁
SELECT 
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_statement,
    blocking_activity.query AS blocking_statement,
    blocked_activity.query_start AS blocked_query_start,
    blocking_activity.query_start AS blocking_query_start
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks ON blocking_locks.relation = blocked_locks.relation
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted AND blocked_activity.datid = blocking_activity.datid;

-- 死锁处理函数
CREATE OR REPLACE FUNCTION check_deadlocks() RETURNS TABLE(
    blocked_pid INTEGER,
    blocked_user TEXT,
    blocking_pid INTEGER,
    blocking_user TEXT,
    blocked_query TEXT,
    blocking_query TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        blocked_locks.pid,
        blocked_activity.usename,
        blocking_locks.pid,
        blocking_activity.usename,
        blocked_activity.query,
        blocking_activity.query
    FROM pg_catalog.pg_locks blocked_locks
    JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
    JOIN pg_catalog.pg_locks blocking_locks ON blocking_locks.relation = blocked_locks.relation
    JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
    WHERE NOT blocked_locks.granted AND blocked_activity.datid = blocking_activity.datid;
END;
$$ LANGUAGE plpgsql;
```

## 事务隔离级别实践

### 选择合适的隔离级别

```sql
-- 创建测试表
CREATE TABLE test_transactions (
    id SERIAL PRIMARY KEY,
    account_name VARCHAR(50),
    balance NUMERIC(10,2),
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO test_transactions (account_name, balance) VALUES 
    ('Alice', 1000.00),
    ('Bob', 800.00),
    ('Charlie', 1200.00);

-- 账户转账事务示例
CREATE OR REPLACE FUNCTION transfer_money(
    from_account VARCHAR(50),
    to_account VARCHAR(50),
    amount NUMERIC
) RETURNS BOOLEAN AS $$
DECLARE
    from_balance NUMERIC;
    to_balance NUMERIC;
BEGIN
    -- 开始事务，使用可重复读级别
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
    
    -- 检查转出账户余额
    SELECT balance INTO from_balance 
    FROM test_transactions 
    WHERE account_name = from_account 
    FOR UPDATE;
    
    IF from_balance IS NULL THEN
        RAISE EXCEPTION 'Account % not found', from_account;
    END IF;
    
    IF from_balance < amount THEN
        RAISE EXCEPTION 'Insufficient balance in account %', from_account;
    END IF;
    
    -- 获取转入账户信息
    SELECT balance INTO to_balance 
    FROM test_transactions 
    WHERE account_name = to_account 
    FOR UPDATE;
    
    IF to_balance IS NULL THEN
        RAISE EXCEPTION 'Account % not found', to_account;
    END IF;
    
    -- 执行转账
    UPDATE test_transactions 
    SET balance = balance - amount, updated_at = CURRENT_TIMESTAMP 
    WHERE account_name = from_account;
    
    UPDATE test_transactions 
    SET balance = balance + amount, updated_at = CURRENT_TIMESTAMP 
    WHERE account_name = to_account;
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;
```

### 事务重试机制

```sql
-- 事务重试函数
CREATE OR REPLACE FUNCTION transfer_with_retry(
    from_account VARCHAR(50),
    to_account VARCHAR(50),
    amount NUMERIC,
    max_retries INTEGER DEFAULT 3
) RETURNS BOOLEAN AS $$
DECLARE
    attempt INTEGER := 0;
    success BOOLEAN := FALSE;
BEGIN
    LOOP
        BEGIN
            -- 重试逻辑
            SELECT transfer_money(from_account, to_account, amount) INTO success;
            IF success THEN
                RETURN TRUE;
            END IF;
        EXCEPTION WHEN OTHERS THEN
            attempt := attempt + 1;
            IF attempt >= max_retries THEN
                RAISE EXCEPTION 'Transfer failed after % attempts: %', 
                    max_retries, SQLERRM;
            END IF;
            -- 等待后重试
            PERFORM pg_sleep(1);
        END;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

## 性能优化策略

### 事务设计原则

```sql
-- 1. 缩短事务持续时间
-- 避免在事务中执行长时间操作
BEGIN;
    -- 快速操作
    UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = user_id;
    -- 避免在这里执行：
    -- - 长时间计算
    -- - 网络请求
    -- - 外部系统调用
COMMIT;

-- 2. 减少锁持有时间
-- 正确的模式
CREATE OR REPLACE FUNCTION update_user_profile(user_id INTEGER, new_email VARCHAR) RETURNS VOID AS $$
BEGIN
    -- 立即获取锁并快速更新
    UPDATE users 
    SET email = new_email, updated_at = CURRENT_TIMESTAMP 
    WHERE id = user_id;
END;
$$ LANGUAGE plpgsql;

-- 3. 使用适当的锁模式
-- 对于纯读取操作，避免使用FOR UPDATE
-- 正确：
SELECT * FROM products WHERE category = 'electronics';

-- 错误（不必要的锁）：
SELECT * FROM products WHERE category = 'electronics' FOR UPDATE;
```

### 批量操作优化

```sql
-- 使用COPY进行批量插入
COPY users (id, name, email, created_at) FROM STDIN;
1\tJohn Doe\tjohn@example.com\t2023-01-01
2\tJane Smith\tjane@example.com\t2023-01-02
3\tBob Johnson\tbob@example.com\t2023-01-03
\.

-- 使用临时表进行批量更新
BEGIN;
    -- 创建临时表
    CREATE TEMP TABLE temp_updates (
        id INTEGER,
        new_balance NUMERIC
    ) ON COMMIT DROP;
    
    -- 插入批量数据
    COPY temp_updates FROM STDIN;
    1\t950.00
    2\t750.00
    3\t1150.00
    \.
    
    -- 批量更新
    UPDATE accounts 
    SET balance = temp_updates.new_balance
    FROM temp_updates 
    WHERE accounts.id = temp_updates.id;
    
COMMIT;

-- 分批处理大批量事务
CREATE OR REPLACE FUNCTION batch_update() RETURNS VOID AS $$
DECLARE
    batch_size INTEGER := 1000;
    processed INTEGER := 0;
    total_to_process INTEGER;
BEGIN
    SELECT COUNT(*) INTO total_to_process 
    FROM large_table 
    WHERE status = 'pending';
    
    WHILE processed < total_to_process LOOP
        BEGIN
            WITH batch AS (
                SELECT id 
                FROM large_table 
                WHERE status = 'pending'
                ORDER BY id
                LIMIT batch_size
            )
            UPDATE large_table 
            SET status = 'processed', processed_at = CURRENT_TIMESTAMP
            WHERE id IN (SELECT id FROM batch);
            
            GET DIAGNOSTICS processed = ROW_COUNT;
            PERFORM pg_sleep(1); -- 给其他事务机会
        EXCEPTION WHEN OTHERS THEN
            RAISE LOG 'Batch processing error: %', SQLERRM;
            EXIT;
        END;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

### 锁竞争优化

```sql
-- 使用索引减少锁范围
-- 好的索引设计
CREATE INDEX CONCURRENTLY idx_orders_user_id ON orders(user_id);
CREATE INDEX CONCURRENTLY idx_orders_status ON orders(status, created_at);

-- 分批处理热点数据
CREATE OR REPLACE FUNCTION process_hot_data() RETURNS VOID AS $$
DECLARE
    rec RECORD;
    batch_size INTEGER := 100;
BEGIN
    FOR rec IN 
        SELECT * FROM hot_table 
        WHERE status = 'new' 
        ORDER BY priority DESC, created_at ASC
        LIMIT batch_size
    LOOP
        BEGIN
            -- 处理单条记录
            UPDATE hot_table 
            SET status = 'processing', processed_at = CURRENT_TIMESTAMP 
            WHERE id = rec.id;
            
            -- 执行具体业务逻辑
            PERFORM process_single_record(rec.id);
            
            UPDATE hot_table 
            SET status = 'completed', completed_at = CURRENT_TIMESTAMP 
            WHERE id = rec.id;
            
        EXCEPTION WHEN OTHERS THEN
            UPDATE hot_table 
            SET status = 'failed', error_message = SQLERRM 
            WHERE id = rec.id;
        END;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

## 故障处理与恢复

### 事务故障类型

```sql
-- 检测长时间运行的事务
SELECT 
    pid,
    usename,
    application_name,
    client_addr,
    state,
    query_start,
    now() - query_start as duration,
    query
FROM pg_stat_activity 
WHERE state != 'idle' 
    AND query != '<IDLE>'
    AND now() - query_start > interval '5 minutes'
ORDER BY duration DESC;

-- 检测idle in transaction状态
SELECT 
    pid,
    usename,
    application_name,
    client_addr,
    query_start,
    now() - query_start as idle_duration,
    query
FROM pg_stat_activity 
WHERE state = 'idle in transaction' 
    AND now() - query_start > interval '1 minutes'
ORDER BY idle_duration DESC;
```

### 事务恢复策略

```sql
-- 创建事务监控视图
CREATE OR REPLACE VIEW transaction_monitoring AS
SELECT 
    pid,
    usename,
    datname,
    application_name,
    client_addr,
    state,
    CASE 
        WHEN state = 'idle in transaction' THEN 
            now() - query_start
        ELSE NULL
    END as idle_duration,
    CASE 
        WHEN state = 'active' THEN 
            now() - query_start
        ELSE NULL
    END as active_duration,
    query_start,
    query
FROM pg_stat_activity
WHERE usename IS NOT NULL;

-- 终止长时间运行的idle in transaction
CREATE OR REPLACE FUNCTION terminate_idle_transactions(max_idle_minutes INTEGER DEFAULT 30) RETURNS INTEGER AS $$
DECLARE
    terminated_count INTEGER := 0;
    rec RECORD;
BEGIN
    FOR rec IN 
        SELECT pid 
        FROM pg_stat_activity 
        WHERE state = 'idle in transaction' 
            AND now() - query_start > (max_idle_minutes || ' minutes')::interval
    LOOP
        PERFORM pg_terminate_backend(rec.pid);
        terminated_count := terminated_count + 1;
        RAISE NOTICE 'Terminated idle transaction PID: %', rec.pid;
    END LOOP;
    
    RETURN terminated_count;
END;
$$ LANGUAGE plpgsql;

-- 检查点配置
-- postgresql.conf:
-- checkpoint_completion_target = 0.9
-- max_wal_size = 2GB
-- min_wal_size = 1GB
-- checkpoint_timeout = 15min
```

## 实战案例

### 案例1：电商订单系统事务处理

```sql
-- 订单系统相关表
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    order_number VARCHAR(50) UNIQUE NOT NULL,
    user_id INTEGER NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    total_amount NUMERIC(10,2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE order_items (
    id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES orders(id) ON DELETE CASCADE,
    product_id INTEGER NOT NULL,
    quantity INTEGER NOT NULL,
    unit_price NUMERIC(10,2) NOT NULL,
    total_price NUMERIC(10,2) GENERATED ALWAYS AS (quantity * unit_price) STORED
);

CREATE TABLE inventory (
    product_id INTEGER PRIMARY KEY,
    quantity INTEGER NOT NULL DEFAULT 0,
    reserved_quantity INTEGER NOT NULL DEFAULT 0,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE payments (
    id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES orders(id) ON DELETE CASCADE,
    payment_method VARCHAR(50) NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    transaction_id VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建订单的事务函数
CREATE OR REPLACE FUNCTION create_order(
    p_user_id INTEGER,
    p_order_items JSONB,
    p_payment_method VARCHAR(50)
) RETURNS INTEGER AS $$
DECLARE
    new_order_id INTEGER;
    item JSONB;
    total_amount NUMERIC(10,2) := 0;
    product_stock INTEGER;
BEGIN
    -- 开始事务，使用SERIALIZABLE级别确保完全隔离
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    
    -- 验证库存并计算总金额
    FOR item IN SELECT * FROM jsonb_array_elements(p_order_items)
    LOOP
        -- 检查库存
        SELECT quantity INTO product_stock
        FROM inventory
        WHERE product_id = (item->>'product_id')::INTEGER;
        
        IF product_stock IS NULL THEN
            RAISE EXCEPTION 'Product % not found', item->>'product_id';
        END IF;
        
        IF product_stock < (item->>'quantity')::INTEGER THEN
            RAISE EXCEPTION 'Insufficient stock for product %', item->>'product_id';
        END IF;
        
        total_amount := total_amount + ((item->>'quantity')::INTEGER * (item->>'unit_price')::NUMERIC);
    END LOOP;
    
    -- 创建订单
    INSERT INTO orders (user_id, order_number, total_amount, status)
    VALUES (
        p_user_id,
        'ORD-' || to_char(now(), 'YYYYMMDD') || '-' || nextval('orders_id_seq'),
        total_amount,
        'confirmed'
    )
    RETURNING id INTO new_order_id;
    
    -- 插入订单项并更新库存
    FOR item IN SELECT * FROM jsonb_array_elements(p_order_items)
    LOOP
        -- 添加订单项
        INSERT INTO order_items (order_id, product_id, quantity, unit_price)
        VALUES (
            new_order_id,
            (item->>'product_id')::INTEGER,
            (item->>'quantity')::INTEGER,
            (item->>'unit_price')::NUMERIC
        );
        
        -- 预留库存
        UPDATE inventory 
        SET reserved_quantity = reserved_quantity + (item->>'quantity')::INTEGER,
            updated_at = CURRENT_TIMESTAMP
        WHERE product_id = (item->>'product_id')::INTEGER;
    END LOOP;
    
    -- 创建支付记录
    INSERT INTO payments (order_id, payment_method, amount, status)
    VALUES (new_order_id, p_payment_method, total_amount, 'pending');
    
    RETURN new_order_id;
    
EXCEPTION WHEN OTHERS THEN
    -- 事务自动回滚
    RAISE EXCEPTION 'Order creation failed: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 确认支付的函数
CREATE OR REPLACE FUNCTION confirm_payment(
    p_order_id INTEGER,
    p_transaction_id VARCHAR(100)
) RETURNS BOOLEAN AS $$
DECLARE
    order_status VARCHAR(20);
    payment_amount NUMERIC(10,2);
    inventory_item RECORD;
BEGIN
    -- 开始事务
    BEGIN
        -- 获取订单状态
        SELECT status, total_amount INTO order_status, payment_amount
        FROM orders
        WHERE id = p_order_id
        FOR UPDATE;
        
        IF order_status != 'confirmed' THEN
            RAISE EXCEPTION 'Order % cannot be confirmed, current status: %', 
                p_order_id, order_status;
        END IF;
        
        -- 更新支付状态
        UPDATE payments 
        SET status = 'completed', 
            transaction_id = p_transaction_id
        WHERE order_id = p_order_id;
        
        -- 更新订单状态
        UPDATE orders 
        SET status = 'paid', 
            updated_at = CURRENT_TIMESTAMP
        WHERE id = p_order_id;
        
        -- 更新实际库存
        FOR inventory_item IN 
            SELECT product_id, quantity, reserved_quantity
            FROM inventory
            WHERE product_id IN (SELECT product_id FROM order_items WHERE order_id = p_order_id)
        LOOP
            UPDATE inventory 
            SET quantity = quantity - (SELECT quantity FROM order_items 
                                      WHERE order_id = p_order_id AND product_id = inventory_item.product_id),
                reserved_quantity = reserved_quantity - (SELECT quantity FROM order_items 
                                                        WHERE order_id = p_order_id AND product_id = inventory_item.product_id),
                updated_at = CURRENT_TIMESTAMP
            WHERE product_id = inventory_item.product_id;
        END LOOP;
        
        RETURN TRUE;
        
    EXCEPTION WHEN OTHERS THEN
        RAISE EXCEPTION 'Payment confirmation failed: %', SQLERRM;
    END;
END;
$$ LANGUAGE plpgsql;
```

### 案例2：银行转账事务

```sql
-- 银行转账示例（展示ACID特性）
CREATE OR REPLACE FUNCTION bank_transfer(
    from_account VARCHAR(20),
    to_account VARCHAR(20),
    amount NUMERIC
) RETURNS BOOLEAN AS $$
DECLARE
    from_balance NUMERIC;
    to_balance NUMERIC;
    from_account_id INTEGER;
    to_account_id INTEGER;
BEGIN
    -- 开始事务，使用REPEATABLE READ
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
    
    -- 获取账户信息并锁定
    SELECT id, balance INTO from_account_id, from_balance
    FROM accounts
    WHERE account_number = from_account
    FOR UPDATE;
    
    IF from_account_id IS NULL THEN
        RAISE EXCEPTION 'Source account % not found', from_account;
    END IF;
    
    IF from_balance < amount THEN
        RAISE EXCEPTION 'Insufficient funds in account %', from_account;
    END IF;
    
    SELECT id, balance INTO to_account_id, to_balance
    FROM accounts
    WHERE account_number = to_account
    FOR UPDATE;
    
    IF to_account_id IS NULL THEN
        RAISE EXCEPTION 'Destination account % not found', to_account;
    END IF;
    
    -- 执行转账（模拟网络延迟）
    -- UPDATE accounts SET balance = balance - amount WHERE id = from_account_id;
    -- PERFORM pg_sleep(2); -- 模拟长时间操作
    -- UPDATE accounts SET balance = balance + amount WHERE id = to_account_id;
    
    -- 实际转账
    UPDATE accounts 
    SET balance = balance - amount, 
        updated_at = CURRENT_TIMESTAMP
    WHERE id = from_account_id;
    
    -- 模拟可能的错误情况
    IF random() < 0.1 THEN -- 10%概率失败
        RAISE EXCEPTION 'Simulated transfer failure';
    END IF;
    
    UPDATE accounts 
    SET balance = balance + amount, 
        updated_at = CURRENT_TIMESTAMP
    WHERE id = to_account_id;
    
    -- 记录转账日志
    INSERT INTO transfer_log (from_account, to_account, amount, status)
    VALUES (from_account, to_account, amount, 'completed');
    
    RETURN TRUE;
    
EXCEPTION WHEN OTHERS THEN
    -- 记录失败日志
    INSERT INTO transfer_log (from_account, to_account, amount, status, error_message)
    VALUES (from_account, to_account, amount, 'failed', SQLERRM);
    
    RAISE EXCEPTION 'Transfer failed: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 监控转账事务
CREATE OR REPLACE VIEW transfer_monitoring AS
SELECT 
    tl.id,
    tl.from_account,
    tl.to_account,
    tl.amount,
    tl.status,
    tl.transfer_time,
    tl.error_message,
    a1.balance as from_balance,
    a2.balance as to_balance
FROM transfer_log tl
LEFT JOIN accounts a1 ON a1.account_number = tl.from_account
LEFT JOIN accounts a2 ON a2.account_number = tl.to_account
ORDER BY tl.transfer_time DESC;
```

### 案例3：库存管理系统

```sql
-- 库存管理系统的事务处理
CREATE OR REPLACE FUNCTION update_inventory_safely(
    p_product_id INTEGER,
    p_quantity_change INTEGER,
    p_reason VARCHAR(100)
) RETURNS BOOLEAN AS $$
DECLARE
    current_stock INTEGER;
    new_stock INTEGER;
BEGIN
    -- 开始事务
    BEGIN
        -- 获取当前库存并锁定
        SELECT quantity INTO current_stock
        FROM inventory
        WHERE product_id = p_product_id
        FOR UPDATE;
        
        IF current_stock IS NULL THEN
            RAISE EXCEPTION 'Product % not found in inventory', p_product_id;
        END IF;
        
        new_stock := current_stock + p_quantity_change;
        
        -- 检查库存不会变为负数
        IF new_stock < 0 THEN
            RAISE EXCEPTION 'Insufficient stock for product % (current: %, requested: %)', 
                p_product_id, current_stock, p_quantity_change;
        END IF;
        
        -- 更新库存
        UPDATE inventory 
        SET quantity = new_stock,
            updated_at = CURRENT_TIMESTAMP
        WHERE product_id = p_product_id;
        
        -- 记录库存变动
        INSERT INTO inventory_transactions (product_id, old_quantity, new_quantity, change_reason)
        VALUES (p_product_id, current_stock, new_stock, p_reason);
        
        RETURN TRUE;
        
    EXCEPTION WHEN OTHERS THEN
        -- 记录库存变动失败
        INSERT INTO inventory_transactions (product_id, old_quantity, new_quantity, change_reason, error_message)
        VALUES (p_product_id, current_stock, COALESCE(new_stock, current_stock), p_reason, SQLERRM);
        
        RAISE EXCEPTION 'Inventory update failed: %', SQLERRM;
    END;
END;
$$ LANGUAGE plpgsql;
```

## 总结

PostgreSQL的事务与并发控制是一个复杂但强大的系统。通过本专题的学习，我们深入理解了：

1. **ACID特性的实现机制**：WAL日志、约束检查、MVCC技术
2. **四种隔离级别的选择**：根据业务需求选择合适的隔离级别
3. **锁机制的优化**：合理使用行锁和表锁，减少锁竞争
4. **死锁处理策略**：预防、检测和处理死锁
5. **性能优化技巧**：缩短事务时间、批量操作、索引优化
6. **故障恢复机制**：监控长时间事务、异常处理、恢复策略

最佳实践建议：
- 选择合适的隔离级别（READ COMMITTED通常是最佳选择）
- 缩短事务持续时间，避免长时间持有锁
- 使用适当的锁模式，避免不必要的锁定
- 实现事务重试机制应对序列化冲突
- 监控事务性能，及时处理异常情况

事务与并发控制是数据库应用开发的核心技能，掌握这些知识对于构建高可靠的数据库应用至关重要。

## 相关资源

- [PostgreSQL官方文档 - 事务](https://www.postgresql.org/docs/current/transaction-iso.html)
- [MVCC原理详解](https://www.postgresql.org/docs/current/mvcc.html)
- [锁监控和调优](https://www.postgresql.org/docs/current/monitoring-locks.html)
- [性能调优指南](https://www.postgresql.org/docs/current/performance-tips.html)