# PostgreSQL高级专题：备份恢复与监控

## 概述

数据备份与恢复是数据库管理的核心职能之一，而系统监控则是确保数据库健康运行的关键。本专题深入探讨PostgreSQL的备份策略、恢复技术、监控方案以及故障处理，帮助你建立完善的数据保护和监控体系。

## 目录

1. [备份策略概述](#备份策略概述)
2. [物理备份方法](#物理备份方法)
3. [逻辑备份方法](#逻辑备份方法)
4. [增量备份策略](#增量备份策略)
5. [复制与流备份](#复制与流备份)
6. [点时间恢复(PITR)](#点时间恢复pitr)
7. [恢复验证与测试](#恢复验证与测试)
8. [系统监控架构](#系统监控架构)
9. [性能监控指标](#性能监控指标)
10. [告警与通知](#告警与通知)
11. [日志管理与分析](#日志管理与分析)
12. [故障诊断与处理](#故障诊断与处理)

## 备份策略概述

### 备份类型分类

```sql
-- 查看数据库大小信息
SELECT 
    datname,
    pg_size_pretty(pg_database_size(datname)) as size,
    pg_database_size(datname) as size_bytes
FROM pg_database
WHERE datname NOT IN ('template0', 'template1', 'postgres')
ORDER BY size_bytes DESC;

-- 查看表大小信息
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) as table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) - pg_relation_size(schemaname||'.'||tablename)) as index_size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

-- 查看数据库配置
SELECT 
    name,
    setting,
    unit,
    context,
    short_desc
FROM pg_settings
WHERE name IN (
    'wal_level',
    'archive_mode',
    'archive_command',
    'max_wal_senders',
    'checkpoint_timeout',
    'checkpoint_completion_target',
    'wal_compression'
)
ORDER BY name;
```

### 备份计划制定

```sql
-- 创建备份历史表
CREATE TABLE backup_history (
    id SERIAL PRIMARY KEY,
    backup_type TEXT NOT NULL, -- 'full', 'incremental', 'wal'
    database_name TEXT NOT NULL,
    backup_location TEXT,
    backup_size BIGINT,
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    status TEXT, -- 'success', 'failed', 'partial'
    error_message TEXT,
    wal_file TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建备份配置表
CREATE TABLE backup_configuration (
    id SERIAL PRIMARY KEY,
    database_name TEXT NOT NULL,
    backup_type TEXT NOT NULL,
    schedule_cron TEXT,
    retention_days INTEGER,
    compression_enabled BOOLEAN DEFAULT true,
    encryption_enabled BOOLEAN DEFAULT false,
    location TEXT,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入示例配置
INSERT INTO backup_configuration (database_name, backup_type, schedule_cron, retention_days, compression_enabled, location, is_active)
VALUES 
    ('main_database', 'full', '0 2 * * 0', 30, true, '/backup/full', true),
    ('main_database', 'incremental', '0 2 * * 1-6', 7, true, '/backup/incremental', true),
    ('main_database', 'wal', '0 */4 * * *', 2, true, '/backup/wal', true);

-- 备份监控视图
CREATE VIEW backup_status AS
SELECT 
    bh.database_name,
    bh.backup_type,
    bh.status,
    bh.start_time,
    bh.end_time,
    bh.backup_size,
    bh.error_message,
    ROW_NUMBER() OVER (PARTITION BY bh.database_name, bh.backup_type ORDER BY bh.start_time DESC) as latest_rank
FROM backup_history bh
ORDER BY bh.database_name, bh.backup_type, bh.start_time DESC;
```

## 物理备份方法

### pg_basebackup完全备份

```sql
-- 物理备份脚本示例
-- 完整服务器级别的pg_basebackup命令：
-- pg_basebackup -h localhost -p 5432 -U postgres -D /backup/basebackup/$(date +%Y%m%d_%H%M%S) -Ft -z -P

-- 创建备份函数
CREATE OR REPLACE FUNCTION perform_basebackup(
    target_directory TEXT,
    compression BOOLEAN DEFAULT true,
    progress BOOLEAN DEFAULT true
) RETURNS TABLE(
    backup_status TEXT,
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    duration INTERVAL,
    backup_size BIGINT,
    error_message TEXT
) AS $$
DECLARE
    backup_cmd TEXT;
    start_ts TIMESTAMP;
    end_ts TIMESTAMP;
    duration_result INTERVAL;
    backup_dir TEXT;
    compression_option TEXT;
    progress_option TEXT;
    exit_status INTEGER;
    output_lines TEXT[];
BEGIN
    start_ts := clock_timestamp();
    backup_dir := target_directory || '/basebackup_' || to_char(start_ts, 'YYYYMMDD_HH24MISS');
    
    -- 构建命令选项
    compression_option := CASE WHEN compression THEN '-z' ELSE '' END;
    progress_option := CASE WHEN progress THEN '-P' ELSE '' END;
    
    backup_cmd := format(
        'pg_basebackup -h localhost -p 5432 -U %I -D %s %s %s',
        current_user,
        backup_dir,
        compression_option,
        progress_option
    );
    
    -- 执行备份
    RAISE NOTICE 'Starting basebackup: %', backup_cmd;
    
    BEGIN
        -- 这里模拟备份过程（实际环境中需要使用pg_basebackup外部命令）
        -- 在生产环境中，应该通过pg_dump或其他方式实现
        
        -- 模拟备份完成
        end_ts := clock_timestamp();
        duration_result := end_ts - start_ts;
        
        -- 记录备份历史
        INSERT INTO backup_history (
            backup_type,
            database_name,
            backup_location,
            backup_size,
            start_time,
            end_time,
            status
        ) VALUES (
            'full',
            current_database(),
            backup_dir,
            1024000000, -- 模拟大小
            start_ts,
            end_ts,
            'success'
        );
        
        RETURN QUERY
        SELECT 
            'success'::TEXT,
            start_ts,
            end_ts,
            duration_result,
            1024000000::BIGINT,
            NULL::TEXT;
            
    EXCEPTION WHEN OTHERS THEN
        end_ts := clock_timestamp();
        duration_result := end_ts - start_ts;
        
        INSERT INTO backup_history (
            backup_type,
            database_name,
            backup_location,
            backup_size,
            start_time,
            end_time,
            status,
            error_message
        ) VALUES (
            'full',
            current_database(),
            backup_dir,
            0,
            start_ts,
            end_ts,
            'failed',
            SQLERRM
        );
        
        RETURN QUERY
        SELECT 
            'failed'::TEXT,
            start_ts,
            end_ts,
            duration_result,
            0::BIGINT,
            SQLERRM::TEXT;
    END;
END;
$$ LANGUAGE plpgsql;

-- 执行基础备份
SELECT * FROM perform_basebackup('/backup', true, true);
```

### 文件级别备份

```sql
-- 创建文件系统备份函数
CREATE OR REPLACE FUNCTION file_system_backup(
    backup_path TEXT,
    include_wal BOOLEAN DEFAULT true,
    compress BOOLEAN DEFAULT true
) RETURNS TABLE(
    component TEXT,
    status TEXT,
    size BIGINT,
    error_message TEXT
) AS $$
DECLARE
    backup_time TEXT;
    backup_dir TEXT;
    component_name TEXT;
    cmd_result TEXT;
BEGIN
    backup_time := to_char(CURRENT_TIMESTAMP, 'YYYYMMDD_HH24MISS');
    backup_dir := backup_path || '/fs_backup_' || backup_time;
    
    -- 创建备份目录
    PERFORM pg_mkdirp(backup_dir);
    
    -- 备份数据目录
    component_name := 'data_directory';
    BEGIN
        -- 模拟复制数据文件
        cmd_result := 'Data files copied successfully';
        
        RETURN QUERY
        SELECT 
            component_name::TEXT,
            'success'::TEXT,
            2048000000::BIGINT, -- 模拟大小
            NULL::TEXT;
            
    EXCEPTION WHEN OTHERS THEN
        RETURN QUERY
        SELECT 
            component_name::TEXT,
            'failed'::TEXT,
            0::BIGINT,
            SQLERRM::TEXT;
    END;
    
    -- 备份配置文件
    component_name := 'config_files';
    BEGIN
        -- 模拟复制配置文件
        cmd_result := 'Config files copied successfully';
        
        RETURN QUERY
        SELECT 
            component_name::TEXT,
            'success'::TEXT,
            1024000::BIGINT,
            NULL::TEXT;
            
    EXCEPTION WHEN OTHERS THEN
        RETURN QUERY
        SELECT 
            component_name::TEXT,
            'failed'::TEXT,
            0::BIGINT,
            SQLERRM::TEXT;
    END;
    
    -- 备份WAL文件（如果需要）
    IF include_wal THEN
        component_name := 'wal_files';
        BEGIN
            -- 模拟复制WAL文件
            cmd_result := 'WAL files copied successfully';
            
            RETURN QUERY
            SELECT 
                component_name::TEXT,
                'success'::TEXT,
                512000000::BIGINT,
                NULL::TEXT;
                
        EXCEPTION WHEN OTHERS THEN
            RETURN QUERY
            SELECT 
                component_name::TEXT,
                'failed'::TEXT,
                0::BIGINT,
                SQLERRM::TEXT;
        END;
    END IF;
    
    -- 记录备份历史
    INSERT INTO backup_history (
        backup_type,
        database_name,
        backup_location,
        backup_size,
        start_time,
        end_time,
        status
    ) VALUES (
        'filesystem',
        current_database(),
        backup_dir,
        2662400000, -- 总大小
        CURRENT_TIMESTAMP,
        CURRENT_TIMESTAMP,
        'success'
    );
    
END;
$$ LANGUAGE plpgsql;

-- 执行文件系统备份
SELECT * FROM file_system_backup('/backup', true, true);
```

## 逻辑备份方法

### pg_dump逻辑备份

```sql
-- 创建逻辑备份函数
CREATE OR REPLACE FUNCTION logical_backup(
    backup_path TEXT,
    database_name TEXT DEFAULT current_database(),
    include_schema BOOLEAN DEFAULT true,
    include_data BOOLEAN DEFAULT true,
    compression_level INTEGER DEFAULT 6
) RETURNS TABLE(
    backup_type TEXT,
    file_name TEXT,
    size BIGINT,
    status TEXT,
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    duration INTERVAL,
    error_message TEXT
) AS $$
DECLARE
    backup_time TEXT;
    backup_file TEXT;
    start_ts TIMESTAMP;
    end_ts TIMESTAMP;
    duration_result INTERVAL;
    dump_cmd TEXT;
    file_size BIGINT;
    dump_options TEXT[];
BEGIN
    start_ts := clock_timestamp();
    backup_time := to_char(start_ts, 'YYYYMMDD_HH24MISS');
    backup_file := backup_path || '/' || database_name || '_backup_' || backup_time || '.sql';
    
    -- 构建pg_dump选项
    dump_options := ARRAY[]::TEXT[];
    
    IF include_schema THEN
        dump_options := array_append(dump_options, '--schema-only');
    END IF;
    
    IF include_data THEN
        dump_options := array_append(dump_options, '--data-only');
    END IF;
    
    IF compression_level > 0 THEN
        dump_options := array_append(dump_options, '--format=custom');
    END IF;
    
    -- 构建完整命令
    dump_cmd := format('pg_dump %s > %s', array_to_string(dump_options, ' '), backup_file);
    
    RAISE NOTICE 'Executing logical backup: %', dump_cmd;
    
    BEGIN
        -- 模拟pg_dump执行
        -- 实际环境中需要通过外部命令执行
        
        -- 等待处理时间
        PERFORM pg_sleep(2);
        
        end_ts := clock_timestamp();
        duration_result := end_ts - start_ts;
        file_size := 1024000000; -- 模拟文件大小
        
        -- 记录备份历史
        INSERT INTO backup_history (
            backup_type,
            database_name,
            backup_location,
            backup_size,
            start_time,
            end_time,
            status
        ) VALUES (
            'logical',
            database_name,
            backup_file,
            file_size,
            start_ts,
            end_ts,
            'success'
        );
        
        RETURN QUERY
        SELECT 
            'logical'::TEXT,
            backup_file::TEXT,
            file_size,
            'success'::TEXT,
            start_ts,
            end_ts,
            duration_result,
            NULL::TEXT;
            
    EXCEPTION WHEN OTHERS THEN
        end_ts := clock_timestamp();
        duration_result := end_ts - start_ts;
        
        -- 记录失败历史
        INSERT INTO backup_history (
            backup_type,
            database_name,
            backup_location,
            backup_size,
            start_time,
            end_time,
            status,
            error_message
        ) VALUES (
            'logical',
            database_name,
            backup_file,
            0,
            start_ts,
            end_ts,
            'failed',
            SQLERRM
        );
        
        RETURN QUERY
        SELECT 
            'logical'::TEXT,
            backup_file::TEXT,
            0::BIGINT,
            'failed'::TEXT,
            start_ts,
            end_ts,
            duration_result,
            SQLERRM::TEXT;
    END;
END;
$$ LANGUAGE plpgsql;

-- 执行逻辑备份
SELECT * FROM logical_backup('/backup', 'main_database', true, true, 6);
```

### 自定义备份格式

```sql
-- 创建压缩备份函数
CREATE OR REPLACE FUNCTION compressed_backup(
    backup_path TEXT,
    compression_level INTEGER DEFAULT 9
) RETURNS TABLE(
    file_name TEXT,
    compressed_size BIGINT,
    original_size BIGINT,
    compression_ratio NUMERIC,
    duration INTERVAL,
    status TEXT
) AS $$
DECLARE
    backup_time TEXT;
    backup_file TEXT;
    start_ts TIMESTAMP;
    end_ts TIMESTAMP;
    duration_result INTERVAL;
    original_size_val BIGINT;
    compressed_size_val BIGINT;
BEGIN
    start_ts := clock_timestamp();
    backup_time := to_char(start_ts, 'YYYYMMDD_HH24MISS');
    backup_file := backup_path || '/compressed_backup_' || backup_time || '.dump';
    
    BEGIN
        -- 模拟压缩备份过程
        -- 实际环境中使用: pg_dump --format=custom --compress=9 > backup.dump
        
        original_size_val := 2048000000; -- 2GB原始大小
        compressed_size_val := 512000000; -- 512MB压缩后大小
        
        -- 模拟压缩过程
        PERFORM pg_sleep(3);
        
        end_ts := clock_timestamp();
        duration_result := end_ts - start_ts;
        
        -- 记录压缩备份历史
        INSERT INTO backup_history (
            backup_type,
            database_name,
            backup_location,
            backup_size,
            start_time,
            end_time,
            status
        ) VALUES (
            'compressed',
            current_database(),
            backup_file,
            compressed_size_val,
            start_ts,
            end_ts,
            'success'
        );
        
        RETURN QUERY
        SELECT 
            backup_file::TEXT,
            compressed_size_val,
            original_size_val,
            (original_size_val::NUMERIC / compressed_size_val)::NUMERIC(4,2),
            duration_result,
            'success'::TEXT;
            
    EXCEPTION WHEN OTHERS THEN
        end_ts := clock_timestamp();
        duration_result := end_ts - start_ts;
        
        RETURN QUERY
        SELECT 
            backup_file::TEXT,
            0::BIGINT,
            0::BIGINT,
            0::NUMERIC,
            duration_result,
            'failed'::TEXT;
    END;
END;
$$ LANGUAGE plpgsql;

-- 执行压缩备份
SELECT * FROM compressed_backup('/backup', 9);
```

## 系统监控架构

### 监控数据采集

```sql
-- 创建系统监控表
CREATE TABLE system_metrics (
    id SERIAL PRIMARY KEY,
    metric_name TEXT NOT NULL,
    metric_value NUMERIC,
    metric_unit TEXT,
    source_system TEXT,
    collection_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    tags JSONB,
    metadata JSONB
);

-- 数据库性能指标
CREATE OR REPLACE FUNCTION collect_database_metrics()
RETURNS TABLE(
    metric_name TEXT,
    metric_value NUMERIC,
    metric_unit TEXT,
    collection_time TIMESTAMP
) AS $$
BEGIN
    -- 插入数据库指标
    INSERT INTO system_metrics (metric_name, metric_value, metric_unit, source_system, tags)
    VALUES 
        ('database.connections.active', 
         (SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active'),
         'count', 'postgres', 
         jsonb_build_object('database', current_database())),
         
        ('database.connections.idle', 
         (SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'idle'),
         'count', 'postgres',
         jsonb_build_object('database', current_database())),
         
        ('database.connections.total', 
         (SELECT COUNT(*) FROM pg_stat_activity),
         'count', 'postgres',
         jsonb_build_object('database', current_database())),
         
        ('database.transactions.commit_rate', 
         (SELECT COALESCE(xact_commit, 0) FROM pg_stat_database WHERE datname = current_database()),
         'transactions/sec', 'postgres',
         jsonb_build_object('database', current_database())),
         
        ('database.cache.hit_ratio', 
         (SELECT COALESCE(100.0 * blks_hit / (blks_hit + blks_read), 0) 
          FROM pg_stat_database WHERE datname = current_database()),
         'percentage', 'postgres',
         jsonb_build_object('database', current_database())),
         
        ('database.locks.total', 
         (SELECT COUNT(*) FROM pg_locks),
         'count', 'postgres',
         jsonb_build_object('database', current_database())),
         
        ('database.locks.waiting', 
         (SELECT COUNT(*) FROM pg_locks WHERE NOT granted),
         'count', 'postgres',
         jsonb_build_object('database', current_database()));
    
    RETURN QUERY
    SELECT 
        metric_name,
        metric_value,
        metric_unit,
        collection_time
    FROM system_metrics
    WHERE source_system = 'postgres'
        AND collection_time >= CURRENT_TIMESTAMP - INTERVAL '1 minute'
    ORDER BY collection_time DESC;
END;
$$ LANGUAGE plpgsql;

-- 收集数据库指标
SELECT * FROM collect_database_metrics();
```

### 关键性能指标(KPI)

```sql
-- 创建KPI监控视图
CREATE OR REPLACE FUNCTION get_database_kpis()
RETURNS TABLE(
    kpi_name TEXT,
    current_value NUMERIC,
    target_value NUMERIC,
    status TEXT,
    trend TEXT,
    last_updated TIMESTAMP
) AS $$
BEGIN
    -- 数据库连接数
    RETURN QUERY
    SELECT 
        'active_connections'::TEXT,
        (SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active')::NUMERIC,
        100.0::NUMERIC, -- 目标值
        CASE 
            WHEN (SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active') <= 50 THEN 'excellent'
            WHEN (SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active') <= 100 THEN 'good'
            WHEN (SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active') <= 200 THEN 'warning'
            ELSE 'critical'
        END,
        'stable'::TEXT,
        CURRENT_TIMESTAMP;
    
    -- 缓存命中率
    RETURN QUERY
    SELECT 
        'cache_hit_ratio'::TEXT,
        (SELECT COALESCE(100.0 * blks_hit / (blks_hit + blks_read), 0) FROM pg_stat_database WHERE datname = current_database())::NUMERIC,
        95.0::NUMERIC,
        CASE 
            WHEN (SELECT COALESCE(100.0 * blks_hit / (blks_hit + blks_read), 0) FROM pg_stat_database WHERE datname = current_database()) >= 95
            THEN 'excellent'
            WHEN (SELECT COALESCE(100.0 * blks_hit / (blks_hit + blks_read), 0) FROM pg_stat_database WHERE datname = current_database()) >= 90
            THEN 'good'
            WHEN (SELECT COALESCE(100.0 * blks_hit / (blks_hit + blks_read), 0) FROM pg_stat_database WHERE datname = current_database()) >= 80
            THEN 'warning'
            ELSE 'critical'
        END,
        'improving'::TEXT,
        CURRENT_TIMESTAMP;
    
    -- 事务吞吐量
    RETURN QUERY
    SELECT 
        'transaction_throughput'::TEXT,
        (SELECT COALESCE(xact_commit + xact_rollback, 0) FROM pg_stat_database WHERE datname = current_database())::NUMERIC,
        1000.0::NUMERIC,
        CASE 
            WHEN (SELECT COALESCE(xact_commit + xact_rollback, 0) FROM pg_stat_database WHERE datname = current_database()) >= 500
            THEN 'excellent'
            WHEN (SELECT COALESCE(xact_commit + xact_rollback, 0) FROM pg_stat_database WHERE datname = current_database()) >= 100
            THEN 'good'
            WHEN (SELECT COALESCE(xact_commit + xact_rollback, 0) FROM pg_stat_database WHERE datname = current_database()) >= 50
            THEN 'warning'
            ELSE 'critical'
        END,
        'increasing'::TEXT,
        CURRENT_TIMESTAMP;
    
    -- 锁等待时间
    RETURN QUERY
    SELECT 
        'lock_waiting_count'::TEXT,
        (SELECT COUNT(*) FROM pg_locks WHERE NOT granted)::NUMERIC,
        5.0::NUMERIC,
        CASE 
            WHEN (SELECT COUNT(*) FROM pg_locks WHERE NOT granted) = 0 THEN 'excellent'
            WHEN (SELECT COUNT(*) FROM pg_locks WHERE NOT granted) <= 2 THEN 'good'
            WHEN (SELECT COUNT(*) FROM pg_locks WHERE NOT granted) <= 5 THEN 'warning'
            ELSE 'critical'
        END,
        'decreasing'::TEXT,
        CURRENT_TIMESTAMP;
        
END;
$$ LANGUAGE plpgsql;

-- 获取KPI数据
SELECT * FROM get_database_kpis();
```

## 告警与通知

### 告警规则设置

```sql
-- 创建告警表
CREATE TABLE alerts (
    id SERIAL PRIMARY KEY,
    alert_name TEXT NOT NULL,
    alert_type TEXT, -- 'metric', 'event', 'custom'
    metric_name TEXT,
    condition_operator TEXT, -- '>', '<', '>=', '<=', '='
    threshold_value NUMERIC,
    severity TEXT, -- 'info', 'warning', 'critical'
    message_template TEXT,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_triggered TIMESTAMP,
    trigger_count BIGINT DEFAULT 0
);

-- 创建告警历史表
CREATE TABLE alert_history (
    id SERIAL PRIMARY KEY,
    alert_id INTEGER REFERENCES alerts(id),
    trigger_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    metric_value NUMERIC,
    message_sent TEXT,
    acknowledgment_status TEXT, -- 'pending', 'acknowledged', 'resolved'
    acknowledged_by TEXT,
    acknowledged_at TIMESTAMP,
    resolved_at TIMESTAMP,
    resolution_notes TEXT
);

-- 插入告警规则
INSERT INTO alerts (alert_name, alert_type, metric_name, condition_operator, threshold_value, severity, message_template, is_active)
VALUES 
    ('High Active Connections', 'metric', 'database.connections.active', '>', 150, 'warning', 
     'Active connections (%s) exceed threshold (%s)', true),
    ('Critical Cache Hit Ratio', 'metric', 'database.cache.hit_ratio', '<', 85.0, 'critical',
     'Cache hit ratio (%s%%) is critically low, threshold: %s%%', true),
    ('Lock Waiting High', 'metric', 'database.locks.waiting', '>', 10, 'critical',
     'High lock waiting count (%s), threshold: %s', true);

-- 创建告警检查函数
CREATE OR REPLACE FUNCTION check_alerts()
RETURNS TABLE(
    alert_name TEXT,
    condition_met BOOLEAN,
    current_value NUMERIC,
    threshold_value NUMERIC,
    severity TEXT,
    message TEXT,
    should_notify BOOLEAN
) AS $$
DECLARE
    alert_record RECORD;
    metric_value NUMERIC;
    condition_result BOOLEAN;
    message_text TEXT;
BEGIN
    -- 检查缓存命中率
    SELECT 95.0 * blks_hit / (blks_hit + blks_read) as cache_ratio
    INTO metric_value
    FROM pg_stat_database 
    WHERE datname = current_database();
    
    -- 缓存命中率告警
    condition_result := metric_value < 85.0;
    message_text := format('Cache hit ratio (%.2f%%) is critically low, threshold: 85%%', metric_value);
    
    IF condition_result THEN
        INSERT INTO alert_history (alert_id, metric_value, message_sent, acknowledgment_status)
        SELECT id, metric_value, message_text, 'pending'
        FROM alerts 
        WHERE alert_name = 'Critical Cache Hit Ratio' AND is_active;
    END IF;
    
    RETURN QUERY
    SELECT 
        'Critical Cache Hit Ratio'::TEXT,
        condition_result,
        metric_value,
        85.0,
        'critical'::TEXT,
        message_text,
        condition_result;
    
    -- 检查活跃连接数
    SELECT COUNT(*) INTO metric_value FROM pg_stat_activity WHERE state = 'active';
    
    condition_result := metric_value > 150;
    message_text := format('Active connections (%s) exceed threshold (150)', metric_value);
    
    IF condition_result THEN
        INSERT INTO alert_history (alert_id, metric_value, message_sent, acknowledgment_status)
        SELECT id, metric_value, message_text, 'pending'
        FROM alerts 
        WHERE alert_name = 'High Active Connections' AND is_active;
    END IF;
    
    RETURN QUERY
    SELECT 
        'High Active Connections'::TEXT,
        condition_result,
        metric_value,
        150.0,
        'warning'::TEXT,
        message_text,
        condition_result;
        
END;
$$ LANGUAGE plpgsql;

-- 检查告警
SELECT * FROM check_alerts();
```

### 通知系统

```sql
-- 创建通知规则表
CREATE TABLE notification_rules (
    id SERIAL PRIMARY KEY,
    alert_severity TEXT,
    notification_method TEXT, -- 'email', 'sms', 'webhook', 'slack'
    notification_target TEXT,
    is_enabled BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入通知规则
INSERT INTO notification_rules (alert_severity, notification_method, notification_target, is_enabled)
VALUES 
    ('critical', 'email', 'admin@company.com', true),
    ('critical', 'slack', '#database-alerts', true),
    ('warning', 'email', 'team@company.com', true),
    ('info', 'webhook', 'https://hooks.company.com/alerts', false);

-- 创建发送通知函数
CREATE OR REPLACE FUNCTION send_notification(
    alert_name TEXT,
    severity TEXT,
    message TEXT,
    notification_method TEXT,
    target TEXT
) RETURNS TABLE(
    notification_status TEXT,
    target TEXT,
    method TEXT,
    message TEXT,
    sent_at TIMESTAMP
) AS $$
DECLARE
    notification_sent BOOLEAN := false;
    send_result TEXT;
BEGIN
    -- 模拟发送通知
    CASE notification_method
        WHEN 'email' THEN
            -- 模拟邮件发送
            send_result := format('Email sent to %s: %s', target, message);
            notification_sent := true;
            
        WHEN 'slack' THEN
            -- 模拟Slack消息发送
            send_result := format('Slack message sent to %s: %s', target, message);
            notification_sent := true;
            
        WHEN 'webhook' THEN
            -- 模拟Webhook调用
            send_result := format('Webhook called %s with message: %s', target, message);
            notification_sent := true;
            
        ELSE
            send_result := 'Unknown notification method';
    END CASE;
    
    -- 记录通知历史
    IF notification_sent THEN
        INSERT INTO alert_history (alert_id, message_sent, acknowledgment_status)
        SELECT id, send_result, 'pending'
        FROM alerts 
        WHERE alert_name = $1;
    END IF;
    
    RETURN QUERY
    SELECT 
        CASE WHEN notification_sent THEN 'sent' ELSE 'failed' END,
        target,
        notification_method,
        message,
        CURRENT_TIMESTAMP;
        
END;
$$ LANGUAGE plpgsql;

-- 发送告警通知
SELECT * FROM send_notification('Critical Cache Hit Ratio', 'critical', 'Cache hit ratio below 85%', 'email', 'admin@company.com');
SELECT * FROM send_notification('Critical Cache Hit Ratio', 'critical', 'Cache hit ratio below 85%', 'slack', '#database-alerts');
```

## 故障诊断与处理

### 故障检测

```sql
-- 创建故障检测函数
CREATE OR REPLACE FUNCTION detect_database_issues()
RETURNS TABLE(
    issue_type TEXT,
    severity TEXT,
    description TEXT,
    recommendation TEXT,
    affected_objects TEXT
) AS $$
BEGIN
    -- 检测连接数异常
    IF (SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active') > 200 THEN
        RETURN QUERY
        SELECT 
            'high_connections'::TEXT,
            'warning'::TEXT,
            format('Active connections (%s) exceed safe limit (200)', 
                   (SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active')),
            'Consider connection pooling or increasing max_connections'::TEXT,
            'database_connections'::TEXT;
    END IF;
    
    -- 检测锁等待
    IF (SELECT COUNT(*) FROM pg_locks WHERE NOT granted) > 5 THEN
        RETURN QUERY
        SELECT 
            'lock_waits'::TEXT,
            'critical'::TEXT,
            format('High lock waiting count: %s', 
                   (SELECT COUNT(*) FROM pg_locks WHERE NOT granted)),
            'Investigate long-running transactions and deadlocks'::TEXT,
            'locks'::TEXT;
    END IF;
    
    -- 检测慢查询
    IF (SELECT COUNT(*) FROM pg_stat_activity 
        WHERE state = 'active' AND query_start < now() - INTERVAL '10 minutes') > 0 THEN
        RETURN QUERY
        SELECT 
            'long_running_queries'::TEXT,
            'warning'::TEXT,
            format('Found %s queries running longer than 10 minutes', 
                   (SELECT COUNT(*) FROM pg_stat_activity 
                    WHERE state = 'active' AND query_start < now() - INTERVAL '10 minutes')),
            'Investigate and potentially terminate long-running queries'::TEXT,
            'queries'::TEXT;
    END IF;
    
    -- 检测磁盘空间
    IF (SELECT pg_database_size(current_database()) / 1024 / 1024 / 1024) > 100 THEN
        RETURN QUERY
        SELECT 
            'database_size'::TEXT,
            'info'::TEXT,
            format('Database size is %s GB, consider archiving old data', 
                   pg_size_pretty(pg_database_size(current_database()))),
            'Implement data archival strategy or increase storage'::TEXT,
            'storage'::TEXT;
    END IF;
    
    -- 检测缓存命中率
    DECLARE
        cache_ratio NUMERIC;
    BEGIN
        SELECT COALESCE(100.0 * blks_hit / (blks_hit + blks_read), 0) 
        INTO cache_ratio
        FROM pg_stat_database 
        WHERE datname = current_database();
        
        IF cache_ratio < 90.0 THEN
            RETURN QUERY
            SELECT 
                'low_cache_hit_ratio'::TEXT,
                'warning'::TEXT,
                format('Cache hit ratio is %.2f%%, below optimal 90%%', cache_ratio),
                'Consider increasing shared_buffers or optimizing queries'::TEXT,
                'performance'::TEXT;
        END IF;
    END;
    
END;
$$ LANGUAGE plpgsql;

-- 检测数据库问题
SELECT * FROM detect_database_issues();

-- 创建问题诊断函数
CREATE OR REPLACE FUNCTION diagnose_issue(
    issue_type TEXT
) RETURNS TABLE(
    diagnostic_step TEXT,
    result_details TEXT,
    additional_info JSONB
) AS $$
BEGIN
    CASE issue_type
        WHEN 'lock_waits' THEN
            -- 诊断锁等待问题
            RETURN QUERY
            SELECT 
                'active_locks'::TEXT,
                format('Active locks: %s', (SELECT COUNT(*) FROM pg_locks WHERE granted)),
                jsonb_build_object(
                    'waiting_locks', (SELECT COUNT(*) FROM pg_locks WHERE NOT granted),
                    'blocking_queries', (
                        SELECT array_agg(DISTINCT query)
                        FROM pg_stat_activity 
                        WHERE pid IN (SELECT DISTINCT blocker.pid FROM pg_locks blocker WHERE NOT blocker.granted)
                    )
                );
                
            RETURN QUERY
            SELECT 
                'lock_details'::TEXT,
                'Lock waiting details',
                jsonb_build_object(
                    'waiters', (
                        SELECT jsonb_agg(jsonb_build_object(
                            'database', d.datname,
                            'relation', l.relation,
                            'lock_type', l.locktype,
                            'mode', l.mode,
                            'granted', l.granted
                        ))
                        FROM pg_locks l
                        JOIN pg_database d ON l.database = d.oid
                        WHERE NOT l.granted
                    )
                );
                
        WHEN 'high_connections' THEN
            -- 诊断连接问题
            RETURN QUERY
            SELECT 
                'connection_details'::TEXT,
                'Connection details',
                jsonb_build_object(
                    'total_connections', (SELECT COUNT(*) FROM pg_stat_activity),
                    'active_connections', (SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active'),
                    'idle_connections', (SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'idle'),
                    'long_running_queries', (
                        SELECT COUNT(*) FROM pg_stat_activity 
                        WHERE query_start < now() - INTERVAL '5 minutes'
                    )
                );
                
            RETURN QUERY
            SELECT 
                'top_queries'::TEXT,
                'Top resource-consuming queries',
                jsonb_build_object(
                    'queries_by_duration', (
                        SELECT jsonb_agg(jsonb_build_object(
                            'query', left(query, 100),
                            'duration', EXTRACT(EPOCH FROM (now() - query_start)),
                            'state', state
                        ))
                        FROM pg_stat_activity 
                        WHERE state = 'active'
                        ORDER BY query_start
                        LIMIT 5
                    )
                );
                
    END CASE;
    
END;
$$ LANGUAGE plpgsql;

-- 诊断特定问题
SELECT * FROM diagnose_issue('lock_waits');
SELECT * FROM diagnose_issue('high_connections');
```

## 最佳实践总结

### 备份策略最佳实践

1. **3-2-1备份规则**
   - 3份备份（原始+2份副本）
   - 2种不同的存储介质
   - 1份异地备份

2. **备份频率策略**
   - 每日增量备份
   - 每周全量备份
   - 每小时WAL归档

3. **恢复测试**
   - 定期恢复测试
   - 自动化验证
   - 文档化恢复流程

### 监控配置最佳实践

1. **关键指标监控**
   - 连接数、使用率
   - 缓存命中率
   - 锁等待情况
   - 查询性能

2. **告警阈值设置**
   - 基于历史数据设置
   - 分级告警机制
   - 避免告警风暴

3. **故障处理流程**
   - 标准化处理流程
   - 自动故障检测
   - 快速响应机制

### 日常维护任务

1. **定期检查**
   - 备份状态验证
   - 磁盘空间监控
   - 性能指标分析

2. **预防性维护**
   - 统计信息更新
   - 索引重建
   - 配置优化

3. **应急响应**
   - 故障检测和诊断
   - 快速恢复程序
   - 事后分析和改进

通过本专题的学习，你已经掌握了PostgreSQL备份恢复与监控的完整体系，能够有效保护数据安全并确保系统稳定运行。