# PostgreSQL高级专题：性能监控与调优

## 概述

PostgreSQL性能调优是一个复杂而重要的主题，涉及系统架构、查询优化、索引策略、配置参数等多个方面。本专题深入探讨PostgreSQL的性能监控方法和调优策略，帮助你构建和维护高性能的数据库系统。

## 目录

1. [性能监控基础](#性能监控基础)
2. [系统资源监控](#系统资源监控)
3. [数据库性能分析](#数据库性能分析)
4. [查询性能分析](#查询性能分析)
5. [索引优化策略](#索引优化策略)
6. [配置参数调优](#配置参数调优)
7. [连接池优化](#连接池优化)
8. [内存管理优化](#内存管理优化)
9. [I/O优化策略](#io优化策略)
10. [并发控制调优](#并发控制调优)
11. [实战调优案例](#实战调优案例)

## 性能监控基础

### 系统统计视图

```sql
-- 查看数据库活动
SELECT 
    datname as database_name,
    numbackends as active_connections,
    xact_commit,
    xact_rollback,
    blks_read,
    blks_hit,
    tup_returned,
    tup_fetched,
    tup_inserted,
    tup_updated,
    tup_deleted,
    conflicts,
    temp_files,
    temp_bytes,
    deadlocks,
    blk_read_time,
    blk_write_time
FROM pg_stat_database 
ORDER BY datname;

-- 查看表统计信息
SELECT 
    schemaname,
    relname as table_name,
    seq_scan,
    seq_tup_read,
    idx_scan,
    idx_tup_fetch,
    n_tup_ins as inserted_rows,
    n_tup_upd as updated_rows,
    n_tup_del as deleted_rows,
    n_live_tup as live_tuples,
    n_dead_tup as dead_tuples,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze,
    vacuum_count,
    autovacuum_count,
    analyze_count,
    autoanalyze_count
FROM pg_stat_user_tables
ORDER BY seq_scan DESC;

-- 查看索引使用情况
SELECT 
    t.schemaname,
    t.relname as table_name,
    i.relname as index_name,
    i.relnatts as columns_count,
    idx_scan as index_scans,
    idx_tup_read as tuples_read,
    idx_tup_fetch as tuples_fetched
FROM pg_stat_user_tables t
JOIN pg_index ix ON t.relid = ix.indrelid
JOIN pg_class i ON ix.indexrelid = i.oid
WHERE idx_scan = 0  -- 未使用的索引
ORDER BY t.relname, i.relname;

-- 查看最近的慢查询
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    min_time,
    max_time,
    stddev_time
FROM pg_stat_statements
ORDER BY mean_time DESC
LIMIT 20;
```

### 实时监控查询

```sql
-- 查看当前活动查询
SELECT 
    pid,
    usename,
    application_name,
    client_addr,
    state,
    query_start,
    state_change,
    query,
    backend_start,
    xact_start
FROM pg_stat_activity
WHERE state != 'idle'
ORDER BY query_start;

-- 查看锁等待情况
SELECT 
    a.pid as blocked_pid,
    a.usename as blocked_user,
    a.query as blocked_statement,
    a.state as blocked_state,
    a.query_start as blocked_query_start,
    b.pid as blocking_pid,
    b.usename as blocking_user,
    b.query as blocking_statement,
    b.state as blocking_state,
    b.query_start as blocking_query_start,
    c.locktype,
    c.mode,
    c.granted
FROM pg_stat_activity a
JOIN pg_locks c ON a.pid = c.pid
JOIN pg_stat_activity b ON c.locktype = 'relation' 
    AND b.pid = c.locked_by
JOIN pg_locks c2 ON b.pid = c2.pid
WHERE a.state = 'active' AND c.granted = 'false'
ORDER BY a.query_start;

-- 查看连接数和会话状态
SELECT 
    state,
    COUNT(*) as connection_count,
    string_agg(usename, ', ') as users
FROM pg_stat_activity
GROUP BY state
ORDER BY connection_count DESC;

-- 查看数据库大小和表大小
SELECT 
    datname,
    pg_size_pretty(pg_database_size(datname)) as database_size
FROM pg_database
WHERE datname NOT IN ('template0', 'template1', 'postgres')
ORDER BY pg_database_size(datname) DESC;

-- 查看表大小排序
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) as table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) - pg_relation_size(schemaname||'.'||tablename)) as index_size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

## 系统资源监控

### CPU和内存监控

```sql
-- CPU使用率统计
SELECT 
    sum(CASE WHEN state = 'active' THEN 1 ELSE 0 END) as active_processes,
    sum(CASE WHEN state = 'idle' THEN 1 ELSE 0 END) as idle_processes,
    sum(CASE WHEN state = 'idle in transaction' THEN 1 ELSE 0 END) as idle_in_transaction,
    sum(CASE WHEN state = 'idle in transaction (aborted)' THEN 1 ELSE 0 END) as idle_in_transaction_aborted,
    COUNT(*) as total_processes
FROM pg_stat_activity;

-- 缓存命中率
SELECT 
    datname,
    100.0 * blks_hit / (blks_hit + blks_read) as cache_hit_ratio,
    blks_hit,
    blks_read,
    CASE 
        WHEN blks_hit + blks_read = 0 THEN 0
        ELSE 100.0 * blks_hit / (blks_hit + blks_read)
    END as hit_ratio_percentage
FROM pg_stat_database
WHERE blks_hit + blks_read > 0
ORDER BY hit_ratio_percentage DESC;

-- 内存使用情况查询
SELECT 
    name,
    setting,
    unit,
    context
FROM pg_settings
WHERE name IN (
    'shared_buffers',
    'effective_cache_size',
    'work_mem',
    'maintenance_work_mem',
    'temp_buffers'
)
ORDER BY name;

-- 查看排序操作
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    sorts,
    tuples_sorted,
    blocks_hit,
    blocks_read
FROM pg_stat_statements
WHERE sorts > 0
ORDER BY total_time DESC
LIMIT 10;
```

### 磁盘I/O监控

```sql
-- 磁盘使用情况
SELECT 
    ts.tablespace_name,
    ts.location,
    pg_size_pretty(pg_tablespace_size(ts.tablespace_name)) as size,
    pg_size_pretty(pg_tablespace_size(ts.tablespace_name) - pg_available_free_space(ts.location)) as used,
    pg_size_pretty(pg_available_free_space(ts.location)) as free
FROM pg_tablespace ts;

-- 检查点统计
SELECT 
    checkpoints_timed,
    checkpoints_req,
    checkpoint_write_time,
    checkpoint_sync_time,
    buffers_checkpoint,
    buffers_clean,
    maxwritten_clean,
    buffers_backend,
    buffers_backend_fsync,
    buffers_alloc,
    stats_reset
FROM pg_stat_bgwriter;

-- 真空统计
SELECT 
    datname,
    n_tup_ins as inserts,
    n_tup_upd as updates,
    n_tup_del as deletes,
    n_live_tup as live_tuples,
    n_dead_tup as dead_tuples,
    last_vacuum,
    last_autovacuum,
    vacuum_count,
    autovacuum_count
FROM pg_stat_database
WHERE datname NOT IN ('template0', 'template1')
ORDER BY dead_tuples DESC;

-- 分析表膨胀
SELECT 
    schemaname,
    relname,
    pg_size_pretty(pg_relation_size(schemaname||'.'||relname)) as table_size,
    n_dead_tup as dead_tuples,
    CASE 
        WHEN pg_relation_size(schemaname||'.'||relname) > 0 
        THEN round(100.0 * n_dead_tup / (n_live_tup + n_dead_tup), 2)
        ELSE 0 
    END as dead_tuple_percentage
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000  -- 死元组超过1000的表
ORDER BY dead_tuple_percentage DESC;
```

## 数据库性能分析

### 事务分析

```sql
-- 事务统计
SELECT 
    xact_commit,
    xact_rollback,
    100.0 * xact_rollback / (xact_commit + xact_rollback) as rollback_rate
FROM pg_stat_database
WHERE datname = current_database();

-- 长事务检测
SELECT 
    pid,
    usename,
    application_name,
    client_addr,
    state,
    query_start,
    now() - query_start as duration,
    query
FROM pg_stat_activity
WHERE state = 'active' 
    AND now() - query_start > interval '10 minutes'
ORDER BY query_start;

-- 事务锁等待分析
SELECT 
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_statement,
    blocking_activity.query AS blocking_statement,
    blocked_activity.query_start AS blocked_statement_start,
    blocking_activity.query_start AS blocking_statement_start
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks ON blocking_locks.locktype = blocked_locks.locktype
WHERE NOT blocked_locks.granted AND blocking_locks.granted;

-- 复制延迟分析
SELECT 
    application_name,
    client_addr,
    state,
    pg_wal_lsn_diff(pg_current_wal_lsn(), sent_lsn) as lag_bytes,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) as replay_lag_bytes,
    write_lag,
    flush_lag,
    replay_lag
FROM pg_stat_replication;
```

### 索引使用分析

```sql
-- 未使用的索引
SELECT 
    schemaname,
    tablename,
    indexname,
    indexdef
FROM pg_indexes 
WHERE schemaname = 'public'
    AND indexname NOT IN (
        SELECT indexrelid::regclass::text
        FROM pg_index i
        JOIN pg_stat_user_tables t ON i.indrelid = t.relid
        WHERE idx_scan > 0
    )
ORDER BY tablename, indexname;

-- 索引效率分析
SELECT 
    t.schemaname,
    t.relname as table_name,
    i.relname as index_name,
    i.relnatts as columns_count,
    idx_scan as index_scans,
    idx_tup_read as tuples_read,
    CASE 
        WHEN idx_scan > 0 
        THEN round(idx_tup_read::numeric / idx_scan, 2)
        ELSE 0 
    END as avg_tuples_per_scan,
    pg_size_pretty(pg_relation_size(i.oid)) as index_size
FROM pg_stat_user_tables t
JOIN pg_index ix ON t.relid = ix.indrelid
JOIN pg_class i ON ix.indexrelid = i.oid
WHERE idx_scan > 0
ORDER BY avg_tuples_per_scan DESC;

-- 重复索引检测
SELECT 
    schemaname,
    tablename,
    array_agg(indexname) as duplicate_indexes,
    array_agg(indexdef) as index_definitions
FROM pg_indexes
WHERE schemaname = 'public'
    AND indexname NOT LIKE '%_pkey'
GROUP BY schemaname, tablename, (SELECT pg_get_indexdef(indexrelid))
HAVING COUNT(*) > 1;

-- 索引膨胀分析
SELECT 
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid::regclass)) as index_size,
    pg_size_pretty(pg_relation_size(indexrelid::regclass) - pg_relation_size(indexrelid::regclass)) as dead_space
FROM pg_stat_user_indexes
WHERE idx_scan > 0
ORDER BY pg_relation_size(indexrelid::regclass) DESC;
```

## 查询性能分析

### EXPLAIN分析

```sql
-- 创建测试表
CREATE TABLE performance_test (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    age INTEGER,
    department_id INTEGER,
    salary NUMERIC,
    hire_date DATE
);

-- 插入测试数据
INSERT INTO performance_test (name, age, department_id, salary, hire_date)
SELECT 
    'Employee ' || generate_series,
    (random() * 50 + 20)::INTEGER,
    (random() * 10 + 1)::INTEGER,
    (random() * 50000 + 30000)::NUMERIC(10,2),
    '2020-01-01'::DATE + (random() * 365)::INTEGER * INTERVAL '1 day'
FROM generate_series(1, 10000);

-- 基础查询分析
EXPLAIN (ANALYZE, BUFFERS) 
SELECT * FROM performance_test WHERE id = 5000;

-- 索引扫描 vs 全表扫描
EXPLAIN (ANALYZE, BUFFERS) 
SELECT * FROM performance_test WHERE age > 40;

-- 创建索引
CREATE INDEX idx_performance_test_age ON performance_test(age);
CREATE INDEX idx_performance_test_dept ON performance_test(department_id);

-- 复合索引
CREATE INDEX idx_performance_test_dept_age ON performance_test(department_id, age);

-- 复合索引查询分析
EXPLAIN (ANALYZE, BUFFERS) 
SELECT * FROM performance_test WHERE department_id = 5 AND age > 35;

-- JOIN查询分析
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.name as department
FROM performance_test e
JOIN (
    SELECT id, name FROM performance_test WHERE id <= 100
) d ON e.department_id = d.id;
```

### 慢查询识别

```sql
-- 启用pg_stat_statements扩展
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- 查找最慢的查询
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    min_time,
    max_time,
    rows,
    100.0 * shared_blks_hit / nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
FROM pg_stat_statements
ORDER BY mean_time DESC
LIMIT 20;

-- 查找最频繁的查询
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    rows,
    100.0 * shared_blks_hit / nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
FROM pg_stat_statements
ORDER BY calls DESC
LIMIT 20;

-- 分析特定查询
EXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT)
SELECT 
    e.name,
    e.salary,
    COUNT(o.id) as order_count,
    SUM(o.total_amount) as total_sales
FROM performance_test e
LEFT JOIN orders o ON e.id = o.user_id
WHERE e.age > 35 
    AND e.department_id IN (1, 2, 3)
GROUP BY e.id, e.name, e.salary
ORDER BY total_sales DESC NULLS LAST
LIMIT 100;
```

### 查询优化建议

```sql
-- 缓存命中率分析
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    100.0 * shared_blks_hit / nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent,
    shared_blks_hit,
    shared_blks_read,
    shared_blks_written
FROM pg_stat_statements
WHERE calls > 10
ORDER BY mean_time DESC
LIMIT 10;

-- 排序操作过多查询
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    sorts,
    tuples_sorted,
    local_blks_written
FROM pg_stat_statements
WHERE sorts > 0
ORDER BY sorts DESC
LIMIT 10;

-- 哈希操作查询
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    hash_batches,
    hash_tuples
FROM pg_stat_statements
WHERE hash_batches > 0
ORDER BY hash_batches DESC
LIMIT 10;

-- 分页查询性能
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    rows
FROM pg_stat_statements
WHERE query ILIKE '%LIMIT%'
    AND query ILIKE '%OFFSET%'
ORDER BY mean_time DESC
LIMIT 10;
```

## 索引优化策略

### 索引类型分析

```sql
-- 查看所有索引类型
SELECT 
    indexname,
    indexdef
FROM pg_indexes
WHERE schemaname = 'public'
    AND indexname NOT LIKE '%_pkey'
ORDER BY tablename, indexname;

-- B-tree索引分析
SELECT 
    t.relname as table_name,
    i.relname as index_name,
    ix.indkey as column_ordinals,
    array_to_string(
        array(
            SELECT a.attname 
            FROM pg_attribute a 
            WHERE a.attrelid = i.oid 
                AND a.attnum = ANY(ix.indkey)
            ORDER BY a.attnum
        ), 
        ', '
    ) as columns
FROM pg_class t
JOIN pg_index ix ON t.oid = ix.indrelid
JOIN pg_class i ON ix.indexrelid = i.oid
JOIN pg_namespace n ON t.relnamespace = n.oid
WHERE n.nspname = 'public'
    AND ix.indclass IS NOT NULL
ORDER BY t.relname, i.relname;

-- 复合索引设计
CREATE INDEX idx_performance_optimized 
ON performance_test(department_id, age, hire_date);

-- 索引选择性好坏分析
SELECT 
    schemaname,
    tablename,
    attname,
    most_common_vals,
    most_common_freqs,
    correlation
FROM pg_stats
WHERE schemaname = 'public'
    AND tablename = 'performance_test'
ORDER BY tablename, attname;
```

### 索引优化技巧

```sql
-- 部分索引
CREATE INDEX idx_active_employees ON performance_test(age) 
WHERE hire_date > '2022-01-01';

-- 表达式索引
CREATE INDEX idx_name_lower ON performance_test(lower(name));
CREATE INDEX idx_salary_range ON performance_test(salary) 
WHERE salary BETWEEN 30000 AND 70000;

-- 唯一索引
CREATE UNIQUE INDEX idx_unique_department_name 
ON departments(name);

-- 索引使用统计
SELECT 
    schemaname,
    tablename,
    attname,
    n_distinct,
    most_common_vals,
    most_common_freqs,
    histogram_bounds,
    correlation
FROM pg_stats
WHERE schemaname = 'public'
    AND tablename = 'performance_test'
ORDER BY tablename;

-- 索引重建建议
SELECT 
    schemaname,
    tablename,
    attname,
    inherited,
    null_frac,
    avg_width,
    n_distinct,
    most_common_vals
FROM pg_stats
WHERE schemaname = 'public'
    AND tablename = 'performance_test';
```

## 配置参数调优

### 内存配置

```sql
-- 查看内存相关配置
SELECT 
    name,
    setting,
    unit,
    context,
    short_desc
FROM pg_settings
WHERE name IN (
    'shared_buffers',
    'effective_cache_size',
    'work_mem',
    'maintenance_work_mem',
    'temp_buffers',
    'huge_pages',
    'huge_page_size',
    'max_prepared_transactions'
)
ORDER BY name;

-- 推荐配置计算
SELECT 
    current_setting('shared_buffers') as current_shared_buffers,
    current_setting('effective_cache_size') as current_effective_cache,
    current_setting('work_mem') as current_work_mem,
    CASE 
        WHEN current_setting('max_connections')::int <= 100 
        THEN '256MB' 
        ELSE '128MB' 
    END as recommended_shared_buffers,
    CASE 
        WHEN current_setting('max_connections')::int <= 100 
        THEN '4GB' 
        ELSE '2GB' 
    END as recommended_effective_cache,
    CASE 
        WHEN current_setting('max_connections')::int <= 100 
        THEN '16MB' 
        ELSE '8MB' 
    END as recommended_work_mem;

-- WAL配置
SELECT 
    name,
    setting,
    unit,
    context,
    short_desc
FROM pg_settings
WHERE name IN (
    'wal_level',
    'max_wal_senders',
    'wal_buffers',
    'checkpoint_segments',
    'checkpoint_timeout',
    'checkpoint_completion_target',
    'archive_mode',
    'archive_command'
)
ORDER BY name;

-- 检查点配置
SELECT 
    name,
    setting,
    unit,
    context,
    short_desc
FROM pg_settings
WHERE name LIKE '%checkpoint%'
ORDER BY name;
```

### 连接和会话配置

```sql
-- 连接配置
SELECT 
    name,
    setting,
    unit,
    context,
    short_desc
FROM pg_settings
WHERE name IN (
    'max_connections',
    'superuser_reserved_connections',
    'reserved_connections',
    'idle_in_transaction_session_timeout',
    'statement_timeout'
)
ORDER BY name;

-- 会话超时设置
ALTER SYSTEM SET idle_in_transaction_session_timeout = '10 minutes';
ALTER SYSTEM SET statement_timeout = '30 minutes';
ALTER SYSTEM SET lock_timeout = '10 seconds';

-- 重载配置
SELECT pg_reload_conf();

-- 验证配置
SELECT name, setting, unit 
FROM pg_settings 
WHERE name IN (
    'idle_in_transaction_session_timeout',
    'statement_timeout',
    'lock_timeout'
);
```

### 写入和I/O配置

```sql
-- I/O配置
SELECT 
    name,
    setting,
    unit,
    context,
    short_desc
FROM pg_settings
WHERE name IN (
    'random_page_cost',
    'seq_page_cost',
    'cpu_tuple_cost',
    'cpu_index_tuple_cost',
    'cpu_operator_cost',
    'effective_io_concurrency'
)
ORDER BY name;

-- 优化SSD设置
ALTER SYSTEM SET random_page_cost = '1.1';
ALTER SYSTEM SET effective_io_concurrency = '200';

-- 写入优化
SELECT 
    name,
    setting,
    unit,
    context,
    short_desc
FROM pg_settings
WHERE name IN (
    'wal_sync_method',
    'full_page_writes',
    'commit_delay',
    'commit_siblings'
)
ORDER BY name;

-- 批量插入优化配置
BEGIN;
ALTER SYSTEM SET synchronous_commit = 'off';
ALTER SYSTEM SET wal_buffers = '16MB';
-- 执行批量插入
COMMIT;
ALTER SYSTEM SET synchronous_commit = 'on';
```

## 连接池优化

### pgBouncer配置

```sql
-- pgBouncer.ini 配置示例
-- [databases]
-- postgres = host=localhost port=5432 dbname=postgres
-- myapp = host=localhost port=5432 dbname=myapp

-- [pgbouncer]
-- listen_addr = *
-- listen_port = 6432
-- auth_type = md5
-- auth_file = /etc/pgbouncer/userlist.txt
-- logfile = /var/log/pgbouncer/pgbouncer.log
-- pidfile = /var/run/pgbouncer/pgbouncer.pid

-- pool_mode = session
-- default_pool_size = 25
-- min_pool_size = 10
-- reserve_pool_size = 10
-- max_client_conn = 100
-- server_lifetime = 3600
-- server_idle_timeout = 600
-- query_timeout = 60
-- client_idle_timeout = 600
-- log_connections = 1
-- log_disconnections = 1
-- log_pooler_errors = 1

-- 连接到连接池
-- psql -h localhost -p 6432 -d myapp

-- 查看连接池状态
SHOW POOLS;
SHOW CLIENTS;
SHOW SERVERS;
SHOW CONFIG;
SHOW HELP;

-- 重启连接池
-- sudo systemctl restart pgbouncer
```

### 连接池监控

```sql
-- 连接池统计
SELECT 
    pool_name,
    database,
    user,
    pool_mode,
    client_conn,
    server_conn,
    active,
    idle,
    used,
    queued,
    max_client_conn
FROM pg_stat_database
WHERE datname = 'pgbouncer';

-- 应用连接监控
SELECT 
    state,
    COUNT(*) as connection_count,
    AVG(CASE WHEN state = 'idle' 
        THEN EXTRACT(EPOCH FROM (now() - query_start)) 
        ELSE NULL END) as avg_idle_time
FROM pg_stat_activity
GROUP BY state
ORDER BY connection_count DESC;

-- 长连接分析
SELECT 
    usename,
    application_name,
    COUNT(*) as connection_count,
    AVG(CASE WHEN state != 'idle' 
        THEN EXTRACT(EPOCH FROM (now() - query_start)) 
        ELSE NULL END) as avg_query_time
FROM pg_stat_activity
GROUP BY usename, application_name
ORDER BY connection_count DESC;
```

## 内存管理优化

### 工作内存优化

```sql
-- 内存使用分析
SELECT 
    usename,
    application_name,
    state,
    COUNT(*) as connection_count,
    SUM(CASE WHEN state != 'idle' THEN 1 ELSE 0 END) as active_connections,
    SUM(CASE WHEN state = 'idle' THEN 1 ELSE 0 END) as idle_connections
FROM pg_stat_activity
GROUP BY usename, application_name, state
ORDER BY connection_count DESC;

-- 工作内存使用情况
SELECT 
    query,
    COUNT(*) as executions,
    SUM(CASE WHEN shared_blks_hit = 0 THEN 1 ELSE 0 END) as cold_cache_queries,
    SUM(shared_blks_hit + shared_blks_read) as total_blocks_accessed,
    AVG(shared_blks_hit + shared_blks_read) as avg_blocks_per_query,
    SUM(CASE WHEN sort_hash_batches > 0 THEN 1 ELSE 0 END) as hash_operations,
    SUM(CASE WHEN sort_sortkey IS NOT NULL THEN 1 ELSE 0 END) as sort_operations
FROM pg_stat_statements
GROUP BY query
ORDER BY avg_blocks_per_query DESC
LIMIT 20;

-- 大型查询识别
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    max_time,
    rows,
    shared_blks_hit,
    shared_blks_read,
    local_blks_hit,
    local_blks_read,
    temp_blks_read,
    temp_blks_written
FROM pg_stat_statements
WHERE (shared_blks_read > 100 OR temp_blks_read > 10 OR temp_blks_written > 10)
ORDER BY shared_blks_read DESC
LIMIT 20;

-- 排序和哈希操作
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    sorts,
    sort_time,
    hash_batches,
    hash_batches_real,
    hash_mem_usage,
    hash_lookups
FROM pg_stat_statements
WHERE sorts > 0 OR hash_batches > 0
ORDER BY sort_time + hash_mem_usage DESC
LIMIT 20;
```

### 共享内存配置

```sql
-- 共享内存使用分析
SELECT 
    name,
    setting,
    unit,
    source,
    context
FROM pg_settings
WHERE name = 'shared_buffers';

-- 缓存效率分析
SELECT 
    datname,
    100.0 * blks_hit / (blks_hit + blks_read) as hit_ratio,
    blks_hit,
    blks_read,
    tup_returned,
    tup_fetched
FROM pg_stat_database
WHERE blks_hit + blks_read > 1000
ORDER BY hit_ratio DESC;

-- 缓存压力检测
SELECT 
    datname,
    numbackends,
    xact_commit,
    xact_rollback,
    blks_read,
    blks_hit,
    100.0 * blks_hit / NULLIF(blks_hit + blks_read, 0) as hit_ratio,
    CASE 
        WHEN blks_hit + blks_read = 0 THEN 0
        ELSE 100.0 * blks_read / (blks_hit + blks_read)
    END as read_ratio
FROM pg_stat_database
ORDER BY hit_ratio;

-- 自动vacuum配置
SELECT 
    name,
    setting,
    unit,
    context
FROM pg_settings
WHERE name LIKE '%autovacuum%'
ORDER BY name;
```

## I/O优化策略

### WAL优化

```sql
-- WAL配置分析
SELECT 
    name,
    setting,
    unit,
    context,
    short_desc
FROM pg_settings
WHERE name IN (
    'wal_level',
    'max_wal_senders',
    'wal_buffers',
    'checkpoint_segments',
    'checkpoint_timeout',
    'checkpoint_completion_target',
    'wal_compression',
    'wal_sync_method'
)
ORDER BY name;

-- WAL写入性能
SELECT 
    datname,
    xact_commit,
    xact_rollback,
    blks_read,
    blks_hit,
    tup_returned,
    tup_fetched,
    tup_inserted,
    tup_updated,
    tup_deleted,
    conflicts,
    temp_files,
    temp_bytes,
    deadlocks,
    blk_read_time,
    blk_write_time
FROM pg_stat_database
WHERE datname = current_database();

-- 检查点统计
SELECT 
    checkpoints_timed,
    checkpoints_req,
    checkpoint_write_time,
    checkpoint_sync_time,
    buffers_checkpoint,
    buffers_clean,
    maxwritten_clean,
    buffers_backend,
    buffers_backend_fsync,
    buffers_alloc,
    stats_reset
FROM pg_stat_bgwriter;

-- 检查点间隔优化建议
SELECT 
    checkpoint_timed,
    checkpoint_req,
    buffers_written,
    buffers_clean,
    buffers_backend,
    checkpoint_duration
FROM pg_stat_bgwriter_history
ORDER BY checkpoint_timed DESC
LIMIT 10;
```

### 存储优化

```sql
-- 表空间分析
SELECT 
    spcname as tablespace_name,
    pg_catalog.pg_tablespace_location(oid) as location,
    pg_size_pretty(pg_tablespace_size(oid)) as size
FROM pg_tablespace
ORDER BY pg_tablespace_size(oid) DESC;

-- 大表识别
SELECT 
    schemaname,
    tablename,
    n_tup_ins,
    n_tup_upd,
    n_tup_del,
    n_live_tup,
    n_dead_tup,
    last_vacuum,
    last_autovacuum,
    vacuum_count,
    autovacuum_count
FROM pg_stat_user_tables
ORDER BY n_live_tup DESC
LIMIT 20;

-- 分区表分析
SELECT 
    n.nspname as schema_name,
    c.relname as table_name,
    c.relname || '_' || p.partstrat || '_' || p.partnatts as partition_name,
    pg_size_pretty(pg_relation_size(p.oid)) as partition_size,
    p.partstrat,
    p.partnatts,
    p.partexpr
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
JOIN pg_partition p ON c.oid = p.parrelid
WHERE c.relkind = 'r'
ORDER BY c.relname, p.partstrat;

-- 存储参数优化
SELECT 
    schemaname,
    tablename,
    hasoids,
    relfillfactor,
    reloptions
FROM pg_tables t
JOIN pg_class c ON c.relname = t.tablename
JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE n.nspname = 'public'
    AND t.tablename LIKE 'performance_test%'
ORDER BY schemaname, tablename;
```

## 并发控制调优

### 锁监控

```sql
-- 锁等待分析
SELECT 
    a.pid,
    a.usename,
    a.application_name,
    a.client_addr,
    a.state,
    a.query_start,
    a.query,
    EXTRACT(EPOCH FROM (now() - a.query_start)) as query_duration,
    l.locktype,
    l.mode,
    l.granted
FROM pg_stat_activity a
JOIN pg_locks l ON a.pid = l.pid
WHERE a.state = 'active'
    AND l.granted = 'false'
ORDER BY query_duration DESC;

-- 锁模式分析
SELECT 
    l.locktype,
    l.mode,
    COUNT(*) as lock_count,
    COUNT(CASE WHEN l.granted THEN 1 END) as granted_locks,
    COUNT(CASE WHEN NOT l.granted THEN 1 END) as waiting_locks
FROM pg_locks l
GROUP BY l.locktype, l.mode
ORDER BY lock_count DESC;

-- 死锁检测
SELECT 
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocked_activity.query AS blocked_query,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocking_activity.query AS blocking_query,
    blocked_activity.query_start AS blocked_query_start,
    blocking_activity.query_start AS blocking_query_start,
    EXTRACT(EPOCH FROM (now() - blocked_activity.query_start)) as blocked_duration
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks ON blocking_locks.locktype = blocked_locks.locktype
    AND blocking_locks.lockable_pa = blocked_locks.lockable_pa
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;

-- 事务隔离级别影响
SELECT 
    name,
    setting,
    unit,
    context,
    short_desc
FROM pg_settings
WHERE name IN (
    'transaction_isolation',
    'transaction_read_only',
    'serializable_snapshot_depth'
)
ORDER BY name;
```

### 并发优化配置

```sql
-- 并发相关配置
SELECT 
    name,
    setting,
    unit,
    context,
    short_desc
FROM pg_settings
WHERE name IN (
    'max_connections',
    'superuser_reserved_connections',
    'autovacuum_max_workers',
    'max_worker_processes',
    'max_parallel_workers',
    'max_parallel_workers_per_gather',
    'parallel_leader_participation'
)
ORDER BY name;

-- 并行查询分析
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    parallel_leader_participation,
    parallel_workers
FROM pg_stat_statements
WHERE parallel_leader_participation > 0
ORDER BY parallel_leader_participation DESC
LIMIT 10;

-- 并行查询配置优化
ALTER SYSTEM SET max_parallel_workers_per_gather = 4;
ALTER SYSTEM SET parallel_tuple_cost = 0.1;
ALTER SYSTEM SET parallel_setup_cost = 1000.0;
ALTER SYSTEM SET max_parallel_workers = 8;

-- 资源管理器配置
SELECT 
    name,
    setting,
    unit,
    context,
    short_desc
FROM pg_settings
WHERE name IN (
    'enable_hashjoin',
    'enable_mergejoin',
    'enable_nestloop',
    'enable_gathermerge',
    'enable_parallel_hash',
    'force_parallel_mode'
)
ORDER BY name;
```

## 实战调优案例

### 电商系统性能调优

```sql
-- 场景：电商订单查询性能问题

-- 1. 问题诊断
-- 慢查询分析
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    max_time,
    rows
FROM pg_stat_statements
WHERE query ILIKE '%orders%'
ORDER BY mean_time DESC
LIMIT 10;

-- 表结构分析
\d+ orders

-- 索引分析
SELECT 
    indexname,
    indexdef,
    pg_size_pretty(pg_relation_size(indexrelid::regclass)) as index_size
FROM pg_indexes
WHERE schemaname = 'public'
    AND tablename = 'orders'
ORDER BY indexname;

-- 2. 优化实施
-- 创建复合索引优化订单查询
CREATE INDEX CONCURRENTLY idx_orders_user_status_date 
ON orders(user_id, status, order_date DESC);

-- 创建部分索引优化活跃订单
CREATE INDEX CONCURRENTLY idx_orders_active 
ON orders(order_date DESC) 
WHERE status IN ('pending', 'processing', 'shipped');

-- 创建表达式索引
CREATE INDEX CONCURRENTLY idx_orders_month 
ON orders(date_trunc('month', order_date));

-- 3. 优化验证
EXPLAIN (ANALYZE, BUFFERS)
SELECT o.*, u.name as customer_name
FROM orders o
JOIN users u ON o.user_id = u.id
WHERE o.status = 'processing'
    AND o.order_date >= CURRENT_DATE - INTERVAL '30 days'
ORDER BY o.order_date DESC
LIMIT 100;

-- 4. 性能监控
SELECT 
    indexname,
    index_scan,
    pg_size_pretty(pg_relation_size(indexrelid::regclass)) as index_size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
    AND tablename = 'orders'
ORDER BY index_scan DESC;
```

### 数据仓库查询优化

```sql
-- 场景：数据仓库复杂聚合查询优化

-- 1. 查询分析
EXPLAIN (ANALYZE, BUFFERS)
SELECT 
    DATE_TRUNC('month', order_date) as month,
    d.name as department,
    COUNT(*) as order_count,
    SUM(total_amount) as total_revenue,
    AVG(total_amount) as avg_order_value
FROM orders o
JOIN employees e ON o.user_id = e.id
JOIN departments d ON e.department_id = d.id
WHERE order_date >= '2023-01-01'
GROUP BY month, d.name
ORDER BY month, total_revenue DESC;

-- 2. 物化视图创建
CREATE MATERIALIZED VIEW monthly_sales_summary AS
SELECT 
    DATE_TRUNC('month', order_date) as month,
    d.name as department,
    COUNT(*) as order_count,
    SUM(total_amount) as total_revenue,
    AVG(total_amount) as avg_order_value,
    COUNT(DISTINCT o.user_id) as unique_customers
FROM orders o
JOIN employees e ON o.user_id = e.id
JOIN departments d ON e.department_id = d.id
GROUP BY month, d.name;

-- 3. 物化视图索引
CREATE INDEX idx_monthly_sales_month ON monthly_sales_summary(month);
CREATE INDEX idx_monthly_sales_department ON monthly_sales_summary(department);

-- 4. 定期刷新
CREATE OR REPLACE FUNCTION refresh_monthly_sales_summary()
RETURNS VOID AS $$
BEGIN
    REFRESH MATERIALIZED VIEW monthly_sales_summary;
END;
$$ LANGUAGE plpgsql;

-- 设置定时任务
-- SELECT cron.schedule('refresh-monthly-sales', '0 2 * * *', 'SELECT refresh_monthly_sales_summary();');
```

### 高并发场景优化

```sql
-- 场景：高并发读写场景下的连接池优化

-- 1. 连接池配置验证
SHOW pool_mode;
SHOW default_pool_size;
SHOW min_pool_size;
SHOW max_client_conn;

-- 2. 会话超时设置
ALTER SYSTEM SET idle_in_transaction_session_timeout = '5 minutes';
ALTER SYSTEM SET statement_timeout = '60 seconds';
ALTER SYSTEM SET lock_timeout = '10 seconds';

-- 3. 并发控制配置
ALTER SYSTEM SET max_connections = 200;
ALTER SYSTEM SET superuser_reserved_connections = 3;
ALTER SYSTEM SET autovacuum_max_workers = 4;

-- 4. 内存优化
ALTER SYSTEM SET shared_buffers = '2GB';
ALTER SYSTEM SET effective_cache_size = '6GB';
ALTER SYSTEM SET work_mem = '16MB';
ALTER SYSTEM SET maintenance_work_mem = '256MB';

-- 5. 写入优化
ALTER SYSTEM SET wal_buffers = '16MB';
ALTER SYSTEM SET checkpoint_completion_target = 0.9;
ALTER SYSTEM SET max_wal_size = '4GB';
ALTER SYSTEM SET min_wal_size = '1GB';

-- 6. 并行查询优化
ALTER SYSTEM SET max_parallel_workers_per_gather = 4;
ALTER SYSTEM SET parallel_tuple_cost = 0.1;
ALTER SYSTEM SET parallel_setup_cost = 1000.0;
ALTER SYSTEM SET max_parallel_workers = 8;

-- 7. 重载配置并验证
SELECT pg_reload_conf();

-- 8. 性能验证
SELECT 
    name,
    setting,
    unit
FROM pg_settings
WHERE name IN (
    'max_connections',
    'shared_buffers',
    'work_mem',
    'effective_cache_size'
)
ORDER BY name;
```

### 定期维护自动化

```sql
-- 创建性能维护函数
CREATE OR REPLACE FUNCTION performance_maintenance()
RETURNS TABLE(
    maintenance_type TEXT,
    table_name TEXT,
    action_taken TEXT,
    duration_seconds NUMERIC
) AS $$
DECLARE
    start_time TIMESTAMP;
    end_time TIMESTAMP;
    result RECORD;
BEGIN
    -- 更新统计信息
    start_time := clock_timestamp();
    ANALYZE;
    end_time := clock_timestamp();
    
    RETURN QUERY
    SELECT 
        'ANALYZE'::TEXT,
        'ALL TABLES'::TEXT,
        'Statistics updated'::TEXT,
        EXTRACT(EPOCH FROM (end_time - start_time))::NUMERIC;

    -- 清理未使用的索引
    FOR result IN (
        SELECT 
            t.schemaname,
            t.relname as table_name,
            i.relname as index_name
        FROM pg_stat_user_tables t
        JOIN pg_index ix ON t.relid = ix.indrelid
        JOIN pg_class i ON ix.indexrelid = i.oid
        WHERE idx_scan = 0 
            AND i.relname NOT LIKE '%_pkey'
            AND i.relname NOT LIKE '%unique%'
    ) LOOP
        BEGIN
            start_time := clock_timestamp();
            EXECUTE format('DROP INDEX IF EXISTS %I.%I', result.schemaname, result.index_name);
            end_time := clock_timestamp();
            
            RETURN QUERY
            SELECT 
                'DROP UNUSED INDEX'::TEXT,
                result.table_name::TEXT,
                format('Dropped index %s', result.index_name)::TEXT,
                EXTRACT(EPOCH FROM (end_time - start_time))::NUMERIC;
        EXCEPTION WHEN OTHERS THEN
            -- 继续处理其他索引
            NULL;
        END;
    END LOOP;
    
    -- 记录维护历史
    INSERT INTO maintenance_log (maintenance_type, details, created_at)
    VALUES ('PERFORMANCE', 'Automatic performance maintenance completed', CURRENT_TIMESTAMP);
    
    RETURN;
END;
$$ LANGUAGE plpgsql;

-- 执行维护
SELECT * FROM performance_maintenance();

-- 创建定时维护
-- SELECT cron.schedule('performance-maintenance', '0 3 * * *', 'SELECT performance_maintenance();');
```

## 总结

PostgreSQL性能监控与调优是一个持续的过程，需要系统性的方法和持续的监控。本专题的主要收获包括：

### 核心监控技能
1. **系统资源监控**：CPU、内存、I/O、磁盘使用率分析
2. **数据库性能分析**：事务统计、锁等待、查询性能监控
3. **查询性能分析**：慢查询识别、EXPLAIN分析、索引使用统计
4. **实时监控技术**：活动查询、连接状态、性能指标实时追踪

### 调优策略掌握
1. **索引优化**：复合索引、部分索引、表达式索引的正确使用
2. **配置参数调优**：内存、连接、I/O等关键参数的优化配置
3. **连接池管理**：pgBouncer配置和连接池性能监控
4. **并发控制**：锁机制理解、死锁预防、并行查询优化

### 最佳实践总结
- 建立完善的监控体系，定期检查关键性能指标
- 根据业务特点选择合适的索引策略
- 合理配置连接池，控制连接资源使用
- 实施自动化维护，定期更新统计信息
- 建立性能基准，持续优化数据库性能

通过系统性的监控和科学的调优方法，能够确保PostgreSQL数据库始终保持最优性能，支持业务快速发展。