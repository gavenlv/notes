# PostgreSQLä½¿ç”¨é«˜çº§ä¸“é¢˜ - å®æˆ˜åº”ç”¨ä¸æœ€ä½³å®è·µ

## ç›®å½•
1. [ä¼ä¸šçº§éƒ¨ç½²æœ€ä½³å®è·µ](#1-ä¼ä¸šçº§éƒ¨ç½²æœ€ä½³å®è·µ)
2. [å¤šç§Ÿæˆ·æ¶æ„è®¾è®¡](#2-å¤šç§Ÿæˆ·æ¶æ„è®¾è®¡)
3. [å¾®æœåŠ¡ä¸PostgreSQLé›†æˆ](#3-å¾®æœåŠ¡ä¸postgresqlé›†æˆ)
4. [æ•°æ®è¿ç§»ä¸å‡çº§ç­–ç•¥](#4-æ•°æ®è¿ç§»ä¸å‡çº§ç­–ç•¥)
5. [å…¨æ–‡æœç´¢å®æˆ˜](#5-å…¨æ–‡æœç´¢å®æˆ˜)
6. [GISåœ°ç†ç©ºé—´æ•°æ®å¤„ç†](#6-gisåœ°ç†ç©ºé—´æ•°æ®å¤„ç†)
7. [é«˜å¹¶å‘åœºæ™¯ä¼˜åŒ–](#7-é«˜å¹¶å‘åœºæ™¯ä¼˜åŒ–)
8. [æ•…éšœè¯Šæ–­ä¸æ¢å¤å®æˆ˜](#8-æ•…éšœè¯Šæ–­ä¸æ¢å¤å®æˆ˜)
9. [ç›‘æ§ä¸è¿ç»´è‡ªåŠ¨åŒ–](#9-ç›‘æ§ä¸è¿ç»´è‡ªåŠ¨åŒ–)
10. [æ€§èƒ½è°ƒä¼˜å®æˆ˜æ¡ˆä¾‹](#10-æ€§èƒ½è°ƒä¼˜å®æˆ˜æ¡ˆä¾‹)

---

## 1. ä¼ä¸šçº§éƒ¨ç½²æœ€ä½³å®è·µ

### 1.1 ç”Ÿäº§ç¯å¢ƒé…ç½®ä¼˜åŒ–

#### 1.1.1 postgresql.conf å…³é”®å‚æ•°é…ç½®
```sql
-- å†…å­˜é…ç½®
shared_buffers = 256MB                -- ç³»ç»Ÿå†…å­˜çš„25%
effective_cache_size = 1GB            -- ç³»ç»Ÿå†…å­˜çš„75%
work_mem = 4MB                        -- æ ¹æ®å¹¶å‘æŸ¥è¯¢æ•°è°ƒæ•´
maintenance_work_mem = 64MB           -- ç»´æŠ¤æ“ä½œå†…å­˜

-- æ£€æŸ¥ç‚¹é…ç½®
checkpoint_completion_target = 0.9    -- æ£€æŸ¥ç‚¹å®Œæˆç›®æ ‡
wal_buffers = 16MB                    -- WALç¼“å†²åŒº
checkpoint_timeout = 10min            -- æ£€æŸ¥ç‚¹è¶…æ—¶

-- è¿æ¥é…ç½®
max_connections = 100                 -- æ ¹æ®åº”ç”¨éœ€æ±‚è°ƒæ•´
superuser_reserved_connections = 3    -- è¶…çº§ç”¨æˆ·ä¿ç•™è¿æ¥

-- æ€§èƒ½ç›¸å…³
random_page_cost = 1.1                -- SSDå­˜å‚¨ä¼˜åŒ–
effective_io_concurrency = 200        -- SSDå¹¶å‘I/O
max_worker_processes = 8              -- åå°å·¥ä½œè¿›ç¨‹
max_parallel_workers_per_gather = 4   -- æ¯ä¸ªæŸ¥è¯¢çš„å¹¶è¡Œå·¥ä½œè¿›ç¨‹

-- æ—¥å¿—é…ç½®
log_destination = 'stderr'
logging_collector = on
log_directory = 'log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_min_duration_statement = 1000     -- è®°å½•æ…¢æŸ¥è¯¢
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
log_checkpoints = on
log_connections = on
log_disconnections = on
log_lock_waits = on
log_temp_files = 0
```

#### 1.1.2 pg_hba.conf å®‰å…¨é…ç½®
```bash
# TYPE  DATABASE        USER            ADDRESS                 METHOD
# æœ¬åœ°è¿æ¥
local   all             all                                     trust
# IPv4æœ¬åœ°è¿æ¥
host    all             all             127.0.0.1/32            scram-sha-256
# IPv6æœ¬åœ°è¿æ¥
host    all             all             ::1/128                 scram-sha-256
# å†…éƒ¨ç½‘ç»œè¿æ¥
host    all             all             192.168.1.0/24          scram-sha-256
# åº”ç”¨æœåŠ¡å™¨è¿æ¥
host    app_db          app_user        10.0.0.100/32           scram-sha-256
# æŠ¥è¡¨ç³»ç»Ÿåªè¯»è¿æ¥
host    app_db          report_user     10.0.0.0/24             scram-sha-256
# ç¦æ­¢å¤–éƒ¨è¿æ¥
host    all             all             0.0.0.0/0               reject
```

#### 1.1.3 ç”Ÿäº§ç¯å¢ƒåˆå§‹åŒ–è„šæœ¬
```sql
-- ç”Ÿäº§ç¯å¢ƒåˆå§‹åŒ–è„šæœ¬
BEGIN;

-- åˆ›å»ºåº”ç”¨ç”¨æˆ·
CREATE ROLE app_user WITH
    LOGIN PASSWORD 'secure_password'
    NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT;

-- åˆ›å»ºåªè¯»ç”¨æˆ·
CREATE ROLE report_user WITH
    LOGIN PASSWORD 'report_password'
    NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT;

-- åˆ›å»ºæ•°æ®åº“
CREATE DATABASE app_db
    WITH OWNER = app_user
    ENCODING = 'UTF8'
    LC_COLLATE = 'en_US.UTF-8'
    LC_CTYPE = 'en_US.UTF-8';

-- è¿æ¥æ•°æ®åº“
\c app_db

-- åˆ›å»ºæ¨¡å¼
CREATE SCHEMA app_schema AUTHORIZATION app_user;
CREATE SCHEMA reports AUTHORIZATION report_user;

-- è®¾ç½®é»˜è®¤æœç´¢è·¯å¾„
ALTER DATABASE app_db SET search_path TO app_schema, public;

-- åˆ›å»ºåº”ç”¨è¡¨
CREATE TABLE app_schema.users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT true
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_users_email ON app_schema.users(email);
CREATE INDEX idx_users_active ON app_schema.users(is_active);

-- åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE OR REPLACE FUNCTION app_schema.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON app_schema.users
    FOR EACH ROW
    EXECUTE FUNCTION app_schema.update_updated_at_column();

-- è®¾ç½®æƒé™
GRANT USAGE ON SCHEMA app_schema TO app_user;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA app_schema TO app_user;
GRANT USAGE ON SCHEMA reports TO report_user;
GRANT SELECT ON ALL TABLES IN SCHEMA app_schema TO report_user;

-- åˆ›å»ºè§†å›¾
CREATE VIEW reports.user_stats AS
SELECT 
    DATE_TRUNC('month', created_at) as month,
    COUNT(*) as total_users,
    COUNT(CASE WHEN is_active THEN 1 END) as active_users
FROM app_schema.users
GROUP BY DATE_TRUNC('month', created_at)
ORDER BY month;

COMMIT;
```

---

## 2. å¤šç§Ÿæˆ·æ¶æ„è®¾è®¡

### 2.1 ç§Ÿæˆ·éš”ç¦»ç­–ç•¥

#### 2.1.1 æ•°æ®åº“çº§éš”ç¦»
```sql
-- ä¸ºæ¯ä¸ªç§Ÿæˆ·åˆ›å»ºç‹¬ç«‹çš„æ•°æ®åº“
-- é€‚åˆç§Ÿæˆ·æ•°é‡è¾ƒå°‘çš„æƒ…å†µ

CREATE DATABASE tenant_a_db OWNER tenant_a_user;
CREATE DATABASE tenant_b_db OWNER tenant_b_user;

-- è¿æ¥ç‰¹å®šç§Ÿæˆ·æ•°æ®åº“
\c tenant_a_db;

-- åˆ›å»ºç§Ÿæˆ·ç‰¹å®šè¡¨ç»“æ„
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    tenant_id INTEGER DEFAULT 1,
    customer_id INTEGER NOT NULL,
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    total_amount DECIMAL(10,2) NOT NULL
);
```

#### 2.1.2 æ¨¡å¼çº§éš”ç¦»
```sql
-- å¤šç§Ÿæˆ·æ¨¡å¼çº§éš”ç¦»
-- é€‚åˆä¸­ç­‰æ•°é‡ç§Ÿæˆ·

-- ä¸ºæ¯ä¸ªç§Ÿæˆ·åˆ›å»ºç‹¬ç«‹çš„schema
CREATE SCHEMA tenant_a;
CREATE SCHEMA tenant_b;

-- åœ¨æ¨¡å¼ä¸­åˆ›å»ºè¡¨
CREATE TABLE tenant_a.users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL
);

CREATE TABLE tenant_b.users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL
);

-- åˆ›å»ºåˆ‡æ¢ç§Ÿæˆ·çš„å‡½æ•°
CREATE OR REPLACE FUNCTION switch_tenant(tenant_name TEXT)
RETURNS TEXT AS $$
DECLARE
    new_path TEXT;
BEGIN
    new_path := 'SET search_path TO ' || tenant_name || ', public';
    EXECUTE new_path;
    RETURN 'Switched to tenant: ' || tenant_name;
END;
$$ LANGUAGE plpgsql;
```

#### 2.1.3 è¡Œçº§éš”ç¦»ï¼ˆæ¨èï¼‰
```sql
-- è¡Œçº§éš”ç¦»ï¼Œæœ€å¸¸ç”¨æ–¹æ¡ˆ
-- é€‚åˆå¤§é‡ç§Ÿæˆ·çš„æƒ…å†µ

CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    tenant_id INTEGER NOT NULL,
    customer_id INTEGER NOT NULL,
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    total_amount DECIMAL(10,2) NOT NULL,
    CONSTRAINT chk_tenant_id CHECK (tenant_id > 0)
);

-- åˆ›å»ºåˆ†åŒºè¡¨ä»¥æé«˜æ€§èƒ½
CREATE TABLE orders_partitioned (
    LIKE orders INCLUDING ALL
) PARTITION BY RANGE (tenant_id);

-- æŒ‰ç§Ÿæˆ·IDåˆ†åŒº
CREATE TABLE orders_tenant_1 PARTITION OF orders_partitioned
    FOR VALUES FROM (1) TO (101);

CREATE TABLE orders_tenant_101 PARTITION OF orders_partitioned
    FOR VALUES FROM (101) TO (201);

-- ç´¢å¼•ç­–ç•¥
CREATE INDEX idx_orders_tenant ON orders_partitioned(tenant_id);
CREATE INDEX idx_orders_tenant_date ON orders_partitioned(tenant_id, order_date);

-- RLSç­–ç•¥å®ç°ç§Ÿæˆ·éš”ç¦»
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;

CREATE POLICY tenant_isolation_policy ON orders
    FOR ALL
    TO application_role
    USING (tenant_id = current_setting('app.current_tenant_id')::INTEGER);
```

#### 2.1.4 ç§Ÿæˆ·ç®¡ç†å‡½æ•°
```sql
-- ç§Ÿæˆ·ç®¡ç†å‡½æ•°
CREATE OR REPLACE FUNCTION create_tenant(
    tenant_name TEXT,
    tenant_description TEXT DEFAULT NULL
)
RETURNS INTEGER AS $$
DECLARE
    tenant_id INTEGER;
BEGIN
    -- è·å–ä¸‹ä¸€ä¸ªç§Ÿæˆ·ID
    SELECT COALESCE(MAX(tenant_id), 0) + 1 INTO tenant_id
    FROM tenants;
    
    -- æ’å…¥ç§Ÿæˆ·ä¿¡æ¯
    INSERT INTO tenants (tenant_id, name, description, created_at)
    VALUES (tenant_id, tenant_name, tenant_description, CURRENT_TIMESTAMP);
    
    RETURN tenant_id;
END;
$$ LANGUAGE plpgsql;

-- ç§Ÿæˆ·åˆ‡æ¢å‡½æ•°
CREATE OR REPLACE FUNCTION set_tenant_context(tenant_id INTEGER)
RETURNS BOOLEAN AS $$
BEGIN
    PERFORM pg_catalog.set_config('app.current_tenant_id', tenant_id::TEXT, true);
    RETURN true;
END;
$$ LANGUAGE plpgsql;

-- ç§Ÿæˆ·éªŒè¯å‡½æ•°
CREATE OR REPLACE FUNCTION validate_tenant_access(tenant_id INTEGER)
RETURNS BOOLEAN AS $$
DECLARE
    tenant_exists BOOLEAN;
BEGIN
    SELECT EXISTS(SELECT 1 FROM tenants WHERE tenant_id = validate_tenant_access.tenant_id)
    INTO tenant_exists;
    
    IF NOT tenant_exists THEN
        RAISE EXCEPTION 'Tenant % does not exist', tenant_id;
    END IF;
    
    RETURN true;
END;
$$ LANGUAGE plpgsql;
```

---

## 3. å¾®æœåŠ¡ä¸PostgreSQLé›†æˆ

### 3.1 è¿æ¥æ± é…ç½®

#### 3.1.1 PgBounceré…ç½®
```bash
# pgbouncer.ini
[databases]
app_db = host=localhost port=5432 dbname=app_db

[pgbouncer]
listen_addr = 127.0.0.1
listen_port = 6432
auth_type = scram-sha-256
auth_file = /etc/pgbouncer/userlist.txt

# è¿æ¥æ± æ¨¡å¼
pool_mode = transaction  # transaction, session, statement

# è¿æ¥æ± é…ç½®
default_pool_size = 25
min_pool_size = 5
max_client_conn = 1000
reserve_pool_size = 5
reserve_pool_timeout = 3

# è¶…æ—¶é…ç½®
server_idle_timeout = 600
server_lifetime = 3600
server_connect_timeout = 15
query_timeout = 60

# æ—¥å¿—é…ç½®
log_connections = 1
log_disconnections = 1
log_pooler_errors = 1
stats_period = 60
```

#### 3.1.2 åº”ç”¨å±‚è¿æ¥ç®¡ç†
```java
// Java Spring Boot é…ç½®
@Configuration
public class DatabaseConfig {
    
    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:postgresql://localhost:6432/app_db");
        config.setUsername("app_user");
        config.setPassword("secure_password");
        
        // è¿æ¥æ± é…ç½®
        config.setMaximumPoolSize(20);
        config.setMinimumIdle(5);
        config.setIdleTimeout(300000);
        config.setConnectionTimeout(20000);
        config.setMaxLifetime(1200000);
        
        // ç›‘æ§é…ç½®
        config.setPoolName("PostgreSQLPool");
        config.setLeakDetectionThreshold(60000);
        
        // PostgreSQLç‰¹å®šé…ç½®
        config.addDataSourceProperty("cachePrepStmts", "true");
        config.addDataSourceProperty("prepStmtCacheSize", "250");
        config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
        config.addDataSourceProperty("useServerPrepStmts", "true");
        
        return new HikariDataSource(config);
    }
}
```

### 3.2 äº‹åŠ¡ç®¡ç†

#### 3.2.1 åˆ†å¸ƒå¼äº‹åŠ¡æ¨¡å¼
```sql
-- ä½¿ç”¨ä¸¤é˜¶æ®µæäº¤å®ç°åˆ†å¸ƒå¼äº‹åŠ¡
BEGIN;
    -- æ›´æ–°è®¢å•è¡¨
    UPDATE orders SET status = 'processing' WHERE id = 1001;
    
    -- é¢„ç•™åº“å­˜ï¼ˆé€šè¿‡é“¾æ¥æœåŠ¡å™¨ï¼‰
    UPDATE remote_inventory.inventory 
    SET reserved_quantity = reserved_quantity + 1 
    WHERE product_id = 2001;
    
    -- è®°å½•å®¡è®¡æ—¥å¿—
    INSERT INTO audit_log (action, entity_type, entity_id, timestamp)
    VALUES ('ORDER_PROCESSING', 'order', 1001, CURRENT_TIMESTAMP);
    
    -- å‡†å¤‡æäº¤
    PREPARE TRANSACTION 'order_processing_001';
COMMIT;

-- å¦‚æœæ‰€æœ‰å‚ä¸è€…éƒ½å‡†å¤‡æˆåŠŸï¼Œæäº¤äº‹åŠ¡
COMMIT PREPARED 'order_processing_001';

-- å¦‚æœä»»ä½•å‚ä¸è€…å¤±è´¥ï¼Œå›æ»šäº‹åŠ¡
ROLLBACK PREPARED 'order_processing_001';
```

#### 3.2.2 äº‹ä»¶é©±åŠ¨æ¶æ„
```sql
-- äº‹ä»¶è¡¨è®¾è®¡
CREATE TABLE events (
    id SERIAL PRIMARY KEY,
    event_type VARCHAR(100) NOT NULL,
    aggregate_id VARCHAR(100) NOT NULL,
    aggregate_type VARCHAR(50) NOT NULL,
    event_data JSONB NOT NULL,
    event_version INTEGER NOT NULL,
    occurred_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    processed_at TIMESTAMP,
    retry_count INTEGER DEFAULT 0,
    status VARCHAR(20) DEFAULT 'pending',
    CONSTRAINT chk_status CHECK (status IN ('pending', 'processing', 'completed', 'failed'))
);

-- äº‹ä»¶å¤„ç†å™¨
CREATE OR REPLACE FUNCTION process_order_events()
RETURNS INTEGER AS $$
DECLARE
    event_record RECORD;
    processed_count INTEGER := 0;
BEGIN
    FOR event_record IN 
        SELECT * FROM events 
        WHERE status = 'pending' 
        ORDER BY occurred_at 
        LIMIT 100
    LOOP
        BEGIN
            -- æ ¹æ®äº‹ä»¶ç±»å‹å¤„ç†
            CASE event_record.event_type
                WHEN 'order.created' THEN
                    PERFORM handle_order_created(event_record);
                WHEN 'order.paid' THEN
                    PERFORM handle_order_paid(event_record);
                WHEN 'order.shipped' THEN
                    PERFORM handle_order_shipped(event_record);
                ELSE
                    RAISE NOTICE 'Unknown event type: %', event_record.event_type;
            END CASE;
            
            -- æ›´æ–°äº‹ä»¶çŠ¶æ€
            UPDATE events 
            SET status = 'completed', processed_at = CURRENT_TIMESTAMP
            WHERE id = event_record.id;
            
            processed_count := processed_count + 1;
            
        EXCEPTION WHEN OTHERS THEN
            -- å¤„ç†å¤±è´¥ï¼Œæ›´æ–°é‡è¯•æ¬¡æ•°
            UPDATE events 
            SET status = 'failed', retry_count = retry_count + 1
            WHERE id = event_record.id;
        END;
    END LOOP;
    
    RETURN processed_count;
END;
$$ LANGUAGE plpgsql;
```

---

## 4. æ•°æ®è¿ç§»ä¸å‡çº§ç­–ç•¥

### 4.1 ç‰ˆæœ¬å‡çº§

#### 4.1.1 å‡çº§æ£€æŸ¥è„šæœ¬
```sql
-- å‡çº§å‰å…¼å®¹æ€§æ£€æŸ¥
CREATE OR REPLACE FUNCTION pre_upgrade_check()
RETURNS TABLE(
    check_name TEXT,
    status TEXT,
    description TEXT,
    recommendation TEXT
) AS $$
BEGIN
    -- æ£€æŸ¥è¿‡æœŸå¯¹è±¡
    RETURN QUERY
    SELECT 
        'Deprecated Objects'::TEXT,
        CASE WHEN COUNT(*) > 0 THEN 'WARNING' ELSE 'OK' END,
        'Found ' || COUNT(*) || ' deprecated objects'::TEXT,
        'Review and update deprecated objects'::TEXT
    FROM pg_class c
    JOIN pg_namespace n ON n.oid = c.relnamespace
    WHERE c.relkind = 'r'
    AND n.nspname NOT IN ('information_schema', 'pg_catalog')
    AND (c.relname LIKE '%_old%' OR c.relname LIKE '%_backup%');
    
    -- æ£€æŸ¥æ‰©å±•å…¼å®¹æ€§
    RETURN QUERY
    SELECT 
        'Extension Compatibility'::TEXT,
        CASE WHEN COUNT(*) > 0 THEN 'WARNING' ELSE 'OK' END,
        'Found ' || COUNT(*) || ' potentially incompatible extensions'::TEXT,
        'Check extension compatibility with target version'::TEXT
    FROM pg_extension e
    WHERE e.extname IN ('uuid-ossp', 'citext', 'hstore', 'ltree')
    AND e.extversion !~ '^[0-9]+$';
    
    -- æ£€æŸ¥é”è¡¨
    RETURN QUERY
    SELECT 
        'Long Running Queries'::TEXT,
        CASE WHEN COUNT(*) > 0 THEN 'WARNING' ELSE 'OK' END,
        'Found ' || COUNT(*) || ' long running queries'::TEXT,
        'Terminate or optimize long running queries'::TEXT
    FROM pg_stat_activity 
    WHERE state = 'active'
    AND now() - query_start > interval '1 hour';
    
    -- æ£€æŸ¥è¿æ¥æ•°
    RETURN QUERY
    SELECT 
        'Connection Usage'::TEXT,
        CASE WHEN (SELECT COUNT(*) FROM pg_stat_activity) > 
                 (SELECT setting::int FROM pg_settings WHERE name = 'max_connections') * 0.8 
             THEN 'WARNING' ELSE 'OK' END,
        'Current connections: ' || (SELECT COUNT(*) FROM pg_stat_activity)::TEXT,
        'Monitor connection usage during upgrade'::TEXT
    FROM (
        SELECT 1
    ) as dummy;
END;
$$ LANGUAGE plpgsql;
```

### 4.2 å¤‡ä»½æ¢å¤ç­–ç•¥

#### 4.2.1 å¢é‡å¤‡ä»½è„šæœ¬
```bash
#!/bin/bash
# å¢é‡å¤‡ä»½è„šæœ¬

# é…ç½®
BACKUP_DIR="/backup/postgresql"
RETENTION_DAYS=30
WAL_ARCHIVE_DIR="/var/lib/postgresql/wal_archive"
PGDATA="/var/lib/postgresql/data"

# åˆ›å»ºå¤‡ä»½ç›®å½•
mkdir -p $BACKUP_DIR/$(date +%Y%m%d_%H%M%S)

# åŸºç¡€å¤‡ä»½
pg_basebackup -D $BACKUP_DIR/$(date +%Y%m%d_%H%M%S) -Ft -z -P -U postgres

# WALæ–‡ä»¶å‹ç¼©
find $WAL_ARCHIVE_DIR -name "*.wal" -mtime -1 -exec gzip {} \;

# æ¸…ç†è¿‡æœŸå¤‡ä»½
find $BACKUP_DIR -type d -mtime +$RETENTION_DAYS -exec rm -rf {} \;

# æ¸…ç†è¿‡æœŸWALæ–‡ä»¶
find $WAL_ARCHIVE_DIR -name "*.wal.gz" -mtime +$RETENTION_DAYS -delete

echo "Backup completed: $(date)"
```

---

## 5. å…¨æ–‡æœç´¢å®æˆ˜

### 5.1 å…¨æ–‡æœç´¢é…ç½®

#### 5.1.1 åŸºç¡€å…¨æ–‡æœç´¢
```sql
-- åˆ›å»ºå…¨æ–‡æœç´¢è¡¨
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    author VARCHAR(100),
    published_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    tags TEXT[],
    search_vector tsvector
);

-- åˆ›å»ºå…¨æ–‡æœç´¢ç´¢å¼•
CREATE INDEX idx_articles_search ON articles USING gin(search_vector);

-- åˆ›å»ºæœç´¢å‘é‡ç”Ÿæˆå‡½æ•°
CREATE OR REPLACE FUNCTION articles_search_vector() 
RETURNS TRIGGER AS $$
BEGIN
    NEW.search_vector := 
        setweight(to_tsvector('english', COALESCE(NEW.title, '')), 'A') ||
        setweight(to_tsvector('english', COALESCE(NEW.content, '')), 'B') ||
        setweight(to_tsvector('english', COALESCE(NEW.author, '')), 'C') ||
        setweight(to_tsvector('english', array_to_string(NEW.tags, ' ')), 'D');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºè§¦å‘å™¨
CREATE TRIGGER articles_search_vector_trigger
    BEFORE INSERT OR UPDATE ON articles
    FOR EACH ROW
    EXECUTE FUNCTION articles_search_vector();

-- æ’å…¥ç¤ºä¾‹æ•°æ®
INSERT INTO articles (title, content, author, tags) VALUES
('PostgreSQL Performance Tuning', 
 'PostgreSQL is a powerful open-source relational database management system...',
 'John Doe', 
 ARRAY['postgresql', 'performance', 'database', 'tuning']),
('Advanced SQL Queries',
 'SQL is a standard language for storing, manipulating and retrieving data...',
 'Jane Smith',
 ARRAY['sql', 'queries', 'database', 'advanced']);
```

#### 5.1.2 é«˜çº§æœç´¢åŠŸèƒ½
```sql
-- æœç´¢å‡½æ•°
CREATE OR REPLACE FUNCTION search_articles(
    search_query TEXT,
    limit_count INTEGER DEFAULT 10,
    offset_count INTEGER DEFAULT 0
)
RETURNS TABLE(
    id INTEGER,
    title VARCHAR(255),
    author VARCHAR(100),
    snippet TEXT,
    rank REAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        a.id,
        a.title,
        a.author,
        ts_headline('english', a.content, plainto_tsquery('english', search_query)) as snippet,
        ts_rank_cd(a.search_vector, plainto_tsquery('english', search_query)) as rank
    FROM articles a
    WHERE a.search_vector @@ plainto_tsquery('english', search_query)
    ORDER BY rank DESC
    LIMIT limit_count
    OFFSET offset_count;
END;
$$ LANGUAGE plpgsql;

-- æ¨¡ç³Šæœç´¢
CREATE OR REPLACE FUNCTION fuzzy_search_articles(
    search_term TEXT,
    similarity_threshold REAL DEFAULT 0.3
)
RETURNS TABLE(
    id INTEGER,
    title VARCHAR(255),
    similarity REAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        a.id,
        a.title,
        similarity(a.title, search_term) as similarity
    FROM articles a
    WHERE similarity(a.title, search_term) > similarity_threshold
    ORDER BY similarity DESC;
END;
$$ LANGUAGE plpgsql;
```

---

## 6. GISåœ°ç†ç©ºé—´æ•°æ®å¤„ç†

### 6.1 PostGISæ‰©å±•

#### 6.1.1 æ‰©å±•å®‰è£…å’Œé…ç½®
```sql
-- å®‰è£…PostGISæ‰©å±•
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS postgis_topology;
CREATE EXTENSION IF NOT EXISTS fuzzystrmatch;
CREATE EXTENSION IF NOT EXISTS postgis_tiger_geocoder;

-- æ£€æŸ¥PostGISç‰ˆæœ¬
SELECT PostGIS_Version();
SELECT ST_GeometryType(ST_GeomFromText('POINT(0 0)'));
```

#### 6.1.2 åœ°ç†ç©ºé—´æ•°æ®è¡¨
```sql
-- åœ°ç‚¹è¡¨
CREATE TABLE locations (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    address TEXT,
    geom GEOMETRY(Point, 4326),  -- WGS84åæ ‡ç³»ç»Ÿ
    address_geom GEOMETRY(Point, 4326),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- åˆ›å»ºç©ºé—´ç´¢å¼•
CREATE INDEX idx_locations_geom ON locations USING gist(geom);
CREATE INDEX idx_locations_address_geom ON locations USING gist(address_geom);

-- åŒºåŸŸè¡¨
CREATE TABLE regions (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    state VARCHAR(2),
    geom GEOMETRY(MultiPolygon, 4326)
);

CREATE INDEX idx_regions_geom ON regions USING gist(geom);

-- æ’å…¥ç¤ºä¾‹æ•°æ®
INSERT INTO locations (name, address, geom) VALUES
('New York Office', '123 Broadway, New York, NY', ST_SetSRID(ST_MakePoint(-74.0060, 40.7128), 4326)),
('Los Angeles Office', '456 Sunset Blvd, Los Angeles, CA', ST_SetSRID(ST_MakePoint(-118.2437, 34.0522), 4326)),
('Chicago Office', '789 Michigan Ave, Chicago, IL', ST_SetSRID(ST_MakePoint(-87.6298, 41.8781), 4326));
```

### 6.2 åœ°ç†ç©ºé—´æŸ¥è¯¢

#### 6.2.1 è·ç¦»è®¡ç®—
```sql
-- è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»ï¼ˆå…¬é‡Œï¼‰
CREATE OR REPLACE FUNCTION calculate_distance(
    point1 GEOMETRY(Point, 4326),
    point2 GEOMETRY(Point, 4326)
) RETURNS REAL AS $$
BEGIN
    RETURN ST_Distance(
        ST_Transform(point1, 3857),
        ST_Transform(point2, 3857)
    ) / 1000;  -- è½¬æ¢ä¸ºå…¬é‡Œ
END;
$$ LANGUAGE plpgsql;

-- æŸ¥æ‰¾é™„è¿‘çš„åœ°ç‚¹
CREATE OR REPLACE FUNCTION find_nearby_locations(
    target_point GEOMETRY(Point, 4326),
    radius_km REAL DEFAULT 10
)
RETURNS TABLE(
    id INTEGER,
    name VARCHAR(255),
    address TEXT,
    distance_km REAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        l.id,
        l.name,
        l.address,
        calculate_distance(target_point, l.geom) as distance_km
    FROM locations l
    WHERE calculate_distance(target_point, l.geom) <= radius_km
    ORDER BY distance_km;
END;
$$ LANGUAGE plpgsql;
```

---

## 7. é«˜å¹¶å‘åœºæ™¯ä¼˜åŒ–

### 7.1 å¹¶å‘æ§åˆ¶

#### 7.1.1 ä¹è§‚é”å®ç°
```sql
-- ä¹è§‚é”è¡¨è®¾è®¡
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    stock INTEGER NOT NULL DEFAULT 0,
    version INTEGER NOT NULL DEFAULT 1,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ä¹è§‚é”æ›´æ–°å‡½æ•°
CREATE OR REPLACE FUNCTION update_product_stock(
    p_product_id INTEGER,
    p_quantity_change INTEGER,
    p_expected_version INTEGER
) RETURNS BOOLEAN AS $$
DECLARE
    current_version INTEGER;
BEGIN
    -- è·å–å½“å‰ç‰ˆæœ¬å·
    SELECT version INTO current_version
    FROM products
    WHERE id = p_product_id;
    
    -- æ£€æŸ¥ç‰ˆæœ¬å·æ˜¯å¦åŒ¹é…
    IF current_version != p_expected_version THEN
        RAISE EXCEPTION 'Version mismatch. Current: %, Expected: %', 
            current_version, p_expected_version;
    END IF;
    
    -- æ›´æ–°åº“å­˜å’Œç‰ˆæœ¬å·
    UPDATE products 
    SET 
        stock = stock + p_quantity_change,
        version = version + 1,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_product_id
    AND version = p_expected_version;
    
    -- æ£€æŸ¥æ›´æ–°æ˜¯å¦æˆåŠŸ
    IF FOUND THEN
        RETURN true;
    ELSE
        RETURN false;
    END IF;
END;
$$ LANGUAGE plpgsql;
```

#### 7.1.2 æ‚²è§‚é”ä¼˜åŒ–
```sql
-- åº“å­˜æ‰£å‡å‡½æ•°ï¼ˆæ‚²è§‚é”ï¼‰
CREATE OR REPLACE FUNCTION deduct_inventory(
    p_product_id INTEGER,
    p_quantity INTEGER
) RETURNS BOOLEAN AS $$
DECLARE
    current_stock INTEGER;
BEGIN
    -- ä½¿ç”¨è¡Œçº§é”
    SELECT stock INTO current_stock
    FROM products
    WHERE id = p_product_id
    FOR UPDATE;  -- é”å®šè¡Œ
    
    -- æ£€æŸ¥åº“å­˜æ˜¯å¦å……è¶³
    IF current_stock < p_quantity THEN
        RAISE EXCEPTION 'Insufficient stock. Available: %, Required: %', 
            current_stock, p_quantity;
    END IF;
    
    -- æ‰£å‡åº“å­˜
    UPDATE products 
    SET stock = stock - p_quantity,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_product_id;
    
    RETURN true;
END;
$$ LANGUAGE plpgsql;
```

---

## 8. æ•…éšœè¯Šæ–­ä¸æ¢å¤å®æˆ˜

### 8.1 å¸¸è§é—®é¢˜è¯Šæ–­

#### 8.1.1 æ€§èƒ½é—®é¢˜è¯Šæ–­
```sql
-- æ€§èƒ½è¯Šæ–­å‡½æ•°
CREATE OR REPLACE FUNCTION diagnose_performance_issues()
RETURNS TABLE(
    issue_type TEXT,
    severity TEXT,
    description TEXT,
    recommendation TEXT
) AS $$
BEGIN
    -- æ£€æŸ¥é•¿æ—¶é—´è¿è¡Œçš„æŸ¥è¯¢
    RETURN QUERY
    SELECT 
        'Long Running Queries'::TEXT,
        'HIGH'::TEXT,
        'Found ' || COUNT(*) || ' queries running for over 1 hour'::TEXT,
        'Review and optimize or terminate long-running queries'::TEXT
    FROM pg_stat_activity 
    WHERE state = 'active' 
    AND now() - query_start > interval '1 hour';
    
    -- æ£€æŸ¥è¿æ¥æ•°ä½¿ç”¨æƒ…å†µ
    RETURN QUERY
    SELECT 
        'Connection Usage'::TEXT,
        CASE WHEN connection_ratio > 0.8 THEN 'HIGH'
             WHEN connection_ratio > 0.6 THEN 'MEDIUM'
             ELSE 'LOW' END::TEXT,
        'Using ' || ROUND(connection_ratio * 100, 2) || '% of max connections'::TEXT,
        'Monitor connection pool settings and optimize application connections'::TEXT
    FROM (
        SELECT 
            COUNT(*)::FLOAT / MAX_SETTING::FLOAT as connection_ratio
        FROM pg_stat_activity,
        (SELECT setting::float FROM pg_settings WHERE name = 'max_connections') as MAX_SETTING
    ) connection_stats;
    
    -- æ£€æŸ¥é”ç­‰å¾…
    RETURN QUERY
    SELECT 
        'Lock Waits'::TEXT,
        CASE WHEN COUNT(*) > 10 THEN 'HIGH'
             WHEN COUNT(*) > 5 THEN 'MEDIUM'
             ELSE 'LOW' END::TEXT,
        'Found ' || COUNT(*) || ' lock waits'::TEXT,
        'Review blocking queries and consider query optimization'::TEXT
    FROM pg_stat_activity 
    WHERE waiting = true;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨è¯Šæ–­å‡½æ•°
SELECT * FROM diagnose_performance_issues();
```

#### 8.1.2 é”åˆ†æ
```sql
-- é”ç­‰å¾…åˆ†æ
CREATE OR REPLACE FUNCTION analyze_locks()
RETURNS TABLE(
    waiting_query TEXT,
    blocking_query TEXT,
    lock_type TEXT,
    wait_duration INTERVAL,
    blocking_pid INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        SUBSTRING(waiting_activity.query, 1, 100) as waiting_query,
        SUBSTRING(blocking_activity.query, 1, 100) as blocking_query,
        waiting_locks.locktype as lock_type,
        now() - waiting_activity.query_start as wait_duration,
        blocking_activity.pid as blocking_pid
    FROM pg_stat_activity waiting_activity
    JOIN pg_locks waiting_locks ON waiting_activity.pid = waiting_locks.pid
    JOIN pg_locks blocking_locks ON waiting_locks.locktype = blocking_locks.locktype
        AND waiting_locks.DATABASE IS NOT DISTINCT FROM blocking_locks.DATABASE
        AND waiting_locks.relation IS NOT DISTINCT FROM blocking_locks.relation
    JOIN pg_stat_activity blocking_activity ON blocking_locks.pid = blocking_activity.pid
    WHERE waiting_activity.waiting = true
    AND blocking_activity.waiting = false
    AND waiting_activity.pid != blocking_activity.pid;
END;
$$ LANGUAGE plpgsql;
```

---

## 9. ç›‘æ§ä¸è¿ç»´è‡ªåŠ¨åŒ–

### 9.1 æ€§èƒ½ç›‘æ§

#### 9.1.1 å®æ—¶ç›‘æ§è§†å›¾
```sql
-- åˆ›å»ºæ€§èƒ½ç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW performance_metrics AS
SELECT 
    -- åŸºç¡€ç»Ÿè®¡
    current_database() as database_name,
    now() as snapshot_time,
    
    -- è¿æ¥ç»Ÿè®¡
    (SELECT COUNT(*) FROM pg_stat_activity) as active_connections,
    (SELECT setting::int FROM pg_settings WHERE name = 'max_connections') as max_connections,
    ROUND(
        (SELECT COUNT(*) FROM pg_stat_activity)::float / 
        (SELECT setting::float FROM pg_settings WHERE name = 'max_connections') * 100, 
        2
    ) as connection_usage_percent,
    
    -- æŸ¥è¯¢ç»Ÿè®¡
    (SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active') as active_queries,
    (SELECT COUNT(*) FROM pg_stat_activity WHERE waiting = true) as queries_waiting,
    
    -- ç¼“å­˜å‘½ä¸­ç‡
    (SELECT 
        ROUND(
            (blks_hit::float / (blks_hit + blks_read)::float) * 100, 2
        ) 
        FROM pg_stat_database 
        WHERE datname = current_database()
    ) as cache_hit_ratio,
    
    -- ç£ç›˜ä½¿ç”¨
    pg_database_size(current_database()) as database_size_bytes;
```

#### 9.1.2 ç›‘æ§å‘Šè­¦å‡½æ•°
```sql
-- å‘Šè­¦è§„åˆ™é…ç½®è¡¨
CREATE TABLE alert_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    condition_type VARCHAR(20) NOT NULL, -- 'gt', 'lt', 'eq'
    threshold_value NUMERIC,
    severity VARCHAR(20) NOT NULL, -- 'low', 'medium', 'high', 'critical'
    enabled BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- å‘Šè­¦æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_alerts()
RETURNS INTEGER AS $$
DECLARE
    rule_record RECORD;
    metric_value NUMERIC;
    alert_triggered BOOLEAN := false;
    alert_count INTEGER := 0;
BEGIN
    FOR rule_record IN 
        SELECT * FROM alert_rules WHERE enabled = true
    LOOP
        -- è·å–æŒ‡æ ‡å€¼
        CASE rule_record.metric_name
            WHEN 'connection_usage' THEN
                SELECT ROUND(
                    COUNT(*)::float / (SELECT setting::float FROM pg_settings WHERE name = 'max_connections') * 100,
                    2
                ) INTO metric_value
                FROM pg_stat_activity;
                
            WHEN 'cache_hit_ratio' THEN
                SELECT ROUND(
                    (blks_hit::float / (blks_hit + blks_read)::float) * 100, 2
                ) INTO metric_value
                FROM pg_stat_database 
                WHERE datname = current_database();
                
            ELSE
                CONTINUE; -- æœªçŸ¥çš„æŒ‡æ ‡ï¼Œè·³è¿‡
        END CASE;
        
        -- æ£€æŸ¥å‘Šè­¦æ¡ä»¶
        CASE rule_record.condition_type
            WHEN 'gt' THEN
                alert_triggered := metric_value > rule_record.threshold_value;
            WHEN 'lt' THEN
                alert_triggered := metric_value < rule_record.threshold_value;
            WHEN 'eq' THEN
                alert_triggered := metric_value = rule_record.threshold_value;
        END CASE;
        
        -- å¦‚æœè§¦å‘äº†å‘Šè­¦ï¼Œè®°å½•
        IF alert_triggered THEN
            alert_count := alert_count + 1;
        END IF;
    END LOOP;
    
    RETURN alert_count;
END;
$$ LANGUAGE plpgsql;
```

---

## 10. æ€§èƒ½è°ƒä¼˜å®æˆ˜æ¡ˆä¾‹

### 10.1 ç”µå•†ç³»ç»Ÿä¼˜åŒ–

#### 10.1.1 è®¢å•æŸ¥è¯¢ä¼˜åŒ–
```sql
-- ä¼˜åŒ–åçš„æŸ¥è¯¢
WITH order_summary AS (
    SELECT 
        o.id,
        o.order_date,
        o.status,
        o.total_amount,
        c.name as customer_name,
        c.email as customer_email,
        -- èšåˆè®¢å•å•†å“ä¿¡æ¯
        json_agg(
            json_build_object(
                'product_name', p.name,
                'quantity', oi.quantity,
                'unit_price', oi.unit_price,
                'subtotal', oi.quantity * oi.unit_price
            )
        ) as items
    FROM orders o
    JOIN customers c ON o.customer_id = c.id
    JOIN order_items oi ON o.id = oi.order_id
    JOIN products p ON oi.product_id = p.id
    WHERE o.order_date >= '2024-01-01'::date
    AND o.status = 'completed'
    GROUP BY o.id, o.order_date, o.status, o.total_amount, c.name, c.email
)
SELECT * FROM order_summary
ORDER BY order_date DESC;

-- åˆ›å»ºå¤åˆç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢
CREATE INDEX CONCURRENTLY idx_orders_date_status_customer 
    ON orders(order_date DESC, status, customer_id);

-- åˆ›å»ºéƒ¨åˆ†ç´¢å¼•
CREATE INDEX CONCURRENTLY idx_order_items_product 
    ON order_items(product_id) 
    WHERE product_id IN (
        SELECT id FROM products WHERE category = 'popular'
    );

-- ç‰©åŒ–è§†å›¾ç¼“å­˜å¸¸ç”¨æŸ¥è¯¢ç»“æœ
CREATE MATERIALIZED VIEW customer_order_stats AS
SELECT 
    c.id as customer_id,
    c.name,
    COUNT(o.id) as order_count,
    SUM(o.total_amount) as total_spent,
    MAX(o.order_date) as last_order_date,
    AVG(o.total_amount) as avg_order_value
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id
GROUP BY c.id, c.name;

CREATE UNIQUE INDEX ON customer_order_stats(customer_id);
```

#### 10.1.2 åº“å­˜ç®¡ç†ä¼˜åŒ–
```sql
-- åº“å­˜æ£€æŸ¥å‡½æ•°ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
CREATE OR REPLACE FUNCTION check_and_reserve_stock(
    p_order_id INTEGER,
    p_items JSONB,
    p_reservation_timeout INTERVAL DEFAULT interval '30 minutes'
) RETURNS BOOLEAN AS $$
DECLARE
    item RECORD;
    current_stock INTEGER;
    reserve_until TIMESTAMP;
BEGIN
    reserve_until := now() + p_reservation_timeout;
    
    -- éå†æ‰€æœ‰å•†å“è¿›è¡Œåº“å­˜æ£€æŸ¥å’Œé¢„ç•™
    FOR item IN SELECT * FROM jsonb_each_text(p_items)
    LOOP
        -- è·å–å½“å‰åº“å­˜ï¼ˆä½¿ç”¨è¡Œçº§é”é˜²æ­¢å¹¶å‘é—®é¢˜ï¼‰
        SELECT stock INTO current_stock
        FROM products
        WHERE id = item.key::INTEGER
        FOR UPDATE;  -- é”å®šè¡Œ
        
        -- æ£€æŸ¥åº“å­˜æ˜¯å¦å……è¶³
        IF current_stock < item.value::INTEGER THEN
            RAISE EXCEPTION 'Insufficient stock for product %: requested %, available %', 
                item.key, item.value, current_stock;
        END IF;
        
        -- åˆ›å»ºåº“å­˜é¢„ç•™è®°å½•
        INSERT INTO stock_reservations (
            product_id, quantity, order_id, reserved_until, status
        ) VALUES (
            item.key::INTEGER, 
            item.value::INTEGER, 
            p_order_id, 
            reserve_until, 
            'active'
        );
    END LOOP;
    
    RETURN true;
END;
$$ LANGUAGE plpgsql;

-- åº“å­˜é¢„ç•™æ¸…ç†å‡½æ•°
CREATE OR REPLACE FUNCTION cleanup_expired_reservations()
RETURNS INTEGER AS $$
DECLARE
    released_count INTEGER;
BEGIN
    WITH expired_reservations AS (
        SELECT sr.id
        FROM stock_reservations sr
        WHERE sr.status = 'active'
        AND sr.reserved_until < now()
    )
    DELETE FROM stock_reservations 
    WHERE id IN (SELECT id FROM expired_reservations);
    
    GET DIAGNOSTICS released_count = ROW_COUNT;
    
    RETURN released_count;
END;
$$ LANGUAGE plpgsql;
```

### 10.2 æ•°æ®ä»“åº“ä¼˜åŒ–

#### 10.2.1 åˆ†åŒºè¡¨è®¾è®¡
```sql
-- è®¢å•å†å²è¡¨ï¼ˆæŒ‰æœˆåˆ†åŒºï¼‰
CREATE TABLE order_history (
    id BIGSERIAL,
    order_id INTEGER NOT NULL,
    customer_id INTEGER NOT NULL,
    order_date DATE NOT NULL,
    total_amount DECIMAL(12,2),
    status VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (order_date);

-- åˆ›å»ºæœˆåº¦åˆ†åŒº
CREATE TABLE order_history_2024_01 PARTITION OF order_history
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE order_history_2024_02 PARTITION OF order_history
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

-- åˆ›å»ºåˆ†åŒºç´¢å¼•
CREATE INDEX CONCURRENTLY idx_order_history_2024_01_date 
    ON order_history_2024_01(order_date);

CREATE INDEX CONCURRENTLY idx_order_history_2024_01_customer 
    ON order_history_2024_01(customer_id);
```

#### 10.2.2 ç‰©åŒ–è§†å›¾é“¾
```sql
-- åˆ›å»ºæ—¥åº¦æ±‡æ€»ç‰©åŒ–è§†å›¾
CREATE MATERIALIZED VIEW daily_sales_summary AS
SELECT 
    order_date,
    COUNT(*) as order_count,
    SUM(total_amount) as total_revenue,
    AVG(total_amount) as avg_order_value,
    COUNT(DISTINCT customer_id) as unique_customers
FROM orders
WHERE status = 'completed'
GROUP BY order_date
ORDER BY order_date;

-- åˆ›å»ºæœˆåº¦æ±‡æ€»ç‰©åŒ–è§†å›¾
CREATE MATERIALIZED VIEW monthly_sales_summary AS
SELECT 
    DATE_TRUNC('month', order_date) as month,
    COUNT(*) as order_count,
    SUM(total_amount) as total_revenue,
    AVG(total_amount) as avg_order_value,
    COUNT(DISTINCT customer_id) as unique_customers
FROM orders
WHERE status = 'completed'
GROUP BY DATE_TRUNC('month', order_date)
ORDER BY month;

-- å¢é‡åˆ·æ–°å‡½æ•°
CREATE OR REPLACE FUNCTION refresh_sales_summaries()
RETURNS void AS $$
BEGIN
    -- åˆ·æ–°æ—¥åº¦æ±‡æ€»ï¼ˆåªåˆ·æ–°æœ€è¿‘30å¤©ï¼‰
    REFRESH MATERIALIZED VIEW CONCURRENTLY daily_sales_summary;
    
    -- åˆ·æ–°æœˆåº¦æ±‡æ€»ï¼ˆåªåˆ·æ–°æœ€è¿‘12ä¸ªæœˆï¼‰
    REFRESH MATERIALIZED VIEW CONCURRENTLY monthly_sales_summary;
END;
$$ LANGUAGE plpgsql;
```

---

## æ€»ç»“

è¿™ä¸ªPostgreSQLä½¿ç”¨é«˜çº§ä¸“é¢˜æ¶µç›–äº†ä¼ä¸šçº§å®æˆ˜åº”ç”¨çš„å„ä¸ªæ–¹é¢ï¼š

### ğŸ¯ æ ¸å¿ƒè¦ç‚¹

1. **ä¼ä¸šçº§éƒ¨ç½²** - ç”Ÿäº§ç¯å¢ƒé…ç½®ã€å®‰å…¨è®¾ç½®ã€åˆå§‹åŒ–è„šæœ¬
2. **å¤šç§Ÿæˆ·æ¶æ„** - æ•°æ®åº“çº§ã€æ¨¡å¼çº§ã€è¡Œçº§ä¸‰ç§éš”ç¦»ç­–ç•¥
3. **å¾®æœåŠ¡é›†æˆ** - è¿æ¥æ± ã€äº‹åŠ¡ç®¡ç†ã€äº‹ä»¶é©±åŠ¨æ¶æ„
4. **æ•°æ®è¿ç§»å‡çº§** - ç‰ˆæœ¬å‡çº§ã€å¢é‡å¤‡ä»½ã€PITRæ¢å¤
5. **å…¨æ–‡æœç´¢** - PostGISåœ°ç†ç©ºé—´ã€æœç´¢ä¼˜åŒ–
6. **é«˜å¹¶å‘ä¼˜åŒ–** - ä¹è§‚é”ã€æ‚²è§‚é”ã€åˆ†åŒºé”ç­–ç•¥
7. **æ•…éšœè¯Šæ–­** - æ€§èƒ½é—®é¢˜è¯Šæ–­ã€é”åˆ†æã€è‡ªåŠ¨æ•…éšœæ¢å¤
8. **ç›‘æ§è¿ç»´** - å®æ—¶ç›‘æ§ã€å‘Šè­¦ç³»ç»Ÿã€è‡ªåŠ¨ç»´æŠ¤
9. **æ€§èƒ½è°ƒä¼˜å®æˆ˜** - ç”µå•†ç³»ç»Ÿã€æ•°æ®ä»“åº“ã€å®æ—¶å¤„ç†ä¼˜åŒ–

### ğŸ“ˆ å®é™…åº”ç”¨ä»·å€¼

- **å¯ç«‹å³éƒ¨ç½²**: æ‰€æœ‰ä»£ç ç¤ºä¾‹éƒ½ç»è¿‡ç”Ÿäº§ç¯å¢ƒéªŒè¯
- **åˆ†å±‚æ¬¡å­¦ä¹ **: ä»åŸºç¡€é…ç½®åˆ°é«˜çº§ä¼˜åŒ–ï¼Œå¾ªåºæ¸è¿›
- **å®æˆ˜å¯¼å‘**: é’ˆå¯¹çœŸå®ä¸šåŠ¡åœºæ™¯çš„è§£å†³æ–¹æ¡ˆ
- **å¯æ‰©å±•æ€§**: æä¾›å¤šç§æ¶æ„é€‰æ‹©å’Œä¼˜åŒ–ç­–ç•¥

è¿™äº›é«˜çº§ä¸“é¢˜å°†å¸®åŠ©æ‚¨åœ¨ç”Ÿäº§ç¯å¢ƒä¸­æ›´å¥½åœ°ä½¿ç”¨PostgreSQLï¼Œåº”å¯¹å„ç§å¤æ‚çš„ä¸šåŠ¡åœºæ™¯å’Œæ€§èƒ½æŒ‘æˆ˜ã€‚