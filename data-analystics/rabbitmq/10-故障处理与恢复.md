# 第10章：故障处理与恢复

## 10.1 故障处理概述

在分布式消息队列系统中，故障是不可避免的。RabbitMQ作为关键的基础设施，需要具备强大的故障处理和恢复能力。本章将详细介绍RabbitMQ的故障类型、检测方法、处理策略和恢复机制。

### 10.1.1 故障分类

#### 1. 网络故障
- **网络分区**：网络分裂导致集群节点间无法通信
- **网络延迟**：高延迟导致消息传递延迟
- **连接超时**：客户端与RabbitMQ连接异常中断
- **丢包**：网络数据包丢失影响消息传递

#### 2. 硬件故障
- **磁盘故障**：磁盘损坏导致数据丢失
- **内存故障**：内存损坏或不足影响性能
- **CPU故障**：CPU过载导致服务响应缓慢
- **网络设备故障**：交换机、路由器等设备故障

#### 3. 软件故障
- **RabbitMQ服务崩溃**：RabbitMQ进程异常退出
- **插件故障**：插件冲突或崩溃
- **配置错误**：错误配置导致服务异常
- **资源泄漏**：内存、文件描述符等资源泄漏

#### 4. 人为故障
- **误操作**：管理员误删除或修改关键数据
- **配置更改**：不当的配置变更导致服务异常
- **代码部署**：错误的代码部署导致功能异常

### 10.1.2 故障处理原则

#### 1. 快速响应
- 建立实时监控和告警机制
- 制定应急预案和响应流程
- 保持团队24/7值班响应能力

#### 2. 最小影响
- 优先保护用户数据完整性
- 最小化业务中断时间
- 逐步恢复服务功能

#### 3. 完整恢复
- 确保数据完整性
- 恢复服务全部功能
- 验证系统稳定性

#### 4. 预防为主
- 定期进行故障演练
- 完善监控和告警系统
- 建立完善的备份策略

## 10.2 故障检测与诊断

### 10.2.1 健康检查

#### 基础健康检查

```python
import requests
import pika
import time
from typing import Dict, List, Optional

class HealthChecker:
    """健康检查器"""
    
    def __init__(self, rabbitmq_config: Dict):
        self.rabbitmq_config = rabbitmq_config
        
    def check_rabbitmq_service(self) -> Dict:
        """检查RabbitMQ服务状态"""
        result = {
            'service_status': 'unknown',
            'api_status': 'unknown',
            'queue_status': 'unknown',
            'connection_status': 'unknown',
            'issues': []
        }
        
        try:
            # 检查API服务
            api_status = self._check_api_service()
            result['api_status'] = api_status
            
            if not api_status['reachable']:
                result['issues'].append(f"API服务不可达: {api_status['error']}")
            
            # 检查队列服务
            queue_status = self._check_queue_service()
            result['queue_status'] = queue_status
            
            if not queue_status['connected']:
                result['issues'].append(f"队列服务连接失败: {queue_status['error']}")
            
            # 检查连接状态
            connection_status = self._check_connection_health()
            result['connection_status'] = connection_status
            
            # 综合判断
            if (api_status['reachable'] and 
                queue_status['connected'] and
                connection_status['healthy']):
                result['service_status'] = 'healthy'
            else:
                result['service_status'] = 'unhealthy'
                
        except Exception as e:
            result['service_status'] = 'error'
            result['issues'].append(f"健康检查异常: {str(e)}")
        
        return result
    
    def _check_api_service(self) -> Dict:
        """检查API服务"""
        try:
            url = f"http://{self.rabbitmq_config['host']}:{self.rabbitmq_config['api_port']}/api/overview"
            auth = (self.rabbitmq_config['username'], self.rabbitmq_config['password'])
            
            response = requests.get(url, auth=auth, timeout=5)
            
            return {
                'reachable': response.status_code == 200,
                'status_code': response.status_code,
                'response_time': response.elapsed.total_seconds()
            }
        except Exception as e:
            return {
                'reachable': False,
                'error': str(e),
                'status_code': 0
            }
    
    def _check_queue_service(self) -> Dict:
        """检查队列服务"""
        try:
            credentials = pika.PlainCredentials(
                self.rabbitmq_config['username'],
                self.rabbitmq_config['password']
            )
            
            parameters = pika.ConnectionParameters(
                host=self.rabbitmq_config['host'],
                port=self.rabbitmq_config['port'],
                credentials=credentials,
                connection_attempts=3,
                retry_delay=2
            )
            
            connection = pika.BlockingConnection(parameters)
            
            try:
                channel = connection.channel()
                # 测试声明队列
                channel.queue_declare(queue='health_check_queue', auto_delete=True)
                return {'connected': True, 'error': None}
            finally:
                connection.close()
                
        except Exception as e:
            return {'connected': False, 'error': str(e)}
    
    def _check_connection_health(self) -> Dict:
        """检查连接健康状态"""
        try:
            # 检查活跃连接数
            overview = self._get_rabbitmq_overview()
            connections = overview.get('connections', [])
            
            active_connections = sum(1 for conn in connections if conn.get('state') == 'running')
            
            return {
                'healthy': True,
                'active_connections': active_connections,
                'total_connections': len(connections)
            }
        except Exception as e:
            return {
                'healthy': False,
                'error': str(e)
            }
    
    def _get_rabbitmq_overview(self) -> Dict:
        """获取RabbitMQ概览信息"""
        url = f"http://{self.rabbitmq_config['host']}:{self.rabbitmq_config['api_port']}/api/overview"
        auth = (self.rabbitmq_config['username'], self.rabbitmq_config['password'])
        
        response = requests.get(url, auth=auth)
        return response.json()
```

#### 系统资源健康检查

```python
import psutil
import platform
from dataclasses import dataclass
from typing import Dict, List

@dataclass
class SystemHealth:
    """系统健康状态"""
    cpu_percent: float
    memory_percent: float
    disk_usage_percent: float
    network_io: Dict[str, int]
    process_count: int
    load_average: List[float]
    timestamp: float

class SystemHealthMonitor:
    """系统健康监控器"""
    
    def __init__(self):
        self.last_network_io = None
        self.last_timestamp = None
        
    def check_system_health(self) -> SystemHealth:
        """检查系统健康状态"""
        # CPU使用率
        cpu_percent = psutil.cpu_percent(interval=1)
        
        # 内存使用率
        memory = psutil.virtual_memory()
        memory_percent = memory.percent
        
        # 磁盘使用率
        disk = psutil.disk_usage('/')
        disk_usage_percent = (disk.used / disk.total) * 100
        
        # 网络I/O
        network_io = self._get_network_io()
        
        # 进程数
        process_count = len(psutil.pids())
        
        # 负载平均值
        load_average = self._get_load_average()
        
        return SystemHealth(
            cpu_percent=cpu_percent,
            memory_percent=memory_percent,
            disk_usage_percent=disk_usage_percent,
            network_io=network_io,
            process_count=process_count,
            load_average=load_average,
            timestamp=time.time()
        )
    
    def _get_network_io(self) -> Dict[str, int]:
        """获取网络I/O信息"""
        current_io = psutil.net_io_counters()
        
        if self.last_network_io is None:
            self.last_network_io = current_io
            self.last_timestamp = time.time()
            return {'bytes_sent': 0, 'bytes_recv': 0, 'packets_sent': 0, 'packets_recv': 0}
        
        time_delta = time.time() - self.last_timestamp
        
        # 计算差值
        bytes_sent = current_io.bytes_sent - self.last_network_io.bytes_sent
        bytes_recv = current_io.bytes_recv - self.last_network_io.bytes_recv
        packets_sent = current_io.packets_sent - self.last_network_io.packets_sent
        packets_recv = current_io.packets_recv - self.last_network_io.packets_recv
        
        # 更新历史数据
        self.last_network_io = current_io
        self.last_timestamp = time.time()
        
        return {
            'bytes_sent': int(bytes_sent / time_delta),
            'bytes_recv': int(bytes_recv / time_delta),
            'packets_sent': int(packets_sent / time_delta),
            'packets_recv': int(packets_recv / time_delta)
        }
    
    def _get_load_average(self) -> List[float]:
        """获取系统负载平均值"""
        if hasattr(os, 'getloadavg'):
            return list(os.getloadavg())
        else:
            return [0.0, 0.0, 0.0]  # Windows系统不支持

    def evaluate_system_health(self, health: SystemHealth) -> Dict:
        """评估系统健康状态"""
        issues = []
        warnings = []
        
        # CPU检查
        if health.cpu_percent > 90:
            issues.append("CPU使用率过高 (>90%)")
        elif health.cpu_percent > 80:
            warnings.append("CPU使用率警告 (>80%)")
        
        # 内存检查
        if health.memory_percent > 90:
            issues.append("内存使用率过高 (>90%)")
        elif health.memory_percent > 80:
            warnings.append("内存使用率警告 (>80%)")
        
        # 磁盘检查
        if health.disk_usage_percent > 90:
            issues.append("磁盘使用率过高 (>90%)")
        elif health.disk_usage_percent > 80:
            warnings.append("磁盘使用率警告 (>80%)")
        
        # 负载检查
        if health.load_average and len(health.load_average) >= 2:
            if health.load_average[0] > psutil.cpu_count() * 0.8:
                issues.append("系统负载过高")
            elif health.load_average[0] > psutil.cpu_count() * 0.6:
                warnings.append("系统负载警告")
        
        # 综合判断
        if issues:
            overall_status = 'critical'
        elif warnings:
            overall_status = 'warning'
        else:
            overall_status = 'healthy'
        
        return {
            'overall_status': overall_status,
            'issues': issues,
            'warnings': warnings,
            'health_score': self._calculate_health_score(health)
        }
    
    def _calculate_health_score(self, health: SystemHealth) -> float:
        """计算健康评分（0-100）"""
        score = 100.0
        
        # CPU权重
        score -= health.cpu_percent * 0.3
        
        # 内存权重
        score -= health.memory_percent * 0.3
        
        # 磁盘权重
        score -= health.disk_usage_percent * 0.2
        
        # 负载权重
        if health.load_average:
            load_score = max(0, 100 - health.load_average[0] * 10)
            score = (score * 0.8) + (load_score * 0.2)
        
        return max(0, min(100, score))
```

### 10.2.2 故障诊断

#### 故障诊断器

```python
import subprocess
import json
from datetime import datetime
from typing import Dict, List, Tuple

class FaultDiagnostic:
    """故障诊断器"""
    
    def __init__(self, rabbitmq_config: Dict):
        self.rabbitmq_config = rabbitmq_config
        self.health_checker = HealthChecker(rabbitmq_config)
        self.system_monitor = SystemHealthMonitor()
    
    def comprehensive_diagnosis(self) -> Dict:
        """综合故障诊断"""
        diagnosis_result = {
            'timestamp': datetime.now().isoformat(),
            'overall_status': 'unknown',
            'system_health': {},
            'rabbitmq_health': {},
            'network_health': {},
            'diagnostics': [],
            'recommendations': []
        }
        
        try:
            # 系统健康检查
            system_health = self.system_monitor.check_system_health()
            system_evaluation = self.system_monitor.evaluate_system_health(system_health)
            diagnosis_result['system_health'] = {
                'metrics': system_health.__dict__,
                'evaluation': system_evaluation
            }
            
            # RabbitMQ健康检查
            rabbitmq_health = self.health_checker.check_rabbitmq_service()
            diagnosis_result['rabbitmq_health'] = rabbitmq_health
            
            # 网络健康检查
            network_health = self._check_network_health()
            diagnosis_result['network_health'] = network_health
            
            # 运行具体诊断
            diagnostics = self._run_diagnostic_tests()
            diagnosis_result['diagnostics'] = diagnostics
            
            # 生成建议
            recommendations = self._generate_recommendations(
                system_evaluation, rabbitmq_health, network_health, diagnostics
            )
            diagnosis_result['recommendations'] = recommendations
            
            # 综合评估
            overall_status = self._evaluate_overall_status(
                system_evaluation, rabbitmq_health, network_health, diagnostics
            )
            diagnosis_result['overall_status'] = overall_status
            
        except Exception as e:
            diagnosis_result['error'] = str(e)
            diagnosis_result['overall_status'] = 'error'
        
        return diagnosis_result
    
    def _check_network_health(self) -> Dict:
        """检查网络健康状态"""
        network_result = {
            'ping_test': {},
            'port_connectivity': {},
            'dns_resolution': {}
        }
        
        try:
            # Ping测试
            network_result['ping_test'] = self._ping_test(self.rabbitmq_config['host'])
            
            # 端口连通性
            network_result['port_connectivity'] = self._port_connectivity_test()
            
            # DNS解析
            network_result['dns_resolution'] = self._dns_resolution_test(self.rabbitmq_config['host'])
            
        except Exception as e:
            network_result['error'] = str(e)
        
        return network_result
    
    def _ping_test(self, host: str) -> Dict:
        """Ping测试"""
        try:
            if platform.system().lower() == 'windows':
                result = subprocess.run(
                    ['ping', '-n', '4', host],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
            else:
                result = subprocess.run(
                    ['ping', '-c', '4', host],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
            
            return {
                'success': result.returncode == 0,
                'output': result.stdout,
                'stderr': result.stderr
            }
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def _port_connectivity_test(self) -> Dict:
        """端口连通性测试"""
        import socket
        
        ports = [
            self.rabbitmq_config['port'],
            self.rabbitmq_config.get('api_port', 15672)
        ]
        
        connectivity = {}
        for port in ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                result = sock.connect_ex((self.rabbitmq_config['host'], port))
                sock.close()
                
                connectivity[f'port_{port}'] = {
                    'open': result == 0,
                    'port': port
                }
            except Exception as e:
                connectivity[f'port_{port}'] = {
                    'open': False,
                    'error': str(e),
                    'port': port
                }
        
        return connectivity
    
    def _dns_resolution_test(self, hostname: str) -> Dict:
        """DNS解析测试"""
        try:
            import socket
            ip_address = socket.gethostbyname(hostname)
            return {
                'success': True,
                'hostname': hostname,
                'ip_address': ip_address
            }
        except Exception as e:
            return {
                'success': False,
                'hostname': hostname,
                'error': str(e)
            }
    
    def _run_diagnostic_tests(self) -> List[Dict]:
        """运行诊断测试"""
        diagnostics = []
        
        try:
            # 检查RabbitMQ进程
            diagnostics.append(self._check_rabbitmq_process())
            
            # 检查磁盘空间
            diagnostics.append(self._check_disk_space())
            
            # 检查内存使用
            diagnostics.append(self._check_memory_usage())
            
            # 检查文件描述符
            diagnostics.append(self._check_file_descriptors())
            
            # 检查配置文件
            diagnostics.append(self._check_configuration_files())
            
            # 检查日志文件
            diagnostics.append(self._check_log_files())
            
        except Exception as e:
            diagnostics.append({
                'test': 'general',
                'success': False,
                'error': str(e)
            })
        
        return diagnostics
    
    def _check_rabbitmq_process(self) -> Dict:
        """检查RabbitMQ进程"""
        try:
            result = subprocess.run(
                ['pgrep', '-f', 'rabbitmq'],
                capture_output=True,
                text=True
            )
            
            pids = result.stdout.strip().split('\n') if result.stdout.strip() else []
            pids = [int(pid) for pid in pids if pid.isdigit()]
            
            return {
                'test': 'rabbitmq_process',
                'success': len(pids) > 0,
                'running_processes': len(pids),
                'pids': pids
            }
        except Exception as e:
            return {
                'test': 'rabbitmq_process',
                'success': False,
                'error': str(e)
            }
    
    def _check_disk_space(self) -> Dict:
        """检查磁盘空间"""
        try:
            disk_usage = psutil.disk_usage('/')
            disk_percent = (disk_usage.used / disk_usage.total) * 100
            
            return {
                'test': 'disk_space',
                'success': disk_percent < 90,
                'usage_percent': disk_percent,
                'free_gb': disk_usage.free / (1024**3),
                'total_gb': disk_usage.total / (1024**3)
            }
        except Exception as e:
            return {
                'test': 'disk_space',
                'success': False,
                'error': str(e)
            }
    
    def _check_memory_usage(self) -> Dict:
        """检查内存使用"""
        try:
            memory = psutil.virtual_memory()
            
            return {
                'test': 'memory_usage',
                'success': memory.percent < 90,
                'usage_percent': memory.percent,
                'available_gb': memory.available / (1024**3),
                'total_gb': memory.total / (1024**3)
            }
        except Exception as e:
            return {
                'test': 'memory_usage',
                'success': False,
                'error': str(e)
            }
    
    def _check_file_descriptors(self) -> Dict:
        """检查文件描述符"""
        try:
            if hasattr(os, 'sysconf'):
                max_fds = os.sysconf('SC_OPEN_MAX')
            else:
                max_fds = 1024  # Windows默认
            
            # 获取当前进程的文件描述符数
            proc_fd_path = f'/proc/{os.getpid()}/fd'
            if os.path.exists(proc_fd_path):
                current_fds = len(os.listdir(proc_fd_path))
            else:
                current_fds = 0
            
            return {
                'test': 'file_descriptors',
                'success': current_fds < max_fds * 0.8,
                'current_fds': current_fds,
                'max_fds': max_fds,
                'usage_percent': (current_fds / max_fds) * 100
            }
        except Exception as e:
            return {
                'test': 'file_descriptors',
                'success': False,
                'error': str(e)
            }
    
    def _check_configuration_files(self) -> Dict:
        """检查配置文件"""
        config_files = [
            '/etc/rabbitmq/rabbitmq.conf',
            '/etc/rabbitmq/advanced.config',
            '/etc/rabbitmq/enabled_plugins'
        ]
        
        file_status = {}
        all_exist = True
        
        for config_file in config_files:
            if os.path.exists(config_file):
                file_status[config_file] = {
                    'exists': True,
                    'readable': os.access(config_file, os.R_OK),
                    'size': os.path.getsize(config_file)
                }
            else:
                file_status[config_file] = {
                    'exists': False,
                    'readable': False,
                    'size': 0
                }
                all_exist = False
        
        return {
            'test': 'configuration_files',
            'success': all_exist,
            'files': file_status
        }
    
    def _check_log_files(self) -> Dict:
        """检查日志文件"""
        log_dir = '/var/log/rabbitmq' if platform.system().lower() != 'windows' else 'C:/RabbitMQ/log'
        
        log_files_status = {
            'exists': os.path.exists(log_dir),
            'readable': False,
            'files': [],
            'total_size': 0
        }
        
        if log_files_status['exists']:
            try:
                log_files_status['readable'] = os.access(log_dir, os.R_OK)
                
                if log_files_status['readable']:
                    for log_file in os.listdir(log_dir):
                        if log_file.endswith('.log'):
                            log_path = os.path.join(log_dir, log_file)
                            file_size = os.path.getsize(log_path)
                            log_files_status['files'].append({
                                'name': log_file,
                                'size': file_size
                            })
                            log_files_status['total_size'] += file_size
                            
            except Exception as e:
                log_files_status['error'] = str(e)
        
        return {
            'test': 'log_files',
            'success': log_files_status['exists'] and log_files_status['readable'],
            'details': log_files_status
        }
    
    def _generate_recommendations(self, system_health: Dict, rabbitmq_health: Dict, 
                                network_health: Dict, diagnostics: List[Dict]) -> List[str]:
        """生成修复建议"""
        recommendations = []
        
        # 基于系统健康状态生成建议
        if system_health.get('overall_status') == 'critical':
            recommendations.append("系统资源使用率过高，建议立即释放资源或增加硬件配置")
        
        for issue in system_health.get('issues', []):
            if 'CPU' in issue:
                recommendations.append("CPU使用率过高，建议优化RabbitMQ配置或增加CPU资源")
            elif '内存' in issue:
                recommendations.append("内存使用率过高，建议优化队列配置或增加内存")
            elif '磁盘' in issue:
                recommendations.append("磁盘空间不足，建议清理日志文件或扩展磁盘空间")
        
        # 基于RabbitMQ健康状态生成建议
        if rabbitmq_health.get('service_status') == 'unhealthy':
            recommendations.append("RabbitMQ服务不健康，建议重启服务或检查配置文件")
        
        if not rabbitmq_health.get('api_status', {}).get('reachable', False):
            recommendations.append("RabbitMQ API不可达，建议检查网络连接和服务状态")
        
        # 基于网络健康状态生成建议
        if not network_health.get('ping_test', {}).get('success', False):
            recommendations.append("网络连接异常，建议检查网络配置和防火墙设置")
        
        for port, status in network_health.get('port_connectivity', {}).items():
            if not status.get('open', False):
                recommendations.append(f"端口 {status.get('port', '')} 不通，建议检查服务是否正常运行")
        
        # 基于诊断测试生成建议
        for diagnostic in diagnostics:
            if not diagnostic.get('success', True):
                if diagnostic['test'] == 'rabbitmq_process':
                    recommendations.append("RabbitMQ进程未运行，建议启动RabbitMQ服务")
                elif diagnostic['test'] == 'disk_space':
                    recommendations.append("磁盘空间不足，建议清理临时文件和日志")
                elif diagnostic['test'] == 'memory_usage':
                    recommendations.append("内存使用过多，建议优化内存配置")
                elif diagnostic['test'] == 'file_descriptors':
                    recommendations.append("文件描述符不足，建议调整系统限制")
        
        return recommendations
    
    def _evaluate_overall_status(self, system_health: Dict, rabbitmq_health: Dict,
                               network_health: Dict, diagnostics: List[Dict]) -> str:
        """评估整体状态"""
        critical_count = 0
        warning_count = 0
        
        # 系统健康检查
        if system_health.get('overall_status') == 'critical':
            critical_count += 1
        elif system_health.get('overall_status') == 'warning':
            warning_count += 1
        
        # RabbitMQ健康检查
        if rabbitmq_health.get('service_status') == 'unhealthy':
            critical_count += 1
        
        # 诊断测试
        for diagnostic in diagnostics:
            if not diagnostic.get('success', True):
                critical_count += 1
        
        # 评估整体状态
        if critical_count >= 3:
            return 'critical'
        elif critical_count >= 1:
            return 'unhealthy'
        elif warning_count >= 2:
            return 'warning'
        else:
            return 'healthy'
```

## 10.3 故障处理策略

### 10.3.1 自动故障转移

#### HAProxy配置

```haproxy
# /etc/haproxy/haproxy.cfg
global
    daemon
    log stdout local0
    maxconn 4096

defaults
    mode http
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

frontend rabbitmq_frontend
    bind *:5672
    default_backend rabbitmq_backend

frontend rabbitmq_management
    bind *:15672
    default_backend rabbitmq_management_backend

backend rabbitmq_backend
    balance roundrobin
    option httpchk GET /
    server rabbitmq1 192.168.1.10:5672 check inter 5s rise 2 fall 3
    server rabbitmq2 192.168.1.11:5672 check inter 5s rise 2 fall 3
    server rabbitmq3 192.168.1.12:5672 check inter 5s rise 2 fall 3

backend rabbitmq_management_backend
    balance roundrobin
    server rabbitmq1 192.168.1.10:15672 check inter 5s rise 2 fall 3
    server rabbitmq2 192.168.1.11:15672 check inter 5s rise 2 fall 3
    server rabbitmq3 192.168.1.12:15672 check inter 5s rise 2 fall 3
```

#### 自动故障转移管理器

```python
import threading
import time
import json
from enum import Enum
from typing import Dict, List, Optional
import requests

class FailoverState(Enum):
    """故障转移状态"""
    NORMAL = "normal"
    MONITORING = "monitoring"
    FAILING_OVER = "failing_over"
    RECOVERING = "recovering"
    FAILED = "failed"

class HealthCheckResult:
    """健康检查结果"""
    def __init__(self, node: str, healthy: bool, latency: float, error: Optional[str] = None):
        self.node = node
        self.healthy = healthy
        self.latency = latency
        self.error = error

class AutoFailoverManager:
    """自动故障转移管理器"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.nodes = config.get('nodes', [])
        self.current_master = config.get('master_node')
        self.failover_state = FailoverState.NORMAL
        self.monitoring_enabled = False
        self.monitoring_thread = None
        self.failover_callbacks = []
        
        # 配置参数
        self.health_check_interval = config.get('health_check_interval', 10)  # 秒
        self.failure_threshold = config.get('failure_threshold', 3)  # 连续失败次数
        self.recovery_check_interval = config.get('recovery_check_interval', 30)  # 秒
        self.max_failover_time = config.get('max_failover_time', 300)  # 秒
        
        # 状态跟踪
        self.failure_count = {}
        self.last_health_check = {}
        
        for node in self.nodes:
            self.failure_count[node] = 0
            self.last_health_check[node] = None
    
    def add_failover_callback(self, callback):
        """添加故障转移回调函数"""
        self.failover_callbacks.append(callback)
    
    def start_monitoring(self):
        """启动健康监控"""
        if not self.monitoring_enabled:
            self.monitoring_enabled = True
            self.monitoring_thread = threading.Thread(target=self._monitoring_loop, daemon=True)
            self.monitoring_thread.start()
            print("自动故障转移监控已启动")
    
    def stop_monitoring(self):
        """停止健康监控"""
        self.monitoring_enabled = False
        if self.monitoring_thread:
            self.monitoring_thread.join(timeout=5)
        print("自动故障转移监控已停止")
    
    def _monitoring_loop(self):
        """监控循环"""
        while self.monitoring_enabled:
            try:
                if self.failover_state == FailoverState.NORMAL:
                    self._check_master_health()
                elif self.failover_state == FailoverState.FAILING_OVER:
                    self._monitor_failover_progress()
                elif self.failover_state == FailoverState.RECOVERING:
                    self._check_recovery()
                
                time.sleep(self.health_check_interval)
                
            except Exception as e:
                print(f"监控循环异常: {e}")
                time.sleep(5)
    
    def _check_master_health(self):
        """检查主节点健康状态"""
        if not self.current_master:
            return
        
        result = self._check_node_health(self.current_master)
        self.last_health_check[self.current_master] = time.time()
        
        if not result.healthy:
            self.failure_count[self.current_master] += 1
            
            if self.failure_count[self.current_master] >= self.failure_threshold:
                print(f"主节点 {self.current_master} 连续失败 {self.failure_threshold} 次，触发故障转移")
                self._initiate_failover()
        else:
            self.failure_count[self.current_master] = 0
    
    def _check_node_health(self, node: str) -> HealthCheckResult:
        """检查节点健康状态"""
        try:
            start_time = time.time()
            
            # 检查API连通性
            url = f"http://{node}:15672/api/overview"
            response = requests.get(url, timeout=5)
            
            latency = time.time() - start_time
            
            if response.status_code == 200:
                # 检查队列状态
                queues_url = f"http://{node}:15672/api/queues"
                queues_response = requests.get(url=queues_url, timeout=5)
                
                if queues_response.status_code == 200:
                    return HealthCheckResult(node, True, latency)
                else:
                    return HealthCheckResult(node, False, latency, f"队列API返回状态码: {queues_response.status_code}")
            else:
                return HealthCheckResult(node, False, latency, f"API返回状态码: {response.status_code}")
                
        except Exception as e:
            return HealthCheckResult(node, False, time.time() - start_time, str(e))
    
    def _initiate_failover(self):
        """启动故障转移"""
        self.failover_state = FailoverState.FAILING_OVER
        print(f"开始故障转移: {self.current_master}")
        
        # 通知故障转移回调
        for callback in self.failover_callbacks:
            try:
                callback('failover_started', {
                    'failed_node': self.current_master,
                    'new_master': None
                })
            except Exception as e:
                print(f"故障转移回调执行失败: {e}")
        
        # 寻找备选节点
        candidate_nodes = [node for node in self.nodes if node != self.current_master]
        new_master = self._find_best_candidate(candidate_nodes)
        
        if new_master:
            print(f"选择新主节点: {new_master}")
            self._perform_failover(new_master)
        else:
            print("没有找到合适的备选节点")
            self.failover_state = FailoverState.FAILED
    
    def _find_best_candidate(self, candidates: List[str]) -> Optional[str]:
        """找到最佳候选节点"""
        best_node = None
        best_score = -1
        
        for node in candidates:
            result = self._check_node_health(node)
            
            if result.healthy:
                # 计算节点分数（延迟越低越好）
                score = 1000 - (result.latency * 1000)  # 基于延迟计算分数
                
                # 检查是否为镜像节点
                if self._is_mirror_node(node):
                    score += 1000  # 镜像节点优先级更高
                
                if score > best_score:
                    best_score = score
                    best_node = node
        
        return best_node
    
    def _is_mirror_node(self, node: str) -> bool:
        """检查是否为镜像节点"""
        try:
            url = f"http://{node}:15672/api/queues"
            response = requests.get(url, timeout=5)
            
            if response.status_code == 200:
                queues = response.json()
                for queue in queues:
                    if 'policy' in queue and queue['policy'] and 'mirroring' in queue['policy']:
                        return True
            return False
        except:
            return False
    
    def _perform_failover(self, new_master: str):
        """执行故障转移"""
        try:
            failover_start_time = time.time()
            
            # 执行故障转移
            success = self._execute_failover(new_master)
            
            failover_time = time.time() - failover_start_time
            
            if success and failover_time <= self.max_failover_time:
                self.current_master = new_master
                self.failover_state = FailoverState.RECOVERING
                print(f"故障转移成功，新主节点: {new_master}")
                
                # 通知故障转移回调
                for callback in self.failover_callbacks:
                    try:
                        callback('failover_completed', {
                            'failed_node': self.current_master,
                            'new_master': new_master,
                            'failover_time': failover_time
                        })
                    except Exception as e:
                        print(f"故障转移回调执行失败: {e}")
            else:
                print("故障转移失败")
                self.failover_state = FailoverState.FAILED
                
        except Exception as e:
            print(f"执行故障转移时发生异常: {e}")
            self.failover_state = FailoverState.FAILED
    
    def _execute_failover(self, new_master: str) -> bool:
        """执行具体的故障转移操作"""
        try:
            # 这里可以实现具体的故障转移逻辑
            # 例如：RabbitMQ镜像队列的故障转移
            
            # 1. 更新HAProxy配置
            self._update_haproxy_config(new_master)
            
            # 2. 通知客户端重新连接
            self._notify_clients_reconnect(new_master)
            
            # 3. 验证故障转移结果
            time.sleep(10)  # 等待服务启动
            result = self._check_node_health(new_master)
            
            return result.healthy
            
        except Exception as e:
            print(f"故障转移执行失败: {e}")
            return False
    
    def _update_haproxy_config(self, new_master: str):
        """更新HAProxy配置"""
        # 这里可以动态更新HAProxy配置
        # 例如使用API调用或文件更新
        pass
    
    def _notify_clients_reconnect(self, new_master: str):
        """通知客户端重新连接"""
        # 这里可以实现客户端通知机制
        # 例如：通过管理API或消息广播
        pass
    
    def _monitor_failover_progress(self):
        """监控故障转移进度"""
        # 监控故障转移的执行进度
        # 如果超时，可以触发超时处理
        pass
    
    def _check_recovery(self):
        """检查恢复状态"""
        # 检查原主节点是否恢复正常
        if self.last_health_check.get(self.current_master):
            if time.time() - self.last_health_check[self.current_master] < self.recovery_check_interval:
                return
        
        result = self._check_node_health(self.current_master)
        
        if result.healthy:
            # 原主节点已恢复，可以选择是否回切
            print(f"原主节点 {self.current_master} 已恢复")
            self._evaluate_failback()
        else:
            self.last_health_check[self.current_master] = time.time()
    
    def _evaluate_failback(self):
        """评估是否需要回切"""
        # 评估回切的收益和风险
        # 可以基于业务需求、性能指标等做出决定
        
        # 这里可以实现智能回切逻辑
        self.failover_state = FailoverState.NORMAL
        print("系统恢复正常运行状态")
    
    def get_status(self) -> Dict:
        """获取故障转移状态"""
        return {
            'failover_state': self.failover_state.value,
            'current_master': self.current_master,
            'monitoring_enabled': self.monitoring_enabled,
            'failure_count': self.failure_count,
            'last_health_check': self.last_health_check
        }
    
    def manual_failover(self, target_node: str):
        """手动故障转移"""
        if target_node not in self.nodes:
            raise ValueError(f"目标节点 {target_node} 不在节点列表中")
        
        if target_node == self.current_master:
            print(f"目标节点 {target_node} 就是当前主节点，无需故障转移")
            return
        
        print(f"执行手动故障转移，目标节点: {target_node}")
        self._perform_failover(target_node)
    
    def force_failover(self):
        """强制故障转移"""
        if not self.current_master:
            print("没有当前主节点，无法执行强制故障转移")
            return
        
        print("执行强制故障转移")
        candidates = [node for node in self.nodes if node != self.current_master]
        new_master = self._find_best_candidate(candidates)
        
        if new_master:
            self._perform_failover(new_master)
        else:
            print("没有找到可用的备选节点")
            self.failover_state = FailoverState.FAILED
```

## 10.4 备份与恢复

### 10.4.1 自动化备份

#### 备份策略

```python
import os
import shutil
import gzip
import json
import time
import tarfile
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from enum import Enum

class BackupType(Enum):
    """备份类型"""
    FULL = "full"              # 完整备份
    INCREMENTAL = "incremental" # 增量备份
    CONFIGURATION = "config"   # 配置备份
    QUEUE_DATA = "queue_data"  # 队列数据备份

class BackupStatus(Enum):
    """备份状态"""
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    CANCELLED = "cancelled"

class BackupManager:
    """备份管理器"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.rabbitmq_config = config.get('rabbitmq', {})
        self.backup_dir = config.get('backup_dir', '/var/backups/rabbitmq')
        self.retention_days = config.get('retention_days', 30)
        
        # 确保备份目录存在
        os.makedirs(self.backup_dir, exist_ok=True)
    
    def create_full_backup(self, description: str = "") -> str:
        """创建完整备份"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"full_backup_{timestamp}"
        backup_path = os.path.join(self.backup_dir, backup_name)
        
        try:
            # 创建备份目录
            os.makedirs(backup_path, exist_ok=True)
            
            # 1. 备份Mnesia数据库
            self._backup_mnesia_database(backup_path)
            
            # 2. 备份配置文件
            self._backup_configuration_files(backup_path)
            
            # 3. 备份日志文件
            self._backup_log_files(backup_path)
            
            # 4. 压缩备份
            compressed_path = self._compress_backup(backup_path)
            
            # 5. 创建备份元数据
            metadata = {
                'backup_type': 'full',
                'created_at': datetime.now().isoformat(),
                'description': description,
                'size_bytes': os.path.getsize(compressed_path)
            }
            
            metadata_file = f"{backup_name}_metadata.json"
            with open(os.path.join(self.backup_dir, metadata_file), 'w') as f:
                json.dump(metadata, f, indent=2)
            
            print(f"完整备份成功: {compressed_path}")
            return compressed_path
            
        except Exception as e:
            # 清理失败的备份
            if os.path.exists(backup_path):
                shutil.rmtree(backup_path)
            raise Exception(f"完整备份失败: {e}")
    
    def _backup_mnesia_database(self, backup_path: str):
        """备份Mnesia数据库"""
        try:
            # 使用RabbitMQ内置的backup命令
            import subprocess
            
            mnesia_backup_path = os.path.join(backup_path, 'mnesia')
            
            # 执行数据库备份命令
            cmd = ['rabbitmqctl', 'backup', mnesia_backup_path]
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode != 0:
                raise Exception(f"Mnesia备份失败: {result.stderr}")
            
            print("Mnesia数据库备份完成")
            
        except Exception as e:
            print(f"Mnesia数据库备份失败: {e}")
            # 如果内置备份失败，尝试手动复制
            self._backup_mnesia_manual(backup_path)
    
    def _backup_mnesia_manual(self, backup_path: str):
        """手动备份Mnesia目录"""
        mnesia_dirs = [
            '/var/lib/rabbitmq/mnesia',
            '/opt/rabbitmq/var/lib/rabbitmq/mnesia',
            './mnesia'
        ]
        
        for mnesia_dir in mnesia_dirs:
            if os.path.exists(mnesia_dir):
                target_dir = os.path.join(backup_path, 'mnesia')
                shutil.copytree(mnesia_dir, target_dir)
                print(f"手动备份Mnesia目录: {mnesia_dir} -> {target_dir}")
                break
        else:
            print("未找到Mnesia目录")
    
    def _backup_configuration_files(self, backup_path: str):
        """备份配置文件"""
        config_files = [
            '/etc/rabbitmq/rabbitmq.conf',
            '/etc/rabbitmq/advanced.config',
            '/etc/rabbitmq/enabled_plugins',
            '/etc/rabbitmq/definitions.json'
        ]
        
        config_backup_dir = os.path.join(backup_path, 'config')
        os.makedirs(config_backup_dir, exist_ok=True)
        
        for config_file in config_files:
            if os.path.exists(config_file):
                try:
                    shutil.copy2(config_file, config_backup_dir)
                    print(f"备份配置文件: {config_file}")
                except Exception as e:
                    print(f"备份配置文件失败: {config_file}, {e}")
    
    def _backup_log_files(self, backup_path: str):
        """备份日志文件"""
        log_dirs = [
            '/var/log/rabbitmq',
            '/opt/rabbitmq/var/log/rabbitmq',
            './log'
        ]
        
        for log_dir in log_dirs:
            if os.path.exists(log_dir):
                try:
                    target_dir = os.path.join(backup_path, 'logs')
                    os.makedirs(target_dir, exist_ok=True)
                    
                    for log_file in os.listdir(log_dir):
                        if log_file.endswith('.log'):
                            source = os.path.join(log_dir, log_file)
                            target = os.path.join(target_dir, log_file)
                            shutil.copy2(source, target)
                    
                    print(f"备份日志目录: {log_dir}")
                    break
                    
                except Exception as e:
                    print(f"备份日志目录失败: {log_dir}, {e}")
    
    def _compress_backup(self, backup_path: str) -> str:
        """压缩备份"""
        compressed_file = f"{backup_path}.tar.gz"
        
        try:
            # 创建tar.gz压缩包
            with tarfile.open(compressed_file, 'w:gz') as tar:
                tar.add(backup_path, arcname=os.path.basename(backup_path))
            
            # 删除原始目录
            shutil.rmtree(backup_path)
            
            print(f"备份压缩完成: {compressed_file}")
            return compressed_file
            
        except Exception as e:
            print(f"备份压缩失败: {e}")
            # 如果压缩失败，返回原始目录
            return backup_path
    
    def restore_backup(self, backup_path: str, stop_service: bool = True) -> bool:
        """恢复备份"""
        if not os.path.exists(backup_path):
            raise FileNotFoundError(f"备份文件不存在: {backup_path}")
        
        try:
            print(f"开始恢复备份: {backup_path}")
            
            # 1. 停止RabbitMQ服务（如果需要）
            if stop_service:
                self._stop_rabbitmq()
                time.sleep(10)
            
            # 2. 解压备份文件
            temp_restore_dir = self._extract_backup(backup_path)
            
            try:
                # 3. 恢复配置文件
                self._restore_configuration_files(temp_restore_dir)
                
                # 4. 恢复Mnesia数据库
                self._restore_mnesia_database(temp_restore_dir)
                
                # 5. 启动RabbitMQ服务
                if stop_service:
                    self._start_rabbitmq()
                
                print("备份恢复成功完成")
                return True
                
            finally:
                # 清理临时目录
                if os.path.exists(temp_restore_dir):
                    shutil.rmtree(temp_restore_dir)
            
        except Exception as e:
            print(f"备份恢复失败: {e}")
            return False
    
    def _extract_backup(self, backup_path: str) -> str:
        """解压备份文件"""
        temp_dir = f"/tmp/rabbitmq_restore_{int(time.time())}"
        
        try:
            if backup_path.endswith('.tar.gz'):
                # 解压tar.gz文件
                with tarfile.open(backup_path, 'r:gz') as tar:
                    tar.extractall(temp_dir)
            elif os.path.isdir(backup_path):
                # 直接复制目录
                shutil.copytree(backup_path, temp_dir)
            else:
                raise ValueError(f"不支持的备份文件格式: {backup_path}")
            
            return temp_dir
            
        except Exception as e:
            print(f"解压备份文件失败: {e}")
            raise
    
    def _stop_rabbitmq(self):
        """停止RabbitMQ服务"""
        try:
            import subprocess
            subprocess.run(['systemctl', 'stop', 'rabbitmq-server'], 
                         capture_output=True, check=True)
            print("RabbitMQ服务已停止")
        except Exception as e:
            print(f"停止RabbitMQ服务失败: {e}")
            raise
    
    def _start_rabbitmq(self):
        """启动RabbitMQ服务"""
        try:
            import subprocess
            subprocess.run(['systemctl', 'start', 'rabbitmq-server'], 
                         capture_output=True, check=True)
            print("RabbitMQ服务已启动")
        except Exception as e:
            print(f"启动RabbitMQ服务失败: {e}")
            raise
    
    def _restore_configuration_files(self, restore_dir: str):
        """恢复配置文件"""
        config_backup_dir = os.path.join(restore_dir, 'config')
        
        if not os.path.exists(config_backup_dir):
            print("未找到配置文件备份")
            return
        
        for config_file in os.listdir(config_backup_dir):
            source = os.path.join(config_backup_dir, config_file)
            target = os.path.join('/etc/rabbitmq', config_file)
            
            try:
                shutil.copy2(source, target)
                print(f"恢复配置文件: {source} -> {target}")
            except Exception as e:
                print(f"恢复配置文件失败: {source} -> {target}, {e}")
    
    def _restore_mnesia_database(self, restore_dir: str):
        """恢复Mnesia数据库"""
        mnesia_backup_path = os.path.join(restore_dir, 'mnesia')
        
        if not os.path.exists(mnesia_backup_path):
            print("未找到Mnesia数据库备份")
            return
        
        mnesia_restore_paths = [
            '/var/lib/rabbitmq/mnesia',
            '/opt/rabbitmq/var/lib/rabbitmq/mnesia'
        ]
        
        # 停止Mnesia应用
        try:
            import subprocess
            subprocess.run(['rabbitmqctl', 'stop_app'], 
                         capture_output=True, check=True)
        except Exception as e:
            print(f"停止Mnesia应用失败: {e}")
        
        for mnesia_restore_path in mnesia_restore_paths:
            if os.path.exists(mnesia_restore_path):
                backup_timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_path = f"{mnesia_restore_path}_pre_restore_{backup_timestamp}"
                shutil.move(mnesia_restore_path, backup_path)
                
                # 恢复数据库
                shutil.copytree(mnesia_backup_path, mnesia_restore_path)
                print(f"恢复Mnesia数据库: {mnesia_backup_path} -> {mnesia_restore_path}")
                break
    
    def cleanup_old_backups(self):
        """清理旧备份"""
        cutoff_date = datetime.now() - timedelta(days=self.retention_days)
        
        cleanup_count = 0
        for filename in os.listdir(self.backup_dir):
            file_path = os.path.join(self.backup_dir, filename)
            
            # 检查文件修改时间
            file_mtime = datetime.fromtimestamp(os.path.getmtime(file_path))
            
            if file_mtime < cutoff_date:
                try:
                    if os.path.isdir(file_path):
                        shutil.rmtree(file_path)
                    else:
                        os.remove(file_path)
                    
                    cleanup_count += 1
                    print(f"清理旧备份: {filename}")
                    
                except Exception as e:
                    print(f"清理备份失败: {filename}, {e}")
        
        print(f"清理完成，共清理 {cleanup_count} 个旧备份")
    
    def list_backups(self) -> List[Dict]:
        """列出所有备份"""
        backups = []
        
        for filename in os.listdir(self.backup_dir):
            file_path = os.path.join(self.backup_dir, filename)
            
            if filename.endswith('_metadata.json'):
                try:
                    with open(file_path, 'r') as f:
                        metadata = json.load(f)
                    
                    backup_name = filename.replace('_metadata.json', '')
                    actual_backup_file = os.path.join(self.backup_dir, backup_name)
                    
                    if os.path.exists(actual_backup_file):
                        backup_info = {
                            'backup_file': actual_backup_file,
                            'created_at': metadata['created_at'],
                            'backup_type': metadata.get('backup_type', 'unknown'),
                            'description': metadata.get('description', ''),
                            'size_bytes': os.path.getsize(actual_backup_file)
                        }
                        backups.append(backup_info)
                        
                except Exception as e:
                    print(f"解析备份信息失败: {filename}, {e}")
        
        return sorted(backups, key=lambda x: x['created_at'], reverse=True)
```

### 10.4.2 灾难恢复计划

#### 灾难恢复策略

```python
import json
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple

class DisasterRecoveryPlan:
    """灾难恢复计划"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.rpo_target = config.get('rpo_target', 3600)  # 恢复点目标（秒）
        self.rto_target = config.get('rto_target', 1800)  # 恢复时间目标（秒）
        self.backup_manager = BackupManager(config.get('backup_manager', {}))
        
    def create_recovery_plan(self, disaster_scenario: str) -> Dict:
        """创建恢复计划"""
        recovery_plans = {
            'single_node_failure': self._create_single_node_recovery_plan(),
            'cluster_node_failure': self._create_cluster_node_recovery_plan(),
            'network_partition': self._create_network_partition_recovery_plan(),
            'data_corruption': self._create_data_corruption_recovery_plan(),
            'complete_system_failure': self._create_complete_system_recovery_plan()
        }
        
        return recovery_plans.get(disaster_scenario, {})
    
    def _create_single_node_recovery_plan(self) -> Dict:
        """单节点故障恢复计划"""
        return {
            'scenario': '单节点故障',
            'detection': [
                '监控告警：节点不可达',
                '健康检查失败',
                '连接失败'
            ],
            'immediate_actions': [
                {
                    'step': 1,
                    'action': '确认故障范围',
                    'description': '验证是单节点故障还是集群故障',
                    'timeout': 300,
                    'responsible': '运维工程师'
                },
                {
                    'step': 2,
                    'action': '评估影响',
                    'description': '评估故障对业务的影响',
                    'timeout': 600,
                    'responsible': '业务分析师'
                }
            ],
            'recovery_steps': [
                {
                    'step': 3,
                    'action': '重启节点服务',
                    'commands': [
                        'systemctl restart rabbitmq-server',
                        'rabbitmqctl status'
                    ],
                    'timeout': 300,
                    'validation': '节点状态正常，队列可访问'
                },
                {
                    'step': 4,
                    'action': '验证数据完整性',
                    'commands': [
                        'rabbitmqctl list_queues',
                        'rabbitmqctl list_channels'
                    ],
                    'timeout': 600,
                    'validation': '队列数量、消息数量正常'
                },
                {
                    'step': 5,
                    'action': '监控恢复过程',
                    'description': '持续监控10-30分钟确认稳定性',
                    'timeout': 1800,
                    'validation': '无异常告警，性能正常'
                }
            ],
            'fallback_plan': '如果重启失败，联系技术支持或使用备份恢复',
            'validation_criteria': [
                '节点状态为running',
                '队列可正常访问',
                '消息丢失率 < 0.1%',
                '延迟在可接受范围内'
            ]
        }
    
    def _create_cluster_node_recovery_plan(self) -> Dict:
        """集群节点故障恢复计划"""
        return {
            'scenario': '集群节点故障',
            'detection': [
                '监控告警：多个节点不可达',
                '集群状态检查失败',
                'HA队列不可用'
            ],
            'immediate_actions': [
                {
                    'step': 1,
                    'action': '确认集群状态',
                    'commands': ['rabbitmqctl cluster_status'],
                    'timeout': 300,
                    'responsible': '集群管理员'
                },
                {
                    'step': 2,
                    'action': '评估集群健康度',
                    'description': '检查剩余节点是否能够维持服务',
                    'timeout': 600,
                    'responsible': '技术主管'
                }
            ],
            'recovery_steps': [
                {
                    'step': 3,
                    'action': '重置故障节点',
                    'commands': [
                        'rabbitmqctl stop_app',
                        'rabbitmqctl reset',
                        'rabbitmqctl start_app'
                    ],
                    'timeout': 600,
                    'validation': '节点成功加入集群'
                },
                {
                    'step': 4,
                    'action': '重新加入集群',
                    'commands': [
                        'rabbitmqctl stop_app',
                        'rabbitmqctl join_cluster <cluster_node>',
                        'rabbitmqctl start_app'
                    ],
                    'timeout': 600,
                    'validation': '集群状态显示所有节点'
                },
                {
                    'step': 5,
                    'action': '同步镜像队列',
                    'description': '等待镜像队列同步完成',
                    'timeout': 3600,
                    'validation': '镜像队列同步状态正常'
                }
            ],
            'fallback_plan': '使用最后一个可用备份进行恢复',
            'validation_criteria': [
                '集群状态显示所有节点正常',
                '镜像队列同步完成',
                '服务可用性恢复'
            ]
        }
    
    def _create_complete_system_recovery_plan(self) -> Dict:
        """完全系统故障恢复计划"""
        return {
            'scenario': '完全系统故障',
            'detection': [
                '所有节点不可达',
                '数据中心不可访问',
                '基础服务中断'
            ],
            'immediate_actions': [
                {
                    'step': 1,
                    'action': '启动DR站点',
                    'description': '激活灾难恢复站点',
                    'timeout': 1800,
                    'responsible': '系统管理员'
                },
                {
                    'step': 2,
                    'action': '评估数据状态',
                    'description': '确定可用备份和恢复点',
                    'timeout': 900,
                    'responsible': '数据库专家'
                }
            ],
            'recovery_steps': [
                {
                    'step': 3,
                    'action': '部署新集群',
                    'description': '在DR站点部署RabbitMQ集群',
                    'timeout': 7200,
                    'validation': '集群部署成功'
                },
                {
                    'step': 4,
                    'action': '恢复最新备份',
                    'commands': [
                        '选择最新的完整备份',
                        '执行恢复操作'
                    ],
                    'timeout': 10800,
                    'validation': '数据恢复完成'
                },
                {
                    'step': 5,
                    'action': '验证服务可用性',
                    'description': '测试消息发送和接收',
                    'timeout': 3600,
                    'validation': '服务功能正常'
                },
                {
                    'step': 6,
                    'action': '切换流量',
                    'description': '将业务流量切换到DR站点',
                    'timeout': 1800,
                    'validation': '业务流量正常'
                }
            ],
            'recovery_time_objective': self.rto_target,
            'recovery_point_objective': self.rpo_target,
            'validation_criteria': [
                'DR站点服务正常',
                '数据完整性验证通过',
                '业务功能测试通过',
                '性能指标在正常范围内'
            ]
        }
```

## 10.5 故障演练与测试

### 10.5.1 故障演练框架

```python
import time
import threading
from typing import Dict, List, Callable
from datetime import datetime

class FailureDrill:
    """故障演练"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.drill_active = False
        self.current_drill = None
        self.observers = []
        
    def add_observer(self, observer: Callable):
        """添加观察者"""
        self.observers.append(observer)
    
    def _notify_observers(self, event: str, data: Dict):
        """通知观察者"""
        for observer in self.observers:
            try:
                observer(event, data)
            except Exception as e:
                print(f"观察者通知失败: {e}")
    
    def simulate_node_failure(self, node: str, duration: int = 300) -> Dict:
        """模拟节点故障"""
        drill_id = f"node_failure_{int(time.time())}"
        
        drill_plan = {
            'drill_id': drill_id,
            'type': 'node_failure',
            'target_node': node,
            'start_time': datetime.now(),
            'duration': duration,
            'steps': [
                {
                    'step': 1,
                    'action': '注入故障',
                    'description': f'停止 {node} 节点服务',
                    'commands': [f'systemctl stop rabbitmq@{node}']
                },
                {
                    'step': 2,
                    'action': '观察系统行为',
                    'description': '监控故障检测和转移过程',
                    'duration': 60
                },
                {
                    'step': 3,
                    'action': '恢复节点',
                    'description': '重新启动故障节点',
                    'commands': [f'systemctl start rabbitmq@{node}'],
                    'delay': duration
                }
            ]
        }
        
        self._execute_drill(drill_plan)
        return drill_plan
    
    def simulate_network_partition(self, nodes: List[str], duration: int = 600) -> Dict:
        """模拟网络分区"""
        drill_id = f"network_partition_{int(time.time())}"
        
        drill_plan = {
            'drill_id': drill_id,
            'type': 'network_partition',
            'affected_nodes': nodes,
            'start_time': datetime.now(),
            'duration': duration,
            'steps': [
                {
                    'step': 1,
                    'action': '隔离节点',
                    'description': f'隔离节点 {", ".join(nodes)}',
                    'commands': [f'iptables -A INPUT -s {", ".join(nodes)} -j DROP']
                },
                {
                    'step': 2,
                    'action': '观察集群行为',
                    'description': '监控集群分割检测和处理',
                    'duration': 120
                },
                {
                    'step': 3,
                    'action': '恢复网络',
                    'description': '恢复节点间网络连接',
                    'commands': [f'iptables -D INPUT -s {", ".join(nodes)} -j DROP'],
                    'delay': duration
                }
            ]
        }
        
        self._execute_drill(drill_plan)
        return drill_plan
    
    def simulate_data_corruption(self, node: str) -> Dict:
        """模拟数据损坏"""
        drill_id = f"data_corruption_{int(time.time())}"
        
        drill_plan = {
            'drill_id': drill_id,
            'type': 'data_corruption',
            'target_node': node,
            'start_time': datetime.now(),
            'steps': [
                {
                    'step': 1,
                    'action': '损坏数据文件',
                    'description': f'损坏 {node} 节点的数据文件',
                    'commands': [f'echo "corrupted" > /var/lib/rabbitmq/mnesia/{node}/NODE_Mnesia.dcd']
                },
                {
                    'step': 2,
                    'action': '重启服务',
                    'description': '重启节点以触发数据恢复',
                    'commands': [f'systemctl restart rabbitmq@{node}']
                },
                {
                    'step': 3,
                    'action': '验证恢复',
                    'description': '检查数据恢复情况',
                    'commands': ['rabbitmqctl list_queues']
                }
            ]
        }
        
        self._execute_drill(drill_plan)
        return drill_plan
    
    def _execute_drill(self, drill_plan: Dict):
        """执行演练"""
        self.drill_active = True
        self.current_drill = drill_plan
        
        self._notify_observers('drill_started', drill_plan)
        
        try:
            for step in drill_plan['steps']:
                print(f"执行演练步骤 {step['step']}: {step['action']}")
                
                # 执行命令
                if 'commands' in step:
                    self._execute_commands(step['commands'])
                
                # 等待指定时间
                if 'duration' in step:
                    time.sleep(step['duration'])
                
                # 延迟执行
                if 'delay' in step:
                    time.sleep(step['delay'])
                
                self._notify_observers('step_completed', step)
            
            drill_plan['status'] = 'completed'
            drill_plan['end_time'] = datetime.now()
            
        except Exception as e:
            drill_plan['status'] = 'failed'
            drill_plan['error'] = str(e)
            drill_plan['end_time'] = datetime.now()
            
        finally:
            self.drill_active = False
            self.current_drill = None
            self._notify_observers('drill_completed', drill_plan)
    
    def _execute_commands(self, commands: List[str]):
        """执行命令"""
        import subprocess
        
        for command in commands:
            try:
                print(f"执行命令: {command}")
                result = subprocess.run(command, shell=True, capture_output=True, text=True)
                
                if result.returncode != 0:
                    print(f"命令执行失败: {command}, 错误: {result.stderr}")
                else:
                    print(f"命令执行成功: {command}")
                    
            except Exception as e:
                print(f"命令执行异常: {command}, 错误: {e}")
    
    def get_drill_status(self) -> Dict:
        """获取演练状态"""
        return {
            'drill_active': self.drill_active,
            'current_drill': self.current_drill,
            'timestamp': datetime.now().isoformat()
        }
    
    def stop_drill(self):
        """停止当前演练"""
        if self.drill_active and self.current_drill:
            self.current_drill['status'] = 'stopped'
            self.current_drill['end_time'] = datetime.now()
            
            self.drill_active = False
            self.current_drill = None
            
            self._notify_observers('drill_stopped', {})
```

## 10.6 总结

本章详细介绍了RabbitMQ的故障处理与恢复体系，包括：

1. **故障分类与检测**：系统化的故障分类方法和全面的健康检查机制
2. **故障处理策略**：自动故障转移、备份恢复等关键策略
3. **灾难恢复计划**：不同场景下的恢复计划和执行步骤
4. **故障演练框架**：定期的故障演练和验证机制

通过建立完善的故障处理与恢复体系，可以确保RabbitMQ系统在面临各种故障时能够快速响应、有效处理并完全恢复，最大限度地减少业务中断和数据损失。

关键要点：
- 建立多层次的故障检测机制
- 制定详细的故障处理流程
- 定期进行故障演练和验证
- 保持备份策略的完整性和可用性
- 建立应急响应团队和值班制度

故障处理与恢复是RabbitMQ运维的重要组成部分，需要持续的投入和优化，以确保系统的高可用性和业务连续性。