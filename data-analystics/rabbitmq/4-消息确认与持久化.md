# ç¬¬4ç« ï¼šæ¶ˆæ¯ç¡®è®¤ä¸æŒä¹…åŒ–

## ğŸ“– ç« èŠ‚æ¦‚è¿°

æ¶ˆæ¯ç¡®è®¤ä¸æŒä¹…åŒ–æ˜¯RabbitMQç¡®ä¿æ¶ˆæ¯å¯é ä¼ é€’çš„æ ¸å¿ƒæœºåˆ¶ã€‚æœ¬ç« å°†æ·±å…¥æ¢è®¨æ¶ˆæ¯ç¡®è®¤çš„å„ä¸ªæ–¹é¢ã€æŒä¹…åŒ–ç­–ç•¥ã€äº‹åŠ¡å¤„ç†ä»¥åŠåœ¨ç”Ÿäº§ç¯å¢ƒä¸­å¦‚ä½•è®¾è®¡å¯é çš„æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

- ç†è§£æ¶ˆæ¯ç¡®è®¤æœºåˆ¶çš„å·¥ä½œåŸç†
- æŒæ¡ä¸åŒç¡®è®¤æ¨¡å¼çš„å®é™…åº”ç”¨
- å­¦ä¼šè®¾è®¡å¯é çš„æŒä¹…åŒ–ç­–ç•¥
- æŒæ¡äº‹åŠ¡å¤„ç†çš„æœ€ä½³å®è·µ
- èƒ½å¤Ÿåœ¨ç”Ÿäº§ç¯å¢ƒä¸­å®ç°å¯é çš„æ¶ˆæ¯ä¼ é€’

## ğŸ“š ç›®å½•

1. [æ¶ˆæ¯ç¡®è®¤åŸºç¡€](#1-æ¶ˆæ¯ç¡®è®¤åŸºç¡€)
2. [è‡ªåŠ¨ç¡®è®¤æ¨¡å¼](#2-è‡ªåŠ¨ç¡®è®¤æ¨¡å¼)
3. [æ‰‹åŠ¨ç¡®è®¤æ¨¡å¼](#3-æ‰‹åŠ¨ç¡®è®¤æ¨¡å¼)
4. [æ¶ˆæ¯æŒä¹…åŒ–ç­–ç•¥](#4-æ¶ˆæ¯æŒä¹…åŒ–ç­–ç•¥)
5. [äº‹åŠ¡å¤„ç†æœºåˆ¶](#5-äº‹åŠ¡å¤„ç†æœºåˆ¶)
6. [æœ€ä½³å®è·µä¸æ€§èƒ½ä¼˜åŒ–](#6-æœ€ä½³å®è·µä¸æ€§èƒ½ä¼˜åŒ–)
7. [å®é™…åº”ç”¨åœºæ™¯](#7-å®é™…åº”ç”¨åœºæ™¯)
8. [å®éªŒéªŒè¯](#8-å®éªŒéªŒè¯)
9. [æ•…éšœæ’æŸ¥](#9-æ•…éšœæ’æŸ¥)

## 1. æ¶ˆæ¯ç¡®è®¤åŸºç¡€

### 1.1 ä¸ºä»€ä¹ˆéœ€è¦æ¶ˆæ¯ç¡®è®¤ï¼Ÿ

åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œæ¶ˆæ¯ä¼ é€’å¯èƒ½å‡ºç°å„ç§é—®é¢˜ï¼š
- **ç½‘ç»œä¸­æ–­**ï¼šæ¶ˆæ¯åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­ä¸¢å¤±
- **æ¶ˆè´¹è€…æ•…éšœ**ï¼šå¤„ç†æ¶ˆæ¯æ—¶å‘ç”Ÿå¼‚å¸¸
- **RabbitMQæ•…éšœ**ï¼šæœåŠ¡å™¨é‡å¯æˆ–å´©æºƒ
- **é˜Ÿåˆ—æº¢å‡º**ï¼šæ¶ˆæ¯ç§¯å‹è¿‡å¤š

æ¶ˆæ¯ç¡®è®¤æœºåˆ¶ç¡®ä¿ï¼š
- âœ… **è‡³å°‘ä¸€æ¬¡æŠ•é€’**ï¼šæ¶ˆæ¯ä¸ä¼šä¸¢å¤±
- âœ… **æ— é‡å¤å¤„ç†**ï¼šé¿å…é‡å¤æ¶ˆè´¹
- âœ… **æ•°æ®ä¸€è‡´æ€§**ï¼šä¿è¯ä¸šåŠ¡æ•°æ®æ­£ç¡®æ€§

### 1.2 AMQPç¡®è®¤æœºåˆ¶

AMQPåè®®å®šä¹‰äº†å®Œæ•´çš„ç¡®è®¤æœºåˆ¶ï¼š

```python
# æ¶ˆæ¯ç¡®è®¤æµç¨‹
Producer -> Exchange -> Queue -> Consumer -> (ç¡®è®¤) -> Broker
```

**ç¡®è®¤ç±»å‹ï¼š**
- **Publisher Confirms**ï¼šç”Ÿäº§è€…ç¡®è®¤
- **Consumer Acknowledgments**ï¼šæ¶ˆè´¹è€…ç¡®è®¤
- **Transaction Confirms**ï¼šäº‹åŠ¡ç¡®è®¤

### 1.3 ç¡®è®¤æœºåˆ¶å±‚æ¬¡

```
åº”ç”¨å±‚ç¡®è®¤
    â†“
æ¶ˆè´¹è€…ç¡®è®¤ (basic.ack)
    â†“
é˜Ÿåˆ—ç¡®è®¤ (queue.ack)
    â†“
äº¤æ¢æœºç¡®è®¤ (exchange.ack)
    â†“
ç½‘ç»œå±‚ç¡®è®¤ (frame.ack)
```

## 2. è‡ªåŠ¨ç¡®è®¤æ¨¡å¼

### 2.1 è‡ªåŠ¨ç¡®è®¤åŸç†

```python
# è‡ªåŠ¨ç¡®è®¤é…ç½®
channel.basic_consume(
    queue='hello',
    on_message_callback=callback_function,
    auto_ack=True  # è‡ªåŠ¨ç¡®è®¤
)
```

**å·¥ä½œæµç¨‹ï¼š**
1. æ¶ˆæ¯æŠ•é€’åˆ°æ¶ˆè´¹è€…
2. æ¶ˆè´¹è€…æ¥æ”¶æ¶ˆæ¯
3. **RabbitMQè‡ªåŠ¨ç¡®è®¤**æ¶ˆæ¯å·²è¢«æ¶ˆè´¹
4. æ¶ˆæ¯ä»é˜Ÿåˆ—ä¸­ç§»é™¤
5. æ¶ˆè´¹è€…å¤„ç†æ¶ˆæ¯ï¼ˆå¯èƒ½åœ¨ç¡®è®¤åï¼‰

### 2.2 è‡ªåŠ¨ç¡®è®¤ä»£ç ç¤ºä¾‹

```python
import pika
import time

def auto_ack_consumer():
    """è‡ªåŠ¨ç¡®è®¤æ¨¡å¼æ¶ˆè´¹è€…"""
    connection = pika.BlockingConnection(
        pika.ConnectionParameters('localhost')
    )
    channel = connection.channel()
    
    # å£°æ˜é˜Ÿåˆ—
    channel.queue_declare(queue='auto_ack_queue')
    
    def callback(ch, method, properties, body):
        """æ¶ˆæ¯å¤„ç†å›è°ƒ"""
        print(f"æ”¶åˆ°æ¶ˆæ¯: {body.decode()}")
        
        # æ¨¡æ‹Ÿæ¶ˆæ¯å¤„ç†æ—¶é—´
        time.sleep(2)
        
        # æ³¨æ„ï¼šauto_ack=Trueæ—¶ï¼Œè¿™é‡Œä¸éœ€è¦æ‰‹åŠ¨ç¡®è®¤
        print("æ¶ˆæ¯å¤„ç†å®Œæˆ")
    
    # æ¶ˆè´¹æ¶ˆæ¯ï¼ˆè‡ªåŠ¨ç¡®è®¤ï¼‰
    channel.basic_consume(
        queue='auto_ack_queue',
        on_message_callback=callback,
        auto_ack=True
    )
    
    print("å¼€å§‹æ¶ˆè´¹æ¶ˆæ¯ï¼ˆè‡ªåŠ¨ç¡®è®¤æ¨¡å¼ï¼‰")
    channel.start_consuming()

def auto_ack_producer():
    """è‡ªåŠ¨ç¡®è®¤æ¨¡å¼ç”Ÿäº§è€…"""
    connection = pika.BlockingConnection(
        pika.ConnectionParameters('localhost')
    )
    channel = connection.channel()
    
    # å£°æ˜é˜Ÿåˆ—
    channel.queue_declare(queue='auto_ack_queue')
    
    for i in range(5):
        message = f"æ¶ˆæ¯ {i+1} - {time.strftime('%H:%M:%S')}"
        
        # å‘é€æ¶ˆæ¯
        channel.basic_publish(
            exchange='',
            routing_key='auto_ack_queue',
            body=message
        )
        
        print(f"å‘é€æ¶ˆæ¯: {message}")
        time.sleep(1)
    
    connection.close()

if __name__ == "__main__":
    # è¿è¡Œç”Ÿäº§è€…
    auto_ack_producer()
    
    print("\n" + "="*50)
    
    # è¿è¡Œæ¶ˆè´¹è€…
    auto_ack_consumer()
```

### 2.3 è‡ªåŠ¨ç¡®è®¤ç‰¹ç‚¹

**ä¼˜ç‚¹ï¼š**
- âœ… ç®€å•æ˜“ç”¨
- âœ… é«˜æ€§èƒ½ï¼Œæ— ç¡®è®¤å¼€é”€
- âœ… é€‚åˆéå…³é”®æ¶ˆæ¯

**ç¼ºç‚¹ï¼š**
- âŒ æ¶ˆæ¯å¯èƒ½ä¸¢å¤±ï¼ˆæ¶ˆè´¹è€…å´©æºƒï¼‰
- âŒ æ— æ³•ç¡®ä¿æ¶ˆæ¯è¢«æ­£ç¡®å¤„ç†
- âŒ ä¸é€‚åˆå…³é”®ä¸šåŠ¡åœºæ™¯

**é€‚ç”¨åœºæ™¯ï¼š**
- æ—¥å¿—è®°å½•
- å®æ—¶æ•°æ®æ¨é€
- ä¸é‡è¦çš„é€šçŸ¥æ¶ˆæ¯
- æ€§èƒ½è¦æ±‚æé«˜çš„åœºæ™¯

## 3. æ‰‹åŠ¨ç¡®è®¤æ¨¡å¼

### 3.1 æ‰‹åŠ¨ç¡®è®¤åŸç†

```python
# æ‰‹åŠ¨ç¡®è®¤é…ç½®
channel.basic_consume(
    queue='hello',
    on_message_callback=callback_function,
    auto_ack=False  # æ‰‹åŠ¨ç¡®è®¤
)
```

**ç¡®è®¤æ–¹æ³•ï¼š**
- `basic_ack`ï¼šç¡®è®¤æ¶ˆæ¯å¤„ç†æˆåŠŸ
- `basic_nack`ï¼šæ‹’ç»æ¶ˆæ¯
- `basic_reject`ï¼šæ‹’ç»å•æ¡æ¶ˆæ¯

### 3.2 åŸºæœ¬æ‰‹åŠ¨ç¡®è®¤

```python
def manual_ack_consumer():
    """æ‰‹åŠ¨ç¡®è®¤æ¨¡å¼æ¶ˆè´¹è€…"""
    connection = pika.BlockingConnection(
        pika.ConnectionParameters('localhost')
    )
    channel = connection.channel()
    
    # å£°æ˜é˜Ÿåˆ—
    channel.queue_declare(queue='manual_ack_queue')
    
    # ç¡®ä¿å…¬å¹³è°ƒåº¦
    channel.basic_qos(prefetch_count=1)
    
    def callback(ch, method, properties, body):
        """æ‰‹åŠ¨ç¡®è®¤æ¶ˆæ¯å¤„ç†å›è°ƒ"""
        try:
            message = body.decode()
            print(f"æ”¶åˆ°æ¶ˆæ¯: {message}")
            
            # æ¨¡æ‹Ÿæ¶ˆæ¯å¤„ç†
            time.sleep(2)
            
            # æ‰‹åŠ¨ç¡®è®¤æ¶ˆæ¯
            ch.basic_ack(delivery_tag=method.delivery_tag)
            print("æ¶ˆæ¯å¤„ç†æˆåŠŸï¼Œå·²ç¡®è®¤")
            
        except Exception as e:
            print(f"å¤„ç†æ¶ˆæ¯å¤±è´¥: {e}")
            
            # æ‹’ç»æ¶ˆæ¯ï¼Œå¯ä»¥é€‰æ‹©æ˜¯å¦é‡æ–°å…¥é˜Ÿ
            ch.basic_nack(
                delivery_tag=method.delivery_tag,
                requeue=True  # é‡æ–°å…¥é˜Ÿ
            )
    
    # æ¶ˆè´¹æ¶ˆæ¯ï¼ˆæ‰‹åŠ¨ç¡®è®¤ï¼‰
    channel.basic_consume(
        queue='manual_ack_queue',
        on_message_callback=callback,
        auto_ack=False
    )
    
    print("å¼€å§‹æ¶ˆè´¹æ¶ˆæ¯ï¼ˆæ‰‹åŠ¨ç¡®è®¤æ¨¡å¼ï¼‰")
    try:
        channel.start_consuming()
    except KeyboardInterrupt:
        channel.stop_consuming()
    finally:
        connection.close()

def manual_ack_producer():
    """æ‰‹åŠ¨ç¡®è®¤æ¨¡å¼ç”Ÿäº§è€…"""
    connection = pika.BlockingConnection(
        pika.ConnectionParameters('localhost')
    )
    channel = connection.channel()
    
    # å£°æ˜é˜Ÿåˆ—
    channel.queue_declare(queue='manual_ack_queue')
    
    # å¯ç”¨å‘å¸ƒç¡®è®¤
    channel.confirm_delivery()
    
    for i in range(5):
        message = f"æ‰‹åŠ¨ç¡®è®¤æ¶ˆæ¯ {i+1} - {time.strftime('%H:%M:%S')}"
        
        try:
            # å‘é€æ¶ˆæ¯å¹¶ç­‰å¾…ç¡®è®¤
            channel.basic_publish(
                exchange='',
                routing_key='manual_ack_queue',
                body=message
            )
            print(f"å‘é€æ¶ˆæ¯: {message}")
            
        except Exception as e:
            print(f"å‘é€æ¶ˆæ¯å¤±è´¥: {e}")
        
        time.sleep(1)
    
    connection.close()

if __name__ == "__main__":
    # å¯åŠ¨ç”Ÿäº§è€…
    manual_ack_producer()
    
    print("\n" + "="*50)
    
    # å¯åŠ¨æ¶ˆè´¹è€…
    manual_ack_consumer()
```

### 3.3 æ‰¹é‡ç¡®è®¤

```python
def batch_ack_consumer():
    """æ‰¹é‡ç¡®è®¤æ¶ˆè´¹è€…"""
    connection = pika.BlockingConnection(
        pika.ConnectionParameters('localhost')
    )
    channel = connection.channel()
    
    channel.queue_declare(queue='batch_ack_queue')
    channel.basic_qos(prefetch_count=10)  # é¢„å–10æ¡æ¶ˆæ¯
    
    processed_count = 0
    
    def callback(ch, method, properties, body):
        nonlocal processed_count
        message = body.decode()
        print(f"å¤„ç†æ¶ˆæ¯: {message}")
        
        try:
            # æ¨¡æ‹Ÿæ¶ˆæ¯å¤„ç†
            time.sleep(1)
            processed_count += 1
            
            # æ¯å¤„ç†5æ¡æ¶ˆæ¯æ‰¹é‡ç¡®è®¤ä¸€æ¬¡
            if processed_count % 5 == 0:
                ch.basic_ack(delivery_tag=method.delivery_tag, multiple=True)
                print(f"æ‰¹é‡ç¡®è®¤ {processed_count} æ¡æ¶ˆæ¯")
            
        except Exception as e:
            print(f"å¤„ç†æ¶ˆæ¯å¤±è´¥: {e}")
            # å•æ¡æ¶ˆæ¯ç¡®è®¤å¤±è´¥
            ch.basic_nack(delivery_tag=method.delivery_tag, requeue=False)
    
    channel.basic_consume(
        queue='batch_ack_queue',
        on_message_callback=callback,
        auto_ack=False
    )
    
    try:
        channel.start_consuming()
    except KeyboardInterrupt:
        channel.stop_consuming()
    finally:
        connection.close()
```

### 3.4 æ¶ˆæ¯æ‹’ç»

```python
def reject_message_consumer():
    """æ¶ˆæ¯æ‹’ç»æ¼”ç¤º"""
    connection = pika.BlockingConnection(
        pika.ConnectionParameters('localhost'))
    channel = connection.channel()
    
    channel.queue_declare(queue='reject_demo_queue')
    
    def callback(ch, method, properties, body):
        message = body.decode()
        print(f"å¤„ç†æ¶ˆæ¯: {message}")
        
        # æ¨¡æ‹Ÿæ¶ˆæ¯å¤„ç†é€»è¾‘
        if message.startswith("REJECT"):
            print("æ‹’ç»å¤„ç†æ­¤æ¶ˆæ¯")
            # æ‹’ç»æ¶ˆæ¯ä¸”ä¸é‡æ–°å…¥é˜Ÿ
            ch.basic_reject(delivery_tag=method.delivery_tag, requeue=False)
            
        elif message.startswith("NACK"):
            print("æ‹’ç»å¹¶é‡æ–°å…¥é˜Ÿ")
            # æ‹’ç»æ¶ˆæ¯å¹¶é‡æ–°å…¥é˜Ÿ
            ch.basic_nack(delivery_tag=method.delivery_tag, requeue=True)
            
        else:
            print("æ­£å¸¸å¤„ç†å¹¶ç¡®è®¤")
            # æ­£å¸¸ç¡®è®¤
            ch.basic_ack(delivery_tag=method.delivery_tag)
    
    channel.basic_consume(
        queue='reject_demo_queue',
        on_message_callback=callback,
        auto_ack=False
    )
    
    try:
        channel.start_consuming()
    except KeyboardInterrupt:
        channel.stop_consuming()
    finally:
        connection.close()
```

## 4. æ¶ˆæ¯æŒä¹…åŒ–ç­–ç•¥

### 4.1 æŒä¹…åŒ–åŸºç¡€

æ¶ˆæ¯æŒä¹…åŒ–ç¡®ä¿åœ¨RabbitMQé‡å¯åæ¶ˆæ¯ä¸ä¼šä¸¢å¤±ï¼š

```python
# é˜Ÿåˆ—æŒä¹…åŒ–
channel.queue_declare(
    queue='durable_queue',
    durable=True  # é˜Ÿåˆ—æŒä¹…åŒ–
)

# æ¶ˆæ¯æŒä¹…åŒ–
channel.basic_publish(
    exchange='',
    routing_key='durable_queue',
    body=message,
    properties=pika.BasicProperties(
        delivery_mode=2,  # æ¶ˆæ¯æŒä¹…åŒ–
    )
)
```

### 4.2 å®Œæ•´æŒä¹…åŒ–ç¤ºä¾‹

```python
import json
import os

class PersistentMessageProducer:
    """æŒä¹…åŒ–æ¶ˆæ¯ç”Ÿäº§è€…"""
    
    def __init__(self, host='localhost', port=5672):
        self.host = host
        self.port = port
        self.connection = None
        self.channel = None
    
    def connect(self):
        """å»ºç«‹è¿æ¥"""
        self.connection = pika.BlockingConnection(
            pika.ConnectionParameters(
                host=self.host,
                port=self.port,
                heartbeat=30
            )
        )
        self.channel = self.connection.channel()
        
        # å¼€å¯å‘å¸ƒç¡®è®¤
        self.channel.confirm_delivery()
        
        return True
    
    def create_durable_queue(self, queue_name):
        """åˆ›å»ºæŒä¹…åŒ–é˜Ÿåˆ—"""
        try:
            self.channel.queue_declare(
                queue=queue_name,
                durable=True,  # é˜Ÿåˆ—æŒä¹…åŒ–
                arguments={
                    'x-message-ttl': 3600000,  # æ¶ˆæ¯è¿‡æœŸæ—¶é—´1å°æ—¶
                    'x-max-priority': 10,      # æœ€å¤§ä¼˜å…ˆçº§
                    'x-dead-letter-exchange': 'dead_letter_exchange',
                    'x-dead-letter-routing-key': 'dead_letter_queue'
                }
            )
            print(f"âœ… åˆ›å»ºæŒä¹…åŒ–é˜Ÿåˆ—: {queue_name}")
            return True
            
        except Exception as e:
            print(f"âŒ åˆ›å»ºé˜Ÿåˆ—å¤±è´¥: {e}")
            return False
    
    def publish_persistent_message(self, queue_name, message, properties=None):
        """å‘å¸ƒæŒä¹…åŒ–æ¶ˆæ¯"""
        try:
            # é»˜è®¤æ¶ˆæ¯å±æ€§
            default_properties = pika.BasicProperties(
                delivery_mode=2,  # æ¶ˆæ¯æŒä¹…åŒ–
                message_id=str(uuid.uuid4()),
                timestamp=time.time(),
                content_type='application/json',
                content_encoding='utf-8'
            )
            
            # åˆå¹¶å±æ€§
            if properties:
                default_properties = properties
            
            # å‘é€æ¶ˆæ¯
            self.channel.basic_publish(
                exchange='',
                routing_key=queue_name,
                body=json.dumps(message, ensure_ascii=False),
                properties=default_properties
            )
            
            print(f"âœ… å‘é€æŒä¹…åŒ–æ¶ˆæ¯: {message}")
            return True
            
        except Exception as e:
            print(f"âŒ å‘é€æ¶ˆæ¯å¤±è´¥: {e}")
            return False
    
    def close(self):
        """å…³é—­è¿æ¥"""
        if self.connection:
            self.connection.close()

class PersistentMessageConsumer:
    """æŒä¹…åŒ–æ¶ˆæ¯æ¶ˆè´¹è€…"""
    
    def __init__(self, host='localhost', port=5672):
        self.host = host
        self.port = port
        self.connection = None
        self.channel = None
    
    def connect(self):
        """å»ºç«‹è¿æ¥"""
        self.connection = pika.BlockingConnection(
            pika.ConnectionParameters(
                host=self.host,
                port=self.port,
                heartbeat=30
            )
        )
        self.channel = self.connection.channel()
        
        return True
    
    def consume_persistent_messages(self, queue_name):
        """æ¶ˆè´¹æŒä¹…åŒ–æ¶ˆæ¯"""
        try:
            # ç¡®ä¿é˜Ÿåˆ—å­˜åœ¨ï¼ˆæŒä¹…åŒ–ï¼‰
            self.channel.queue_declare(queue=queue_name, durable=True)
            
            # è®¾ç½®å…¬å¹³è°ƒåº¦
            self.channel.basic_qos(prefetch_count=1)
            
            def callback(ch, method, properties, body):
                try:
                    message = json.loads(body.decode())
                    print(f"ğŸ“¥ æ”¶åˆ°æŒä¹…åŒ–æ¶ˆæ¯: {message}")
                    
                    # å¤„ç†æ¶ˆæ¯
                    self.process_message(message)
                    
                    # æ‰‹åŠ¨ç¡®è®¤
                    ch.basic_ack(delivery_tag=method.delivery_tag)
                    print("âœ… æ¶ˆæ¯å¤„ç†å®Œæˆï¼Œå·²ç¡®è®¤")
                    
                except Exception as e:
                    print(f"âŒ å¤„ç†æ¶ˆæ¯å¤±è´¥: {e}")
                    # æ‹’ç»æ¶ˆæ¯ä½†ä¸é‡æ–°å…¥é˜Ÿï¼ˆé¿å…æ— é™å¾ªç¯ï¼‰
                    ch.basic_nack(
                        delivery_tag=method.delivery_tag,
                        requeue=False
                    )
            
            # å¼€å§‹æ¶ˆè´¹
            self.channel.basic_consume(
                queue=queue_name,
                on_message_callback=callback,
                auto_ack=False
            )
            
            print(f"ğŸ“¥ å¼€å§‹æ¶ˆè´¹æŒä¹…åŒ–æ¶ˆæ¯: {queue_name}")
            
            try:
                self.channel.start_consuming()
            except KeyboardInterrupt:
                self.channel.stop_consuming()
                
        except Exception as e:
            print(f"âŒ æ¶ˆè´¹æ¶ˆæ¯å¤±è´¥: {e}")
    
    def process_message(self, message):
        """å¤„ç†æ¶ˆæ¯"""
        # æ¨¡æ‹Ÿæ¶ˆæ¯å¤„ç†
        time.sleep(1)
        
        # å¯ä»¥æ·»åŠ å®é™…çš„ä¸šåŠ¡é€»è¾‘
        print(f"ğŸ”„ å¤„ç†æ¶ˆæ¯å†…å®¹: {message}")
    
    def close(self):
        """å…³é—­è¿æ¥"""
        if self.connection:
            self.connection.close()

if __name__ == "__main__":
    import uuid
    
    # åˆ›å»ºç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…
    producer = PersistentMessageProducer()
    consumer = PersistentMessageConsumer()
    
    # å»ºç«‹è¿æ¥
    producer.connect()
    consumer.connect()
    
    # åˆ›å»ºæŒä¹…åŒ–é˜Ÿåˆ—
    queue_name = "persistent_order_queue"
    producer.create_durable_queue(queue_name)
    
    # å‘é€æŒä¹…åŒ–æ¶ˆæ¯
    test_messages = [
        {
            'order_id': 'ORD-001',
            'customer': 'å¼ ä¸‰',
            'amount': 299.99,
            'status': 'pending'
        },
        {
            'order_id': 'ORD-002', 
            'customer': 'æå››',
            'amount': 499.99,
            'status': 'pending'
        }
    ]
    
    print("\nğŸ“¤ å‘é€æŒä¹…åŒ–è®¢å•æ¶ˆæ¯:")
    for message in test_messages:
        producer.publish_persistent_message(queue_name, message)
        time.sleep(1)
    
    producer.close()
    
    print("\n" + "="*50)
    print("ğŸ“¥ å¯åŠ¨æ¶ˆè´¹è€…ï¼ˆæ¨¡æ‹Ÿæ¶ˆè´¹æŒä¹…åŒ–æ¶ˆæ¯ï¼‰:")
    print("æ³¨æ„ï¼šå®é™…ä½¿ç”¨æ—¶æ¶ˆè´¹è€…ä¼šç­‰å¾…æ¶ˆæ¯")
    consumer.consume_persistent_messages(queue_name)
    
    consumer.close()
```

### 4.3 æ¶ˆæ¯å±æ€§è¯¦è§£

```python
def demonstrate_message_properties():
    """æ¼”ç¤ºæ¶ˆæ¯å±æ€§"""
    
    # å„ç§æ¶ˆæ¯å±æ€§
    properties = pika.BasicProperties(
        content_type='application/json',        # å†…å®¹ç±»å‹
        content_encoding='utf-8',               # å†…å®¹ç¼–ç 
        correlation_id=str(uuid.uuid4()),       # å…³è”IDï¼ˆç”¨äºRPCï¼‰
        reply_to='reply_queue',                 # å›å¤é˜Ÿåˆ—ï¼ˆç”¨äºRPCï¼‰
        message_id=str(uuid.uuid4()),           # æ¶ˆæ¯ID
        timestamp=time.time(),                  # æ—¶é—´æˆ³
        expiration='3600000',                   # æ¶ˆæ¯è¿‡æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
        type='order_created',                   # æ¶ˆæ¯ç±»å‹
        user_id='system',                       # ç”¨æˆ·ID
        app_id='order_service',                 # åº”ç”¨ID
        delivery_mode=2,                        # æŒä¹…åŒ–æ¨¡å¼
        priority=5,                             # ä¼˜å…ˆçº§
        headers={
            'retry_count': 0,
            'source_system': 'order_management',
            'business_type': 'ecommerce'
        }                                       # è‡ªå®šä¹‰å¤´éƒ¨
    )
    
    return properties
```

### 4.4 æ­»ä¿¡é˜Ÿåˆ—

```python
def setup_dead_letter_queue():
    """è®¾ç½®æ­»ä¿¡é˜Ÿåˆ—"""
    
    # 1. åˆ›å»ºæ­»ä¿¡äº¤æ¢æœº
    channel.exchange_declare(
        exchange='dead_letter_exchange',
        exchange_type='topic',
        durable=True
    )
    
    # 2. åˆ›å»ºæ­»ä¿¡é˜Ÿåˆ—
    channel.queue_declare(
        queue='dead_letter_queue',
        durable=True
    )
    
    # 3. ç»‘å®šæ­»ä¿¡é˜Ÿåˆ—
    channel.queue_bind(
        exchange='dead_letter_exchange',
        queue='dead_letter_queue',
        routing_key='dead_letter.*'
    )
    
    # 4. åˆ›å»ºæ­£å¸¸é˜Ÿåˆ—å¹¶é…ç½®æ­»ä¿¡
    channel.queue_declare(
        queue='main_queue',
        durable=True,
        arguments={
            'x-dead-letter-exchange': 'dead_letter_exchange',
            'x-dead-letter-routing-key': 'dead_letter.message',
            'x-message-ttl': 300000,  # 5åˆ†é’Ÿè¿‡æœŸ
            'x-max-length': 1000      # æœ€å¤§é•¿åº¦
        }
    )
    
    print("âœ… æ­»ä¿¡é˜Ÿåˆ—è®¾ç½®å®Œæˆ")
```

## 5. äº‹åŠ¡å¤„ç†æœºåˆ¶

### 5.1 äº‹åŠ¡åŸºç¡€

RabbitMQçš„äº‹åŠ¡æœºåˆ¶ç¡®ä¿æ¶ˆæ¯çš„åŸå­æ€§ï¼š

```python
# äº‹åŠ¡æ¨¡å¼
channel.tx_select()     # å¼€å§‹äº‹åŠ¡
# å‘é€æ¶ˆæ¯
channel.tx_commit()     # æäº¤äº‹åŠ¡
# æˆ–
channel.tx_rollback()   # å›æ»šäº‹åŠ¡
```

### 5.2 äº‹åŠ¡ç¤ºä¾‹

```python
def transaction_producer():
    """äº‹åŠ¡æ¨¡å¼ç”Ÿäº§è€…"""
    
    try:
        connection = pika.BlockingConnection(
            pika.ConnectionParameters('localhost')
        )
        channel = connection.channel()
        
        # å£°æ˜é˜Ÿåˆ—
        channel.queue_declare(queue='transaction_queue', durable=True)
        
        # å¼€å§‹äº‹åŠ¡
        channel.tx_select()
        
        try:
            # å‘é€å¤šæ¡æ¶ˆæ¯
            for i in range(5):
                message = f"äº‹åŠ¡æ¶ˆæ¯ {i+1}"
                channel.basic_publish(
                    exchange='',
                    routing_key='transaction_queue',
                    body=message
                )
                print(f"ğŸ“¤ å‘é€: {message}")
                
                # æ¨¡æ‹Ÿå¤±è´¥æƒ…å†µ
                if i == 2:
                    raise Exception("æ¨¡æ‹Ÿäº‹åŠ¡å¤±è´¥")
            
            # æäº¤äº‹åŠ¡
            channel.tx_commit()
            print("âœ… äº‹åŠ¡æäº¤æˆåŠŸ")
            
        except Exception as e:
            # å›æ»šäº‹åŠ¡
            channel.tx_rollback()
            print(f"âŒ äº‹åŠ¡å›æ»š: {e}")
            
    except Exception as e:
        print(f"âŒ äº‹åŠ¡æ“ä½œå¤±è´¥: {e}")
    finally:
        connection.close()

def transaction_consumer():
    """äº‹åŠ¡æ¨¡å¼æ¶ˆè´¹è€…"""
    
    connection = pika.BlockingConnection(
        pika.ConnectionParameters('localhost')
    )
    channel = connection.channel()
    
    # å£°æ˜é˜Ÿåˆ—
    channel.queue_declare(queue='transaction_queue', durable=True)
    
    # å…¬å¹³è°ƒåº¦
    channel.basic_qos(prefetch_count=1)
    
    def callback(ch, method, properties, body):
        message = body.decode()
        print(f"ğŸ“¥ å¤„ç†: {message}")
        
        try:
            # æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
            time.sleep(1)
            
            # ç¡®è®¤æ¶ˆæ¯
            ch.basic_ack(delivery_tag=method.delivery_tag)
            print(f"âœ… ç¡®è®¤: {message}")
            
        except Exception as e:
            print(f"âŒ å¤„ç†å¤±è´¥: {e}")
            # æ‹’ç»æ¶ˆæ¯
            ch.basic_nack(delivery_tag=method.delivery_tag, requeue=True)
    
    channel.basic_consume(
        queue='transaction_queue',
        on_message_callback=callback,
        auto_ack=False
    )
    
    try:
        channel.start_consuming()
    except KeyboardInterrupt:
        channel.stop_consuming()
    finally:
        connection.close()
```

### 5.3 å‘å¸ƒè€…ç¡®è®¤ vs äº‹åŠ¡

```python
def compare_confirmation_methods():
    """å¯¹æ¯”ç¡®è®¤æ–¹æ³•"""
    
    # æ–¹æ³•1ï¼šå‘å¸ƒè€…ç¡®è®¤ï¼ˆæ¨èï¼‰
    def publisher_confirms():
        channel.confirm_delivery()
        
        # å‘é€æ¶ˆæ¯ï¼Œå¤±è´¥ä¼šæŠ›å‡ºå¼‚å¸¸
        channel.basic_publish(
            exchange='',
            routing_key='test_queue',
            body='test message'
        )
        print("âœ… å‘å¸ƒè€…ç¡®è®¤ï¼šæ¶ˆæ¯å‘é€æˆåŠŸ")
    
    # æ–¹æ³•2ï¼šäº‹åŠ¡ï¼ˆæ€§èƒ½è¾ƒå·®ï¼‰
    def transaction_mode():
        channel.tx_select()
        
        channel.basic_publish(
            exchange='',
            routing_key='test_queue',
            body='test message'
        )
        
        channel.tx_commit()
        print("âœ… äº‹åŠ¡æ¨¡å¼ï¼šæ¶ˆæ¯å‘é€æˆåŠŸ")
    
    # æ–¹æ³•3ï¼šæ‰‹åŠ¨ç¡®è®¤ï¼ˆæ¶ˆè´¹è€…ç«¯ï¼‰
    def manual_ack():
        # æ¶ˆè´¹è€…ç«¯æ‰‹åŠ¨ç¡®è®¤
        def callback(ch, method, properties, body):
            print(f"æ”¶åˆ°æ¶ˆæ¯: {body}")
            ch.basic_ack(delivery_tag=method.delivery_tag)
        
        channel.basic_consume(
            queue='test_queue',
            on_message_callback=callback,
            auto_ack=False
        )
    
    print("å‘å¸ƒè€…ç¡®è®¤ï¼šé«˜æ€§èƒ½ï¼Œä½å»¶è¿Ÿ")
    print("äº‹åŠ¡æ¨¡å¼ï¼šä¿è¯ä¸€è‡´æ€§ï¼Œæ€§èƒ½è¾ƒä½")
    print("æ‰‹åŠ¨ç¡®è®¤ï¼šçµæ´»æ§åˆ¶ï¼Œå¤„ç†å¯é ")
```

## 6. æœ€ä½³å®è·µä¸æ€§èƒ½ä¼˜åŒ–

### 6.1 ç¡®è®¤ç­–ç•¥é€‰æ‹©

```python
class MessageReliabilityStrategy:
    """æ¶ˆæ¯å¯é æ€§ç­–ç•¥"""
    
    def __init__(self, scenario):
        self.scenario = scenario
        self.strategies = {
            'high_throughput': self.high_throughput_strategy,
            'critical_data': self.critical_data_strategy,
            'balanced': self.balanced_strategy,
            'development': self.development_strategy
        }
    
    def high_throughput_strategy(self):
        """é«˜ååé‡ç­–ç•¥"""
        return {
            'auto_ack': True,
            'prefetch_count': 100,
            'message_persistence': False,
            'confirmation': False
        }
    
    def critical_data_strategy(self):
        """å…³é”®æ•°æ®ç­–ç•¥"""
        return {
            'auto_ack': False,
            'prefetch_count': 1,
            'message_persistence': True,
            'confirmation': True,
            'dead_letter': True
        }
    
    def balanced_strategy(self):
        """å¹³è¡¡ç­–ç•¥"""
        return {
            'auto_ack': False,
            'prefetch_count': 10,
            'message_persistence': True,
            'confirmation': True
        }
    
    def development_strategy(self):
        """å¼€å‘ç¯å¢ƒç­–ç•¥"""
        return {
            'auto_ack': True,
            'prefetch_count': 5,
            'message_persistence': False,
            'confirmation': False
        }
    
    def get_strategy(self):
        return self.strategies.get(self.scenario, self.balanced_strategy())
```

### 6.2 æ€§èƒ½ä¼˜åŒ–æŠ€å·§

```python
class PerformanceOptimizer:
    """æ€§èƒ½ä¼˜åŒ–å™¨"""
    
    @staticmethod
    def optimize_producer():
        """ç”Ÿäº§è€…æ€§èƒ½ä¼˜åŒ–"""
        return {
            # è¿æ¥æ± å¤ç”¨
            'connection_pool': True,
            
            # æ‰¹é‡å‘é€
            'batch_size': 100,
            'batch_timeout': 1.0,
            
            # å‘å¸ƒç¡®è®¤ä¼˜åŒ–
            'confirmation_mode': 'async',  # å¼‚æ­¥ç¡®è®¤
            
            # æ¶ˆæ¯æŒä¹…åŒ–
            'persistent': False,  # é«˜æ€§èƒ½åœºæ™¯
            
            # é¢„å¤„ç†æ•°é‡
            'prefetch_count': 0
        }
    
    @staticmethod
    def optimize_consumer():
        """æ¶ˆè´¹è€…æ€§èƒ½ä¼˜åŒ–"""
        return {
            # é¢„å–æ¶ˆæ¯æ•°é‡
            'prefetch_count': 10,
            
            # è‡ªåŠ¨ç¡®è®¤
            'auto_ack': False,
            
            # è¿æ¥æ± 
            'connection_pool': True,
            
            # å¹¶å‘å¤„ç†
            'worker_count': 5,
            
            # é˜Ÿåˆ—é¢„å–
            'channel_qos': 10
        }
    
    @staticmethod
    def batch_processing():
        """æ‰¹é‡å¤„ç†ä¼˜åŒ–"""
        def callback_batch(channel, method, properties, body_list):
            """æ‰¹é‡å¤„ç†å›è°ƒ"""
            
            # æ‰¹é‡å¤„ç†é€»è¾‘
            processed_messages = []
            
            for body in body_list:
                try:
                    message = json.loads(body.decode())
                    processed_messages.append(message)
                except Exception as e:
                    print(f"å¤„ç†æ¶ˆæ¯å¤±è´¥: {e}")
            
            # æ‰¹é‡ç¡®è®¤
            if processed_messages:
                channel.basic_ack(
                    delivery_tag=method.delivery_tag,
                    multiple=True
                )
        
        return callback_batch
```

### 6.3 ç›‘æ§å’ŒæŒ‡æ ‡

```python
import threading
import time
from datetime import datetime

class MessageMetrics:
    """æ¶ˆæ¯æŒ‡æ ‡ç›‘æ§"""
    
    def __init__(self):
        self.metrics = {
            'sent': 0,
            'confirmed': 0,
            'rejected': 0,
            'failed': 0,
            'processing_time': [],
            'queue_depth': {}
        }
        self.lock = threading.Lock()
    
    def increment_counter(self, metric_name, value=1):
        """å¢åŠ è®¡æ•°å™¨"""
        with self.lock:
            if metric_name in self.metrics:
                self.metrics[metric_name] += value
    
    def add_processing_time(self, duration):
        """è®°å½•å¤„ç†æ—¶é—´"""
        with self.lock:
            self.metrics['processing_time'].append(duration)
            # ä¿æŒæœ€è¿‘1000æ¬¡è®°å½•
            if len(self.metrics['processing_time']) > 1000:
                self.metrics['processing_time'] = self.metrics['processing_time'][-1000:]
    
    def update_queue_depth(self, queue_name, depth):
        """æ›´æ–°é˜Ÿåˆ—æ·±åº¦"""
        with self.lock:
            self.metrics['queue_depth'][queue_name] = depth
    
    def get_summary(self):
        """è·å–æ‘˜è¦"""
        with self.lock:
            avg_processing_time = (
                sum(self.metrics['processing_time']) / 
                len(self.metrics['processing_time'])
                if self.metrics['processing_time'] else 0
            )
            
            return {
                'sent_messages': self.metrics['sent'],
                'confirmed_messages': self.metrics['confirmed'],
                'rejected_messages': self.metrics['rejected'],
                'failed_messages': self.metrics['failed'],
                'success_rate': (
                    self.metrics['confirmed'] / self.metrics['sent'] * 100
                    if self.metrics['sent'] > 0 else 0
                ),
                'average_processing_time': avg_processing_time,
                'queue_depths': dict(self.metrics['queue_depth']),
                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
    
    def print_report(self):
        """æ‰“å°æŠ¥å‘Š"""
        summary = self.get_summary()
        
        print(f"\nğŸ“Š æ¶ˆæ¯å¤„ç†æŠ¥å‘Š ({summary['timestamp']})")
        print("=" * 50)
        print(f"ğŸ“¤ å‘é€æ¶ˆæ¯: {summary['sent_messages']}")
        print(f"âœ… ç¡®è®¤æ¶ˆæ¯: {summary['confirmed_messages']}")
        print(f"âŒ æ‹’ç»æ¶ˆæ¯: {summary['rejected_messages']}")
        print(f"ğŸ”¥ å¤±è´¥æ¶ˆæ¯: {summary['failed_messages']}")
        print(f"ğŸ“ˆ æˆåŠŸç‡: {summary['success_rate']:.2f}%")
        print(f"â±ï¸ å¹³å‡å¤„ç†æ—¶é—´: {summary['average_processing_time']:.3f}s")
        
        print(f"\nğŸ“‹ é˜Ÿåˆ—æ·±åº¦:")
        for queue, depth in summary['queue_depths'].items():
            print(f"   {queue}: {depth}")

def monitoring_demo():
    """ç›‘æ§æ¼”ç¤º"""
    metrics = MessageMetrics()
    
    # æ¨¡æ‹Ÿæ¶ˆæ¯å¤„ç†
    for i in range(20):
        start_time = time.time()
        
        # æ¨¡æ‹Ÿæ¶ˆæ¯å¤„ç†
        if i % 5 == 0:  # æ¨¡æ‹Ÿå¤±è´¥
            metrics.increment_counter('sent')
            metrics.increment_counter('failed')
        else:
            metrics.increment_counter('sent')
            time.sleep(0.1)  # æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
            processing_time = time.time() - start_time
            
            metrics.add_processing_time(processing_time)
            metrics.increment_counter('confirmed')
        
        # æ›´æ–°é˜Ÿåˆ—æ·±åº¦
        metrics.update_queue_depth('test_queue', i % 10)
        
        if (i + 1) % 10 == 0:
            metrics.print_report()
    
    print("\nğŸ¯ ç›‘æ§æ¼”ç¤ºå®Œæˆ")
```

## 7. å®é™…åº”ç”¨åœºæ™¯

### 7.1 ç”µå•†è®¢å•å¤„ç†

```python
class EcommerceOrderProcessor:
    """ç”µå•†è®¢å•å¤„ç†å™¨"""
    
    def __init__(self):
        self.connection = None
        self.channel = None
        self.metrics = MessageMetrics()
    
    def setup_order_queues(self):
        """è®¾ç½®è®¢å•å¤„ç†é˜Ÿåˆ—"""
        
        # åˆ›å»ºäº¤æ¢æœº
        self.channel.exchange_declare(
            exchange='order_exchange',
            exchange_type='topic',
            durable=True
        )
        
        # è®¢å•å¤„ç†é˜Ÿåˆ—
        queues = [
            ('order.pending', 'order.pending'),
            ('order.processing', 'order.processing'),
            ('order.completed', 'order.completed'),
            ('order.failed', 'order.failed'),
            ('order.payment', 'order.payment'),
            ('order.shipping', 'order.shipping')
        ]
        
        for queue_name, routing_key in queues:
            self.channel.queue_declare(queue=queue_name, durable=True)
            
            self.channel.queue_bind(
                exchange='order_exchange',
                queue=queue_name,
                routing_key=routing_key
            )
        
        print("âœ… è®¢å•å¤„ç†é˜Ÿåˆ—è®¾ç½®å®Œæˆ")
    
    def process_order_payment(self, order_data):
        """å¤„ç†è®¢å•æ”¯ä»˜"""
        
        try:
            # æ¶ˆæ¯å±æ€§
            properties = pika.BasicProperties(
                delivery_mode=2,  # æŒä¹…åŒ–
                message_id=order_data['order_id'],
                correlation_id=order_data.get('correlation_id'),
                reply_to='order.response.queue',
                headers={
                    'order_type': order_data.get('type', 'normal'),
                    'customer_tier': order_data.get('customer_tier', 'regular'),
                    'payment_method': order_data.get('payment_method', 'credit_card')
                }
            )
            
            # å‘é€åˆ°æ”¯ä»˜å¤„ç†é˜Ÿåˆ—
            self.channel.basic_publish(
                exchange='order_exchange',
                routing_key='order.pending',
                body=json.dumps(order_data),
                properties=properties
            )
            
            self.metrics.increment_counter('sent')
            print(f"âœ… è®¢å• {order_data['order_id']} å·²å‘é€åˆ°å¤„ç†é˜Ÿåˆ—")
            
            return True
            
        except Exception as e:
            self.metrics.increment_counter('failed')
            print(f"âŒ è®¢å•å¤„ç†å¤±è´¥: {e}")
            return False
    
    def consume_order_updates(self):
        """æ¶ˆè´¹è®¢å•çŠ¶æ€æ›´æ–°"""
        
        def callback(ch, method, properties, body):
            try:
                order_data = json.loads(body.decode())
                order_id = order_data['order_id']
                
                print(f"ğŸ“¥ å¤„ç†è®¢å•çŠ¶æ€æ›´æ–°: {order_id}")
                
                # è®°å½•å¤„ç†æ—¶é—´
                start_time = time.time()
                
                # å¤„ç†è®¢å•é€»è¾‘
                self.update_order_status(order_data)
                
                # ç¡®è®¤æ¶ˆæ¯
                ch.basic_ack(delivery_tag=method.delivery_tag)
                
                # æ›´æ–°æŒ‡æ ‡
                processing_time = time.time() - start_time
                self.metrics.add_processing_time(processing_time)
                self.metrics.increment_counter('confirmed')
                
                print(f"âœ… è®¢å• {order_id} å¤„ç†å®Œæˆ")
                
            except Exception as e:
                print(f"âŒ å¤„ç†è®¢å•å¤±è´¥: {e}")
                self.metrics.increment_counter('failed')
                
                # æ‹’ç»æ¶ˆæ¯ï¼Œé‡æ–°å…¥é˜Ÿ
                ch.basic_nack(
                    delivery_tag=method.delivery_tag,
                    requeue=True
                )
        
        # æ¶ˆè´¹çŠ¶æ€æ›´æ–°æ¶ˆæ¯
        self.channel.basic_consume(
            queue='order.processing',
            on_message_callback=callback,
            auto_ack=False
        )
        
        print("ğŸ“¥ å¼€å§‹ç›‘å¬è®¢å•çŠ¶æ€æ›´æ–°")
        self.channel.start_consuming()
    
    def update_order_status(self, order_data):
        """æ›´æ–°è®¢å•çŠ¶æ€"""
        # æ¨¡æ‹Ÿè®¢å•çŠ¶æ€æ›´æ–°
        status = order_data.get('status', 'processing')
        
        if status == 'payment_confirmed':
            self.send_to_shipping(order_data)
        elif status == 'shipped':
            self.notify_customer(order_data)
        elif status == 'delivered':
            self.complete_order(order_data)
    
    def send_to_shipping(self, order_data):
        """å‘é€åˆ°ç‰©æµ"""
        print(f"ğŸ“¦ è®¢å• {order_data['order_id']} å‘é€åˆ°ç‰©æµ")
    
    def notify_customer(self, order_data):
        """é€šçŸ¥å®¢æˆ·"""
        print(f"ğŸ“§ é€šçŸ¥å®¢æˆ·è®¢å• {order_data['order_id']} å·²å‘è´§")
    
    def complete_order(self, order_data):
        """å®Œæˆè®¢å•"""
        print(f"ğŸ‰ è®¢å• {order_data['order_id']} å·²å®Œæˆ")

if __name__ == "__main__":
    # ç”µå•†è®¢å•å¤„ç†æ¼”ç¤º
    processor = EcommerceOrderProcessor()
    
    # è¿æ¥RabbitMQ
    processor.connection = pika.BlockingConnection(
        pika.ConnectionParameters('localhost')
    )
    processor.channel = processor.connection.channel()
    
    # è®¾ç½®é˜Ÿåˆ—
    processor.setup_order_queues()
    
    # æ¨¡æ‹Ÿè®¢å•å¤„ç†
    test_orders = [
        {
            'order_id': 'ORD-001',
            'customer': 'å¼ ä¸‰',
            'amount': 299.99,
            'type': 'normal',
            'customer_tier': 'gold',
            'payment_method': 'credit_card'
        },
        {
            'order_id': 'ORD-002',
            'customer': 'æå››',
            'amount': 599.99,
            'type': 'premium',
            'customer_tier': 'premium',
            'payment_method': 'paypal'
        }
    ]
    
    print("ğŸ“¤ å‘é€è®¢å•åˆ°å¤„ç†ç³»ç»Ÿ:")
    for order in test_orders:
        processor.process_order_payment(order)
    
    print("\n" + "="*50)
    print("ğŸ“¥ å¯åŠ¨è®¢å•çŠ¶æ€ç›‘å¬:")
    
    # åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œä¼šå¯åŠ¨æ¶ˆè´¹è€…
    # processor.consume_order_updates()
    
    # æ˜¾ç¤ºæŒ‡æ ‡
    processor.metrics.print_report()
    
    # å…³é—­è¿æ¥
    processor.connection.close()
```

### 7.2 é‡‘èäº¤æ˜“å¤„ç†

```python
class FinancialTransactionProcessor:
    """é‡‘èäº¤æ˜“å¤„ç†å™¨"""
    
    def __init__(self):
        self.metrics = MessageMetrics()
        self.transaction_log = []
    
    def setup_transaction_queues(self):
        """è®¾ç½®äº¤æ˜“å¤„ç†é˜Ÿåˆ—"""
        
        # åˆ›å»ºäº¤æ¢æœº
        self.channel.exchange_declare(
            exchange='transaction_exchange',
            exchange_type='topic',
            durable=True
        )
        
        # äº¤æ˜“é˜Ÿåˆ—é…ç½®
        queues = [
            ('transaction.pending', 'transaction.pending', 1),      # é«˜ä¼˜å…ˆçº§
            ('transaction.verification', 'transaction.verification', 1),
            ('transaction.approved', 'transaction.approved', 10),   # ä½ä¼˜å…ˆçº§
            ('transaction.rejected', 'transaction.rejected', 10),
            ('transaction.settlement', 'transaction.settlement', 5)
        ]
        
        for queue_name, routing_key, priority in queues:
            self.channel.queue_declare(
                queue=queue_name,
                durable=True,
                arguments={'x-max-priority': 10}
            )
            
            self.channel.queue_bind(
                exchange='transaction_exchange',
                queue=queue_name,
                routing_key=routing_key
            )
        
        print("âœ… é‡‘èäº¤æ˜“é˜Ÿåˆ—è®¾ç½®å®Œæˆ")
    
    def submit_transaction(self, transaction_data):
        """æäº¤äº¤æ˜“"""
        
        try:
            # äº¤æ˜“æ•°æ®éªŒè¯
            if not self.validate_transaction(transaction_data):
                return False
            
            # è®¾ç½®æ¶ˆæ¯å±æ€§
            properties = pika.BasicProperties(
                delivery_mode=2,  # æŒä¹…åŒ–
                message_id=transaction_data['transaction_id'],
                timestamp=time.time(),
                priority=transaction_data.get('priority', 5),
                headers={
                    'transaction_type': transaction_data.get('type', 'transfer'),
                    'account_tier': transaction_data.get('account_tier', 'standard'),
                    'amount_category': self.get_amount_category(transaction_data['amount'])
                }
            )
            
            # ç¡®å®šè·¯ç”±é”®
            routing_key = self.determine_routing_key(transaction_data)
            
            # å‘é€äº¤æ˜“åˆ°ç›¸åº”é˜Ÿåˆ—
            self.channel.basic_publish(
                exchange='transaction_exchange',
                routing_key=routing_key,
                body=json.dumps(transaction_data),
                properties=properties
            )
            
            self.metrics.increment_counter('sent')
            
            # è®°å½•äº¤æ˜“æ—¥å¿—
            self.transaction_log.append({
                'transaction_id': transaction_data['transaction_id'],
                'status': 'submitted',
                'timestamp': time.time()
            })
            
            print(f"âœ… äº¤æ˜“ {transaction_data['transaction_id']} å·²æäº¤")
            return True
            
        except Exception as e:
            self.metrics.increment_counter('failed')
            print(f"âŒ äº¤æ˜“æäº¤å¤±è´¥: {e}")
            return False
    
    def validate_transaction(self, transaction_data):
        """éªŒè¯äº¤æ˜“æ•°æ®"""
        required_fields = ['transaction_id', 'from_account', 'to_account', 'amount']
        
        for field in required_fields:
            if field not in transaction_data:
                print(f"âŒ ç¼ºå°‘å¿…éœ€å­—æ®µ: {field}")
                return False
        
        if transaction_data['amount'] <= 0:
            print(f"âŒ äº¤æ˜“é‡‘é¢æ— æ•ˆ: {transaction_data['amount']}")
            return False
        
        return True
    
    def get_amount_category(self, amount):
        """è·å–é‡‘é¢ç±»åˆ«"""
        if amount <= 1000:
            return 'small'
        elif amount <= 10000:
            return 'medium'
        else:
            return 'large'
    
    def determine_routing_key(self, transaction_data):
        """ç¡®å®šè·¯ç”±é”®"""
        amount = transaction_data['amount']
        account_tier = transaction_data.get('account_tier', 'standard')
        
        if amount > 100000 or account_tier == 'vip':
            return 'transaction.pending'
        elif amount > 10000:
            return 'transaction.verification'
        else:
            return 'transaction.pending'
    
    def consume_high_priority_transactions(self):
        """æ¶ˆè´¹é«˜ä¼˜å…ˆçº§äº¤æ˜“"""
        
        def callback(ch, method, properties, body):
            try:
                transaction_data = json.loads(body.decode())
                transaction_id = transaction_data['transaction_id']
                
                print(f"ğŸ” å¤„ç†é«˜ä¼˜å…ˆçº§äº¤æ˜“: {transaction_id}")
                
                # å¤„ç†æ—¶é—´è®°å½•
                start_time = time.time()
                
                # é«˜ä¼˜å…ˆçº§äº¤æ˜“å¤„ç†é€»è¾‘
                if self.process_high_priority_transaction(transaction_data):
                    # å‘é€æ‰¹å‡†
                    self.send_approval(transaction_data)
                else:
                    # å‘é€æ‹’ç»
                    self.send_rejection(transaction_data)
                
                # ç¡®è®¤æ¶ˆæ¯
                ch.basic_ack(delivery_tag=method.delivery_tag)
                
                # æ›´æ–°æŒ‡æ ‡
                processing_time = time.time() - start_time
                self.metrics.add_processing_time(processing_time)
                self.metrics.increment_counter('confirmed')
                
                print(f"âœ… é«˜ä¼˜å…ˆçº§äº¤æ˜“ {transaction_id} å¤„ç†å®Œæˆ")
                
            except Exception as e:
                print(f"âŒ å¤„ç†é«˜ä¼˜å…ˆçº§äº¤æ˜“å¤±è´¥: {e}")
                self.metrics.increment_counter('failed')
                
                # æ‹’ç»æ¶ˆæ¯ä½†é‡æ–°å…¥é˜Ÿ
                ch.basic_nack(
                    delivery_tag=method.delivery_tag,
                    requeue=True
                )
        
        # æ¶ˆè´¹é«˜ä¼˜å…ˆçº§äº¤æ˜“
        self.channel.basic_consume(
            queue='transaction.pending',
            on_message_callback=callback,
            auto_ack=False
        )
        
        print("ğŸ“¥ å¼€å§‹å¤„ç†é«˜ä¼˜å…ˆçº§äº¤æ˜“")
    
    def process_high_priority_transaction(self, transaction_data):
        """å¤„ç†é«˜ä¼˜å…ˆçº§äº¤æ˜“"""
        
        # æ¨¡æ‹Ÿäº¤æ˜“éªŒè¯
        time.sleep(0.5)  # æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
        
        # ç®€å•çš„éªŒè¯é€»è¾‘
        if transaction_data['amount'] > 100000:
            return False  # å¤§é¢äº¤æ˜“éœ€è¦æ›´å¤šéªŒè¯
        
        return True  # æ‰¹å‡†äº¤æ˜“
    
    def send_approval(self, transaction_data):
        """å‘é€æ‰¹å‡†"""
        self.channel.basic_publish(
            exchange='transaction_exchange',
            routing_key='transaction.approved',
            body=json.dumps({
                'transaction_id': transaction_data['transaction_id'],
                'status': 'approved',
                'processed_at': time.time()
            })
        )
    
    def send_rejection(self, transaction_data):
        """å‘é€æ‹’ç»"""
        self.channel.basic_publish(
            exchange='transaction_exchange',
            routing_key='transaction.rejected',
            body=json.dumps({
                'transaction_id': transaction_data['transaction_id'],
                'status': 'rejected',
                'processed_at': time.time(),
                'reason': 'éœ€è¦é¢å¤–éªŒè¯'
            })
        )

if __name__ == "__main__":
    # é‡‘èäº¤æ˜“å¤„ç†æ¼”ç¤º
    processor = FinancialTransactionProcessor()
    
    # æ¨¡æ‹Ÿäº¤æ˜“æ•°æ®
    test_transactions = [
        {
            'transaction_id': 'TXN-001',
            'from_account': 'ACC-12345',
            'to_account': 'ACC-67890',
            'amount': 50000.00,
            'type': 'transfer',
            'account_tier': 'gold',
            'priority': 8
        },
        {
            'transaction_id': 'TXN-002',
            'from_account': 'ACC-11111',
            'to_account': 'ACC-22222',
            'amount': 200.50,
            'type': 'payment',
            'account_tier': 'standard',
            'priority': 5
        },
        {
            'transaction_id': 'TXN-003',
            'from_account': 'ACC-33333',
            'to_account': 'ACC-44444',
            'amount': 150000.00,
            'type': 'transfer',
            'account_tier': 'vip',
            'priority': 9
        }
    ]
    
    print("ğŸ“¤ æäº¤é‡‘èäº¤æ˜“:")
    for transaction in test_transactions:
        processor.submit_transaction(transaction)
    
    processor.metrics.print_report()
    
    print("\nğŸ“Š äº¤æ˜“æ‘˜è¦:")
    for log_entry in processor.transaction_log:
        print(f"   {log_entry['transaction_id']}: {log_entry['status']}")
```

## 8. å®éªŒéªŒè¯

### 8.1 å¯é æ€§æµ‹è¯•

```python
def reliability_test_suite():
    """å¯é æ€§æµ‹è¯•å¥—ä»¶"""
    
    class ReliabilityTester:
        def __init__(self):
            self.test_results = {}
        
        def test_message_durability(self):
            """æµ‹è¯•æ¶ˆæ¯æŒä¹…æ€§"""
            print("\nğŸ§ª æµ‹è¯•æ¶ˆæ¯æŒä¹…æ€§")
            print("-" * 40)
            
            # å‘é€æŒä¹…åŒ–æ¶ˆæ¯
            messages = []
            for i in range(10):
                message = {
                    'id': i,
                    'content': f'æŒä¹…åŒ–æµ‹è¯•æ¶ˆæ¯ {i}',
                    'timestamp': time.time()
                }
                messages.append(message)
            
            # è¿™é‡Œåº”è¯¥å®é™…å‘é€æ¶ˆæ¯åˆ°RabbitMQ
            print(f"ğŸ“¤ å‘é€ {len(messages)} æ¡æŒä¹…åŒ–æ¶ˆæ¯")
            
            # æ¨¡æ‹Ÿé‡å¯ï¼ˆå®é™…æµ‹è¯•ä¸­éœ€è¦é‡å¯RabbitMQï¼‰
            print("ğŸ”„ æ¨¡æ‹ŸRabbitMQé‡å¯...")
            
            # éªŒè¯æ¶ˆæ¯æ˜¯å¦ä¿ç•™
            print("âœ… éªŒè¯æ¶ˆæ¯æŒä¹…æ€§...")
            
            return len(messages) == 10  # å‡è®¾å…¨éƒ¨ä¿ç•™
        
        def test_consumer_acknowledge(self):
            """æµ‹è¯•æ¶ˆè´¹è€…ç¡®è®¤"""
            print("\nğŸ§ª æµ‹è¯•æ¶ˆè´¹è€…ç¡®è®¤")
            print("-" * 40)
            
            # æµ‹è¯•åœºæ™¯
            test_cases = [
                {'scenario': 'æ­£å¸¸ç¡®è®¤', 'should_ack': True, 'expected_result': 'success'},
                {'scenario': 'å¼‚å¸¸æ‹’ç»', 'should_ack': False, 'expected_result': 'requeue'},
                {'scenario': 'å•æ¡æ‹’ç»', 'should_ack': False, 'expected_result': 'reject'}
            ]
            
            results = []
            for test_case in test_cases:
                print(f"æµ‹è¯•åœºæ™¯: {test_case['scenario']}")
                
                # æ¨¡æ‹Ÿæ¶ˆè´¹è€…è¡Œä¸º
                if test_case['should_ack']:
                    result = 'success'
                else:
                    result = test_case['expected_result']
                
                results.append({
                    'scenario': test_case['scenario'],
                    'result': result,
                    'passed': result == test_case['expected_result']
                })
                
                print(f"  ç»“æœ: {result}")
            
            return results
        
        def test_transaction_rollback(self):
            """æµ‹è¯•äº‹åŠ¡å›æ»š"""
            print("\nğŸ§ª æµ‹è¯•äº‹åŠ¡å›æ»š")
            print("-" * 40)
            
            # æ¨¡æ‹Ÿäº‹åŠ¡æ“ä½œ
            test_messages = [
                {'id': 1, 'should_succeed': True},
                {'id': 2, 'should_succeed': False},
                {'id': 3, 'should_succeed': True}
            ]
            
            success_count = 0
            for message in test_messages:
                if message['should_succeed']:
                    success_count += 1
                    print(f"âœ… æ¶ˆæ¯ {message['id']} å¤„ç†æˆåŠŸ")
                else:
                    print(f"âŒ æ¶ˆæ¯ {message['id']} å¤„ç†å¤±è´¥ï¼Œè§¦å‘å›æ»š")
            
            print(f"ğŸ“Š æˆåŠŸå¤„ç† {success_count}/{len(test_messages)} æ¡æ¶ˆæ¯")
            
            return success_count == len(test_messages)
        
        def test_batch_processing(self):
            """æµ‹è¯•æ‰¹é‡å¤„ç†"""
            print("\nğŸ§ª æµ‹è¯•æ‰¹é‡å¤„ç†")
            print("-" * 40)
            
            # ç”Ÿæˆæµ‹è¯•æ¶ˆæ¯
            batch_messages = list(range(1, 101))  # 100æ¡æ¶ˆæ¯
            
            # æ¨¡æ‹Ÿæ‰¹é‡å¤„ç†
            batch_size = 10
            batches_processed = 0
            
            for i in range(0, len(batch_messages), batch_size):
                batch = batch_messages[i:i + batch_size]
                batches_processed += 1
                
                print(f"å¤„ç†æ‰¹æ¬¡ {batches_processed}: {len(batch)} æ¡æ¶ˆæ¯")
            
            print(f"ğŸ“¦ æ€»å…±å¤„ç† {batches_processed} ä¸ªæ‰¹æ¬¡")
            
            return batches_processed == 10  # 100æ¡æ¶ˆæ¯åº”è¯¥åˆ†æˆ10ä¸ªæ‰¹æ¬¡
        
        def run_all_tests(self):
            """è¿è¡Œæ‰€æœ‰æµ‹è¯•"""
            print("ğŸš€ å¼€å§‹å¯é æ€§æµ‹è¯•å¥—ä»¶")
            print("=" * 50)
            
            # è¿è¡Œå„é¡¹æµ‹è¯•
            self.test_results['durability'] = self.test_message_durability()
            self.test_results['acknowledge'] = self.test_consumer_acknowledge()
            self.test_results['transaction'] = self.test_transaction_rollback()
            self.test_results['batch'] = self.test_batch_processing()
            
            # æ±‡æ€»ç»“æœ
            print("\nğŸ“Š æµ‹è¯•ç»“æœæ±‡æ€»")
            print("=" * 50)
            
            passed_tests = 0
            total_tests = 4
            
            for test_name, result in self.test_results.items():
                if isinstance(result, bool):
                    status = "âœ… é€šè¿‡" if result else "âŒ å¤±è´¥"
                    if result:
                        passed_tests += 1
                else:
                    # ACKæµ‹è¯•è¿”å›å¤šä¸ªç»“æœ
                    passed_in_test = sum(1 for r in result if r['passed'])
                    status = f"âœ… {passed_in_test}/{len(result)} é€šè¿‡"
                    if passed_in_test == len(result):
                        passed_tests += 1
                
                print(f"{test_name.capitalize()}: {status}")
            
            print(f"\nğŸ¯ æ€»ä½“ç»“æœ: {passed_tests}/{total_tests} é¡¹æµ‹è¯•é€šè¿‡")
            
            if passed_tests == total_tests:
                print("ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼æ¶ˆæ¯ç³»ç»Ÿå¯é æ€§è‰¯å¥½ã€‚")
            else:
                print("âš ï¸ éƒ¨åˆ†æµ‹è¯•å¤±è´¥ï¼Œéœ€è¦æ£€æŸ¥æ¶ˆæ¯ç³»ç»Ÿé…ç½®ã€‚")
            
            return self.test_results
    
    # è¿è¡Œæµ‹è¯•
    tester = ReliabilityTester()
    return tester.run_all_tests()

if __name__ == "__main__":
    reliability_test_suite()
```

### 8.2 æ€§èƒ½åŸºå‡†æµ‹è¯•

```python
def performance_benchmark():
    """æ€§èƒ½åŸºå‡†æµ‹è¯•"""
    
    class PerformanceBenchmark:
        def __init__(self):
            self.results = {}
        
        def benchmark_throughput(self):
            """åŸºå‡†ååé‡æµ‹è¯•"""
            print("\nğŸ“Š ååé‡åŸºå‡†æµ‹è¯•")
            print("-" * 40)
            
            test_configs = [
                {'name': 'è‡ªåŠ¨ç¡®è®¤', 'auto_ack': True, 'prefetch': 1},
                {'name': 'æ‰‹åŠ¨ç¡®è®¤', 'auto_ack': False, 'prefetch': 1},
                {'name': 'æ‰¹é‡ç¡®è®¤', 'auto_ack': False, 'prefetch': 100},
                {'name': 'äº‹åŠ¡æ¨¡å¼', 'transaction': True, 'prefetch': 1}
            ]
            
            results = []
            
            for config in test_configs:
                print(f"æµ‹è¯•é…ç½®: {config['name']}")
                
                # æ¨¡æ‹Ÿå‘é€1000æ¡æ¶ˆæ¯
                start_time = time.time()
                
                # è¿™é‡Œåº”è¯¥æ˜¯å®é™…çš„æ¶ˆæ¯å‘é€é€»è¾‘
                for i in range(1000):
                    # æ¨¡æ‹Ÿæ¶ˆæ¯å‘é€
                    time.sleep(0.001)  # æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
                
                end_time = time.time()
                duration = end_time - start_time
                throughput = 1000 / duration
                
                results.append({
                    'config': config['name'],
                    'duration': duration,
                    'throughput': throughput,
                    'messages_per_second': f"{throughput:.1f}"
                })
                
                print(f"  æŒç»­æ—¶é—´: {duration:.2f}s")
                print(f"  ååé‡: {throughput:.1f} æ¶ˆæ¯/ç§’")
            
            return results
        
        def benchmark_latency(self):
            """å»¶è¿ŸåŸºå‡†æµ‹è¯•"""
            print("\nâ±ï¸ å»¶è¿ŸåŸºå‡†æµ‹è¯•")
            print("-" * 40)
            
            test_scenarios = [
                {'name': 'å•æ¡æ¶ˆæ¯å»¶è¿Ÿ', 'batch_size': 1},
                {'name': 'æ‰¹é‡æ¶ˆæ¯å»¶è¿Ÿ', 'batch_size': 10},
                {'name': 'å¤§æ¶ˆæ¯å»¶è¿Ÿ', 'message_size': '10KB'},
                {'name': 'å°æ¶ˆæ¯å»¶è¿Ÿ', 'message_size': '100B'}
            ]
            
            results = []
            
            for scenario in test_scenarios:
                print(f"æµ‹è¯•åœºæ™¯: {scenario['name']}")
                
                # æ¨¡æ‹Ÿå»¶è¿Ÿæµ‹è¯•
                start_time = time.time()
                
                if scenario['batch_size'] > 1:
                    # æ‰¹é‡æµ‹è¯•
                    for _ in range(scenario['batch_size']):
                        time.sleep(0.001)  # æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
                else:
                    # å•æ¡æµ‹è¯•
                    time.sleep(0.001)
                
                end_time = time.time()
                avg_latency = (end_time - start_time) * 1000  # è½¬æ¢ä¸ºæ¯«ç§’
                
                results.append({
                    'scenario': scenario['name'],
                    'avg_latency_ms': avg_latency,
                    'p95_latency_ms': avg_latency * 1.5,
                    'p99_latency_ms': avg_latency * 2
                })
                
                print(f"  å¹³å‡å»¶è¿Ÿ: {avg_latency:.2f}ms")
                print(f"  95%å»¶è¿Ÿ: {avg_latency * 1.5:.2f}ms")
                print(f"  99%å»¶è¿Ÿ: {avg_latency * 2:.2f}ms")
            
            return results
        
        def benchmark_memory_usage(self):
            """å†…å­˜ä½¿ç”¨åŸºå‡†æµ‹è¯•"""
            print("\nğŸ’¾ å†…å­˜ä½¿ç”¨åŸºå‡†æµ‹è¯•")
            print("-" * 40)
            
            test_scenarios = [
                {'name': 'ä½è´Ÿè½½', 'concurrent_consumers': 1},
                {'name': 'ä¸­è´Ÿè½½', 'concurrent_consumers': 5},
                {'name': 'é«˜è´Ÿè½½', 'concurrent_consumers': 20},
                {'name': 'è¶…é«˜è´Ÿè½½', 'concurrent_consumers': 50}
            ]
            
            results = []
            
            for scenario in test_scenarios:
                print(f"æµ‹è¯•åœºæ™¯: {scenario['name']}")
                
                # æ¨¡æ‹Ÿå†…å­˜ä½¿ç”¨
                base_memory = 50  # MB
                memory_per_consumer = 5  # MB per consumer
                estimated_memory = base_memory + (
                    scenario['concurrent_consumers'] * memory_per_consumer
                )
                
                results.append({
                    'scenario': scenario['name'],
                    'concurrent_consumers': scenario['concurrent_consumers'],
                    'estimated_memory_mb': estimated_memory,
                    'memory_per_consumer_mb': memory_per_consumer
                })
                
                print(f"  å¹¶å‘æ¶ˆè´¹è€…: {scenario['concurrent_consumers']}")
                print(f"  ä¼°è®¡å†…å­˜ä½¿ç”¨: {estimated_memory}MB")
            
            return results
        
        def run_benchmark(self):
            """è¿è¡Œå®Œæ•´åŸºå‡†æµ‹è¯•"""
            print("ğŸš€ å¼€å§‹æ€§èƒ½åŸºå‡†æµ‹è¯•")
            print("=" * 50)
            
            # è¿è¡Œå„é¡¹åŸºå‡†æµ‹è¯•
            self.results['throughput'] = self.benchmark_throughput()
            self.results['latency'] = self.benchmark_latency()
            self.results['memory'] = self.benchmark_memory_usage()
            
            # ç”ŸæˆæŠ¥å‘Š
            print("\nğŸ“ˆ æ€§èƒ½åŸºå‡†æµ‹è¯•æŠ¥å‘Š")
            print("=" * 50)
            
            print("ğŸ“Š ååé‡å¯¹æ¯”:")
            for result in self.results['throughput']:
                print(f"  {result['config']}: {result['throughput']:.1f} æ¶ˆæ¯/ç§’")
            
            print("\nâ±ï¸ å»¶è¿Ÿåˆ†æ:")
            for result in self.results['latency']:
                print(f"  {result['scenario']}: {result['avg_latency_ms']:.2f}ms")
            
            print("\nğŸ’¾ å†…å­˜ä½¿ç”¨:")
            for result in self.results['memory']:
                print(f"  {result['scenario']}: {result['estimated_memory_mb']}MB")
            
            # æ¨èé…ç½®
            print("\nğŸ’¡ æ€§èƒ½ä¼˜åŒ–å»ºè®®:")
            print("  - é«˜ååé‡åœºæ™¯ï¼šä½¿ç”¨æ‰¹é‡ç¡®è®¤ï¼Œå¢å¤§prefetch_count")
            print("  - ä½å»¶è¿Ÿè¦æ±‚ï¼šä½¿ç”¨æ‰‹åŠ¨ç¡®è®¤ï¼Œå‡å°prefetch_count")
            print("  - å¤§å¹¶å‘åœºæ™¯ï¼šä½¿ç”¨è¿æ¥æ± ï¼Œæ§åˆ¶æ¶ˆè´¹è€…æ•°é‡")
            print("  - å†…å­˜å—é™ï¼šå¯ç”¨æ¶ˆæ¯è¿‡æœŸï¼Œé…ç½®é˜Ÿåˆ—æœ€å¤§é•¿åº¦")
            
            return self.results
    
    # è¿è¡ŒåŸºå‡†æµ‹è¯•
    benchmark = PerformanceBenchmark()
    return benchmark.run_benchmark()

if __name__ == "__main__":
    performance_benchmark()
```

## 9. æ•…éšœæ’æŸ¥

### 9.1 å¸¸è§é—®é¢˜è¯Šæ–­

```python
def troubleshoot_common_issues():
    """å¸¸è§é—®é¢˜è¯Šæ–­"""
    
    class IssueDiagnostics:
        def __init__(self):
            self.issue_patterns = {
                'message_loss': self.diagnose_message_loss,
                'duplicate_messages': self.diagnose_duplicate_messages,
                'high_latency': self.diagnose_high_latency,
                'queue_backlog': self.diagnose_queue_backlog,
                'connection_issues': self.diagnose_connection_issues
            }
        
        def diagnose_message_loss(self):
            """è¯Šæ–­æ¶ˆæ¯ä¸¢å¤±"""
            print("\nğŸ” æ¶ˆæ¯ä¸¢å¤±è¯Šæ–­")
            print("-" * 40)
            
            # æ£€æŸ¥é¡¹
            checks = [
                {
                    'item': 'é˜Ÿåˆ—æŒä¹…åŒ–',
                    'status': 'â“ æœªæ£€æŸ¥',
                    'solution': 'è®¾ç½® durable=True'
                },
                {
                    'item': 'æ¶ˆæ¯æŒä¹…åŒ–',
                    'status': 'â“ æœªæ£€æŸ¥',
                    'solution': 'è®¾ç½® delivery_mode=2'
                },
                {
                    'item': 'æ¶ˆè´¹è€…ç¡®è®¤',
                    'status': 'â“ æœªæ£€æŸ¥',
                    'solution': 'æ£€æŸ¥ auto_ack=False'
                },
                {
                    'item': 'æ­»ä¿¡é˜Ÿåˆ—',
                    'status': 'â“ æœªæ£€æŸ¥',
                    'solution': 'é…ç½® x-dead-letter-*'
                },
                {
                    'item': 'RabbitMQæ—¥å¿—',
                    'status': 'â“ æœªæ£€æŸ¥',
                    'solution': 'æ£€æŸ¥ /var/log/rabbitmq/'
                }
            ]
            
            for check in checks:
                print(f"  {check['item']}: {check['status']}")
                print(f"    ğŸ’¡ è§£å†³æ–¹æ¡ˆ: {check['solution']}")
            
            print("\nğŸ“‹ æ¶ˆæ¯ä¸¢å¤±æ£€æŸ¥æ¸…å•:")
            print("  â–¡ é˜Ÿåˆ—æ˜¯å¦è®¾ç½®ä¸ºæŒä¹…åŒ–")
            print("  â–¡ æ¶ˆæ¯æ˜¯å¦æ ‡è®°ä¸ºæŒä¹…åŒ–")
            print("  â–¡ æ¶ˆè´¹è€…æ˜¯å¦ä½¿ç”¨æ‰‹åŠ¨ç¡®è®¤")
            print("  â–¡ æ˜¯å¦é…ç½®æ­»ä¿¡é˜Ÿåˆ—")
            print("  â–¡ RabbitMQæ—¥å¿—æ˜¯å¦è®°å½•å¼‚å¸¸")
            
            return checks
        
        def diagnose_duplicate_messages(self):
            """è¯Šæ–­é‡å¤æ¶ˆæ¯"""
            print("\nğŸ” é‡å¤æ¶ˆæ¯è¯Šæ–­")
            print("-" * 40)
            
            # æ£€æŸ¥é¡¹
            checks = [
                {
                    'issue': 'ç”Ÿäº§è€…é‡è¯•',
                    'symptoms': 'ç›¸åŒæ¶ˆæ¯IDé‡å¤å‡ºç°',
                    'solution': 'ä½¿ç”¨å¹‚ç­‰é”®å»é‡'
                },
                {
                    'issue': 'æ¶ˆè´¹è€…é‡è¯•',
                    'symptoms': 'æ¶ˆè´¹è€…é‡å¯åé‡å¤å¤„ç†',
                    'solution': 'ä½¿ç”¨æ¶ˆæ¯ç¡®è®¤æœºåˆ¶'
                },
                {
                    'issue': 'ç½‘ç»œé‡å‘',
                    'symptoms': 'ç½‘ç»œæ³¢åŠ¨åæ¶ˆæ¯é‡å¤',
                    'solution': 'å¯ç”¨å‘å¸ƒè€…ç¡®è®¤'
                }
            ]
            
            for check in checks:
                print(f"  é—®é¢˜: {check['issue']}")
                print(f"    ç—‡çŠ¶: {check['symptoms']}")
                print(f"    è§£å†³æ–¹æ¡ˆ: {check['solution']}")
            
            return checks
        
        def diagnose_high_latency(self):
            """è¯Šæ–­é«˜å»¶è¿Ÿ"""
            print("\nğŸ” é«˜å»¶è¿Ÿè¯Šæ–­")
            print("-" * 40)
            
            # æ£€æŸ¥é¡¹
            checks = [
                {
                    'component': 'ç½‘ç»œå»¶è¿Ÿ',
                    'check': 'ping RabbitMQæœåŠ¡å™¨',
                    'threshold': '< 1ms (åŒå±€åŸŸç½‘)',
                    'solution': 'ä¼˜åŒ–ç½‘ç»œæ‹“æ‰‘'
                },
                {
                    'component': 'é˜Ÿåˆ—ç§¯å‹',
                    'check': 'æ£€æŸ¥é˜Ÿåˆ—æ¶ˆæ¯æ•°é‡',
                    'threshold': '< 1000 æ¡æ¶ˆæ¯',
                    'solution': 'å¢åŠ æ¶ˆè´¹è€…æˆ–ä¼˜åŒ–å¤„ç†é€»è¾‘'
                },
                {
                    'component': 'æ¶ˆè´¹è€…æ€§èƒ½',
                    'check': 'ç›‘æ§æ¶ˆè´¹è€…å¤„ç†æ—¶é—´',
                    'threshold': '< 100ms å¹³å‡å¤„ç†æ—¶é—´',
                    'solution': 'ä¼˜åŒ–æ¶ˆæ¯å¤„ç†é€»è¾‘'
                },
                {
                    'component': 'ç£ç›˜I/O',
                    'check': 'ç›‘æ§ç£ç›˜ä½¿ç”¨ç‡',
                    'threshold': '< 80% ç£ç›˜ä½¿ç”¨ç‡',
                    'solution': 'æ¸…ç†ç£ç›˜æˆ–å¢åŠ å­˜å‚¨'
                }
            ]
            
            for check in checks:
                print(f"  ç»„ä»¶: {check['component']}")
                print(f"    æ£€æŸ¥æ–¹æ³•: {check['check']}")
                print(f"    é˜ˆå€¼: {check['threshold']}")
                print(f"    è§£å†³æ–¹æ¡ˆ: {check['solution']}")
            
            return checks
        
        def diagnose_queue_backlog(self):
            """è¯Šæ–­é˜Ÿåˆ—ç§¯å‹"""
            print("\nğŸ” é˜Ÿåˆ—ç§¯å‹è¯Šæ–­")
            print("-" * 40)
            
            # æ£€æŸ¥é¡¹
            checks = [
                {
                    'cause': 'æ¶ˆè´¹è€…å¤„ç†èƒ½åŠ›ä¸è¶³',
                    'indicators': ['é˜Ÿåˆ—æŒç»­å¢é•¿', 'æ¶ˆè´¹è€…CPUä½¿ç”¨ç‡ä½'],
                    'solutions': ['å¢åŠ æ¶ˆè´¹è€…æ•°é‡', 'ä¼˜åŒ–æ¶ˆè´¹è€…å¤„ç†é€»è¾‘']
                },
                {
                    'cause': 'æ¶ˆè´¹è€…åœæ­¢å“åº”',
                    'indicators': ['æ¶ˆè´¹è€…è¿æ¥å¼‚å¸¸', 'æ¶ˆæ¯æ— æ³•ç¡®è®¤'],
                    'solutions': ['é‡å¯æ¶ˆè´¹è€…æœåŠ¡', 'æ£€æŸ¥æ¶ˆè´¹è€…ä»£ç ']
                },
                {
                    'cause': 'æ¶ˆæ¯å¤§å°è¿‡å¤§',
                    'indicators': ['ç½‘ç»œååé‡ä½', 'å†…å­˜ä½¿ç”¨ç‡é«˜'],
                    'solutions': ['å‹ç¼©æ¶ˆæ¯å†…å®¹', 'ä¼˜åŒ–æ¶ˆæ¯æ ¼å¼']
                }
            ]
            
            for check in checks:
                print(f"  åŸå› : {check['cause']}")
                print(f"    æŒ‡æ ‡: {', '.join(check['indicators'])}")
                print(f"    è§£å†³æ–¹æ¡ˆ: {', '.join(check['solutions'])}")
            
            return checks
        
        def diagnose_connection_issues(self):
            """è¯Šæ–­è¿æ¥é—®é¢˜"""
            print("\nğŸ” è¿æ¥é—®é¢˜è¯Šæ–­")
            print("-" * 40)
            
            # æ£€æŸ¥é¡¹
            checks = [
                {
                    'issue': 'è¿æ¥è¶…æ—¶',
                    'causes': ['ç½‘ç»œä¸ç¨³å®š', 'é˜²ç«å¢™é˜»æ–­', 'RabbitMQæœåŠ¡åœæ­¢'],
                    'solutions': ['æ£€æŸ¥ç½‘ç»œè¿æ¥', 'é…ç½®é˜²ç«å¢™è§„åˆ™', 'é‡å¯RabbitMQæœåŠ¡']
                },
                {
                    'issue': 'è®¤è¯å¤±è´¥',
                    'causes': ['ç”¨æˆ·åå¯†ç é”™è¯¯', 'æƒé™ä¸è¶³', 'SSLè¯ä¹¦é—®é¢˜'],
                    'solutions': ['éªŒè¯è®¤è¯ä¿¡æ¯', 'æ£€æŸ¥ç”¨æˆ·æƒé™', 'æ£€æŸ¥SSLé…ç½®']
                },
                {
                    'issue': 'è¿æ¥æ± è€—å°½',
                    'causes': ['è¿æ¥æœªæ­£ç¡®é‡Šæ”¾', 'è¿æ¥æ•°é™åˆ¶è¿‡ä½'],
                    'solutions': ['ä¼˜åŒ–è¿æ¥ç®¡ç†', 'å¢åŠ è¿æ¥æ± å¤§å°']
                }
            ]
            
            for check in checks:
                print(f"  é—®é¢˜: {check['issue']}")
                print(f"    åŸå› : {', '.join(check['causes'])}")
                print(f"    è§£å†³æ–¹æ¡ˆ: {', '.join(check['solutions'])}")
            
            return checks
        
        def run_full_diagnostics(self):
            """è¿è¡Œå®Œæ•´è¯Šæ–­"""
            print("ğŸ”§ å¼€å§‹ç³»ç»Ÿè¯Šæ–­")
            print("=" * 50)
            
            all_results = {}
            
            for issue_name, diagnostic_func in self.issue_patterns.items():
                try:
                    result = diagnostic_func()
                    all_results[issue_name] = result
                except Exception as e:
                    print(f"âŒ è¯Šæ–­ {issue_name} æ—¶å‘ç”Ÿé”™è¯¯: {e}")
                    all_results[issue_name] = None
            
            # ç”Ÿæˆè¯Šæ–­æŠ¥å‘Š
            print("\nğŸ“Š è¯Šæ–­æŠ¥å‘Šæ‘˜è¦")
            print("=" * 50)
            
            print("ğŸ” å·²å®Œæˆçš„è¯Šæ–­:")
            for issue_name, result in all_results.items():
                if result:
                    print(f"  âœ… {issue_name}: å·²å®Œæˆ")
                else:
                    print(f"  âŒ {issue_name}: å¤±è´¥")
            
            print("\nğŸ’¡ ä¸‹ä¸€æ­¥å»ºè®®:")
            print("  1. æ ¹æ®è¯Šæ–­ç»“æœå®šä½é—®é¢˜")
            print("  2. å®æ–½ç›¸åº”çš„è§£å†³æ–¹æ¡ˆ")
            print("  3. é‡æ–°æµ‹è¯•ç¡®è®¤é—®é¢˜è§£å†³")
            print("  4. å»ºç«‹ç›‘æ§é¢„é˜²æœºåˆ¶")
            
            return all_results
    
    # è¿è¡Œè¯Šæ–­
    diagnostics = IssueDiagnostics()
    return diagnostics.run_full_diagnostics()

if __name__ == "__main__":
    troubleshoot_common_issues()
```

### 9.2 ç›‘æ§å’Œè­¦æŠ¥

```python
def setup_monitoring_alerts():
    """è®¾ç½®ç›‘æ§å’Œè­¦æŠ¥"""
    
    class MonitoringAlerts:
        def __init__(self):
            self.alert_thresholds = {
                'queue_depth': 1000,
                'message_rate': 10000,  # æ¶ˆæ¯/ç§’
                'connection_failures': 5,
                'consumer_lag': 500,
                'dead_letter_rate': 0.01  # 1%
            }
            self.metrics_history = []
        
        def monitor_queue_metrics(self):
            """ç›‘æ§é˜Ÿåˆ—æŒ‡æ ‡"""
            print("\nğŸ“Š é˜Ÿåˆ—æŒ‡æ ‡ç›‘æ§")
            print("-" * 40)
            
            # æ¨¡æ‹Ÿé˜Ÿåˆ—æŒ‡æ ‡
            metrics = {
                'queue_name': 'test_queue',
                'depth': 150,  # å½“å‰é˜Ÿåˆ—æ·±åº¦
                'message_rate_in': 150.5,
                'message_rate_out': 149.2,
                'consumer_count': 3,
                'active_consumers': 3,
                'acknowledged_rate': 148.8,
                'redelivered_rate': 0.4
            }
            
            # æ£€æŸ¥è­¦æŠ¥æ¡ä»¶
            alerts = []
            
            if metrics['depth'] > self.alert_thresholds['queue_depth']:
                alerts.append({
                    'level': 'WARNING',
                    'message': f"é˜Ÿåˆ— {metrics['queue_name']} æ·±åº¦è¿‡é«˜: {metrics['depth']}",
                    'threshold': self.alert_thresholds['queue_depth']
                })
            
            if metrics['redelivered_rate'] > 0.5:
                alerts.append({
                    'level': 'ERROR',
                    'message': f"é˜Ÿåˆ— {metrics['queue_name']} é‡æŠ•é€’ç‡è¿‡é«˜: {metrics['redelivered_rate']}%",
                    'threshold': '0.5%'
                })
            
            print(f"é˜Ÿåˆ—åç§°: {metrics['queue_name']}")
            print(f"å½“å‰æ·±åº¦: {metrics['depth']}")
            print(f"æ¶ˆæ¯æµå…¥ç‡: {metrics['message_rate_in']}/s")
            print(f"æ¶ˆæ¯æµå‡ºç‡: {metrics['message_rate_out']}/s")
            print(f"æ¶ˆè´¹è€…æ•°é‡: {metrics['consumer_count']}")
            print(f"æ´»è·ƒæ¶ˆè´¹è€…: {metrics['active_consumers']}")
            print(f"ç¡®è®¤ç‡: {metrics['acknowledged_rate']}/s")
            print(f"é‡æŠ•é€’ç‡: {metrics['redelivered_rate']}%")
            
            if alerts:
                print("\nğŸš¨ è­¦æŠ¥:")
                for alert in alerts:
                    print(f"  {alert['level']}: {alert['message']}")
            else:
                print("\nâœ… æ— è­¦æŠ¥ï¼Œé˜Ÿåˆ—çŠ¶æ€æ­£å¸¸")
            
            return metrics, alerts
        
        def monitor_connection_health(self):
            """ç›‘æ§è¿æ¥å¥åº·çŠ¶æ€"""
            print("\nğŸ”— è¿æ¥å¥åº·ç›‘æ§")
            print("-" * 40)
            
            # æ¨¡æ‹Ÿè¿æ¥æŒ‡æ ‡
            metrics = {
                'total_connections': 15,
                'active_connections': 12,
                'connection_failures': 2,
                'channel_count': 45,
                'memory_usage': 256,  # MB
                'disk_space': 1024,  # MB
                'uptime': 86400  # ç§’
            }
            
            alerts = []
            
            if metrics['connection_failures'] > self.alert_thresholds['connection_failures']:
                alerts.append({
                    'level': 'ERROR',
                    'message': f"è¿æ¥å¤±è´¥æ¬¡æ•°è¿‡é«˜: {metrics['connection_failures']}",
                    'threshold': self.alert_thresholds['connection_failures']
                })
            
            if metrics['memory_usage'] > 512:  # MB
                alerts.append({
                    'level': 'WARNING',
                    'message': f"å†…å­˜ä½¿ç”¨é‡è¿‡é«˜: {metrics['memory_usage']}MB",
                    'threshold': '512MB'
                })
            
            print(f"æ€»è¿æ¥æ•°: {metrics['total_connections']}")
            print(f"æ´»è·ƒè¿æ¥æ•°: {metrics['active_connections']}")
            print(f"è¿æ¥å¤±è´¥æ•°: {metrics['connection_failures']}")
            print(f"é€šé“æ•°é‡: {metrics['channel_count']}")
            print(f"å†…å­˜ä½¿ç”¨: {metrics['memory_usage']}MB")
            print(f"ç£ç›˜ç©ºé—´: {metrics['disk_space']}MB")
            print(f"è¿è¡Œæ—¶é—´: {metrics['uptime']}ç§’")
            
            if alerts:
                print("\nğŸš¨ è­¦æŠ¥:")
                for alert in alerts:
                    print(f"  {alert['level']}: {alert['message']}")
            else:
                print("\nâœ… è¿æ¥çŠ¶æ€æ­£å¸¸")
            
            return metrics, alerts
        
        def generate_monitoring_report(self):
            """ç”Ÿæˆç›‘æ§æŠ¥å‘Š"""
            print("\nğŸ“ˆ ç³»ç»Ÿç›‘æ§æŠ¥å‘Š")
            print("=" * 50)
            
            # æ”¶é›†æ‰€æœ‰æŒ‡æ ‡
            queue_metrics, queue_alerts = self.monitor_queue_metrics()
            connection_metrics, connection_alerts = self.monitor_connection_health()
            
            # æ±‡æ€»æŠ¥å‘Š
            total_alerts = len(queue_alerts) + len(connection_alerts)
            
            print(f"\nğŸ“Š æŠ¥å‘Šæ‘˜è¦:")
            print(f"  æ£€æŸ¥æ—¶é—´: {time.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"  é˜Ÿåˆ—è­¦æŠ¥: {len(queue_alerts)} ä¸ª")
            print(f"  è¿æ¥è­¦æŠ¥: {len(connection_alerts)} ä¸ª")
            print(f"  æ€»è­¦æŠ¥æ•°: {total_alerts} ä¸ª")
            
            if total_alerts == 0:
                print("\nğŸ‰ ç³»ç»Ÿè¿è¡Œæ­£å¸¸ï¼Œæ— è­¦æŠ¥")
            elif total_alerts <= 3:
                print("\nâš ï¸ ç³»ç»Ÿå­˜åœ¨è½»å¾®é—®é¢˜ï¼Œå»ºè®®å…³æ³¨")
            else:
                print("\nğŸš¨ ç³»ç»Ÿå­˜åœ¨ä¸¥é‡é—®é¢˜ï¼Œéœ€è¦ç«‹å³å¤„ç†")
            
            # ä¿å­˜å†å²æ•°æ®
            self.metrics_history.append({
                'timestamp': time.time(),
                'queue_metrics': queue_metrics,
                'connection_metrics': connection_metrics,
                'total_alerts': total_alerts
            })
            
            # ä¿æŒæœ€è¿‘100æ¡è®°å½•
            if len(self.metrics_history) > 100:
                self.metrics_history = self.metrics_history[-100:]
            
            # è¶‹åŠ¿åˆ†æ
            if len(self.metrics_history) > 10:
                print("\nğŸ“ˆ è¶‹åŠ¿åˆ†æ:")
                recent_alerts = [h['total_alerts'] for h in self.metrics_history[-10:]]
                avg_alerts = sum(recent_alerts) / len(recent_alerts)
                
                if avg_alerts > 2:
                    print(f"  âš ï¸ è¿‘æœŸè­¦æŠ¥é¢‘ç‡ä¸Šå‡ï¼Œå¹³å‡ {avg_alerts:.1f} ä¸ª/æ£€æŸ¥å‘¨æœŸ")
                else:
                    print(f"  âœ… è¿‘æœŸè­¦æŠ¥é¢‘ç‡ç¨³å®šï¼Œå¹³å‡ {avg_alerts:.1f} ä¸ª/æ£€æŸ¥å‘¨æœŸ")
            
            return queue_alerts + connection_alerts
        
        def alert_handling(self, alerts):
            """è­¦æŠ¥å¤„ç†"""
            print("\nğŸ”” è­¦æŠ¥å¤„ç†")
            print("-" * 40)
            
            for alert in alerts:
                print(f"å¤„ç†è­¦æŠ¥: {alert['message']}")
                
                # æ ¹æ®è­¦æŠ¥çº§åˆ«é‡‡å–ä¸åŒè¡ŒåŠ¨
                if alert['level'] == 'ERROR':
                    print("  ğŸš¨ ä¸¥é‡é”™è¯¯ - ç«‹å³é€šçŸ¥ç®¡ç†å‘˜")
                    # è¿™é‡Œå¯ä»¥é›†æˆå®é™…çš„è­¦æŠ¥ç³»ç»Ÿ
                elif alert['level'] == 'WARNING':
                    print("  âš ï¸ è­¦å‘Š - è®°å½•æ—¥å¿—ï¼Œé€šçŸ¥ç›¸å…³äººå‘˜")
                else:
                    print("  â„¹ï¸ ä¿¡æ¯ - è®°å½•æ—¥å¿—")
                
                # å¯ä»¥æ·»åŠ è‡ªåŠ¨å¤„ç†é€»è¾‘
                self.auto_remediation(alert)
        
        def auto_remediation(self, alert):
            """è‡ªåŠ¨ä¿®å¤"""
            print(f"  ğŸ”§ è‡ªåŠ¨ä¿®å¤: {alert['message']}")
            
            # æ ¹æ®è­¦æŠ¥ç±»å‹æ‰§è¡Œè‡ªåŠ¨ä¿®å¤
            if 'é˜Ÿåˆ—æ·±åº¦è¿‡é«˜' in alert['message']:
                print("    â†’ å¯åŠ¨é¢å¤–çš„æ¶ˆè´¹è€…å®ä¾‹")
            elif 'å†…å­˜ä½¿ç”¨è¿‡é«˜' in alert['message']:
                print("    â†’ æ¸…ç†è¿‡æœŸæ¶ˆæ¯")
            elif 'è¿æ¥å¤±è´¥' in alert['message']:
                print("    â†’ é‡æ–°è¿æ¥RabbitMQ")
    
    # è¿è¡Œç›‘æ§
    monitoring = MonitoringAlerts()
    alerts = monitoring.generate_monitoring_report()
    
    if alerts:
        monitoring.alert_handling(alerts)

if __name__ == "__main__":
    setup_monitoring_alerts()
```

## ğŸ“ æœ¬ç« æ€»ç»“

### æ ¸å¿ƒæ¦‚å¿µå›é¡¾

1. **æ¶ˆæ¯ç¡®è®¤æœºåˆ¶**
   - è‡ªåŠ¨ç¡®è®¤ï¼šç®€å•é«˜æ•ˆä½†å¯èƒ½ä¸¢å¤±æ¶ˆæ¯
   - æ‰‹åŠ¨ç¡®è®¤ï¼šå¯é ä½†éœ€è¦æ›´å¤šä»£ç 
   - æ‰¹é‡ç¡®è®¤ï¼šæé«˜æ€§èƒ½ä½†éœ€è¦è°¨æ…è®¾è®¡

2. **æŒä¹…åŒ–ç­–ç•¥**
   - é˜Ÿåˆ—æŒä¹…åŒ–ï¼š`durable=True`
   - æ¶ˆæ¯æŒä¹…åŒ–ï¼š`delivery_mode=2`
   - äº¤æ¢æœºæŒä¹…åŒ–ï¼šç¡®ä¿äº¤æ¢æœºä¸ä¸¢å¤±

3. **äº‹åŠ¡å¤„ç†**
   - äº‹åŠ¡æ¨¡å¼ï¼šä¿è¯åŸå­æ€§ä½†æ€§èƒ½è¾ƒä½
   - å‘å¸ƒè€…ç¡®è®¤ï¼šæ€§èƒ½æ›´å¥½çš„ç¡®è®¤æœºåˆ¶
   - æ‰‹åŠ¨ç¡®è®¤ï¼šæ¶ˆè´¹è€…ç«¯ç¡®è®¤æœºåˆ¶

### æœ€ä½³å®è·µ

1. **å¯é æ€§ç­–ç•¥**
   - ç”Ÿäº§ç¯å¢ƒä½¿ç”¨æ‰‹åŠ¨ç¡®è®¤
   - é‡è¦æ¶ˆæ¯å¯ç”¨æŒä¹…åŒ–
   - é…ç½®æ­»ä¿¡é˜Ÿåˆ—å¤„ç†å¤±è´¥æ¶ˆæ¯
   - ä½¿ç”¨å‘å¸ƒè€…ç¡®è®¤ç¡®ä¿æ¶ˆæ¯åˆ°è¾¾

2