# ç¬¬7ç« ï¼šå®‰å…¨ä¸è®¤è¯

## ğŸ”’ ç« èŠ‚æ¦‚è¿°

åœ¨ç°ä»£åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œæ¶ˆæ¯é˜Ÿåˆ—çš„å®‰å…¨æ€§è‡³å…³é‡è¦ã€‚æœ¬ç« å°†æ·±å…¥æ¢è®¨RabbitMQçš„å®‰å…¨æœºåˆ¶ï¼ŒåŒ…æ‹¬èº«ä»½è®¤è¯ã€æƒé™æ§åˆ¶ã€åŠ å¯†ä¼ è¾“ã€å®¡è®¡æ—¥å¿—ç­‰å…³é”®å®‰å…¨ç‰¹æ€§ï¼Œç¡®ä¿æ‚¨çš„æ¶ˆæ¯ç³»ç»Ÿæ—¢å®‰å…¨åˆå¯é ã€‚

## ğŸ—ï¸ 7.1 å®‰å…¨æ¶æ„æ¦‚è¿°

### 7.1.1 å®‰å…¨å¨èƒæ¨¡å‹

RabbitMQé¢ä¸´çš„ä¸»è¦å®‰å…¨å¨èƒï¼š

- **æœªæˆæƒè®¿é—®**: æœªç»è®¤è¯çš„ç”¨æˆ·å°è¯•è®¿é—®ç³»ç»Ÿ
- **æ•°æ®æ³„éœ²**: æ•æ„Ÿæ¶ˆæ¯åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­è¢«çªƒå–
- **ä¸­é—´äººæ”»å‡»**: ç½‘ç»œé€šä¿¡ä¸­çš„æ•°æ®ç¯¡æ”¹
- **æƒé™æå‡**: ä½æƒé™ç”¨æˆ·å°è¯•è·å–æ›´é«˜æƒé™
- **æ‹’ç»æœåŠ¡**: é€šè¿‡å¤§é‡è¯·æ±‚å¯¼è‡´ç³»ç»Ÿä¸å¯ç”¨

### 7.1.2 å®‰å…¨é˜²æŠ¤å±‚æ¬¡

RabbitMQçš„å®‰å…¨é˜²æŠ¤é‡‡ç”¨å¤šå±‚æ¶æ„ï¼š

```
åº”ç”¨å±‚å®‰å…¨
    â†“
ä¼ è¾“å±‚å®‰å…¨ (TLS/SSL)
    â†“
è®¤è¯å±‚å®‰å…¨ (ç”¨æˆ·è®¤è¯/Tokenè®¤è¯)
    â†“
æˆæƒå±‚å®‰å…¨ (æƒé™æ§åˆ¶/è§’è‰²ç®¡ç†)
    â†“
å®¡è®¡å±‚å®‰å…¨ (æ—¥å¿—è®°å½•/ç›‘æ§å‘Šè­¦)
```

## ğŸ” 7.2 èº«ä»½è®¤è¯æœºåˆ¶

### 7.2.1 ç”¨æˆ·è®¤è¯

RabbitMQæ”¯æŒå¤šç§è®¤è¯æ–¹å¼ï¼š

#### 1. ç”¨æˆ·åå¯†ç è®¤è¯
```python
# åŸºç¡€ç”¨æˆ·åå¯†ç è®¤è¯
credentials = pika.PlainCredentials('username', 'password')
connection_parameters = pika.ConnectionParameters(
    'localhost',
    5672,
    '/',
    credentials
)
```

#### 2. LDAPè®¤è¯é›†æˆ
```bash
# å¯ç”¨LDAPæ’ä»¶
rabbitmq-plugins enable rabbitmq_auth_backend_ldap

# é…ç½®LDAP
# /etc/rabbitmq/rabbitmq.conf
auth_backend_ldap.servers = ldap.example.com
auth_backend_ldap.port = 389
auth_backend_ldap.user_dn_pattern = cn=${username},ou=people,dc=example,dc=com
auth_backend_ldap.use_ssl = false
auth_backend_ldap.log = true
```

#### 3. JWT Tokenè®¤è¯
```python
import jwt
import datetime

class JWTAuthProvider:
    def __init__(self, secret_key):
        self.secret_key = secret_key
    
    def generate_token(self, user_id, permissions):
        payload = {
            'user_id': user_id,
            'permissions': permissions,
            'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=24)
        }
        return jwt.encode(payload, self.secret_key, algorithm='HS256')
    
    def verify_token(self, token):
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=['HS256'])
            return payload
        except jwt.ExpiredSignatureError:
            raise Exception("Token expired")
        except jwt.InvalidTokenError:
            raise Exception("Invalid token")
```

### 7.2.2 è¯ä¹¦è®¤è¯

#### å®¢æˆ·ç«¯è¯ä¹¦è®¤è¯
```python
import ssl

class CertificateAuthConnection:
    def __init__(self, cert_file, key_file, ca_cert):
        self.cert_file = cert_file
        self.key_file = key_file
        self.ca_cert = ca_cert
    
    def create_ssl_context(self):
        context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)
        context.load_verify_locations(self.ca_cert)
        context.load_cert_chain(self.cert_file, self.key_file)
        context.check_hostname = False
        context.verify_mode = ssl.CERT_REQUIRED
        return context
    
    def create_connection(self):
        ssl_context = self.create_ssl_context()
        
        connection_parameters = pika.ConnectionParameters(
            'rabbitmq.example.com',
            5671,
            ssl_options=pika.SSLOptions(ssl_context)
        )
        return pika.BlockingConnection(connection_parameters)
```

## ğŸ›¡ï¸ 7.3 æƒé™æ§åˆ¶

### 7.3.1 ç”¨æˆ·è§’è‰²ç®¡ç†

```bash
# åˆ›å»ºç”¨æˆ·
rabbitmqctl add_user developer developer123

# è®¾ç½®è§’è‰²
rabbitmqctl set_user_tags developer management

# è®¾ç½®æƒé™
rabbitmqctl set_permissions -p / developer ".*" ".*" ".*"
```

### 7.3.2 ç»†ç²’åº¦æƒé™æ§åˆ¶

#### é˜Ÿåˆ—æƒé™æ§åˆ¶
```python
class QueuePermissionManager:
    def __init__(self):
        self.permissions = {}
    
    def grant_queue_access(self, user, queue, permission_type):
        if user not in self.permissions:
            self.permissions[user] = {}
        
        if queue not in self.permissions[user]:
            self.permissions[user][queue] = []
        
        self.permissions[user][queue].append(permission_type)
    
    def check_queue_permission(self, user, queue, operation):
        if user not in self.permissions:
            return False
        
        if queue not in self.permissions[user]:
            return False
        
        return operation in self.permissions[user][queue]
    
    def revoke_queue_access(self, user, queue, permission_type):
        if user in self.permissions and queue in self.permissions[user]:
            if permission_type in self.permissions[user][queue]:
                self.permissions[user][queue].remove(permission_type)
```

#### åŠ¨æ€æƒé™ç®¡ç†
```python
import pika

class DynamicPermissionManager:
    def __init__(self, manager_connection):
        self.manager_conn = manager_connection
    
    def create_user_with_permissions(self, username, password, vhost, config_pattern, write_pattern, read_pattern):
        """åˆ›å»ºç”¨æˆ·å¹¶è®¾ç½®æƒé™"""
        try:
            # æ·»åŠ ç”¨æˆ·
            self.manager_conn.add_user(username, password)
            
            # è®¾ç½®æƒé™
            self.manager_conn.set_permission(vhost, username, config_pattern, write_pattern, read_pattern)
            
            # è®¾ç½®ç”¨æˆ·æ ‡ç­¾
            self.manager_conn.set_user_tags(username, ['management'])
            
            return True
        except Exception as e:
            print(f"åˆ›å»ºç”¨æˆ·å¤±è´¥: {e}")
            return False
    
    def update_user_permissions(self, username, vhost, config_pattern, write_pattern, read_pattern):
        """æ›´æ–°ç”¨æˆ·æƒé™"""
        try:
            self.manager_conn.clear_permission(vhost, username)
            self.manager_conn.set_permission(vhost, username, config_pattern, write_pattern, read_pattern)
            return True
        except Exception as e:
            print(f"æ›´æ–°æƒé™å¤±è´¥: {e}")
            return False
    
    def revoke_user_access(self, username, vhost):
        """æ’¤é”€ç”¨æˆ·è®¿é—®æƒé™"""
        try:
            self.manager_conn.clear_permission(vhost, username)
            return True
        except Exception as e:
            print(f"æ’¤é”€æƒé™å¤±è´¥: {e}")
            return False
```

### 7.3.3 åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶ (RBAC)

```python
class RBACManager:
    def __init__(self):
        self.roles = {
            'admin': {
                'permissions': ['configure', 'write', 'read'],
                'resources': ['.*']
            },
            'publisher': {
                'permissions': ['write'],
                'resources': ['events.*', 'notifications.*']
            },
            'consumer': {
                'permissions': ['read'],
                'resources': ['events.*', 'logs.*']
            },
            'viewer': {
                'permissions': ['read'],
                'resources': ['status.*', 'monitoring.*']
            }
        }
    
    def assign_role(self, user, role):
        """åˆ†é…è§’è‰²ç»™ç”¨æˆ·"""
        if role not in self.roles:
            raise ValueError(f"è§’è‰² {role} ä¸å­˜åœ¨")
        
        # è®¾ç½®ç”¨æˆ·è§’è‰²æ ‡ç­¾
        return self.roles[role]
    
    def check_permission(self, user_role, operation, resource):
        """æ£€æŸ¥æƒé™"""
        if user_role not in self.roles:
            return False
        
        role_info = self.roles[user_role]
        
        # æ£€æŸ¥æ“ä½œæƒé™
        if operation not in role_info['permissions']:
            return False
        
        # æ£€æŸ¥èµ„æºæƒé™
        import re
        for allowed_resource in role_info['resources']:
            if re.match(f"^{allowed_resource}$", resource):
                return True
        
        return False
```

## ğŸ”’ 7.4 åŠ å¯†ä¼ è¾“

### 7.4.1 TLS/SSLé…ç½®

#### æœåŠ¡ç«¯SSLé…ç½®
```bash
# /etc/rabbitmq/rabbitmq.conf
listeners.ssl.default = 5671
ssl_options.cacertfile = /etc/rabbitmq/ssl/cacert.pem
ssl_options.certfile   = /etc/rabbitmq/ssl/cert.pem
ssl_options.keyfile    = /etc/rabbitmq/ssl/key.pem
ssl_options.verify     = verify_peer
ssl_options.fail_if_no_peer_cert = true
ssl_options.versions.1 = tlsv1.2
ssl_options.versions.2 = tlsv1.3
ssl_options.ciphers.1  = ECDHE-RSA-AES256-GCM-SHA384
ssl_options.ciphers.2  = ECDHE-RSA-AES128-GCM-SHA256
```

#### å®¢æˆ·ç«¯SSLè¿æ¥
```python
import pika
import ssl

class SSLConnection:
    def __init__(self, host, port, ca_cert, cert_file, key_file):
        self.host = host
        self.port = port
        self.ca_cert = ca_cert
        self.cert_file = cert_file
        self.key_file = key_file
    
    def create_ssl_context(self):
        context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)
        context.load_verify_locations(self.ca_cert)
        context.load_cert_chain(self.cert_file, self.key_file)
        
        # è®¾ç½®å®‰å…¨é€‰é¡¹
        context.check_hostname = True
        context.verify_mode = ssl.CERT_REQUIRED
        
        # å¼ºåˆ¶TLS 1.2+
        context.minimum_version = ssl.TLSVersion.TLSv1_2
        
        return context
    
    def create_secure_connection(self):
        ssl_context = self.create_ssl_context()
        
        connection_params = pika.ConnectionParameters(
            host=self.host,
            port=self.port,
            ssl_options=pika.SSLOptions(ssl_context),
            credentials=pika.PlainCredentials('user', 'pass')
        )
        
        return pika.BlockingConnection(connection_params)
```

### 7.4.2 æ¶ˆæ¯å†…å®¹åŠ å¯†

#### å¯¹ç§°åŠ å¯†æ¶ˆæ¯
```python
from cryptography.fernet import Fernet
import base64
import json

class MessageEncryption:
    def __init__(self, encryption_key=None):
        if encryption_key:
            self.cipher = Fernet(encryption_key)
        else:
            self.cipher = Fernet.generate_key()
            self.cipher = Fernet(self.cipher)
    
    def encrypt_message(self, message_data):
        """åŠ å¯†æ¶ˆæ¯"""
        if isinstance(message_data, dict):
            message_data = json.dumps(message_data)
        
        if isinstance(message_data, str):
            message_data = message_data.encode('utf-8')
        
        encrypted_data = self.cipher.encrypt(message_data)
        return base64.b64encode(encrypted_data).decode('utf-8')
    
    def decrypt_message(self, encrypted_message):
        """è§£å¯†æ¶ˆæ¯"""
        encrypted_data = base64.b64decode(encrypted_message.encode('utf-8'))
        decrypted_data = self.cipher.decrypt(encrypted_data)
        return decrypted_data.decode('utf-8')

# ä½¿ç”¨ç¤ºä¾‹
encryption = MessageEncryption()
encrypted_msg = encryption.encrypt_message({'user_id': 123, 'action': 'login'})
decrypted_msg = encryption.decrypt_message(encrypted_msg)
```

#### éå¯¹ç§°åŠ å¯†æ¶ˆæ¯
```python
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import os

class AsymmetricEncryption:
    def __init__(self):
        self.private_key = None
        self.public_key = None
    
    def generate_key_pair(self):
        """ç”Ÿæˆå¯†é’¥å¯¹"""
        self.private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
        )
        self.public_key = self.private_key.public_key()
    
    def encrypt_with_public_key(self, message):
        """ä½¿ç”¨å…¬é’¥åŠ å¯†"""
        if not self.public_key:
            raise Exception("å…¬é’¥æœªç”Ÿæˆ")
        
        message_bytes = message.encode('utf-8')
        
        encrypted = self.public_key.encrypt(
            message_bytes,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        
        return base64.b64encode(encrypted).decode('utf-8')
    
    def decrypt_with_private_key(self, encrypted_message):
        """ä½¿ç”¨ç§é’¥è§£å¯†"""
        if not self.private_key:
            raise Exception("ç§é’¥æœªç”Ÿæˆ")
        
        encrypted_bytes = base64.b64decode(encrypted_message.encode('utf-8'))
        
        decrypted = self.private_key.decrypt(
            encrypted_bytes,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        
        return decrypted.decode('utf-8')
```

## ğŸ“Š 7.5 å®‰å…¨å®¡è®¡

### 7.5.1 å®¡è®¡æ—¥å¿—

```python
import logging
from datetime import datetime
import json

class SecurityAuditor:
    def __init__(self, log_file='security_audit.log'):
        self.logger = logging.getLogger('SecurityAuditor')
        self.logger.setLevel(logging.INFO)
        
        # æ–‡ä»¶å¤„ç†å™¨
        handler = logging.FileHandler(log_file)
        formatter = logging.Formatter(
            '%(asctime)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)
        
        # å®¡è®¡äº‹ä»¶è®°å½•
        self.audit_events = []
    
    def log_authentication_attempt(self, user, client_ip, success, details=None):
        """è®°å½•è®¤è¯å°è¯•"""
        event = {
            'event_type': 'authentication',
            'timestamp': datetime.now().isoformat(),
            'user': user,
            'client_ip': client_ip,
            'success': success,
            'details': details or {}
        }
        
        self.audit_events.append(event)
        
        status = "SUCCESS" if success else "FAILED"
        self.logger.info(f"AUTHENTICATION - {user} from {client_ip}: {status}")
        
        return event
    
    def log_permission_change(self, admin_user, target_user, action, permission_details):
        """è®°å½•æƒé™å˜æ›´"""
        event = {
            'event_type': 'permission_change',
            'timestamp': datetime.now().isoformat(),
            'admin_user': admin_user,
            'target_user': target_user,
            'action': action,
            'permission_details': permission_details
        }
        
        self.audit_events.append(event)
        self.logger.info(f"PERMISSION_CHANGE - {admin_user} -> {target_user}: {action}")
        
        return event
    
    def log_message_access(self, user, action, queue, message_id=None):
        """è®°å½•æ¶ˆæ¯è®¿é—®"""
        event = {
            'event_type': 'message_access',
            'timestamp': datetime.now().isoformat(),
            'user': user,
            'action': action,
            'queue': queue,
            'message_id': message_id
        }
        
        self.audit_events.append(event)
        self.logger.info(f"MESSAGE_ACCESS - {user} on {queue}: {action}")
        
        return event
    
    def log_security_incident(self, incident_type, severity, description, source_ip=None):
        """è®°å½•å®‰å…¨äº‹ä»¶"""
        event = {
            'event_type': 'security_incident',
            'timestamp': datetime.now().isoformat(),
            'incident_type': incident_type,
            'severity': severity,
            'description': description,
            'source_ip': source_ip
        }
        
        self.audit_events.append(event)
        self.logger.warning(f"SECURITY_INCIDENT - {severity}: {incident_type} - {description}")
        
        return event
    
    def generate_audit_report(self, start_time=None, end_time=None):
        """ç”Ÿæˆå®¡è®¡æŠ¥å‘Š"""
        if start_time:
            start_time = datetime.fromisoformat(start_time) if isinstance(start_time, str) else start_time
        
        if end_time:
            end_time = datetime.fromisoformat(end_time) if isinstance(end_time, str) else end_time
        
        # ç­›é€‰äº‹ä»¶
        filtered_events = self.audit_events
        if start_time or end_time:
            filtered_events = []
            for event in self.audit_events:
                event_time = datetime.fromisoformat(event['timestamp'])
                if start_time and event_time < start_time:
                    continue
                if end_time and event_time > end_time:
                    continue
                filtered_events.append(event)
        
        # ç»Ÿè®¡ä¿¡æ¯
        report = {
            'report_period': {
                'start_time': start_time.isoformat() if start_time else 'beginning',
                'end_time': end_time.isoformat() if end_time else 'now'
            },
            'total_events': len(filtered_events),
            'event_types': {},
            'security_incidents': [],
            'authentication_summary': {
                'total_attempts': 0,
                'successful': 0,
                'failed': 0
            }
        }
        
        for event in filtered_events:
            event_type = event['event_type']
            report['event_types'][event_type] = report['event_types'].get(event_type, 0) + 1
            
            if event_type == 'security_incident':
                report['security_incidents'].append(event)
            elif event_type == 'authentication':
                report['authentication_summary']['total_attempts'] += 1
                if event.get('success'):
                    report['authentication_summary']['successful'] += 1
                else:
                    report['authentication_summary']['failed'] += 1
        
        return report
```

### 7.5.2 å®æ—¶å®‰å…¨ç›‘æ§

```python
import time
from threading import Thread, Event

class SecurityMonitor:
    def __init__(self, auditor):
        self.auditor = auditor
        self.is_monitoring = False
        self.monitoring_thread = None
        self.stop_event = Event()
        
        # å®‰å…¨è§„åˆ™
        self.security_rules = {
            'max_failed_logins': 5,
            'login_window_minutes': 15,
            'suspicious_ip_threshold': 10,
            'privilege_escalation_keywords': ['admin', 'root', 'superuser']
        }
        
        # çŠ¶æ€è·Ÿè¸ª
        self.failed_logins = {}  # {user: [timestamps]}
        self.suspicious_ips = {}  # {ip: count}
    
    def start_monitoring(self):
        """å¼€å§‹å®‰å…¨ç›‘æ§"""
        if self.is_monitoring:
            return
        
        self.is_monitoring = True
        self.stop_event.clear()
        self.monitoring_thread = Thread(target=self._monitor_loop)
        self.monitoring_thread.start()
        self.auditor.log_security_incident("monitoring_started", "info", "å®‰å…¨ç›‘æ§å·²å¼€å§‹")
    
    def stop_monitoring(self):
        """åœæ­¢å®‰å…¨ç›‘æ§"""
        if not self.is_monitoring:
            return
        
        self.is_monitoring = False
        self.stop_event.set()
        if self.monitoring_thread:
            self.monitoring_thread.join()
        
        self.auditor.log_security_incident("monitoring_stopped", "info", "å®‰å…¨ç›‘æ§å·²åœæ­¢")
    
    def _monitor_loop(self):
        """ç›‘æ§å¾ªç¯"""
        while not self.stop_event.is_set():
            try:
                # æ£€æŸ¥å¤±è´¥ç™»å½•
                self._check_failed_logins()
                
                # æ£€æŸ¥å¯ç–‘IP
                self._check_suspicious_ips()
                
                # æ£€æŸ¥æƒé™æå‡
                self._check_privilege_escalation()
                
                time.sleep(30)  # 30ç§’æ£€æŸ¥ä¸€æ¬¡
                
            except Exception as e:
                self.auditor.log_security_incident(
                    "monitoring_error", 
                    "error", 
                    f"ç›‘æ§å¼‚å¸¸: {str(e)}"
                )
                time.sleep(5)
    
    def _check_failed_logins(self):
        """æ£€æŸ¥å¤±è´¥ç™»å½•"""
        current_time = time.time()
        window_start = current_time - (self.security_rules['login_window_minutes'] * 60)
        
        for user, timestamps in list(self.failed_logins.items()):
            # æ¸…ç†è¿‡æœŸçš„å¤±è´¥è®°å½•
            self.failed_logins[user] = [ts for ts in timestamps if ts > window_start]
            
            # æ£€æŸ¥æ˜¯å¦è¶…è¿‡é˜ˆå€¼
            if len(self.failed_logins[user]) >= self.security_rules['max_failed_logins']:
                self.auditor.log_security_incident(
                    "multiple_failed_logins",
                    "warning",
                    f"ç”¨æˆ· {user} åœ¨ {self.security_rules['login_window_minutes']} åˆ†é’Ÿå†…å¤±è´¥ç™»å½• {len(self.failed_logins[user])} æ¬¡",
                    source_ip=user  # ç®€åŒ–å¤„ç†
                )
                
                # é‡ç½®å¤±è´¥è®¡æ•°
                self.failed_logins[user] = []
    
    def _check_suspicious_ips(self):
        """æ£€æŸ¥å¯ç–‘IP"""
        for ip, count in list(self.suspicious_ips.items()):
            if count >= self.security_rules['suspicious_ip_threshold']:
                self.auditor.log_security_incident(
                    "suspicious_ip_activity",
                    "warning",
                    f"IP {ip} åœ¨çŸ­æ—¶é—´å†…è¿æ¥ {count} æ¬¡",
                    source_ip=ip
                )
                
                # é‡ç½®è®¡æ•°
                self.suspicious_ips[ip] = 0
    
    def _check_privilege_escalation(self):
        """æ£€æŸ¥æƒé™æå‡ï¼ˆç®€åŒ–å®ç°ï¼‰"""
        # è¿™é‡Œå¯ä»¥æ£€æŸ¥ç”¨æˆ·æƒé™å˜æ›´æ—¥å¿—
        # å®é™…å®ç°ä¸­éœ€è¦è®¿é—®ç”¨æˆ·ç®¡ç†ç³»ç»Ÿçš„æ—¥å¿—
        pass
    
    def record_failed_login(self, user, client_ip):
        """è®°å½•å¤±è´¥ç™»å½•"""
        current_time = time.time()
        
        if user not in self.failed_logins:
            self.failed_logins[user] = []
        
        self.failed_logins[user].append(current_time)
        
        if client_ip not in self.suspicious_ips:
            self.suspicious_ips[client_ip] = 0
        
        self.suspicious_ips[client_ip] += 1
        
        self.auditor.log_authentication_attempt(user, client_ip, False)
    
    def record_successful_login(self, user, client_ip):
        """è®°å½•æˆåŠŸç™»å½•"""
        # æ¸…ç†å¤±è´¥è®°å½•
        if user in self.failed_logins:
            self.failed_logins[user] = []
        
        if client_ip in self.suspicious_ips:
            self.suspicious_ips[client_ip] = 0
        
        self.auditor.log_authentication_attempt(user, client_ip, True)
```

## ğŸ”§ 7.6 å®‰å…¨é…ç½®ç®¡ç†

### 7.6.1 å®‰å…¨é…ç½®éªŒè¯

```python
import configparser
import os
import re

class SecurityConfigValidator:
    def __init__(self):
        self.validation_rules = {
            'password_min_length': 8,
            'password_require_special_chars': True,
            'password_require_numbers': True,
            'password_require_uppercase': True,
            'session_timeout_minutes': 30,
            'max_login_attempts': 3,
            'ssl_min_version': 'TLSv1.2'
        }
    
    def validate_password(self, password):
        """éªŒè¯å¯†ç å¼ºåº¦"""
        errors = []
        
        if len(password) < self.validation_rules['password_min_length']:
            errors.append(f"å¯†ç é•¿åº¦è‡³å°‘ {self.validation_rules['password_min_length']} ä½")
        
        if self.validation_rules['password_require_special_chars']:
            if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
                errors.append("å¯†ç å¿…é¡»åŒ…å«ç‰¹æ®Šå­—ç¬¦")
        
        if self.validation_rules['password_require_numbers']:
            if not re.search(r'\d', password):
                errors.append("å¯†ç å¿…é¡»åŒ…å«æ•°å­—")
        
        if self.validation_rules['password_require_uppercase']:
            if not re.search(r'[A-Z]', password):
                errors.append("å¯†ç å¿…é¡»åŒ…å«å¤§å†™å­—æ¯")
        
        return len(errors) == 0, errors
    
    def validate_ssl_config(self, ssl_config):
        """éªŒè¯SSLé…ç½®"""
        errors = []
        warnings = []
        
        # æ£€æŸ¥è¯ä¹¦æ–‡ä»¶
        if 'cert_file' in ssl_config and not os.path.exists(ssl_config['cert_file']):
            errors.append(f"è¯ä¹¦æ–‡ä»¶ä¸å­˜åœ¨: {ssl_config['cert_file']}")
        
        if 'key_file' in ssl_config and not os.path.exists(ssl_config['key_file']):
            errors.append(f"ç§é’¥æ–‡ä»¶ä¸å­˜åœ¨: {ssl_config['key_file']}")
        
        if 'ca_cert' in ssl_config and not os.path.exists(ssl_config['ca_cert']):
            errors.append(f"CAè¯ä¹¦æ–‡ä»¶ä¸å­˜åœ¨: {ssl_config['ca_cert']}")
        
        # æ£€æŸ¥SSLç‰ˆæœ¬
        ssl_version = ssl_config.get('ssl_version', 'TLSv1.2')
        if ssl_version < self.validation_rules['ssl_min_version']:
            warnings.append(f"SSLç‰ˆæœ¬ {ssl_version} ä½äºæ¨èç‰ˆæœ¬ {self.validation_rules['ssl_min_version']}")
        
        return len(errors) == 0, errors, warnings
    
    def validate_user_config(self, user_config):
        """éªŒè¯ç”¨æˆ·é…ç½®"""
        errors = []
        
        if 'username' not in user_config:
            errors.append("ç”¨æˆ·åæ˜¯å¿…éœ€çš„")
        
        if 'password' not in user_config:
            errors.append("å¯†ç æ˜¯å¿…éœ€çš„")
        else:
            password_valid, password_errors = self.validate_password(user_config['password'])
            if not password_valid:
                errors.extend(password_errors)
        
        if 'permissions' in user_config:
            valid_operations = ['configure', 'read', 'write']
            for perm in user_config['permissions']:
                if perm not in valid_operations:
                    errors.append(f"æ— æ•ˆçš„æƒé™: {perm}")
        
        return len(errors) == 0, errors
```

### 7.6.2 å®‰å…¨é…ç½®æ¨¡æ¿

```python
class SecurityConfigTemplate:
    @staticmethod
    def get_basic_security_config():
        """è·å–åŸºç¡€å®‰å…¨é…ç½®"""
        return {
            'authentication': {
                'method': 'internal',  # internal, ldap, external
                'password_policy': {
                    'min_length': 8,
                    'require_uppercase': True,
                    'require_lowercase': True,
                    'require_numbers': True,
                    'require_special_chars': True,
                    'password_history': 5,
                    'max_age_days': 90
                },
                'session': {
                    'timeout_minutes': 30,
                    'max_concurrent_sessions': 3,
                    'renew_on_activity': True
                }
            },
            'ssl': {
                'enabled': True,
                'port': 5671,
                'cert_file': '/etc/rabbitmq/ssl/cert.pem',
                'key_file': '/etc/rabbitmq/ssl/key.pem',
                'ca_cert': '/etc/rabbitmq/ssl/cacert.pem',
                'ssl_version': 'TLSv1.2',
                'verify_mode': 'peer'
            },
            'authorization': {
                'default_deny': True,
                'vhost_access_control': True,
                'resource_pattern_matching': True
            },
            'monitoring': {
                'audit_logging': True,
                'connection_logging': True,
                'failed_auth_logging': True,
                'permission_change_logging': True
            }
        }
    
    @staticmethod
    def get_enterprise_security_config():
        """è·å–ä¼ä¸šçº§å®‰å…¨é…ç½®"""
        base_config = SecurityConfigTemplate.get_basic_security_config()
        
        # æ·»åŠ ä¼ä¸šçº§åŠŸèƒ½
        base_config.update({
            'authentication': {
                'method': 'ldap',
                'ldap_config': {
                    'server': 'ldap.example.com',
                    'port': 389,
                    'use_ssl': True,
                    'user_dn_pattern': 'cn=${username},ou=people,dc=example,dc=com',
                    'group_membership': True,
                    'group_dn_pattern': 'cn=${group},ou=groups,dc=example,dc=com'
                },
                'multi_factor_auth': {
                    'enabled': True,
                    'methods': ['totp', 'sms']
                },
                'password_policy': base_config['authentication']['password_policy']
            },
            'ssl': {
                'enabled': True,
                'client_cert_required': True,
                'cipher_suites': [
                    'ECDHE-RSA-AES256-GCM-SHA384',
                    'ECDHE-RSA-AES128-GCM-SHA256'
                ],
                'protocols': ['TLSv1.2', 'TLSv1.3']
            },
            'audit': {
                'real_time_monitoring': True,
                'log_retention_days': 365,
                'log_encryption': True,
                'compliance_mode': True
            },
            'network_security': {
                'ip_whitelist': ['10.0.0.0/8', '192.168.0.0/16'],
                'rate_limiting': {
                    'connections_per_minute': 100,
                    'messages_per_minute': 10000
                },
                'network_isolation': True
            }
        })
        
        return base_config
```

## ğŸ“š 7.7 å®‰å…¨æœ€ä½³å®è·µ

### 7.7.1 éƒ¨ç½²å®‰å…¨

```yaml
# docker-compose.security.yml
version: '3.8'

services:
  rabbitmq:
    image: rabbitmq:3-management-alpine
    environment:
      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER}
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}
    volumes:
      - ./ssl:/etc/rabbitmq/ssl
      - ./config/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf
      - ./config/definitions.json:/etc/rabbitmq/definitions.json
    ports:
      - "5671:5671"  # SSLç«¯å£
      - "15671:15671"  # ç®¡ç†ç•Œé¢SSLç«¯å£
    networks:
      - rabbitmq_network
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - SETUID
      - SETGID
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

networks:
  rabbitmq_network:
    driver: bridge
    internal: true
```

### 7.7.2 åº”ç”¨çº§å®‰å…¨

```python
class SecureMessageHandler:
    def __init__(self, encryption_key, audit_logger):
        self.encryption = MessageEncryption(encryption_key)
        self.audit_logger = audit_logger
        self.rate_limiter = RateLimiter()
    
    def secure_publish(self, channel, exchange, routing_key, message_data, user_info):
        """å®‰å…¨å‘å¸ƒæ¶ˆæ¯"""
        # æ£€æŸ¥ç”¨æˆ·æƒé™
        if not self._check_publish_permission(user_info, exchange):
            self.audit_logger.log_security_incident(
                "unauthorized_publish",
                "warning",
                f"ç”¨æˆ· {user_info['username']} å°è¯•å‘å¸ƒåˆ°æœªæˆæƒçš„exchange: {exchange}",
                user_info.get('client_ip')
            )
            raise PermissionError("æ— å‘å¸ƒæƒé™")
        
        # é€Ÿç‡é™åˆ¶æ£€æŸ¥
        if not self.rate_limiter.check_rate_limit(user_info['username'], 'publish'):
            self.audit_logger.log_security_incident(
                "rate_limit_exceeded",
                "warning",
                f"ç”¨æˆ· {user_info['username']} å‘å¸ƒé€Ÿç‡è¶…é™",
                user_info.get('client_ip')
            )
            raise RateLimitError("å‘å¸ƒé€Ÿç‡è¶…é™")
        
        # æ¶ˆæ¯åŠ å¯†
        encrypted_message = self.encryption.encrypt_message(message_data)
        
        # å‘å¸ƒæ¶ˆæ¯
        channel.basic_publish(
            exchange=exchange,
            routing_key=routing_key,
            body=encrypted_message,
            properties=pika.BasicProperties(
                delivery_mode=2,  # æŒä¹…åŒ–
                headers={'encrypted': True}
            )
        )
        
        # è®°å½•å®¡è®¡æ—¥å¿—
        self.audit_logger.log_message_access(
            user_info['username'],
            'publish',
            routing_key
        )
    
    def secure_consume(self, channel, queue, consumer_tag, callback, user_info):
        """å®‰å…¨æ¶ˆè´¹æ¶ˆæ¯"""
        # æ£€æŸ¥ç”¨æˆ·æƒé™
        if not self._check_consume_permission(user_info, queue):
            self.audit_logger.log_security_incident(
                "unauthorized_consume",
                "warning",
                f"ç”¨æˆ· {user_info['username']} å°è¯•æ¶ˆè´¹æœªæˆæƒçš„é˜Ÿåˆ—: {queue}",
                user_info.get('client_ip')
            )
            raise PermissionError("æ— æ¶ˆè´¹æƒé™")
        
        # é€Ÿç‡é™åˆ¶æ£€æŸ¥
        if not self.rate_limiter.check_rate_limit(user_info['username'], 'consume'):
            self.audit_logger.log_security_incident(
                "rate_limit_exceeded",
                "warning",
                f"ç”¨æˆ· {user_info['username']} æ¶ˆè´¹é€Ÿç‡è¶…é™",
                user_info.get('client_ip')
            )
            raise RateLimitError("æ¶ˆè´¹é€Ÿç‡è¶…é™")
        
        # å¼€å§‹æ¶ˆè´¹
        channel.basic_consume(
            queue=queue,
            consumer_tag=consumer_tag,
            on_message_callback=callback
        )
        
        # è®°å½•å®¡è®¡æ—¥å¿—
        self.audit_logger.log_message_access(
            user_info['username'],
            'consume',
            queue
        )
    
    def _check_publish_permission(self, user_info, exchange):
        """æ£€æŸ¥å‘å¸ƒæƒé™"""
        user_permissions = user_info.get('permissions', {})
        return 'write' in user_permissions and exchange in user_permissions.get('exchanges', [])
    
    def _check_consume_permission(self, user_info, queue):
        """æ£€æŸ¥æ¶ˆè´¹æƒé™"""
        user_permissions = user_info.get('permissions', {})
        return 'read' in user_permissions and queue in user_permissions.get('queues', [])

class RateLimiter:
    def __init__(self):
        self.limits = {
            'publish': {'requests': 100, 'window': 60},  # æ¯åˆ†é’Ÿ100ä¸ªå‘å¸ƒè¯·æ±‚
            'consume': {'requests': 1000, 'window': 60}  # æ¯åˆ†é’Ÿ1000ä¸ªæ¶ˆè´¹è¯·æ±‚
        }
        self.request_counts = {}
    
    def check_rate_limit(self, user_id, operation_type):
        """æ£€æŸ¥é€Ÿç‡é™åˆ¶"""
        current_time = time.time()
        
        if operation_type not in self.limits:
            return True
        
        limit_config = self.limits[operation_type]
        window_start = current_time - limit_config['window']
        
        # åˆå§‹åŒ–ç”¨æˆ·è®¡æ•°
        if user_id not in self.request_counts:
            self.request_counts[user_id] = {}
        
        if operation_type not in self.request_counts[user_id]:
            self.request_counts[user_id][operation_type] = []
        
        # æ¸…ç†è¿‡æœŸçš„è¯·æ±‚è®°å½•
        user_requests = self.request_counts[user_id][operation_type]
        user_requests[:] = [req_time for req_time in user_requests if req_time > window_start]
        
        # æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
        if len(user_requests) >= limit_config['requests']:
            return False
        
        # è®°å½•å½“å‰è¯·æ±‚
        user_requests.append(current_time)
        return True
```

### 7.7.3 ç›‘æ§å’Œå“åº”

```python
class SecurityResponseSystem:
    def __init__(self, auditor, rabbitmq_manager):
        self.auditor = auditor
        self.rabbitmq_manager = rabbitmq_manager
        self.response_actions = {
            'multiple_failed_logins': self._handle_failed_logins,
            'suspicious_ip_activity': self._handle_suspicious_ip,
            'unauthorized_access': self._handle_unauthorized_access,
            'privilege_escalation': self._handle_privilege_escalation
        }
    
    def handle_security_incident(self, incident):
        """å¤„ç†å®‰å…¨äº‹ä»¶"""
        incident_type = incident['incident_type']
        
        if incident_type in self.response_actions:
            try:
                self.response_actions[incident_type](incident)
                self.auditor.log_security_incident(
                    "incident_response",
                    "info",
                    f"å·²å¯¹äº‹ä»¶ {incident_type} æ‰§è¡Œå“åº”æ“ä½œ"
                )
            except Exception as e:
                self.auditor.log_security_incident(
                    "incident_response_error",
                    "error",
                    f"å“åº”äº‹ä»¶ {incident_type} æ—¶å‡ºé”™: {str(e)}"
                )
    
    def _handle_failed_logins(self, incident):
        """å¤„ç†å¤šæ¬¡å¤±è´¥ç™»å½•"""
        user = incident.get('description', '').split(' ')[1]  # æå–ç”¨æˆ·å
        
        # ä¸´æ—¶ç¦ç”¨ç”¨æˆ·
        try:
            self.rabbitmq_manager.disable_user(user)
            self.auditor.log_security_incident(
                "user_temporarily_disabled",
                "warning",
                f"ç”¨æˆ· {user} å› å¤šæ¬¡å¤±è´¥ç™»å½•è¢«ä¸´æ—¶ç¦ç”¨"
            )
        except Exception as e:
            self.auditor.log_security_incident(
                "user_disable_failed",
                "error",
                f"ç¦ç”¨ç”¨æˆ· {user} å¤±è´¥: {str(e)}"
            )
    
    def _handle_suspicious_ip(self, incident):
        """å¤„ç†å¯ç–‘IPæ´»åŠ¨"""
        ip = incident.get('source_ip')
        
        # æ·»åŠ IPåˆ°é»‘åå•
        try:
            self.rabbitmq_manager.block_ip(ip)
            self.auditor.log_security_incident(
                "ip_blocked",
                "warning",
                f"å¯ç–‘IP {ip} å·²è¢«é˜»æ­¢è®¿é—®"
            )
        except Exception as e:
            self.auditor.log_security_incident(
                "ip_block_failed",
                "error",
                f"é˜»æ­¢IP {ip} å¤±è´¥: {str(e)}"
            )
    
    def _handle_unauthorized_access(self, incident):
        """å¤„ç†æœªæˆæƒè®¿é—®"""
        # åŠ å¼ºæƒé™æ£€æŸ¥
        self.audit_logger.log_security_incident(
            "access_control_enhanced",
            "info",
            f"å¯¹æœªæˆæƒè®¿é—®äº‹ä»¶åŠ å¼ºç›‘æ§: {incident['description']}"
        )
    
    def _handle_privilege_escalation(self, incident):
        """å¤„ç†æƒé™æå‡"""
        # ç«‹å³æ’¤é”€æƒé™å˜æ›´å¹¶é€šçŸ¥ç®¡ç†å‘˜
        self.auditor.log_security_incident(
            "privilege_escalation_alert",
            "critical",
            f"æƒé™æå‡äº‹ä»¶ï¼Œéœ€è¦ç«‹å³äººå·¥ä»‹å…¥: {incident['description']}"
        )
        
        # å‘é€ç´§æ€¥é€šçŸ¥ï¼ˆé‚®ä»¶ã€çŸ­ä¿¡ç­‰ï¼‰
        self._send_emergency_notification(incident)
    
    def _send_emergency_notification(self, incident):
        """å‘é€ç´§æ€¥é€šçŸ¥"""
        # è¿™é‡Œé›†æˆé‚®ä»¶ã€çŸ­ä¿¡ã€Slackç­‰é€šçŸ¥æ–¹å¼
        notification_message = {
            'severity': incident['severity'],
            'title': 'ç´§æ€¥å®‰å…¨äº‹ä»¶',
            'message': incident['description'],
            'timestamp': incident['timestamp'],
            'action_required': True
        }
        
        # å®é™…å®ç°ä¸­å‘é€é€šçŸ¥
        print(f"ğŸš¨ ç´§æ€¥é€šçŸ¥: {notification_message}")
```

## ğŸ“– æœ¬ç« å°ç»“

### å…³é”®è¦ç‚¹

1. **å¤šå±‚å®‰å…¨é˜²æŠ¤**: è®¤è¯ã€æˆæƒã€åŠ å¯†ã€å®¡è®¡å››å±‚é˜²æŠ¤ç¡®ä¿ç³»ç»Ÿå®‰å…¨
2. **çµæ´»çš„è®¤è¯æœºåˆ¶**: æ”¯æŒç”¨æˆ·åå¯†ç ã€LDAPã€è¯ä¹¦ã€JWTç­‰å¤šç§è®¤è¯æ–¹å¼
3. **ç»†ç²’åº¦æƒé™æ§åˆ¶**: åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶ï¼Œç¡®ä¿æœ€å°æƒé™åŸåˆ™
4. **ä¼ è¾“å®‰å…¨**: TLS/SSLåŠ å¯†ä¿æŠ¤æ•°æ®ä¼ è¾“å®‰å…¨
5. **å…¨é¢çš„å®¡è®¡**: å®æ—¶ç›‘æ§å’Œå®Œæ•´çš„å®¡è®¡æ—¥å¿—è®°å½•
6. **ä¸»åŠ¨å®‰å…¨å“åº”**: è‡ªåŠ¨åŒ–çš„å®‰å…¨äº‹ä»¶æ£€æµ‹å’Œå“åº”æœºåˆ¶

### æœ€ä½³å®è·µæ€»ç»“

- å§‹ç»ˆä½¿ç”¨åŠ å¯†è¿æ¥è¿›è¡Œæ•°æ®ä¼ è¾“
- å®æ–½å¼ºå¯†ç ç­–ç•¥å’Œå¤šå› ç´ è®¤è¯
- å®šæœŸå®¡æŸ¥å’Œæ›´æ–°ç”¨æˆ·æƒé™
- å¯ç”¨å®Œæ•´çš„å®¡è®¡æ—¥å¿—è®°å½•
- å»ºç«‹å®‰å…¨äº‹ä»¶å“åº”æµç¨‹
- å®šæœŸè¿›è¡Œå®‰å…¨è¯„ä¼°å’Œæ¸—é€æµ‹è¯•

### ä¸‹ä¸€æ­¥

åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ RabbitMQçš„æ€§èƒ½è°ƒä¼˜å’Œç›‘æ§ï¼Œäº†è§£å¦‚ä½•ä¼˜åŒ–æ¶ˆæ¯ç³»ç»Ÿçš„æ€§èƒ½å¹¶å»ºç«‹æœ‰æ•ˆçš„ç›‘æ§ä½“ç³»ã€‚

---

*æœ¬ç« ä»£ç ç¤ºä¾‹å°†åœ¨é…å¥—çš„ä»£ç ä»“åº“ä¸­æä¾›ï¼Œè¯»è€…å¯ä»¥é€šè¿‡å®é™…è¿è¡Œæ¥åŠ æ·±å¯¹å®‰å…¨æœºåˆ¶çš„ç†è§£ã€‚*