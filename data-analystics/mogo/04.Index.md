## 1. Index Types
- Single fild index > only one field index
- MultiKey Index > Index on array fields
- Compound Index > Index on multiple fields

## 2. Create index
```bash
// aceding:1, decding:0
db.customers.createIndex({
  birthdate: 1
})

//
db.customers.createIndex({
  email: 1
},
{
  unique:true
})
```

## 3. Check index usage status
```bash
//explain()
db.customers.explain().find({
  birthdate: {
    $gt:ISODate("1995-08-01")
    }
  })
```

## 4. Index executionStats
```bash
db.zips.find({
    pop: { $gte: 100000, $lte: 111000 },
    city: 'NEW YORK',
    state: 'NY',
  }).sort({ zip: 1 })
    .explain("executionStats")
```

## 5. Insert data for testing
```
db.getSiblingDB("sample_products").products.insertMany([
  {
    _id: new ObjectId("64a36318574fd20cd8fb9798"),
    sku: 111,
    product_name: "Stero Speakers",
    price: 100,
    stock: 5,
    product_attributes: { color: "black", size: "5x5x5", weight: "5lbs" },
  },
  {
    _id: new ObjectId("64a36318574fd20cd8fb9799"),
    sku: 121,
    product_name: "Bread",
    price: 2,
    stock: 50,
    product_attributes: {
      type: "white",
      calories: 100,
      weight: "24g",
      crust: "soft",
    },
  },
  {
    _id: new ObjectId("64a36318574fd20cd8fb979a"),
    sku: 131,
    product_name: "Milk",
    price: 3,
    stock: 20,
    product_attributes: {
      type: "2%",
      calories: 120,
      weight: "1L",
      brand: "Dairy Farmers",
    },
  },
]);

```

## 6. Wildcard index
```bash

//$** for wildcard index
db.products.createIndex({ "product_attributes.$**" : 1 })
//create index for all, except wildcardProjection with 0
db.products.createIndex(
  { "$**": 1 },
  { wildcardProjection: { _id: 1, stock: 0, prices: 0 } }
)
```


## 7. Partial Indexs
```dotnetcli
db.zips.createIndex(
    {state: 1},
    {partialFilterExpression: {pop: {$gte: 10000}}}
)
//to test if your index been usage
db.zips.find({state:"CA"}).explain().queryPlanner.winningPlan
```

## 8. Sparse indexs
//for the case only care if the field is exists or not
```bash
db.users.createIndex({avatar_url: 1}, {sparse:true})
// how to test
db.users.find({avatar_url: {$exists: true}}).explain("executionStats").executionStats
```

## 9.Cluster index
```bash

```

## 10. Time series index
```bash
db.createCollection("weather", {
    timeseries: {
        timeFiled: "timestemp",
        metaFiled: "metadata",
        granularity: "hours",
    }
})

db.weather.find({
  timestamp: ISODate("2021-05-18T00:00:00.000Z")
}).explain().stages[0].$cursor.queryPlanner.winningPlan

//create second index
db.weather.createIndex({"metadata.sensorId":1, "timestamp":1})


```

## 11. Index monitor
```bash
//check if index been usage
db.customers.aggregate([{ $indexStats: {} }])s
//monitor perf
db.setProfilingLevel(1, {slowms: 50})

db.system.profile.find({op: 'query', ns: "sample_airbnb.listingsAndReviews"}).sort({ts:-1}).limit(1)
```

MongoDB Indexes II
In this unit, you learned how to:

Identify which fields in the explain() output will indicate a performance issue, i.e. nReturned, totalDocsExamined, totalKeysExamined
Set the verbosity level for explain(), i.e. executionStats
Run explain() on a query to determine if the query is using an index
Read the explain() output run on a query and identify what index a query is using
Create an efficient compound index for a given query
Create a wildcard index
Create a partial index
Create a sparse index
Create a clustered time series index
Use $indexStats to view the indexes with the most operations and unused indexes in a collection
Enable profiling and set the profiling level using db.setProfilingLevel()
Use Database Profiler (system.profile collection) to identify slow queries
Resources
Use the following resources to learn more about Indexing with MongoDB:

Lesson 1: How Indexes Work

Indexes in MongoDB
What is Indexing in a Database?
Compound Indexes
MongoDB University: Indexing I (Prerequisite course)
Index Best Practices
Lesson 2: Index Usage Details via Explain

Explain Method
Explain Verbosity Levels
Explain Results
Query Plans
Lesson 3: Optimized Compound Indexes

Compound Indexes
The ESR (Equality Sort Range) Rule
Tips and Tricks for Effective Indexing
Create Indexes to Support Your Queries
Lesson 4: Wildcard Indexes

Wildcard Indexes in MongoDB
Create a WildCard Index on All Fields
Include or Exclude Fields in a Wildcard Index
Wildcard Index Restrictions
Compound Wildcard Indexes (new in 7.0)
Lesson 5: Partial Indexes

Partial Indexes in MongoDB
Partial Index Restrictions
Lesson 6: Sparse Indexes

Sparse Indexes in MongoDB
Indexes that are Sparse by Default
Lesson 7: Clustered Indexes

Clustered Collections in MongoDB
Clustered Index Reference
expireAfterSeconds
Clustered Collection Examples
Lesson 8: Time Series Collections

Time Series
Create a Time-Series Collection
Add Secondary Indexes to Time-Series Collections
List Time-Series Collections in a Database
Set up Automatic Removal
Time Series Product Overview
Lesson 9: How to Monitor Indexes

$indexStats Operator
MongoDB Database Profiler
Reading Profiler Output
db.setProfilingLevel()
Database Profiler Verbosity Levels

https://learn.mongodb.com/learn/course/mongodb-indexes-ii/conclusion/learn?client=customer&page=2