# 第4章：索引与性能优化

## 目录
1. [索引基础](#1-索引基础)
2. [索引类型](#2-索引类型)
3. [复合索引](#3-复合索引)
4. [索引优化策略](#4-索引优化策略)
5. [查询优化](#5-查询优化)
6. [性能监控](#6-性能监控)

## 1. 索引基础

### 1.1 索引概念

#### 1.1.1 为什么需要索引
```javascript
// 没有索引的查询 - 全表扫描
const queryWithoutIndex = db.users.find({email: "user@example.com"});

// 创建索引后
db.users.createIndex({email: 1});

// 查询会使用索引，显著提升性能
const queryWithIndex = db.users.find({email: "user@example.com"});
```

#### 1.1.2 索引原理
```javascript
// B-Tree索引结构
const indexStructure = {
  "email": {
    "alice@example.com": ObjectId("64a7b123..."),
    "bob@example.com": ObjectId("64a7b124..."),
    "charlie@example.com": ObjectId("64a7b125...")
  },
  "created_at": {
    ISODate("2024-01-01"): [ObjectId("64a7b123..."), ObjectId("64a7b124...")],
    ISODate("2024-01-02"): [ObjectId("64a7b126...")]
  }
};
```

### 1.2 索引操作

#### 1.2.1 创建索引
```javascript
// 单字段索引
db.users.createIndex({email: 1});                    // 升序
db.users.createIndex({email: -1});                   // 降序
db.users.createIndex({email: 1}, {unique: true});    // 唯一索引

// 复合索引
db.users.createIndex({status: 1, created_at: -1});

// 部分索引
db.users.createIndex(
  {email: 1},
  {partialFilterExpression: {status: "active"}}
);

// 稀疏索引
db.users.createIndex(
  {phone: 1},
  {sparse: true}
);

// 文本索引
db.articles.createIndex(
  {title: "text", content: "text", tags: "text"}
);
```

#### 1.2.2 索引信息查询
```javascript
// 查看集合的所有索引
db.users.getIndexes();

// 查看索引使用统计
db.users.aggregate([
  {$indexStats: {}}
]);

// 查看索引大小
db.users.stats().indexSizes;

// 分析索引性能
const analyzeIndex = (collectionName) => {
  const stats = db[collectionName].aggregate([
    {$indexStats: {}},
    {$sort: {accesses: -1}},
    {$limit: 10}
  ]);
  
  return stats.toArray();
};
```

### 1.3 索引选择原则

#### 1.3.1 基数选择
```javascript
// 高基数字段 - 适合索引
const highCardinalityFields = {
  email: "unique values",
  user_id: "unique values", 
  product_id: "unique values"
};

// 低基数字段 - 不适合独立索引
const lowCardinalityFields = {
  status: ["active", "inactive"],
  gender: ["M", "F"],
  category: ["A", "B", "C"]
};

// 复合索引优化低基数字段
const optimizedCompositeIndex = {
  // 状态 + 创建时间，状态作为前缀
  index: {status: 1, created_at: 1},
  
  // 查询示例
  query: db.users.find({
    status: "active",
    created_at: {$gte: new Date("2024-01-01")}
  }).explain()
};
```

#### 1.3.2 查询模式分析
```javascript
// 分析查询模式
const queryPatternAnalyzer = {
  // 频繁查询字段组合
  commonQueries: [
    {email: "string"},
    {status: "string", created_at: "date"},
    {last_login: "date", status: "string"},
    {username: "string", status: "string"}
  ],
  
  // 生成优化索引
  generateIndexes: (patterns) => {
    const indexSuggestions = [];
    
    patterns.forEach(pattern => {
      const keys = Object.keys(pattern).sort();
      const indexKey = {};
      
      keys.forEach(key => {
        indexKey[key] = 1;
      });
      
      indexSuggestions.push({
        index: indexKey,
        reason: `优化查询: ${JSON.stringify(pattern)}`
      });
    });
    
    return indexSuggestions;
  }
};
```

## 2. 索引类型

### 2.1 单字段索引

#### 2.1.1 基本单字段索引
```javascript
// 升序索引
db.products.createIndex({category: 1});

// 降序索引（影响排序优化）
db.products.createIndex({price: -1});

// 唯一索引
db.users.createIndex({username: 1}, {unique: true});

// 唯一索引示例
const uniqueIndexExample = async () => {
  try {
    // 创建唯一索引
    await db.users.createIndex(
      {email: 1},
      {unique: true, name: "unique_email"}
    );
    
    // 插入重复邮箱会失败
    await db.users.insertOne({
      username: "user1",
      email: "test@example.com"
    });
    
    await db.users.insertOne({
      username: "user2", 
      email: "test@example.com"  // 重复邮箱
    });
  } catch (error) {
    console.log("唯一索引约束生效:", error.message);
  }
};
```

#### 2.1.2 TTL索引
```javascript
// TTL索引 - 自动过期删除
const createTTLIndex = () => {
  // 24小时后过期
  db.sessions.createIndex(
    {created_at: 1},
    {expireAfterSeconds: 24 * 60 * 60}
  );
  
  // 自定义过期时间字段
  db.temp_data.createIndex(
    {expires_at: 1},
    {expireAfterSeconds: 0}
  );
};

// 插入测试数据
const insertTTLData = async () => {
  await db.sessions.insertMany([
    {
      session_id: "sess1",
      user_id: ObjectId("64a7b123..."),
      created_at: new Date(),
      data: {token: "abc123"}
    },
    {
      session_id: "sess2", 
      user_id: ObjectId("64a7b124..."),
      created_at: new Date(Date.now() - 2 * 60 * 60 * 1000), // 2小时前
      data: {token: "def456"}
    }
  ]);
};
```

### 2.2 复合索引

#### 2.2.1 复合索引原则
```javascript
// 复合索引字段顺序
const compositeIndexPrinciples = {
  // 1. 等值查询字段在前
  emailStatusIndex: {email: 1, status: 1, created_at: 1},
  
  // 2. 范围查询字段在后
  // 这个索引对以下查询都有帮助：
  
  // 查询1: email = "user@example.com" AND status = "active"
  // 查询2: email = "user@example.com" AND status = "active" AND created_at >= date
  // 查询3: email = "user@example.com" (只使用email部分)
  
  // 但这个查询会失败：
  // status = "active" AND created_at >= date (跳过了email字段)
};

// 错误示例
const badCompositeIndex = {
  // 范围查询字段在前，等值查询字段在后（不推荐）
  badIndex: {created_at: 1, status: 1, email: 1}
};
```

#### 2.2.2 复合索引优化示例
```javascript
// 场景：用户活跃度分析
const optimizeUserQueries = async () => {
  // 复合索引1: 基础过滤 + 排序
  await db.users.createIndex({
    status: 1,              // 等值查询
    created_at: -1          // 排序
  });
  
  // 复合索引2: 多条件查询
  await db.users.createIndex({
    status: 1,              // 等值查询
    user_type: 1,           // 等值查询
    last_login: -1          // 排序
  });
  
  // 查询测试
  const query1 = await db.users.find({
    status: "active"
  }).sort({created_at: -1}).explain();
  
  const query2 = await db.users.find({
    status: "active",
    user_type: "premium"
  }).sort({last_login: -1}).explain();
};
```

### 2.3 特殊索引类型

#### 2.3.1 哈希索引
```javascript
// 哈希索引用于分片
const hashIndex = {
  // 仅支持等值查询，不支持范围查询
  createHashIndex: () => {
    db.users.createIndex(
      {user_id: "hashed"}
    );
  },
  
  // 查询示例
  queryWithHashIndex: async () => {
    // ✅ 有效查询
    return db.users.find({user_id: ObjectId("64a7b123...")});
    
    // ❌ 无效查询（范围查询）
    // return db.users.find({user_id: {$gte: someId}});
  }
};
```

#### 2.3.2 地理空间索引
```javascript
// 2dsphere索引 - 地球表面查询
const createGeospatialIndex = () => {
  // 2dsphere索引
  db.locations.createIndex({
    coordinates: "2dsphere"
  });
  
  // 2d索引（平面几何）
  db.mapPoints.createIndex({
    location: "2d"
  });
};

// 地理空间查询
const geospatialQueries = {
  // 附近查询
  findNearby: async () => {
    const userLocation = {
      type: "Point",
      coordinates: [-74.0060, 40.7128]  // 纽约坐标
    };
    
    return db.locations.find({
      coordinates: {
        $near: {
          $geometry: userLocation,
          $maxDistance: 5000,    // 5公里
          $minDistance: 0
        }
      }
    });
  },
  
  // 区域内查询
  findInRegion: async () => {
    const region = {
      type: "Polygon",
      coordinates: [[
        [-74.1, 40.7],
        [-73.9, 40.7],
        [-73.9, 40.8],
        [-74.1, 40.8],
        [-74.1, 40.7]
      ]]
    };
    
    return db.locations.find({
      coordinates: {
        $geoWithin: {
          $geometry: region
        }
      }
    });
  }
};
```

#### 2.3.3 全文索引
```javascript
// 创建全文索引
const createTextIndex = () => {
  db.articles.createIndex(
    {title: "text", content: "text", tags: "text"},
    {
      weights: {               // 字段权重
        title: 10,
        content: 5,
        tags: 3
      },
      default_language: "english",
      name: "article_text_index"
    }
  );
};

// 全文搜索查询
const textSearchQueries = {
  // 基础全文搜索
  basicTextSearch: async () => {
    return db.articles.find({
      $text: {$search: "mongodb database performance"}
    });
  },
  
  // 带评分的搜索
  scoredTextSearch: async () => {
    return db.articles.find(
      {$text: {$search: "mongodb performance"}},
      {
        score: {$meta: "textScore"},
        title: 1,
        content: 1
      }
    ).sort({score: {$meta: "textScore"}});
  },
  
  // 短语搜索
  phraseSearch: async () => {
    return db.articles.find({
      $text: {$search: "\"mongodb performance\""}  // 双引号内的短语
    });
  }
};
```

## 3. 复合索引

### 3.1 索引前缀

#### 3.1.1 前缀规则
```javascript
// 复合索引前缀
const indexPrefixes = {
  baseIndex: {status: 1, user_type: 1, created_at: -1},
  
  // 这个索引可以作为以下查询的索引前缀：
  prefixes: [
    {status: 1},                           // 前缀1
    {status: 1, user_type: 1},            // 前缀2
    {status: 1, user_type: 1, created_at: -1}  // 完整索引
  ],
  
  // 查询示例
  queries: {
    // ✅ 使用索引前缀
    query1: {status: "active"},
    query2: {status: "active", user_type: "premium"},
    query3: {status: "active", user_type: "premium", created_at: {$gte: date}},
    
    // ❌ 不使用索引前缀
    query4: {user_type: "premium"},        // 跳过status
    query5: {created_at: {$gte: date}}     // 跳过前缀字段
  }
};
```

#### 3.1.2 索引前缀优化
```javascript
// 查询模式分析和索引设计
const indexPrefixOptimization = {
  // 分析查询模式
  analyzeQueries: (queryLogs) => {
    const fieldFrequency = {};
    
    queryLogs.forEach(query => {
      const fields = Object.keys(query.filters || {});
      fields.forEach(field => {
        fieldFrequency[field] = (fieldFrequency[field] || 0) + 1;
      });
    });
    
    // 按频率排序字段
    return Object.entries(fieldFrequency)
      .sort(([,a], [,b]) => b - a)
      .map(([field]) => field);
  },
  
  // 设计最优复合索引
  designOptimalIndex: (fieldOrder) => {
    const prefixFields = fieldOrder.slice(0, 3); // 最多3个字段
    const indexKey = {};
    
    prefixFields.forEach(field => {
      indexKey[field] = 1; // 升序
    });
    
    return indexKey;
  }
};
```

### 3.2 索引交集

#### 3.2.1 索引交集原理
```javascript
// 索引交集示例
const indexIntersection = {
  // 创建独立索引
  createIndexes: () => {
    db.users.createIndex({status: 1});
    db.users.createIndex({user_type: 1});
    db.users.createIndex({created_at: -1});
  },
  
  // 查询会使用索引交集
  queryWithIntersection: async () => {
    return db.users.find({
      status: "active",
      user_type: "premium",
      created_at: {$gte: new Date("2024-01-01")}
    });
  },
  
  // 查看执行计划
  explainIntersection: async () => {
    return db.users.find({
      status: "active",
      user_type: "premium"
    }).explain("executionStats");
  }
};
```

#### 3.2.2 索引交集vs复合索引
```javascript
// 选择索引策略
const indexStrategyComparison = {
  // 复合索引策略
  compositeIndexStrategy: {
    createIndex: () => {
      db.users.createIndex({
        status: 1, user_type: 1, created_at: -1
      });
    },
    
    advantages: [
      "更少的索引查找",
      "更好的缓存局部性",
      "对复合查询更高效"
    ],
    
    disadvantages: [
      "占用更多存储空间",
      "写性能稍差",
      "只优化前缀查询"
    ]
  },
  
  // 索引交集策略
  indexIntersectionStrategy: {
    createIndexes: () => {
      db.users.createIndex({status: 1});
      db.users.createIndex({user_type: 1});
      db.users.createIndex({created_at: -1});
    },
    
    advantages: [
      "更少的存储空间",
      "对多种查询模式灵活",
      "写性能更好"
    ],
    
    disadvantages: [
      "查询时需要多个索引",
      "可能需要更多内存",
      "性能可能不如复合索引"
    ]
  }
};
```

### 3.3 排序优化

#### 3.3.1 排序索引设计
```javascript
// 排序优化原则
const sortOptimization = {
  // 单字段排序
  singleFieldSort: {
    createIndex: () => {
      db.users.createIndex({created_at: -1}); // 降序匹配降序排序
    },
    
    query: () => {
      return db.users.find()
        .sort({created_at: -1});  // 使用索引
    }
  },
  
  // 复合排序
  compositeSort: {
    createIndex: () => {
      // 排序字段必须与索引字段顺序一致
      db.users.createIndex({
        status: 1,              // 查询字段
        created_at: -1          // 排序字段（降序）
      });
    },
    
    query: () => {
      return db.users.find({status: "active"})
        .sort({created_at: -1});  // 使用索引
    }
  },
  
  // 混合排序
  mixedSort: {
    // 不同排序方向的索引
    createIndex: () => {
      db.users.createIndex({
        status: 1,
        created_at: -1,         // 降序
        last_login: 1           // 升序
      });
    },
    
    query: () => {
      return db.users.find({status: "active"})
        .sort({created_at: -1, last_login: 1});
    }
  }
};
```

#### 3.3.2 排序性能分析
```javascript
// 排序性能测试
const sortPerformanceTest = {
  // 测试不同排序策略
  testSortStrategies: async () => {
    const strategies = [
      {
        name: "无索引排序",
        query: () => db.users.find().sort({name: 1})
      },
      {
        name: "匹配排序索引",
        query: () => db.users.find().sort({created_at: -1})
      },
      {
        name: "部分匹配索引排序", 
        query: () => db.users.find({status: "active"}).sort({created_at: -1})
      }
    ];
    
    for (const strategy of strategies) {
      const startTime = performance.now();
      const result = await strategy.query().limit(1000).toArray();
      const endTime = performance.now();
      
      console.log(`${strategy.name}: ${(endTime - startTime).toFixed(2)}ms`);
      console.log(`返回文档数: ${result.length}`);
    }
  }
};
```

## 4. 索引优化策略

### 4.1 索引选择算法

#### 4.1.1 查询分析器
```javascript
// 查询模式分析器
const queryAnalyzer = {
  analyzeQueryPatterns: (queries) => {
    const patterns = {
      equalityFields: [],      // 等值查询字段
      rangeFields: [],         // 范围查询字段
      sortFields: [],          // 排序字段
      textFields: []           // 全文搜索字段
    };
    
    queries.forEach(query => {
      if (query.filter) {
        Object.entries(query.filter).forEach(([field, value]) => {
          if (typeof value === 'object' && value.$gte !== undefined) {
            patterns.rangeFields.push(field);
          } else {
            patterns.equalityFields.push(field);
          }
        });
      }
      
      if (query.sort) {
        patterns.sortFields.push(...Object.keys(query.sort));
      }
    });
    
    return patterns;
  },
  
  suggestIndexes: (patterns) => {
    const suggestions = [];
    
    // 1. 复合索引建议
    const compositeFields = [
      ...patterns.equalityFields,
      ...patterns.sortFields
    ];
    
    if (compositeFields.length > 0) {
      const compositeIndex = {};
      compositeFields.forEach(field => {
        compositeIndex[field] = 1;
      });
      
      suggestions.push({
        type: "composite",
        fields: compositeIndex,
        reason: "复合查询优化"
      });
    }
    
    // 2. 全文索引建议
    if (patterns.textFields.length > 0) {
      suggestions.push({
        type: "text",
        fields: patterns.textFields.reduce((acc, field) => {
          acc[field] = "text";
          return acc;
        }, {}),
        reason: "全文搜索优化"
      });
    }
    
    return suggestions;
  }
};
```

#### 4.1.2 动态索引管理
```javascript
// 动态索引管理器
const dynamicIndexManager = {
  // 基于查询日志自动创建索引
  autoIndexCreation: {
    analyzeQueryLog: async (collectionName) => {
      // 假设从查询日志中提取查询模式
      const queryLog = [
        {filter: {status: "active"}, sort: {created_at: -1}},
        {filter: {email: "user@example.com"}},
        {filter: {user_type: "premium"}, sort: {last_login: -1}}
      ];
      
      const analyzer = queryAnalyzer;
      const patterns = analyzer.analyzeQueryPatterns(queryLog);
      const suggestions = analyzer.suggestIndexes(patterns);
      
      return suggestions;
    },
    
    createIndexes: async (collectionName, suggestions) => {
      for (const suggestion of suggestions) {
        try {
          if (suggestion.type === "composite") {
            await db[collectionName].createIndex(suggestion.fields);
            console.log(`创建复合索引: ${JSON.stringify(suggestion.fields)}`);
          } else if (suggestion.type === "text") {
            await db[collectionName].createIndex(suggestion.fields);
            console.log(`创建全文索引: ${JSON.stringify(suggestion.fields)}`);
          }
        } catch (error) {
          console.error(`索引创建失败:`, error.message);
        }
      }
    }
  }
};
```

### 4.2 索引维护

#### 4.2.1 索引使用率分析
```javascript
// 索引使用率分析
const indexUsageAnalyzer = {
  // 分析索引使用情况
  analyzeIndexUsage: async (collectionName) => {
    const stats = await db[collectionName].aggregate([
      {$indexStats: {}},
      {
        $project: {
          name: 1,
          accesses: 1,
          hits: 1,
          misses: 1,
          lastAccess:  "$accesses.ops",
          hitRatio: {
            $cond: [
              {$eq: ["$accesses.hits", 0]},
              0,
              {$divide: ["$accesses.hits", "$accesses.ops"]}
            ]
          }
        }
      },
      {
        $sort: {accesses: -1}
      }
    ]);
    
    return stats.toArray();
  },
  
  // 建议删除未使用的索引
  suggestUnusedIndexes: async (collectionName) => {
    const stats = await this.analyzeIndexUsage(collectionName);
    const unusedIndexes = stats.filter(stat => 
      stat.accesses < 10 || stat.hitRatio < 0.1
    );
    
    const recommendations = unusedIndexes.map(index => ({
      indexName: index.name,
      reason: "使用率低",
      suggestions: "考虑删除以提高写性能"
    }));
    
    return recommendations;
  }
};
```

#### 4.2.2 索引碎片整理
```javascript
// 索引维护操作
const indexMaintenance = {
  // 重建索引
  rebuildIndex: async (collectionName, indexName) => {
    try {
      // 删除现有索引
      await db[collectionName].dropIndex(indexName);
      
      // 重建索引
      const indexes = await db[collectionName].getIndexes();
      const originalIndex = indexes.find(idx => idx.name === indexName);
      
      if (originalIndex) {
        const key = originalIndex.key;
        const options = {...originalIndex};
        delete options.name;
        delete options.v;
        
        await db[collectionName].createIndex(key, options);
        console.log(`索引重建完成: ${indexName}`);
      }
    } catch (error) {
      console.error(`索引重建失败: ${error.message}`);
    }
  },
  
  // 压缩索引
  compactIndex: async (collectionName) => {
    // MongoDB会自动处理索引压缩
    // 手动触发压缩（如果需要）
    await db.runCommand({
      compact: collectionName,
      force: false
    });
  }
};
```

### 4.3 索引策略优化

#### 4.3.1 覆盖查询索引
```javascript
// 覆盖查询索引设计
const coveringIndex = {
  // 设计覆盖查询的索引
  createCoveringIndex: async () => {
    // 对于查询：{email: "user@example.com"}
    // 选择返回字段：{_id: 0, email: 1, username: 1, status: 1}
    
    await db.users.createIndex({
      email: 1,        // 查询字段
      username: 1,     // 覆盖字段
      status: 1        // 覆盖字段
    });
    
    // 查询时指定返回字段
    const result = await db.users.find(
      {email: "user@example.com"},
      {_id: 0, email: 1, username: 1, status: 1}
    ).explain("executionStats");
    
    // 检查是否使用了覆盖查询
    const stage = result.executionStats.executionStages;
    const isCovering = stage.inputStage.stage === "IDHACK";
    
    console.log("使用覆盖查询:", isCovering);
    return isCovering;
  }
};
```

#### 4.3.2 部分索引优化
```javascript
// 部分索引策略
const partialIndexOptimization = {
  // 条件索引
  createPartialIndex: async () => {
    // 只为活跃用户创建索引
    await db.users.createIndex(
      {last_login: -1},
      {
        partialFilterExpression: {status: "active"},
        name: "active_users_last_login"
      }
    );
    
    // 只为付费用户创建索引
    await db.users.createIndex(
      {subscription_end: 1},
      {
        partialFilterExpression: {is_paid: true},
        name: "paid_users_subscription"
      }
    );
  },
  
  // 稀疏索引
  createSparseIndex: async () => {
    // 只为有手机号的用户创建索引
    await db.users.createIndex(
      {phone: 1},
      {sparse: true}
    );
  },
  
  // 使用部分索引的查询
  queryWithPartialIndex: async () => {
    // 这个查询会使用部分索引
    const activeUsers = await db.users.find({
      status: "active"
    }).sort({last_login: -1});
    
    // 这个查询不会使用部分索引
    const allUsers = await db.users.find({
      status: "active",
      is_paid: false
    }).sort({last_login: -1});
  }
};
```

## 5. 查询优化

### 5.1 查询模式优化

#### 5.1.1 查询计划分析
```javascript
// 查询计划分析器
const queryPlanAnalyzer = {
  // 分析查询执行计划
  analyzeQueryPlan: async (collectionName, query, sort = {}, limit = null) => {
    const explanation = await db[collectionName].find(query).sort(sort).limit(limit).explain("executionStats");
    
    const analysis = {
      stage: explanation.executionStats.executionStages.stage,
      totalDocuments: explanation.executionStats.totalDocumentsReturned,
      totalObjects: explanation.executionStats.totalObjectsExamined,
      indexesUsed: explanation.executionStats.executionStages.inputStage?.indexName,
      executionTime: explanation.executionStats.executionTimeMillis,
      indexBounds: explanation.executionStats.executionStages.inputStage?.indexBounds
    };
    
    return analysis;
  },
  
  // 对比不同查询策略
  compareQueryStrategies: async () => {
    const query = {status: "active", created_at: {$gte: new Date("2024-01-01")}};
    
    const strategies = [
      {name: "无排序", sort: {}},
      {name: "按时间排序", sort: {created_at: -1}},
      {name: "按用户名排序", sort: {username: 1}}
    ];
    
    for (const strategy of strategies) {
      const analysis = await this.analyzeQueryPlan("users", query, strategy.sort);
      console.log(`${strategy.name}:`, {
        stage: analysis.stage,
        docsExamined: analysis.totalObjects,
        indexUsed: analysis.indexesUsed,
        executionTime: analysis.executionTime
      });
    }
  }
};
```

#### 5.1.2 查询重写优化
```javascript
// 查询重写和优化
const queryRewriter = {
  // 优化查询结构
  optimizeQueryStructure: (originalQuery) => {
    const optimized = {...originalQuery};
    
    // 1. 移除不必要的$and
    if (optimized.$and) {
      const conditions = optimized.$and.filter(condition => 
        Object.keys(condition).length > 0
      );
      optimized.$and = conditions;
      
      // 如果只有一个条件，展开
      if (conditions.length === 1) {
        return conditions[0];
      }
    }
    
    // 2. 优化范围查询
    if (optimized.date) {
      const dateFilter = optimized.date;
      if (dateFilter.$gte && dateFilter.$lte) {
        // 确保日期范围合理
        const start = new Date(dateFilter.$gte);
        const end = new Date(dateFilter.$lte);
        
        if (start > end) {
          throw new Error("无效的日期范围");
        }
      }
    }
    
    return optimized;
  },
  
  // 使用聚合优化复杂查询
  rewriteWithAggregation: async (query) => {
    // 将复杂查询转换为聚合管道
    const pipeline = [];
    
    // 1. 添加查询条件
    if (query.status) {
      pipeline.push({$match: {status: query.status}});
    }
    
    if (query.created_at) {
      pipeline.push({$match: {created_at: query.created_at}});
    }
    
    // 2. 添加排序
    if (query.sort) {
      const sortStage = {};
      Object.entries(query.sort).forEach(([field, direction]) => {
        sortStage[field] = direction;
      });
      pipeline.push({$sort: sortStage});
    }
    
    // 3. 添加分页
    if (query.skip) {
      pipeline.push({$skip: query.skip});
    }
    
    if (query.limit) {
      pipeline.push({$limit: query.limit});
    }
    
    // 4. 添加投影
    if (query.projection) {
      pipeline.push({$project: query.projection});
    }
    
    return pipeline;
  }
};
```

### 5.2 聚合优化

#### 5.2.1 聚合管道优化
```javascript
// 聚合优化策略
const aggregationOptimizer = {
  // 早期过滤
  earlyFiltering: async () => {
    // ❌ 错误的做法
    const badPipeline = [
      {$unwind: "$orders"},                    // 先展开
      {$group: {_id: "$_id", total: {$sum: 1}}}, // 后聚合
      {$match: {total: {$gte: 5}}}             // 最后过滤
    ];
    
    // ✅ 正确的做法
    const goodPipeline = [
      {$match: {status: "active"}},            // 早期过滤
      {$unwind: "$orders"},
      {$group: {_id: "$_id", total: {$sum: 1}}},
      {$match: {total: {$gte: 5}}}
    ];
    
    return {badPipeline, goodPipeline};
  },
  
  // 使用索引优化聚合
  indexOptimizedAggregation: async () => {
    // 确保聚合使用索引
    const optimizedPipeline = [
      {
        $match: {
          created_at: {$gte: new Date("2024-01-01")} // 使用索引
        }
      },
      {
        $sort: {created_at: -1}  // 利用索引排序
      },
      {
        $group: {
          _id: {
            year: {$year: "$created_at"},
            month: {$month: "$created_at"}
          },
          count: {$sum: 1},
          total_amount: {$sum: "$amount"}
        }
      }
    ];
    
    const result = await db.orders.aggregate(optimizedPipeline);
    return result.toArray();
  },
  
  // 分片聚合优化
  shardedAggregationOptimization: async () => {
    // 使用$match作为第一阶段（可下推）
    const pipeline = [
      {
        $match: {
          tenant_id: ObjectId("64a7b123..."),  // 分片键
          created_at: {$gte: new Date("2024-01-01")}
        }
      },
      // 其他阶段会发送到各分片执行
      {
        $group: {
          _id: "$category",
          count: {$sum: 1}
        }
      },
      {
        $sort: {count: -1}
      },
      {
        $limit: 10
      }
    ];
    
    return db.products.aggregate(pipeline);
  }
};
```

#### 5.2.2 聚合性能分析
```javascript
// 聚合性能监控
const aggregationProfiler = {
  // 监控聚合查询性能
  profileAggregation: async (pipeline, collectionName) => {
    const startTime = performance.now();
    const result = await db[collectionName].aggregate(pipeline).toArray();
    const endTime = performance.now();
    
    return {
      executionTime: endTime - startTime,
      documentCount: result.length,
      pipeline: pipeline
    };
  },
  
  // 比较聚合策略
  compareAggregationStrategies: async () => {
    const baseQuery = {
      created_at: {$gte: new Date("2024-01-01")},
      status: "completed"
    };
    
    const strategies = [
      {
        name: "基础查询",
        pipeline: [{$match: baseQuery}]
      },
      {
        name: "带索引排序",
        pipeline: [
          {$match: baseQuery},
          {$sort: {created_at: -1}}
        ]
      },
      {
        name: "分组统计",
        pipeline: [
          {$match: baseQuery},
          {
            $group: {
              _id: "$category",
              count: {$sum: 1},
              total: {$sum: "$amount"}
            }
          }
        ]
      }
    ];
    
    for (const strategy of strategies) {
      const profile = await this.profileAggregation(strategy.pipeline, "orders");
      console.log(`${strategy.name}: ${profile.executionTime.toFixed(2)}ms`);
    }
  }
};
```

### 5.3 分页优化

#### 5.3.1 传统分页问题
```javascript
// 分页性能问题
const paginationProblems = {
  // OFFSET分页问题
  offsetPaginationProblem: async (page = 1, limit = 20) => {
    const skip = (page - 1) * limit;
    
    // ❌ 问题：随着页数增加，skip操作越来越慢
    const startTime = performance.now();
    
    const result = await db.users.find({status: "active"})
      .sort({created_at: -1})
      .skip(skip)
      .limit(limit)
      .toArray();
    
    const endTime = performance.now();
    
    return {
      page,
      limit,
      documentsFound: result.length,
      executionTime: endTime - startTime,
      skipOperations: skip
    };
  }
};
```

#### 5.3.2 游标分页优化
```javascript
// 游标分页优化
const cursorPaginationOptimization = {
  // 基于ID的游标分页
  idBasedPagination: async (lastId = null, limit = 20) => {
    const query = {status: "active"};
    
    // 如果有游标，添加查询条件
    if (lastId) {
      query._id = {$gt: ObjectId(lastId)};
    }
    
    const result = await db.users.find(query)
      .sort({_id: 1})
      .limit(limit)
      .toArray();
    
    // 返回下一批的游标
    const nextCursor = result.length > 0 ? 
      result[result.length - 1]._id.toString() : null;
    
    return {
      data: result,
      nextCursor,
      hasMore: result.length === limit
    };
  },
  
  // 基于时间戳的游标分页
  timeBasedPagination: async (lastTimestamp = null, limit = 20) => {
    const query = {status: "active"};
    
    if (lastTimestamp) {
      query.created_at = {$gt: new Date(lastTimestamp)};
    }
    
    const result = await db.users.find(query)
      .sort({created_at: 1})
      .limit(limit)
      .toArray();
    
    const nextCursor = result.length > 0 ? 
      result[result.length - 1].created_at.getTime() : null;
    
    return {
      data: result,
      nextCursor,
      hasMore: result.length === limit
    };
  },
  
  // 无限滚动分页
  infiniteScrollPagination: async (cursor, limit = 20) => {
    const query = {status: "active"};
    
    if (cursor) {
      const {timestamp, id} = JSON.parse(cursor);
      query.$or = [
        {created_at: {$gt: new Date(timestamp)}},
        {
          created_at: new Date(timestamp),
          _id: {$gt: ObjectId(id)}
        }
      ];
    }
    
    const result = await db.users.find(query)
      .sort({created_at: 1, _id: 1})
      .limit(limit)
      .toArray();
    
    const nextCursor = result.length > 0 ? JSON.stringify({
      timestamp: result[result.length - 1].created_at.getTime(),
      id: result[result.length - 1]._id.toString()
    }) : null;
    
    return {
      data: result,
      nextCursor,
      hasMore: result.length === limit
    };
  }
};
```

## 6. 性能监控

### 6.1 查询性能监控

#### 6.1.1 慢查询日志
```javascript
// 慢查询监控
const slowQueryMonitoring = {
  // 启用慢查询日志
  enableSlowQueryLog: async () => {
    await db.adminCommand({
      setParameter: 1,
      slowms: 100,              // 100ms以上的查询记录
      profile: 2                // 记录所有慢查询
    });
  },
  
  // 分析慢查询
  analyzeSlowQueries: async () => {
    const slowQueries = await db.system.profile.find({
      ts: {$gte: new Date(Date.now() - 24 * 60 * 60 * 1000)} // 过去24小时
    }).sort({ts: -1}).limit(100).toArray();
    
    const analysis = slowQueries.map(query => ({
      timestamp: query.ts,
      duration: query.millis,
      collection: query.ns,
      operation: query.op,
      query: query.command || query.query,
      indexUsed: query.cursor?.id ? "yes" : "no",
      documentsReturned: query.nreturned || query.documentsReturned
    }));
    
    return analysis;
  },
  
  // 慢查询统计
  getSlowQueryStats: async () => {
    const pipeline = [
      {
        $match: {
          ts: {$gte: new Date(Date.now() - 24 * 60 * 60 * 1000)}
        }
      },
      {
        $group: {
          _id: {
            collection: "$ns",
            operation: "$op"
          },
          count: {$sum: 1},
          avgDuration: {$avg: "$millis"},
          maxDuration: {$max: "$millis"},
          totalDuration: {$sum: "$millis"}
        }
      },
      {
        $sort: {avgDuration: -1}
      },
      {
        $limit: 10
      }
    ];
    
    return db.system.profile.aggregate(pipeline).toArray();
  }
};
```

#### 6.1.2 实时性能监控
```javascript
// 实时性能监控
const realTimePerformance = {
  // 当前操作监控
  getCurrentOperations: async () => {
    const currentOps = await db.adminCommand({
      currentOp: 1,
      $all: false,
      active: true
    });
    
    return currentOps.inprog.map(op => ({
      opid: op.opid,
      operation: op.op,
      collection: op.ns,
      duration: (Date.now() - op.secs_running * 1000),
      query: op.command || op.query
    }));
  },
  
  // 锁监控
  getLockStats: async () => {
    const lockStats = await db.adminCommand({
      serverStatus: 1,
      locks: 1
    });
    
    return lockStats.locks;
  },
  
  // 连接数监控
  getConnectionStats: async () => {
    const stats = await db.adminCommand({
      serverStatus: 1,
      connections: 1
    });
    
    return {
      current: stats.connections.current,
      available: stats.connections.available,
      totalCreated: stats.connections.totalCreated
    };
  }
};
```

### 6.2 索引性能分析

#### 6.2.1 索引效率分析
```javascript
// 索引效率分析
const indexEfficiencyAnalyzer = {
  // 分析索引效率
  analyzeIndexEfficiency: async (collectionName) => {
    const indexes = await db[collectionName].aggregate([
      {$indexStats: {}},
      {
        $project: {
          name: 1,
          accesses: "$accesses.ops",
          hits: "$accesses.hits",
          misses: "$accesses.misses",
          hitRatio: {
            $cond: [
              {$eq: ["$accesses.hits", 0]},
              0,
              {$divide: ["$accesses.hits", "$accesses.ops"]}
            ]
          },
          efficiency: {
            $multiply: [
              {
                $cond: [
                  {$eq: ["$accesses.hits", 0]},
                  0,
                  {$divide: ["$accesses.hits", "$accesses.ops"]}
                ]
              },
              100
            ]
          }
        }
      },
      {
        $sort: {accesses: -1}
      }
    ]);
    
    return indexes.toArray();
  },
  
  // 索引推荐系统
  recommendIndexes: async (collectionName) => {
    // 分析最近的查询
    const recentQueries = await db.system.profile.find({
      ns: `${dbName}.${collectionName}`,
      ts: {$gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)} // 最近7天
    }).toArray();
    
    const queryPatterns = {};
    
    recentQueries.forEach(query => {
      const command = query.command || {};
      const filter = command.filter || {};
      const sort = command.sort || {};
      
      const pattern = {
        filter: Object.keys(filter).sort().join(','),
        sort: Object.keys(sort).sort().join(','),
        operation: query.op
      };
      
      const key = `${pattern.filter}|${pattern.sort}`;
      queryPatterns[key] = (queryPatterns[key] || 0) + 1;
    });
    
    // 生成索引推荐
    const recommendations = [];
    Object.entries(queryPatterns)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)
      .forEach(([pattern, count]) => {
        const [filter, sort] = pattern.split('|');
        const indexSpec = {};
        
        // 添加过滤字段
        filter.split(',').forEach(field => {
          if (field) indexSpec[field] = 1;
        });
        
        // 添加排序字段
        sort.split(',').forEach(field => {
          if (field && !indexSpec[field]) indexSpec[field] = 1;
        });
        
        recommendations.push({
          indexSpec,
          estimatedBenefit: count,
          reason: `此查询模式出现${count}次`
        });
      });
    
    return recommendations;
  }
};
```

### 6.3 系统性能监控

#### 6.3.1 服务器状态监控
```javascript
// 服务器性能监控
const serverPerformance = {
  // 获取服务器状态
  getServerStatus: async () => {
    const status = await db.adminCommand({serverStatus: 1});
    
    return {
      uptime: status.uptime,
      connections: {
        current: status.connections.current,
        available: status.connections.available
      },
      globalLock: {
        totalTime: status.globalLock.totalTime,
        lockTime: status.globalLock.lockTime
      },
      opcounters: status.opcounters,
      opcountersRepl: status.opcountersRepl,
      mem: status.mem,
      metrics: status.metrics
    };
  },
  
  // 数据库统计信息
  getDatabaseStats: async () => {
    const stats = await db.stats();
    
    return {
      collections: stats.collections,
      objects: stats.objects,
      dataSize: stats.dataSize,
      indexSize: stats.indexSize,
      storageSize: stats.storageSize,
      fileSize: stats.fileSize,
      avgObjSize: stats.avgObjSize
    };
  },
  
  // 集合统计信息
  getCollectionStats: async (collectionName) => {
    const stats = await db[collectionName].stats();
    
    return {
      count: stats.count,
      size: stats.size,
      avgObjSize: stats.avgObjSize,
      storageSize: stats.storageSize,
      indexes: Object.keys(stats.indexStats || {}).length,
      totalIndexSize: stats.totalIndexSize,
      indexSizes: stats.indexSizes
    };
  }
};
```

#### 6.3.2 性能基线和告警
```javascript
// 性能基线管理
const performanceBaseline = {
  // 创建性能基线
  createBaseline: async () => {
    const baseline = {
      timestamp: new Date(),
      serverStatus: await serverPerformance.getServerStatus(),
      dbStats: await serverPerformance.getDatabaseStats(),
      indexStats: {}
    };
    
    // 获取所有集合的索引统计
    const collections = await db.listCollections().toArray();
    for (const collection of collections) {
      const name = collection.name;
      const indexes = await db[name].aggregate([{$indexStats: {}}]).toArray();
      baseline.indexStats[name] = indexes;
    }
    
    return baseline;
  },
  
  // 性能对比分析
  compareWithBaseline: async (baseline) => {
    const current = await serverPerformance.getServerStatus();
    
    const comparison = {
      connections: {
        baseline: baseline.serverStatus.connections.current,
        current: current.connections.current,
        change: current.connections.current - baseline.serverStatus.connections.current
      },
      memory: {
        baseline: baseline.serverStatus.mem.resident,
        current: current.mem.resident,
        change: current.mem.resident - baseline.serverStatus.mem.resident
      },
      operations: {
        baseline: baseline.serverStatus.opcounters.total,
        current: current.opcounters.total,
        change: current.opcounters.total - baseline.serverStatus.opcounters.total
      }
    };
    
    return comparison;
  },
  
  // 性能告警
  performanceAlerts: async (baseline) => {
    const comparison = await this.compareWithBaseline(baseline);
    const alerts = [];
    
    // 检查连接数告警
    if (comparison.connections.change > 100) {
      alerts.push({
        type: "CONNECTION_INCREASE",
        severity: "warning",
        message: `连接数增长${comparison.connections.change}`,
        baseline: comparison.connections.baseline,
        current: comparison.connections.current
      });
    }
    
    // 检查内存使用告警
    if (comparison.memory.change > 1000) { // MB
      alerts.push({
        type: "MEMORY_INCREASE", 
        severity: "warning",
        message: `内存使用增长${comparison.memory.change}MB`,
        baseline: comparison.memory.baseline,
        current: comparison.memory.current
      });
    }
    
    return alerts;
  }
};
```

---

*第4章全面介绍了MongoDB索引与性能优化的核心概念和实践技巧。通过合理的索引设计、查询优化和持续的性能监控，您可以确保MongoDB应用程序始终保持最佳性能状态。*