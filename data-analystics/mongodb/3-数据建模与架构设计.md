# 第3章：数据建模与架构设计

## 目录
1. [数据建模原则](#1-数据建模原则)
2. [模式设计策略](#2-模式设计策略)
3. [文档结构设计](#3-文档结构设计)
4. [关系建模](#4-关系建模)
5. [架构模式](#5-架构模式)
6. [分片设计](#6-分片设计)

## 1. 数据建模原则

### 1.1 MongoDB数据建模特点

MongoDB的文档模型提供了关系型数据库无法比拟的灵活性：

#### 1.1.1 模式灵活性
```javascript
// 同一集合中可以有不同结构的文档
db.users.insertMany([
  {
    _id: ObjectId("64a7b1234567890abcdef1234"),
    name: "John Doe",
    email: "john@example.com",
    age: 30,
    address: {city: "New York", country: "USA"}
  },
  {
    _id: ObjectId("64a7b1234567890abcdef1235"),
    name: "Jane Smith",
    email: "jane@example.com",
    // 可以省略某些字段
    skills: ["mongodb", "javascript", "react"],
    social_media: {
      twitter: "@janesmith",
      linkedin: "jane-smith-123"
    }
  }
]);
```

#### 1.1.2 嵌入vs引用
```javascript
// 嵌入模式 - 适合强一致性的小数据量场景
{
  _id: ObjectId("order1"),
  customer_name: "John Doe",
  customer_email: "john@example.com",
  items: [                    // 嵌入订单项
    {product_id: "prod1", quantity: 2, price: 25.99},
    {product_id: "prod2", quantity: 1, price: 99.99}
  ],
  shipping_address: {
    street: "123 Main St",
    city: "New York",
    zipCode: "10001"
  },
  order_date: new Date()
}

// 引用模式 - 适合独立管理的大数据集
{
  _id: ObjectId("order1"),
  customer_id: ObjectId("customer123"),
  item_ids: [ObjectId("item1"), ObjectId("item2")],
  order_date: new Date(),
  status: "processing"
}
```

### 1.2 建模决策因素

#### 1.2.1 数据一致性需求
```javascript
// 强一致性需求 - 嵌入模式
const orderSchema = {
  _id: ObjectId(),
  order_number: String,
  customer: {                  // 嵌入客户信息
    customer_id: ObjectId(),
    name: String,
    email: String
  },
  items: [{                    // 嵌入订单项
    product_id: ObjectId(),
    quantity: Number,
    price: Number
  }],
  total_amount: Number,
  order_date: Date,
  status: String
};

// 最终一致性需求 - 引用模式
const orderSchemaRef = {
  _id: ObjectId(),
  order_number: String,
  customer_id: ObjectId(),     // 引用客户ID
  item_ids: [ObjectId()],      // 引用订单项ID
  total_amount: Number,
  order_date: Date,
  status: String
};
```

#### 1.2.2 数据访问模式
```javascript
// 频繁读取完整订单信息 - 嵌入
const queryPattern1 = {
  name: "getCompleteOrder",
  frequency: "high",
  query: "find order by order_id and return complete order with all details"
};

// 需要单独管理订单项 - 引用
const queryPattern2 = {
  name: "getOrderItems",
  frequency: "medium", 
  query: "find order items by order_id for inventory management"
};
```

### 1.3 性能考虑

#### 1.3.1 文档大小限制
```javascript
// MongoDB文档大小限制为16MB
// 避免创建过大的文档

// ❌ 避免 - 过大数组
const badDocument = {
  user_id: ObjectId("user123"),
  activities: [                // 活动历史可能无限增长
    // 假设每个活动100字节，如果用户有10万个活动
    // 文档将超过10MB
    ...100000activities
  ]
};

// ✅ 推荐 - 时间分片
const goodDocument = {
  user_id: ObjectId("user123"),
  period: "2024-01",           // 按月分片
  activities: [...],           // 控制数量
  next_period: "2024-02"
};
```

#### 1.3.2 写入性能
```javascript
// 高频更新字段应该独立
const userProfile = {
  _id: ObjectId(),
  user_id: ObjectId("user123"),
  basic_info: {                // 很少更新的基本信息
    name: String,
    email: String,
    birth_date: Date
  },
  preferences: {               // 可能频繁更新的偏好设置
    theme: String,
    language: String,
    notifications: Boolean
  },
  stats: {                     // 经常更新的统计数据
    login_count: Number,
    last_login: Date,
    activity_score: Number
  }
};
```

## 2. 模式设计策略

### 2.1 反规范化模式

#### 2.1.1 读取优化
```javascript
// 为查询优化进行反规范化
const productSchema = {
  _id: ObjectId(),
  name: String,
  category_id: ObjectId(),
  category_name: String,       // 反规范化的分类名称
  brand_id: ObjectId(),
  brand_name: String,          // 反规范化的品牌名称
  price: Number,
  rating: {
    average: Number,
    count: Number
  },
  inventory: {
    total_quantity: Number,
    warehouse_locations: [String]
  }
};

// 查询时不需要联表查询
const productQuery = db.products.find({
  category_name: "Electronics",
  "rating.average": {$gte: 4.0}
});
```

#### 2.1.2 数据维护策略
```javascript
// 应用程序维护反规范化数据
class ProductService {
  async updateCategoryName(categoryId, newName) {
    // 更新分类表
    await db.categories.updateOne(
      {_id: categoryId},
      {$set: {name: newName}}
    );
    
    // 更新所有相关产品的反规范化字段
    await db.products.updateMany(
      {category_id: categoryId},
      {$set: {category_name: newName}}
    );
  }
}
```

### 2.2 时间序列模式

#### 2.2.1 时间分片模式
```javascript
// 按时间范围分片
const timeSeriesSchema = {
  _id: ObjectId(),
  sensor_id: ObjectId(),
  measurement_type: String,     // temperature, humidity, pressure
  value: Number,
  timestamp: Date,
  metadata: {
    location: String,
    unit: String,
    accuracy: Number
  },
  // 分片键
  date_bucket: {               // 用于分片的时间桶
    year: Number,
    month: Number,
    day: Number
  }
};

// 插入数据时计算时间桶
function insertMeasurement(sensorData) {
  const date = new Date(sensorData.timestamp);
  const date_bucket = {
    year: date.getUTCFullYear(),
    month: date.getUTCMonth() + 1,
    day: date.getUTCDate()
  };
  
  return db.measurements.insertOne({
    ...sensorData,
    date_bucket
  });
}
```

#### 2.2.2 聚合模式
```javascript
// 使用聚合进行时间序列分析
const aggregateTimeSeries = (sensorId, startDate, endDate) => {
  return db.measurements.aggregate([
    // 时间筛选
    {
      $match: {
        sensor_id: sensorId,
        timestamp: {$gte: startDate, $lte: endDate}
      }
    },
    
    // 按小时分组
    {
      $group: {
        _id: {
          year: {$year: "$timestamp"},
          month: {$month: "$timestamp"},
          day: {$dayOfMonth: "$timestamp"},
          hour: {$hour: "$timestamp"}
        },
        count: {$sum: 1},
        avg_value: {$avg: "$value"},
        min_value: {$min: "$value"},
        max_value: {$max: "$value"}
      }
    },
    
    // 按时间排序
    {
      $sort: {"_id.year": 1, "_id.month": 1, "_id.day": 1, "_id.hour": 1}
    }
  ]);
};
```

### 2.3 版本控制模式

#### 2.3.1 文档版本控制
```javascript
// 模式1: 内联版本字段
const versionedDocument1 = {
  _id: ObjectId(),
  version: 2,                  // 当前版本号
  name: String,
  email: String,
  // v1 字段
  address: String,
  // v2 新增字段
  phone: String,
  updated_at: Date,
  updated_by: ObjectId()
};

// 模式2: 版本历史表
const currentDocument = {
  _id: ObjectId(),
  current_version: 2,
  document_data: {
    name: String,
    email: String,
    phone: String
  }
};

const versionHistory = {
  _id: ObjectId(),
  document_id: ObjectId("doc123"),  // 引用主文档
  version: Number,
  changed_by: ObjectId(),
  changed_at: Date,
  change_type: String,              // create, update, delete
  previous_data: Object,            // 变更前数据
  new_data: Object                  // 变更后数据
};
```

#### 2.3.2 架构迁移
```javascript
// 数据迁移脚本
async function migrateDocumentVersion() {
  // 1. 创建新版本集合
  db.createCollection("users_v2");
  
  // 2. 获取所有v1文档
  const v1Documents = await db.users.find().toArray();
  
  // 3. 转换并插入v2文档
  const v2Documents = v1Documents.map(doc => {
    return {
      _id: doc._id,
      version: 2,
      // 迁移字段
      name: doc.name,
      email: doc.email,
      phone: doc.phone || null,      // 新增字段
      preferences: doc.preferences || {}, // 重组偏好设置
      updated_at: new Date(),
      updated_by: doc.created_by
    };
  });
  
  await db.users_v2.insertMany(v2Documents);
  
  // 4. 验证迁移
  const v1Count = await db.users.countDocuments();
  const v2Count = await db.users_v2.countDocuments();
  
  if (v1Count === v2Count) {
    console.log("迁移成功");
    // 删除v1集合或重命名
  } else {
    console.log("迁移失败，数据不匹配");
  }
}
```

## 3. 文档结构设计

### 3.1 嵌套文档设计

#### 3.1.1 深度嵌套vs扁平结构
```javascript
// 深度嵌套结构
const deeplyNestedDoc = {
  _id: ObjectId(),
  user: {
    profile: {
      personal: {
        name: String,
        birth_date: Date,
        gender: String
      },
      contact: {
        email: String,
        phone: String,
        address: {
          street: String,
          city: String,
          country: String
        }
      }
    }
  }
};

// 扁平结构（推荐）
const flatDoc = {
  _id: ObjectId(),
  name: String,
  birth_date: Date,
  gender: String,
  email: String,
  phone: String,
  address_street: String,
  address_city: String,
  address_country: String
};
```

#### 3.1.2 数组 vs 对象
```javascript
// 小规模数组 - 嵌入
const userWithTags = {
  _id: ObjectId(),
  name: String,
  skills: ["javascript", "mongodb", "react"],  // 小数组，嵌入
  social_links: {                              // 对象，结构固定
    twitter: String,
    linkedin: String,
    github: String
  }
};

// 大规模数组 - 分表
const userSchema = {
  _id: ObjectId(),
  name: String,
  skill_ids: [ObjectId()],     // 引用技能表
  social_link_ids: [ObjectId()] // 引用社交链接表
};

// 技能表
const skillSchema = {
  _id: ObjectId(),
  user_id: ObjectId(),
  skill_name: String,
  proficiency_level: Number,    // 1-5
  certified: Boolean
};
```

### 3.2 多态模式

#### 3.2.1 类型字段模式
```javascript
// 使用类型字段支持多态
const polymorphicDocument = {
  _id: ObjectId(),
  type: "vehicle",              // 类型标识
  common_fields: {
    id: String,
    name: String,
    manufacturer: String,
    year: Number
  },
  vehicle_specific: {           // 车辆特定字段
    wheels: Number,
    fuel_type: String,
    transmission: String
  },
  metadata: {
    created_at: Date,
    updated_at: Date,
    version: Number
  }
};

// 查询特定类型
const findCars = () => {
  return db.vehicles.find({
    type: "vehicle",
    "vehicle_specific.wheels": 4
  });
};
```

#### 3.2.2 继承模式
```javascript
// 基础文档结构
const baseEntity = {
  _id: ObjectId(),
  type: String,                  // entity type
  created_at: Date,
  updated_at: Date,
  audit_log: [{
    action: String,
    user_id: ObjectId,
    timestamp: Date,
    changes: Object
  }]
};

// 特化实体
const specializedEntity = {
  ...baseEntity,
  type: "product",
  product_data: {
    name: String,
    category: String,
    price: Number,
    variants: [{
      sku: String,
      attributes: Object
    }]
  }
};
```

### 3.3 灵活模式

#### 3.3.1 动态属性模式
```javascript
// 支持动态属性的设计
const flexibleProduct = {
  _id: ObjectId(),
  name: String,
  category: String,
  base_attributes: {
    price: Number,
    sku: String,
    in_stock: Boolean
  },
  custom_attributes: Object,      // 动态属性
  attribute_schema: {             // 属性定义
    material: {type: "string", required: true},
    color: {type: "string", required: false},
    dimensions: {type: "object", required: false}
  }
};

// 使用示例
const laptopProduct = {
  _id: ObjectId(),
  name: "MacBook Pro",
  category: "laptop",
  base_attributes: {
    price: 1999.99,
    sku: "MBP-2024-001",
    in_stock: true
  },
  custom_attributes: {
    material: "aluminum",
    color: "space gray",
    screen_size: 16,
    ram: "16GB",
    storage: "512GB SSD"
  },
  attribute_schema: {
    material: {type: "string", required: true},
    screen_size: {type: "number", required: true},
    ram: {type: "string", required: true}
  }
};
```

#### 3.3.2 配置模式
```javascript
// 配置文档设计
const applicationConfig = {
  _id: ObjectId(),
  environment: String,           // development, staging, production
  application_name: String,
  version: String,
  config_sections: {
    database: {
      host: String,
      port: Number,
      db_name: String,
      options: Object
    },
    cache: {
      type: String,             // redis, memcached
      host: String,
      ttl: Number
    },
    logging: {
      level: String,
      format: String,
      outputs: [String]
    }
  },
  secrets: Object,               // 加密存储的敏感信息
  metadata: {
    created_by: ObjectId(),
    updated_by: ObjectId(),
    last_deployed: Date
  }
};
```

## 4. 关系建模

### 4.1 一对一关系

#### 4.1.1 嵌入模式
```javascript
// 用户和用户档案一对一关系
const userWithProfile = {
  _id: ObjectId(),
  username: String,
  email: String,
  password_hash: String,
  profile: {                     // 嵌入档案信息
    first_name: String,
    last_name: String,
    bio: String,
    avatar_url: String,
    preferences: Object
  },
  created_at: Date,
  updated_at: Date
};

// 查询包含档案的用户
const getUserWithProfile = (userId) => {
  return db.users.findOne({_id: userId});
};
```

#### 4.1.2 引用模式
```javascript
// 用户和档案分离存储
const user = {
  _id: ObjectId(),
  username: String,
  email: String,
  password_hash: String,
  profile_id: ObjectId(),        // 引用档案
  created_at: Date
};

const userProfile = {
  _id: ObjectId(),
  user_id: ObjectId(),           // 反向引用
  first_name: String,
  last_name: String,
  bio: String,
  avatar_url: String,
  preferences: Object
};

// 使用lookup查询
const getUserWithProfile = (userId) => {
  return db.users.aggregate([
    {
      $match: {_id: userId}
    },
    {
      $lookup: {
        from: "user_profiles",
        localField: "profile_id",
        foreignField: "_id",
        as: "profile"
      }
    },
    {
      $unwind: "$profile"
    }
  ]);
};
```

### 4.2 一对多关系

#### 4.2.1 数组引用模式
```javascript
// 用户和订单的一对多关系
const user = {
  _id: ObjectId(),
  username: String,
  email: String,
  order_ids: [ObjectId()]        // 引用用户的所有订单
};

const order = {
  _id: ObjectId(),
  user_id: ObjectId(),           // 引用用户
  order_number: String,
  total_amount: Number,
  status: String,
  order_date: Date
};

// 查询用户的订单
const getUserOrders = (userId) => {
  return db.orders.find({user_id: userId})
    .sort({order_date: -1});
};

// 批量查询用户和订单
const getUsersWithOrders = () => {
  return db.users.aggregate([
    {
      $lookup: {
        from: "orders",
        localField: "_id",
        foreignField: "user_id",
        as: "orders"
      }
    },
    {
      $project: {
        username: 1,
        email: 1,
        order_count: {$size: "$orders"},
        orders: {
          $slice: ["$orders", 5]  // 只返回前5个订单
        }
      }
    }
  ]);
};
```

#### 4.2.2 子文档模式
```javascript
// 用户和地址的一对多关系（使用嵌入）
const userWithAddresses = {
  _id: ObjectId(),
  username: String,
  email: String,
  addresses: [{                  // 嵌入多个地址
    _id: ObjectId(),
    type: String,                // home, work, billing
    street: String,
    city: String,
    country: String,
    is_default: Boolean
  }],
  created_at: Date
};

// 查询用户的默认地址
const getDefaultAddress = (userId) => {
  return db.users.findOne(
    {_id: userId},
    {addresses: {$elemMatch: {is_default: true}}}
  );
};
```

### 4.3 多对多关系

#### 4.3.1 双向引用模式
```javascript
// 用户和角色多对多关系
const user = {
  _id: ObjectId(),
  username: String,
  role_ids: [ObjectId()]         // 用户拥有的角色
};

const role = {
  _id: ObjectId(),
  name: String,
  description: String,
  user_ids: [ObjectId()]         // 拥有该角色的用户
};

// 查询用户的角色
const getUserRoles = (userId) => {
  return db.roles.find({
    user_ids: userId
  });
};

// 双向维护一致性
const assignRoleToUser = async (userId, roleId) => {
  const session = db.client.startSession();
  
  try {
    await session.withTransaction(async () => {
      // 更新用户角色列表
      await db.users.updateOne(
        {_id: userId},
        {$addToSet: {role_ids: roleId}},
        {session}
      );
      
      // 更新角色用户列表
      await db.roles.updateOne(
        {_id: roleId},
        {$addToSet: {user_ids: userId}},
        {session}
      );
    });
  } finally {
    await session.endSession();
  }
};
```

#### 4.3.2 关联表模式
```javascript
// 使用中间表实现多对多关系
const user = {
  _id: ObjectId(),
  username: String,
  email: String
};

const permission = {
  _id: ObjectId(),
  name: String,
  description: String,
  resource: String,
  action: String
};

const userPermission = {         // 关联表
  _id: ObjectId(),
  user_id: ObjectId(),
  permission_id: ObjectId(),
  granted_at: Date,
  granted_by: ObjectId(),
  expires_at: Date
};

// 查询用户权限
const getUserPermissions = (userId) => {
  return db.userPermissions.aggregate([
    {
      $match: {user_id: userId}
    },
    {
      $lookup: {
        from: "permissions",
        localField: "permission_id",
        foreignField: "_id",
        as: "permission"
      }
    },
    {
      $unwind: "$permission"
    },
    {
      $project: {
        permission_name: "$permission.name",
        resource: "$permission.resource",
        action: "$permission.action",
        granted_at: 1
      }
    }
  ]);
};
```

## 5. 架构模式

### 5.1 分层架构

#### 5.1.1 CQRS模式
```javascript
// 命令查询责任分离
// 写入模型 - 优化写入性能
const writeModel = {
  _id: ObjectId(),
  aggregate_id: ObjectId(),
  event_type: String,            // OrderCreated, OrderUpdated
  event_data: Object,            // 变更数据
  version: Number,               // 版本号
  timestamp: Date,
  metadata: {
    correlation_id: String,
    causation_id: String,
    user_id: ObjectId
  }
};

// 读取模型 - 优化查询性能
const readModel = {
  _id: ObjectId(),
  order_id: ObjectId(),
  customer_name: String,         // 预计算字段
  total_items: Number,           // 预计算字段
  total_amount: Number,          // 预计算字段
  status: String,
  last_updated: Date
};

// 事件处理器更新读取模型
const eventHandler = {
  handleOrderCreated: async (event) => {
    const readModel = {
      order_id: event.aggregate_id,
      customer_name: event.event_data.customer_name,
      total_items: event.event_data.items.length,
      total_amount: event.event_data.total_amount,
      status: "pending",
      last_updated: new Date()
    };
    
    await db.readModels.insertOne(readModel);
  }
};
```

#### 5.1.2 事件溯源模式
```javascript
// 事件存储
const eventStore = {
  _id: ObjectId(),
  aggregate_id: ObjectId(),
  aggregate_type: String,        // Order, User, Product
  event_id: ObjectId(),          // 事件ID
  event_type: String,            // Created, Updated, Deleted
  event_version: Number,         // 事件版本
  event_data: Object,            // 事件载荷
  metadata: {
    correlation_id: String,
    causation_id: String,
    user_id: ObjectId,
    timestamp: Date
  }
};

// 重新构建聚合状态
const buildAggregate = async (aggregateId) => {
  const events = await db.eventStore.find({
    aggregate_id: aggregateId
  }).sort({event_version: 1}).toArray();
  
  let state = {};
  
  for (const event of events) {
    state = applyEvent(state, event);
  }
  
  return state;
};

const applyEvent = (state, event) => {
  switch (event.event_type) {
    case 'UserCreated':
      return {
        ...state,
        _id: event.aggregate_id,
        ...event.event_data,
        created_at: event.metadata.timestamp
      };
    case 'UserUpdated':
      return {
        ...state,
        ...event.event_data,
        updated_at: event.metadata.timestamp
      };
    default:
      return state;
  }
};
```

### 5.2 微服务数据模式

#### 5.2.1 数据库每服务
```javascript
// 用户服务数据
const userDatabase = {
  users: {
    _id: ObjectId(),
    username: String,
    email: String,
    profile: Object,
    created_at: Date
  },
  user_sessions: {
    _id: ObjectId(),
    user_id: ObjectId(),
    token: String,
    expires_at: Date
  }
};

// 订单服务数据
const orderDatabase = {
  orders: {
    _id: ObjectId(),
    order_number: String,
    customer_reference: ObjectId,  // 引用用户服务
    items: [Object],
    total_amount: Number,
    created_at: Date
  },
  order_items: {
    _id: ObjectId(),
    order_id: ObjectId(),
    product_reference: ObjectId,   // 引用产品服务
    quantity: Number,
    unit_price: Number
  }
};

// 服务间通信
const orderService = {
  async getCustomerInfo(customerRef) {
    // 调用用户服务API
    const userResponse = await fetch(`http://user-service/api/users/${customerRef}`);
    return await userResponse.json();
  }
};
```

#### 5.2.2 API网关模式
```javascript
// API网关聚合查询
const apiGateway = {
  // 聚合用户和订单数据
  getUserDashboard: async (userId) => {
    // 并行调用多个服务
    const [userProfile, recentOrders, userStats] = await Promise.all([
      this.getUserProfile(userId),
      this.getRecentOrders(userId),
      this.getUserStats(userId)
    ]);
    
    return {
      user: userProfile,
      orders: recentOrders,
      statistics: userStats
    };
  },
  
  getUserProfile: async (userId) => {
    return await db.users.findOne({_id: userId});
  },
  
  getRecentOrders: async (userId) => {
    return await db.orders.find({user_id: userId})
      .sort({created_at: -1})
      .limit(10)
      .toArray();
  },
  
  getUserStats: async (userId) => {
    return await db.orders.aggregate([
      {$match: {user_id: userId}},
      {
        $group: {
          _id: null,
          total_orders: {$sum: 1},
          total_spent: {$sum: "$total_amount"},
          avg_order_value: {$avg: "$total_amount"}
        }
      }
    ]);
  }
};
```

## 6. 分片设计

### 6.1 分片键选择

#### 6.1.1 理想分片键特征
```javascript
// 好的分片键 - 高基数、均匀分布、独立查询
const goodShardKey = {
  user_id: ObjectId(),           // 高基数
  created_at: Date              // 时间分布
};

// 分片键复合
const compoundShardKey = {
  tenant_id: ObjectId(),         // 多租户
  created_at: Date              // 时间
};

// 避免的分片键
const badShardKey = {
  status: String,               // 低基数
  category: String,             # 低基数
  is_active: Boolean            # 极低基数
};
```

#### 6.1.2 分片策略
```javascript
// 范围分片
const rangeSharding = {
  config: {
    shardKey: {user_id: 1, timestamp: 1},  // 范围分片
    chunkSize: 64,                         // 64MB块大小
    balancer: true                         // 自动平衡
  },
  collection: "user_activities"
};

// 哈希分片
const hashSharding = {
  config: {
    shardKey: {user_id: "hashed"},         // 哈希分片
    chunkSize: 64
  },
  collection: "user_sessions"
};

// 自定义分片
const customSharding = {
  config: {
    shardKey: {
      region: "hashed",                    // 地区哈希
      user_id: 1,                          // 用户ID范围
      timestamp: 1                         // 时间范围
    }
  },
  collection: "global_events"
};
```

### 6.2 分片集合设计

#### 6.2.1 时间序列分片
```javascript
// 时间序列数据分片策略
const timeSeriesShard = {
  shardKey: {
    device_id: "hashed",          // 哈希设备ID
    timestamp: 1                  // 按时间范围
  },
  
  // 索引策略
  indexes: [
    {device_id: 1, timestamp: 1},    // 查询设备数据
    {timestamp: 1},                  // 时间范围查询
    {device_id: 1, timestamp: -1}    // 设备数据倒序
  ],
  
  // 预分割策略
  presplitRanges: [
    {device_id: "hashed", timestamp: new Date("2024-01-01")},
    {device_id: "hashed", timestamp: new Date("2024-02-01")},
    {device_id: "hashed", timestamp: new Date("2024-03-01")}
  ]
};
```

#### 6.2.2 多租户分片
```javascript
// 多租户应用分片策略
const multiTenantShard = {
  shardKey: {
    tenant_id: "hashed",           // 哈希租户ID
    entity_id: 1                  // 租户内实体ID
  },
  
  // 租户隔离策略
  tenantIsolation: {
    primary_shard: "shard01",      // 主要分片
    backup_shards: ["shard02", "shard03"]
  },
  
  // 查询路由
  queryRouter: {
    tenantQueries: true,           // 租户内查询
    crossTenantQueries: false      // 跨租户查询
  }
};
```

### 6.3 分片性能优化

#### 6.3.1 聚合优化
```javascript
// 分片聚合管道
const optimizedAggregation = (shardedCollection) => {
  // 第1阶段：在分片上执行
  const shardPipeline = [
    {
      $match: {
        timestamp: {$gte: startDate, $lte: endDate},
        region: "US"
      }
    },
    {
      $group: {
        _id: "$user_id",
        total_actions: {$sum: 1},
        avg_value: {$avg: "$action_value"}
      }
    },
    {
      $project: {
        user_id: "$_id",
        total_actions: 1,
        avg_value: {$round: ["$avg_value", 2]}
      }
    }
  ];
  
  // 第2阶段：在mongos上执行
  const mergePipeline = [
    {
      $group: {
        _id: null,
        total_users: {$sum: 1},
        total_actions: {$sum: "$total_actions"},
        overall_avg: {$avg: "$avg_value"}
      }
    }
  ];
  
  return shardedCollection.aggregate([
    ...shardPipeline,
    ...mergePipeline
  ]);
};
```

#### 6.3.2 查询优化
```javascript
// 分片查询最佳实践
const shardQueryOptimization = {
  // 使用分片键进行查询
  queryWithShardKey: (tenantId, userId) => {
    return db.user_data.find({
      tenant_id: tenantId,       // 分片键
      user_id: userId
    });
  },
  
  // 避免跨分片查询
  avoidCrossShardQuery: () => {
    // ❌ 避免：查询所有租户
    return db.user_data.find({user_id: userId});  // 需要查询所有分片
    
    // ✅ 推荐：指定租户
    return db.user_data.find({
      tenant_id: tenantId,       // 指定分片
      user_id: userId
    });
  },
  
  // 使用聚合框架进行分布式查询
  distributedAggregation: () => {
    return db.user_data.aggregate([
      {
        $match: {
          tenant_id: tenantId,   // 分片键
          action_date: {$gte: startDate}
        }
      },
      {
        $group: {
          _id: "$action_type",
          count: {$sum: 1},
          avg_value: {$avg: "$value"}
        }
      }
    ]);
  }
};
```

---

*第3章深入探讨了MongoDB的数据建模和架构设计原则。通过合理的数据建模，您可以充分发挥MongoDB文档数据库的优势，构建高性能、可扩展的应用程序。*