# 第5章：事务处理

## 目录
1. [事务基础](#1-事务基础)
2. [多文档事务](#2-多文档事务)
3. [事务隔离级别](#3-事务隔离级别)
4. [分布式事务](#4-分布式事务)
5. [事务性能优化](#5-事务性能优化)
6. [事务最佳实践](#6-事务最佳实践)

## 1. 事务基础

### 1.1 ACID属性

#### 1.1.1 MongoDB事务的ACID保证
```javascript
// MongoDB事务保证ACID属性
const acidProperties = {
  atomicity: {
    description: "事务中的所有操作要么全部成功，要么全部失败",
    example: async () => {
      const session = db.client.startSession();
      
      try {
        await session.withTransaction(async () => {
          // 操作1：创建用户
          await db.users.insertOne({
            _id: ObjectId("user123"),
            username: "john_doe",
            email: "john@example.com",
            balance: 1000
          }, {session});
          
          // 操作2：创建账户
          await db.accounts.insertOne({
            _id: ObjectId("acc123"),
            user_id: ObjectId("user123"),
            account_number: "ACC001",
            balance: 1000
          }, {session});
          
          // 如果任何操作失败，整个事务回滚
        });
        
        console.log("事务成功提交");
      } catch (error) {
        console.log("事务回滚:", error.message);
      } finally {
        await session.endSession();
      }
    }
  },
  
  consistency: {
    description: "事务执行前后数据库状态保持一致性",
    example: async () => {
      // 确保用户和账户数据一致
      const session = db.client.startSession();
      
      try {
        await session.withTransaction(async () => {
          // 创建用户
          const user = await db.users.insertOne({
            username: "jane_doe",
            email: "jane@example.com"
          }, {session});
          
          // 自动创建对应的账户（业务逻辑约束）
          await db.accounts.insertOne({
            user_id: user.insertedId,
            account_number: `ACC${user.insertedId.toString().slice(-6)}`,
            balance: 0
          }, {session});
        });
      } finally {
        await session.endSession();
      }
    }
  },
  
  isolation: {
    description: "并发事务之间相互隔离，互不干扰",
    example: async () => {
      const session1 = db.client.startSession();
      const session2 = db.client.startSession();
      
      try {
        // 会话1：开始事务并读取数据
        await session1.withTransaction(async () => {
          const user = await db.users.findOne(
            {username: "john_doe"},
            {session}
          );
          console.log("会话1读取用户:", user);
          
          // 会话2同时读取相同数据
          const user2 = await db.users.findOne(
            {username: "john_doe"},
            {session: session2}
          );
          console.log("会话2读取用户:", user2);
        });
      } finally {
        await session1.endSession();
        await session2.endSession();
      }
    }
  },
  
  durability: {
    description: "事务一旦提交，数据持久化保存",
    example: async () => {
      const session = db.client.startSession();
      
      try {
        await session.withTransaction(async () => {
          await db.users.updateOne(
            {username: "john_doe"},
            {$set: {last_login: new Date()}},
            {session}
          );
        });
        
        // 即使系统立即崩溃，数据也会持久化
        console.log("数据已持久化");
      } finally {
        await session.endSession();
      }
    }
  }
};
```

#### 1.1.2 单文档原子性
```javascript
// MongoDB在单个文档级别提供原子操作
const singleDocumentAtomicity = {
  // 基本原子操作
  basicAtomicOperations: async () => {
    // 原子更新操作
    const result = await db.users.updateOne(
      {username: "john_doe", balance: {$gte: 100}},  // 检查条件
      {
        $inc: {balance: -100},                       // 原子操作
        $push: {transactions: {amount: -100, type: "purchase"}}
      }
    );
    
    console.log("原子操作结果:", {
      matchedCount: result.matchedCount,
      modifiedCount: result.modifiedCount
    });
  },
  
  // 使用原子操作实现转账
  atomicTransfer: async (fromUserId, toUserId, amount) => {
    const session = db.client.startSession();
    
    try {
      await session.withTransaction(async () => {
        // 检查发送方余额
        const fromUser = await db.users.findOne(
          {_id: fromUserId, balance: {$gte: amount}},
          {session}
        );
        
        if (!fromUser) {
          throw new Error("余额不足或用户不存在");
        }
        
        // 扣除发送方余额
        await db.users.updateOne(
          {_id: fromUserId},
          {
            $inc: {balance: -amount},
            $push: {transactions: {amount: -amount, to: toUserId, type: "transfer"}}
          },
          {session}
        );
        
        // 增加接收方余额
        await db.users.updateOne(
          {_id: toUserId},
          {
            $inc: {balance: amount},
            $push: {transactions: {amount: amount, from: fromUserId, type: "transfer"}}
          },
          {session}
        );
      });
      
      console.log("转账成功");
    } catch (error) {
      console.log("转账失败:", error.message);
      throw error;
    } finally {
      await session.endSession();
    }
  }
};
```

### 1.2 事务类型

#### 1.2.1 单文档事务
```javascript
// 单文档事务（原子操作）
const singleDocumentTransactions = {
  // 更新订单状态
  updateOrderStatus: async (orderId, status) => {
    const session = db.client.startSession();
    
    try {
      await session.withTransaction(async () => {
        // 原子更新订单
        const orderResult = await db.orders.updateOne(
          {_id: orderId, status: {$ne: status}},  // 防止重复更新
          {
            $set: {
              status: status,
              updated_at: new Date()
            }
          },
          {session}
        );
        
        if (orderResult.modifiedCount === 0) {
          throw new Error("订单不存在或状态已更新");
        }
        
        // 如果是完成状态，添加完成时间
        if (status === "completed") {
          await db.orders.updateOne(
            {_id: orderId},
            {$set: {completed_at: new Date()}},
            {session}
          );
        }
      });
      
      return {success: true};
    } finally {
      await session.endSession();
    }
  },
  
  // 复杂的单文档更新
  complexSingleDocUpdate: async (productId, userId, quantity) => {
    const session = db.client.startSession();
    
    try {
      await session.withTransaction(async () => {
        // 检查库存
        const product = await db.products.findOne(
          {_id: productId, stock: {$gte: quantity}},
          {session}
        );
        
        if (!product) {
          throw new Error("库存不足或商品不存在");
        }
        
        // 原子更新：减少库存，添加购买记录
        const result = await db.products.updateOne(
          {_id: productId},
          {
            $inc: {stock: -quantity},
            $push: {
              purchase_history: {
                user_id: userId,
                quantity: quantity,
                price: product.price,
                timestamp: new Date()
              }
            },
            $set: {last_sold_at: new Date()}
          },
          {session}
        );
        
        if (result.modifiedCount === 0) {
          throw new Error("更新失败");
        }
      });
      
      return {success: true};
    } finally {
      await session.endSession();
    }
  }
};
```

#### 1.2.2 多文档事务
```javascript
// 多文档事务示例
const multiDocumentTransactions = {
  // 用户注册和欢迎奖励
  userRegistrationWithWelcomeBonus: async (userData) => {
    const session = db.client.startSession();
    
    try {
      await session.withTransaction(async () => {
        // 1. 创建用户
        const userResult = await db.users.insertOne(
          {
            ...userData,
            created_at: new Date(),
            status: "active"
          },
          {session}
        );
        
        const userId = userResult.insertedId;
        
        // 2. 创建用户配置
        await db.userConfigs.insertOne(
          {
            user_id: userId,
            preferences: {
              language: "zh-CN",
              theme: "light",
              notifications: true
            },
            created_at: new Date()
          },
          {session}
        );
        
        // 3. 添加欢迎奖励
        await db.transactions.insertOne(
          {
            user_id: userId,
            type: "welcome_bonus",
            amount: 10.0,
            description: "新用户注册奖励",
            created_at: new Date()
          },
          {session}
        );
        
        // 4. 更新用户余额
        await db.users.updateOne(
          {_id: userId},
          {$inc: {balance: 10.0}},
          {session}
        );
      });
      
      return {success: true, message: "用户注册完成"};
    } catch (error) {
      return {success: false, error: error.message};
    } finally {
      await session.endSession();
    }
  },
  
  // 订单处理流程
  processOrder: async (orderData) => {
    const session = db.client.startSession();
    
    try {
      await session.withTransaction(async () => {
        // 1. 创建订单
        const orderResult = await db.orders.insertOne(
          {
            ...orderData,
            status: "pending",
            created_at: new Date()
          },
          {session}
        );
        
        const orderId = orderResult.insertedId;
        
        // 2. 验证库存
        for (const item of orderData.items) {
          const product = await db.products.findOne(
            {
              _id: item.product_id,
              stock: {$gte: item.quantity}
            },
            {session}
          );
          
          if (!product) {
            throw new Error(`商品 ${item.product_id} 库存不足`);
          }
        }
        
        // 3. 扣减库存
        for (const item of orderData.items) {
          await db.products.updateOne(
            {_id: item.product_id},
            {
              $inc: {stock: -item.quantity},
              $set: {last_sold_at: new Date()}
            },
            {session}
          );
        }
        
        // 4. 创建交易记录
        await db.transactions.insertOne(
          {
            order_id: orderId,
            user_id: orderData.user_id,
            type: "purchase",
            amount: orderData.total_amount,
            status: "pending",
            created_at: new Date()
          },
          {session}
        );
        
        // 5. 更新订单状态
        await db.orders.updateOne(
          {_id: orderId},
          {$set: {status: "confirmed"}},
          {session}
        );
      });
      
      return {success: true, message: "订单处理成功"};
    } catch (error) {
      return {success: false, error: error.message};
    } finally {
      await session.endSession();
    }
  }
};
```

## 2. 多文档事务

### 2.1 事务生命周期

#### 2.1.1 事务状态管理
```javascript
// 事务生命周期管理
const transactionLifecycle = {
  // 事务状态跟踪
  TransactionState: {
    PENDING: "pending",        // 事务开始
    ACTIVE: "active",          // 事务执行中
    COMMITTED: "committed",    // 事务提交
    ABORTED: "aborted"         // 事务中止
  },
  
  // 创建事务管理器
  TransactionManager: {
    async createTransaction(context = {}) {
      const session = db.client.startSession();
      
      const transaction = {
        id: ObjectId(),
        session,
        state: "pending",
        context,
        startTime: new Date(),
        operations: [],
        callbacks: {
          onStart: [],
          onCommit: [],
          onAbort: []
        }
      };
      
      return transaction;
    },
    
    async start(transaction) {
      transaction.state = "active";
      transaction.startTime = new Date();
      
      // 执行开始回调
      for (const callback of transaction.callbacks.onStart) {
        await callback(transaction);
      }
      
      console.log(`事务 ${transaction.id} 开始`);
      return transaction;
    },
    
    async commit(transaction) {
      if (transaction.state !== "active") {
        throw new Error(`事务状态错误: ${transaction.state}`);
      }
      
      try {
        await transaction.session.commitTransaction();
        transaction.state = "committed";
        
        console.log(`事务 ${transaction.id} 提交成功`);
        
        // 执行提交回调
        for (const callback of transaction.callbacks.onCommit) {
          await callback(transaction);
        }
        
      } finally {
        await transaction.session.endSession();
      }
      
      return transaction;
    },
    
    async abort(transaction, error) {
      if (transaction.state !== "active") {
        throw new Error(`事务状态错误: ${transaction.state}`);
      }
      
      try {
        await transaction.session.abortTransaction();
        transaction.state = "aborted";
        
        console.log(`事务 ${transaction.id} 中止: ${error.message}`);
        
        // 执行中止回调
        for (const callback of transaction.callbacks.onAbort) {
          await callback(transaction, error);
        }
        
      } finally {
        await transaction.session.endSession();
      }
      
      return transaction;
    }
  }
};

// 使用事务管理器
const useTransactionManager = async () => {
  const manager = transactionLifecycle.TransactionManager;
  
  // 创建事务
  const transaction = await manager.createTransaction({
    description: "用户注册和初始化",
    user_id: ObjectId("user123")
  });
  
  try {
    // 开始事务
    await manager.start(transaction);
    
    // 添加操作到事务
    transaction.operations.push({
      type: "insert",
      collection: "users",
      document: {
        username: "john_doe",
        email: "john@example.com"
      }
    });
    
    // 执行其他操作...
    
    // 提交事务
    await manager.commit(transaction);
    
  } catch (error) {
    await manager.abort(transaction, error);
    throw error;
  }
};
```

#### 2.1.2 事务重试机制
```javascript
// 事务重试机制
const transactionRetry = {
  // 可重试的异常类型
  RetryableErrors: [
    "MongoServerError",          // 服务器错误
    "MongoNetworkError",         // 网络错误
    "MongoWriteConcernError"     // 写关注错误
  ],
  
  // 可重试的事务操作
  async retryableTransaction(operation, maxRetries = 3, backoffMs = 100) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      const session = db.client.startSession();
      
      try {
        console.log(`事务尝试 ${attempt}/${maxRetries}`);
        
        const result = await session.withTransaction(operation);
        
        await session.endSession();
        return result;
        
      } catch (error) {
        await session.endSession();
        lastError = error;
        
        // 检查是否可重试
        if (!this.isRetryableError(error) || attempt === maxRetries) {
          throw error;
        }
        
        // 指数退避
        const delay = backoffMs * Math.pow(2, attempt - 1);
        console.log(`等待 ${delay}ms 后重试...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    
    throw lastError;
  },
  
  isRetryableError(error) {
    // 检查错误类型
    if (this.RetryableErrors.includes(error.name)) {
      return true;
    }
    
    // 检查错误代码
    const retryableCodes = [
      112,  // WriteConflict
      11600, // InterruptedAtShutdown
      10107, // NotWritablePrimary
      13435, // PrimarySteppedDown
      189,   // ExceededTimeLimit
    ];
    
    return retryableCodes.includes(error.code);
  },
  
  // 示例：可重试的用户转账
  async retryableTransfer(fromUserId, toUserId, amount, maxRetries = 3) {
    const operation = async (session) => {
      // 检查余额
      const fromUser = await db.users.findOne(
        {
          _id: fromUserId,
          balance: {$gte: amount}
        },
        {session}
      );
      
      if (!fromUser) {
        throw new Error("余额不足");
      }
      
      // 执行转账
      await db.users.updateOne(
        {_id: fromUserId},
        {
          $inc: {balance: -amount},
          $push: {transactions: {to: toUserId, amount: -amount, timestamp: new Date()}}
        },
        {session}
      );
      
      await db.users.updateOne(
        {_id: toUserId},
        {
          $inc: {balance: amount},
          $push: {transactions: {from: fromUserId, amount: amount, timestamp: new Date()}}
        },
        {session}
      );
    };
    
    return await this.retryableTransaction(operation, maxRetries);
  }
};
```

### 2.2 事务操作类型

#### 2.2.1 CRUD操作事务
```javascript
// 事务中的CRUD操作
const transactionalCRUD = {
  // 创建操作
  create: async (collectionName, document) => {
    const session = db.client.startSession();
    
    try {
      await session.withTransaction(async () => {
        // 插入文档
        const result = await db[collectionName].insertOne(
          {
            ...document,
            created_at: new Date(),
            updated_at: new Date()
          },
          {session}
        );
        
        console.log("文档创建成功:", result.insertedId);
        return result;
      });
    } finally {
      await session.endSession();
    }
  },
  
  // 读取操作
  read: async (collectionName, query, projection = {}) => {
    const session = db.client.startSession();
    
    try {
      return await db[collectionName].find(query, projection).session(session).toArray();
    } finally {
      await session.endSession();
    }
  },
  
  // 更新操作
  update: async (collectionName, filter, update, options = {}) => {
    const session = db.client.startSession();
    
    try {
      return await session.withTransaction(async () => {
        // 添加更新时间
        const updateDoc = {
          ...update,
          $set: {...update.$set, updated_at: new Date()}
        };
        
        return await db[collectionName].updateOne(
          filter,
          updateDoc,
          {...options, session}
        );
      });
    } finally {
      await session.endSession();
    }
  },
  
  // 删除操作
  delete: async (collectionName, filter) => {
    const session = db.client.startSession();
    
    try {
      return await session.withTransaction(async () => {
        return await db[collectionName].deleteOne(filter, {session});
      });
    } finally {
      await session.endSession();
    }
  }
};
```

#### 2.2.2 复杂事务操作
```javascript
// 复杂业务事务示例
const complexTransactions = {
  // 电商订单完整流程
  eCommerceOrderFlow: async (orderData) => {
    const session = db.client.startSession();
    
    try {
      await session.withTransaction(async () => {
        const orderId = ObjectId();
        
        // 1. 创建订单
        const order = await db.orders.insertOne(
          {
            _id: orderId,
            user_id: orderData.user_id,
            items: orderData.items,
            total_amount: orderData.total_amount,
            shipping_address: orderData.shipping_address,
            status: "pending",
            created_at: new Date()
          },
          {session}
        );
        
        // 2. 验证库存和价格
        let totalAmount = 0;
        for (const item of orderData.items) {
          const product = await db.products.findOne(
            {_id: item.product_id, is_active: true},
            {session}
          );
          
          if (!product) {
            throw new Error(`商品 ${item.product_id} 不可用`);
          }
          
          if (product.stock < item.quantity) {
            throw new Error(`商品 ${item.product_id} 库存不足`);
          }
          
          totalAmount += product.price * item.quantity;
        }
        
        // 验证订单金额
        if (Math.abs(totalAmount - orderData.total_amount) > 0.01) {
          throw new Error("订单金额不匹配");
        }
        
        // 3. 检查用户余额
        const user = await db.users.findOne(
          {
            _id: orderData.user_id,
            balance: {$gte: orderData.total_amount}
          },
          {session}
        );
        
        if (!user) {
          throw new Error("用户余额不足");
        }
        
        // 4. 扣减库存
        for (const item of orderData.items) {
          await db.products.updateOne(
            {_id: item.product_id},
            {$inc: {stock: -item.quantity}},
            {session}
          );
        }
        
        // 5. 扣除用户余额
        await db.users.updateOne(
          {_id: orderData.user_id},
          {
            $inc: {balance: -orderData.total_amount},
            $push: {
              orders: {
                order_id: orderId,
                amount: orderData.total_amount,
                timestamp: new Date()
              }
            }
          },
          {session}
        );
        
        // 6. 创建交易记录
        await db.transactions.insertOne(
          {
            user_id: orderData.user_id,
            order_id: orderId,
            type: "purchase",
            amount: -orderData.total_amount,
            description: "订单支付",
            status: "completed",
            created_at: new Date()
          },
          {session}
        );
        
        // 7. 更新订单状态
        await db.orders.updateOne(
          {_id: orderId},
          {$set: {status: "confirmed", confirmed_at: new Date()}},
          {session}
        );
      });
      
      return {success: true, message: "订单处理成功"};
      
    } catch (error) {
      return {success: false, error: error.message};
    } finally {
      await session.endSession();
    }
  },
  
  // 用户资料迁移
  migrateUserProfile: async (fromUserId, toUserId) => {
    const session = db.client.startSession();
    
    try {
      await session.withTransaction(async () => {
        // 1. 获取源用户资料
        const sourceUser = await db.users.findOne(
          {_id: fromUserId},
          {session}
        );
        
        if (!sourceUser) {
          throw new Error("源用户不存在");
        }
        
        // 2. 检查目标用户
        const targetUser = await db.users.findOne(
          {_id: toUserId},
          {session}
        );
        
        if (!targetUser) {
          throw new Error("目标用户不存在");
        }
        
        // 3. 合并用户数据
        const mergedData = {
          email: targetUser.email || sourceUser.email,
          preferences: {
            ...targetUser.preferences,
            ...sourceUser.preferences
          },
          settings: {
            ...targetUser.settings,
            ...sourceUser.settings
          },
          migrated_from: fromUserId,
          migrated_at: new Date()
        };
        
        // 4. 更新目标用户
        await db.users.updateOne(
          {_id: toUserId},
          {
            $set: mergedData,
            $push: {
              migration_history: {
                from_user: fromUserId,
                migrated_at: new Date(),
                data_fields: Object.keys(mergedData)
              }
            }
          },
          {session}
        );
        
        // 5. 标记源用户为已迁移
        await db.users.updateOne(
          {_id: fromUserId},
          {
            $set: {
              is_migrated: true,
              migration_target: toUserId,
              migrated_at: new Date()
            },
            $unset: {
              email: "",
              preferences: "",
              settings: ""
            }
          },
          {session}
        );
      });
      
      return {success: true, message: "用户资料迁移成功"};
      
    } catch (error) {
      return {success: false, error: error.message};
    } finally {
      await session.endSession();
    }
  }
};
```

## 3. 事务隔离级别

### 3.1 隔离级别概念

#### 3.1.1 MongoDB事务隔离级别
```javascript
// MongoDB事务隔离级别
const transactionIsolation = {
  // READ COMMITTED（已提交读）- MongoDB默认级别
  readCommitted: {
    description: "只能读取已提交的数据",
    example: async () => {
      const session1 = db.client.startSession();
      const session2 = db.client.startSession();
      
      try {
        // 会话1开始事务
        await session1.withTransaction(async () => {
          // 读取当前值
          const initialValue = await db.counters.findOne(
            {name: "order_count"},
            {session}
          );
          console.log("初始值:", initialValue?.value);
          
          // 修改但未提交
          await db.counters.updateOne(
            {name: "order_count"},
            {$inc: {value: 100}},
            {session}
          );
          
          // 会话2尝试读取
          const session2Value = await db.counters.findOne(
            {name: "order_count"},
            {session: session2}
          );
          
          // session2读不到session1的未提交修改
          console.log("会话2读取的值:", session2Value?.value);
          console.log("应该等于初始值:", initialValue?.value === session2Value?.value);
        });
      } finally {
        await session1.endSession();
        await session2.endSession();
      }
    }
  },
  
  // SNAPSHOT（快照读）- 事务级别
  snapshot: {
    description: "事务开始时获取数据快照",
    example: async () => {
      const session1 = db.client.startSession();
      const session2 = db.client.startSession();
      
      try {
        // 会话1开始事务
        await session1.withTransaction(async () => {
          const snapshot1 = await db.products.findOne(
            {name: "iPhone 15"},
            {session}
          );
          console.log("会话1快照:", snapshot1?.stock);
          
          // 会话2在会话1事务期间修改数据
          await session2.withTransaction(async () => {
            await db.products.updateOne(
              {name: "iPhone 15"},
              {$inc: {stock: -10}},
              {session: session2}
            );
          });
          
          // 会话1再次读取，应该还是原始快照
          const snapshot2 = await db.products.findOne(
            {name: "iPhone 15"},
            {session}
          );
          
          console.log("会话1读取的快照:", snapshot2?.stock);
          console.log("快照一致性:", snapshot1?.stock === snapshot2?.stock);
        });
      } finally {
        await session1.endSession();
        await session2.endSession();
      }
    }
  }
};
```

#### 3.1.2 事务隔离与并发控制
```javascript
// 并发控制示例
const concurrencyControl = {
  // 幻读（Phantom Read）示例
  phantomRead: async () => {
    const session1 = db.client.startSession();
    const session2 = db.client.startSession();
    
    try {
      await session1.withTransaction(async () => {
        // 第一次查询：获取所有价格>100的商品
        const initialProducts = await db.products.find(
          {price: {$gt: 100}},
          {session}
        ).toArray();
        
        console.log("初始商品数量:", initialProducts.length);
        
        // 会话2在会话1事务期间插入新商品
        await session2.withTransaction(async () => {
          await db.products.insertOne({
            name: "Expensive Item",
            price: 150,
            created_at: new Date()
          }, {session: session2});
        });
        
        // 第二次查询：获取所有价格>100的商品
        const finalProducts = await db.products.find(
          {price: {$gt: 100}},
          {session}
        ).toArray();
        
        console.log("最终商品数量:", finalProducts.length);
        console.log("发生了幻读:", initialProducts.length !== finalProducts.length);
      });
    } finally {
      await session1.endSession();
      await session2.endSession();
    }
  },
  
  // 不可重复读（Non-repeatable Read）示例
  nonRepeatableRead: async () => {
    const session1 = db.client.startSession();
    const session2 = db.client.startSession();
    
    try {
      await session1.withTransaction(async () => {
        // 第一次读取商品信息
        const product1 = await db.products.findOne(
          {name: "Laptop"},
          {session}
        );
        console.log("第一次读取:", product1?.price);
        
        // 会话2修改同一商品价格
        await session2.withTransaction(async () => {
          await db.products.updateOne(
            {name: "Laptop"},
            {$set: {price: 999}},
            {session: session2}
          );
        });
        
        // 第二次读取同一商品（如果用快照读，结果不变）
        const product2 = await db.products.findOne(
          {name: "Laptop"},
          {session}
        );
        console.log("第二次读取:", product2?.price);
        console.log("价格是否一致:", product1?.price === product2?.price);
      });
    } finally {
      await session1.endSession();
      await session2.endSession();
    }
  }
};
```

### 3.2 读写冲突处理

#### 3.2.1 写冲突检测
```javascript
// 写冲突处理
const writeConflictHandling = {
  // 检测和解决写冲突
  handleWriteConflicts: async (operations) => {
    const maxRetries = 3;
    let attempt = 0;
    
    while (attempt < maxRetries) {
      const session = db.client.startSession();
      
      try {
        await session.withTransaction(async () => {
          const results = [];
          
          for (const operation of operations) {
            const result = await operation(session);
            results.push(result);
          }
          
          return results;
        });
        
        break; // 成功，跳出重试循环
        
      } catch (error) {
        attempt++;
        
        if (attempt >= maxRetries || !isConflictError(error)) {
          throw error;
        }
        
        console.log(`写冲突，重试第 ${attempt} 次`);
        await new Promise(resolve => setTimeout(resolve, 100 * attempt));
        
      } finally {
        await session.endSession();
      }
    }
  },
  
  // 并发库存检查和更新
  concurrentInventoryUpdate: async (updates) => {
    const conflictHandler = this.handleWriteConflicts;
    
    const operations = updates.map(update => {
      return async (session) => {
        // 先读取当前库存
        const product = await db.products.findOne(
          {_id: update.product_id},
          {session}
        );
        
        if (!product) {
          throw new Error(`产品 ${update.product_id} 不存在`);
        }
        
        if (product.stock < update.quantity) {
          throw new Error(`产品 ${update.product_id} 库存不足`);
        }
        
        // 更新库存
        return await db.products.updateOne(
          {_id: update.product_id},
          {
            $inc: {stock: -update.quantity},
            $set: {last_updated: new Date()}
          },
          {session}
        );
      };
    });
    
    return await conflictHandler(operations);
  }
};

const isConflictError = (error) => {
  return error.code === 112 || // WriteConflict
         error.message?.includes("WriteConflict");
};
```

#### 3.2.2 乐观锁控制
```javascript
// 乐观锁实现
const optimisticLocking = {
  // 使用版本号实现乐观锁
  versionBasedLock: {
    // 尝试更新带版本检查的文档
    async updateWithVersion(productId, newData, expectedVersion) {
      const session = db.client.startSession();
      
      try {
        await session.withTransaction(async () => {
          // 首先检查版本号
          const current = await db.products.findOne(
            {_id: product_id},
            {session}
          );
          
          if (!current) {
            throw new Error("产品不存在");
          }
          
          if (current.version !== expectedVersion) {
            throw new Error(`版本冲突：期望 ${expectedVersion}，实际 ${current.version}`);
          }
          
          // 版本号匹配，执行更新
          await db.products.updateOne(
            {_id: product_id},
            {
              $set: {
                ...newData,
                version: expectedVersion + 1,
                updated_at: new Date()
              }
            },
            {session}
          );
        });
        
        return {success: true, newVersion: expectedVersion + 1};
        
      } catch (error) {
        if (error.message.includes("版本冲突")) {
          return {success: false, error: error.message, needRetry: true};
        }
        throw error;
      } finally {
        await session.endSession();
      }
    },
    
    // 带重试的乐观锁更新
    async updateWithRetry(productId, newData, maxRetries = 3) {
      let attempt = 0;
      let expectedVersion;
      
      while (attempt < maxRetries) {
        // 获取当前版本
        const current = await db.products.findOne({_id: productId});
        expectedVersion = current.version;
        
        try {
          const result = await this.updateWithVersion(productId, newData, expectedVersion);
          
          if (result.success) {
            return result;
          }
          
          attempt++;
          if (attempt >= maxRetries) {
            return result;
          }
          
          // 短暂延迟后重试
          await new Promise(resolve => setTimeout(resolve, 100));
          
        } catch (error) {
          attempt++;
          if (attempt >= maxRetries || !error.message?.includes("版本冲突")) {
            throw error;
          }
        }
      }
    }
  },
  
  // 使用ETag实现乐观锁
  etagBasedLock: {
    // 获取带ETag的文档
    async getWithETag(query) {
      const document = await db.products.findOne(query);
      
      if (document) {
        // 生成ETag
        const eTag = generateETag(document);
        document.eTag = eTag;
      }
      
      return document;
    },
    
    // 使用ETag更新
    async updateWithETag(query, update, clientETag) {
      const session = db.client.startSession();
      
      try {
        await session.withTransaction(async () => {
          // 获取当前文档
          const current = await db.products.findOne(query, {session});
          
          if (!current) {
            throw new Error("文档不存在");
          }
          
          // 检查ETag
          const currentETag = generateETag(current);
          if (clientETag !== currentETag) {
            throw new Error("ETag不匹配，文档已被修改");
          }
          
          // 更新文档
          const result = await db.products.updateOne(
            query,
            {...update, $set: {updated_at: new Date()}},
            {session}
          );
          
          return result;
        });
      } finally {
        await session.endSession();
      }
    }
  }
};

// 生成ETag的辅助函数
const generateETag = (document) => {
  const version = document.version || 0;
  const lastUpdated = document.updated_at || document.created_at || new Date();
  return `${document._id}-${version}-${lastUpdated.getTime()}`;
};
```

## 4. 分布式事务

### 4.1 分片事务

#### 4.1.1 跨分片事务限制
```javascript
// 分片事务限制和注意事项
const shardedTransactionLimits = {
  // 分片事务要求
  requirements: {
    // 1. 必须在主节点上执行
    primaryOnly: {
      description: "分片事务只能在主节点上执行",
      example: async () => {
        const session = db.client.startSession();
        
        try {
          // 在主节点上执行分片事务
          await session.withTransaction(async () => {
            // 多分片操作
            await db.users.insertOne({name: "user1"}, {session});
            await db.products.insertOne({name: "product1"}, {session});
          });
        } catch (error) {
          console.log("分片事务错误:", error.message);
        } finally {
          await session.endSession();
        }
      }
    },
    
    // 2. 集合必须存在
    collectionExistence: {
      description: "事务中的所有集合必须事先存在",
      example: async () => {
        const session = db.client.startSession();
        
        try {
          await session.withTransaction(async () => {
            // 插入到已存在的集合
            await db.users.insertOne({name: "user1"}, {session});
            // 插入到不存在的集合会失败
            await db.nonexistent.insertOne({data: "test"}, {session});
          });
        } catch (error) {
          console.log("集合不存在错误:", error.message);
        } finally {
          await session.endSession();
        }
      }
    },
    
    // 3. 事务超时限制
    timeoutLimit: {
      description: "分片事务有严格的超时限制",
      maxTimeout: "120 seconds",
      example: async () => {
        const session = db.client.startSession({
          defaultTransactionOptions: {
            maxTimeMS: 60000  // 60秒超时
          }
        });
        
        try {
          await session.withTransaction(async () => {
            // 长时间运行的操作
            await new Promise(resolve => setTimeout(resolve, 50000));
          });
        } catch (error) {
          console.log("事务超时:", error.message);
        } finally {
          await session.endSession();
        }
      }
    }
  },
  
  // 分片事务最佳实践
  bestPractices: {
    // 1. 避免大事务
    avoidLargeTransactions: async () => {
      // ❌ 不推荐：大事务涉及大量操作
      const badExample = async () => {
        const session = db.client.startSession();
        
        try {
          await session.withTransaction(async () {
            // 1000个插入操作
            for (let i = 0; i < 1000; i++) {
              await db.users.insertOne({index: i}, {session});
            }
          });
        } finally {
          await session.endSession();
        }
      };
      
      // ✅ 推荐：分批操作
      const goodExample = async (data) => {
        const batchSize = 100;
        
        for (let i = 0; i < data.length; i += batchSize) {
          const batch = data.slice(i, i + batchSize);
          await db.users.insertMany(batch);
        }
      };
    },
    
    // 2. 使用合适的超时时间
    appropriateTimeout: async () => {
      const session = db.client.startSession({
        defaultTransactionOptions: {
          readConcern: {level: "snapshot"},
          writeConcern: {w: "majority"},
          maxTimeMS: 30000  // 30秒超时
        }
      });
      
      try {
        await session.withTransaction(async () => {
          // 快速完成的操作
          await db.users.updateOne({name: "user1"}, {$inc: {loginCount: 1}}, {session});
        });
      } finally {
        await session.endSession();
      }
    }
  }
};
```

#### 4.1.2 分片事务性能优化
```javascript
// 分片事务性能优化
const shardedTransactionOptimization = {
  // 优化分片事务性能
  optimizePerformance: {
    // 1. 最小化跨分片操作
    minimizeCrossShardOps: async () => {
      // 最佳实践：将相关数据放在同一分片
      const session = db.client.startSession();
      
      try {
        await session.withTransaction(async () => {
          // 操作同一分片上的数据
          await db.users.findOne({_id: userId}, {session});
          await db.userProfiles.findOne({user_id: userId}, {session});
          await db.userSettings.findOne({user_id: userId}, {session});
          
          // 如果必须跨分片，尽量减少操作数量
          await db.orders.findOne({user_id: userId}, {session}); // 可能在不同分片
        });
      } finally {
        await session.endSession();
      }
    },
    
    // 2. 使用批量操作
    useBulkOperations: async () => {
      const session = db.client.startSession();
      
      try {
        await session.withTransaction(async () => {
          // 批量插入比多次单次插入更高效
          const documents = Array.from({length: 100}, (_, i) => ({
            name: `user${i}`,
            email: `user${i}@example.com`,
            created_at: new Date()
          }));
          
          await db.users.insertMany(documents, {session});
          
          // 批量更新
          await db.users.updateMany(
            {email: {$regex: "@example.com$"}},
            {$set: {status: "verified"}},
            {session}
          );
        });
      } finally {
        await session.endSession();
      }
    },
    
    // 3. 避免长时间持有事务
    avoidLongTransactions: async () => {
      // 快速事务示例
      const quickTransaction = async () => {
        const session = db.client.startSession();
        
        try {
          await session.withTransaction(async () => {
            // 立即执行操作
            const user = await db.users.findOne({status: "active"}, {session});
            
            if (user) {
              await db.users.updateOne(
                {_id: user._id},
                {$set: {last_login: new Date()}},
                {session}
              );
            }
            
            // 不要在事务中执行耗时操作
          });
        } finally {
          await session.endSession();
        }
      };
    }
  }
};
```

### 4.2 跨数据库事务

#### 4.2.1 两阶段提交
```javascript
// 两阶段提交模式实现跨数据库事务
const twoPhaseCommit = {
  // 事务协调器
  TransactionCoordinator: {
    async beginTransaction(transactionId) {
      const transaction = {
        _id: transactionId,
        status: "pending",
        participants: [],
        created_at: new Date(),
        updated_at: new Date()
      };
      
      await db.transactions.insertOne(transaction);
      return transaction;
    },
    
    async registerParticipant(transactionId, participant) {
      await db.transactions.updateOne(
        {_id: transactionId},
        {
          $push: {
            participants: {
              ...participant,
              status: "pending",
              registered_at: new Date()
            }
          },
          $set: {updated_at: new Date()}
        }
      );
    },
    
    async prepare(transactionId) {
      const transaction = await db.transactions.findOne({_id: transactionId});
      
      if (!transaction || transaction.status !== "pending") {
        throw new Error("无效的事务状态");
      }
      
      // Phase 1: Prepare phase
      await db.transactions.updateOne(
        {_id: transactionId},
        {$set: {status: "preparing", updated_at: new Date()}}
      );
      
      const results = [];
      for (const participant of transaction.participants) {
        try {
          const result = await this.prepareParticipant(participant);
          results.push({participant: participant.name, success: true, result});
          
          // 更新参与者状态
          await db.transactions.updateOne(
            {_id: transactionId, "participants.name": participant.name},
            {
              $set: {
                "participants.$.status": "prepared",
                "participants.$.prepared_at": new Date()
              }
            }
          );
        } catch (error) {
          results.push({participant: participant.name, success: false, error: error.message});
          
          // 如果任何参与者准备失败，中止整个事务
          await this.abortTransaction(transactionId, "Prepare failed: " + error.message);
          return {success: false, error: "Prepare phase failed"};
        }
      }
      
      return {success: true, results};
    },
    
    async commit(transactionId) {
      const transaction = await db.transactions.findOne({_id: transactionId});
      
      if (!transaction || transaction.status !== "preparing") {
        throw new Error("无效的事务状态");
      }
      
      // Phase 2: Commit phase
      await db.transactions.updateOne(
        {_id: transactionId},
        {$set: {status: "committing", updated_at: new Date()}}
      );
      
      const results = [];
      for (const participant of transaction.participants) {
        try {
          await this.commitParticipant(participant);
          results.push({participant: participant.name, success: true});
          
          await db.transactions.updateOne(
            {_id: transactionId, "participants.name": participant.name},
            {
              $set: {
                "participants.$.status": "committed",
                "participants.$.committed_at": new Date()
              }
            }
          );
        } catch (error) {
          results.push({participant: participant.name, success: false, error: error.message});
        }
      }
      
      await db.transactions.updateOne(
        {_id: transactionId},
        {$set: {status: "committed", updated_at: new Date()}}
      );
      
      return {success: true, results};
    },
    
    async abortTransaction(transactionId, reason) {
      await db.transactions.updateOne(
        {_id: transactionId},
        {
          $set: {
            status: "aborted",
            abort_reason: reason,
            updated_at: new Date()
          }
        }
      );
    }
  },
  
  // 示例：跨数据库资金转账
  crossDatabaseTransfer: async (fromAccountId, toAccountId, amount) => {
    const transactionId = ObjectId();
    const coordinator = this.TransactionCoordinator;
    
    try {
      // 开始分布式事务
      await coordinator.beginTransaction(transactionId);
      
      // 注册参与者
      await coordinator.registerParticipant(transactionId, {
        name: "source_account",
        database: "bank_main",
        collection: "accounts",
        operation: "debit"
      });
      
      await coordinator.registerParticipant(transactionId, {
        name: "target_account",
        database: "bank_backup", 
        collection: "accounts",
        operation: "credit"
      });
      
      // 执行转账操作
      const result = await coordinator.withTransaction(transactionId, async (session) => {
        // 借记源账户
        const sourceAccount = await db.accounts.findOne(
          {_id: fromAccountId, balance: {$gte: amount}},
          {session}
        );
        
        if (!sourceAccount) {
          throw new Error("源账户余额不足");
        }
        
        await db.accounts.updateOne(
          {_id: fromAccountId},
          {$inc: {balance: -amount}},
          {session}
        );
        
        // 贷记目标账户
        await db.accounts.updateOne(
          {_id: toAccountId},
          {$inc: {balance: amount}},
          {session}
        );
      });
      
      // 提交事务
      const commitResult = await coordinator.prepare(transactionId);
      if (commitResult.success) {
        await coordinator.commit(transactionId);
      }
      
      return {success: true, message: "转账成功"};
      
    } catch (error) {
      await coordinator.abortTransaction(transactionId, error.message);
      return {success: false, error: error.message};
    }
  }
};
```

## 5. 事务性能优化

### 5.1 事务性能考量

#### 5.1.1 事务开销分析
```javascript
// 事务性能分析
const transactionPerformanceAnalysis = {
  // 事务开销分析
  analyzeTransactionOverhead: {
    // 对比事务和非事务操作性能
    async comparePerformance() {
      const testData = Array.from({length: 1000}, (_, i) => ({
        name: `user${i}`,
        email: `user${i}@example.com`,
        value: Math.random() * 100
      }));
      
      // 测试非事务操作
      const nonTransactionalStart = performance.now();
      await db.users.insertMany(testData);
      const nonTransactionalEnd = performance.now();
      const nonTransactionalTime = nonTransactionalEnd - nonTransactionalStart;
      
      // 测试事务操作
      const transactionalStart = performance.now();
      const session = db.client.startSession();
      
      try {
        await session.withTransaction(async () => {
          const batchSize = 100;
          for (let i = 0; i < testData.length; i += batchSize) {
            const batch = testData.slice(i, i + batchSize);
            await db.users.insertMany(batch, {session});
          }
        });
      } finally {
        await session.endSession();
      }
      
      const transactionalEnd = performance.now();
      const transactionalTime = transactionalEnd - transactionalStart;
      
      return {
        nonTransactionalTime,
        transactionalTime,
        overhead: ((transactionalTime - nonTransactionalTime) / nonTransactionalTime * 100).toFixed(2) + "%"
      };
    },
    
    // 分析不同大小事务的性能
    analyzeTransactionSize() {
      const sizes = [10, 50, 100, 500, 1000];
      const results = [];
      
      for (const size of sizes) {
        const start = performance.now();
        
        const session = db.client.startSession();
        (async () => {
          try {
            await session.withTransaction(async () => {
              const docs = Array.from({length: size}, (_, i) => ({
                name: `user${i}`,
                value: i
              }));
              await db.users.insertMany(docs, {session});
            });
          } finally {
            await session.endSession();
          }
        })();
        
        const end = performance.now();
        results.push({size, time: end - start});
      }
      
      return results;
    }
  }
};
```

#### 5.1.2 事务优化策略
```javascript
// 事务性能优化策略
const transactionOptimizationStrategies = {
  // 1. 批量操作优化
  batchOperations: {
    // 将大事务分解为小批次
    async batchInsert(data, batchSize = 100) {
      const results = [];
      let session;
      
      try {
        for (let i = 0; i < data.length; i += batchSize) {
          const batch = data.slice(i, i + batchSize);
          
          session = db.client.startSession();
          
          try {
            const result = await session.withTransaction(async () => {
              return await db.users.insertMany(batch, {session});
            });
            
            results.push(result);
            
          } finally {
            await session.endSession();
            session = null;
          }
        }
        
        return results;
        
      } catch (error) {
        if (session) {
          await session.endSession();
        }
        throw error;
      }
    }
  },
  
  // 2. 事务池管理
  transactionPool: {
    // 事务池实现
    pool: [],
    maxSize: 10,
    
    async getTransaction() {
      if (this.pool.length > 0) {
        return this.pool.pop();
      }
      
      return db.client.startSession();
    },
    
    async releaseTransaction(session) {
      if (this.pool.length < this.maxSize) {
        this.pool.push(session);
      } else {
        await session.endSession();
      }
    },
    
    // 使用连接池进行批量操作
    async pooledBatchOperation(operations) {
      const session = await this.getTransaction();
      
      try {
        return await session.withTransaction(async () => {
          const results = [];
          
          for (const operation of operations) {
            const result = await operation(session);
            results.push(result);
          }
          
          return results;
        });
        
      } finally {
        await this.releaseTransaction(session);
      }
    }
  },
  
  // 3. 异步事务处理
  asynchronousTransactions: {
    // 异步事务队列
    queue: [],
    processing: false,
    
    async addTransaction(transaction) {
      this.queue.push(transaction);
      await this.processQueue();
    },
    
    async processQueue() {
      if (this.processing || this.queue.length === 0) {
        return;
      }
      
      this.processing = true;
      
      while (this.queue.length > 0) {
        const transaction = this.queue.shift();
        
        try {
          await this.executeTransaction(transaction);
          console.log("事务执行成功:", transaction.id);
        } catch (error) {
          console.error("事务执行失败:", error.message);
          
          // 可以实现重试逻辑
          if (transaction.retryCount < 3) {
            transaction.retryCount++;
            this.queue.push(transaction);
          }
        }
      }
      
      this.processing = false;
    },
    
    async executeTransaction(transaction) {
      const session = db.client.startSession();
      
      try {
        await session.withTransaction(async () => {
          await transaction.operation(session);
        });
      } finally {
        await session.endSession();
      }
    }
  }
};
```

### 5.2 事务监控

#### 5.2.1 事务指标监控
```javascript
// 事务监控指标
const transactionMonitoring = {
  // 事务性能指标
  performanceMetrics: {
    // 监控事务执行时间
    async monitorExecutionTime() {
      const metrics = {
        totalTransactions: 0,
        successfulTransactions: 0,
        failedTransactions: 0,
        averageExecutionTime: 0,
        maxExecutionTime: 0,
        minExecutionTime: Infinity
      };
      
      // 监听系统事件
      db.system.profile.watch().on('change', (change) => {
        if (change.operationType === 'insert' && change.ns.endsWith('.transactions')) {
          const transaction = change.fullDocument;
          
          metrics.totalTransactions++;
          
          if (transaction.status === 'committed') {
            metrics.successfulTransactions++;
          } else if (transaction.status === 'aborted') {
            metrics.failedTransactions++;
          }
          
          // 更新执行时间统计
          const executionTime = new Date(transaction.updated_at) - new Date(transaction.created_at);
          metrics.averageExecutionTime = 
            (metrics.averageExecutionTime + executionTime) / 2;
          metrics.maxExecutionTime = Math.max(metrics.maxExecutionTime, executionTime);
          metrics.minExecutionTime = Math.min(metrics.minExecutionTime, executionTime);
        }
      });
      
      return metrics;
    },
    
    // 事务成功率监控
    async monitorSuccessRate(timeWindow = 3600000) { // 1小时
      const pipeline = [
        {
          $match: {
            created_at: {$gte: new Date(Date.now() - timeWindow)}
          }
        },
        {
          $group: {
            _id: '$status',
            count: {$sum: 1}
          }
        },
        {
          $project: {
            status: '$_id',
            count: 1,
            _id: 0
          }
        }
      ];
      
      const results = await db.transactions.aggregate(pipeline).toArray();
      
      const total = results.reduce((sum, result) => sum + result.count, 0);
      const successful = results.find(r => r.status === 'committed')?.count || 0;
      const successRate = total > 0 ? (successful / total) * 100 : 0;
      
      return {
        total,
        successful,
        failed: total - successful,
        successRate: successRate.toFixed(2) + '%'
      };
    }
  }
};
```

## 6. 事务最佳实践

### 6.1 设计模式

#### 6.1.1 事务性工作单元模式
```javascript
// 事务性工作单元模式
const unitOfWork = {
  // 工作单元实现
  UnitOfWork: {
    constructor() {
      this.newObjects = [];
      this.dirtyObjects = [];
      this.removedObjects = [];
      this.session = null;
    },
    
    async begin() {
      this.session = db.client.startSession();
    },
    
    async commit() {
      if (!this.session) {
        throw new Error("No active session");
      }
      
      await this.session.withTransaction(async () => {
        // 保存新对象
        for (const obj of this.newObjects) {
          await db[obj.collection].insertOne(obj.data, {session: this.session});
        }
        
        // 更新修改的对象
        for (const obj of this.dirtyObjects) {
          await db[obj.collection].updateOne(
            obj.filter,
            obj.update,
            {session: this.session}
          );
        }
        
        // 删除移除的对象
        for (const obj of this.removedObjects) {
          await db[obj.collection].deleteOne(obj.filter, {session: this.session});
        }
      });
      
      this.clear();
    },
    
    async rollback() {
      if (this.session) {
        await this.session.abortTransaction();
        await this.session.endSession();
        this.clear();
      }
    },
    
    registerNew(collection, data) {
      this.newObjects.push({collection, data});
    },
    
    registerDirty(collection, filter, update) {
      this.dirtyObjects.push({collection, filter, update});
    },
    
    registerRemoved(collection, filter) {
      this.removedObjects.push({collection, filter});
    },
    
    clear() {
      this.newObjects = [];
      this.dirtyObjects = [];
      this.removedObjects = [];
      this.session = null;
    }
  },
  
  // 使用工作单元模式
  async useUnitOfWork() {
    const uow = new this.UnitOfWork();
    
    try {
      await uow.begin();
      
      // 注册操作
      uow.registerNew('users', {
        name: 'John Doe',
        email: 'john@example.com',
        status: 'active'
      });
      
      uow.registerDirty('users',
        {email: 'john@example.com'},
        {$set: {last_login: new Date()}}
      );
      
      uow.registerRemoved('sessions', {user_id: userId});
      
      // 提交事务
      await uow.commit();
      
    } catch (error) {
      await uow.rollback();
      throw error;
    }
  }
};
```

#### 6.1.2 幂等性模式
```javascript
// 幂等性事务设计
const idempotentTransactions = {
  // 幂等性键模式
  IdempotencyKey: {
    // 使用幂等性键防止重复执行
    async executeIdempotent(operationId, operation) {
      // 检查操作是否已执行
      const existing = await db.operations.findOne({operation_id: operationId});
      
      if (existing) {
        return {
          success: true,
          result: existing.result,
          idempotent: true
        };
      }
      
      // 执行操作
      const session = db.client.startSession();
      
      try {
        const result = await session.withTransaction(async () => {
          // 记录操作开始
          await db.operations.insertOne({
            operation_id: operationId,
            status: 'running',
            started_at: new Date()
          }, {session});
          
          // 执行实际操作
          const operationResult = await operation(session);
          
          // 记录操作完成
          await db.operations.updateOne(
            {operation_id: operationId},
            {
              $set: {
                status: 'completed',
                result: operationResult,
                completed_at: new Date()
              }
            },
            {session}
          );
          
          return operationResult;
        });
        
        return {
          success: true,
          result,
          idempotent: false
        };
        
      } catch (error) {
        // 记录失败
        await db.operations.updateOne(
          {operation_id: operationId},
          {
            $set: {
              status: 'failed',
              error: error.message,
              failed_at: new Date()
            }
          }
        );
        
        throw error;
        
      } finally {
        await session.endSession();
      }
    }
  },
  
  // 示例：幂等性支付处理
  async processIdempotentPayment(paymentId, paymentData) {
    const idempotencyKey = `payment_${paymentId}`;
    
    return await this.IdempotencyKey.executeIdempotent(
      idempotencyKey,
      async (session) => {
        // 检查支付状态
        const existingPayment = await db.payments.findOne(
          {payment_id: paymentId},
          {session}
        );
        
        if (existingPayment) {
          return existingPayment;
        }
        
        // 创建支付记录
        const payment = await db.payments.insertOne({
          payment_id: paymentId,
          amount: paymentData.amount,
          currency: paymentData.currency,
          status: 'processing',
          created_at: new Date()
        }, {session});
        
        // 处理支付逻辑
        // ...
        
        // 更新支付状态
        await db.payments.updateOne(
          {payment_id: paymentId},
          {$set: {status: 'completed', completed_at: new Date()}},
          {session}
        );
        
        return payment;
      }
    );
  }
};
```

### 6.2 错误处理

#### 6.2.1 事务错误处理策略
```javascript
// 事务错误处理
const transactionErrorHandling = {
  // 错误分类和处理
  errorClassification: {
    // 可重试的错误
    retryableErrors: [
      {code: 112, name: 'WriteConflict'},
      {code: 11600, name: 'InterruptedAtShutdown'},
      {code: 10107, name: 'NotWritablePrimary'},
      {code: 13435, name: 'PrimarySteppedDown'}
    ],
    
    // 不可重试的错误
    nonRetryableErrors: [
      {code: 11000, name: 'DuplicateKey'},
      {code: 121, name: 'DocumentExceedsMaximumSize'},
      {code: 17284, name: 'IncompatibleServerVersion'}
    ],
    
    classifyError(error) {
      const retryable = this.retryableErrors.find(e => e.code === error.code);
      if (retryable) {
        return {type: 'retryable', category: retryable.name};
      }
      
      const nonRetryable = this.nonRetryableErrors.find(e => e.code === error.code);
      if (nonRetryable) {
        return {type: 'non-retryable', category: nonRetryable.name};
      }
      
      return {type: 'unknown', category: error.name || 'Unknown'};
    }
  },
  
  // 错误恢复策略
  recoveryStrategies: {
    // 自动重试策略
    async automaticRetry(operation, maxRetries = 3, backoffStrategy = 'exponential') {
      let attempt = 0;
      let lastError;
      
      while (attempt < maxRetries) {
        try {
          return await operation();
        } catch (error) {
          lastError = error;
          attempt++;
          
          const classification = this.errorClassification.classifyError(error);
          
          if (classification.type === 'non-retryable') {
            console.log(`非重试性错误，停止重试: ${classification.category}`);
            break;
          }
          
          if (attempt >= maxRetries) {
            console.log(`达到最大重试次数 (${maxRetries})`);
            break;
          }
          
          // 计算延迟时间
          let delay = 0;
          switch (backoffStrategy) {
            case 'exponential':
              delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000);
              break;
            case 'linear':
              delay = 100 * attempt;
              break;
            case 'fixed':
              delay = 1000;
              break;
          }
          
          console.log(`重试第 ${attempt} 次，等待 ${delay}ms: ${error.message}`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
      
      throw lastError;
    },
    
    // 降级策略
    fallbackStrategies: {
      // 读操作降级
      async fallbackRead(operation, fallbackOperation) {
        try {
          return await operation();
        } catch (error) {
          console.log("事务读操作失败，使用降级策略");
          
          // 尝试从缓存或从库读取
          return await fallbackOperation();
        }
      },
      
      // 写操作补偿
      async compensateWrite(originalOperation, compensationOperation) {
        const session = db.client.startSession();
        
        try {
          await session.withTransaction(originalOperation);
        } catch (error) {
          console.log("事务写操作失败，执行补偿操作");
          
          try {
            await compensationOperation();
          } catch (compensationError) {
            console.error("补偿操作也失败:", compensationError.message);
          }
          
          throw error;
        } finally {
          await session.endSession();
        }
      }
    }
  }
};
```

---

*第5章深入探讨了MongoDB事务处理的各个方面，包括ACID属性保证、多文档事务、事务隔离级别、分布式事务以及性能优化和最佳实践。理解这些概念对于构建可靠的数据驱动应用程序至关重要。*