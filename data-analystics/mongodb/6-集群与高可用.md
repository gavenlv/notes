# 第6章：集群与高可用

## 目录
1. [集群架构概述](#1-集群架构概述)
2. [副本集（Replica Set）](#2-副本集replica-set)
3. [分片集群（Sharded Cluster）](#3-分片集群sharded-cluster)
4. [高可用性配置](#4-高可用性配置)
5. [负载均衡](#5-负载均衡)
6. [故障转移](#6-故障转移)
7. [监控与维护](#7-监控与维护)

## 1. 集群架构概述

### 1.1 MongoDB集群架构类型

#### 1.1.1 副本集架构
```javascript
// MongoDB副本集架构设计
const replicaSetArchitecture = {
  // 基本副本集结构
  basicReplicaSet: {
    components: {
      primary: {
        description: "主节点：处理所有写操作",
        responsibilities: [
          "处理客户端写请求",
          "维护数据最新状态",
          "选举和投票",
          "处理读操作（如果有配置）"
        ],
        configuration: {
          priority: 3,        // 优先级，越高越容易成为主节点
          votes: 1,           // 投票权
          hidden: false,      // 是否隐藏（客户端不连接）
          slaveDelay: 0       // 延迟复制时间（秒）
        }
      },
      
      secondary: {
        description: "从节点：复制主节点数据",
        types: {
          regular: {
            description: "常规从节点",
            canBecomePrimary: true,
            canServeReadRequests: true
          },
          hidden: {
            description: "隐藏从节点",
            canBecomePrimary: false,
            canServeReadRequests: false,
            useCase: "备份和报告"
          },
          arbiter: {
            description: "仲裁节点",
            doesNotStoreData: true,
            canBecomePrimary: false,
            useCase: "奇数节点投票"
          }
        }
      }
    },
    
    // 副本集配置示例
    configuration: {
      _id: "myReplicaSet",
      members: [
        {
          _id: 0,
          host: "server1:27017",
          priority: 3,
          tags: {
            data_center: "dc1",
            role: "production"
          }
        },
        {
          _id: 1,
          host: "server2:27017",
          priority: 2,
          tags: {
            data_center: "dc1",
            role: "production"
          }
        },
        {
          _id: 2,
          host: "server3:27017",
          priority: 1,
          tags: {
            data_center: "dc2",
            role: "production"
          }
        },
        {
          _id: 3,
          host: "backup-server:27017",
          priority: 0,
          hidden: true,
          tags: {
            role: "backup"
          }
        }
      ],
      settings: {
        chainingAllowed: true,        // 允许链式复制
        heartbeatTimeoutSecs: 10,     // 心跳超时时间
        electionTimeoutMs: 10000,     // 选举超时时间
        catchUpTimeoutMillis: -1      // 追赶超时时间（无限制）
      }
    }
  }
};
```

#### 1.1.2 分片集群架构
```javascript
// MongoDB分片集群架构设计
const shardedClusterArchitecture = {
  // 分片集群组件
  components: {
    // 配置服务器
    configServers: {
      purpose: "存储集群元数据和配置信息",
      components: {
        mongod: {
          description: "配置服务器实例",
          requirements: "必须使用副本集",
          data: [
            "chunks信息",
            "所有shard的主机名",
            "集群chunk分布信息"
          ]
        }
      },
      
      configuration: {
        configReplSet: {
          _id: "configReplSet",
          members: [
            {_id: 0, host: "config1:27019"},
            {_id: 1, host: "config2:27019"},
            {_id: 2, host: "config3:27019"}
          ]
        }
      }
    },
    
    // 分片服务器
    shardServers: {
      purpose: "实际存储数据",
      architecture: "每个shard本身是一个副本集",
      shardingStrategy: {
        range: {
          description: "范围分片",
          useCase: "范围查询频繁",
          advantages: ["高效范围查询", "顺序写性能好"],
          disadvantages: ["热点风险", "数据分布不均"]
        },
        hash: {
          description: "哈希分片",
          useCase: "数据写入均匀",
          advantages: ["数据分布均匀", "写负载分散"],
          disadvantages: ["范围查询效率低", "随机读较多"]
        }
      },
      
      configuration: {
        shard1ReplSet: {
          _id: "shard1",
          members: [
            {_id: 0, host: "shard1-1:27018"},
            {_id: 1, host: "shard1-2:27018"},
            {_id: 2, host: "shard1-3:27018"}
          ]
        },
        shard2ReplSet: {
          _id: "shard2",
          members: [
            {_id: 0, host: "shard2-1:27018"},
            {_id: 1, host: "shard2-2:27018"},
            {_id: 2, host: "shard2-3:27018"}
          ]
        }
      }
    },
    
    // 查询路由器
    mongos: {
      purpose: "查询路由和结果聚合",
      responsibilities: [
        "接收客户端查询请求",
        "确定查询涉及的分片",
        "将查询分发到相应分片",
        "聚合和返回结果",
        "管理chunk分裂和迁移"
      ],
      
      configuration: {
        configDB: "configReplSet/config1:27019,config2:27019,config3:27019",
        sharding: {
          enabled: true
        }
      }
    }
  }
};
```

### 1.2 集群设计原则

#### 1.2.1 高可用性设计
```javascript
// 高可用性集群设计
const highAvailabilityDesign = {
  // 地理分布策略
  geographicDistribution: {
    // 多数据中心部署
    multiDCDeployment: {
      primaryDC: {
        location: "北京",
        purpose: "主数据中心",
        components: {
          primaryNodes: 2,    // 主节点副本
          secondaryNodes: 1,  // 从节点副本
          arbiterNodes: 1     // 仲裁节点
        }
      },
      
      secondaryDC: {
        location: "上海",
        purpose: "灾备数据中心",
        components: {
          primaryNodes: 0,    // 不作为主节点
          secondaryNodes: 2,  // 从节点副本
          hiddenNodes: 1      // 隐藏备份节点
        }
      },
      
      arbiterDC: {
        location: "广州",
        purpose: "独立仲裁",
        components: {
          arbiterNodes: 1     // 纯仲裁节点
        }
      }
    },
    
    // 跨区域延迟考虑
    latencyConsiderations: {
      readPreference: {
        // 读偏好设置
        nearReadPreference: async () => {
          // 根据用户位置选择最近的数据中心
          const userLocation = "北京";
          
          let readPreference = "primary";
          
          switch (userLocation) {
            case "北京":
              readPreference = {
                mode: "nearest",
                maxStalenessMS: 10000  // 最大延迟10秒
              };
              break;
            case "上海":
              readPreference = {
                mode: "secondary",
                maxStalenessMS: 30000
              };
              break;
            default:
              readPreference = "secondaryPreferred";
          }
          
          return readPreference;
        }
      },
      
      writeConcern: {
        // 写关注配置
        writeConcernStrategy: async (operation) => {
          const dc = "北京";
          
          let writeConcern = {w: "majority"};
          
          // 根据操作重要性调整写关注
          if (operation === "critical_transaction") {
            writeConcern = {
              w: "majority",
              j: true,        // 日志确认
              wtimeout: 5000  // 5秒超时
            };
          } else if (operation === "analytics_query") {
            writeConcern = {w: 1};  // 最小写入保证
          }
          
          return writeConcern;
        }
      }
    }
  },
  
  // 容量规划
  capacityPlanning: {
    // 数据增长预估
    dataGrowthEstimation: {
      currentDataSize: 100, // GB
      growthRate: 0.2,      // 每月20%增长
      projectedMonths: 12,
      
      calculateProjectedSize() {
        const monthlyGrowth = this.growthRate;
        const months = this.projectedMonths;
        
        const projectedSize = this.currentDataSize * Math.pow(1 + monthlyGrowth, months);
        return Math.ceil(projectedSize);
      },
      
      shardingRecommendations: {
        shardSize: 1024, // GB per shard
        recommendedShards: 0,
        chunkSize: 256   // MB per chunk
      }
    },
    
    // 性能需求评估
    performanceRequirements: {
      // 读写QPS评估
      qpsEstimates: {
        readQPS: 10000,
        writeQPS: 2000,
        peakReadQPS: 15000,
        peakWriteQPS: 3000
      },
      
      // 集群规格建议
      clusterSpecs: {
        shardCount: 3,           // 分片数量
        replicaPerShard: 3,      // 每个分片的副本数
        nodeSpecs: {
          cpu: "16 cores",
          memory: "64 GB",
          storage: "SSD 1TB",
          network: "10 Gbps"
        }
      }
    }
  }
};
```

## 2. 副本集（Replica Set）

### 2.1 副本集基础配置

#### 2.1.1 副本集初始化
```javascript
// MongoDB副本集初始化和管理
const replicaSetManagement = {
  // 副本集初始化脚本
  initializationScript: `
    // 1. 启动各个节点
    // mongod --replSet myReplSet --dbpath /data/db1 --port 27017
    // mongod --replSet myReplSet --dbpath /data/db2 --port 27018
    // mongod --replSet myReplSet --dbpath /data/db3 --port 27019
    
    // 2. 连接主节点并初始化副本集
  `,
  
  // 使用Node.js进行副本集初始化
  initializeReplicaSet: {
    // 连接到副本集
    async connectToReplicaSet(replicaSetName, hosts) {
      const {MongoClient} = require('mongodb');
      
      const client = new MongoClient(
        \`mongodb://\${hosts.join(',')}/\${replicaSetName}?replicaSet=\${replicaSetName}\`
      );
      
      try {
        await client.connect();
        console.log("连接到副本集:", replicaSetName);
        
        // 获取数据库连接
        const db = client.db('admin');
        
        // 初始化副本集配置
        const config = {
          _id: replicaSetName,
          members: hosts.map((host, index) => ({
            _id: index,
            host: host,
            priority: index === 0 ? 3 : 1,  // 第一个节点优先级最高
            tags: {
              data_center: index < 2 ? 'dc1' : 'dc2',
              role: 'production'
            }
          }))
        };
        
        // 执行初始化
        const result = await db.admin().command({
          replSetInitiate: config
        });
        
        console.log("副本集初始化结果:", result);
        return result;
        
      } finally {
        await client.close();
      }
    },
    
    // 检查副本集状态
    async checkReplicaSetStatus(replicaSetName, hosts) {
      const {MongoClient} = require('mongodb');
      
      const client = new MongoClient(
        \`mongodb://\${hosts.join(',')}/\${replicaSetName}?replicaSet=\${replicaSetName}\`
      );
      
      try {
        await client.connect();
        const admin = client.db('admin').admin();
        
        // 获取副本集状态
        const status = await admin.command({replSetGetStatus: 1});
        
        console.log("副本集状态:");
        console.log("- 副本集名称:", status.set);
        console.log("- 节点数量:", status.members.length);
        console.log("- 当前主节点:", status.members.find(m => m.self)?.name || '无');
        
        // 详细节点信息
        status.members.forEach((member, index) => {
          console.log(\`节点 \${index + 1}: \${member.name}\`);
          console.log(\`  - 状态: \${member.health === 1 ? '健康' : '异常'}\`);
          console.log(\`  - 角色: \${member.self ? '主节点' : (member.ArbiterOnly ? '仲裁节点' : '从节点')}\`);
          console.log(\`  - 运行时间: \${member.uptime}秒\`);
          console.log(\`  - 最后心跳: \${new Date(member.lastHeartbeat).toLocaleString()}\`);
          if (member.self) {
            console.log(\`  - 数据延迟: \${member.self.syncingTo || 'N/A'}\`);
          }
        });
        
        return status;
        
      } finally {
        await client.close();
      }
    }
  }
};
```

#### 2.1.2 副本集节点管理
```javascript
// 副本集节点管理操作
const replicaSetNodeManagement = {
  // 添加节点
  async addNode(replicaSetName, hosts, newNodeHost) {
    const {MongoClient} = require('mongodb');
    
    const client = new MongoClient(
      \`mongodb://\${hosts.join(',')}/\${replicaSetName}?replicaSet=\${replicaSetName}\`
    );
    
    try {
      await client.connect();
      const admin = client.db('admin').admin();
      
      // 获取当前配置
      const config = await admin.command({replSetGetConfig: 1});
      
      // 添加新节点
      config.config.members.push({
        _id: config.config.members.length,
        host: newNodeHost,
        priority: 1,
        tags: {
          data_center: 'dc3',
          role: 'standby'
        }
      });
      
      // 更新配置
      await admin.command({
        replSetReconfig: config.config,
        force: false
      });
      
      console.log("节点添加成功:", newNodeHost);
      
    } finally {
      await client.close();
    }
  },
  
  // 移除节点
  async removeNode(replicaSetName, hosts, targetNodeHost) {
    const {MongoClient} = require('mongodb');
    
    const client = new MongoClient(
      \`mongodb://\${hosts.join(',')}/\${replicaSetName}?replicaSet=\${replicaSetName}\`
    );
    
    try {
      await client.connect();
      const admin = client.db('admin').admin();
      
      // 获取当前配置
      const config = await admin.command({replSetGetConfig: 1});
      
      // 找到并移除目标节点
      const memberIndex = config.config.members.findIndex(m => m.host === targetNodeHost);
      if (memberIndex === -1) {
        throw new Error(\`节点 \${targetNodeHost} 不存在\`);
      }
      
      config.config.members.splice(memberIndex, 1);
      
      // 更新配置
      await admin.command({
        replSetReconfig: config.config
      });
      
      console.log("节点移除成功:", targetNodeHost);
      
    } finally {
      await client.close();
    }
  },
  
  // 节点优先级调整
  async adjustNodePriority(replicaSetName, hosts, nodeHost, newPriority) {
    const {MongoClient} = require('mongodb');
    
    const client = new MongoClient(
      \`mongodb://\${hosts.join(',')}/\${replicaSetName}?replicaSet=\${replicaSetName}\`
    );
    
    try {
      await client.connect();
      const admin = client.db('admin').admin();
      
      // 获取当前配置
      const config = await admin.command({replSetGetConfig: 1});
      
      // 找到并更新节点优先级
      const member = config.config.members.find(m => m.host === nodeHost);
      if (!member) {
        throw new Error(\`节点 \${nodeHost} 不存在\`);
      }
      
      member.priority = newPriority;
      
      // 更新配置
      await admin.command({
        replSetReconfig: config.config
      });
      
      console.log(\`节点 \${nodeHost} 优先级已更新为: \${newPriority}\`);
      
    } finally {
      await client.close();
    }
  },
  
  // 隐藏节点配置
  async configureHiddenNode(replicaSetName, hosts, nodeHost) {
    const {MongoClient} = require('mongodb');
    
    const client = new MongoClient(
      \`mongodb://\${hosts.join(',')}/\${replicaSetName}?replicaSet=\${replicaSetName}\`
    );
    
    try {
      await client.connect();
      const admin = client.db('admin').admin();
      
      // 获取当前配置
      const config = await admin.command({replSetGetConfig: 1});
      
      // 找到并配置隐藏节点
      const member = config.config.members.find(m => m.host === nodeHost);
      if (!member) {
        throw new Error(\`节点 \${nodeHost} 不存在\`);
      }
      
      // 配置为隐藏节点
      member.priority = 0;
      member.hidden = true;
      member.tags = {
        ...member.tags,
        role: 'backup'
      };
      
      // 更新配置
      await admin.command({
        replSetReconfig: config.config
      });
      
      console.log(\`节点 \${nodeHost} 已配置为隐藏节点\`);
      
    } finally {
      await client.close();
    }
  }
};
```

### 2.2 数据复制与同步

#### 2.2.1 复制原理
```javascript
// MongoDB复制原理和机制
const replicationMechanism = {
  // 复制流程
  replicationFlow: {
    // 操作日志（Oplog）
    oplogDescription: {
      purpose: "记录所有数据变更操作",
      characteristics: [
        "固定大小集合",
        "幂等操作",
        "按时间排序",
        "支持异步复制"
      ],
      
      // Oplog结构
      oplogStructure: async () => {
        const {MongoClient} = require('mongodb');
        
        const client = new MongoClient('mongodb://localhost:27017');
        
        try {
          await client.connect();
          const db = client.db('local');
          const oplog = db.collection('oplog.rs');
          
          // 查看最近的Oplog条目
          const recentOps = await oplog
            .find({})
            .sort({$natural: -1})
            .limit(5)
            .toArray();
          
          console.log("最近的Oplog操作:");
          recentOps.forEach(op => {
            console.log({
              ts: op.ts,           // 时间戳
              h: op.h,             // 操作哈希
              op: op.op,           // 操作类型 (i=insert, u=update, d=delete, c=command)
              ns: op.ns,           // 命名空间
              from: op.from,       // 来源主机（用于同步）
              o: op.o              // 操作对象
            });
          });
          
        } finally {
          await client.close();
        }
      }
    },
    
    // 复制流程详解
    replicationProcess: {
      // 1. 主节点写入操作
      primaryWrite: {
        description: "客户端写入主节点",
        process: [
          "客户端发送写操作到主节点",
          "主节点验证操作",
          "将操作写入Oplog",
          "执行写操作到数据文件",
          "向客户端确认写入",
          "返回写入结果"
        ],
        
        example: async () => {
          const {MongoClient} = require('mongodb');
          
          const client = new MongoClient('mongodb://primary-host:27017');
          
          try {
            await client.connect();
            const db = client.db('mydb');
            const collection = db.collection('users');
            
            // 写入操作
            const result = await collection.insertOne({
              name: "John Doe",
              email: "john@example.com",
              age: 30
            });
            
            console.log("写入结果:", result.insertedId);
            console.log("写入确认时间:", new Date());
            
          } finally {
            await client.close();
          }
        }
      },
      
      // 2. 从节点同步操作
      secondarySync: {
        description: "从节点从主节点复制操作",
        process: [
          "从节点向主节点发起同步请求",
          "主节点返回Oplog条目",
          "从节点应用Oplog操作",
          "更新本地数据",
          "更新同步进度",
          "继续下一轮同步"
        ],
        
        // 从节点同步管理
        syncManagement: {
          // 检查从节点同步状态
          async checkSyncStatus() {
            const {MongoClient} = require('mongodb');
            
            const client = new MongoClient('mongodb://secondary-host:27017');
            
            try {
              await client.connect();
              const admin = client.db('admin').admin();
              
              // 获取复制状态
              const replicationStatus = await admin.command({replSetGetStatus: 1});
              
              const selfMember = replicationStatus.members.find(m => m.self);
              if (selfMember) {
                console.log("从节点同步状态:");
                console.log("- 同步目标:", selfMember.syncingTo || '无');
                console.log("- 滞后操作数:", selfMember.optime?.lag);
                console.log("- 最后操作时间:", new Date(selfMember.optime?.ts * 1000));
              }
              
            } finally {
              await client.close();
            }
          },
          
          // 手动重新同步
          async forceResync() {
            const {MongoClient} = require('mongodb');
            
            const client = new MongoClient('mongodb://secondary-host:27017');
            
            try {
              await client.connect();
              const admin = client.db('admin').admin();
              
              // 执行重新同步
              const result = await admin.command({resync: 1});
              console.log("重新同步结果:", result);
              
            } finally {
              await client.close();
            }
          }
        }
      }
    }
  }
};
```

#### 2.2.2 复制延迟和优化
```javascript
// 复制延迟监控和优化
const replicationOptimization = {
  // 复制延迟监控
  lagMonitoring: {
    // 计算复制延迟
    async calculateReplicationLag() {
      const {MongoClient} = require('mongodb');
      
      const client = new MongoClient('mongodb://primary-host:27017');
      
      try {
        await client.connect();
        const admin = client.db('admin').admin();
        
        // 获取复制状态
        const status = await admin.command({replSetGetStatus: 1});
        const primary = status.members.find(m => m.self);
        
        const results = [];
        
        for (const member of status.members) {
          if (!member.self) {
            const primaryTime = new Date(primary.optime.ts * 1000);
            const memberTime = member.optime ? new Date(member.optime.ts * 1000) : null;
            
            const lagSeconds = memberTime ? (primaryTime - memberTime) / 1000 : null;
            
            results.push({
              host: member.name,
              health: member.health,
              state: member.stateStr,
              replicationLag: lagSeconds,
              lastHeartbeat: new Date(member.lastHeartbeat).toLocaleString(),
              syncSource: member.syncingTo || 'N/A'
            });
          }
        }
        
        return results;
        
      } finally {
        await client.close();
      }
    },
    
    // 持续监控复制延迟
    async monitorReplicationLag(intervalMs = 60000) {
      console.log("开始复制延迟监控...");
      
      setInterval(async () => {
        try {
          const lagData = await this.calculateReplicationLag();
          
          lagData.forEach(data => {
            console.log(\`[\${new Date().toLocaleTimeString()}] \${data.host}: 延迟 \${data.replicationLag?.toFixed(2) || 'N/A'}秒\`);
            
            if (data.replicationLag > 60) {
              console.warn(\`⚠️  \${data.host} 复制延迟过高!\`);
            }
          });
          
        } catch (error) {
          console.error("监控错误:", error.message);
        }
      }, intervalMs);
    }
  },
  
  // 复制优化策略
  optimizationStrategies: {
    // 1. 网络优化
    networkOptimization: {
      // 配置网络参数
      networkConfig: {
        // 主节点配置
        primaryConfig: `
          # MongoDB主节点配置
          net:
            maxIncomingConnections: 1000
            wireObjectCheck: true
            
          replication:
            oplogSizeMB: 51200  # 50GB Oplog
            replSetName: "myReplSet"
        `,
        
        // 从节点配置
        secondaryConfig: `
          # MongoDB从节点配置
          net:
            maxIncomingConnections: 1000
            
          replication:
            oplogSizeMB: 51200
            replSetName: "myReplSet"
            readPreference: "secondaryPreferred"
            
          storage:
            wiredTiger:
              collectionConfig:
                blockCompressor: snappy  # 压缩算法
              engineConfig:
                cacheSizeGB: 16         # 缓存大小
        `
      }
    },
    
    // 2. 写关注优化
    writeConcernOptimization: {
      // 根据延迟调整写关注
      adaptiveWriteConcern: async (primaryHost, secondaryHosts) => {
        const {MongoClient} = require('mongodb');
        
        const client = new MongoClient(\`mongodb://\${primaryHost}\`);
        
        try {
          await client.connect();
          const admin = client.db('admin').admin();
          const status = await admin.command({replSetGetStatus: 1});
          
          // 计算平均复制延迟
          const activeSecondaries = status.members.filter(m => !m.self && m.health === 1);
          const avgLag = activeSecondaries.reduce((sum, m) => {
            if (m.optime) {
              const primaryTime = new Date(status.date);
              const memberTime = new Date(m.optime.ts * 1000);
              return sum + (primaryTime - memberTime) / 1000;
            }
            return sum;
          }, 0) / activeSecondaries.length;
          
          // 根据延迟选择写关注
          let writeConcern;
          
          if (avgLag < 1) {
            // 低延迟：使用更强的写关注
            writeConcern = {w: "majority", j: true, wtimeout: 3000};
          } else if (avgLag < 5) {
            // 中等延迟
            writeConcern = {w: "majority", j: false, wtimeout: 5000};
          } else {
            // 高延迟：使用较弱的写关注
            writeConcern = {w: 1, j: false, wtimeout: 10000};
          }
          
          return writeConcern;
          
        } finally {
          await client.close();
        }
      }
    },
    
    // 3. 批量写入优化
    batchWriteOptimization: {
      // 批量插入优化
      optimizedBulkInsert: async (collection, documents, options = {}) => {
        const defaultOptions = {
          ordered: false,           // 无序写入
          writeConcern: {w: "majority"},
          bypassDocumentValidation: false
        };
        
        const finalOptions = {...defaultOptions, ...options};
        
        // 分批处理大量文档
        const batchSize = 1000;
        const batches = [];
        
        for (let i = 0; i < documents.length; i += batchSize) {
          const batch = documents.slice(i, i + batchSize);
          batches.push(batch);
        }
        
        let totalInserted = 0;
        const results = [];
        
        for (const batch of batches) {
          try {
            const result = await collection.insertMany(batch, finalOptions);
            totalInserted += result.insertedCount;
            results.push(result);
          } catch (error) {
            console.error("批次插入失败:", error.message);
            // 继续处理下一批
          }
        }
        
        return {
          totalInserted,
          batchCount: batches.length,
          results
        };
      }
    }
  }
};
```

## 3. 分片集群（Sharded Cluster）

### 3.1 分片配置

#### 3.1.1 分片键选择
```javascript
// MongoDB分片键选择策略
const shardKeySelection = {
  // 分片键评估标准
  evaluationCriteria: {
    // 1. 基数（Cardinality）
    cardinalityAnalysis: {
      calculateCardinality: (collection, field) => {
        const pipeline = [
          {$group: {_id: \`$\${field}\`, count: {$sum: 1}}},
          {$count: "uniqueValues"}
        ];
        
        return db.collection.aggregate(pipeline);
      },
      
      // 高基数 vs 低基数
      cardinalityComparison: {
        highCardinality: {
          field: "user_id",
          uniqueValues: 1000000,
          description: "高基数：数据分布均匀",
          advantages: ["更好的数据分布", "避免热点", "查询分布均匀"],
          disadvantages: ["查询需要扫描多个分片"]
        },
        
        lowCardinality: {
          field: "status",
          uniqueValues: 5,
          description: "低基数：数据分布不均",
          advantages: ["简单查询", "读取效率高"],
          disadvantages: ["数据倾斜", "热点分片", "扩展困难"]
        }
      }
    },
    
    // 2. 频率（Frequency）
    frequencyAnalysis: {
      analyzeFrequency: (collection, field) => {
        const pipeline = [
          {$group: {_id: \`$\${field}\`, count: {$sum: 1}}},
          {$sort: {count: -1}},
          {$limit: 100}
        ];
        
        return db.collection.aggregate(pipeline);
      }
    },
    
    // 3. 查询模式（Query Patterns）
    queryPatternAnalysis: {
      commonQueries: [
        {
          query: {user_id: "12345"},
          frequency: 1000,  // 每秒查询次数
          type: "equality"
        },
        {
          query: {created_date: {$gte: ISODate("2024-01-01")}},
          frequency: 500,
          type: "range"
        },
        {
          query: {user_id: "12345", created_date: {$gte: ISODate("2024-01-01")}},
          frequency: 100,
          type: "compound"
        }
      ]
    }
  },
  
  // 分片策略选择
  shardingStrategies: {
    // 范围分片策略
    rangeSharding: {
      description: "基于分片键的范围进行分片",
      bestFor: [
        "范围查询频繁",
        "数据按时间或ID顺序增长",
        "需要顺序访问数据"
      ],
      
      configuration: {
        // 启用范围分片
        enableRangeSharding: async (database, collection, shardKey) => {
          const {MongoClient} = require('mongodb');
          
          const client = new MongoClient('mongodb://mongos-host:27017');
          
          try {
            await client.connect();
            const admin = client.db('admin').admin();
            
            // 启用分片
            await admin.command({enableSharding: database});
            
            // 创建范围分片集合
            await admin.command({
              shardCollection: \`\${database}.\${collection}\`,
              key: {[shardKey]: 1}  // 1表示升序，-1表示降序
            });
            
            console.log(\`已启用 \${database}.\${collection} 的范围分片\`);
            
          } finally {
            await client.close();
          }
        }
      },
      
      // 分片键选择建议
      keySelectionGuide: {
        goodKeys: [
          "_id",          // 自然主键
          "created_at",   // 时间戳
          "user_id",      // 用户ID
          "timestamp"     // 时间戳
        ],
        
        badKeys: [
          "status",       // 低基数
          "category",     // 枚举值
          "is_active"     // 布尔值
        ],
        
        compoundKeys: {
          example: {"user_id": 1, "created_at": 1},
          advantages: [
            "结合了多个字段的优势",
            "可以同时支持范围和等值查询",
            "提供更好的数据分布"
          ]
        }
      }
    },
    
    // 哈希分片策略
    hashSharding: {
      description: "基于分片键的哈希值进行分片",
      bestFor: [
        "数据写入负载均衡",
        "随机查询模式",
        "避免热点写入"
      ],
      
      configuration: {
        // 启用哈希分片
        enableHashSharding: async (database, collection, shardKey) => {
          const {MongoClient} = require('mongodb');
          
          const client = new MongoClient('mongodb://mongos-host:27017');
          
          try {
            await client.connect();
            const admin = client.db('admin').admin();
            
            // 启用分片
            await admin.command({enableSharding: database});
            
            // 创建哈希分片集合
            await admin.command({
              shardCollection: \`\${database}.\${collection}\`,
              key: {[shardKey]: "hashed"}  // 哈希分片
            });
            
            console.log(\`已启用 \${database}.\${collection} 的哈希分片\`);
            
          } finally {
            await client.close();
          }
        }
      }
    }
  }
};
```

#### 3.1.2 分片配置管理
```javascript
// MongoDB分片集群配置管理
const shardConfiguration = {
  // 分片集群初始化
  clusterInitialization: {
    // 配置服务器启动
    startConfigServers: async () => {
      const configServers = [
        "config1:27019",
        "config2:27019", 
        "config3:27019"
      ];
      
      // 启动脚本示例
      const startScript = configServers.map((host, index) => `
        # 启动配置服务器${index + 1}
        mongod --configsvr 
               --replSet configReplSet 
               --port 27019 
               --dbpath /data/config${index + 1}
               --logpath /var/log/mongodb/config${index + 1}.log
               --fork
      `).join('\n');
      
      return startScript;
    },
    
    // 分片服务器启动
    startShardServers: async () => {
      const shards = [
        {id: 1, hosts: ["shard1-1:27018", "shard1-2:27018", "shard1-3:27018"]},
        {id: 2, hosts: ["shard2-1:27018", "shard2-2:27018", "shard2-3:27018"]},
        {id: 3, hosts: ["shard3-1:27018", "shard3-2:27018", "shard3-3:27018"]}
      ];
      
      const scripts = [];
      
      for (const shard of shards) {
        scripts.push(`
          # 分片 ${shard.id} 副本集初始化
          mongod --replSet shard${shard.id}
                 --shardsvr
                 --port 27018
                 --dbpath /data/shard${shard.id}
                 --logpath /var/log/mongodb/shard${shard.id}.log
                 --fork
        `);
      }
      
      return scripts.join('\n');
    },
    
    // 初始化分片集群
    async initializeCluster() {
      const {MongoClient} = require('mongodb');
      
      const client = new MongoClient('mongodb://mongos-host:27017');
      
      try {
        await client.connect();
        const admin = client.db('admin').admin();
        
        // 1. 添加分片
        const shards = [
          "shard1/shard1-1:27018,shard1-2:27018,shard1-3:27018",
          "shard2/shard2-1:27018,shard2-2:27018,shard2-3:27018",
          "shard3/shard3-1:27018,shard3-2:27018,shard3-3:27018"
        ];
        
        for (const shard of shards) {
          await admin.command({addShard: shard});
          console.log("添加分片:", shard);
        }
        
        // 2. 启用数据库分片
        await admin.command({enableSharding: "mydb"});
        
        // 3. 配置集合分片
        await admin.command({
          shardCollection: "mydb.users",
          key: {user_id: "hashed"}
        });
        
        await admin.command({
          shardCollection: "mydb.orders", 
          key: {created_at: 1}
        });
        
        console.log("分片集群初始化完成");
        
      } finally {
        await client.close();
      }
    }
  },
  
  // Chunk管理
  chunkManagement: {
    // 查看Chunk分布
    async viewChunkDistribution(database, collection) {
      const {MongoClient} = require('mongodb');
      
      const client = new MongoClient('mongodb://mongos-host:27017');
      
      try {
        await client.connect();
        const admin = client.db('admin').admin();
        
        // 获取chunk分布信息
        const distribution = await admin.command({
          collStats: \`\${database}.\${collection}\`
        });
        
        console.log(\`集合 \${database}.\${collection} 的chunk分布:\`);
        console.log("总chunk数:", distribution.chunkCount);
        console.log("数据大小:", \`\${(distribution.size / 1024 / 1024).toFixed(2)} MB\`);
        
        // 获取详细的chunk信息
        const configDB = client.db('config');
        const chunks = await configDB.collection('chunks')
          .find({ns: \`\${database}.\${collection}\`})
          .sort({min: 1})
          .toArray();
        
        chunks.forEach(chunk => {
          console.log(\`Chunk: [\${JSON.stringify(chunk.min)} - \${JSON.stringify(chunk.max)}] → \${chunk.shard}\`);
        });
        
        return chunks;
        
      } finally {
        await client.close();
      }
    },
    
    // 手动移动chunk
    async moveChunk(database, collection, chunkBounds, targetShard) {
      const {MongoClient} = require('mongodb');
      
      const client = new MongoClient('mongodb://mongos-host:27017');
      
      try {
        await client.connect();
        const admin = client.db('admin').admin();
        
        // 执行chunk移动
        const result = await admin.command({
          moveChunk: \`\${database}.\${collection}\`,
          bounds: chunkBounds,
          to: targetShard,
          find: chunkBounds[0]  // 查找chunk的查询
        });
        
        console.log(\`Chunk移动结果: \${JSON.stringify(result)}\`);
        return result;
        
      } finally {
        await client.close();
      }
    },
    
    // 分裂chunk
    async splitChunk(database, collection, splitPoint) {
      const {MongoClient} = require('mongodb');
      
      const client = new MongoClient('mongodb://mongos-host:27017');
      
      try {
        await client.connect();
        const admin = client.db('admin').admin();
        
        // 执行chunk分裂
        const result = await admin.command({
          split: \`\${database}.\${collection}\`,
          middle: splitPoint
        });
        
        console.log(\`Chunk分裂结果: \${JSON.stringify(result)}\`);
        return result;
        
      } finally {
        await client.close();
      }
    }
  }
};
```

### 3.2 数据分布与查询

#### 3.2.1 查询路由器配置
```javascript
// MongoDB查询路由器（Mongos）配置和优化
const mongosConfiguration = {
  // Mongos配置优化
  configurationOptimization: {
    // 连接池配置
    connectionPooling: {
      maxPoolSize: 100,
      minPoolSize: 5,
      maxIdleTimeMS: 300000,
      waitQueueMultiple: 5,
      
      example: async () => {
        const {MongoClient} = require('mongodb');
        
        const client = new MongoClient('mongodb://mongos-host:27017', {
          maxPoolSize: 100,
          minPoolSize: 5,
          maxIdleTimeMS: 300000,
          serverSelectionTimeoutMS: 30000,
          socketTimeoutMS: 45000,
          heartbeatFrequencyMS: 10000
        });
        
        try {
          await client.connect();
          
          // 连接池统计
          const topology = client.topology;
          console.log("连接池状态:", {
            available: topology.s.pool.availableLength(),
            inUse: topology.s.pool.inUsePairs().length,
            waiting: topology.s.pool.waiting
          });
          
        } finally {
          await client.close();
        }
      }
    },
    
    // 查询路由优化
    queryRoutingOptimization: {
      // 优化读偏好
      optimizeReadPreference: {
        primaryPreferred: async () => {
          // 主节点优先读偏好
          const client = new MongoClient('mongodb://mongos-host:27017', {
            readPreference: {
              mode: 'primaryPreferred',
              maxStalenessMS: 10000
            }
          });
          
          try {
            await client.connect();
            const db = client.db('mydb');
            
            // 这个查询将优先在主节点执行
            const result = await db.collection('users').find({
              created_at: {$gte: new Date(Date.now() - 24 * 60 * 60 * 1000)}
            }).toArray();
            
            return result;
            
          } finally {
            await client.close();
          }
        },
        
        nearest: async () => {
          // 最近节点读偏好
          const client = new MongoClient('mongodb://mongos-host:27017', {
            readPreference: {
              mode: 'nearest',
              maxStalenessMS: 30000
            }
          });
          
          try {
            await client.connect();
            const db = client.db('mydb');
            
            // 查询将在网络延迟最短的节点执行
            const result = await db.collection('users').find({
              status: 'active'
            }).toArray();
            
            return result;
            
          } finally {
            await client.close();
          }
        }
      },
      
      // 聚合管道优化
      aggregationOptimization: {
        // 分片聚合优化
        optimizedAggregation: async () => {
          const client = new MongoClient('mongodb://mongos-host:27017');
          
          try {
            await client.connect();
            const db = client.db('mydb');
            
            // 优化后的聚合管道
            const pipeline = [
              // 1. 首先使用$match减少数据量
              {
                $match: {
                  created_at: {
                    $gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
                  }
                }
              },
              
              // 2. 使用$project选择必要字段
              {
                $project: {
                  user_id: 1,
                  amount: 1,
                  category: 1,
                  created_at: 1,
                  month: {$month: "$created_at"},
                  year: {$year: "$created_at"}
                }
              },
              
              // 3. 分组聚合
              {
                $group: {
                  _id: {
                    user_id: "$user_id",
                    category: "$category",
                    year: "$year",
                    month: "$month"
                  },
                  totalAmount: {$sum: "$amount"},
                  count: {$sum: 1}
                }
              },
              
              // 4. 排序
              {
                $sort: {totalAmount: -1}
              },
              
              // 5. 分页
              {
                $skip: 0},
              {
                $limit: 100
              }
            ];
            
            const result = await db.collection('transactions').aggregate(pipeline).toArray();
            
            return result;
            
          } finally {
            await client.close();
          }
        }
      }
    }
  }
};
```

#### 3.2.2 跨分片查询优化
```javascript
// 跨分片查询优化策略
const crossShardQueryOptimization = {
  // 查询分布策略
  queryDistributionStrategies: {
    // 1. 精确查询路由
    preciseQueryRouting: {
      // 基于分片键的精确路由
      shardKeyBasedQuery: async (collection, query, fields) => {
        const client = new MongoClient('mongodb://mongos-host:27017');
        
        try {
          await client.connect();
          const db = client.db('mydb');
          
          // 分析查询是否包含分片键
          const shardKeyField = collection.includes('users') ? 'user_id' : 
                               collection.includes('orders') ? 'created_at' : '_id';
          
          if (query[shardKeyField]) {
            // 精确路由：查询只涉及单个分片
            console.log("精确路由：查询将只涉及一个分片");
            
            const result = await db.collection(collection)
              .find(query, {projection: fields})
              .toArray();
              
            return {result, routing: 'precise', shardCount: 1};
            
          } else {
            // 广播查询：涉及多个分片
            console.log("广播查询：需要查询多个分片");
            
            const result = await db.collection(collection)
              .find(query, {projection: fields})
              .toArray();
              
            return {result, routing: 'broadcast', shardCount: 'all'};
          }
          
        } finally {
          await client.close();
        }
      }
    },
    
    // 2. 聚合管道优化
    aggregationPipelineOptimization: {
      // 分阶段聚合
      stagedAggregation: async () => {
        const client = new MongoClient('mongodb://mongos-host:27017');
        
        try {
          await client.connect();
          const db = client.db('mydb');
          
          // 优化策略：先在各分片上做局部聚合，再在mongos上做全局聚合
          const pipeline = [
            // 阶段1：各分片预处理
            {
              $match: {
                created_at: {
                  $gte: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000)
                }
              }
            },
            
            // 阶段2：预聚合
            {
              $group: {
                _id: {
                  user_id: "$user_id",
                  year: {$year: "$created_at"},
                  month: {$month: "$created_at"}
                },
                total_amount: {$sum: "$amount"},
                transaction_count: {$sum: 1}
              }
            },
            
            // 阶段3：排序和分页
            {
              $sort: {total_amount: -1}
            },
            
            {
              $limit: 100
            }
          ];
          
          const result = await db.collection('transactions').aggregate(pipeline).toArray();
          
          return result;
          
        } finally {
          await client.close();
        }
      }
    },
    
    // 3. 批量查询优化
    batchQueryOptimization: {
      // 批量查询合并
      batchedQueryMerging: async (collection, queries) => {
        const client = new MongoClient('mongodb://mongos-host:27017');
        
        try {
          await client.connect();
          const db = client.db('mydb');
          
          // 将多个查询合并为一个聚合查询
          const pipeline = [
            {
              $match: {
                $or: queries
              }
            },
            
            {
              $group: {
                _id: "$user_id",
                documents: {$push: "$$ROOT"}
              }
            }
          ];
          
          const result = await db.collection(collection).aggregate(pipeline).toArray();
          
          return result;
          
        } finally {
          await client.close();
        }
      }
    }
  },
  
  // 性能监控
  performanceMonitoring: {
    // 查询性能分析
    async analyzeQueryPerformance() {
      const client = new MongoClient('mongodb://mongos-host:27017');
      
      try {
        await client.connect();
        const admin = client.db('admin').admin();
        
        // 启用profile
        await admin.command({profile: 2, slowms: 1000});
        
        // 获取查询统计
        const systemProfile = client.db('mydb').collection('system.profile');
        
        const slowQueries = await systemProfile
          .find({ts: {$gte: new Date(Date.now() - 3600000)}}) // 最近1小时
          .sort({millis: -1})
          .limit(10)
          .toArray();
        
        console.log("最慢的10个查询:");
        slowQueries.forEach(query => {
          console.log(\`
            查询: \${query.command?.find || query.command?.aggregate || 'unknown'}
            耗时: \${query.millis}ms
            扫描文档数: \${query.nscanned}
            返回文档数: \${query.nreturned}
            分片: \${query.shards || 'N/A'}
          \`);
        });
        
        return slowQueries;
        
      } finally {
        await client.close();
      }
    }
  }
};
```

## 4. 高可用性配置

### 4.1 自动故障转移

#### 4.1.1 选举机制
```javascript
// MongoDB自动故障转移和选举机制
const automaticFailover = {
  // 选举算法
  electionAlgorithm: {
    // 选举优先级
    priorityBasedElection: {
      description: "基于优先级的选举算法",
      
      // 节点优先级配置
      nodePriorities: {
        primary: {
          priority: 3,
          description: "主数据中心节点，优先级最高",
          characteristics: [
            "硬件配置最优",
            "网络延迟最低",
            "数据同步最新"
          ]
        },
        
        secondary: {
          priority: 2,
          description: "备选主节点，优先级中等",
          characteristics: [
            "性能良好",
            "网络延迟可接受",
            "数据相对较新"
          ]
        },
        
        standby: {
          priority: 1,
          description: "备用节点，优先级较低",
          characteristics: [
            "配置标准",
            "可能存在延迟",
            "只参与投票"
          ]
        }
      },
      
      // 选举触发条件
      electionTriggers: [
        "主节点不可用",
        "副本集初始化",
        "节点加入副本集",
        "配置变更",
        "优先级变更"
      ]
    },
    
    // 投票机制
    votingMechanism: {
      // 投票规则
      votingRules: {
        majorityRequired: {
          description: "需要多数节点同意",
          calculation: "⌊N/2⌋ + 1 其中N为有投票权的节点数",
          
          examples: [
            {nodes: 3, required: 2},
            {nodes: 5, required: 3},
            {nodes: 7, required: 4}
          ]
        },
        
        priorityImpact: {
          description: "优先级影响选举结果",
          rules: [
            "priority > 0的节点可以成为主节点",
            "priority = 0的节点不能成为主节点",
            "更高优先级的节点更容易当选",
            "隐藏节点不能参与选举但可以投票"
          ]
        }
      },
      
      // 仲裁节点配置
      arbiterConfiguration: {
        purpose: "在偶数节点时提供决定性投票",
        configuration: {
          priority: 0,      // 优先级为0，不能成为主节点
          hidden: false,    // 可以显示但主要用于仲裁
          votes: 1         // 拥有投票权
        },
        
        example: async () => {
          // 3节点副本集的仲裁配置
          const config = {
            _id: "myReplSet",
            members: [
              {_id: 0, host: "server1:27017", priority: 3},
              {_id: 1, host: "server2:27017", priority: 2},
              {_id: 2, host: "arbiter:27017", priority: 0, arbiterOnly: true}
            ]
          };
          
          console.log("配置仲裁节点用于偶数节点决策");
          return config;
        }
      }
    }
  },
  
  // 故障转移流程
  failoverProcess: {
    // 故障检测
    failureDetection: {
      // 心跳检测
      heartbeatMonitoring: {
        heartbeatInterval: 2000,    // 心跳间隔2秒
        heartbeatTimeout: 10000,    // 心跳超时10秒
        
        example: async () => {
          const client = new MongoClient('mongodb://node1:27017');
          
          try {
            await client.connect();
            const admin = client.db('admin').admin();
            
            // 获取节点状态
            const status = await admin.command({replSetGetStatus: 1});
            
            status.members.forEach(member => {
              const lastHeartbeat = new Date(member.lastHeartbeat);
              const now = new Date();
              const heartbeatAge = (now - lastHeartbeat) / 1000;
              
              console.log(\`\${member.name}: 心跳年龄 \${heartbeatAge.toFixed(1)}秒\`);
              
              if (heartbeatAge > 10) {
                console.warn(\`⚠️  \${member.name} 心跳超时！\`);
              }
            });
            
          } finally {
            await client.close();
          }
        }
      },
      
      // 健康检查
      healthChecking: {
        // 主动健康检查
        activeHealthCheck: async (nodeHost) => {
          const {MongoClient} = require('mongodb');
          
          try {
            const client = new MongoClient(\`mongodb://\${nodeHost}\`);
            await client.connect();
            
            // 执行简单查询验证节点健康
            const result = await client.db('admin').admin().command({ping: 1});
            
            console.log(\`\${nodeHost} 健康检查通过\`);
            return true;
            
          } catch (error) {
            console.error(\`\${nodeHost} 健康检查失败:\`, error.message);
            return false;
          } finally {
            if (client) {
              await client.close();
            }
          }
        }
      }
    },
    
    // 故障转移步骤
    failoverSteps: {
      // 完整的故障转移流程
      async fullFailoverProcess() {
        const steps = [
          {
            step: 1,
            action: "检测主节点故障",
            description: "检测到主节点心跳超时或不可达",
            duration: "~10秒"
          },
          
          {
            step: 2,
            action: "启动选举",
            description: "剩余节点启动选举过程",
            duration: "~10-30秒"
          },
          
          {
            step: 3,
            action: "候选节点竞争",
            description: "符合条件的节点发起候选",
            duration: "~5-10秒"
          },
          
          {
            step: 4,
            action: "投票过程",
            description: "节点进行投票选择新主节点",
            duration: "~5-15秒"
          },
          
          {
            step: 5,
            action: "确认主节点",
            description: "新主节点确认并开始服务",
            duration: "~5秒"
          }
        ];
        
        steps.forEach(step => {
          console.log(\`步骤 \${step.step}: \${step.action}\`);
          console.log(\`  描述: \${step.description}\`);
          console.log(\`  预计耗时: \${step.duration}\`);
        });
        
        return steps;
      }
    }
  }
};
```

#### 4.1.2 客户端连接管理
```javascript
// MongoDB客户端连接和高可用性管理
const clientConnectionManagement = {
  // 连接字符串配置
  connectionStringConfig: {
    // 标准副本集连接字符串
    standardReplicaSet: {
      connectionString: "mongodb://node1:27017,node2:27017,node3:27017/?replicaSet=myReplSet",
      
      options: {
        replicaSet: "myReplSet",              // 副本集名称
        maxPoolSize: 100,                     // 最大连接池大小
        minPoolSize: 5,                       // 最小连接池大小
        maxIdleTimeMS: 300000,                // 连接最大空闲时间
        waitQueueMultiple: 5,                 // 等待队列倍数
        serverSelectionTimeoutMS: 30000,      // 服务器选择超时
        heartbeatFrequencyMS: 10000,          // 心跳频率
        connectTimeoutMS: 30000,              // 连接超时
        socketTimeoutMS: 45000                // 套接字超时
      },
      
      example: async () => {
        const {MongoClient} = require('mongodb');
        
        const client = new MongoClient(
          "mongodb://node1:27017,node2:27017,node3:27017/?replicaSet=myReplSet",
          {
            maxPoolSize: 100,
            minPoolSize: 5,
            serverSelectionTimeoutMS: 30000,
            heartbeatFrequencyMS: 10000,
            connectTimeoutMS: 30000,
            socketTimeoutMS: 45000
          }
        );
        
        try {
          await client.connect();
          console.log("连接到副本集成功");
          
          // 监控连接状态
          const topology = client.topology;
          console.log("连接池状态:", {
            available: topology.s.pool.availableLength(),
            inUse: topology.s.pool.inUsePairs().length
          });
          
        } finally {
          await client.close();
        }
      }
    }
  },
  
  // 客户端重连机制
  reconnectionMechanism: {
    // 自动重连配置
    autoReconnect: {
      // 连接失败时的重试策略
      retryStrategy: {
        maxRetries: 3,
        retryDelay: 1000,  // 重试间隔1秒
        maxRetryDelay: 30000,  // 最大重试间隔30秒
        
        example: async () => {
          const {MongoClient} = require('mongodb');
          
          const client = new MongoClient(
            "mongodb://node1:27017,node2:27017,node3:27017/?replicaSet=myReplSet",
            {
              serverSelectionTimeoutMS: 30000,
              heartbeatFrequencyMS: 10000
            }
          );
          
          let retryCount = 0;
          const maxRetries = 3;
          const retryDelay = 1000;
          
          while (retryCount < maxRetries) {
            try {
              await client.connect();
              console.log("连接成功");
              break;
              
            } catch (error) {
              retryCount++;
              console.log(\`连接失败，尝试 \${retryCount}/\${maxRetries}\`);
              
              if (retryCount < maxRetries) {
                await new Promise(resolve => setTimeout(resolve, retryDelay));
              } else {
                throw error;
              }
            }
          }
          
          return client;
        }
      }
    },
    
    // 读写操作重试
    operationRetry: {
      // 写操作重试
      writeOperationRetry: async (operation, maxRetries = 3) => {
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          try {
            return await operation();
            
          } catch (error) {
            lastError = error;
            
            // 检查是否是可重试的错误
            if (error.code === 91 || // NotWritablePrimary
                error.codeName === 'NotWritablePrimary' ||
                error.code === 10107 || // NotWritablePrimary (legacy)
                error.message.includes('not master')) {
              
              if (attempt < maxRetries) {
                console.log(\`写操作重试 \${attempt}/\${maxRetries}\`);
                await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                continue;
              }
            }
            
            // 不可重试的错误
            throw error;
          }
        }
        
        throw lastError;
      },
      
      // 读操作重试
      readOperationRetry: async (operation, maxRetries = 3) => {
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          try {
            return await operation();
            
          } catch (error) {
            lastError = error;
            
            // 检查是否是可重试的错误
            if (error.code === 91 || // NotWritablePrimary
                error.codeName === 'NotWritablePrimary' ||
                error.code === 10107 || // NotWritablePrimary (legacy)
                error.message.includes('not master') ||
                error.message.includes('No suitable servers')) {
              
              if (attempt < maxRetries) {
                console.log(\`读操作重试 \${attempt}/\${maxRetries}\`);
                await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                continue;
              }
            }
            
            // 不可重试的错误
            throw error;
          }
        }
        
        throw lastError;
      }
    }
  }
};
```

### 4.2 健康监控

#### 4.2.1 系统监控
```javascript
// MongoDB集群健康监控
const clusterHealthMonitoring = {
  // 节点健康状态监控
  nodeHealthMonitoring: {
    // 定期健康检查
    regularHealthCheck: {
      checkInterval: 30000,  // 30秒检查一次
      
      async performHealthCheck() {
        const {MongoClient} = require('mongodb');
        
        const nodes = [
          "node1:27017",
          "node2:27017",
          "node3:27017"
        ];
        
        const healthStatus = [];
        
        for (const node of nodes) {
          try {
            const client = new MongoClient(\`mongodb://\${node}\`);
            const startTime = Date.now();
            
            await client.connect();
            const admin = client.db('admin').admin();
            
            // 执行ping测试
            await admin.command({ping: 1});
            
            // 获取基本统计信息
            const serverStatus = await admin.command({serverStatus: 1});
            const uptime = serverStatus.uptime;
            
            const responseTime = Date.now() - startTime;
            
            healthStatus.push({
              node: node,
              status: 'healthy',
              responseTime: responseTime,
              uptime: uptime,
              timestamp: new Date()
            });
            
            await client.close();
            
          } catch (error) {
            healthStatus.push({
              node: node,
              status: 'unhealthy',
              error: error.message,
              timestamp: new Date()
            });
          }
        }
        
        return healthStatus;
      },
      
      // 启动持续监控
      startContinuousMonitoring: (callback) => {
        setInterval(async () => {
          try {
            const status = await this.performHealthCheck();
            
            // 检查是否有节点异常
            const unhealthyNodes = status.filter(node => node.status === 'unhealthy');
            
            if (unhealthyNodes.length > 0) {
              console.warn(\`发现 \${unhealthyNodes.length} 个异常节点:\`);
              unhealthyNodes.forEach(node => {
                console.warn(\`- \${node.node}: \${node.error}\`);
              });
            }
            
            // 调用回调函数
            if (callback) {
              callback(status);
            }
            
          } catch (error) {
            console.error("健康检查失败:", error.message);
          }
        }, this.checkInterval);
      }
    },
    
    // 详细的健康指标监控
    detailedHealthMetrics: {
      async getDetailedMetrics() {
        const {MongoClient} = require('mongodb');
        
        const client = new MongoClient('mongodb://node1:27017');
        
        try {
          await client.connect();
          const admin = client.db('admin').admin();
          
          // 获取服务器状态
          const serverStatus = await admin.command({serverStatus: 1});
          
          // 获取副本集状态
          const replSetStatus = await admin.command({replSetGetStatus: 1});
          
          // 获取副本集配置
          const replSetConfig = await admin.command({replSetGetConfig: 1});
          
          const metrics = {
            timestamp: new Date(),
            host: serverStatus.host,
            version: serverStatus.version,
            uptime: serverStatus.uptime,
            connections: {
              current: serverStatus.connections.current,
              available: serverStatus.connections.available,
              totalCreated: serverStatus.connections.totalCreated
            },
            operations: {
              inserts: serverStatus.opcounters.insert,
              queries: serverStatus.opcounters.query,
              updates: serverStatus.opcounters.update,
              deletes: serverStatus.opcounters.delete
            },
            memory: {
              resident: serverStatus.mem.resident,
              virtual: serverStatus.mem.virtual,
              mapped: serverStatus.mem.mapped
            },
            locks: serverStatus.locks,
            replicaSet: {
              name: replSetConfig.config._id,
              members: replSetStatus.members.map(member => ({
                _id: member._id,
                name: member.name,
                health: member.health,
                state: member.stateStr,
                uptime: member.uptime,
                self: member.self,
                priority: replSetConfig.config.members[member._id]?.priority
              }))
            }
          };
          
          return metrics;
          
        } finally {
          await client.close();
        }
      }
    }
  },
  
  // 报警机制
  alertSystem: {
    // 报警规则
    alertRules: {
      critical: [
        {condition: "node_count < 2", message: "可用节点数量严重不足"},
        {condition: "response_time > 5000", message: "节点响应时间过长"},
        {condition: "memory_usage > 90", message: "内存使用率过高"},
        {condition: "disk_usage > 90", message: "磁盘使用率过高"}
      ],
      
      warning: [
        {condition: "replication_lag > 60", message: "复制延迟过高"},
        {condition: "connection_pool_exhausted", message: "连接池耗尽"},
        {condition: "slow_queries > 100", message: "慢查询数量过多"}
      ]
    },
    
    // 报警处理
    async processAlerts(metrics) {
      const alerts = [];
      
      // 检查关键指标
      const healthyNodes = metrics.replicaSet.members.filter(m => m.health === 1);
      
      if (healthyNodes.length < 2) {
        alerts.push({
          level: 'critical',
          message: `可用节点数量: ${healthyNodes.length}`,
          action: '立即检查集群状态'
        });
      }
      
      // 检查复制延迟
      const primaryNode = metrics.replicaSet.members.find(m => m.self);
      if (primaryNode) {
        const secondaryNodes = metrics.replicaSet.members.filter(m => !m.self && m.health === 1);
        
        for (const secondary of secondaryNodes) {
          // 这里需要实际计算复制延迟
          // const lag = calculateReplicationLag(primaryNode, secondary);
          
          if (secondary.uptime < 300) { // 少于5分钟
            alerts.push({
              level: 'warning',
              message: `节点 ${secondary.name} 复制延迟: 可能存在同步问题`,
              action: '检查网络和硬件状态'
            });
          }
        }
      }
      
      // 检查资源使用
      if (metrics.memory.resident > 80) {
        alerts.push({
          level: 'warning',
          message: `内存使用率: ${metrics.memory.resident}%`,
          action: '考虑增加内存或优化查询'
        });
      }
      
      return alerts;
    }
  }
};
```

## 5. 负载均衡

### 5.1 读写负载分发

#### 5.1.1 读偏好设置
```javascript
// MongoDB读写负载均衡配置
const readWriteLoadBalancing = {
  // 读偏好配置
  readPreferenceConfiguration: {
    // 不同读偏好模式的配置
    preferenceModes: {
      primary: {
        description: "只从主节点读取",
        useCase: [
          "要求数据一致性最高",
          "读取频繁更新的数据",
          "不能接受读取到旧数据"
        ],
        
        configuration: {
          mode: 'primary',
          options: {
            maxStalenessMS: undefined  // 无时间限制
          }
        },
        
        example: async () => {
          const {MongoClient} = require('mongodb');
          
          const client = new MongoClient(
            'mongodb://node1:27017,node2:27017,node3:27017/?replicaSet=myReplSet',
            {
              readPreference: {
                mode: 'primary'
              }
            }
          );
          
          try {
            await client.connect();
            const db = client.db('mydb');
            
            // 这个查询将只在主节点执行
            const result = await db.collection('users').findOne({
              _id: userId
            });
            
            return result;
            
          } finally {
            await client.close();
          }
        }
      },
      
      primaryPreferred: {
        description: "优先从主节点，失败时从从节点",
        useCase: [
          "优先保证数据一致性",
          "在主节点不可用时提供容错"
        ],
        
        configuration: {
          mode: 'primaryPreferred',
          options: {
            maxStalenessMS: 15000  // 最大15秒延迟
          }
        }
      },
      
      secondary: {
        description: "只从从节点读取",
        useCase: [
          "读取分析性数据",
          "减少主节点负载",
          "可以接受读取到旧数据"
        ],
        
        configuration: {
          mode: 'secondary',
          options: {
            maxStalenessMS: 30000  // 最大30秒延迟
          }
        }
      },
      
      secondaryPreferred: {
        description: "优先从从节点，失败时从主节点",
        useCase: [
          "默认配置，负载均衡",
          "报表和统计查询",
          "减少主节点压力"
        ],
        
        configuration: {
          mode: 'secondaryPreferred',
          options: {
            maxStalenessMS: 30000
          }
        }
      },
      
      nearest: {
        description: "从网络延迟最低的节点读取",
        useCase: [
          "地理分布式集群",
          "需要最低延迟的查询"
        ],
        
        configuration: {
          mode: 'nearest',
          options: {
            maxStalenessMS: 10000  // 最大10秒延迟
          }
        }
      }
    },
    
    // 标签匹配
    tagMatching: {
      // 基于节点标签的读偏好
      configureTaggedReadPreference: async () => {
        const {MongoClient} = require('mongodb');
        
        const client = new MongoClient(
          'mongodb://node1:27017,node2:27017,node3:27017