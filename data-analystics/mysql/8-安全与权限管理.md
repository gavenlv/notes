# 8-安全与权限管理

## 1. MySQL安全概述

### 1.1 安全的重要性

数据库安全是任何应用系统的核心组成部分，它关系到数据的保密性、完整性和可用性。MySQL作为世界上最受欢迎的开源数据库之一，提供了全面的安全功能来保护数据免受未经授权的访问和恶意攻击。

数据库安全的重要性主要体现在以下几个方面：

1. **数据保密性**：防止敏感数据被未经授权的用户访问
2. **数据完整性**：确保数据不被篡改或损坏
3. **数据可用性**：确保授权用户可以随时访问所需数据
4. **合规要求**：满足法律法规和行业标准的要求
5. **业务连续性**：保护业务不受安全事件的影响

### 1.2 安全威胁与防护

MySQL面临的主要安全威胁包括：

1. **未授权访问**：未经授权的用户访问数据库
2. **SQL注入**：通过恶意SQL代码攻击数据库
3. **数据泄露**：敏感数据被非法获取
4. **拒绝服务攻击**：通过大量请求使数据库无法正常服务
5. **内部威胁**：合法用户的恶意或无意操作

针对这些威胁，MySQL提供了多层次的防护措施：

1. **身份认证**：验证用户身份
2. **访问控制**：限制用户权限
3. **数据加密**：保护敏感数据
4. **审计日志**：记录数据库操作
5. **网络安全**：限制网络访问

### 1.3 安全评估与规划

建立MySQL安全体系需要：

1. **安全评估**：识别安全风险和漏洞
2. **安全策略**：制定安全规则和标准
3. **安全实施**：部署安全措施
4. **安全监控**：持续监控系统状态
5. **安全更新**：定期更新安全配置

## 2. 用户账号管理

### 2.1 用户账号基础

在MySQL中，用户账号由两部分组成：用户名和主机名。完整的用户标识格式为 `user_name@host_name`，其中：

- `user_name`：用户名称
- `host_name`：允许该用户连接的主机名或IP地址

示例用户账号：
```sql
'admin'@'localhost'           -- 只能从本地连接的admin用户
'readonly'@'192.168.1.%'      -- 可以从192.168.1.0/24网段连接的readonly用户
'app'@'%'                     -- 可以从任何主机连接的app用户
```

### 2.2 创建用户账号

创建用户账号的基本语法：
```sql
CREATE USER 'username'@'hostname' IDENTIFIED BY 'password';
```

#### 2.2.1 基本用户创建

```sql
-- 创建本地用户
CREATE USER 'local_user'@'localhost' IDENTIFIED BY 'StrongPassword123!';

-- 创建远程用户
CREATE USER 'remote_user'@'%' IDENTIFIED BY 'RemotePassword123!';

-- 创建特定网段的用户
CREATE USER 'admin'@'192.168.1.%' IDENTIFIED BY 'AdminPassword123!';
```

#### 2.2.2 高级用户创建选项

```sql
-- 指定密码验证插件
CREATE USER 'secure_user'@'localhost' 
IDENTIFIED WITH mysql_native_password BY 'SecurePassword123!';

-- 指定密码过期策略
CREATE USER 'temp_user'@'localhost' 
IDENTIFIED BY 'TempPassword123!'
PASSWORD EXPIRE INTERVAL 30 DAY;

-- 指定资源限制
CREATE USER 'limited_user'@'localhost' 
IDENTIFIED BY 'LimitedPassword123!'
WITH MAX_QUERIES_PER_HOUR 1000
MAX_UPDATES_PER_HOUR 100
MAX_CONNECTIONS_PER_HOUR 10
MAX_USER_CONNECTIONS 5;

-- 指定账户锁定策略
CREATE USER 'locked_user'@'localhost' 
IDENTIFIED BY 'LockedPassword123!'
ACCOUNT LOCK;

-- 需要SSL连接
CREATE USER 'ssl_user'@'localhost' 
IDENTIFIED BY 'SSLPassword123!'
REQUIRE SSL;
```

### 2.3 修改用户账号

修改用户账号的基本语法：
```sql
ALTER USER 'username'@'hostname' [options];
```

#### 2.3.1 修改密码

```sql
-- 修改用户密码
ALTER USER 'user1'@'localhost' IDENTIFIED BY 'NewStrongPassword123!';

-- 使用CURRENT_USER修改当前用户密码
ALTER USER CURRENT_USER() IDENTIFIED BY 'CurrentNewPassword123!';
```

#### 2.3.2 重命名用户

```sql
-- 重命名用户
RENAME USER 'old_name'@'localhost' TO 'new_name'@'localhost';
```

#### 2.3.3 修改用户属性

```sql
-- 解锁账户
ALTER USER 'locked_user'@'localhost' ACCOUNT UNLOCK;

-- 设置密码过期
ALTER USER 'user1'@'localhost' PASSWORD EXPIRE;

-- 设置密码永不过期
ALTER USER 'user1'@'localhost' PASSWORD EXPIRE NEVER;

-- 设置下次登录需要修改密码
ALTER USER 'user1'@'localhost' PASSWORD EXPIRE DEFAULT;

-- 修改资源限制
ALTER USER 'user1'@'localhost' 
WITH MAX_QUERIES_PER_HOUR 2000
MAX_UPDATES_PER_HOUR 200;
```

### 2.4 删除用户账号

删除用户账号的基本语法：
```sql
DROP USER 'username'@'hostname';
```

```sql
-- 删除单个用户
DROP USER 'user1'@'localhost';

-- 删除多个用户
DROP USER 'user1'@'localhost', 'user2'@'192.168.1.%';
```

## 3. 权限管理

### 3.1 权限系统概述

MySQL的权限系统基于访问控制列表(ACL)，实现了精细化的权限控制。权限分为几个级别：

1. **全局级别**：适用于所有数据库的所有对象
2. **数据库级别**：适用于特定数据库的所有对象
3. **表级别**：适用于特定表
4. **列级别**：适用于特定表的特定列
5. **子程序级别**：适用于存储过程和函数

### 3.2 权限类型

MySQL提供了多种权限类型，主要分为：

#### 3.2.1 管理权限

```sql
-- 所有权限（等同于GRANT ALL）
ALL [PRIVILEGES]

-- 创建用户和数据库的权限
CREATE USER
CREATE TEMPORARY TABLES
CREATE VIEW
CREATE ROUTINE
CREATE TABLESPACE

-- 删除和修改的权限
DROP
ALTER
ALTER ROUTINE
INDEX
REFERENCES

-- 服务器管理权限
SUPER
RELOAD
SHUTDOWN
PROCESS
FILE
SHOW DATABASES
REPLICATION CLIENT
REPLICATION SLAVE
BINLOG ADMIN
SYSTEM_VARIABLES_ADMIN
REPLICATION_SLAVE_ADMIN
GROUP_REPLICATION_ADMIN
ENCRYPTION_KEY_ADMIN
VERSION_TOKEN_ADMIN
RESOURCE_GROUP_ADMIN
RESOURCE_GROUP_USER
ROLE_ADMIN
SET_USER_ID
XA_RECOVER_ADMIN
BINLOG_ENCRYPTION_ADMIN
CONNECTION_ADMIN
CLONE_ADMIN
PERSIST_RO_VARIABLES_ADMIN
INNODB_REDO_LOG_ARCHIVE
INNODB_REDO_LOG_ENABLE
AUDIT_ADMIN
BINLOG_ADMIN
SYSTEM_USER
BACKUP_ADMIN
TABLE_ENCRYPTION_ADMIN
AUTHENTICATION_POLICY_ADMIN
SESSION_VARIABLES_ADMIN
```

#### 3.2.2 数据操作权限

```sql
-- 数据查询权限
SELECT
SHOW VIEW

-- 数据修改权限
INSERT
UPDATE
DELETE

-- 执行权限
EXECUTE
```

#### 3.2.3 特殊权限

```sql
-- 代理权限
PROXY

-- 使用权限
USAGE
```

### 3.3 授予权限

授予权限的基本语法：
```sql
GRANT privilege_type [(column_list)] 
    ON [object_type] privilege_level 
    TO user_or_role [, user_or_role] ...
    [WITH GRANT OPTION]
    [AS user]
    [REQUIRE {NONE | tls_option [[AND] tls_option] ...}]
```

#### 3.3.1 全局权限授予

```sql
-- 授予所有权限
GRANT ALL PRIVILEGES ON *.* TO 'superadmin'@'localhost';

-- 授予部分管理权限
GRANT RELOAD, SHUTDOWN, PROCESS, FILE ON *.* TO 'admin'@'localhost';

-- 授予创建数据库和用户的权限
GRANT CREATE USER, CREATE, DROP ON *.* TO 'dbmanager'@'%';

-- 授予复制权限
GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'replication'@'%';
```

#### 3.3.2 数据库权限授予

```sql
-- 授予数据库所有权限
GRANT ALL PRIVILEGES ON mydatabase.* TO 'dbadmin'@'localhost';

-- 授予特定权限
GRANT SELECT, INSERT, UPDATE, DELETE ON mydatabase.* TO 'appuser'@'%';

-- 授予创建临时表权限
GRANT CREATE TEMPORARY TABLES ON mydatabase.* TO 'appuser'@'%';

-- 授予存储过程执行权限
GRANT EXECUTE ON PROCEDURE mydatabase.* TO 'appuser'@'%';

-- 授予函数执行权限
GRANT EXECUTE ON FUNCTION mydatabase.* TO 'appuser'@'%';
```

#### 3.3.3 表级别权限授予

```sql
-- 授予表的所有权限
GRANT ALL PRIVILEGES ON mydatabase.customers TO 'tableadmin'@'localhost';

-- 授予特定表的特定权限
GRANT SELECT, INSERT ON mydatabase.orders TO 'orderclerk'@'%';
GRANT SELECT ON mydatabase.products TO 'salesrep'@'%';

-- 授予特定列的权限
GRANT SELECT (id, name, email), UPDATE (last_login) ON mydatabase.users TO 'profileadmin'@'%';
```

#### 3.3.4 授予权限的选项

```sql
-- 允许被授权用户再授权给其他用户
GRANT SELECT ON mydatabase.* TO 'manager'@'%' WITH GRANT OPTION;

-- 要求SSL连接
GRANT SELECT ON mydatabase.* TO 'secureuser'@'%' REQUIRE SSL;

-- 要求特定加密算法
GRANT SELECT ON mydatabase.* TO 'secureuser2'@'%' 
REQUIRE CIPHER 'AES-256-SHA' AND SUBJECT 'CN=client.example.com';

-- 设置资源限制
GRANT SELECT ON mydatabase.* TO 'limiteduser'@'%' 
WITH MAX_QUERIES_PER_HOUR 100 
MAX_UPDATES_PER_HOUR 20 
MAX_CONNECTIONS_PER_HOUR 5 
MAX_USER_CONNECTIONS 2;
```

### 3.4 撤销权限

撤销权限的基本语法：
```sql
REVOKE privilege_type [(column_list)]
    ON [object_type] privilege_level
    FROM user_or_role [, user_or_role] ...
```

#### 3.4.1 基本权限撤销

```sql
-- 撤销特定权限
REVOKE INSERT, UPDATE, DELETE ON mydatabase.* FROM 'readonly_user'@'%';

-- 撤销所有权限
REVOKE ALL PRIVILEGES, GRANT OPTION FROM 'exadmin'@'%';

-- 撤销数据库级别权限
REVOKE ALL ON mydatabase.* FROM 'dbuser'@'%';

-- 撤销表级别权限
REVOKE SELECT ON mydatabase.sensitive_table FROM 'user'@'%';
```

#### 3.4.2 撤销用户权限

```sql
-- 撤销用户所有权限
REVOKE ALL PRIVILEGES, GRANT OPTION FROM 'user'@'%';

-- 撤销所有角色
REVOKE ALL FROM 'user'@'%';
```

### 3.5 查看权限

#### 3.5.1 查看当前用户权限

```sql
-- 查看当前用户权限
SHOW GRANTS;
SHOW GRANTS FOR CURRENT_USER();

-- 查看指定用户权限
SHOW GRANTS FOR 'username'@'hostname';
```

#### 3.5.2 查看权限表

```sql
-- 查看用户权限记录
SELECT * FROM mysql.user WHERE User = 'username' AND Host = 'hostname';

-- 查看数据库级别权限
SELECT * FROM mysql.db WHERE User = 'username' AND Host = 'hostname';

-- 查看表级别权限
SELECT * FROM mysql.tables_priv WHERE User = 'username' AND Host = 'hostname';

-- 查看列级别权限
SELECT * FROM mysql.columns_priv WHERE User = 'username' AND Host = 'hostname';
```

## 4. 角色管理

### 4.1 角色概述

MySQL 8.0引入了角色管理功能，角色是一组权限的命名集合，可以被授予用户，简化了权限管理。角色具有以下特点：

1. **简化权限管理**：将一组权限打包为一个角色
2. **提高可维护性**：修改角色权限，所有拥有该角色的用户权限自动更新
3. **支持角色嵌套**：一个角色可以包含其他角色
4. **角色激活**：用户需要激活角色才能使用角色权限

### 4.2 创建角色

```sql
-- 创建基本角色
CREATE ROLE 'app_developer', 'app_readonly', 'app_admin';

-- 创建带有注释的角色
CREATE ROLE 'data_analyst' COMMENT '数据分析角色，可以查询但不能修改数据';

-- 创建带密码的角色（用于登录）
CREATE ROLE 'admin_role' IDENTIFIED BY 'AdminRolePassword123!';
```

### 4.3 授予角色权限

```sql
-- 为角色授予数据库级别权限
GRANT SELECT ON app_database.* TO 'app_readonly';
GRANT SELECT, INSERT, UPDATE, DELETE ON app_database.* TO 'app_developer';
GRANT ALL PRIVILEGES ON app_database.* TO 'app_admin';

-- 为角色授予特定表权限
GRANT SELECT ON app_database.reports TO 'report_reader';
GRANT SELECT, INSERT ON app_database.logs TO 'log_writer';

-- 为角色授予存储过程权限
GRANT EXECUTE ON PROCEDURE app_database.* TO 'app_developer';

-- 为角色授予管理权限
GRANT CREATE TEMPORARY TABLES, SHOW VIEW ON *.* TO 'app_developer';
```

### 4.4 将角色授予用户

```sql
-- 将角色授予用户
GRANT 'app_readonly' TO 'report_user'@'%';
GRANT 'app_developer' TO 'developer_user'@'%';
GRANT 'app_admin' TO 'admin_user'@'%';

-- 将多个角色授予用户
GRANT 'app_readonly', 'log_reader' TO 'analyst_user'@'%';

-- 授予角色并设置默认角色
GRANT 'app_developer' TO 'dev_user'@'%' WITH ADMIN OPTION;
SET DEFAULT ROLE ALL TO 'dev_user'@'%';
```

### 4.5 角色管理

#### 4.5.1 激活角色

```sql
-- 设置用户的默认角色（在用户连接时自动激活）
SET DEFAULT ROLE 'app_developer' TO 'user'@'%';
SET DEFAULT ROLE ALL TO 'user'@'%';
SET DEFAULT ROLE NONE TO 'user'@'%';

-- 当前会话激活角色
SET ROLE 'app_developer';
SET ROLE ALL;
SET ROLE NONE;

-- 使用WITH ADMIN OPTION授予角色
GRANT 'app_developer' TO 'manager'@'%' WITH ADMIN OPTION;
```

#### 4.5.2 查看角色信息

```sql
-- 查看角色列表
SELECT * FROM mysql.roles_mapping;

-- 查看用户的角色
SELECT * FROM mysql.default_roles WHERE User = 'username' AND Host = 'hostname';

-- 查看当前会话的激活角色
SELECT CURRENT_ROLE();

-- 查看角色定义
SELECT * FROM information_schema.role_table_grants WHERE grantee = "'app_readonly'@'%'";
```

#### 4.5.3 修改和删除角色

```sql
-- 修改角色名称
RENAME ROLE 'old_role' TO 'new_role';

-- 删除角色
DROP ROLE IF EXISTS 'app_developer';

-- 删除多个角色
DROP ROLE IF EXISTS 'app_developer', 'app_readonly', 'app_admin';

-- 从用户撤销角色
REVOKE 'app_developer' FROM 'user'@'%';
```

## 5. 密码策略与安全加固

### 5.1 密码策略配置

#### 5.1.1 密码验证组件

MySQL提供了密码验证组件，用于增强密码安全性：

```sql
-- 安装密码验证组件
INSTALL COMPONENT 'file://component_validate_password';

-- 查看密码验证组件状态
SELECT * FROM mysql.component WHERE component_urn LIKE '%validate_password%';

-- 查看密码验证配置
SHOW VARIABLES LIKE 'validate_password%';
```

#### 5.1.2 密码策略参数

```sql
-- 设置密码策略级别（0-低，1-中，2-高）
SET GLOBAL validate_password.policy=1;

-- 设置密码最小长度
SET GLOBAL validate_password.length=8;

-- 设置数字字符的最小数量
SET GLOBAL validate_password.mixed_case_count=1;

-- 设置特殊字符的最小数量
SET GLOBAL validate_password.special_char_count=1;

-- 设置字典文件路径
SET GLOBAL validate_password.dictionary_file='/path/to/dictionary';
```

### 5.2 账户安全配置

#### 5.2.1 密码过期策略

```sql
-- 设置密码过期策略
SET GLOBAL default_password_lifetime=90;  -- 90天后过期

-- 为特定用户设置密码过期策略
ALTER USER 'user'@'%' PASSWORD EXPIRE INTERVAL 30 DAY;
ALTER USER 'user'@'%' PASSWORD EXPIRE NEVER;
ALTER USER 'user'@'%' PASSWORD EXPIRE DEFAULT;
```

#### 5.2.2 密码重用限制

```sql
-- 设置密码重用历史记录数量
SET GLOBAL password_history=5;  -- 不能重用最近5个密码

-- 设置密码重用时间间隔
SET GLOBAL password_reuse_interval=365;  -- 不能重用一年内的密码

-- 禁用密码重用
SET GLOBAL password_history=0;
SET GLOBAL password_reuse_interval=0;
```

#### 5.2.3 登录失败处理

```sql
-- 设置连接控制插件
INSTALL COMPONENT 'file://component_connection_control';

-- 设置登录失败次数阈值
SET GLOBAL connection_control_failed_connections_threshold=3;

-- 设置锁定时间（毫秒）
SET GLOBAL connection_control_min_connection_delay=1000;
SET GLOBAL connection_control_max_connection_delay=86400000;  -- 24小时
```

### 5.3 网络安全配置

#### 5.3.1 限制连接主机

```sql
-- 创建只允许特定IP连接的用户
CREATE USER 'admin'@'192.168.1.100' IDENTIFIED BY 'strong_password';

-- 创建允许特定网段连接的用户
CREATE USER 'user'@'192.168.1.%' IDENTIFIED BY 'strong_password';

-- 禁用匿名用户
DROP USER ''@'localhost';
```

#### 5.3.2 SSL/TLS配置

```sql
-- 启用SSL
-- 在my.cnf中配置：
-- [mysqld]
-- ssl-ca=ca.pem
-- ssl-cert=server-cert.pem
-- ssl-key=server-key.pem

-- 创建需要SSL连接的用户
CREATE USER 'secure_user'@'%' 
IDENTIFIED BY 'strong_password'
REQUIRE SSL;

-- 创建需要特定证书的用户
CREATE USER 'cert_user'@'%' 
IDENTIFIED BY 'strong_password'
REQUIRE SUBJECT '/CN=client.example.com'
AND ISSUER '/CN=ca.example.com';

-- 创建需要特定密码算法的用户
CREATE USER 'cipher_user'@'%' 
IDENTIFIED BY 'strong_password'
REQUIRE CIPHER 'AES-256-SHA';
```

## 6. 数据加密

### 6.1 传输加密

#### 6.1.1 SSL/TLS配置

传输加密使用SSL/TLS协议保护客户端和服务器之间的通信：

```sql
-- 检查MySQL服务器是否支持SSL
SHOW VARIABLES LIKE 'have_ssl';

-- 查看SSL配置
SHOW VARIABLES LIKE '%ssl%';
```

在my.cnf中配置SSL：
```ini
[mysqld]
# 启用SSL
ssl

# SSL证书配置
ssl-ca=ca.pem
ssl-cert=server-cert.pem
ssl-key=server-key.pem

# 强制SSL连接
require_secure_transport=ON
```

#### 6.1.2 客户端SSL连接

```bash
# 使用SSL连接MySQL
mysql --ssl-mode=REQUIRED -u username -p

# 指定CA证书
mysql --ssl-mode=VERIFY_CA --ssl-ca=ca.pem -u username -p

# 指定完整证书链
mysql --ssl-mode=VERIFY_IDENTITY \
      --ssl-ca=ca.pem \
      --ssl-cert=client-cert.pem \
      --ssl-key=client-key.pem \
      -u username -p
```

### 6.2 静态数据加密

#### 6.2.1 InnoDB表空间加密

InnoDB表空间加密保护存储在磁盘上的数据：

```sql
-- 安装密钥管理插件
INSTALL PLUGIN keyring_file SONAME 'keyring_file.so';

-- 设置密钥文件路径
SET GLOBAL keyring_file_data='/var/lib/mysql-keyring/keyring';

-- 创建加密表
CREATE TABLE secure_table (
    id INT PRIMARY KEY,
    sensitive_data VARCHAR(255),
    encrypted_text VARBINARY(255)
) ENCRYPTION='Y';

-- 修改表加密属性
ALTER TABLE existing_table ENCRYPTION='Y';
ALTER TABLE existing_table ENCRYPTION='N';

-- 查看加密表状态
SELECT TABLE_SCHEMA, TABLE_NAME, CREATE_OPTIONS 
FROM information_schema.TABLES 
WHERE CREATE_OPTIONS LIKE '%ENCRYPTION%';
```

#### 6.2.2 通用表空间加密

```sql
-- 创建加密的通用表空间
CREATE TABLESPACE secure_space 
ADD DATAFILE 'secure_space.ibd'
ENCRYPTION='Y';

-- 在加密表空间中创建表
CREATE TABLE secure_table (
    id INT PRIMARY KEY,
    data VARCHAR(255)
) TABLESPACE=secure_space;
```

### 6.3 应用层数据加密

#### 6.3.1 使用MySQL加密函数

MySQL提供了多种加密函数来保护应用数据：

```sql
-- AES加密
INSERT INTO secure_table (id, encrypted_text) 
VALUES (1, AES_ENCRYPT('Secret message', 'encryption_key'));

SELECT id, AES_DECRYPT(encrypted_text, 'encryption_key') AS decrypted_text 
FROM secure_table WHERE id = 1;

-- SHA2哈希
INSERT INTO users (username, password_hash) 
VALUES ('user1', SHA2('userpassword', 256));

-- 验证密码
SELECT username FROM users 
WHERE username = 'user1' AND password_hash = SHA2('userpassword', 256);

-- 使用随机盐值加密
-- 插入时
SET @salt = RANDOM_BYTES(16);
INSERT INTO users (username, password_hash, salt) 
VALUES ('user1', SHA2(CONCAT('userpassword', HEX(@salt)), 256), @salt);

-- 验证时
SELECT username FROM users 
WHERE username = 'user1' AND password_hash = SHA2(CONCAT('userpassword', HEX(salt)), 256);
```

#### 6.3.2 应用层加密示例

```python
# Python示例：应用层加密
import pymysql
import hashlib
import os
from cryptography.fernet import Fernet

class SecureMySQLConnector:
    def __init__(self, host, user, password, database):
        # 连接使用SSL
        self.connection = pymysql.connect(
            host=host,
            user=user,
            password=password,
            database=database,
            ssl={'ca': '/path/to/ca.pem'}
        )
        
        # 生成加密密钥
        self.encryption_key = Fernet.generate_key()
        self.cipher_suite = Fernet(self.encryption_key)
    
    def hash_password(self, password):
        """使用SHA2加盐哈希密码"""
        salt = os.urandom(16)
        salt_hex = salt.hex()
        hashed = hashlib.sha256((password + salt_hex).encode()).hexdigest()
        return hashed, salt_hex
    
    def encrypt_sensitive_data(self, data):
        """加密敏感数据"""
        encrypted_data = self.cipher_suite.encrypt(data.encode())
        return encrypted_data
    
    def decrypt_sensitive_data(self, encrypted_data):
        """解密敏感数据"""
        decrypted_data = self.cipher_suite.decrypt(encrypted_data).decode()
        return decrypted_data
    
    def create_user(self, username, password, email, phone):
        """创建加密用户"""
        # 哈希密码
        password_hash, salt = self.hash_password(password)
        
        # 加密敏感数据
        encrypted_email = self.encrypt_sensitive_data(email)
        encrypted_phone = self.encrypt_sensitive_data(phone)
        
        cursor = self.connection.cursor()
        cursor.execute(
            "INSERT INTO users (username, password_hash, salt, encrypted_email, encrypted_phone) "
            "VALUES (%s, %s, %s, %s, %s)",
            (username, password_hash, salt, encrypted_email, encrypted_phone)
        )
        self.connection.commit()
        cursor.close()
```

## 7. 审计与日志

### 7.1 审计插件配置

#### 7.1.1 安装审计插件

```sql
-- 安装企业审计插件
INSTALL PLUGIN audit_log SONAME 'audit_log.so';

-- 查看审计插件状态
SELECT * FROM mysql.plugin WHERE name = 'audit_log';

-- 查看审计日志配置
SHOW VARIABLES LIKE 'audit_log%';
```

#### 7.1.2 配置审计日志

```sql
-- 设置审计日志格式（JSON, OLD, NEW）
SET GLOBAL audit_log_format=JSON;

-- 设置审计日志文件路径
SET GLOBAL audit_log_file=/var/log/mysql/audit.log;

-- 设置审计日志策略
-- ALL: 记录所有事件
-- LOGINS: 只记录登录事件
-- QUERIES: 记录查询事件
-- NONE: 不记录事件
SET GLOBAL audit_log_policy=ALL;

-- 设置审计日志刷新策略
-- NONE: 不刷新
-- ONCE: 每次写入后刷新
-- REALTIME: 实时刷新
-- PERFORMANCE: 性能优化模式
SET GLOBAL audit_log_flush=ONCE;

-- 设置审计日志文件大小限制（字节）
SET GLOBAL audit_log_file_size=1073741824;  -- 1GB

-- 设置审计日志旋转策略
-- NONE: 不旋转
-- SIZE: 按大小旋转
-- TIME: 按时间旋转
SET GLOBAL audit_log_rotations=ON;
```

### 7.2 审计事件过滤

#### 7.2.1 基于用户的过滤

```sql
-- 排除特定用户
SET GLOBAL audit_log_exclude_accounts="'root'@'localhost'";

-- 包含特定用户
SET GLOBAL audit_log_include_accounts="'app_user'@'%'";
```

#### 7.2.2 基于事件的过滤

```sql
-- 只审计特定事件
SET GLOBAL audit_log_include_events='CONNECT,QUERY,TABLE';

-- 排除特定事件
SET GLOBAL audit_log_exclude_events='QUERY_DML';
```

#### 7.2.3 基于数据库和表的过滤

```sql
-- 只审计特定数据库
SET GLOBAL audit_log_include_databases='sensitive_db';

-- 排除特定数据库
SET GLOBAL audit_log_exclude_databases='performance_schema,information_schema,mysql';

-- 只审计特定表
SET GLOBAL audit_log_include_tables='users,credit_cards,transactions';
```

### 7.3 通用日志和慢查询日志

#### 7.3.1 通用日志配置

```sql
-- 启用通用日志
SET GLOBAL general_log=ON;

-- 设置通用日志输出方式（TABLE, FILE, NONE）
SET GLOBAL general_log=ON;
SET GLOBAL log_output='TABLE';  -- 记录到表
SET GLOBAL log_output='FILE';   -- 记录到文件
SET GLOBAL log_output='TABLE,FILE';  -- 同时记录到表和文件

-- 设置通用日志文件路径
SET GLOBAL general_log_file=/var/log/mysql/general.log;

-- 查看通用日志表
SELECT * FROM mysql.general_log ORDER BY event_time DESC LIMIT 10;
```

#### 7.3.2 慢查询日志配置

```sql
-- 启用慢查询日志
SET GLOBAL slow_query_log=ON;

-- 设置慢查询阈值（秒）
SET GLOBAL long_query_time=1;

-- 设置慢查询日志输出方式
SET GLOBAL slow_query_log=ON;
SET GLOBAL log_output='TABLE,FILE';

-- 设置慢查询日志文件路径
SET GLOBAL slow_query_log_file=/var/log/mysql/slow.log;

-- 记录未使用索引的查询
SET GLOBAL log_queries_not_using_indexes=ON;

-- 记录管理语句
SET GLOBAL log_slow_admin_statements=ON;

-- 查看慢查询日志表
SELECT * FROM mysql.slow_log ORDER BY start_time DESC LIMIT 10;
```

### 7.4 二进制日志

#### 7.4.1 二进制日志配置

```ini
# 在my.cnf中配置
[mysqld]
# 启用二进制日志
log-bin=mysql-bin

# 设置二进制日志格式（STATEMENT, ROW, MIXED）
binlog_format=ROW

# 设置二进制日志过期时间（天）
expire_logs_days=7

# 设置单个二进制日志文件大小
max_binlog_size=1073741824  -- 1GB

# 启用GTID（全局事务ID）
gtid_mode=ON
enforce_gtid_consistency=ON
```

#### 7.4.2 查看二进制日志

```sql
-- 查看二进制日志列表
SHOW BINARY LOGS;

-- 查看当前二进制日志状态
SHOW MASTER STATUS;

-- 查看二进制日志内容
SHOW BINLOG EVENTS IN 'mysql-bin.000001';

-- 使用mysqlbinlog工具查看日志
-- 在命令行执行：
-- mysqlbinlog /var/log/mysql/mysql-bin.000001
```

## 8. SQL注入防护

### 8.1 SQL注入原理

SQL注入是一种代码注入技术，攻击者通过在应用程序的输入字段中插入恶意SQL代码，来欺骗服务器执行非预期的SQL命令。攻击者可以利用SQL注入：

1. **绕过身份验证**：修改登录查询以获取未经授权的访问
2. **数据泄露**：查询敏感数据并泄露给攻击者
3. **数据篡改**：修改或删除数据库中的数据
4. **执行管理操作**：执行数据库管理操作，如关闭服务器

### 8.2 SQL注入示例

#### 8.2.1 经典SQL注入场景

```sql
-- 不安全的查询（易受SQL注入攻击）
SELECT * FROM users WHERE username = '${username}' AND password = '${password}';

-- 攻击者输入：
-- username: admin' --
-- password: 任意密码

-- 实际执行的查询：
SELECT * FROM users WHERE username = 'admin' -- ' AND password = '任意密码';
-- 结果：绕过密码验证，登录为admin用户
```

```sql
-- 不安全的搜索查询
SELECT * FROM products WHERE name LIKE '%${search_term}%';

-- 攻击者输入：
-- search_term: '; DROP TABLE users; --

-- 实际执行的查询：
SELECT * FROM products WHERE name LIKE '%'; DROP TABLE users; -- %';
-- 结果：删除整个users表
```

#### 8.2.2 盲注攻击

```sql
-- 不安全的查询
SELECT * FROM products WHERE category = ${category_id};

-- 攻击者输入：
-- category_id: 1 AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='admin')='a'

-- 实际执行的查询：
SELECT * FROM products WHERE category = 1 AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='admin')='a';
-- 结果：根据查询结果猜测密码字符
```

### 8.3 SQL注入防护措施

#### 8.3.1 使用预处理语句

预处理语句是防止SQL注入最有效的方法：

```python
# Python示例：使用预处理语句
import pymysql

def safe_query_login(username, password):
    conn = pymysql.connect(host='localhost', user='app', password='app_pass', database='myapp')
    cursor = conn.cursor(pymysql.cursors.DictCursor)
    
    # 使用预处理语句
    query = "SELECT * FROM users WHERE username = %s AND password = %s"
    cursor.execute(query, (username, password))
    
    user = cursor.fetchone()
    cursor.close()
    conn.close()
    
    return user

def safe_search_products(search_term):
    conn = pymysql.connect(host='localhost', user='app', password='app_pass', database='myapp')
    cursor = conn.cursor(pymysql.cursors.DictCursor)
    
    # 使用预处理语句和LIKE
    query = "SELECT * FROM products WHERE name LIKE %s"
    cursor.execute(query, (f"%{search_term}%",))
    
    products = cursor.fetchall()
    cursor.close()
    conn.close()
    
    return products
```

#### 8.3.2 输入验证和转义

```python
# Python示例：输入验证和转义
import re
import html

def validate_username(username):
    """验证用户名格式"""
    # 只允许字母、数字和下划线，长度3-20
    pattern = r'^[a-zA-Z0-9_]{3,20}$'
    return re.match(pattern, username) is not None

def sanitize_input(input_string):
    """转义输入字符串"""
    # 转义HTML特殊字符
    escaped = html.escape(input_string)
    # 移除潜在的SQL字符
    escaped = escaped.replace("'", "''")
    return escaped

def safe_login_with_validation(username, password):
    # 验证输入
    if not validate_username(username):
        return None
    
    if not validate_username(password):
        return None
    
    # 转义输入
    safe_username = sanitize_input(username)
    safe_password = sanitize_input(password)
    
    # 构建查询（虽然预处理语句更好，但这是额外的保护层）
    query = f"SELECT * FROM users WHERE username = '{safe_username}' AND password = '{safe_password}'"
    
    # 执行查询...
    # ...
```

#### 8.3.3 最小权限原则

```sql
-- 为应用创建最小权限用户
CREATE USER 'app_user'@'%' IDENTIFIED BY 'StrongPassword123!';

-- 只授予必要的权限
GRANT SELECT, INSERT, UPDATE ON app_database.users TO 'app_user'@'%';
GRANT SELECT ON app_database.products TO 'app_user'@'%';

-- 不授予DROP, ALTER, CREATE等危险权限
```

#### 8.3.4 存储过程防护

```sql
-- 使用存储过程封装查询
DELIMITER //
CREATE PROCEDURE login_user(IN p_username VARCHAR(50), IN p_password VARCHAR(50))
BEGIN
    SELECT * FROM users 
    WHERE username = p_username AND password = p_password;
END //
DELIMITER ;

-- 调用存储过程（更安全）
CALL login_user('username', 'password');
```

#### 8.3.5 Web应用防火墙(WAF)

Web应用防火墙可以在应用层检测和阻止SQL注入攻击：

```python
# Python示例：简单的WAF过滤器
class SQLInjectionFilter:
    def __init__(self):
        # 常见SQL注入模式
        self.suspicious_patterns = [
            r"(\%27)|(\')|(\-\-)|(\%23)|(#)",
            r"((\%3D)|(=))[^\n]*((\%27)|(\')|(\-\-)|(\%3B)|(;))",
            r"\w*((\%27)|(\'))((\%6F)|o|(\%4F))((\%72)|r|(\%52))",
            r"((\%27)|(\'))union",
            r"exec(\s|\+)+(s|x)p\w+",
            r"UNION.*SELECT",
            r"INSERT.*INTO",
            r"DELETE.*FROM",
            r"DROP.*TABLE"
        ]
    
    def is_suspicious(self, input_string):
        """检查输入是否可疑"""
        for pattern in self.suspicious_patterns:
            if re.search(pattern, input_string, re.IGNORECASE):
                return True
        return False
    
    def filter_input(self, input_string):
        """过滤输入"""
        if self.is_suspicious(input_string):
            raise SecurityException("Potential SQL injection detected!")
        return input_string

# 使用示例
filter = SQLInjectionFilter()

try:
    safe_username = filter.filter_input(username)
    safe_password = filter.filter_input(password)
    # 继续处理安全输入
except SecurityException as e:
    # 记录安全事件
    log_security_event(e)
    # 返回错误
```

### 8.4 安全编码最佳实践

1. **始终使用预处理语句**：这是防止SQL注入最有效的方法
2. **执行严格的输入验证**：验证所有用户输入的格式和类型
3. **应用最小权限原则**：只授予应用程序必要的最小权限
4. **使用存储过程**：封装数据库逻辑，减少直接SQL查询
5. **实施Web应用防火墙**：在应用层添加额外的安全防护
6. **定期安全审计**：定期检查代码中的安全漏洞
7. **使用ORM框架**：ORM框架通常会自动处理SQL注入防护
8. **错误处理**：不要向用户暴露详细的数据库错误信息

## 9. MySQL安全最佳实践

### 9.1 系统级安全配置

1. **及时更新**：保持MySQL服务器和操作系统的最新版本，及时应用安全补丁

2. **禁用不必要的服务**：
   ```bash
   # 禁用MySQL的本地文件功能
   # 在my.cnf中添加：
   # [mysqld]
   # local_infile=0
   ```

3. **文件系统权限**：
   ```bash
   # 设置MySQL数据目录权限
   chown -R mysql:mysql /var/lib/mysql
   chmod 700 /var/lib/mysql
   
   # 限制配置文件权限
   chmod 600 /etc/mysql/my.cnf
   ```

4. **网络隔离**：
   ```ini
   # 限制MySQL监听地址
   # 在my.cnf中添加：
   # [mysqld]
   # bind-address=127.0.0.1  # 只监听本地
   # bind-address=10.0.0.5   # 监听特定IP
   ```

5. **防火墙配置**：
   ```bash
   # 使用iptables限制MySQL访问
   iptables -A INPUT -p tcp --dport 3306 -s 192.168.1.0/24 -j ACCEPT
   iptables -A INPUT -p tcp --dport 3306 -j DROP
   ```

### 9.2 数据库级安全配置

1. **删除默认账户**：
   ```sql
   -- 删除匿名用户
   DROP USER ''@'localhost';
   
   -- 删除测试数据库
   DROP DATABASE IF EXISTS test;
   
   -- 重命名root用户（可选）
   RENAME USER 'root'@'localhost' TO 'admin'@'localhost';
   ```

2. **强密码策略**：
   ```sql
   -- 安装密码验证插件
   INSTALL COMPONENT 'file://component_validate_password';
   
   -- 设置密码策略
   SET GLOBAL validate_password.policy=STRONG;
   SET GLOBAL validate_password.length=12;
   ```

3. **定期更改密码**：
   ```sql
   -- 设置密码过期时间
   SET GLOBAL default_password_lifetime=90;
   ```

4. **限制超级用户**：
   ```sql
   -- 创建普通管理员，不使用root
   CREATE USER 'dbadmin'@'localhost' IDENTIFIED BY 'StrongPassword123!';
   GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, ALTER, INDEX ON *.* TO 'dbadmin'@'localhost';
   ```

### 9.3 应用级安全配置

1. **使用专用数据库用户**：
   ```sql
   -- 为应用程序创建专用用户
   CREATE USER 'appuser'@'appserver.example.com' IDENTIFIED BY 'AppPassword123!';
   GRANT SELECT, INSERT, UPDATE, DELETE ON app_database.* TO 'appuser'@'appserver.example.com';
   ```

2. **实施预处理语句**：在所有应用程序代码中使用预处理语句

3. **加密敏感数据**：
   ```sql
   -- 启用InnoDB表空间加密
   ALTER TABLE sensitive_data ENCRYPTION='Y';
   ```

4. **最小权限原则**：只授予应用程序必要的最小权限

### 9.4 监控与审计

1. **启用审计日志**：
   ```sql
   -- 安装审计插件
   INSTALL PLUGIN audit_log SONAME 'audit_log.so';
   
   -- 配置审计策略
   SET GLOBAL audit_log_policy=ALL;
   SET GLOBAL audit_log_format=JSON;
   ```

2. **监控登录尝试**：
   ```sql
   -- 启用连接控制
   INSTALL COMPONENT 'file://component_connection_control';
   
   -- 设置失败登录限制
   SET GLOBAL connection_control_failed_connections_threshold=3;
   SET GLOBAL connection_control_max_connection_delay=86400000;
   ```

3. **定期安全审计**：
   ```sql
   -- 查看用户权限
   SELECT user, host FROM mysql.user;
   SELECT * FROM mysql.db;
   
   -- 检查匿名用户
   SELECT * FROM mysql.user WHERE user = '';
   
   -- 检查空密码用户
   SELECT user, host FROM mysql.user WHERE authentication_string = '';
   ```

### 9.5 备份安全

1. **加密备份**：
   ```bash
   # 使用gpg加密备份
   mysqldump -u root -p database | gpg -c -o database.sql.gpg
   ```

2. **安全存储备份**：
   ```bash
   # 将备份存储在安全位置
   scp database.sql.gpg backup@backup-server:/secure/backups/
   ```

3. **限制备份访问**：
   ```bash
   # 设置备份文件权限
   chmod 600 database.sql.gpg
   chown backup:backup database.sql.gpg
   ```

## 10. 故障排除与安全事件响应

### 10.1 常见安全问题诊断

#### 10.1.1 诊断未授权访问

```sql
-- 查看用户账号
SELECT user, host, authentication_string FROM mysql.user;

-- 查看用户权限
SELECT * FROM mysql.db WHERE user = 'username';

-- 查看当前会话用户
SELECT USER(), CURRENT_USER();

-- 查看最近登录记录（需要启用审计日志）
SELECT * FROM mysql.general_log WHERE argument LIKE '%CONNECT%' ORDER BY event_time DESC;
```

#### 10.1.2 诊断SQL注入攻击

```sql
-- 查看异常查询（需要启用通用日志）
SELECT * FROM mysql.general_log 
WHERE argument LIKE '%UNION%' 
   OR argument LIKE '%SELECT%'
   OR argument LIKE '%DROP%'
ORDER BY event_time DESC;

-- 查看频繁访问敏感表的查询
SELECT argument FROM mysql.general_log 
WHERE argument LIKE '%sensitive_table%'
ORDER BY event_time DESC;
```

#### 10.1.3 诊断暴力破解攻击

```sql
-- 查看频繁失败的登录尝试（需要启用审计日志）
SELECT * FROM mysql.general_log 
WHERE argument LIKE '%Access denied%'
ORDER BY event_time DESC;
```

### 10.2 安全事件响应

#### 10.2.1 发现安全事件后的应对措施

1. **隔离受影响系统**：断开可疑连接，阻止进一步攻击
2. **评估损害**：确定攻击范围和影响
3. **收集证据**：保存相关日志和证据
4. **修复漏洞**：修补导致安全事件的问题
5. **恢复服务**：在确保安全的前提下恢复服务
6. **事后分析**：分析事件原因，改进安全措施

#### 10.2.2 应急处理脚本示例

```sql
-- 紧急锁定可疑用户
ALTER USER 'suspicious_user'@'%' ACCOUNT LOCK;

-- 紧急撤销危险权限
REVOKE ALL PRIVILEGES, GRANT OPTION FROM 'compromised_user'@'%';

-- 记录安全事件
INSERT INTO security_incidents (incident_time, incident_type, details) 
VALUES (NOW(), 'UNAUTHORIZED_ACCESS', 'Suspicious activity detected from IP address');
```

## 总结

MySQL安全是一个多层次、全方位的体系，需要从系统、网络、数据库和应用程序等多个层面进行防护。本章介绍了MySQL安全的各个方面，包括：

1. **用户账号管理**：创建、修改和删除用户账号
2. **权限管理**：细粒度的权限控制系统
3. **角色管理**：简化权限管理的角色系统
4. **密码策略**：强化密码安全性的策略配置
5. **数据加密**：传输加密、静态数据加密和应用层加密
6. **审计与日志**：全面的审计和日志记录系统
7. **SQL注入防护**：防止SQL注入的各种技术和方法
8. **安全最佳实践**：系统级、数据库级和应用级的安全配置
9. **故障排除**：安全问题的诊断和事件响应

通过实施这些安全措施，可以大大提高MySQL数据库系统的安全性，保护数据免受各种安全威胁。记住，安全是一个持续的过程，需要定期评估、更新和改进安全策略。

安全不是一次性的配置，而是一种持续的态度和文化。只有将安全意识融入到数据库管理的每个环节，才能真正构建起一个安全、可靠的数据库系统。