# 第2章：高级查询

## 目录
1. [高级SELECT语句](#1-高级select语句)
2. [连接查询](#2-连接查询)
3. [子查询](#3-子查询)
4. [聚合函数与分组](#4-聚合函数与分组)
5. [窗口函数](#5-窗口函数)
6. [高级过滤条件](#6-高级过滤条件)
7. [查询优化](#7-查询优化)
8. [最佳实践](#8-最佳实践)

## 1. 高级SELECT语句

### 1.1 SELECT语句语法结构

完整的SELECT语句语法结构如下：

```sql
SELECT [DISTINCT | DISTINCTROW | ALL]
    select_expression [, select_expression ...]
    [FROM table_references
    [WHERE where_condition]
    [GROUP BY {col_name | expr | position}
      [ASC | DESC], ... [WITH ROLLUP]]
    [HAVING where_condition]
    [ORDER BY {col_name | expr | position}
      [ASC | DESC], ...]
    [LIMIT {[offset,] row_count | row_count OFFSET offset}]
    [FOR UPDATE | LOCK IN SHARE MODE]]
```

### 1.2 DISTINCT关键字

DISTINCT关键字用于消除重复的行。

```sql
-- 基本用法
SELECT DISTINCT column1, column2 FROM table_name;

-- 示例：获取所有不重复的部门ID
SELECT DISTINCT department_id FROM employees;

-- 示例：获取所有不重复的部门-职位组合
SELECT DISTINCT department_id, job_id FROM employees;
```

### 1.3 别名使用

别名可以提高SQL语句的可读性。

```sql
-- 列别名
SELECT 
    first_name AS '名',
    last_name AS '姓',
    salary AS '薪资',
    salary * 12 AS '年薪'
FROM employees;

-- 表别名
SELECT 
    e.first_name,
    e.last_name,
    d.department_name
FROM employees AS e
JOIN departments AS d ON e.department_id = d.department_id;
```

### 1.4 CASE表达式

CASE表达式用于在查询中实现条件逻辑。

```sql
-- 简单CASE表达式
SELECT 
    employee_id,
    first_name,
    last_name,
    CASE department_id
        WHEN 10 THEN '行政部'
        WHEN 20 THEN '市场部'
        WHEN 30 THEN '销售部'
        WHEN 40 THEN '技术部'
        ELSE '其他部门'
    END AS department_name
FROM employees;

-- 搜索CASE表达式
SELECT 
    employee_id,
    first_name,
    last_name,
    salary,
    CASE 
        WHEN salary < 5000 THEN '低薪资'
        WHEN salary >= 5000 AND salary < 10000 THEN '中等薪资'
        WHEN salary >= 10000 AND salary < 20000 THEN '高薪资'
        ELSE '超高薪资'
    END AS salary_level
FROM employees;
```

## 2. 连接查询

### 2.1 内连接（INNER JOIN）

内连接返回两个表中连接条件匹配的行。

```sql
-- 基本语法
SELECT column_names
FROM table1
INNER JOIN table2
ON table1.column_name = table2.column_name;

-- 示例：查询员工及其部门信息
SELECT 
    e.employee_id,
    e.first_name,
    e.last_name,
    d.department_name
FROM employees e
INNER JOIN departments d ON e.department_id = d.department_id;
```

### 2.2 左连接（LEFT JOIN）

左连接返回左表的所有行，以及右表中匹配的行。如果右表中没有匹配的行，则结果为NULL。

```sql
-- 基本语法
SELECT column_names
FROM table1
LEFT JOIN table2
ON table1.column_name = table2.column_name;

-- 示例：查询所有员工及其部门信息（包括没有部门的员工）
SELECT 
    e.employee_id,
    e.first_name,
    e.last_name,
    d.department_name
FROM employees e
LEFT JOIN departments d ON e.department_id = d.department_id;
```

### 2.3 右连接（RIGHT JOIN）

右连接返回右表的所有行，以及左表中匹配的行。如果左表中没有匹配的行，则结果为NULL。

```sql
-- 基本语法
SELECT column_names
FROM table1
RIGHT JOIN table2
ON table1.column_name = table2.column_name;

-- 示例：查询所有部门及其员工信息（包括没有员工的部门）
SELECT 
    e.employee_id,
    e.first_name,
    e.last_name,
    d.department_name
FROM employees e
RIGHT JOIN departments d ON e.department_id = d.department_id;
```

### 2.4 全连接（FULL OUTER JOIN）

MySQL不直接支持FULL OUTER JOIN，但可以通过LEFT JOIN和RIGHT JOIN的组合来实现。

```sql
-- 示例：使用UNION实现全连接
SELECT 
    e.employee_id,
    e.first_name,
    e.last_name,
    d.department_name
FROM employees e
LEFT JOIN departments d ON e.department_id = d.department_id

UNION

SELECT 
    e.employee_id,
    e.first_name,
    e.last_name,
    d.department_name
FROM employees e
RIGHT JOIN departments d ON e.department_id = d.department_id;
```

### 2.5 自连接

自连接是指表与自身的连接，通常用于处理层级数据或比较同一表中的行。

```sql
-- 示例：查询员工及其直接上级的信息
SELECT 
    e.employee_id AS '员工ID',
    e.first_name AS '员工姓名',
    m.employee_id AS '上级ID',
    m.first_name AS '上级姓名'
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.employee_id;

-- 示例：查询同一部门内薪资高于平均薪资的员工
SELECT 
    e1.employee_id,
    e1.first_name,
    e1.salary,
    e1.department_id
FROM employees e1
JOIN (
    SELECT department_id, AVG(salary) AS avg_salary
    FROM employees
    GROUP BY department_id
) e2 ON e1.department_id = e2.department_id
WHERE e1.salary > e2.avg_salary;
```

### 2.6 多表连接

```sql
-- 示例：查询员工、部门、薪资等级信息
SELECT 
    e.employee_id,
    e.first_name,
    d.department_name,
    j.job_title,
    s.grade_level
FROM employees e
JOIN departments d ON e.department_id = d.department_id
JOIN jobs j ON e.job_id = j.job_id
JOIN job_grades s ON e.salary BETWEEN s.lowest_sal AND s.highest_sal;
```

## 3. 子查询

### 3.1 子查询基础

子查询是嵌套在另一个查询中的查询，可以出现在SELECT、FROM、WHERE、HAVING等子句中。

```sql
-- 在WHERE子句中使用子查询
SELECT employee_id, first_name, salary
FROM employees
WHERE salary > (
    SELECT AVG(salary) FROM employees
);

-- 在FROM子句中使用子查询（派生表）
SELECT department_id, avg_salary
FROM (
    SELECT department_id, AVG(salary) AS avg_salary
    FROM employees
    GROUP BY department_id
) dept_avg
WHERE avg_salary > 10000;
```

### 3.2 相关子查询

相关子查询是指子查询依赖于外部查询的值，对于外部查询的每一行，子查询都会执行一次。

```sql
-- 示例：查询薪资高于所在部门平均薪资的员工
SELECT employee_id, first_name, salary, department_id
FROM employees e
WHERE salary > (
    SELECT AVG(salary)
    FROM employees
    WHERE department_id = e.department_id  -- 相关子查询
);

-- 使用EXISTS的相关子查询
SELECT department_id, department_name
FROM departments d
WHERE EXISTS (
    SELECT 1
    FROM employees
    WHERE department_id = d.department_id AND salary > 15000
);
```

### 3.3 非相关子查询

非相关子查询不依赖于外部查询的值，只执行一次。

```sql
-- 示例：查询薪资高于公司平均薪资的员工
SELECT employee_id, first_name, salary
FROM employees
WHERE salary > (
    SELECT AVG(salary) FROM employees  -- 非相关子查询
);

-- 示例：查询薪资最高的员工信息
SELECT employee_id, first_name, salary
FROM employees
WHERE salary = (
    SELECT MAX(salary) FROM employees  -- 非相关子查询
);
```

### 3.4 子查询与IN、ANY、ALL

```sql
-- 使用IN的子查询
SELECT employee_id, first_name, department_id
FROM employees
WHERE department_id IN (
    SELECT department_id
    FROM departments
    WHERE location_id = 1700
);

-- 使用ANY的子查询
SELECT employee_id, first_name, salary
FROM employees
WHERE salary > ANY (
    SELECT salary
    FROM employees
    WHERE department_id = 50
);

-- 等价于
SELECT employee_id, first_name, salary
FROM employees
WHERE salary > (
    SELECT MIN(salary)
    FROM employees
    WHERE department_id = 50
);

-- 使用ALL的子查询
SELECT employee_id, first_name, salary
FROM employees
WHERE salary > ALL (
    SELECT salary
    FROM employees
    WHERE department_id = 50
);

-- 等价于
SELECT employee_id, first_name, salary
FROM employees
WHERE salary > (
    SELECT MAX(salary)
    FROM employees
    WHERE department_id = 50
);
```

### 3.5 子查询与EXISTS、NOT EXISTS

```sql
-- 使用EXISTS
SELECT department_id, department_name
FROM departments d
WHERE EXISTS (
    SELECT 1
    FROM employees e
    WHERE e.department_id = d.department_id
);

-- 使用NOT EXISTS
SELECT department_id, department_name
FROM departments d
WHERE NOT EXISTS (
    SELECT 1
    FROM employees e
    WHERE e.department_id = d.department_id
);
```

## 4. 聚合函数与分组

### 4.1 常用聚合函数

MySQL提供了多种聚合函数：

| 函数 | 描述 |
|------|------|
| COUNT() | 计数，统计行数 |
| SUM() | 求和 |
| AVG() | 平均值 |
| MAX() | 最大值 |
| MIN() | 最小值 |
| GROUP_CONCAT() | 连接组内的值 |

```sql
-- COUNT函数
SELECT COUNT(*) FROM employees;  -- 统计所有行
SELECT COUNT(employee_id) FROM employees;  -- 统计非NULL值的行
SELECT COUNT(DISTINCT department_id) FROM employees;  -- 统计不同部门数量

-- SUM和AVG函数
SELECT 
    SUM(salary) AS total_salary,
    AVG(salary) AS avg_salary,
    MAX(salary) AS max_salary,
    MIN(salary) AS min_salary
FROM employees;

-- GROUP_CONCAT函数
SELECT 
    department_id,
    GROUP_CONCAT(first_name) AS employee_names
FROM employees
GROUP BY department_id;
```

### 4.2 GROUP BY子句

GROUP BY子句用于将具有相同值的行组合成摘要行。

```sql
-- 基本用法
SELECT department_id, AVG(salary) AS avg_salary
FROM employees
GROUP BY department_id;

-- 多列分组
SELECT department_id, job_id, COUNT(*) AS employee_count
FROM employees
GROUP BY department_id, job_id;

-- GROUP BY与CASE表达式结合
SELECT 
    CASE 
        WHEN salary < 5000 THEN '低薪资'
        WHEN salary < 10000 THEN '中等薪资'
        ELSE '高薪资'
    END AS salary_level,
    COUNT(*) AS employee_count
FROM employees
GROUP BY 
    CASE 
        WHEN salary < 5000 THEN '低薪资'
        WHEN salary < 10000 THEN '中等薪资'
        ELSE '高薪资'
    END;
```

### 4.3 HAVING子句

HAVING子句用于过滤分组后的结果，类似于WHERE子句，但用于聚合函数。

```sql
-- 基本用法
SELECT department_id, AVG(salary) AS avg_salary
FROM employees
GROUP BY department_id
HAVING AVG(salary) > 10000;

-- 与WHERE子句结合
SELECT 
    d.department_name,
    COUNT(e.employee_id) AS employee_count,
    AVG(e.salary) AS avg_salary
FROM employees e
JOIN departments d ON e.department_id = d.department_id
WHERE e.hire_date > '2005-01-01'  -- 过滤行
GROUP BY d.department_name
HAVING AVG(e.salary) > 10000;  -- 过滤分组
```

### 4.4 WITH ROLLUP

WITH ROLLUP选项可以生成超级聚合行，提供多层汇总。

```sql
-- 基本用法
SELECT 
    department_id,
    job_id,
    COUNT(*) AS employee_count,
    AVG(salary) AS avg_salary
FROM employees
GROUP BY department_id, job_id WITH ROLLUP;

-- 结果解读：
-- 1. 部门+职位的组合
-- 2. 部门（job_id为NULL）
-- 3. 所有（department_id和job_id都为NULL）
```

### 4.5 GROUPING函数

GROUPING函数用于区分由WITH ROLLUP生成的NULL值和实际数据中的NULL值。

```sql
SELECT 
    department_id,
    job_id,
    COUNT(*) AS employee_count,
    GROUPING(department_id) AS dept_grouping,
    GROUPING(job_id) AS job_grouping
FROM employees
GROUP BY department_id, job_id WITH ROLLUP;
```

## 5. 窗口函数

### 5.1 窗口函数基础

窗口函数（Window Functions）允许我们对结果集中的行进行计算，类似于聚合函数，但不会导致行被合并成单个输出行。

```sql
-- 基本语法
function_name(argument) OVER (
    [PARTITION BY partition_expression]
    [ORDER BY sort_expression]
    [frame_clause]
)
```

### 5.2 排名函数

| 函数 | 描述 |
|------|------|
| ROW_NUMBER() | 为每一行分配一个唯一的连续整数 |
| RANK() | 为每一行分配一个排名，相同值具有相同排名，会有间隔 |
| DENSE_RANK() | 为每一行分配一个排名，相同值具有相同排名，无间隔 |
| NTILE(n) | 将分区中的行分成n个大致相等的组 |

```sql
-- ROW_NUMBER示例
SELECT 
    employee_id,
    first_name,
    salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) AS salary_rank
FROM employees;

-- RANK示例
SELECT 
    employee_id,
    first_name,
    salary,
    RANK() OVER (ORDER BY salary DESC) AS salary_rank
FROM employees;

-- DENSE_RANK示例
SELECT 
    employee_id,
    first_name,
    salary,
    DENSE_RANK() OVER (ORDER BY salary DESC) AS salary_rank
FROM employees;

-- 分区排名
SELECT 
    employee_id,
    first_name,
    department_id,
    salary,
    ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) AS dept_rank
FROM employees;
```

### 5.3 聚合窗口函数

聚合函数也可以用作窗口函数。

```sql
-- SUM作为窗口函数
SELECT 
    employee_id,
    first_name,
    salary,
    SUM(salary) OVER () AS total_salary,
    SUM(salary) OVER (ORDER BY employee_id) AS running_total
FROM employees;

-- AVG作为窗口函数
SELECT 
    employee_id,
    first_name,
    department_id,
    salary,
    AVG(salary) OVER (PARTITION BY department_id) AS dept_avg_salary
FROM employees;
```

### 5.4 取值函数

| 函数 | 描述 |
|------|------|
| LAG() | 获取当前行之前的行的值 |
| LEAD() | 获取当前行之后的行的值 |
| FIRST_VALUE() | 获取窗口中的第一行值 |
| LAST_VALUE() | 获取窗口中的最后一行值 |
| NTH_VALUE() | 获取窗口中的第n行值 |

```sql
-- LAG和LEAD示例
SELECT 
    employee_id,
    first_name,
    hire_date,
    LAG(hire_date, 1) OVER (ORDER BY hire_date) AS prev_hire_date,
    LEAD(hire_date, 1) OVER (ORDER BY hire_date) AS next_hire_date
FROM employees;

-- FIRST_VALUE和LAST_VALUE示例
SELECT 
    employee_id,
    first_name,
    department_id,
    salary,
    FIRST_VALUE(salary) OVER (
        PARTITION BY department_id 
        ORDER BY salary 
        RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS dept_min_salary,
    LAST_VALUE(salary) OVER (
        PARTITION BY department_id 
        ORDER BY salary 
        RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS dept_max_salary
FROM employees;
```

### 5.5 窗口框架

窗口框架定义了窗口函数计算的行范围。

```sql
-- ROWS BETWEEN示例
SELECT 
    employee_id,
    first_name,
    salary,
    SUM(salary) OVER (
        ORDER BY salary 
        ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
    ) AS moving_sum
FROM employees;

-- RANGE BETWEEN示例
SELECT 
    employee_id,
    first_name,
    salary,
    AVG(salary) OVER (
        ORDER BY salary 
        RANGE BETWEEN 1000 PRECEDING AND 1000 FOLLOWING
    ) AS moving_avg
FROM employees;

-- 不同窗口框架示例
SELECT 
    employee_id,
    first_name,
    salary,
    SUM(salary) OVER (ORDER BY salary ROWS UNBOUNDED PRECEDING) AS running_total,
    SUM(salary) OVER (ORDER BY salary RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS remaining_total,
    SUM(salary) OVER (ORDER BY salary ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS moving_sum_5
FROM employees;
```

## 6. 高级过滤条件

### 6.1 模式匹配（LIKE和REGEXP）

```sql
-- LIKE操作符
SELECT first_name, last_name
FROM employees
WHERE first_name LIKE 'J%';  -- 以J开头

SELECT first_name, last_name
FROM employees
WHERE last_name LIKE '%s';   -- 以s结尾

SELECT first_name, last_name
FROM employees
WHERE first_name LIKE '_ohn';  -- 第二个字符是o的4字符名字

-- REGEXP操作符
SELECT first_name, last_name
FROM employees
WHERE first_name REGEXP '^J.*n$';  -- 以J开头，以n结尾

SELECT first_name, last_name
FROM employees
WHERE first_name REGEXP 'an|on';    -- 包含an或on

SELECT first_name, last_name
FROM employees
WHERE first_name REGEXP '[aeiou]';  -- 包含元音字母
```

### 6.2 NULL值处理

```sql
-- IS NULL和IS NOT NULL
SELECT first_name, commission_pct
FROM employees
WHERE commission_pct IS NULL;

SELECT first_name, commission_pct
FROM employees
WHERE commission_pct IS NOT NULL;

-- COALESCE函数：返回第一个非NULL值
SELECT 
    employee_id,
    first_name,
    COALESCE(commission_pct, 0) AS commission_pct
FROM employees;

-- IFNULL函数：MySQL特有，与COALESCE类似
SELECT 
    employee_id,
    first_name,
    IFNULL(commission_pct, 0) AS commission_pct
FROM employees;
```

### 6.3 类型转换

```sql
-- CAST函数
SELECT 
    employee_id,
    salary,
    CAST(salary AS CHAR) AS salary_as_char,
    CAST('2023-05-15' AS DATE) AS date_value
FROM employees;

-- CONVERT函数
SELECT 
    employee_id,
    salary,
    CONVERT(salary, CHAR) AS salary_as_char,
    CONVERT('2023-05-15', DATE) AS date_value
FROM employees;
```

### 6.4 日期时间函数

```sql
-- 日期提取函数
SELECT 
    employee_id,
    hire_date,
    YEAR(hire_date) AS hire_year,
    MONTH(hire_date) AS hire_month,
    DAY(hire_date) AS hire_day,
    DAYOFWEEK(hire_date) AS day_of_week,
    WEEKDAY(hire_date) AS weekday
FROM employees;

-- 日期计算函数
SELECT 
    employee_id,
    hire_date,
    DATEDIFF(CURRENT_DATE(), hire_date) AS days_employed,
    DATE_ADD(hire_date, INTERVAL 10 YEAR) AS ten_year_anniversary,
    DATE_SUB(hire_date, INTERVAL 30 DAY) AS thirty_days_before_hire
FROM employees;

-- 日期格式化函数
SELECT 
    employee_id,
    hire_date,
    DATE_FORMAT(hire_date, '%Y-%m-%d') AS formatted_date,
    DATE_FORMAT(hire_date, '%W, %M %d, %Y') AS long_format
FROM employees;
```

### 6.5 字符串函数

```sql
-- 字符串提取和连接
SELECT 
    employee_id,
    first_name,
    last_name,
    CONCAT(first_name, ' ', last_name) AS full_name,
    CONCAT_WS(', ', last_name, first_name) AS last_first_name
FROM employees;

-- 字符串操作
SELECT 
    employee_id,
    first_name,
    UPPER(first_name) AS upper_name,
    LOWER(first_name) AS lower_name,
    LENGTH(first_name) AS name_length,
    SUBSTRING(first_name, 1, 3) AS first_three_chars
FROM employees;

-- 字符串替换和去除
SELECT 
    employee_id,
    email,
    REPLACE(email, '@', ' [at] ') AS masked_email,
    TRIM('  hello  ') AS trimmed_string
FROM employees;
```

## 7. 查询优化

### 7.1 EXPLAIN分析

EXPLAIN命令用于分析查询的执行计划。

```sql
-- 基本用法
EXPLAIN SELECT * FROM employees WHERE department_id = 50;

-- 扩展用法
EXPLAIN FORMAT=JSON SELECT * FROM employees WHERE department_id = 50;

-- 分析连接查询
EXPLAIN 
SELECT e.first_name, d.department_name 
FROM employees e
JOIN departments d ON e.department_id = d.department_id;
```

EXPLAIN输出结果的关键列：

| 列 | 描述 |
|------|------|
| id | 查询标识符 |
| select_type | 查询类型（SIMPLE, PRIMARY, SUBQUERY等） |
| table | 输出行所在的表 |
| type | 连接类型（ALL, index, range, ref, eq_ref, const, system） |
| possible_keys | 可能使用的索引 |
| key | 实际使用的索引 |
| key_len | 使用的索引长度 |
| ref | 索引比较的列 |
| rows | 预计需要检查的行数 |
| Extra | 额外信息（Using where, Using index, Using filesort等） |

### 7.2 索引优化

```sql
-- 创建适当的索引
CREATE INDEX idx_emp_dept ON employees(department_id);
CREATE INDEX idx_emp_salary ON employees(salary);

-- 复合索引
CREATE INDEX idx_emp_dept_salary ON employees(department_id, salary);

-- 使用索引覆盖查询
SELECT department_id, salary FROM employees WHERE department_id = 50;

-- 避免在索引列上使用函数
-- 不好的查询：不会使用索引
SELECT * FROM employees WHERE YEAR(hire_date) = 2005;

-- 好的查询：可以使用范围查询
SELECT * FROM employees WHERE hire_date >= '2005-01-01' AND hire_date < '2006-01-01';
```

### 7.3 查询重写技巧

```sql
-- 使用JOIN代替子查询
-- 不好的查询
SELECT employee_id, first_name
FROM employees
WHERE department_id IN (
    SELECT department_id FROM departments WHERE location_id = 1700
);

-- 好的查询
SELECT e.employee_id, e.first_name
FROM employees e
JOIN departments d ON e.department_id = d.department_id
WHERE d.location_id = 1700;

-- 使用UNION ALL代替UNION（如果不需要去重）
-- 不好的查询
SELECT employee_id, first_name FROM employees WHERE department_id = 50
UNION
SELECT employee_id, first_name FROM employees WHERE department_id = 60;

-- 好的查询（如果确定没有重复）
SELECT employee_id, first_name FROM employees WHERE department_id = 50
UNION ALL
SELECT employee_id, first_name FROM employees WHERE department_id = 60;
```

### 7.4 分页优化

```sql
-- 基本分页（对于大数据集性能较差）
SELECT * FROM employees ORDER BY employee_id LIMIT 10 OFFSET 1000;

-- 使用ID优化分页（假设employee_id是连续的）
SELECT * FROM employees 
WHERE employee_id > 1000 
ORDER BY employee_id 
LIMIT 10;

-- 使用子查询优化分页
SELECT * FROM employees 
WHERE employee_id >= (
    SELECT employee_id FROM employees 
    ORDER BY employee_id 
    LIMIT 1 OFFSET 1000
)
ORDER BY employee_id 
LIMIT 10;
```

## 8. 最佳实践

### 8.1 查询设计原则

1. **明确指定列名**：避免使用SELECT *，只查询需要的列
2. **合理使用索引**：为WHERE、JOIN、ORDER BY子句中的列创建索引
3. **避免在WHERE子句中对列使用函数**：这会导致索引失效
4. **使用适当的JOIN类型**：根据需要选择INNER JOIN、LEFT JOIN等
5. **优化子查询**：考虑使用JOIN或EXISTS替代某些子查询
6. **合理使用LIMIT**：避免返回不必要的大量数据

### 8.2 性能优化技巧

1. **使用EXPLAIN分析查询**：定期分析查询执行计划
2. **避免全表扫描**：确保WHERE条件能够使用索引
3. **谨慎使用通配符**：LIKE '%text%'会导致全表扫描
4. **优化GROUP BY和ORDER BY**：确保它们使用索引
5. **批量操作替代循环操作**：减少数据库往返次数
6. **定期优化表**：使用OPTIMIZE TABLE命令优化表结构

### 8.3 可读性提升

1. **使用表别名**：提高多表查询的可读性
2. **格式化SQL**：合理使用缩进和换行
3. **添加注释**：为复杂查询添加必要的注释
4. **命名规范**：使用有意义的表名和列名
5. **避免过长的查询**：将复杂查询分解为多个简单查询

## 总结

本章介绍了MySQL高级查询技术，包括：

1. **高级SELECT语句**：DISTINCT、别名、CASE表达式等
2. **连接查询**：内连接、外连接、自连接、多表连接
3. **子查询**：相关子查询、非相关子查询、IN/ANY/ALL、EXISTS
4. **聚合函数与分组**：常用聚合函数、GROUP BY、HAVING、WITH ROLLUP
5. **窗口函数**：排名函数、聚合窗口函数、取值函数、窗口框架
6. **高级过滤条件**：模式匹配、NULL处理、类型转换、日期函数
7. **查询优化**：EXPLAIN分析、索引优化、查询重写、分页优化

通过掌握这些高级查询技术，您可以构建更复杂、更高效的查询，满足各种复杂的数据检索需求。下一章我们将深入探讨MySQL的事务处理与锁机制。