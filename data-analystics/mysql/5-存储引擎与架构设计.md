# 第5章：存储引擎与架构设计

## 1. MySQL存储引擎概述

### 1.1 存储引擎简介

MySQL采用插件式存储引擎架构，允许根据不同的应用需求选择最适合的存储引擎。存储引擎是MySQL中处理数据存储和检索的组件，负责数据的物理存储、索引管理、事务处理等底层操作。

#### 存储引擎的作用

- **数据存储**：负责数据的物理存储和检索
- **索引管理**：创建和维护数据索引
- **事务处理**：支持ACID事务特性（部分引擎）
- **锁定机制**：实现并发控制和数据一致性
- **缓存管理**：管理数据和索引的缓存

#### 查看存储引擎

```sql
-- 查看所有支持的存储引擎
SHOW ENGINES;

-- 查看默认存储引擎
SHOW VARIABLES LIKE 'storage_engine';

-- 查看表的存储引擎
SHOW TABLE STATUS FROM your_database;

-- 查看特定表的存储引擎
SHOW CREATE TABLE your_table;
```

### 1.2 常见存储引擎对比

| 特性 | InnoDB | MyISAM | Memory | NDB | Archive |
|------|--------|--------|--------|-----|---------|
| 事务支持 | 是 | 否 | 否 | 是 | 否 |
| 锁定机制 | 行级锁 | 表级锁 | 表级锁 | 行级锁 | 行级锁 |
| 外键约束 | 支持 | 不支持 | 不支持 | 不支持 | 不支持 |
| 崩溃恢复 | 支持 | 不支持 | 不支持 | 支持 | 不支持 |
| 全文索引 | 5.6+支持 | 支持 | 不支持 | 不支持 | 不支持 |
| 空间数据 | 支持 | 支持 | 不支持 | 不支持 | 不支持 |
| 数据压缩 | 支持 | 支持 | 不支持 | 不支持 | 支持 |
| 主要用途 | 事务处理 | 读密集 | 临时数据 | 分布式集群 | 归档数据 |

### 1.3 存储引擎选择指南

#### InnoDB适用场景

- 需要事务支持的应用
- 高并发读写场景
- 需要外键约束的数据
- 需要崩溃恢复的可靠应用

#### MyISAM适用场景

- 读多写少的应用
- 不需要事务支持的场景
- 需要全文搜索的应用（MySQL 5.6之前）
- 需要表级锁定的应用

#### Memory适用场景

- 需要快速访问的临时数据
- 小型查找表或参考表
- 会话数据存储
- 结果集缓存

## 2. InnoDB存储引擎详解

### 2.1 InnoDB架构

#### 物理结构

InnoDB将数据存储在表空间文件中，支持多种表空间管理方式：

- **系统表空间**：存储数据字典、撤销日志等
- **独立表空间**：每个表使用独立的.ibd文件存储数据和索引
- **通用表空间**：共享表空间，可以包含多个表

```sql
-- 查看表空间配置
SHOW VARIABLES LIKE 'innodb_file_per_table';

-- 查看表空间信息
SELECT 
    SPACE, 
    NAME, 
    PATH, 
    FLAG 
FROM INFORMATION_SCHEMA.INNODB_DATAFILES
WHERE NAME LIKE '%your_database%';

-- 创建独立表空间的表
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE
) ENGINE=InnoDB TABLESPACE innodb_file_per_table;
```

#### 内存结构

InnoDB使用多个内存区域来提高性能：

- **缓冲池(Buffer Pool)**：缓存数据和索引
- **日志缓冲区(Log Buffer)**：缓存事务日志
- **额外内存池(Extra Memory Pool)**：存储内部数据结构

```sql
-- 查看缓冲池配置
SHOW VARIABLES LIKE 'innodb_buffer_pool%';
SHOW STATUS LIKE 'Innodb_buffer_pool%';
```

### 2.2 InnoDB事务特性

#### ACID特性

- **原子性(Atomicity)**：事务是一个不可分割的工作单位
- **一致性(Consistency)**：事务前后数据库的完整性约束没有被破坏
- **隔离性(Isolation)**：多个并发事务之间相互隔离
- **持久性(Durability)**：事务一旦提交，对数据库的改变是永久的

#### 隔离级别

```sql
-- 查看当前隔离级别
SELECT @@global.tx_isolation, @@session.tx_isolation;

-- 设置隔离级别
SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 查看各隔离级别的特点
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;
```

#### 事务控制语句

```sql
-- 开始事务
START TRANSACTION;
BEGIN;

-- 提交事务
COMMIT;

-- 回滚事务
ROLLBACK;

-- 保存点
SAVEPOINT savepoint_name;
ROLLBACK TO SAVEPOINT savepoint_name;
RELEASE SAVEPOINT savepoint_name;
```

### 2.3 InnoDB锁定机制

#### 锁类型

- **共享锁(Shared Lock/S锁)**：允许事务读取数据
- **排他锁(Exclusive Lock/X锁)**：允许事务修改数据
- **意向锁(Intention Lock)**：表级锁，表示事务打算在表中的某些行上获取锁

```sql
-- 显式加锁
SELECT * FROM users WHERE id = 1 LOCK IN SHARE MODE;  -- 共享锁
SELECT * FROM users WHERE id = 1 FOR UPDATE;  -- 排他锁
```

#### 死锁检测与处理

```sql
-- 查看最近的死锁信息
SHOW ENGINE INNODB STATUS;

-- 设置锁等待超时
SET GLOBAL innodb_lock_wait_timeout = 50;

-- 设置死锁检测开关
SET GLOBAL innodb_deadlock_detect = ON;
```

### 2.4 InnoDB性能优化

#### 缓冲池优化

```sql
-- 设置缓冲池大小（建议为物理内存的60%-80%）
SET GLOBAL innodb_buffer_pool_size = 4294967296;  -- 4GB

-- 设置缓冲池实例数（每个实例1GB）
SET GLOBAL innodb_buffer_pool_instances = 4;
```

#### 日志优化

```sql
-- 设置日志文件大小
SET GLOBAL innodb_log_file_size = 268435456;  -- 256MB

-- 设置日志缓冲区大小
SET GLOBAL innodb_log_buffer_size = 16777216;  -- 16MB

-- 设置日志刷新策略
SET GLOBAL innodb_flush_log_at_trx_commit = 1;  -- 每次提交都刷新
```

#### I/O优化

```sql
-- 设置I/O线程数
SET GLOBAL innodb_read_io_threads = 8;
SET GLOBAL innodb_write_io_threads = 8;

-- 设置I/O容量
SET GLOBAL innodb_io_capacity = 2000;
SET GLOBAL innodb_io_capacity_max = 4000;
```

## 3. MyISAM存储引擎详解

### 3.1 MyISAM架构

#### 存储文件

MyISAM表由以下文件组成：

- `.frm`文件：表结构定义文件
- `.MYD`文件：数据文件
- `.MYI`文件：索引文件

```sql
-- 创建MyISAM表
CREATE TABLE articles (
    id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(100) NOT NULL,
    content TEXT,
    author VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=MyISAM;

-- 查看表文件信息
SHOW TABLE STATUS LIKE 'articles';
```

#### 索引结构

MyISAM使用B-Tree索引，支持：

- **主键索引**：PRIMARY KEY
- **唯一索引**：UNIQUE
- **普通索引**：INDEX
- **全文索引**：FULLTEXT
- **空间索引**：SPATIAL

```sql
-- 创建全文索引
ALTER TABLE articles ADD FULLTEXT(title, content);

-- 使用全文索引搜索
SELECT id, title, author FROM articles 
WHERE MATCH(title, content) AGAINST('MySQL tutorial');
```

### 3.2 MyISAM特性

#### 非事务性

MyISAM不支持事务，但提供了一些替代机制：

```sql
-- 表修复
REPAIR TABLE articles;

-- 表优化
OPTIMIZE TABLE articles;

-- 表检查
CHECK TABLE articles;
```

#### 表级锁定

MyISAM使用表级锁定，适合读多写少的场景：

```sql
-- 显式锁定
LOCK TABLE articles READ;  -- 读锁
LOCK TABLE articles WRITE;  -- 写锁

-- 解锁
UNLOCK TABLES;
```

#### 延迟键写入

```sql
-- 启用延迟键写入
ALTER TABLE articles DELAY_KEY_WRITE = 1;

-- 全局设置延迟键写入
SET GLOBAL delayed_key_write = ON;
```

### 3.3 MyISAM性能优化

#### 键缓冲区优化

```sql
-- 设置键缓冲区大小
SET GLOBAL key_buffer_size = 268435456;  -- 256MB

-- 设置键缓冲区数量
SET GLOBAL key_cache_division_limit = 100;

-- 查看键缓冲区使用情况
SHOW STATUS LIKE 'Key_%';
```

#### 并发插入优化

```sql
-- 启用并发插入
ALTER TABLE articles CONCURRENT = ON;

-- 设置并发插入阈值
SET GLOBAL concurrent_insert = AUTO;  -- AUTO, NEVER, ALWAYS
```

#### 压缩表

```sql
-- 创建压缩表
CREATE TABLE compressed_articles (
    id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(100) NOT NULL,
    content TEXT
) ENGINE=MyISAM ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8;

-- 修改现有表为压缩表
ALTER TABLE articles ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8;
```

## 4. 特殊用途存储引擎

### 4.1 Memory存储引擎

Memory存储引擎将数据存储在内存中，提供极快的访问速度，但数据在服务器重启后会丢失。

```sql
-- 创建Memory表
CREATE TABLE user_sessions (
    session_id VARCHAR(40) PRIMARY KEY,
    user_id INT NOT NULL,
    data TEXT,
    last_access TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=Memory;

-- 设置Memory表的最大行数
SET GLOBAL max_heap_table_size = 134217728;  -- 128MB
```

### 4.2 Archive存储引擎

Archive存储引擎用于存储大量历史数据，支持高压缩比和高效插入。

```sql
-- 创建Archive表
CREATE TABLE logs (
    id BIGINT UNSIGNED AUTO_INCREMENT,
    log_time TIMESTAMP NOT NULL,
    level ENUM('DEBUG', 'INFO', 'WARNING', 'ERROR') NOT NULL,
    message TEXT,
    PRIMARY KEY (id),
    INDEX idx_log_time (log_time)
) ENGINE=Archive;
```

### 4.3 NDB集群存储引擎

NDB存储引擎用于MySQL集群环境，提供分布式数据存储和高可用性。

```sql
-- 创建NDB表
CREATE TABLE cluster_users (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE
) ENGINE=NDB;

-- 设置NDB集群参数
SET GLOBAL ndbcluster_connection_pool = 4;
SET GLOBAL ndb_force_send = ON;
```

### 4.4 CSV存储引擎

CSV存储引擎将数据存储为CSV格式文件，适合与外部数据交换。

```sql
-- 创建CSV表
CREATE TABLE user_exports (
    id INT NOT NULL,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100)
) ENGINE=CSV;

-- 导入CSV数据
LOAD DATA INFILE '/path/to/users.csv'
INTO TABLE user_exports
FIELDS TERMINATED BY ',' ENCLOSED BY '"'
LINES TERMINATED BY '\n';
```

## 5. 高可用架构设计

### 5.1 主从复制

#### 基础复制架构

```sql
-- 主服务器配置
[mysqld]
server-id=1
log-bin=mysql-bin
binlog-format=ROW
binlog-do-db=your_database
expire_logs_days=7

-- 从服务器配置
[mysqld]
server-id=2
relay-log=relay-bin
read-only=1
```

#### 创建复制用户

```sql
-- 在主服务器上创建复制用户
CREATE USER 'repl_user'@'%' IDENTIFIED BY 'repl_password';
GRANT REPLICATION SLAVE ON *.* TO 'repl_user'@'%';
FLUSH PRIVILEGES;

-- 获取主服务器二进制日志位置
SHOW MASTER STATUS;
```

#### 配置从服务器

```sql
-- 在从服务器上配置主服务器信息
CHANGE MASTER TO
    MASTER_HOST='master_ip',
    MASTER_USER='repl_user',
    MASTER_PASSWORD='repl_password',
    MASTER_LOG_FILE='mysql-bin.000001',
    MASTER_LOG_POS=154;

-- 启动复制
START SLAVE;

-- 检查复制状态
SHOW SLAVE STATUS\G;
```

### 5.2 GTID复制

#### GTID配置

```sql
-- 主服务器配置
[mysqld]
server-id=1
log-bin=mysql-bin
binlog-format=ROW
gtid-mode=ON
enforce-gtid-consistency=1
log-slave-updates=1

-- 从服务器配置
[mysqld]
server-id=2
gtid-mode=ON
enforce-gtid-consistency=1
log-slave-updates=1
```

#### GTID复制设置

```sql
-- 在从服务器上配置GTID复制
CHANGE MASTER TO
    MASTER_HOST='master_ip',
    MASTER_USER='repl_user',
    MASTER_PASSWORD='repl_password',
    MASTER_AUTO_POSITION=1;

-- 启动GTID复制
START SLAVE;

-- 检查GTID执行情况
SHOW GLOBAL VARIABLES LIKE 'gtid%';
SELECT * FROM performance_schema.replication_connection_status;
SELECT * FROM performance_schema.replication_applier_status;
```

### 5.3 半同步复制

#### 半同步复制配置

```sql
-- 主服务器安装插件
INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';
SET GLOBAL rpl_semi_sync_master_enabled = 1;
SET GLOBAL rpl_semi_sync_master_timeout = 1000;  -- 1秒

-- 从服务器安装插件
INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';
SET GLOBAL rpl_semi_sync_slave_enabled = 1;
```

#### 监控半同步复制

```sql
-- 查看半同步状态
SHOW STATUS LIKE 'Rpl_semi_sync%';

-- 检查从服务器状态
SELECT * FROM performance_schema.replication_connection_status;
```

### 5.4 组复制

#### 组复制配置

```sql
-- 组复制配置
[mysqld]
server-id=1
gtid-mode=ON
enforce-gtid-consistency=1
log-slave-updates=1
binlog-format=ROW
binlog-checksum=NONE
master-info-repository=TABLE
relay-log-info-repository=TABLE
relay-log-recovery=ON
transaction-write-set-extraction=XXHASH64
loose-group-replication-start-on-boot=off
loose-group-replication-local-address=127.0.0.1:33061
loose-group-replication-group-seeds=127.0.0.1:33061,127.0.0.1:33062,127.0.0.1:33063
loose-group-replication-single-primary-mode=on
loose-group-replication-ip-whitelist=127.0.0.1,10.0.0.0/8
```

#### 启动组复制

```sql
-- 安装组复制插件
INSTALL PLUGIN group_replication SONAME 'group_replication.so';

-- 设置复制通道
CHANGE MASTER TO MASTER_USER='rpl_user', MASTER_PASSWORD='rpl_password' FOR CHANNEL 'group_replication_recovery';

-- 启动组复制
SET GLOBAL group_replication_bootstrap_group=ON;
START GROUP_REPLICATION;
SET GLOBAL group_replication_bootstrap_group=OFF;
```

#### 监控组复制

```sql
-- 查看组复制成员
SELECT * FROM performance_schema.replication_group_members;

-- 查看组复制状态
SELECT * FROM performance_schema.replication_group_member_stats;
```

## 6. 分片架构设计

### 6.1 水平分片

#### 基于范围分片

```sql
-- 创建分片表结构
CREATE TABLE users_shard1 LIKE users;
CREATE TABLE users_shard2 LIKE users;
CREATE TABLE users_shard3 LIKE users;

-- 创建分片视图
CREATE VIEW users AS
SELECT * FROM users_shard1
UNION ALL
SELECT * FROM users_shard2
UNION ALL
SELECT * FROM users_shard3;

-- 创建分片存储过程
DELIMITER //
CREATE PROCEDURE insert_user_shard(IN user_name VARCHAR(50), IN email_addr VARCHAR(100))
BEGIN
    DECLARE shard_id INT;
    SET shard_id = CRC32(user_name) % 3 + 1;
    
    CASE shard_id
        WHEN 1 THEN
            INSERT INTO users_shard1 (name, email) VALUES (user_name, email_addr);
        WHEN 2 THEN
            INSERT INTO users_shard2 (name, email) VALUES (user_name, email_addr);
        WHEN 3 THEN
            INSERT INTO users_shard3 (name, email) VALUES (user_name, email_addr);
    END CASE;
END //
DELIMITER ;
```

#### 基于哈希分片

```sql
-- 创建哈希分片函数
DELIMITER //
CREATE FUNCTION get_shard_id(input_value VARCHAR(100), shard_count INT)
RETURNS INT
DETERMINISTIC
BEGIN
    RETURN CRC32(input_value) % shard_count + 1;
END //
DELIMITER ;

-- 使用哈希分片插入
INSERT INTO products_shard1 (name, price) 
SELECT name, price FROM products 
WHERE get_shard_id(name, 4) = 1;
```

### 6.2 垂直分片

#### 垂直分片设计

```sql
-- 原始表
CREATE TABLE all_data (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100),
    profile TEXT,
    preferences JSON,
    login_history TEXT,
    last_login TIMESTAMP
);

-- 垂直分片后的表
CREATE TABLE users_basic (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE
);

CREATE TABLE users_profile (
    user_id INT PRIMARY KEY,
    profile TEXT,
    preferences JSON,
    FOREIGN KEY (user_id) REFERENCES users_basic(id)
);

CREATE TABLE users_activity (
    user_id INT,
    login_history TEXT,
    last_login TIMESTAMP,
    PRIMARY KEY (user_id),
    FOREIGN KEY (user_id) REFERENCES users_basic(id)
);

-- 创建跨分片视图
CREATE VIEW users_all AS
SELECT 
    b.id,
    b.name,
    b.email,
    p.profile,
    p.preferences,
    a.login_history,
    a.last_login
FROM users_basic b
LEFT JOIN users_profile p ON b.id = p.user_id
LEFT JOIN users_activity a ON b.id = a.user_id;
```

### 6.3 分片中间件

#### 使用ProxySQL实现分片

```sql
-- 配置ProxySQL分片规则
INSERT INTO mysql_servers (
    hostgroup_id, 
    hostname, 
    port
) VALUES (
    10, 
    'shard1.db.com', 
    3306
);

INSERT INTO mysql_servers (
    hostgroup_id, 
    hostname, 
    port
) VALUES (
    20, 
    'shard2.db.com', 
    3306
);

-- 配置分片规则
INSERT INTO mysql_query_rules (
    rule_id,
    active,
    match_digest,
    destination_hostgroup,
    apply
) VALUES (
    1,
    1,
    '^SELECT.*FROM users_shard1',
    10,
    1
);

INSERT INTO mysql_query_rules (
    rule_id,
    active,
    match_digest,
    destination_hostgroup,
    apply
) VALUES (
    2,
    1,
    '^SELECT.*FROM users_shard2',
    20,
    1
);
```

## 7. 分布式事务

### 7.1 XA事务

#### XA事务基础

```sql
-- 开始XA事务
XA START 'xa_transaction_1';

-- 执行SQL操作
INSERT INTO orders (customer_id, total_amount) VALUES (1, 100.00);
INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (LAST_INSERT_ID(), 1, 1, 100.00);

-- 结束XA事务
XA END 'xa_transaction_1';

-- 准备提交
XA PREPARE 'xa_transaction_1';

-- 提交XA事务
XA COMMIT 'xa_transaction_1';

-- 回滚XA事务
XA ROLLBACK 'xa_transaction_1';
```

#### XA事务管理

```sql
-- 查看XA事务状态
XA RECOVER;

-- 设置XA事务超时
SET GLOBAL innodb_xa_timeout = 60;
```

### 7.2 两阶段提交

#### 两阶段提交协议

```sql
-- 第一阶段：准备阶段
PREPARE TRANSACTION 'transaction_id';

-- 第二阶段：提交阶段
COMMIT PREPARED 'transaction_id';

-- 或者回滚
ROLLBACK PREPARED 'transaction_id';
```

#### 分布式事务示例

```sql
-- 在数据库1上执行
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
PREPARE TRANSACTION 'tx_001';

-- 在数据库2上执行
BEGIN;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
PREPARE TRANSACTION 'tx_002';

-- 提交所有事务
COMMIT PREPARED 'tx_001';
COMMIT PREPARED 'tx_002';
```

## 8. 架构最佳实践

### 8.1 高可用性设计

#### 主从复制最佳实践

```sql
-- 使用GTID实现自动故障转移
-- 确保主从数据一致性
-- 定期监控复制延迟
SELECT * FROM performance_schema.replication_applier_status;
```

#### 负载均衡策略

```sql
-- 读写分离配置
-- 读操作路由到从服务器
-- 写操作路由到主服务器
-- 使用连接池管理连接
```

### 8.2 性能优化

#### 索引优化

```sql
-- 为常用查询创建合适的索引
-- 避免过度索引
-- 定期分析和维护索引
ANALYZE TABLE table_name;
```

#### 查询优化

```sql
-- 使用EXPLAIN分析查询
-- 避免全表扫描
-- 合理使用缓存
EXPLAIN SELECT * FROM table_name WHERE condition;
```

### 8.3 数据安全

#### 备份策略

```sql
-- 全量备份
mysqldump --single-transaction --routines --triggers --all-databases > backup.sql

-- 增量备份
mysqlbinlog --start-datetime="2023-01-01 00:00:00" --stop-datetime="2023-01-02 00:00:00" mysql-bin.000001 > incremental.sql
```

#### 数据加密

```sql
-- 启用数据加密
SET GLOBAL innodb_encrypt_tables = ON;
SET GLOBAL innodb_encrypt_log = ON;
SET GLOBAL innodb_encrypt_tmp = ON;
```

### 8.4 监控与维护

#### 性能监控

```sql
-- 监控查询性能
SELECT * FROM performance_schema.events_statements_summary_by_digest 
ORDER BY SUM_TIMER_WAIT DESC LIMIT 10;

-- 监控锁等待
SELECT * FROM sys.innodb_lock_waits;
```

#### 定期维护

```sql
-- 定期优化表
OPTIMIZE TABLE table_name;

-- 检查表完整性
CHECK TABLE table_name;

-- 分析表统计信息
ANALYZE TABLE table_name;
```

## 9. 故障排除

### 9.1 复制故障

#### 常见复制问题

```sql
-- 检查复制状态
SHOW SLAVE STATUS\G;

-- 跳过复制错误
SET GLOBAL sql_slave_skip_counter = 1;
START SLAVE;

-- 重置复制
STOP SLAVE;
RESET SLAVE ALL;
```

#### 主从延迟处理

```sql
-- 监控复制延迟
SELECT * FROM performance_schema.replication_connection_status;

-- 并行复制配置
SET GLOBAL slave_parallel_workers = 4;
SET GLOBAL slave_parallel_type = LOGICAL_CLOCK;
```

### 9.2 存储引擎问题

#### InnoDB问题

```sql
-- 检查InnoDB状态
SHOW ENGINE INNODB STATUS;

-- 强制恢复
SET GLOBAL innodb_force_recovery = 1;
```

#### MyISAM问题

```sql
-- 修复MyISAM表
REPAIR TABLE table_name;

-- 优化MyISAM表
OPTIMIZE TABLE table_name;
```

### 9.3 集群故障

#### 组复制问题

```sql
-- 检查组复制状态
SELECT * FROM performance_schema.replication_group_members;

-- 重新加入组
STOP GROUP_REPLICATION;
START GROUP_REPLICATION;
```

## 10. 总结

本章详细介绍了MySQL存储引擎与架构设计的各个方面，包括：

### 10.1 存储引擎知识

- 理解了不同存储引擎的特点和适用场景
- 掌握了InnoDB的事务特性和性能优化
- 了解了MyISAM的特性和优化方法
- 熟悉了特殊用途存储引擎的应用场景

### 10.2 高可用架构

- 掌握了主从复制的配置和管理
- 理解了GTID复制和半同步复制
- 学会了组复制的配置和使用
- 了解了各种复制模式的优缺点

### 10.3 分布式架构

- 掌握了水平分片和垂直分片的设计方法
- 理解了分片中间件的使用
- 学会了分布式事务的实现
- 了解了XA事务和两阶段提交

### 10.4 最佳实践

- 学会了高可用性设计原则
- 掌握了性能优化方法
- 理解了数据安全和备份策略
- 了解了监控和维护的最佳实践

通过本章的学习，您应该能够：

1. **选择合适的存储引擎**，根据应用需求选择最适合的存储引擎
2. **设计高可用架构**，实现数据库的高可用和故障转移
3. **实现分布式架构**，通过分片和集群实现系统的可扩展性
4. **处理分布式事务**，保证分布式环境下的数据一致性
5. **优化系统性能**，通过各种技术和方法提高系统性能
6. **保障数据安全**，实现数据的备份、加密和恢复

存储引擎选择和架构设计是构建高性能、高可用数据库系统的关键。掌握这些知识，将帮助您设计出满足业务需求的优秀数据库架构。