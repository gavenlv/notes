# 第3章：函数与作用域

## 3.1 函数基础

### 3.1.1 什么是函数

函数是一段可重复使用的代码块，它接受输入（参数），执行特定任务，并可能返回输出（返回值）。在JavaScript中，函数是"一等公民"，这意味着函数可以作为值传递、存储在变量中、作为其他函数的参数或返回值。

### 3.1.2 为什么需要函数

1. **代码重用**：避免重复编写相同的代码
2. **模块化**：将复杂问题分解为更小的、可管理的部分
3. **抽象**：隐藏实现细节，只暴露必要的接口
4. **可维护性**：更容易定位和修复问题
5. **可测试性**：独立的函数更容易测试

### 3.1.3 函数的组成部分

一个典型的JavaScript函数包含以下部分：

```javascript
function 函数名(参数1, 参数2, ...) {
    // 函数体 - 执行的代码
    // ...
    
    return 返回值; // 可选
}
```

- **函数名**：标识函数的名称
- **参数**：函数接受输入的变量
- **函数体**：包含执行的代码
- **返回值**：函数输出的结果（可选）

## 3.2 函数声明方式

JavaScript提供了多种函数声明方式，每种方式有其特定的用途和特点。

### 3.2.1 函数声明（Function Declaration）

函数声明是最常见的函数定义方式，使用`function`关键字后跟函数名：

```javascript
// 基本函数声明
function greet(name) {
    return '你好，' + name + '！';
}

// 调用函数
console.log(greet('JavaScript')); // 输出：你好，JavaScript！

// 没有参数的函数
function sayHello() {
    return '你好，世界！';
}

console.log(sayHello()); // 输出：你好，世界！

// 多个参数的函数
function add(a, b) {
    return a + b;
}

console.log(add(5, 3)); // 输出：8
```

函数声明具有**函数提升**的特性，意味着函数可以在声明之前被调用：

```javascript
// 函数声明可以在声明之前调用
console.log(subtract(10, 3)); // 输出：7

function subtract(a, b) {
    return a - b;
}
```

### 3.2.2 函数表达式（Function Expression）

函数表达式是将函数赋值给变量的方式：

```javascript
// 基本函数表达式
const multiply = function(a, b) {
    return a * b;
};

console.log(multiply(5, 3)); // 输出：15

// 匿名函数表达式
const divide = function(a, b) {
    if (b === 0) {
        return '除数不能为0';
    }
    return a / b;
};

console.log(divide(10, 2)); // 输出：5
console.log(divide(10, 0)); // 输出：除数不能为0

// 命名函数表达式
const factorial = function fact(n) {
    if (n <= 1) {
        return 1;
    }
    return n * fact(n - 1);
};

console.log(factorial(5)); // 输出：120
```

与函数声明不同，函数表达式**不会**被提升，只能在定义之后使用：

```javascript
// 下面这行会报错，因为函数表达式不会被提升
// console.log(cube(3)); // ReferenceError: cube is not defined

const cube = function(n) {
    return n * n * n;
};

console.log(cube(3)); // 输出：27
```

### 3.2.3 箭头函数（Arrow Function）

箭头函数是ES6引入的简写函数语法，它更简洁且没有自己的`this`绑定：

```javascript
// 基本箭头函数
const add = (a, b) => {
    return a + b;
};

console.log(add(5, 3)); // 输出：8

// 如果函数体只有一条return语句，可以进一步简化
const multiply = (a, b) => a * b;
console.log(multiply(5, 3)); // 输出：15

// 单参数的箭头函数可以省略括号
const square = x => x * x;
console.log(square(5)); // 输出：25

// 无参数的箭头函数需要空括号
const getRandomNumber = () => Math.random();
console.log(getRandomNumber()); // 输出：0到1之间的随机数

// 返回对象字面量时需要用括号包裹
const createUser = (name, age) => ({ name, age });
console.log(createUser('张三', 25)); // 输出：{name: "张三", age: 25}
```

### 3.2.4 立即执行函数表达式（IIFE）

IIFE是定义后立即执行的函数：

```javascript
// 基本IIFE
(function() {
    console.log('这是一个IIFE');
})();

// 带参数的IIFE
(function(name) {
    console.log('你好，' + name);
})('JavaScript');

// 返回值的IIFE
const result = (function(a, b) {
    return a + b;
})(5, 3);

console.log(result); // 输出：8

// 使用箭头函数的IIFE
(() => {
    console.log('这是一个箭头函数IIFE');
})();

// 创建私有作用域
const counter = (function() {
    let count = 0; // 私有变量
    
    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
})();

console.log(counter.increment()); // 输出：1
console.log(counter.increment()); // 输出：2
console.log(counter.getCount());  // 输出：2
console.log(counter.decrement()); // 输出：1
// console.log(count); // ReferenceError: count is not defined
```

### 3.2.5 构造函数（Constructor Function）

使用`new`关键字调用函数可以创建对象：

```javascript
// 构造函数
function Person(name, age) {
    this.name = name;
    this.age = age;
    
    this.greet = function() {
        return '你好，我是' + this.name;
    };
}

// 使用new关键字创建实例
const person1 = new Person('张三', 25);
const person2 = new Person('李四', 30);

console.log(person1.name); // 输出：张三
console.log(person1.greet()); // 输出：你好，我是张三

console.log(person2.age); // 输出：30
console.log(person2.greet()); // 输出：你好，我是李四
```

## 3.3 函数参数

### 3.3.1 参数与实参

在定义函数时，参数列表中的变量称为**形参**（parameter），而调用函数时传递的实际值称为**实参**（argument）：

```javascript
// name是形参
function greet(name) {
    return '你好，' + name;
}

// 'JavaScript'是实参
console.log(greet('JavaScript')); // 输出：你好，JavaScript
```

### 3.3.2 默认参数

ES6允许为函数参数设置默认值：

```javascript
// 基本默认参数
function greet(name = 'Guest') {
    return '你好，' + name;
}

console.log(greet());           // 输出：你好，Guest
console.log(greet('张三'));     // 输出：你好，张三

// 多个默认参数
function createUser(name = 'Unknown', age = 18, country = 'China') {
    return { name, age, country };
}

console.log(createUser());                     // 输出：{name: "Unknown", age: 18, country: "China"}
console.log(createUser('李四'));               // 输出：{name: "李四", age: 18, country: "China"}
console.log(createUser('王五', 25));           // 输出：{name: "王五", age: 25, country: "China"}
console.log(createUser('赵六', 30, 'USA'));    // 输出：{name: "赵六", age: 30, country: "USA"}

// 使用表达式作为默认值
function createRandomArray(size = 5, max = 100) {
    const array = [];
    for (let i = 0; i < size; i++) {
        array.push(Math.floor(Math.random() * max));
    }
    return array;
}

console.log(createRandomArray());              // 输出：长度为5的随机数组
console.log(createRandomArray(3));            // 输出：长度为3的随机数组
console.log(createRandomArray(5, 50));        // 输出：长度为5，最大值为50的随机数组
```

### 3.3.3 剩余参数（Rest Parameters）

剩余参数使用`...`语法，将多个实参收集到一个数组中：

```javascript
// 基本剩余参数
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3));            // 输出：6
console.log(sum(1, 2, 3, 4, 5));      // 输出：15
console.log(sum());                   // 输出：0

// 混合普通参数和剩余参数
function createList(title, ...items) {
    return {
        title,
        items,
        count: items.length
    };
}

console.log(createList('购物清单', '苹果', '香蕉', '橙子'));
// 输出：{title: "购物清单", items: ["苹果", "香蕉", "橙子"], count: 3}

// 剩余参数必须放在最后
// function wrongOrder(...items, title) {} // 语法错误
```

### 3.3.4 参数解构

解构允许将数组或对象作为参数，并直接提取所需的值：

```javascript
// 数组解构
function processCoordinates([x, y]) {
    return { x, y };
}

console.log(processCoordinates([10, 20])); // 输出：{x: 10, y: 20}

// 带默认值的数组解构
function getName([first, last = 'Unknown']) {
    return { first, last };
}

console.log(getName(['张']));        // 输出：{first: "张", last: "Unknown"}
console.log(getName(['张', '三']));   // 输出：{first: "张", last: "三"}

// 对象解构
function introduceUser({ name, age }) {
    return `${name}今年${age}岁`;
}

console.log(introduceUser({ name: '李四', age: 25 })); // 输出：李四今年25岁

// 带默认值的对象解构
function describeUser({ name = 'Unknown', age = 18, city = 'Unknown' } = {}) {
    return `${name}，${age}岁，来自${city}`;
}

console.log(describeUser({ name: '王五', age: 30 }));          // 输出：王五，30岁，来自Unknown
console.log(describeUser({ city: '北京' }));                  // 输出：Unknown，18岁，来自北京
console.log(describeUser());                                  // 输出：Unknown，18岁，来自Unknown

// 重命名解构的参数
function createUserPreferences({ name, theme: colorScheme, notifications: notify = true }) {
    return {
        userName: name,
        colorScheme,
        notificationsEnabled: notify
    };
}

console.log(createUserPreferences({
    name: '赵六',
    theme: 'dark',
    notifications: false
}));
// 输出：{userName: "赵六", colorScheme: "dark", notificationsEnabled: false}
```

## 3.4 返回值

### 3.4.1 return语句

`return`语句用于从函数中返回值，并终止函数的执行：

```javascript
// 基本返回值
function add(a, b) {
    return a + b; // 返回两个数的和
}

const result = add(5, 3);
console.log(result); // 输出：8

// 没有return语句的函数默认返回undefined
function noReturn() {
    console.log('这个函数没有return语句');
}

console.log(noReturn()); // 输出：undefined

// 提前返回
function checkAge(age) {
    if (age < 0) {
        return '年龄不能为负数';
    }
    
    if (age < 18) {
        return '未成年';
    }
    
    return '成年';
}

console.log(checkAge(-5));  // 输出：年龄不能为负数
console.log(checkAge(16));  // 输出：未成年
console.log(checkAge(25));  // 输出：成年
```

### 3.4.2 返回多个值

JavaScript函数只能返回一个值，但可以通过对象或数组返回多个值：

```javascript
// 使用对象返回多个值
function getUserInfo(id) {
    // 模拟从数据库获取用户信息
    if (id === 1) {
        return {
            name: '张三',
            age: 25,
            email: 'zhangsan@example.com',
            isAdmin: false
        };
    }
    
    return null;
}

const user = getUserInfo(1);
if (user) {
    console.log(user.name);      // 输出：张三
    console.log(user.age);       // 输出：25
    console.log(user.email);     // 输出：zhangsan@example.com
    console.log(user.isAdmin);   // 输出：false
}

// 使用数组返回多个值
function getMinMax(numbers) {
    if (numbers.length === 0) {
        return [null, null];
    }
    
    let min = numbers[0];
    let max = numbers[0];
    
    for (let i = 1; i < numbers.length; i++) {
        if (numbers[i] < min) {
            min = numbers[i];
        }
        if (numbers[i] > max) {
            max = numbers[i];
        }
    }
    
    return [min, max];
}

const [minValue, maxValue] = getMinMax([3, 7, 2, 9, 5]);
console.log('最小值:', minValue);  // 输出：最小值: 2
console.log('最大值:', maxValue);  // 输出：最大值: 9

// 使用解构赋值接收返回值
function calculateRectangle(width, height) {
    return {
        width,
        height,
        area: width * height,
        perimeter: 2 * (width + height)
    };
}

const { area, perimeter } = calculateRectangle(5, 3);
console.log('面积:', area);      // 输出：面积: 15
console.log('周长:', perimeter);  // 输出：周长: 16
```

### 3.4.3 递归函数

递归函数是调用自身的函数，通常用于解决可以分解为相同子问题的问题：

```javascript
// 阶乘函数
function factorial(n) {
    // 基本情况
    if (n <= 1) {
        return 1;
    }
    
    // 递归情况
    return n * factorial(n - 1);
}

console.log(factorial(5)); // 输出：120 (5 * 4 * 3 * 2 * 1)

// 斐波那契数列
function fibonacci(n) {
    // 基本情况
    if (n <= 1) {
        return n;
    }
    
    // 递归情况
    return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(6)); // 输出：8 (0, 1, 1, 2, 3, 5, 8)

// 使用尾递归优化的阶乘函数（JavaScript引擎不一定支持优化）
function tailFactorial(n, accumulator = 1) {
    if (n <= 1) {
        return accumulator;
    }
    
    return tailFactorial(n - 1, n * accumulator);
}

console.log(tailFactorial(5)); // 输出：120

// 递归与循环的比较
function factorialIterative(n) {
    let result = 1;
    
    for (let i = 2; i <= n; i++) {
        result *= i;
    }
    
    return result;
}

console.log(factorialIterative(5)); // 输出：120

// 递归遍历DOM树（实际应用示例）
function traverseDOM(node, depth = 0) {
    const indent = '  '.repeat(depth);
    console.log(`${indent}${node.nodeName}: ${node.textContent.trim().substring(0, 20)}`);
    
    // 递归遍历子节点
    for (const child of node.children) {
        traverseDOM(child, depth + 1);
    }
}

// 注意：这需要在浏览器环境中执行
// traverseDOM(document.body);
```

## 3.5 函数作用域

### 3.5.1 全局作用域

全局作用域是在代码任何地方都能访问的作用域：

```javascript
// 全局变量
var globalVar = '我是全局变量';
let globalLet = '我也是全局变量';
const globalConst = '我还是全局变量';

function accessGlobal() {
    console.log(globalVar);  // 可以访问
    console.log(globalLet);  // 可以访问
    console.log(globalConst); // 可以访问
}

accessGlobal();

// 在函数外部也可以访问
console.log(globalVar);  // 可以访问
console.log(globalLet);  // 可以访问
console.log(globalConst); // 可以访问
```

### 3.5.2 函数作用域

函数作用域是指在函数内部声明的变量只能在函数内部访问：

```javascript
function demonstrateFunctionScope() {
    // 函数作用域变量
    var functionVar = '函数作用域变量';
    let functionLet = '块级作用域变量';
    const functionConst = '块级作用域常量';
    
    console.log(functionVar);  // 可以访问
    console.log(functionLet);  // 可以访问
    console.log(functionConst); // 可以访问
}

demonstrateFunctionScope();

// 下面这些访问会报错
// console.log(functionVar);  // ReferenceError: functionVar is not defined
// console.log(functionLet);  // ReferenceError: functionLet is not defined
// console.log(functionConst); // ReferenceError: functionConst is not defined
```

### 3.5.3 块级作用域

块级作用域是在`{}`块内部声明的变量（使用`let`和`const`）只能在该块内访问：

```javascript
function demonstrateBlockScope() {
    if (true) {
        // 块级作用域变量
        let blockLet = '块级作用域变量';
        const blockConst = '块级作用域常量';
        var functionVar = '函数作用域变量';
        
        console.log(blockLet);   // 可以访问
        console.log(blockConst); // 可以访问
        console.log(functionVar); // 可以访问
    }
    
    // 下面这些访问会报错
    // console.log(blockLet);   // ReferenceError: blockLet is not defined
    // console.log(blockConst); // ReferenceError: blockConst is not defined
    
    // 但这个可以访问，因为var有函数作用域
    console.log(functionVar); // 可以访问
}

demonstrateBlockScope();
```

### 3.5.4 词法作用域（静态作用域）

JavaScript使用词法作用域，这意味着函数的作用域在函数定义时确定，而不是在调用时确定：

```javascript
const globalVar = '全局变量';

function outerFunction() {
    const outerVar = '外部函数变量';
    
    function innerFunction() {
        const innerVar = '内部函数变量';
        
        // 内部函数可以访问外部函数和全局变量
        console.log(globalVar); // 可以访问
        console.log(outerVar);  // 可以访问
        console.log(innerVar);  // 可以访问
    }
    
    return innerFunction;
}

const innerFunc = outerFunction();
innerFunc();

// outerFunction无法访问innerFunction的变量
// console.log(innerVar); // ReferenceError: innerVar is not defined
```

### 3.5.5 作用域链

当访问一个变量时，JavaScript引擎会从当前作用域开始向上查找，直到全局作用域：

```javascript
const globalVar = '全局变量';

function level1() {
    const level1Var = '第1级变量';
    
    function level2() {
        const level2Var = '第2级变量';
        
        function level3() {
            const level3Var = '第3级变量';
            
            // 访问各级作用域的变量
            console.log(level3Var); // 第3级变量
            console.log(level2Var); // 第2级变量
            console.log(level1Var); // 第1级变量
            console.log(globalVar); // 全局变量
        }
        
        level3();
        
        // level2无法访问level3的变量
        // console.log(level3Var); // ReferenceError: level3Var is not defined
    }
    
    level2();
}

level1();
```

## 3.6 闭包

### 3.6.1 什么是闭包

闭包是指一个函数能够访问并操作其外部（封闭）函数作用域中的变量，即使在外部函数执行完毕后：

```javascript
function createCounter() {
    let count = 0; // 外部函数的变量
    
    // 返回一个内部函数，形成闭包
    return function() {
        count++; // 访问外部变量
        return count;
    };
}

const counter1 = createCounter();
const counter2 = createCounter();

console.log(counter1()); // 输出：1
console.log(counter1()); // 输出：2
console.log(counter1()); // 输出：3

console.log(counter2()); // 输出：1 (独立的计数器)
console.log(counter2()); // 输出：2

// 即使createCounter已经执行完毕，count变量仍然存在于内存中
// 这是因为内部函数形成了一个闭包，保留了对count的引用
```

### 3.6.2 闭包的应用

#### 1. 私有变量

闭包可以创建私有变量，隐藏实现细节：

```javascript
function createBankAccount(initialBalance) {
    let balance = initialBalance; // 私有变量
    
    return {
        deposit: function(amount) {
            if (amount > 0) {
                balance += amount;
                return balance;
            }
            return '存款金额必须大于0';
        },
        
        withdraw: function(amount) {
            if (amount > 0 && amount <= balance) {
                balance -= amount;
                return balance;
            }
            return '取款金额无效或余额不足';
        },
        
        getBalance: function() {
            return balance;
        }
    };
}

const account = createBankAccount(1000);

console.log(account.getBalance()); // 输出：1000
console.log(account.deposit(500)); // 输出：1500
console.log(account.withdraw(200)); // 输出：1300
console.log(account.getBalance()); // 输出：1300

// 无法直接访问balance变量
// console.log(account.balance); // undefined
```

#### 2. 函数工厂

闭包可以创建特定用途的函数：

```javascript
function createMultiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);
const quadruple = createMultiplier(4);

console.log(double(5));    // 输出：10
console.log(triple(5));    // 输出：15
console.log(quadruple(5)); // 输出：20

function createGreeting(greeting) {
    return function(name) {
        return `${greeting}, ${name}!`;
    };
}

const sayHello = createGreeting('Hello');
const sayHi = createGreeting('Hi');
const sayGoodbye = createGreeting('Goodbye');

console.log(sayHello('Alice'));   // 输出：Hello, Alice!
console.log(sayHi('Bob'));         // 输出：Hi, Bob!
console.log(sayGoodbye('Charlie')); // 输出：Goodbye, Charlie!
```

#### 3. 事件处理

在事件处理中，闭包可以保存状态：

```javascript
// 创建按钮点击计数器
function createClickCounter() {
    let clickCount = 0;
    
    return function() {
        clickCount++;
        console.log(`按钮被点击了 ${clickCount} 次`);
        return clickCount;
    };
}

// 注意：这需要在浏览器环境中执行
// const counter = createClickCounter();
// document.getElementById('myButton').addEventListener('click', counter);

// 循环中的闭包问题
function createButtons() {
    const buttons = [];
    
    for (let i = 0; i < 3; i++) {
        // 使用let解决闭包问题
        buttons.push(function() {
            console.log(`按钮 ${i} 被点击`);
        });
    }
    
    return buttons;
}

const btns = createButtons();
btns[0](); // 输出：按钮 0 被点击
btns[1](); // 输出：按钮 1 被点击
btns[2](); // 输出：按钮 2 被点击

// 如果使用var，会导致所有按钮都输出"按钮 3 被点击"
// 解决方法：使用IIFE创建新的作用域
function createButtonsWithVar() {
    const buttons = [];
    
    for (var i = 0; i < 3; i++) {
        (function(index) {
            buttons.push(function() {
                console.log(`按钮 ${index} 被点击`);
            });
        })(i);
    }
    
    return buttons;
}

const btnsWithVar = createButtonsWithVar();
btnsWithVar[0](); // 输出：按钮 0 被点击
btnsWithVar[1](); // 输出：按钮 1 被点击
btnsWithVar[2](); // 输出：按钮 2 被点击
```

#### 4. 缓存和记忆化

闭包可以用于缓存计算结果：

```javascript
function memoize(fn) {
    const cache = {}; // 缓存对象
    
    return function(...args) {
        const key = JSON.stringify(args);
        
        if (key in cache) {
            console.log('从缓存中获取结果');
            return cache[key];
        }
        
        console.log('计算新结果');
        const result = fn(...args);
        cache[key] = result;
        return result;
    };
}

// 计算斐波那契数列（慢）
function fibonacci(n) {
    if (n <= 1) {
        return n;
    }
    
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// 创建记忆化版本
const memoizedFibonacci = memoize(fibonacci);

console.log(memoizedFibonacci(10)); // 计算新结果
console.log(memoizedFibonacci(10)); // 从缓存中获取结果
console.log(memoizedFibonacci(8));  // 从缓存中获取结果
```

### 3.6.3 闭包的注意事项

#### 1. 内存泄漏

闭包会保留对外部变量的引用，如果不小心使用，可能会导致内存泄漏：

```javascript
function createLargeObject() {
    const largeObject = {
        data: new Array(1000000).fill(0), // 大数组
        name: 'Large Object'
    };
    
    return function() {
        return largeObject.name;
    };
}

const getName = createLargeObject();
console.log(getName()); // 输出：Large Object

// largeObject仍然存在于内存中，因为getName形成闭包
// 解决方法：如果不再需要，设置为null
// getName = null;
```

#### 2. 循环引用

闭包可能导致循环引用，特别是在DOM操作中：

```javascript
// 循环引用示例
function createCircularReference() {
    const element = document.getElementById('myElement');
    const data = {
        element: element
    };
    
    element.onclick = function() {
        console.log(data.name);
    };
    
    // element -> onclick -> data -> element 形成循环引用
    // 在现代浏览器中，垃圾回收器可以处理大多数循环引用
    // 但在旧版浏览器中可能导致内存泄漏
    
    return data;
}
```

## 3.7 函数方法与属性

### 3.7.1 函数的length属性

函数的`length`属性表示函数定义时的形参个数：

```javascript
function noParams() {}
function oneParam(a) {}
function twoParams(a, b) {}
function defaultParams(a = 1, b = 2) {}
function restParams(a, b, ...c) {}

console.log(noParams.length);      // 输出：0
console.log(oneParam.length);      // 输出：1
console.log(twoParams.length);      // 输出：2
console.log(defaultParams.length);  // 输出：0（默认参数不计入）
console.log(restParams.length);     // 输出：2（剩余参数不计入）
```

### 3.7.2 函数的name属性

函数的`name`属性返回函数的名称：

```javascript
function namedFunction() {}
const anonymousFunction = function() {};
const arrowFunction = () => {};

console.log(namedFunction.name);      // 输出：namedFunction
console.log(anonymousFunction.name);  // 输出：anonymousFunction
console.log(arrowFunction.name);      // 输出：arrowFunction

const boundFunction = namedFunction.bind(null);
console.log(boundFunction.name);      // 输出：bound namedFunction
```

### 3.7.3 call、apply和bind方法

这三个方法用于改变函数中`this`的指向：

#### call方法

`call()`方法调用函数，并指定`this`值和参数列表：

```javascript
const person = {
    name: '张三',
    age: 25,
    introduce() {
        return `我是${this.name}，今年${this.age}岁`;
    }
};

const anotherPerson = {
    name: '李四',
    age: 30
};

// 使用call方法，改变this指向
console.log(person.introduce()); // 输出：我是张三，今年25岁
console.log(person.introduce.call(anotherPerson)); // 输出：我是李四，今年30岁

// 传递额外参数
function greet(greeting, punctuation) {
    return `${greeting}，我是${this.name}${punctuation}`;
}

console.log(greet.call(person, '你好', '！')); // 输出：你好，我是张三！
```

#### apply方法

`apply()`方法与`call()`类似，但参数以数组形式传递：

```javascript
// 使用apply方法
console.log(greet.apply(person, ['你好', '！'])); // 输出：你好，我是张三！

// 实际应用：找出数组中的最大值
const numbers = [5, 8, 2, 9, 3];
const max = Math.max.apply(null, numbers);
console.log(max); // 输出：9

// ES6扩展运算符更简单
const maxES6 = Math.max(...numbers);
console.log(maxES6); // 输出：9
```

#### bind方法

`bind()`方法创建一个新函数，`this`值被绑定到指定值：

```javascript
// 创建绑定函数
const boundGreet = greet.bind(person);
console.log(boundGreet('大家好', '。')); // 输出：大家好，我是张三。

// 部分应用（预设部分参数）
const partialGreet = greet.bind(person, '你好');
console.log(partialGreet('！')); // 输出：你好，我是张三！

// 在事件处理中使用bind
const button = {
    label: '点击我',
    handleClick() {
        console.log(`${this.label}被点击了`);
    }
};

// 注意：这需要在浏览器环境中执行
// document.getElementById('myButton').addEventListener('click', button.handleClick.bind(button));
```

### 3.7.4 函数作为参数

高阶函数是接受函数作为参数或返回函数的函数：

```javascript
// 数组方法接受回调函数
const numbers = [1, 2, 3, 4, 5];

// map函数接受一个回调函数
const doubled = numbers.map(function(num) {
    return num * 2;
});
console.log(doubled); // 输出：[2, 4, 6, 8, 10]

// 使用箭头函数
const squared = numbers.map(num => num * num);
console.log(squared); // 输出：[1, 4, 9, 16, 25]

// 自定义高阶函数
function processArray(array, processor) {
    const result = [];
    
    for (let i = 0; i < array.length; i++) {
        result.push(processor(array[i]));
    }
    
    return result;
}

const tripled = processArray(numbers, num => num * 3);
console.log(tripled); // 输出：[3, 6, 9, 12, 15]

// 过滤函数
function filterArray(array, predicate) {
    const result = [];
    
    for (let i = 0; i < array.length; i++) {
        if (predicate(array[i])) {
            result.push(array[i]);
        }
    }
    
    return result;
}

const evenNumbers = filterArray(numbers, num => num % 2 === 0);
console.log(evenNumbers); // 输出：[2, 4]
```

### 3.7.5 函数作为返回值

函数可以返回其他函数：

```javascript
// 创建比较器函数
function createComparator(property) {
    return function(a, b) {
        if (a[property] < b[property]) {
            return -1;
        }
        if (a[property] > b[property]) {
            return 1;
        }
        return 0;
    };
}

const users = [
    { name: '张三', age: 25 },
    { name: '李四', age: 30 },
    { name: '王五', age: 20 }
];

// 按姓名排序
const byName = createComparator('name');
console.log([...users].sort(byName));

// 按年龄排序
const byAge = createComparator('age');
console.log([...users].sort(byAge));

// 创建特定用途的函数
function createMultiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 输出：10
console.log(triple(5)); // 输出：15
```

## 3.8 函数式编程概念

### 3.8.1 纯函数

纯函数是给定相同输入始终返回相同输出，且没有副作用的函数：

```javascript
// 纯函数示例
function add(a, b) {
    return a + b; // 相同输入始终返回相同输出
}

function square(n) {
    return n * n; // 不依赖外部状态，无副作用
}

// 非纯函数示例
let counter = 0;

function increment() {
    counter++; // 修改外部状态
    return counter; // 相同调用可能返回不同值
}

function getNow() {
    return new Date(); // 每次调用返回不同值
}

// 使用纯函数的好处
// 1. 可预测性：相同输入总是产生相同输出
// 2. 可测试性：容易编写测试
// 3. 并行性：可以安全地并行执行
// 4. 可缓存性：可以缓存结果
```

### 3.8.2 高阶函数

高阶函数是接受函数作为参数或返回函数的函数：

```javascript
// 接受函数作为参数的高阶函数
function withLogging(fn) {
    return function(...args) {
        console.log(`调用函数 ${fn.name}，参数: ${args}`);
        const result = fn(...args);
        console.log(`返回结果: ${result}`);
        return result;
    };
}

const add = (a, b) => a + b;
const loggedAdd = withLogging(add);
loggedAdd(5, 3); // 输出调用信息和结果

// 返回函数的高阶函数
function createGreeter(greeting) {
    return function(name) {
        return `${greeting}, ${name}!`;
    };
}

const sayHello = createGreeter('Hello');
console.log(sayHello('World')); // 输出：Hello, World!
```

### 3.8.3 函数组合

函数组合是将多个函数组合成一个新函数的过程：

```javascript
// 基本函数组合
function compose(f, g) {
    return function(x) {
        return f(g(x));
    };
}

// 示例函数
const addOne = x => x + 1;
const multiplyByTwo = x => x * 2;

// 组合函数
const addOneThenMultiply = compose(multiplyByTwo, addOne);
console.log(addOneThenMultiply(5)); // 输出：12 ((5 + 1) * 2)

const multiplyThenAddOne = compose(addOne, multiplyByTwo);
console.log(multiplyThenAddOne(5)); // 输出：11 ((5 * 2) + 1)

// 多函数组合
function pipe(...fns) {
    return function(x) {
        return fns.reduce((acc, fn) => fn(acc), x);
    };
}

const calculate = pipe(
    x => x + 1,    // 加1
    x => x * 2,    // 乘2
    x => x - 3     // 减3
);

console.log(calculate(5)); // 输出：9 (((5 + 1) * 2) - 3)
```

### 3.8.4 柯里化（Currying）

柯里化是将接受多个参数的函数转换为接受单个参数的函数序列：

```javascript
// 普通函数
function add(a, b) {
    return a + b;
}

// 柯里化版本
function curriedAdd(a) {
    return function(b) {
        return a + b;
    };
}

// 使用
console.log(add(5, 3)); // 输出：8
console.log(curriedAdd(5)(3)); // 输出：8

// 通用的柯里化函数
function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn(...args);
        }
        
        return function(...nextArgs) {
            return curried(...args, ...nextArgs);
        };
    };
}

// 柯里化add函数
const curriedAdd = curry(add);
console.log(curriedAdd(5)(3)); // 输出：8
console.log(curriedAdd(5, 3)); // 输出：8
console.log(curriedAdd(5)(3)(2)); // 输出：8（忽略额外参数）

// 柯里化的应用
function log(level, message) {
    console.log(`[${level}] ${message}`);
}

const curriedLog = curry(log);
const errorLog = curriedLog('ERROR');
const infoLog = curriedLog('INFO');

errorLog('Something went wrong'); // 输出：[ERROR] Something went wrong
infoLog('Process completed');     // 输出：[INFO] Process completed
```

## 3.9 最佳实践

### 3.9.1 函数设计原则

1. **单一职责**：每个函数只做一件事
2. **简短精炼**：函数应该尽可能简短，一般不超过20行
3. **有意义的名称**：函数名应该清楚地表达其功能
4. **避免副作用**：尽量编写纯函数
5. **参数最少化**：尽量减少函数参数数量

```javascript
// 好的函数设计
function calculateTax(price, taxRate) {
    return price * taxRate;
}

function calculateTotalPrice(price, taxRate, shipping) {
    const tax = calculateTax(price, taxRate);
    return price + tax + shipping;
}

// 不好的函数设计：函数做了太多事情
function processOrder(items, customer, shippingMethod, taxRate, discount) {
    // 计算总价
    let total = 0;
    for (const item of items) {
        total += item.price * item.quantity;
    }
    
    // 应用折扣
    if (discount > 0) {
        total *= (1 - discount);
    }
    
    // 计算税费
    const tax = total * taxRate;
    total += tax;
    
    // 计算运费
    let shippingCost = 0;
    if (shippingMethod === 'express') {
        shippingCost = 15;
    } else if (shippingMethod === 'standard') {
        shippingCost = 5;
    }
    
    total += shippingCost;
    
    // 保存订单到数据库
    const order = {
        customer,
        items,
        total,
        shippingMethod
    };
    
    // 这里还有数据库操作...
    
    return total;
}

// 重构后的版本：每个函数只做一件事
function calculateSubtotal(items) {
    return items.reduce((total, item) => total + item.price * item.quantity, 0);
}

function applyDiscount(total, discount) {
    return discount > 0 ? total * (1 - discount) : total;
}

function calculateShippingCost(shippingMethod) {
    if (shippingMethod === 'express') return 15;
    if (shippingMethod === 'standard') return 5;
    return 0;
}

function saveOrder(customer, items, total, shippingMethod) {
    const order = { customer, items, total, shippingMethod };
    // 保存到数据库的逻辑
    return order;
}

function processOrder(items, customer, shippingMethod, taxRate, discount) {
    const subtotal = calculateSubtotal(items);
    const discountedTotal = applyDiscount(subtotal, discount);
    const tax = calculateTax(discountedTotal, taxRate);
    const shippingCost = calculateShippingCost(shippingMethod);
    const total = discountedTotal + tax + shippingCost;
    
    return saveOrder(customer, items, total, shippingMethod);
}
```

### 3.9.2 参数设计

1. **使用对象参数**：当函数参数较多时，使用对象参数更清晰
2. **提供默认值**：为可选参数提供合理的默认值
3. **验证参数**：在函数开始时验证参数的有效性

```javascript
// 使用对象参数
function createProduct(productConfig) {
    const {
        name,
        price,
        category = 'General',
        inStock = true,
        description = ''
    } = productConfig;
    
    // 参数验证
    if (!name || typeof name !== 'string') {
        throw new Error('产品名称必须提供且为字符串');
    }
    
    if (typeof price !== 'number' || price <= 0) {
        throw new Error('产品价格必须为正数');
    }
    
    return {
        id: Date.now().toString(),
        name,
        price,
        category,
        inStock,
        description
    };
}

const product = createProduct({
    name: '智能手机',
    price: 999.99,
    description: '高性能智能手机'
});

// 不好的参数设计
function createUser(name, email, age, isActive, isAdmin, lastLogin, createdAt) {
    // 函数实现...
}

// 好的参数设计
function createUser(userConfig) {
    const {
        name,
        email,
        age,
        isActive = true,
        isAdmin = false,
        lastLogin = new Date(),
        createdAt = new Date()
    } = userConfig;
    
    // 参数验证
    if (!name || !email) {
        throw new Error('姓名和邮箱是必需的');
    }
    
    if (typeof email !== 'string' || !email.includes('@')) {
        throw new Error('邮箱格式无效');
    }
    
    return {
        id: generateId(),
        name,
        email,
        age,
        isActive,
        isAdmin,
        lastLogin,
        createdAt
    };
}
```

### 3.9.3 错误处理

1. **使用try-catch**：对可能出错的代码使用异常处理
2. **抛出有意义的错误**：提供清晰的错误信息
3. **优雅降级**：在出错时提供备选方案

```javascript
// 好的错误处理示例
function fetchUserData(userId) {
    try {
        // 验证参数
        if (!userId || typeof userId !== 'string') {
            throw new Error('用户ID必须提供且为字符串');
        }
        
        // 模拟API调用
        const userData = api.getUser(userId);
        
        if (!userData) {
            throw new Error(`用户ID ${userId} 不存在`);
        }
        
        return userData;
    } catch (error) {
        console.error('获取用户数据失败:', error.message);
        
        // 优雅降级：返回默认用户数据
        return {
            id: userId,
            name: '未知用户',
            avatar: '/default-avatar.png'
        };
    }
}

// 函数链式调用中的错误处理
function processWorkflow(data) {
    try {
        const step1Result = step1(data);
        const step2Result = step2(step1Result);
        return step3(step2Result);
    } catch (error) {
        console.error('工作流处理失败:', error);
        
        // 可以选择：
        // 1. 返回默认值
        // 2. 抛出更高级别的错误
        // 3. 记录错误并继续执行
        throw new Error(`工作流处理失败: ${error.message}`);
    }
}
```

### 3.9.4 性能考虑

1. **避免不必要的函数调用**：在循环中避免重复调用函数
2. **使用记忆化**：对计算密集型函数使用缓存
3. **防抖和节流**：对频繁触发的事件使用防抖和节流

```javascript
// 避免在循环中重复调用函数
// 不好的实现
function processItems(items) {
    for (let i = 0; i < items.length; i++) {
        const processed = expensiveOperation(items[i]); // 每次循环都调用
        items[i] = processed;
    }
    return items;
}

// 好的实现：如果可能，批量处理
function processItems(items) {
    // 一次处理所有项目，减少函数调用开销
    return expensiveBatchOperation(items);
}

// 记忆化优化
function memoize(fn) {
    const cache = new Map();
    
    return function(...args) {
        const key = JSON.stringify(args);
        
        if (cache.has(key)) {
            return cache.get(key);
        }
        
        const result = fn(...args);
        cache.set(key, result);
        return result;
    };
}

// 防抖（Debounce）
function debounce(func, delay) {
    let timeoutId;
    
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func(...args), delay);
    };
}

// 节流（Throttle）
function throttle(func, delay) {
    let isThrottled = false;
    
    return function(...args) {
        if (!isThrottled) {
            func(...args);
            isThrottled = true;
            setTimeout(() => isThrottled = false, delay);
        }
    };
}

// 使用防抖优化搜索输入
const debouncedSearch = debounce(query => {
    // 发送搜索请求
    api.search(query);
}, 300);

// 使用节流优化滚动事件
const throttledScrollHandler = throttle(() => {
    // 更新UI
    updateUI();
}, 100);
```

## 3.10 总结

本章详细介绍了JavaScript中的函数与作用域，包括：

1. **函数基础**：函数的概念、重要性和组成部分
2. **函数声明方式**：函数声明、函数表达式、箭头函数、IIFE和构造函数
3. **函数参数**：参数与实参、默认参数、剩余参数和参数解构
4. **返回值**：return语句、返回多个值和递归函数
5. **函数作用域**：全局作用域、函数作用域、块级作用域、词法作用域和作用域链
6. **闭包**：闭包的概念、应用和注意事项
7. **函数方法与属性**：length、name、call、apply、bind和高阶函数
8. **函数式编程**：纯函数、高阶函数、函数组合和柯里化
9. **最佳实践**：函数设计原则、参数设计、错误处理和性能考虑

掌握函数与作用域是JavaScript开发的核心技能，它们为理解后续的面向对象编程、异步编程等高级概念奠定了基础。

## 3.11 练习

1. 创建一个计算器对象，包含加、减、乘、除方法，使用闭包保存当前值。
2. 编写一个函数，接受一个数组和一个回调函数，返回一个新数组，其中每个元素是原数组元素经过回调函数处理后的结果。
3. 实现一个记忆化函数，可以缓存任何函数的计算结果。
4. 创建一个函数工厂，生成特定格式的验证函数（如邮箱验证、电话验证等）。
5. 实现一个防抖函数，用于优化频繁触发的事件处理。

## 3.12 参考资料

- [MDN JavaScript函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions)
- [JavaScript.info - 函数](https://javascript.info/function-basics)
- [You Don't Know JS Yet: Scope & Closures](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/README.md)
- [函数式编程JavaScript](https://github.com/MostlyAdequate/mostly-adequate-guide)