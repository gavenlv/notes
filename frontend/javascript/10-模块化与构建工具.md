# 第10章：模块化与构建工具

## 10.1 JavaScript模块化概述

### 10.1.1 为什么需要模块化

随着前端应用越来越复杂，JavaScript代码量急剧增加，模块化编程变得至关重要。模块化带来的主要好处包括：

1. **代码组织**：将大程序拆分为小的、可管理的模块
2. **命名空间**：避免全局变量污染
3. **依赖管理**：明确模块之间的依赖关系
4. **代码复用**：模块可以在多个地方重复使用
5. **可维护性**：更容易理解和修改特定功能的代码
6. **性能优化**：按需加载模块，减少初始加载时间

### 10.1.2 模块化发展历程

JavaScript模块化经历了以下几个发展阶段：

1. **全局函数模式**：将功能封装在全局函数中
2. **命名空间模式**：使用对象作为命名空间组织代码
3. **IIFE模式**：使用立即执行函数表达式创建作用域
4. **CommonJS**：Node.js采用的模块系统
5. **AMD**：异步模块定义规范，RequireJS是其实现
6. **UMD**：通用模块定义，兼容多种模块系统
7. **ES Modules**：ECMAScript官方模块系统

```javascript
// 1. 全局函数模式（不推荐）
function add(a, b) {
  return a + b;
}

// 2. 命名空间模式
const MyApp = MyApp || {};
MyApp.Math = MyApp.Math || {};
MyApp.Math.add = function(a, b) {
  return a + b;
};

// 3. IIFE模式
const Calculator = (function() {
  // 私有变量和函数
  let history = [];
  
  function addToHistory(operation) {
    history.push(operation);
  }
  
  // 公共API
  return {
    add: function(a, b) {
      const result = a + b;
      addToHistory(`add ${a} + ${b} = ${result}`);
      return result;
    },
    
    getHistory: function() {
      return [...history];
    }
  };
})();

console.log(Calculator.add(5, 3)); // 8
console.log(Calculator.getHistory()); // ["add 5 + 3 = 8"]
```

## 10.2 CommonJS模块

### 10.2.1 CommonJS规范

CommonJS是为服务器端JavaScript（Node.js）设计的模块系统，其核心特点是：

1. 同步加载模块
2. 使用`require`导入模块
3. 使用`module.exports`或`exports`导出模块
4. 每个模块都有自己的作用域
5. 模块可以被多次`require`，但只会在第一次执行时加载

```javascript
// math.js - 定义模块
const PI = 3.14159;

function add(a, b) {
  return a + b;
}

function subtract(a, b) {
  return a - b;
}

function multiply(a, b) {
  return a * b;
}

function divide(a, b) {
  if (b === 0) {
    throw new Error('除数不能为零');
  }
  return a / b;
}

// 导出多个函数
module.exports = {
  add,
  subtract,
  multiply,
  divide
};

// 或者导出单个函数
// module.exports = add;

// main.js - 使用模块
const math = require('./math.js');
const result = math.add(5, 3); // 8
console.log(result);
```

### 10.2.2 CommonJS高级用法

```javascript
// 1. 动态导入模块
function loadMathModule() {
  try {
    const math = require('./math');
    return math;
  } catch (error) {
    console.error('加载math模块失败:', error);
    return null;
  }
}

// 2. 条件导入
if (process.env.NODE_ENV === 'production') {
  module.exports = require('./production-config');
} else {
  module.exports = require('./development-config');
}

// 3. 模块缓存
// math.js
console.log('math模块加载'); // 只会在第一次require时执行

// main.js
const math1 = require('./math'); // 输出 "math模块加载"
const math2 = require('./math'); // 不会输出，因为模块已缓存
console.log(math1 === math2); // true，引用同一个模块对象

// 4. 循环依赖处理
// a.js
const b = require('./b');
console.log('a模块完成');

module.exports = {
  name: 'a模块',
  b
};

// b.js
const a = require('./a');
console.log('b模块完成');

module.exports = {
  name: 'b模块',
  a
};

// main.js
const a = require('./a');
const b = require('./b');
console.log(a.name, b.name);
// 输出: b模块完成, a模块完成, a模块 b模块
```

## 10.3 ES模块（ES Modules）

### 10.3.1 ES模块基础

ES6引入了官方的JavaScript模块系统，它有以下特点：

1. 编译时静态分析，支持Tree Shaking
2. 默认异步加载
3. 严格的模式（自动'use strict'）
4. 顶层`this`指向`undefined`
5. 导出的是引用，不是拷贝

```javascript
// math.js - ES模块定义
export const PI = 3.14159;

// 命名导出
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

// 默认导出
export default function multiply(a, b) {
  return a * b;
}

// 或者先定义后导出
function divide(a, b) {
  if (b === 0) {
    throw new Error('除数不能为零');
  }
  return a / b;
}

export { divide };

// 导出时重命名
export { subtract as sub };

// 重新导出
export * from './constants';
export { default as mathConstants } from './constants';

// main.js - 使用ES模块
import multiply, { add, subtract, PI, sub } from './math.js';

console.log(PI); // 3.14159
console.log(add(5, 3)); // 8
console.log(subtract(5, 3)); // 2
console.log(multiply(5, 3)); // 15

// 导入整个模块
import * as math from './math.js';
console.log(math.divide(10, 2)); // 5

// 动态导入
async function loadMathModule() {
  try {
    const mathModule = await import('./math.js');
    console.log(mathModule.add(5, 3)); // 8
  } catch (error) {
    console.error('加载模块失败:', error);
  }
}
```

### 10.3.2 ES模块高级特性

```javascript
// 1. 导出类
export class Calculator {
  constructor() {
    this.history = [];
  }
  
  add(a, b) {
    const result = a + b;
    this.history.push(`${a} + ${b} = ${result}`);
    return result;
  }
  
  getHistory() {
    return [...this.history];
  }
}

// 2. 导出常量和对象
export const CONFIG = {
  API_URL: 'https://api.example.com',
  TIMEOUT: 5000,
  RETRY_COUNT: 3
};

export const utils = {
  formatDate: (date) => date.toISOString(),
  parseJSON: (str) => {
    try {
      return JSON.parse(str);
    } catch (error) {
      console.error('JSON解析错误:', error);
      return null;
    }
  }
};

// 3. 条件导出
let secretKey;

if (process.env.NODE_ENV === 'production') {
  secretKey = 'prod-secret-key';
} else {
  secretKey = 'dev-secret-key';
}

export { secretKey };

// 4. 模块间共享状态
// state.js
export const state = {
  user: null,
  isLoading: false,
  error: null
};

export const mutations = {
  setUser(user) {
    state.user = user;
  },
  
  setLoading(loading) {
    state.isLoading = loading;
  },
  
  setError(error) {
    state.error = error;
  }
};

// 5. 使用动态导入实现代码分割
class App {
  constructor() {
    this.routes = {};
  }
  
  registerRoute(path, modulePath) {
    this.routes[path] = () => import(modulePath);
  }
  
  async navigate(path) {
    const loadRoute = this.routes[path];
    if (loadRoute) {
      try {
        const module = await loadRoute();
        module.render();
      } catch (error) {
        console.error(`加载路由 ${path} 失败:`, error);
      }
    }
  }
}

const app = new App();
app.registerRoute('/home', './views/home.js');
app.registerRoute('/about', './views/about.js');
app.navigate('/home');
```

## 10.4 模块打包工具

### 10.4.1 Webpack入门

Webpack是一个现代JavaScript应用程序的静态模块打包工具，它将带有依赖关系的模块打包为一个或多个bundle。

```javascript
// webpack.config.js - 基本配置
const path = require('path');

module.exports = {
  // 入口文件
  entry: './src/index.js',
  
  // 输出配置
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
    clean: true, // 清理输出目录
  },
  
  // 模块解析规则
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: ['style-loader', 'css-loader'],
      },
      {
        test: /\.(png|svg|jpg|jpeg|gif)$/i,
        type: 'asset/resource',
      },
      {
        test: /\.m?js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env']
          }
        }
      }
    ],
  },
  
  // 解析配置
  resolve: {
    extensions: ['.js', '.json'],
    alias: {
      '@': path.resolve(__dirname, 'src'),
      'components': path.resolve(__dirname, 'src/components'),
    }
  },
  
  // 插件
  plugins: [
    // 生成HTML文件
    new HtmlWebpackPlugin({
      template: './src/index.html',
    }),
  ],
  
  // 开发服务器
  devServer: {
    static: {
      directory: path.join(__dirname, 'dist'),
    },
    compress: true,
    port: 9000,
    hot: true, // 热模块替换
  },
  
  // 优化配置
  optimization: {
    splitChunks: {
      chunks: 'all',
    },
  },
  
  // 模式
  mode: 'development',
};
```

### 10.4.2 Webpack高级配置

```javascript
// webpack.prod.js - 生产环境配置
const { merge } = require('webpack-merge');
const common = require('./webpack.common.js');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const TerserPlugin = require('terser-webpack-plugin');
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');

module.exports = merge(common, {
  mode: 'production',
  
  output: {
    filename: '[name].[contenthash].js',
    chunkFilename: '[name].[contenthash].chunk.js',
  },
  
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader'],
      },
    ],
  },
  
  plugins: [
    new MiniCssExtractPlugin({
      filename: '[name].[contenthash].css',
      chunkFilename: '[id].[contenthash].css',
    }),
  ],
  
  optimization: {
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true, // 移除console
          },
        },
      }),
      new CssMinimizerPlugin(),
    ],
    
    runtimeChunk: 'single',
    
    splitChunks: {
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
        
        common: {
          name: 'common',
          minChunks: 2,
          chunks: 'all',
          enforce: true,
        },
      },
    },
  },
  
  performance: {
    maxAssetSize: 244 * 1024, // 244KB
    maxEntrypointSize: 244 * 1024,
  },
});
```

## 10.5 现代构建工具

### 10.5.1 Vite

Vite是一个新一代的前端构建工具，它在开发环境下使用ESM（ES Modules）实现快速的热更新，在生产环境下使用Rollup进行打包。

```javascript
// vite.config.js
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import { resolve } from 'path';

export default defineConfig({
  plugins: [vue()],
  
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
    },
  },
  
  css: {
    preprocessorOptions: {
      scss: {
        additionalData: `@import "@/styles/variables.scss";`
      }
    }
  },
  
  server: {
    port: 3000,
    open: true,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ''),
      },
    },
  },
  
  build: {
    target: 'es2015',
    outDir: 'dist',
    assetsDir: 'assets',
    
    rollupOptions: {
      output: {
        manualChunks: {
          'vendor': ['vue', 'vue-router', 'pinia'],
          'ui': ['element-plus'],
        },
      },
    },
    
    chunkSizeWarningLimit: 1500,
  },
  
  optimizeDeps: {
    include: ['vue', 'vue-router', 'pinia', 'axios'],
  },
});
```

### 10.5.2 Rollup

Rollup是一个模块打包工具，专注于生成小而高效的包，特别适合库的打包。

```javascript
// rollup.config.js
import { nodeResolve } from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import babel from '@rollup/plugin-babel';
import { terser } from 'rollup-plugin-terser';
import pkg from './package.json';

const external = Object.keys(pkg.peerDependencies || {});

export default [
  // CommonJS build
  {
    input: 'src/index.js',
    output: {
      file: pkg.main,
      format: 'cjs',
      sourcemap: true,
    },
    external,
    plugins: [
      nodeResolve(),
      commonjs(),
      babel({
        babelHelpers: 'bundled',
        exclude: 'node_modules/**',
      }),
    ],
  },
  
  // ES module build
  {
    input: 'src/index.js',
    output: {
      file: pkg.module,
      format: 'es',
      sourcemap: true,
    },
    external,
    plugins: [
      nodeResolve(),
      commonjs(),
      babel({
        babelHelpers: 'bundled',
        exclude: 'node_modules/**',
      }),
    ],
  },
  
  // UMD build (minified)
  {
    input: 'src/index.js',
    output: {
      file: pkg.browser,
      format: 'umd',
      name: 'MyLibrary',
      sourcemap: true,
      globals: {
        'react': 'React',
        'react-dom': 'ReactDOM',
      },
    },
    external,
    plugins: [
      nodeResolve(),
      commonjs(),
      babel({
        babelHelpers: 'bundled',
        exclude: 'node_modules/**',
      }),
      terser(),
    ],
  },
];
```

## 10.6 代码分割与懒加载

### 10.6.1 动态导入实现代码分割

代码分割是一种优化技术，它允许我们将代码分割成多个块（bundle），然后按需加载这些块。

```javascript
// 1. 路由级别的代码分割
import { createRouter, createWebHistory } from 'vue-router';

const routes = [
  {
    path: '/',
    name: 'Home',
    component: () => import(/* webpackChunkName: "home" */ './views/Home.vue')
  },
  {
    path: '/about',
    name: 'About',
    component: () => import(/* webpackChunkName: "about" */ './views/About.vue')
  },
  {
    path: '/admin',
    name: 'Admin',
    component: () => import(/* webpackChunkName: "admin" */ './views/Admin.vue'),
    children: [
      {
        path: 'dashboard',
        component: () => import(/* webpackChunkName: "admin-dashboard" */ './views/admin/Dashboard.vue')
      },
      {
        path: 'users',
        component: () => import(/* webpackChunkName: "admin-users" */ './views/admin/Users.vue')
      }
    ]
  }
];

const router = createRouter({
  history: createWebHistory(),
  routes
});

// 2. 条件性加载模块
class FeatureManager {
  constructor() {
    this.features = {};
  }
  
  async loadFeature(featureName) {
    if (this.features[featureName]) {
      return this.features[featureName];
    }
    
    try {
      // 根据特性名称动态加载模块
      const module = await import(`./features/${featureName}.js`);
      this.features[featureName] = module.default;
      return this.features[featureName];
    } catch (error) {
      console.error(`加载特性 ${featureName} 失败:`, error);
      throw error;
    }
  }
  
  async useFeature(featureName, ...args) {
    const feature = await this.loadFeature(featureName);
    return feature(...args);
  }
}

// 使用示例
const featureManager = new FeatureManager();

// 根据用户权限加载特性
if (user.hasPermission('analytics')) {
  featureManager.useFeature('analytics', userId)
    .then(data => console.log('分析数据:', data))
    .catch(error => console.error('加载分析模块失败:', error));
}

// 3. 预加载模块
function preloadResources() {
  // 预加载关键资源
  const criticalModules = [
    import(/* webpackPrefetch: true */ './modules/checkout.js'),
    import(/* webpackPrefetch: true */ './modules/payment.js'),
    import(/* webpackPrefetch: true */ './modules/receipt.js')
  ];
  
  Promise.all(criticalModules)
    .then(() => console.log('关键模块预加载完成'))
    .catch(error => console.error('预加载失败:', error));
}

// 用户可能在后续步骤中需要这些功能
window.addEventListener('load', preloadResources);
```

### 10.6.2 Webpack代码分割配置

```javascript
// webpack.config.js - 代码分割配置
module.exports = {
  entry: {
    main: './src/index.js',
    vendor: ['react', 'react-dom', 'axios']
  },
  
  output: {
    filename: '[name].[contenthash].js',
    chunkFilename: '[name].[contenthash].chunk.js',
    path: path.resolve(__dirname, 'dist'),
    publicPath: '/'
  },
  
  optimization: {
    splitChunks: {
      chunks: 'all',
      minSize: 30000, // 小于此大小的模块不分割
      maxSize: 0, // 无最大大小限制
      minChunks: 1, // 至少被引用的次数
      maxAsyncRequests: 5, // 按需加载时的最大请求数
      maxInitialRequests: 3, // 入口点的最大请求数
      automaticNameDelimiter: '~',
      
      cacheGroups: {
        // 第三方库
        vendors: {
          test: /[\\/]node_modules[\\/]/,
          priority: -10,
          name: 'vendors'
        },
        
        // 公共模块
        common: {
          name: 'common',
          minChunks: 2, // 至少被2个入口引用
          priority: -20,
          reuseExistingChunk: true
        },
        
        // React相关
        react: {
          test: /[\\/]node_modules[\\/](react|react-dom)[\\/]/,
          name: 'react',
          priority: 20
        },
        
        // 工具库
        utils: {
          test: /[\\/]node_modules[\\/](lodash|axios|dayjs)[\\/]/,
          name: 'utils',
          priority: 20
        }
      }
    },
    
    // 运行时代码单独打包
    runtimeChunk: {
      name: 'runtime'
    }
  },
  
  plugins: [
    // 生成资源清单
    new webpack.ManifestPlugin({
      fileName: 'asset-manifest.json',
      publicPath: '/'
    })
  ]
};
```

## 10.7 模块联邦（Module Federation）

### 10.7.1 Module Federation基础

Module Federation是Webpack 5引入的一项功能，它允许多个独立的JavaScript应用在运行时共享代码和依赖。

```javascript
// webpack.config.js - 应用A配置（暴露模块）
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  mode: 'development',
  devServer: { port: 3001 },
  
  plugins: [
    new ModuleFederationPlugin({
      name: 'appA',
      filename: 'remoteEntry.js',
      
      // 暴露模块供其他应用使用
      exposes: {
        './Button': './src/components/Button',
        './Header': './src/components/Header',
        './utils': './src/utils/index'
      },
      
      // 共享依赖
      shared: {
        'react': { 
          singleton: true, 
          requiredVersion: deps.react,
          eager: true
        },
        'react-dom': { 
          singleton: true, 
          requiredVersion: deps['react-dom'],
          eager: true
        }
      }
    })
  ]
};

// webpack.config.js - 应用B配置（消费模块）
module.exports = {
  mode: 'development',
  devServer: { port: 3002 },
  
  plugins: [
    new ModuleFederationPlugin({
      name: 'appB',
      filename: 'remoteEntry.js',
      
      // 引用其他应用的模块
      remotes: {
        appA: 'appA@http://localhost:3001/remoteEntry.js'
      },
      
      // 共享依赖
      shared: {
        'react': { 
          singleton: true, 
          requiredVersion: deps.react,
          eager: true
        },
        'react-dom': { 
          singleton: true, 
          requiredVersion: deps['react-dom'],
          eager: true
        }
      }
    })
  ]
};

// 在应用B中使用应用A的模块
import React from 'react';
const Button = React.lazy(() => import('appA/Button'));
const { formatDate } = React.lazy(() => import('appA/utils'));

function App() {
  return (
    <div>
      <h1>应用B</h1>
      <React.Suspense fallback="加载中...">
        <Button>来自应用A的按钮</Button>
      </React.Suspense>
    </div>
  );
}
```

### 10.7.2 动态远程容器

```javascript
// 动态加载远程应用
class RemoteLoader {
  constructor() {
    this.loadedScripts = {};
    this.loadedModules = {};
  }
  
  async loadRemote(remoteName, remoteUrl, module) {
    // 检查是否已经加载过远程容器
    if (!this.loadedScripts[remoteName]) {
      await this.loadScript(`${remoteUrl}`);
      this.loadedScripts[remoteName] = true;
    }
    
    // 获取远程容器
    const container = window[remoteName];
    
    // 初始化容器（共享作用域）
    await container.init(__webpack_share_scopes__.default);
    
    // 获取模块
    const factory = await container.get(module);
    const Module = factory();
    
    // 缓存模块
    this.loadedModules[`${remoteName}/${module}`] = Module;
    
    return Module;
  }
  
  loadScript(url) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.type = 'text/javascript';
      script.async = true;
      
      script.onload = resolve;
      script.onerror = reject;
      
      document.head.appendChild(script);
    });
  }
}

// 使用示例
const remoteLoader = new RemoteLoader();

// 动态加载远程组件
async function loadRemoteComponent(remoteName, remoteUrl, componentPath) {
  try {
    const Component = await remoteLoader.loadRemote(remoteName, remoteUrl, componentPath);
    return Component;
  } catch (error) {
    console.error(`加载远程组件失败: ${remoteName}/${componentPath}`, error);
    return null;
  }
}

// 在React中使用
function RemoteComponentWrapper({ remoteName, remoteUrl, componentPath, ...props }) {
  const [Component, setComponent] = React.useState(null);
  
  React.useEffect(() => {
    loadRemoteComponent(remoteName, remoteUrl, componentPath)
      .then(setComponent);
  }, [remoteName, remoteUrl, componentPath]);
  
  if (!Component) {
    return <div>加载中...</div>;
  }
  
  return <Component {...props} />;
}

// 使用
<RemoteComponentWrapper 
  remoteName="appA" 
  remoteUrl="http://localhost:3001/remoteEntry.js" 
  componentPath="./Button" 
/>
```

## 10.8 性能优化与最佳实践

### 10.8.1 模块加载优化

```javascript
// 1. 预加载关键模块
const preloadCriticalModules = () => {
  // 预加载关键路径上的模块
  const criticalModules = [
    import(/* webpackPrefetch: true */ './components/CriticalComponent1'),
    import(/* webpackPrefetch: true */ './components/CriticalComponent2'),
    import(/* webpackPrefetch: true */ './utils/criticalHelpers')
  ];
  
  return Promise.all(criticalModules);
};

// 2. 按需加载非关键模块
class LazyModuleLoader {
  constructor() {
    this.cache = new Map();
  }
  
  async get(modulePath, preload = false) {
    if (this.cache.has(modulePath)) {
      return this.cache.get(modulePath);
    }
    
    const importPromise = import(modulePath);
    
    if (preload) {
      // 预加载但不等待
      importPromise.then(module => {
        this.cache.set(modulePath, module);
      });
      return null;
    } else {
      const module = await importPromise;
      this.cache.set(modulePath, module);
      return module;
    }
  }
  
  // 预加载模块
  preload(modulePath) {
    if (!this.cache.has(modulePath)) {
      this.get(modulePath, true);
    }
  }
  
  // 批量预加载
  preloadAll(modulePaths) {
    modulePaths.forEach(path => this.preload(path));
  }
}

// 3. 智能预加载
class SmartPreloader {
  constructor() {
    this.observerOptions = {
      root: null,
      rootMargin: '200px', // 提前200px预加载
      threshold: 0.01
    };
    
    this.observer = new IntersectionObserver(
      this.handleIntersection.bind(this),
      this.observerOptions
    );
  }
  
  observe(element, modulePath) {
    this.observer.observe(element);
    
    // 存储元素对应的模块路径
    if (!element.dataset.module) {
      element.dataset.module = modulePath;
    }
  }
  
  async handleIntersection(entries) {
    for (const entry of entries) {
      if (entry.isIntersecting) {
        const element = entry.target;
        const modulePath = element.dataset.module;
        
        if (modulePath) {
          await import(modulePath);
          this.observer.unobserve(element);
        }
      }
    }
  }
}

// 使用示例
const preloader = new SmartPreloader();

// 当用户可能点击某个按钮时预加载相关模块
const checkoutButton = document.getElementById('checkout');
if (checkoutButton) {
  preloader.observe(checkoutButton, './modules/checkout.js');
}
```

### 10.8.2 构建优化策略

```javascript
// webpack.config.js - 性能优化配置
module.exports = {
  optimization: {
    // 最小化输出
    minimize: true,
    
    // 代码分割
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        // 将node_modules中的代码分离到vendor chunk
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
      },
    },
    
    // 运行时代码单独打包
    runtimeChunk: 'single',
    
    // 压缩选项
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true,
            drop_debugger: true,
          },
          mangle: true,
        },
        extractComments: false,
      }),
    ],
  },
  
  // 解析优化
  resolve: {
    modules: [path.resolve(__dirname, 'node_modules')],
    extensions: ['.js', '.json'],
    mainFields: ['module', 'main'],
    
    // 路径别名
    alias: {
      '@': path.resolve(__dirname, 'src'),
      'react': 'preact/compat',
      'react-dom': 'preact/compat',
    },
  },
  
  // 模块匹配
  module: {
    noParse: [/jquery/], // 跳过解析大型库
    
    rules: [
      {
        test: /\.js$/,
        include: path.resolve(__dirname, 'src'),
        use: {
          loader: 'babel-loader',
          options: {
            cacheDirectory: true, // 启用缓存
            presets: [
              ['@babel/preset-env', {
                useBuiltIns: 'usage',
                corejs: 3,
              }]
            ]
          }
        }
      },
      
      // 图片优化
      {
        test: /\.(png|jpe?g|gif|webp)$/i,
        type: 'asset',
        parser: {
          dataUrlCondition: {
            maxSize: 8 * 1024, // 小于8KB的图片转为base64
          },
        },
        generator: {
          filename: 'images/[name].[hash:8][ext]',
        },
      },
    ],
  },
  
  // 性能预算
  performance: {
    maxAssetSize: 250 * 1024, // 250KB
    maxEntrypointSize: 250 * 1024,
    assetFilter: (assetFilename) => {
      return !assetFilename.endsWith('.map');
    },
  },
  
  // 统计信息
  stats: {
    children: false,
    modules: false,
    chunks: false,
    chunkModules: false,
  },
};
```

### 10.8.3 模块化最佳实践

1. **设计清晰的API**：设计易于理解、一致性和可预测的模块接口
2. **保持小而专注**：每个模块应该只做一件事，并且做好
3. **避免循环依赖**：循环依赖会导致模块加载问题
4. **合理使用树摇**：确保代码能够被正确地树摇优化
5. **合理分割代码**：基于功能或路由而不是任意分割代码

```javascript
// 1. 清晰的API设计
// ✅ 好的做法 - 明确的输入输出
export function formatDate(date, format = 'YYYY-MM-DD') {
  // 格式化逻辑
  return formattedDate;
}

// ❌ 避免的做法 - 隐式依赖全局状态
export function formatDate() {
  // 依赖全局状态，不明确
  return formattedDate;
}

// 2. 保持小而专注
// ✅ 好的做法 - 单一职责
export function calculateTax(amount, rate) {
  return amount * (rate / 100);
}

export function calculateDiscount(price, discount) {
  return price - discount;
}

// ❌ 避免的做法 - 职责混乱
export function processPayment(order, user, taxRate, discountCode) {
  // 计算税
  // 计算折扣
  // 处理支付
  // 更新库存
  // 发送邮件
  // 做了太多事情
}

// 3. 避免循环依赖
// utils.js
export { formatDate } from './dateUtils';
export { calculateDistance } from './geoUtils';
export { validateEmail } from './validationUtils';

// ❌ 避免的做法
// utils.js 导入了 main.js 中的函数
// main.js 也导入了 utils.js 中的函数
// 形成循环依赖

// 4. 支持树摇的导出方式
// ✅ 好的做法 - 命名导出
export const API_BASE_URL = 'https://api.example.com';
export function fetchData(endpoint) { /* ... */ }
export function postData(endpoint, data) { /* ... */ }

// ❌ 避免的做法 - 可能影响树摇
export default {
  API_BASE_URL: 'https://api.example.com',
  fetchData,
  postData
};

// 5. 合理的代码分割
// ✅ 好的做法 - 基于功能分割
const Home = () => import('./views/Home');
const Dashboard = () => import('./views/Dashboard');
const Profile = () => import('./views/Profile');

// ❌ 避免的做法 - 随意分割
const Component1 = () => import('./components/Component1');
const Component2 = () => import('./components/Component2');
const Component3 = () => import('./components/Component3');
// 这些组件可能经常一起使用，不应该分开
```

## 10.9 总结与练习

### 10.9.1 本章要点

1. **模块化概述**：了解JavaScript模块化的发展历程和重要性
2. **CommonJS模块**：掌握Node.js中使用的CommonJS模块系统
3. **ES模块**：学习官方的JavaScript模块系统
4. **模块打包工具**：了解Webpack等打包工具的基本使用和高级配置
5. **现代构建工具**：掌握Vite、Rollup等新一代构建工具的特点和使用
6. **代码分割与懒加载**：理解代码分割的原理和实现方法
7. **模块联邦**：了解Webpack 5中的Module Federation功能
8. **性能优化与最佳实践**：掌握模块化开发的性能优化策略和最佳实践

### 10.9.2 实践练习

1. **练习1：创建多模块项目**
   - 创建一个包含多个模块的项目，使用ES模块组织代码
   - 实现模块间的依赖关系，包括命名导出和默认导出
   - 使用Webpack配置项目，实现代码分割和打包优化

2. **练习2：代码分割实现**
   - 实现一个简单的单页应用，使用动态导入实现路由级别的代码分割
   - 添加条件加载功能，根据用户角色加载不同模块
   - 实现预加载机制，优化用户体验

3. **练习3：模块联邦应用**
   - 创建两个独立的应用，使用Module Federation实现模块共享
   - 在一个应用中暴露组件，在另一个应用中消费这些组件
   - 实现动态加载远程容器的功能

4. **练习4：性能优化**
   - 分析现有项目的打包配置，识别性能瓶颈
   - 优化Webpack配置，实现代码压缩、Tree Shaking等优化
   - 设计并实现预加载策略，提高应用加载速度

通过本章的学习，你应该已经掌握了JavaScript模块化开发的核心知识和现代构建工具的使用方法。模块化是现代前端开发的基础，掌握这些技能将帮助你更好地组织和管理复杂的前端应用。在下一章中，我们将探讨JavaScript的实战项目，通过实际项目来巩固和应用所学知识。