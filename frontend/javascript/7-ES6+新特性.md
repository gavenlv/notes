# 第7章：ES6+新特性

## 1. ES6概述

### 1.1 什么是ES6

ES6（ECMAScript 2015）是JavaScript语言的重大更新，引入了许多新的语法特性和API。ES6及其后续版本（ES2016、ES2017等）统称为ES6+，这些新特性极大地提升了JavaScript的开发体验和代码质量。

### 1.2 ES6的主要改进

1. **更好的变量声明方式**：let和const
2. **简化的函数写法**：箭头函数
3. **便捷的数据结构**：解构赋值、扩展运算符
4. **新的数据类型**：Symbol、Set、Map
5. **面向对象编程增强**：类、继承
6. **模块系统**：import/export
7. **异步编程改进**：Promise、async/await
8. **更强大的字符串处理**：模板字符串
9. **更简洁的对象操作**：对象简写、计算属性名
10. **迭代器和生成器**：for...of、yield

### 1.3 浏览器兼容性

虽然现代浏览器已经支持大部分ES6+特性，但在生产环境中，我们仍然需要考虑兼容性问题。可以使用以下工具解决兼容性问题：

- **Babel**：将ES6+代码转换为ES5
- **Polyfill**：为不支持新特性的浏览器提供实现
- **TypeScript**：提供ES6+语法支持并转换为JavaScript

## 2. 变量声明与作用域

### 2.1 let和const

ES6引入了`let`和`const`关键字，用于声明变量，解决了`var`存在的一些问题。

```javascript
// 使用var存在的问题
function varIssues() {
    if (true) {
        var x = 10;
    }
    console.log(x); // 10，var没有块级作用域
    
    for (var i = 0; i < 3; i++) {
        setTimeout(function() {
            console.log(i); // 3 3 3，因为i是同一个变量
        }, 100);
    }
}

// 使用let解决作用域问题
function letSolutions() {
    if (true) {
        let x = 10;
    }
    // console.log(x); // ReferenceError，let有块级作用域
    
    for (let i = 0; i < 3; i++) {
        setTimeout(function() {
            console.log(i); // 0 1 2，每次循环都有新的i
        }, 100);
    }
}

// const声明常量
const PI = 3.14159;
// PI = 3.14; // TypeError，常量不能重新赋值

// 对象和数组的const声明
const arr = [1, 2, 3];
arr.push(4); // 可以，修改数组内容
console.log(arr); // [1, 2, 3, 4]
// arr = [5, 6]; // TypeError，不能重新赋值
```

### 2.2 作用域和暂时性死区

```javascript
// 暂时性死区（TDZ）
function tdzExample() {
    // console.log(a); // ReferenceError: a is not defined
    // let a = 10; // 在声明前访问a会报错
    
    // 先使用后声明会报错
    console.log(b); // undefined（变量提升）
    var b = 20;
    
    // console.log(c); // ReferenceError（暂时性死区）
    let c = 30;
}

// 块级作用域
function blockScope() {
    let x = 10;
    
    if (true) {
        let y = 20;
        console.log(x); // 10，可以访问外层作用域
        console.log(y); // 20
    }
    
    // console.log(y); // ReferenceError，无法访问内层作用域
}

// 循环中的作用域
function loopScope() {
    const buttons = document.querySelectorAll('button');
    
    for (let i = 0; i < buttons.length; i++) {
        buttons[i].addEventListener('click', function() {
            console.log(`按钮 ${i + 1} 被点击`); // 每个按钮都有正确的i值
        });
    }
}
```

## 3. 箭头函数

### 3.1 基本语法

箭头函数提供了一种更简洁的函数写法：

```javascript
// 传统函数
function add(a, b) {
    return a + b;
}

// 箭头函数
const addArrow = (a, b) => {
    return a + b;
};

// 简写形式（单个表达式）
const addSimple = (a, b) => a + b;

// 单个参数可以省略括号
const double = x => x * 2;

// 无参数需要括号
const getRandom = () => Math.random();
```

### 3.2 箭头函数的特点

```javascript
// 没有自己的this
const obj = {
    name: "对象",
    regularFunction: function() {
        console.log(this.name); // "对象"
        
        setTimeout(function() {
            console.log(this.name); // undefined（window），因为this改变了
        }, 100);
        
        setTimeout(() => {
            console.log(this.name); // "对象"，继承了外层的this
        }, 200);
    }
};

obj.regularFunction();

// 没有自己的arguments对象
function regularFunc() {
    console.log(arguments); // Arguments对象
}

const arrowFunc = () => {
    // console.log(arguments); // ReferenceError: arguments is not defined
    // 可以使用rest参数代替
};

// 不能作为构造函数
const Person = (name) => {
    this.name = name;
};

// const john = new Person("John"); // TypeError: Person is not a constructor

// 没有prototype属性
// console.log(Person.prototype); // undefined
```

### 3.3 实际应用

```javascript
// 数组方法中的使用
const numbers = [1, 2, 3, 4, 5];

// 使用箭头函数简化代码
const doubled = numbers.map(x => x * 2);
const evens = numbers.filter(x => x % 2 === 0);
const sum = numbers.reduce((acc, x) => acc + x, 0);

// 对象方法（需要注意this）
const calculator = {
    value: 0,
    // 不推荐：箭头函数作为对象方法
    addArrow: (x) => {
        // this不是calculator对象
        // this.value += x; // undefined
        // return this.value;
    },
    
    // 推荐：使用传统方法或简写方法
    add(x) {
        this.value += x;
        return this.value;
    }
};

// 嵌套函数中的使用
function Timer() {
    this.seconds = 0;
    
    setInterval(() => {
        this.seconds++;
        console.log(`计时: ${this.seconds} 秒`);
    }, 1000);
}

const timer = new Timer();
```

## 4. 模板字符串

### 4.1 基本语法

```javascript
// 基本模板字符串
const name = "Alice";
const greeting = `Hello, ${name}!`;
console.log(greeting); // "Hello, Alice!"

// 多行字符串
const multiline = `
    第一行
    第二行
    第三行
`;
console.log(multiline);

// 表达式计算
const a = 10;
const b = 20;
const result = `${a} + ${b} = ${a + b}`;
console.log(result); // "10 + 20 = 30"

// 函数调用
const upper = str => str.toUpperCase();
const message = `${upper("hello")} world!`;
console.log(message); // "HELLO world!"

// 三元表达式
const age = 18;
const status = `${age >= 18 ? "成年" : "未成年"}`;
console.log(status); // "成年"
```

### 4.2 高级用法

```javascript
// 嵌套模板字符串
const user = {
    name: "Bob",
    age: 30,
    address: {
        city: "北京",
        country: "中国"
    }
};

const userInfo = `
    用户信息:
    姓名: ${user.name}
    年龄: ${user.age}
    地址: ${user.address.city}, ${user.address.country}
`;
console.log(userInfo);

// 条件渲染
function formatProduct(product) {
    return `
        <div class="product">
            <h3>${product.name}</h3>
            <p>价格: ¥${product.price}</p>
            ${product.discount ? 
                `<p class="discount">折扣: ${product.discount}%</p>` : 
                ''}
            ${product.inStock ? 
                '<button class="buy">购买</button>' : 
                '<button disabled>缺货</button>'}
        </div>
    `;
}

// 标签模板字符串
function highlight(strings, ...values) {
    return strings.reduce((result, str, i) => {
        const value = i < values.length ? values[i] : '';
        return `${result}${str}<mark>${value}</mark>`;
    }, '');
}

const highlighted = highlight`用户: ${user.name}, 年龄: ${user.age}`;
console.log(highlighted);
// 用户: <mark>Bob</mark>, 年龄: <mark>30</mark>
```

## 5. 解构赋值

### 5.1 数组解构

```javascript
// 基本数组解构
const colors = ["red", "green", "blue"];
const [firstColor, secondColor, thirdColor] = colors;
console.log(firstColor); // "red"
console.log(secondColor); // "green"
console.log(thirdColor); // "blue"

// 忽略某些元素
const [, , third] = colors;
console.log(third); // "blue"

// 使用默认值
const [a, b, c, d = "yellow"] = colors;
console.log(d); // "yellow"

// 剩余元素
const [primary, ...rest] = colors;
console.log(primary); // "red"
console.log(rest); // ["green", "blue"]

// 交换变量
let x = 10, y = 20;
[x, y] = [y, x];
console.log(x, y); // 20, 10

// 函数返回值解构
function getCoordinates() {
    return [10, 20];
}
const [xCoord, yCoord] = getCoordinates();

// 解构嵌套数组
const matrix = [[1, 2], [3, 4]];
const [[a1, b1], [a2, b2]] = matrix;
```

### 5.2 对象解构

```javascript
// 基本对象解构
const person = {
    name: "Alice",
    age: 30,
    job: "developer"
};

const { name, age } = person;
console.log(name); // "Alice"
console.log(age); // 30

// 重命名变量
const { name: fullName, age: years } = person;
console.log(fullName); // "Alice"
console.log(years); // 30

// 默认值
const { name, salary = 50000 } = person;
console.log(salary); // 50000

// 嵌套对象解构
const employee = {
    id: 123,
    personal: {
        name: "Bob",
        address: {
            city: "北京",
            street: "中关村"
        }
    }
};

const { 
    personal: { 
        name: empName, 
        address: { 
            city, 
            street 
        } 
    } 
} = employee;

console.log(city); // "北京"
console.log(street); // "中关村"

// 解构函数参数
function displayUser({ name, age, location = "未知" }) {
    console.log(`${name}, ${age}岁, 来自${location}`);
}

displayUser({ name: "Carol", age: 25, location: "上海" });
displayUser({ name: "David", age: 30 });

// 函数返回对象解构
function getUserInfo() {
    return {
        id: 1,
        name: "Eve",
        email: "eve@example.com"
    };
}

const { id, name, email } = getUserInfo();
```

## 6. 扩展运算符和剩余参数

### 6.1 扩展运算符

```javascript
// 数组扩展
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2];
console.log(combined); // [1, 2, 3, 4, 5, 6]

// 数组复制
const original = [1, 2, 3];
const copy = [...original];
console.log(copy); // [1, 2, 3]

// 在数组中间插入元素
const numbers = [1, 4, 5];
const withTwoThree = [1, 2, 3, ...numbers.slice(1)];
console.log(withTwoThree); // [1, 2, 3, 4, 5]

// 对象扩展
const user = {
    name: "Alice",
    age: 30
};

const updatedUser = {
    ...user,
    email: "alice@example.com"
};
console.log(updatedUser);
// { name: "Alice", age: 30, email: "alice@example.com" }

// 对象覆盖
const overridden = {
    ...user,
    age: 31  // 覆盖原来的age
};
console.log(overridden);
// { name: "Alice", age: 31 }

// 函数参数扩展
function add(...numbers) {
    return numbers.reduce((sum, num) => sum + num, 0);
}

console.log(add(1, 2, 3)); // 6
console.log(add(1, 2, 3, 4, 5)); // 15

// 结合使用
const parts = ['shoulders', 'knees'];
const lyrics = ['head', ...parts, 'and', 'toes'];
console.log(lyrics); // ["head", "shoulders", "knees", "and", "toes"]
```

### 6.2 剩余参数

```javascript
// 剩余参数收集多余的参数
function sum(first, second, ...rest) {
    console.log(`第一个参数: ${first}`);
    console.log(`第二个参数: ${second}`);
    console.log(`剩余参数: ${rest}`);
    return first + second + rest.reduce((acc, val) => acc + val, 0);
}

console.log(sum(1, 2, 3, 4, 5));
// 第一个参数: 1
// 第二个参数: 2
// 剩余参数: 3,4,5
// 15

// 解构中的剩余参数
const [first, ...rest] = [1, 2, 3, 4, 5];
console.log(first); // 1
console.log(rest); // [2, 3, 4, 5]

const { a, b, ...others } = { a: 1, b: 2, c: 3, d: 4 };
console.log(others); // { c: 3, d: 4 }

// 剩余参数与arguments的区别
function funcWithRest(...args) {
    console.log(args); // 真正的数组，可以使用数组方法
    console.log(arguments); // 类数组对象
}

funcWithRest(1, 2, 3);
```

## 7. 对象字面量增强

### 7.1 属性简写

```javascript
// 属性值简写
const name = "Alice";
const age = 30;

// ES5写法
const person1 = {
    name: name,
    age: age,
    greet: function() {
        return `Hello, I'm ${this.name}`;
    }
};

// ES6简写
const person2 = {
    name,
    age,
    greet() {
        return `Hello, I'm ${this.name}`;
    }
};

console.log(person2.greet()); // "Hello, I'm Alice"

// 函数作为方法
const calculator = {
    value: 0,
    
    // 简写方法
    add(x) {
        this.value += x;
        return this;
    },
    
    multiply(x) {
        this.value *= x;
        return this;
    },
    
    getResult() {
        return this.value;
    }
};

console.log(calculator.add(5).multiply(2).getResult()); // 10
```

### 7.2 计算属性名

```javascript
// 动态属性名
const propName = "dynamicProp";
const value = "dynamic value";

const obj = {
    [propName]: value,
    ["computed" + "Prop"]: "computed value"
};

console.log(obj.dynamicProp); // "dynamic value"
console.log(obj.computedProp); // "computed value"

// 在类中使用计算属性名
class MyClass {
    [Symbol.iterator]() {
        // 返回迭代器
        return {
            next() {
                return { value: 42, done: false };
            }
        };
    }
}

// 实际应用：基于条件创建属性
function createObject(includeExtra) {
    const base = {
        id: 1,
        name: "基础对象"
    };
    
    return {
        ...base,
        ...(includeExtra ? { extra: "额外属性" } : {})
    };
}

const obj1 = createObject(true);
const obj2 = createObject(false);

console.log(obj1); // { id: 1, name: "基础对象", extra: "额外属性" }
console.log(obj2); // { id: 1, name: "基础对象" }
```

### 7.3 方法定义和super

```javascript
// 对象方法定义
const person = {
    name: "Alice",
    
    // 传统方法
    greet: function() {
        return `Hello, I'm ${this.name}`;
    },
    
    // ES6简写方法
    introduce() {
        return `My name is ${this.name}`;
    }
};

// 继承和super
const parent = {
    greet() {
        return "Hello from parent";
    }
};

const child = {
    // 设置原型
    __proto__: parent,
    
    greet() {
        // 调用父类方法
        return super.greet() + " and from child";
    }
};

console.log(child.greet()); // "Hello from parent and from child"

// 在类中使用super
class Animal {
    speak() {
        return "Animal makes a sound";
    }
}

class Dog extends Animal {
    speak() {
        return super.speak() + " - Dog barks";
    }
}

const dog = new Dog();
console.log(dog.speak()); // "Animal makes a sound - Dog barks"
```

## 8. 新的数据结构

### 8.1 Symbol

```javascript
// 创建Symbol
const sym1 = Symbol();
const sym2 = Symbol("description");
const sym3 = Symbol("description"); // 即使描述相同，也是不同的Symbol

console.log(sym1 === sym2); // false
console.log(sym2 === sym3); // false

// Symbol作为对象属性
const idSymbol = Symbol("id");
const user = {
    name: "Alice",
    [idSymbol]: 12345
};

// 访问Symbol属性
console.log(user[idSymbol]); // 12345

// Symbol属性不会出现在for...in循环中
for (const prop in user) {
    console.log(prop); // 只会输出 "name"
}

// Object.keys()也不会返回Symbol属性
console.log(Object.keys(user)); // ["name"]

// 需要使用Object.getOwnPropertySymbols()获取Symbol属性
console.log(Object.getOwnPropertySymbols(user)); // [Symbol(id)]

// Symbol.for()和Symbol.keyFor()
const globalSym1 = Symbol.for("global");
const globalSym2 = Symbol.for("global");
console.log(globalSym1 === globalSym2); // true

console.log(Symbol.keyFor(globalSym1)); // "global"

// 内置Symbol
class MyCollection {
    constructor() {
        this.items = [];
    }
    
    // 使用内置Symbol实现迭代
    [Symbol.iterator]() {
        let index = 0;
        return {
            next: () => {
                if (index < this.items.length) {
                    return { value: this.items[index++], done: false };
                } else {
                    return { done: true };
                }
            }
        };
    }
    
    add(item) {
        this.items.push(item);
    }
}

const collection = new MyCollection();
collection.add("A");
collection.add("B");
collection.add("C");

for (const item of collection) {
    console.log(item); // A, B, C
}
```

### 8.2 Set

```javascript
// 创建Set
const set1 = new Set();
const set2 = new Set([1, 2, 3, 3, 4]); // 自动去重
console.log(set2); // Set {1, 2, 3, 4}

// 添加元素
set1.add("a");
set1.add("b");
set1.add("a"); // 重复添加不会生效
console.log(set1); // Set {"a", "b"}

// 删除元素
set1.delete("a");
console.log(set1); // Set {"b"}

// 检查元素是否存在
console.log(set1.has("b")); // true
console.log(set1.has("a")); // false

// 获取大小
console.log(set1.size); // 1

// 清空Set
set1.clear();
console.log(set1.size); // 0

// Set的遍历
const colors = new Set(["red", "green", "blue"]);

// 使用forEach
colors.forEach((value, valueAgain, set) => {
    console.log(value); // red, green, blue
});

// 使用for...of
for (const color of colors) {
    console.log(color); // red, green, blue
}

// Set的常见用途
// 1. 数组去重
const arrayWithDuplicates = [1, 2, 2, 3, 4, 4, 5];
const uniqueArray = [...new Set(arrayWithDuplicates)];
console.log(uniqueArray); // [1, 2, 3, 4, 5]

// 2. 检查元素是否唯一
function hasDuplicates(arr) {
    return arr.length !== new Set(arr).size;
}

console.log(hasDuplicates([1, 2, 3])); // false
console.log(hasDuplicates([1, 2, 2])); // true

// 3. 集合操作
const setA = new Set([1, 2, 3]);
const setB = new Set([3, 4, 5]);

// 并集
const union = new Set([...setA, ...setB]);
console.log(union); // Set {1, 2, 3, 4, 5}

// 交集
const intersection = new Set([...setA].filter(x => setB.has(x)));
console.log(intersection); // Set {3}

// 差集 (A - B)
const difference = new Set([...setA].filter(x => !setB.has(x)));
console.log(difference); // Set {1, 2}
```

### 8.3 Map

```javascript
// 创建Map
const map1 = new Map();
const map2 = new Map([
    ["key1", "value1"],
    ["key2", "value2"]
]);

// 设置值
map1.set("name", "Alice");
map1.set("age", 30);
map1.set("objectKey", { id: 1 });

// Map可以使用任何类型作为键
const key1 = {};
const key2 = function() {};
map1.set(key1, "object as key");
map1.set(key2, "function as key");

// 获取值
console.log(map1.get("name")); // "Alice"
console.log(map1.get(key1)); // "object as key"

// 检查键是否存在
console.log(map1.has("name")); // true
console.log(map1.has("nonexistent")); // false

// 获取大小
console.log(map1.size); // 5

// 删除键值对
map1.delete("age");
console.log(map1.has("age")); // false

// 清空Map
map1.clear();
console.log(map1.size); // 0

// Map的遍历
const userMap = new Map([
    ["name", "Bob"],
    ["age", 25],
    ["email", "bob@example.com"]
]);

// 使用forEach
userMap.forEach((value, key) => {
    console.log(`${key}: ${value}`);
});

// 使用for...of遍历键值对
for (const [key, value] of userMap) {
    console.log(`${key}: ${value}`);
}

// 只遍历键
for (const key of userMap.keys()) {
    console.log(key);
}

// 只遍历值
for (const value of userMap.values()) {
    console.log(value);
}

// Map与对象的转换
// Map转对象
const mapToObject = (map) => {
    const obj = {};
    for (const [key, value] of map) {
        obj[key] = value;
    }
    return obj;
};

// 对象转Map
const objectToMap = (obj) => {
    return new Map(Object.entries(obj));
};

const obj = { a: 1, b: 2 };
const map = objectToMap(obj);
const backToObj = mapToObject(map);

// 实际应用：缓存
const cache = new Map();

function expensiveOperation(input) {
    // 检查缓存
    if (cache.has(input)) {
        console.log("从缓存获取结果");
        return cache.get(input);
    }
    
    console.log("执行耗时操作...");
    // 模拟耗时操作
    const result = input * input;
    
    // 存入缓存
    cache.set(input, result);
    return result;
}

console.log(expensiveOperation(5)); // 执行计算
console.log(expensiveOperation(5)); // 从缓存获取
console.log(expensiveOperation(10)); // 执行计算
console.log(expensiveOperation(10)); // 从缓存获取
```

## 9. 迭代器和生成器

### 9.1 迭代器

```javascript
// 迭代器的基本概念
const myArray = ["a", "b", "c"];

// 获取迭代器
const iterator = myArray[Symbol.iterator]();

// 手动迭代
console.log(iterator.next()); // { value: "a", done: false }
console.log(iterator.next()); // { value: "b", done: false }
console.log(iterator.next()); // { value: "c", done: false }
console.log(iterator.next()); // { value: undefined, done: true }

// 实现自定义迭代器
const range = {
    start: 1,
    end: 5,
    
    [Symbol.iterator]() {
        let current = this.start;
        const end = this.end;
        
        return {
            next() {
                if (current <= end) {
                    return { value: current++, done: false };
                } else {
                    return { done: true };
                }
            }
        };
    }
};

// 使用for...of遍历自定义迭代器
for (const num of range) {
    console.log(num); // 1, 2, 3, 4, 5
}

// 使用扩展运算符
console.log([...range]); // [1, 2, 3, 4, 5]

// 迭代器的高级应用
function* fibonacci() {
    let [prev, curr] = [0, 1];
    
    while (true) {
        yield curr;
        [prev, curr] = [curr, prev + curr];
    }
}

const fib = fibonacci();
console.log(fib.next().value); // 1
console.log(fib.next().value); // 1
console.log(fib.next().value); // 2
console.log(fib.next().value); // 3
console.log(fib.next().value); // 5

// 有限斐波那契数列
function* limitedFibonacci(count) {
    let [prev, curr] = [0, 1];
    
    for (let i = 0; i < count; i++) {
        yield curr;
        [prev, curr] = [curr, prev + curr];
    }
}

for (const num of limitedFibonacci(10)) {
    console.log(num);
}
```

### 9.2 生成器

```javascript
// 基本生成器
function* simpleGenerator() {
    console.log("生成器开始执行");
    yield 1;
    console.log("第一个yield后");
    yield 2;
    console.log("第二个yield后");
    yield 3;
    console.log("生成器结束");
}

const gen = simpleGenerator();
console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }

// 生成器作为迭代器
for (const value of simpleGenerator()) {
    console.log(value); // 1, 2, 3
}

// 生成器的实际应用：实现异步流程控制
function asyncFlow() {
    return spawn(function*() {
        const data1 = yield fetchData1();
        const data2 = yield fetchData2(data1);
        const data3 = yield fetchData3(data2);
        
        console.log("所有数据获取完成:", { data1, data2, data3 });
    });
}

// 模拟fetchData函数
function fetchData1() {
    return new Promise(resolve => {
        setTimeout(() => resolve("数据1"), 1000);
    });
}

function fetchData2(data) {
    return new Promise(resolve => {
        setTimeout(() => resolve(`基于${data}的数据2`), 1000);
    });
}

function fetchData3(data) {
    return new Promise(resolve => {
        setTimeout(() => resolve(`基于${data}的数据3`), 1000);
    });
}

// spawn函数实现（简化版）
function spawn(genFunc) {
    const gen = genFunc();
    
    function step(nextF) {
        let next;
        
        try {
            next = nextF();
        } catch (e) {
            return Promise.reject(e);
        }
        
        if (next.done) {
            return Promise.resolve(next.value);
        }
        
        Promise.resolve(next.value).then(
            v => step(() => gen.next(v)),
            e => step(() => gen.throw(e))
        );
    }
    
    step(() => gen.next());
}

// asyncFlow(); // 实际运行异步流程

// 生成器实现状态机
function* trafficLight() {
    while (true) {
        yield "red";     // 红灯
        yield "yellow";  // 黄灯
        yield "green";   // 绿灯
        yield "yellow";  // 黄灯
    }
}

const light = trafficLight();
setInterval(() => {
    console.log(light.next().value);
}, 2000);

// 生成器处理树形结构遍历
class TreeNode {
    constructor(value, children = []) {
        this.value = value;
        this.children = children;
    }
    
    // 使用生成器实现深度优先遍历
    *[Symbol.iterator]() {
        yield this.value;
        
        for (const child of this.children) {
            yield* child;
        }
    }
}

// 构建树
const tree = new TreeNode(1, [
    new TreeNode(2, [
        new TreeNode(4),
        new TreeNode(5)
    ]),
    new TreeNode(3, [
        new TreeNode(6),
        new TreeNode(7)
    ])
]);

// 遍历树
for (const value of tree) {
    console.log(value); // 1, 2, 4, 5, 3, 6, 7
}
```

## 10. 类与继承

### 10.1 基本类的定义

```javascript
// 基本类定义
class Person {
    // 构造函数
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    // 实例方法
    greet() {
        return `Hello, I'm ${this.name}`;
    }
    
    // 获取器
    get info() {
        return `${this.name} is ${this.age} years old`;
    }
    
    // 设置器
    set age(value) {
        if (value < 0) {
            throw new Error("年龄不能为负数");
        }
        this._age = value;
    }
    
    get age() {
        return this._age;
    }
    
    // 静态方法
    static createAdult(name) {
        return new Person(name, 18);
    }
}

// 使用类
const alice = new Person("Alice", 30);
console.log(alice.greet()); // "Hello, I'm Alice"
console.log(alice.info); // "Alice is 30 years old"

const bob = Person.createAdult("Bob");
console.log(bob.age); // 18

// 表达式形式定义类
const MyOtherClass = class MyClass {
    constructor(value) {
        this.value = value;
    }
    
    getValue() {
        return this.value;
    }
};
```

### 10.2 继承

```javascript
// 基类
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        return `${this.name} makes a sound`;
    }
}

// 子类
class Dog extends Animal {
    constructor(name, breed) {
        // 调用父类构造函数
        super(name);
        this.breed = breed;
    }
    
    // 重写父类方法
    speak() {
        return `${this.name} barks`;
    }
    
    // 新增方法
    fetch() {
        return `${this.name} is fetching`;
    }
}

const myDog = new Dog("Rex", "Golden Retriever");
console.log(myDog.speak()); // "Rex barks"
console.log(myDog.fetch()); // "Rex is fetching"

// 调用父类方法
class Cat extends Animal {
    speak() {
        // 使用super调用父类方法
        return super.speak() + " and purrs";
    }
}

const myCat = new Cat("Whiskers");
console.log(myCat.speak()); // "Whiskers makes a sound and purrs"

// 继承中的属性访问
class Vehicle {
    constructor(brand) {
        this.brand = brand;
    }
    
    start() {
        return `${this.brand} vehicle starts`;
    }
}

class Car extends Vehicle {
    constructor(brand, model) {
        super(brand);
        this.model = model;
    }
    
    start() {
        // 调用父类方法并添加子类特有内容
        return `${super.start()}, specifically the ${this.model}`;
    }
}

const myCar = new Car("Toyota", "Camry");
console.log(myCar.start()); // "Toyota vehicle starts, specifically the Camry"
```

### 10.3 高级类特性

```javascript
// 私有字段（ES2022）
class BankAccount {
    // 私有字段以#开头
    #balance = 0;
    
    #owner;
    
    constructor(owner, initialBalance = 0) {
        this.#owner = owner;
        this.#balance = initialBalance;
    }
    
    // 公共方法可以访问私有字段
    deposit(amount) {
        if (amount <= 0) {
            throw new Error("存款金额必须大于0");
        }
        this.#balance += amount;
        return this.#balance;
    }
    
    withdraw(amount) {
        if (amount <= 0) {
            throw new Error("取款金额必须大于0");
        }
        if (amount > this.#balance) {
            throw new Error("余额不足");
        }
        this.#balance -= amount;
        return this.#balance;
    }
    
    // 私有方法
    #validateAmount(amount) {
        return typeof amount === 'number' && amount > 0;
    }
    
    get balance() {
        return this.#balance;
    }
    
    get owner() {
        return this.#owner;
    }
}

const account = new BankAccount("Alice", 1000);
console.log(account.deposit(500)); // 1500
console.log(account.withdraw(200)); // 1300
// console.log(account.#balance); // SyntaxError: Private field '#balance' must be declared in an enclosing class

// 使用私有字段的替代方案（ES6）
class BankAccountES6 {
    constructor(owner, initialBalance = 0) {
        // 使用WeakMap实现私有字段
        if (!BankAccountES6._privateData) {
            BankAccountES6._privateData = new WeakMap();
        }
        
        BankAccountES6._privateData.set(this, {
            balance: initialBalance,
            owner
        });
    }
    
    deposit(amount) {
        const privateData = BankAccountES6._privateData.get(this);
        
        if (amount <= 0) {
            throw new Error("存款金额必须大于0");
        }
        
        privateData.balance += amount;
        return privateData.balance;
    }
    
    get balance() {
        return BankAccountES6._privateData.get(this).balance;
    }
}

// 静态字段和方法
class MathUtils {
    // 静态字段（ES2022）
    static PI = 3.14159;
    
    static #precision = 2;
    
    // 静态方法
    static circleArea(radius) {
        return (MathUtils.PI * radius * radius).toFixed(MathUtils.#precision);
    }
    
    static triangleArea(base, height) {
        return (0.5 * base * height).toFixed(MathUtils.#precision);
    }
}

console.log(MathUtils.circleArea(5)); // "78.54"
console.log(MathUtils.triangleArea(10, 5)); // "25.00"

// 混入模式（多重继承的替代方案）
const canEat = {
    eat(food) {
        console.log(`${this.name} is eating ${food}`);
    }
};

const canWalk = {
    walk(distance) {
        console.log(`${this.name} walked ${distance} meters`);
    }
};

class Person {
    constructor(name) {
        this.name = name;
    }
}

// 使用Object.assign将混入应用到原型
Object.assign(Person.prototype, canEat, canWalk);

const john = new Person("John");
john.eat("apple"); // "John is eating apple"
john.walk(100); // "John walked 100 meters"

// new.target
class Shape {
    constructor() {
        if (new.target === Shape) {
            throw new Error("不能直接实例化抽象类");
        }
    }
    
    draw() {
        console.log(`Drawing a ${this.constructor.name}`);
    }
}

class Circle extends Shape {
    constructor(radius) {
        super();
        this.radius = radius;
        console.log(`Created a Circle with radius ${radius}`);
    }
}

// new Shape(); // Error: 不能直接实例化抽象类
const circle = new Circle(5); // "Created a Circle with radius 5"
circle.draw(); // "Drawing a Circle"
```

## 11. 模块系统

### 11.1 导入和导出

```javascript
// math.js - 模块文件
// 命名导出
export function add(a, b) {
    return a + b;
}

export function subtract(a, b) {
    return a - b;
}

export function multiply(a, b) {
    return a * b;
}

// 默认导出
export default function divide(a, b) {
    if (b === 0) {
        throw new Error("不能除以0");
    }
    return a / b;
}

// 导出常量
export const PI = 3.14159;

// 导出类
export class Calculator {
    constructor() {
        this.result = 0;
    }
    
    add(value) {
        this.result += value;
        return this;
    }
    
    subtract(value) {
        this.result -= value;
        return this;
    }
    
    getResult() {
        return this.result;
    }
}

// 使用模块
// main.js
import divide, { add, subtract, multiply, PI, Calculator } from './math.js';

// 也可以重命名导入
import { add as sum } from './math.js';

// 或导入所有命名导出到对象
import * as math from './math.js';

// 使用默认导出的函数
console.log(divide(10, 2)); // 5

// 使用命名导出
console.log(add(5, 3)); // 8
console.log(math.subtract(10, 3)); // 7
console.log(PI); // 3.14159

// 使用导出的类
const calc = new Calculator();
const result = calc.add(10).subtract(3).getResult(); // 7
```

### 11.2 动态导入

```javascript
// 动态导入（返回Promise）
async function loadMathModule() {
    try {
        const mathModule = await import('./math.js');
        
        console.log(mathModule.add(5, 3)); // 8
        console.log(mathModule.subtract(10, 3)); // 7
        console.log(mathModule.default(10, 2)); // 5
        
        // 使用Calculator类
        const calc = new mathModule.Calculator();
        const result = calc.add(10).subtract(3).getResult();
        console.log(result); // 7
    } catch (error) {
        console.error('加载模块失败:', error);
    }
}

loadMathModule();

// 条件动态加载
function loadModuleBasedOnCondition() {
    if (someCondition) {
        return import('./module1.js');
    } else {
        return import('./module2.js');
    }
}

// 路由基础代码分割
async function loadRoute(route) {
    switch (route) {
        case '/home':
            return await import('./views/home.js');
        case '/about':
            return await import('./views/about.js');
        case '/contact':
            return await import('./views/contact.js');
        default:
            return await import('./views/notFound.js');
    }
}
```

## 12. 总结

ES6+为JavaScript带来了许多强大的新特性，大大提升了开发效率和代码质量：

1. **变量声明**：let和const提供了更好的作用域控制
2. **箭头函数**：简化函数写法，解决this绑定问题
3. **模板字符串**：使字符串拼接更加直观和灵活
4. **解构赋值**：从数组和对象中提取值，简化代码
5. **扩展运算符和剩余参数**：处理数组和函数参数更加便捷
6. **对象字面量增强**：简写属性和方法，支持计算属性名
7. **新的数据结构**：Symbol、Set、Map提供更多数据组织方式
8. **迭代器和生成器**：实现自定义迭代逻辑和控制流程
9. **类与继承**：提供更直观的面向对象编程方式
10. **模块系统**：支持代码的模块化和重用

掌握ES6+特性对于现代JavaScript开发至关重要，这些特性不仅提高了代码的可读性和维护性，还使得JavaScript能够应对更复杂的应用场景。在下一章中，我们将学习JavaScript中的面向对象编程，进一步深入理解JavaScript的核心编程思想。