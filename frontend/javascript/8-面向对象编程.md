# 第8章：面向对象编程

## 8.1 面向对象编程基础

### 8.1.1 什么是面向对象编程

面向对象编程（Object-Oriented Programming，简称OOP）是一种编程范式，它将现实世界中的事物抽象为程序中的"对象"，通过对象之间的交互来完成任务。

OOP的核心思想：
- **抽象**：忽略事物中与当前目标无关的方面，以便更充分地关注与当前目标有关的方面
- **封装**：将数据和操作数据的方法绑定在一起，对外部隐藏实现细节
- **继承**：一个对象可以继承另一个对象的属性和方法，实现代码复用
- **多态**：不同对象对同一消息做出不同的响应

### 8.1.2 JavaScript中的对象

JavaScript中的对象是动态的属性集合，其属性可以是原始值、对象或函数。

```javascript
// 简单对象
const person = {
  name: "张三",
  age: 30,
  greet: function() {
    return `你好，我是${this.name}`;
  }
};

console.log(person.name);  // 输出: "张三"
console.log(person.greet()); // 输出: "你好，我是张三"
```

### 8.1.3 对象创建方式

#### 1. 对象字面量

```javascript
const car = {
  brand: "特斯拉",
  model: "Model 3",
  year: 2022,
  start: function() {
    return `${this.brand} ${this.model} 启动了`;
  }
};
```

#### 2. 构造函数

```javascript
function Car(brand, model, year) {
  this.brand = brand;
  this.model = model;
  this.year = year;
  this.start = function() {
    return `${this.brand} ${this.model} 启动了`;
  };
}

const myCar = new Car("特斯拉", "Model 3", 2022);
console.log(myCar.start()); // 输出: "特斯拉 Model 3 启动了"
```

#### 3. Object.create()

```javascript
const carPrototype = {
  start: function() {
    return `${this.brand} ${this.model} 启动了`;
  }
};

const myCar = Object.create(carPrototype);
myCar.brand = "特斯拉";
myCar.model = "Model 3";
console.log(myCar.start()); // 输出: "特斯拉 Model 3 启动了"
```

#### 4. ES6类

```javascript
class Car {
  constructor(brand, model, year) {
    this.brand = brand;
    this.model = model;
    this.year = year;
  }
  
  start() {
    return `${this.brand} ${this.model} 启动了`;
  }
}

const myCar = new Car("特斯拉", "Model 3", 2022);
console.log(myCar.start()); // 输出: "特斯拉 Model 3 启动了"
```

## 8.2 原型与原型链

### 8.2.1 原型对象

每个JavaScript对象都有一个内部属性`[[Prototype]]`（在大多数浏览器中通过`__proto__`访问），它指向另一个对象，即原型对象。当我们访问对象的属性时，如果对象本身没有这个属性，JavaScript引擎会沿着原型链向上查找。

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function() {
  return `你好，我是${this.name}`;
};

const person1 = new Person("张三");
const person2 = new Person("李四");

console.log(person1.greet()); // "你好，我是张三"
console.log(person2.greet()); // "你好，我是李四"

// 两个实例共享同一个原型方法
console.log(person1.greet === person2.greet); // true
```

### 8.2.2 原型链

原型链是由相互链接的原型对象组成的链式结构，用于实现继承和属性共享。

```javascript
// 父类
function Animal(name) {
  this.name = name;
}

Animal.prototype.eat = function() {
  return `${this.name} 正在吃东西`;
};

// 子类
function Dog(name, breed) {
  Animal.call(this, name); // 调用父类构造函数
  this.breed = breed;
}

// 设置子类的原型
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

// 子类特有方法
Dog.prototype.bark = function() {
  return `${this.name} 正在汪汪叫`;
};

const myDog = new Dog("旺财", "金毛寻回犬");

console.log(myDog.eat());  // "旺财 正在吃东西" (来自父类)
console.log(myDog.bark()); // "旺财 正在汪汪叫" (来自子类)
console.log(myDog instanceof Dog);    // true
console.log(myDog instanceof Animal); // true
```

### 8.2.3 原型链图解

```
myDog (实例)
   ↓ (.__proto__)
Dog.prototype
   ↓ (.__proto__)
Animal.prototype
   ↓ (.__proto__)
Object.prototype
   ↓ (.__proto__)
null
```

## 8.3 ES6类与继承

### 8.3.1 ES6类的定义

ES6引入了`class`关键字，使得定义对象模板更加清晰和简洁。

```javascript
class User {
  // 构造函数
  constructor(username, email) {
    this.username = username;
    this.email = email;
    this._loginAttempts = 0; // 私有属性约定
  }
  
  // 实例方法
  login() {
    this._loginAttempts++;
    console.log(`${this.username} 登录成功`);
    return true;
  }
  
  // Getter方法
  get loginAttempts() {
    return this._loginAttempts;
  }
  
  // Setter方法
  set resetAttempts(value) {
    if (value === 0) {
      this._loginAttempts = 0;
    }
  }
  
  // 静态方法
  static createUser(username, email) {
    return new User(username, email);
  }
}

const user = User.createUser("张三", "zhangsan@example.com");
user.login();
user.login();
console.log(user.loginAttempts); // 2
user.resetAttempts = 0;
console.log(user.loginAttempts); // 0
```

### 8.3.2 类的继承

使用`extends`关键字实现类的继承，子类可以继承父类的所有属性和方法。

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  eat() {
    console.log(`${this.name} 正在吃东西`);
  }
  
  sleep() {
    console.log(`${this.name} 正在睡觉`);
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    // 调用父类构造函数
    super(name);
    this.breed = breed;
  }
  
  // 重写父类方法
  eat() {
    console.log(`${this.name}(${this.breed}) 正在吃东西`);
  }
  
  // 子类特有方法
  bark() {
    console.log(`${this.name} 正在汪汪叫`);
  }
  
  // 调用父类方法
  rest() {
    // 使用super调用父类方法
    super.sleep();
    console.log(`${this.name} 休息中...`);
  }
}

const myDog = new Dog("旺财", "金毛");
myDog.eat();  // "旺财(金毛) 正在吃东西"
myDog.sleep(); // "旺财 正在睡觉"
myDog.bark(); // "旺财 正在汪汪叫"
myDog.rest(); // "旺财 正在睡觉" + "旺财 休息中..."
```

### 8.3.3 私有字段

ES2022引入了真正的私有字段，使用`#`前缀表示私有字段。

```javascript
class BankAccount {
  #balance = 0; // 私有字段
  
  constructor(initialBalance = 0) {
    this.#balance = initialBalance;
  }
  
  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
      return true;
    }
    return false;
  }
  
  withdraw(amount) {
    if (amount > 0 && amount <= this.#balance) {
      this.#balance -= amount;
      return true;
    }
    return false;
  }
  
  getBalance() {
    return this.#balance;
  }
}

const account = new BankAccount(1000);
account.deposit(500);
account.withdraw(200);
console.log(account.getBalance()); // 1300
console.log(account.#balance); // SyntaxError: Private field '#balance' must be declared in an enclosing class
```

## 8.4 多态与接口

### 8.4.1 多态的实现

多态允许不同类的对象对相同的方法做出不同的响应。

```javascript
// 形状基类
class Shape {
  draw() {
    throw new Error("子类必须实现draw方法");
  }
  
  area() {
    throw new Error("子类必须实现area方法");
  }
}

// 圆形类
class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }
  
  draw() {
    console.log(`绘制一个半径为${this.radius}的圆形`);
  }
  
  area() {
    return Math.PI * Math.pow(this.radius, 2);
  }
}

// 矩形类
class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }
  
  draw() {
    console.log(`绘制一个宽为${this.width}、高为${this.height}的矩形`);
  }
  
  area() {
    return this.width * this.height;
  }
}

// 三角形类
class Triangle extends Shape {
  constructor(base, height) {
    super();
    this.base = base;
    this.height = height;
  }
  
  draw() {
    console.log(`绘制一个底为${this.base}、高为${this.height}的三角形`);
  }
  
  area() {
    return 0.5 * this.base * this.height;
  }
}

// 多态应用
const shapes = [
  new Circle(5),
  new Rectangle(4, 6),
  new Triangle(3, 4)
];

shapes.forEach(shape => {
  shape.draw();
  console.log(`面积: ${shape.area().toFixed(2)}`);
  console.log('---');
});
```

### 8.4.2 接口模拟

JavaScript中没有真正的接口，但可以通过文档约定、鸭子类型和抽象基类来模拟接口。

#### 1. 文档约定接口

```javascript
/**
 * 渲染器接口
 * 应该实现以下方法:
 * - render(data): 渲染数据
 * - clear(): 清除渲染内容
 */

class DataRenderer {
  // 具体实现...
}
```

#### 2. 鸭子类型接口

```javascript
// 游戏中的移动策略接口
class MoveStrategy {
  move(entity, deltaTime) {
    throw new Error("必须实现move方法");
  }
}

// 具体移动策略
class WalkStrategy extends MoveStrategy {
  constructor(speed) {
    super();
    this.speed = speed;
  }
  
  move(entity, deltaTime) {
    entity.x += this.speed * deltaTime;
  }
}

class FlyStrategy extends MoveStrategy {
  constructor(speed) {
    super();
    this.speed = speed;
  }
  
  move(entity, deltaTime) {
    entity.x += this.speed * deltaTime;
    entity.y += this.speed * deltaTime * 0.5; // 同时向上移动
  }
}

// 实体类
class Entity {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.moveStrategy = null;
  }
  
  setMoveStrategy(strategy) {
    this.moveStrategy = strategy;
  }
  
  update(deltaTime) {
    if (this.moveStrategy) {
      this.moveStrategy.move(this, deltaTime);
    }
  }
}

const player = new Entity(0, 0);
player.setMoveStrategy(new WalkStrategy(5));
player.update(1); // x = 5
player.setMoveStrategy(new FlyStrategy(10));
player.update(1); // x = 15, y = 5
```

## 8.5 设计模式入门

### 8.5.1 单例模式

单例模式确保一个类只有一个实例，并提供一个全局访问点。

```javascript
class Database {
  constructor() {
    if (Database.instance) {
      return Database.instance;
    }
    
    this.connection = "数据库连接";
    Database.instance = this;
  }
  
  query(sql) {
    console.log(`执行查询: ${sql}`);
    return "查询结果";
  }
  
  static getInstance() {
    if (!Database.instance) {
      Database.instance = new Database();
    }
    return Database.instance;
  }
}

// 使用
const db1 = Database.getInstance();
const db2 = Database.getInstance();
console.log(db1 === db2); // true
```

### 8.5.2 工厂模式

工厂模式提供一个创建对象的接口，但让子类决定实例化哪一个类。

```javascript
// 抽象产品
class Animal {
  speak() {
    throw new Error("子类必须实现speak方法");
  }
}

// 具体产品
class Dog extends Animal {
  speak() {
    return "汪汪!";
  }
}

class Cat extends Animal {
  speak() {
    return "喵喵!";
  }
}

class Cow extends Animal {
  speak() {
    return "哞哞!";
  }
}

// 工厂类
class AnimalFactory {
  static createAnimal(type) {
    switch (type.toLowerCase()) {
      case 'dog':
        return new Dog();
      case 'cat':
        return new Cat();
      case 'cow':
        return new Cow();
      default:
        throw new Error(`未知的动物类型: ${type}`);
    }
  }
}

// 使用
const dog = AnimalFactory.createAnimal('dog');
const cat = AnimalFactory.createAnimal('cat');
console.log(dog.speak()); // "汪汪!"
console.log(cat.speak()); // "喵喵!"
```

### 8.5.3 观察者模式

观察者模式定义对象间一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

```javascript
// 主题（被观察者）
class Subject {
  constructor() {
    this.observers = [];
  }
  
  // 添加观察者
  subscribe(observer) {
    this.observers.push(observer);
  }
  
  // 移除观察者
  unsubscribe(observer) {
    this.observers = this.observers.filter(obs => obs !== observer);
  }
  
  // 通知所有观察者
  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

// 观察者
class Observer {
  constructor(name) {
    this.name = name;
  }
  
  update(data) {
    console.log(`${this.name} 收到通知: ${data}`);
  }
}

// 使用
const subject = new Subject();
const observer1 = new Observer("观察者1");
const observer2 = new Observer("观察者2");

subject.subscribe(observer1);
subject.subscribe(observer2);
subject.notify("主题状态已更新"); // 两个观察者都会收到通知
subject.unsubscribe(observer1);
subject.notify("再次更新状态"); // 只有观察者2会收到通知
```

### 8.5.4 装饰器模式

装饰器模式动态地给对象添加一些额外的职责，就增加功能来说，装饰器模式相比生成子类更为灵活。

```javascript
// 基础咖啡类
class Coffee {
  cost() {
    return 10;
  }
  
  description() {
    return "基础咖啡";
  }
}

// 装饰器基类
class CoffeeDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }
  
  cost() {
    return this.coffee.cost();
  }
  
  description() {
    return this.coffee.description();
  }
}

// 牛奶装饰器
class MilkDecorator extends CoffeeDecorator {
  cost() {
    return this.coffee.cost() + 2;
  }
  
  description() {
    return `${this.coffee.description()} + 牛奶`;
  }
}

// 糖装饰器
class SugarDecorator extends CoffeeDecorator {
  cost() {
    return this.coffee.cost() + 1;
  }
  
  description() {
    return `${this.coffee.description()} + 糖`;
  }
}

// 使用
let coffee = new Coffee();
console.log(coffee.description(), "价格:", coffee.cost()); // "基础咖啡 价格: 10"

coffee = new MilkDecorator(coffee);
console.log(coffee.description(), "价格:", coffee.cost()); // "基础咖啡 + 牛奶 价格: 12"

coffee = new SugarDecorator(coffee);
console.log(coffee.description(), "价格:", coffee.cost()); // "基础咖啡 + 牛奶 + 糖 价格: 13"
```

## 8.6 面向对象的实际应用

### 8.6.1 电子商务系统中的类设计

```javascript
// 用户类
class User {
  constructor(id, name, email) {
    this.id = id;
    this.name = name;
    this.email = email;
    this.shoppingCart = new ShoppingCart();
    this.orders = [];
  }
  
  addToCart(product, quantity = 1) {
    this.shoppingCart.addProduct(product, quantity);
  }
  
  checkout() {
    if (this.shoppingCart.isEmpty()) {
      throw new Error("购物车是空的，无法结算");
    }
    
    const order = new Order(this, [...this.shoppingCart.items]);
    this.orders.push(order);
    this.shoppingCart.clear();
    return order;
  }
}

// 产品类
class Product {
  constructor(id, name, price, description = "") {
    this.id = id;
    this.name = name;
    this.price = price;
    this.description = description;
  }
  
  getDisplayInfo() {
    return {
      name: this.name,
      price: `¥${this.price.toFixed(2)}`,
      description: this.description
    };
  }
}

// 购物车类
class ShoppingCart {
  constructor() {
    this.items = [];
  }
  
  addProduct(product, quantity) {
    const existingItem = this.items.find(item => item.product.id === product.id);
    
    if (existingItem) {
      existingItem.quantity += quantity;
    } else {
      this.items.push({ product, quantity });
    }
  }
  
  removeProduct(productId) {
    this.items = this.items.filter(item => item.product.id !== productId);
  }
  
  getTotalPrice() {
    return this.items.reduce((total, item) => {
      return total + (item.product.price * item.quantity);
    }, 0);
  }
  
  isEmpty() {
    return this.items.length === 0;
  }
  
  clear() {
    this.items = [];
  }
}

// 订单类
class Order {
  constructor(user, items) {
    this.id = Order.generateId();
    this.userId = user.id;
    this.items = items;
    this.status = "pending";
    this.createDate = new Date();
    this.totalAmount = this.calculateTotal();
  }
  
  static generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }
  
  calculateTotal() {
    return this.items.reduce((total, item) => {
      return total + (item.product.price * item.quantity);
    }, 0);
  }
  
  complete() {
    this.status = "completed";
    this.completeDate = new Date();
  }
  
  cancel() {
    this.status = "cancelled";
    this.cancelDate = new Date();
  }
}

// 使用示例
const user = new User("1", "张三", "zhangsan@example.com");
const laptop = new Product("1", "笔记本电脑", 5999, "高性能笔记本电脑");
const mouse = new Product("2", "无线鼠标", 99, "舒适的无线鼠标");

user.addToCart(laptop, 1);
user.addToCart(mouse, 2);
console.log("购物车总价:", user.shoppingCart.getTotalPrice()); // 6197

const order = user.checkout();
console.log("订单编号:", order.id);
console.log("订单金额:", order.totalAmount);
order.complete();
console.log("订单状态:", order.status);
```

### 8.6.2 游戏开发中的类设计

```javascript
// 游戏实体基类
class GameObject {
  constructor(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.isActive = true;
  }
  
  update(deltaTime) {
    // 子类实现具体更新逻辑
  }
  
  render(ctx) {
    // 子类实现具体渲染逻辑
  }
  
  checkCollision(other) {
    return (
      this.x < other.x + other.width &&
      this.x + this.width > other.x &&
      this.y < other.y + other.height &&
      this.y + this.height > other.y
    );
  }
}

// 玩家类
class Player extends GameObject {
  constructor(x, y) {
    super(x, y, 50, 50);
    this.speed = 5;
    this.health = 100;
    this.score = 0;
    this.bullets = [];
  }
  
  update(deltaTime, keys) {
    // 移动
    if (keys.ArrowUp && this.y > 0) {
      this.y -= this.speed;
    }
    if (keys.ArrowDown && this.y < window.innerHeight - this.height) {
      this.y += this.speed;
    }
    if (keys.ArrowLeft && this.x > 0) {
      this.x -= this.speed;
    }
    if (keys.ArrowRight && this.x < window.innerWidth - this.width) {
      this.x += this.speed;
    }
    
    // 更新子弹
    this.bullets = this.bullets.filter(bullet => {
      bullet.update(deltaTime);
      return bullet.isActive;
    });
  }
  
  shoot() {
    const bullet = new Bullet(this.x + this.width / 2, this.y);
    this.bullets.push(bullet);
  }
  
  takeDamage(damage) {
    this.health -= damage;
    if (this.health <= 0) {
      this.isActive = false;
    }
  }
  
  render(ctx) {
    ctx.fillStyle = "blue";
    ctx.fillRect(this.x, this.y, this.width, this.height);
    
    // 渲染生命值
    ctx.fillStyle = "red";
    ctx.fillRect(this.x, this.y - 10, this.width, 5);
    ctx.fillStyle = "green";
    ctx.fillRect(this.x, this.y - 10, (this.width * this.health) / 100, 5);
    
    // 渲染子弹
    this.bullets.forEach(bullet => bullet.render(ctx));
  }
}

// 子弹类
class Bullet extends GameObject {
  constructor(x, y) {
    super(x - 2, y, 4, 10);
    this.speed = 10;
  }
  
  update(deltaTime) {
    this.y -= this.speed;
    
    // 超出屏幕则禁用
    if (this.y < -this.height) {
      this.isActive = false;
    }
  }
  
  render(ctx) {
    ctx.fillStyle = "yellow";
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }
}

// 敌人类
class Enemy extends GameObject {
  constructor(x, y) {
    super(x, y, 40, 40);
    this.speed = 2;
    this.health = 30;
    this.scoreValue = 10;
    this.lastShotTime = 0;
    this.shootInterval = 2000; // 2秒发射一次
  }
  
  update(deltaTime) {
    this.y += this.speed;
    
    // 超出屏幕则禁用
    if (this.y > window.innerHeight) {
      this.isActive = false;
    }
    
    // 定时射击
    const currentTime = Date.now();
    if (currentTime - this.lastShotTime > this.shootInterval) {
      this.shoot();
      this.lastShotTime = currentTime;
    }
  }
  
  shoot() {
    // 创建敌方子弹
    return new Bullet(this.x + this.width / 2, this.y + this.height);
  }
  
  takeDamage(damage) {
    this.health -= damage;
    if (this.health <= 0) {
      this.isActive = false;
    }
  }
  
  render(ctx) {
    ctx.fillStyle = "red";
    ctx.fillRect(this.x, this.y, this.width, this.height);
    
    // 渲染生命值
    ctx.fillStyle = "red";
    ctx.fillRect(this.x, this.y - 10, this.width, 5);
    ctx.fillStyle = "green";
    ctx.fillRect(this.x, this.y - 10, (this.width * this.health) / 30, 5);
  }
}

// 游戏管理器
class Game {
  constructor() {
    this.canvas = document.createElement("canvas");
    this.ctx = this.canvas.getContext("2d");
    this.player = new Player(400, 500);
    this.enemies = [];
    this.keys = {};
    this.isRunning = false;
    this.score = 0;
    this.enemySpawnTimer = 0;
    this.enemySpawnInterval = 2000; // 2秒生成一个敌人
    
    this.setupCanvas();
    this.setupEventListeners();
  }
  
  setupCanvas() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    document.body.appendChild(this.canvas);
  }
  
  setupEventListeners() {
    window.addEventListener("keydown", (e) => {
      this.keys[e.key] = true;
      
      if (e.key === " ") {
        this.player.shoot();
      }
    });
    
    window.addEventListener("keyup", (e) => {
      this.keys[e.key] = false;
    });
  }
  
  spawnEnemy() {
    const x = Math.random() * (this.canvas.width - 40);
    const enemy = new Enemy(x, -40);
    this.enemies.push(enemy);
  }
  
  checkCollisions() {
    // 检查玩家子弹和敌人的碰撞
    this.player.bullets.forEach(bullet => {
      this.enemies.forEach(enemy => {
        if (bullet.isActive && enemy.isActive && bullet.checkCollision(enemy)) {
          enemy.takeDamage(10);
          bullet.isActive = false;
          
          if (!enemy.isActive) {
            this.score += enemy.scoreValue;
            this.player.score += enemy.scoreValue;
          }
        }
      });
    });
    
    // 检查敌人和玩家的碰撞
    this.enemies.forEach(enemy => {
      if (enemy.isActive && this.player.isActive && enemy.checkCollision(this.player)) {
        this.player.takeDamage(20);
        enemy.isActive = false;
      }
    });
  }
  
  update(deltaTime) {
    if (!this.isRunning) return;
    
    // 更新玩家
    this.player.update(deltaTime, this.keys);
    
    // 更新敌人
    this.enemies = this.enemies.filter(enemy => {
      enemy.update(deltaTime);
      return enemy.isActive;
    });
    
    // 生成敌人
    this.enemySpawnTimer += deltaTime;
    if (this.enemySpawnTimer > this.enemySpawnInterval) {
      this.spawnEnemy();
      this.enemySpawnTimer = 0;
    }
    
    // 检查碰撞
    this.checkCollisions();
  }
  
  render() {
    // 清空画布
    this.ctx.fillStyle = "black";
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    // 渲染玩家
    if (this.player.isActive) {
      this.player.render(this.ctx);
    }
    
    // 渲染敌人
    this.enemies.forEach(enemy => {
      if (enemy.isActive) {
        enemy.render(this.ctx);
      }
    });
    
    // 渲染分数
    this.ctx.fillStyle = "white";
    this.ctx.font = "20px Arial";
    this.ctx.fillText(`分数: ${this.score}`, 10, 30);
    this.ctx.fillText(`生命值: ${this.player.health}`, 10, 60);
    
    // 游戏结束
    if (!this.player.isActive) {
      this.ctx.fillStyle = "white";
      this.ctx.font = "48px Arial";
      this.ctx.textAlign = "center";
      this.ctx.fillText("游戏结束", this.canvas.width / 2, this.canvas.height / 2);
      this.ctx.font = "24px Arial";
      this.ctx.fillText(`最终得分: ${this.score}`, this.canvas.width / 2, this.canvas.height / 2 + 50);
    }
  }
  
  gameLoop() {
    const update = () => {
      this.update(16); // 假设60FPS，每帧约16ms
      this.render();
      requestAnimationFrame(update);
    };
    
    update();
  }
  
  start() {
    this.isRunning = true;
    this.gameLoop();
  }
  
  stop() {
    this.isRunning = false;
  }
}

// 启动游戏
const game = new Game();
game.start();
```

## 8.7 最佳实践

### 8.7.1 面向对象设计原则

#### 1. 单一职责原则 (SRP)
一个类应该只有一个引起变化的原因。

```javascript
// 不好的例子 - 一个类承担多个职责
class User {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }
  
  // 用户信息管理
  updateProfile(name, email) {
    this.name = name;
    this.email = email;
  }
  
  // 数据库操作 - 应该分离
  saveToDatabase() {
    // 数据库操作代码...
  }
  
  // 邮件发送 - 应该分离
  sendWelcomeEmail() {
    // 邮件发送代码...
  }
}

// 好的例子 - 职责分离
class User {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }
  
  updateProfile(name, email) {
    this.name = name;
    this.email = email;
  }
}

class UserRepository {
  save(user) {
    // 数据库操作代码...
  }
}

class EmailService {
  sendWelcomeEmail(user) {
    // 邮件发送代码...
  }
}
```

#### 2. 开放封闭原则 (OCP)
软件实体应该是可以扩展的，但是不可修改的。

```javascript
// 不好的例子 - 修改现有类来添加新功能
class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }
  
  area() {
    return this.width * this.height;
  }
}

// 添加新形状需要修改现有代码
function calculateArea(shapes) {
  let totalArea = 0;
  for (const shape of shapes) {
    if (shape instanceof Rectangle) {
      totalArea += shape.area();
    }
    // 如果添加新形状，需要在这里添加新的条件
  }
  return totalArea;
}

// 好的例子 - 使用多态扩展新功能
class Shape {
  area() {
    throw new Error("子类必须实现area方法");
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }
  
  area() {
    return this.width * this.height;
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }
  
  area() {
    return Math.PI * Math.pow(this.radius, 2);
  }
}

// 添加新形状不需要修改现有代码
function calculateArea(shapes) {
  return shapes.reduce((total, shape) => total + shape.area(), 0);
}
```

### 8.7.2 代码组织建议

1. **模块化设计**：将相关的类组织在模块中，提高代码的可维护性。
2. **避免深层嵌套**：尽量保持继承层次简单，避免过深的继承链。
3. **使用组合优于继承**：优先考虑使用组合而不是继承来扩展功能。
4. **保持类的内聚性**：确保类的成员方法和属性都是紧密相关的。
5. **减少类的耦合度**：尽量降低类之间的依赖关系。

## 8.8 总结与练习

### 8.8.1 本章要点

1. **面向对象编程基础**：理解面向对象编程的核心概念，包括对象、类、继承、封装和多态。
2. **JavaScript中的对象**：掌握JavaScript中对象的创建方式和属性操作。
3. **原型与原型链**：理解JavaScript中基于原型的继承机制。
4. **ES6类与继承**：掌握ES6引入的类语法和继承方式。
5. **多态与接口**：理解多态的实现和接口的模拟方式。
6. **设计模式入门**：了解常见的面向对象设计模式及其应用。
7. **面向对象的实际应用**：通过实际案例学习如何应用面向对象编程。

### 8.8.2 实践练习

1. **练习1：图书管理系统**
   - 创建`Book`类，包含书名、作者、ISBN和价格属性
   - 创建`Library`类，管理图书的借出和归还
   - 实现`Member`类，记录会员信息和借阅历史
   - 实现图书的搜索功能

2. **练习2：动物王国模拟器**
   - 创建`Animal`基类，包含基本属性和方法
   - 创建不同的动物子类（如哺乳动物、鸟类、鱼类）
   - 实现动物的繁殖和进化机制
   - 创建生态系统管理器，模拟动物之间的相互作用

3. **练习3：简单计算器**
   - 创建`Calculator`类，实现基本的数学运算
   - 使用装饰器模式添加历史记录功能
   - 实现运算符优先级处理
   - 添加错误处理机制

通过本章的学习，你应该已经掌握了JavaScript面向对象编程的核心概念和技术。面向对象编程不仅是一种编程技巧，更是一种思维方式，它可以帮助我们更好地组织代码、提高代码的可维护性和可扩展性。在下一章中，我们将探讨JavaScript的高级特性，进一步扩展我们的编程能力。