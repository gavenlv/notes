<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript 闭包与作用域详解</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        
        h1, h2, h3, h4 {
            color: #2c3e50;
        }
        
        h1 {
            text-align: center;
            border-bottom: 2px solid #e74c3c;
            padding-bottom: 10px;
            margin-bottom: 40px;
        }
        
        h2 {
            border-left: 4px solid #e74c3c;
            padding-left: 15px;
            margin-top: 50px;
        }
        
        h3 {
            color: #e74c3c;
            margin-top: 30px;
        }
        
        .container {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .code-block {
            background-color: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 6px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        
        .code-line {
            display: block;
        }
        
        .comment {
            color: #98c379;
        }
        
        .keyword {
            color: #c678dd;
        }
        
        .string {
            color: #e5c07b;
        }
        
        .function {
            color: #61afef;
        }
        
        .demo-section {
            margin-bottom: 40px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 6px;
        }
        
        button {
            background-color: #e74c3c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #c0392b;
        }
        
        .result {
            background-color: #e8f4f8;
            border: 1px solid #b3e5fc;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
        }
        
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-item {
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #ddd;
        }
        
        .before {
            background-color: #f8d7da;
            border-left: 4px solid #dc3545;
        }
        
        .after {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
        }
        
        .explanation {
            background-color: #e7f3ff;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 4px solid #0d6efd;
        }
        
        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }
        
        .pros {
            background-color: #d4edda;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #28a745;
        }
        
        .cons {
            background-color: #f8d7da;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #dc3545;
        }
        
        ul {
            padding-left: 20px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        .diagram {
            background-color: #f0f0f0;
            padding: 20px;
            border-radius: 6px;
            text-align: center;
            margin: 20px 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background-color: #f2f2f2;
        }
        
        tr:hover {
            background-color: #f5f5f5;
        }
        
        .highlight {
            background-color: #ffeb3b;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .note {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 4px solid #ffc107;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .comparison,
            .pros-cons {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 15px;
            }
            
            body {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <h1>JavaScript 闭包与作用域详解</h1>
    
    <div class="container">
        <p>本教程深入探讨 JavaScript 中的闭包（Closures）和作用域（Scope）概念，这是理解 JavaScript 执行机制的关键知识点。掌握闭包和作用域对于编写高效、可维护的代码至关重要。</p>
    </div>

    <!-- 1. 作用域基础 -->
    <section class="demo-section">
        <h2>1. 作用域基础</h2>
        <div class="explanation">
            <p>作用域是指变量、函数和对象在代码中可访问的范围，它决定了代码中不同部分对变量的可见性。</p>
            <p>JavaScript 中的作用域分为以下几种类型：</p>
            <ul>
                <li><strong>全局作用域</strong>：在任何地方都能访问的变量</li>
                <li><strong>函数作用域</strong>：在函数内部定义的变量，只在函数内部可访问</li>
                <li><strong>块级作用域</strong>：在代码块（如 if、for、while 等）内部定义的变量，使用 let 和 const 声明</li>
            </ul>
        </div>

        <h3>1.1 全局作用域</h3>
        <div class="code-block">
<span class="comment">// 全局作用域中的变量</span>
<span class="keyword">const</span> globalVar = "我是全局变量";

<span class="keyword">function</span> <span class="function">accessGlobal</span>() {
    console.log(globalVar); <span class="comment">// 可以访问全局变量</span>
}

accessGlobal(); <span class="comment">// 输出: 我是全局变量</span>
console.log(globalVar); <span class="comment">// 输出: 我是全局变量</span>

<span class="comment">// 隐式全局变量 - 不推荐使用</span>
<span class="keyword">function</span> <span class="function">createGlobal</span>() {
    implicitGlobal = "我是隐式全局变量"; <span class="comment">// 没有使用 var/let/const</span>
}

createGlobal();
console.log(implicitGlobal); <span class="comment">// 输出: 我是隐式全局变量</span>
        </div>

        <h3>1.2 函数作用域</h3>
        <div class="code-block">
<span class="keyword">function</span> <span class="function">functionScope</span>() {
    <span class="keyword">var</span> localVar = "我是局部变量";
    <span class="keyword">let</span> blockVar = "我是块变量";
    
    console.log(localVar); <span class="comment">// 输出: 我是局部变量</span>
    console.log(blockVar); <span class="comment">// 输出: 我是块变量</span>
}

functionScope();

<span class="keyword">try</span> {
    console.log(localVar); <span class="comment">// 引用错误: localVar is not defined</span>
} <span class="keyword">catch</span> (e) {
    console.log("错误: " + e.message);
}

<span class="keyword">try</span> {
    console.log(blockVar); <span class="comment">// 引用错误: blockVar is not defined</span>
} <span class="keyword">catch</span> (e) {
    console.log("错误: " + e.message);
}
        </div>

        <h3>1.3 块级作用域</h3>
        <div class="code-block">
<span class="comment">// 使用 var 声明的变量没有块级作用域</span>
<span class="keyword">if</span> (true) {
    <span class="keyword">var</span> varVar = "使用 var 声明";
    console.log(varVar); <span class="comment">// 输出: 使用 var 声明</span>
}
console.log(varVar); <span class="comment">// 输出: 使用 var 声明 - 可以在块外部访问</span>

<span class="comment">// 使用 let 和 const 声明的变量具有块级作用域</span>
<span class="keyword">if</span> (true) {
    <span class="keyword">let</span> letVar = "使用 let 声明";
    <span class="keyword">const</span> constVar = "使用 const 声明";
    console.log(letVar);  <span class="comment">// 输出: 使用 let 声明</span>
    console.log(constVar); <span class="comment">// 输出: 使用 const 声明</span>
}

<span class="keyword">try</span> {
    console.log(letVar);  <span class="comment">// 引用错误: letVar is not defined</span>
} <span class="keyword">catch</span> (e) {
    console.log("错误: " + e.message);
}

<span class="keyword">try</span> {
    console.log(constVar); <span class="comment">// 引用错误: constVar is not defined</span>
} <span class="keyword">catch</span> (e) {
    console.log("错误: " + e.message);
}

<span class="comment">// 在循环中使用块级作用域</span>
<span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100); <span class="comment">// 输出: 0, 1, 2</span>
}

<span class="keyword">for</span> (<span class="keyword">var</span> j = 0; j < 3; j++) {
    setTimeout(() => console.log(j), 100); <span class="comment">// 输出: 3, 3, 3</span>
}
        </div>
        
        <button onclick="runScopeDemo()">运行作用域演示</button>
        <div id="scopeResult" class="result">点击按钮查看运行结果...</div>
    </section>

    <!-- 2. 词法作用域 -->
    <section class="demo-section">
        <h2>2. 词法作用域</h2>
        <div class="explanation">
            <p>JavaScript 采用词法作用域（也称为静态作用域），这意味着变量的作用域是在代码编写时确定的，而不是在运行时确定的。</p>
            <p>词法作用域的规则：</p>
            <ul>
                <li>每个函数在定义时就确定了其作用域链</li>
                <li>内部函数可以访问外部函数中声明的变量</li>
                <li>函数的作用域链包含函数自己的作用域和所有父级作用域</li>
            </ul>
        </div>

        <div class="code-block">
<span class="comment">// 词法作用域示例</span>
<span class="keyword">var</span> globalVar = "全局变量";

<span class="keyword">function</span> <span class="function">outer</span>() {
    <span class="keyword">var</span> outerVar = "外部函数变量";
    
    <span class="keyword">function</span> <span class="function">inner</span>() {
        <span class="keyword">var</span> innerVar = "内部函数变量";
        
        <span class="comment">// inner 函数可以访问自己、outer 和全局作用域中的变量</span>
        console.log(innerVar);  <span class="comment">// 输出: 内部函数变量</span>
        console.log(outerVar);  <span class="comment">// 输出: 外部函数变量</span>
        console.log(globalVar); <span class="comment">// 输出: 全局变量</span>
    }
    
    inner();
    
    <span class="comment">// outer 函数可以访问自己和全局作用域中的变量</span>
    console.log(outerVar);  <span class="comment">// 输出: 外部函数变量</span>
    console.log(globalVar); <span class="comment">// 输出: 全局变量</span>
    
    <span class="comment">// outer 函数不能访问 inner 函数作用域中的变量</span>
    <span class="keyword">try</span> {
        console.log(innerVar); <span class="comment">// 引用错误: innerVar is not defined</span>
    } <span class="keyword">catch</span> (e) {
        console.log("错误: " + e.message);
    }
}

outer();

<span class="comment">// 全局作用域只能访问全局变量</span>
console.log(globalVar); <span class="comment">// 输出: 全局变量</span>
        </div>

        <div class="note">
            重要：词法作用域的关键是"在哪里定义"而不是"在哪里执行"。这是理解闭包的基础。
        </div>
        
        <div class="diagram">
            <h4>词法作用域层级结构</h4>
            <p>全局作用域</p>
            <p>└── 外部函数作用域</p>
            <p>    └── 内部函数作用域</p>
            <p><br>内部函数可以访问所有外部作用域的变量<br>外部函数不能访问内部函数的变量</p>
        </div>
        
        <button onclick="runLexicalScopeDemo()">运行词法作用域演示</button>
        <div id="lexicalScopeResult" class="result">点击按钮查看运行结果...</div>
    </section>

    <!-- 3. 闭包的概念 -->
    <section class="demo-section">
        <h2>3. 闭包的概念</h2>
        <div class="explanation">
            <p>闭包是指有权访问另一个函数作用域中变量的函数。换句话说，闭包是函数和声明该函数的词法环境的组合。</p>
            <p>当一个函数能够记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。</p>
        </div>

        <h3>3.1 闭包的基本示例</h3>
        <div class="code-block">
<span class="keyword">function</span> <span class="function">createCounter</span>() {
    <span class="keyword">let</span> count = 0; <span class="comment">// 私有变量</span>
    
    <span class="keyword">return</span> {
        increment: <span class="keyword">function</span>() {
            count++; <span class="comment">// 可以访问 count 变量</span>
            <span class="keyword">return</span> count;
        },
        decrement: <span class="keyword">function</span>() {
            count--; <span class="comment">// 可以访问 count 变量</span>
            <span class="keyword">return</span> count;
        },
        getCount: <span class="keyword">function</span>() {
            <span class="keyword">return</span> count; <span class="comment">// 可以访问 count 变量</span>
        }
    };
}

<span class="keyword">const</span> counter = createCounter(); <span class="comment">// 创建闭包</span>

console.log(counter.getCount()); <span class="comment">// 输出: 0</span>
console.log(counter.increment()); <span class="comment">// 输出: 1</span>
console.log(counter.increment()); <span class="comment">// 输出: 2</span>
console.log(counter.decrement()); <span class="comment">// 输出: 1</span>
console.log(counter.getCount()); <span class="comment">// 输出: 1</span>

<span class="comment">// 无法直接访问 count 变量</span>
console.log(counter.count); <span class="comment">// 输出: undefined</span>

<span class="comment">// 创建多个独立的闭包</span>
<span class="keyword">const</span> counter1 = createCounter();
<span class="keyword">const</span> counter2 = createCounter();

counter1.increment(); <span class="comment">// counter1 变为 1</span>
console.log(counter1.getCount()); <span class="comment">// 输出: 1</span>
console.log(counter2.getCount()); <span class="comment">// 输出: 0 - counter2 不受影响</span>
        </div>

        <h3>3.2 闭包的工作原理</h3>
        <div class="explanation">
            <p>闭包的工作原理基于以下几点：</p>
            <ol>
                <li>当函数被定义时，会创建一个闭包，这个闭包包含了函数本身和函数声明时的词法环境</li>
                <li>词法环境包含了函数可以访问的所有变量</li>
                <li>当函数在其定义的词法环境之外被调用时，它仍然可以通过闭包访问到原来的词法环境中的变量</li>
                <li>每次调用外部函数都会创建一个新的闭包和新的词法环境</li>
            </ol>
        </div>

        <div class="diagram">
            <h4>闭包工作原理示意图</h4>
            <p>外部函数 createCounter()</p>
            <p>    ↓ 创建本地变量 count = 0</p>
            <p>    ↓ 返回内部函数对象</p>
            <p>内部函数 increment(), decrement(), getCount()</p>
            <p>    ↓ 包含对外部变量 count 的引用</p>
            <p>    ↓ 即使 createCounter() 执行完毕，也能访问 count</p>
        </div>
        
        <button onclick="runClosureDemo()">运行闭包演示</button>
        <div id="closureResult" class="result">点击按钮查看运行结果...</div>
    </section>

    <!-- 4. 闭包的实际应用 -->
    <section class="demo-section">
        <h2>4. 闭包的实际应用</h2>
        <div class="explanation">
            <p>闭包在 JavaScript 中有许多实际应用场景，下面介绍一些常见的使用方式。</p>
        </div>

        <h3>4.1 数据私有化</h3>
        <div class="code-block">
<span class="comment">// 使用闭包实现数据私有化</span>
<span class="keyword">function</span> <span class="function">createPerson</span>(name, age) {
    <span class="comment">// 私有变量</span>
    <span class="keyword">let</span> _name = name;
    <span class="keyword">let</span> _age = age;
    
    <span class="comment">// 返回公共方法</span>
    <span class="keyword">return</span> {
        <span class="comment">// getter 方法</span>
        getName: <span class="keyword">function</span>() {
            <span class="keyword">return</span> _name;
        },
        getAge: <span class="keyword">function</span>() {
            <span class="keyword">return</span> _age;
        },
        
        <span class="comment">// setter 方法</span>
        setName: <span class="keyword">function</span>(newName) {
            <span class="keyword">if</span> (typeof newName === 'string' \u0026\u0026 newName.trim() !== '') {
                _name = newName;
            }
        },
        setAge: <span class="keyword">function</span>(newAge) {
            <span class="keyword">if</span> (typeof newAge === 'number' \u0026\u0026 newAge >= 0) {
                _age = newAge;
            }
        },
        
        // 方法
        celebrateBirthday: <span class="keyword">function</span>() {
            _age++;
            <span class="keyword">return</span> `${_name} 现在 ${_age} 岁了！`;
        }
    };
}

<span class="keyword">const</span> person = createPerson("张三", 30);

console.log(person.getName()); <span class="comment">// 输出: 张三</span>
console.log(person.getAge());  <span class="comment">// 输出: 30</span>

person.setName("李四");
person.setAge(35);

console.log(person.getName()); <span class="comment">// 输出: 李四</span>
console.log(person.getAge());  <span class="comment">// 输出: 35</span>

<span class="comment">// 尝试设置无效值</span>
person.setName(""); <span class="comment">// 不会改变 _name</span>
person.setAge(-5);  <span class="comment">// 不会改变 _age</span>

console.log(person.getName()); <span class="comment">// 输出: 李四</span>
console.log(person.getAge());  <span class="comment">// 输出: 35</span>

<span class="comment">// 使用方法</span>
console.log(person.celebrateBirthday()); <span class="comment">// 输出: 李四 现在 36 岁了！</span>

<span class="comment">// 无法直接访问私有变量</span>
console.log(person._name); <span class="comment">// 输出: undefined</span>
console.log(person._age);  <span class="comment">// 输出: undefined</span>
        </div>

        <h3>4.2 函数工厂</h3>
        <div class="code-block">
<span class="comment">// 使用闭包创建函数工厂</span>
<span class="keyword">function</span> <span class="function">createMultiplier</span>(multiplier) {
    <span class="comment">// multiplier 被闭包捕获</span>
    <span class="keyword">return</span> <span class="keyword">function</span>(number) {
        <span class="keyword">return</span> number * multiplier;
    };
}

<span class="comment">// 创建多个乘法函数</span>
<span class="keyword">const</span> double = createMultiplier(2);
<span class="keyword">const</span> triple = createMultiplier(3);
<span class="keyword">const</span> quadruple = createMultiplier(4);

<span class="comment">// 使用这些函数</span>
console.log(double(5));    <span class="comment">// 输出: 10</span>
console.log(triple(5));    <span class="comment">// 输出: 15</span>
console.log(quadruple(5)); <span class="comment">// 输出: 20</span>

<span class="comment">// 另一个函数工厂示例 - 创建问候函数</span>
<span class="keyword">function</span> <span class="function">createGreeting</span>(greeting) {
    <span class="keyword">return</span> <span class="keyword">function</span>(name) {
        <span class="keyword">return</span> `${greeting}, ${name}!`;
    };
}

<span class="keyword">const</span> sayHello = createGreeting("你好");
<span class="keyword">const</span> sayGoodbye = createGreeting("再见");

console.log(sayHello("张三"));     <span class="comment">// 输出: 你好, 张三!</span>
console.log(sayGoodbye("李四"));   <span class="comment">// 输出: 再见, 李四!</span>
        </div>

        <h3>4.3 模块化设计</h3>
        <div class="code-block">
<span class="comment">// 使用闭包实现模块化</span>
<span class="keyword">const</span> MathModule = (<span class="keyword">function</span>() {
    <span class="comment">// 私有变量</span>
    <span class="keyword">const</span> PI = 3.14159265359;
    
    <span class="comment">// 私有辅助函数</span>
    <span class="keyword">function</span> <span class="function">validateNumber</span>(n) {
        <span class="keyword">return</span> typeof n === 'number' \u0026\u0026 !isNaN(n);
    }
    
    <span class="comment">// 公共API - 返回的对象将成为模块的公共接口</span>
    <span class="keyword">return</span> {
        <span class="comment">// 公共常量</span>
        getPI: <span class="keyword">function</span>() {
            <span class="keyword">return</span> PI;
        },
        
        <span class="comment">// 数学运算</span>
        add: <span class="keyword">function</span>(a, b) {
            <span class="keyword">if</span> (validateNumber(a) \u0026\u0026 validateNumber(b)) {
                <span class="keyword">return</span> a + b;
            }
            <span class="keyword">throw</span> <span class="keyword">new</span> Error("参数必须是有效的数字");
        },
        
        subtract: <span class="keyword">function</span>(a, b) {
            <span class="keyword">if</span> (validateNumber(a) \u0026\u0026 validateNumber(b)) {
                <span class="keyword">return</span> a - b;
            }
            <span class="keyword">throw</span> <span class="keyword">new</span> Error("参数必须是有效的数字");
        },
        
        multiply: <span class="keyword">function</span>(a, b) {
            <span class="keyword">if</span> (validateNumber(a) \u0026\u0026 validateNumber(b)) {
                <span class="keyword">return</span> a * b;
            }
            <span class="keyword">throw</span> <span class="keyword">new</span> Error("参数必须是有效的数字");
        },
        
        divide: <span class="keyword">function</span>(a, b) {
            <span class="keyword">if</span> (validateNumber(a) \u0026\u0026 validateNumber(b)) {
                <span class="keyword">if</span> (b === 0) {
                    <span class="keyword">throw</span> <span class="keyword">new</span> Error("除数不能为零");
                }
                <span class="keyword">return</span> a / b;
            }
            <span class="keyword">throw</span> <span class="keyword">new</span> Error("参数必须是有效的数字");
        },
        
        <span class="comment">// 几何计算</span>
        calculateCircleArea: <span class="keyword">function</span>(radius) {
            <span class="keyword">if</span> (validateNumber(radius) \u0026\u0026 radius >= 0) {
                <span class="keyword">return</span> PI * radius * radius;
            }
            <span class="keyword">throw</span> <span class="keyword">new</span> Error("半径必须是非负数");
        }
    };
})(); <span class="comment">// 立即执行函数表达式 (IIFE)</span>

<span class="comment">// 使用模块</span>
console.log("PI =", MathModule.getPI());  <span class="comment">// 输出: PI = 3.14159265359</span>
console.log("5 + 3 =", MathModule.add(5, 3));  <span class="comment">// 输出: 5 + 3 = 8</span>
console.log("10 - 4 =", MathModule.subtract(10, 4));  <span class="comment">// 输出: 10 - 4 = 6</span>
console.log("6 * 7 =", MathModule.multiply(6, 7));  <span class="comment">// 输出: 6 * 7 = 42</span>
console.log("20 / 5 =", MathModule.divide(20, 5));  <span class="comment">// 输出: 20 / 5 = 4</span>
console.log("半径为 5 的圆面积 =", MathModule.calculateCircleArea(5));  <span class="comment">// 输出: 半径为 5 的圆面积 = 78.53981633975</span>

<span class="comment">// 无法访问私有变量和方法</span>
console.log(MathModule.PI);  <span class="comment">// 输出: undefined</span>
console.log(MathModule.validateNumber);  <span class="comment">// 输出: undefined</span>
        </div>

        <h3>4.4 记忆化（Memoization）</h3>
        <div class="code-block">
<span class="comment">// 使用闭包实现函数记忆化</span>
<span class="keyword">function</span> <span class="function">memoize</span>(fn) {
    <span class="comment">// 缓存结果的对象</span>
    <span class="keyword">const</span> cache = {};
    
    <span class="keyword">return</span> <span class="keyword">function</span>(...args) {
        <span class="comment">// 创建缓存键</span>
        <span class="keyword">const</span> key = JSON.stringify(args);
        
        <span class="comment">// 检查结果是否已缓存</span>
        <span class="keyword">if</span> (key in cache) {
            console.log(`从缓存返回结果: ${key}`);
            <span class="keyword">return</span> cache[key];
        }
        
        <span class="comment">// 计算结果并缓存</span>
        console.log(`计算新结果: ${key}`);
        <span class="keyword">const</span> result = fn.apply(this, args);
        cache[key] = result;
        
        <span class="keyword">return</span> result;
    };
}

<span class="comment">// 测试 - 计算斐波那契数列</span>
<span class="keyword">function</span> <span class="function">fibonacci</span>(n) {
    <span class="keyword">if</span> (n <= 1) <span class="keyword">return</span> n;
    <span class="keyword">return</span> fibonacci(n - 1) + fibonacci(n - 2);
}

<span class="comment">// 创建记忆化版本的斐波那契函数</span>
<span class="keyword">const</span> memoizedFibonacci = memoize(<span class="keyword">function</span>(n) {
    <span class="keyword">if</span> (n <= 1) <span class="keyword">return</span> n;
    <span class="keyword">return</span> memoizedFibonacci(n - 1) + memoizedFibonacci(n - 2);
});

<span class="comment">// 测试记忆化效果</span>
console.log("计算 fibonacci(10):");
console.time("未优化版本");
console.log(fibonacci(30)); <span class="comment">// 这会非常慢</span>
console.timeEnd("未优化版本");

console.log("\n计算 memoizedFibonacci(10):");
console.time("记忆化版本");
console.log(memoizedFibonacci(30)); <span class="comment">// 第一次计算</span>
console.timeEnd("记忆化版本");

console.log("\n再次计算 memoizedFibonacci(10):");
console.time("记忆化版本(缓存)");
console.log(memoizedFibonacci(30)); <span class="comment">// 使用缓存的结果</span>
console.timeEnd("记忆化版本(缓存)");
        </div>
        
        <button onclick="runApplicationDemo()">运行实际应用演示</button>
        <div id="applicationResult" class="result">点击按钮查看运行结果...</div>
    </section>

    <!-- 5. 闭包的陷阱与注意事项 -->
    <section class="demo-section">
        <h2>5. 闭包的陷阱与注意事项</h2>
        <div class="explanation">
            <p>虽然闭包非常有用，但也需要注意一些潜在的问题和陷阱。</p>
        </div>

        <h3>5.1 内存泄漏</h3>
        <div class="code-block">
<span class="comment">// 闭包可能导致的内存泄漏示例</span>
<span class="keyword">function</span> <span class="function">createHeavyObject</span>() {
    <span class="comment">// 创建一个大对象</span>
    <span class="keyword">const</span> largeData = <span class="keyword">new</span> Array(1000000).fill('data');
    
    <span class="keyword">return</span> <span class="keyword">function</span>() {
        <span class="comment">// 即使只使用 largeData 的一小部分，整个 largeData 仍会被保留在内存中</span>
        console.log(`数据大小: ${largeData.length}`);
        <span class="keyword">return</span> largeData[0];
    };
}

<span class="comment">// 使用后没有正确释放</span>
<span class="keyword">const</span> getDataReference = createHeavyObject();

<span class="comment">// 即使不使用了，如果 getDataReference 仍然存在，largeData 就不会被垃圾回收</span>
<span class="comment">// getDataReference = null; // 取消引用以允许垃圾回收</span>
        </div>

        <h3>5.2 循环中的闭包陷阱</h3>
        <div class="comparison">
            <div class="comparison-item before">
                <h4>问题代码</h4>
                <div class="code-block">
<span class="comment">// 循环中的闭包常见问题</span>
<span class="keyword">function</span> <span class="function">setupBadHandlers</span>() {
    <span class="keyword">for</span> (<span class="keyword">var</span> i = 0; i < 5; i++) {
        <span class="comment">// 所有函数共享同一个 i 变量的引用</span>
        setTimeout(<span class="keyword">function</span>() {
            console.log(`索引: ${i}`);
        }, i * 100);
    }
    <span class="comment">// 输出: 5, 5, 5, 5, 5</span>
    <span class="comment">// 而不是期望的: 0, 1, 2, 3, 4</span>
}

setupBadHandlers();
                </div>
            </div>
            <div class="comparison-item after">
                <h4>解决方案</h4>
                <div class="code-block">
<span class="comment">// 解决方案 1: 使用 IIFE 为每个迭代创建新的作用域</span>
<span class="keyword">function</span> <span class="function">setupGoodHandlers1</span>() {
    <span class="keyword">for</span> (<span class="keyword">var</span> i = 0; i < 5; i++) {
        (<span class="keyword">function</span>(index) {
            setTimeout(<span class="keyword">function</span>() {
                console.log(`索引: ${index}`);
            }, index * 100);
        })(i);
    }
    <span class="comment">// 输出: 0, 1, 2, 3, 4</span>
}

<span class="comment">// 解决方案 2: 使用 let 创建块级作用域</span>
<span class="keyword">function</span> <span class="function">setupGoodHandlers2</span>() {
    <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < 5; i++) {
        <span class="comment">// 每个迭代都有自己的 i 变量</span>
        setTimeout(<span class="keyword">function</span>() {
            console.log(`索引: ${i}`);
        }, i * 100);
    }
    <span class="comment">// 输出: 0, 1, 2, 3, 4</span>
}

<span class="comment">// 解决方案 3: 使用函数工厂</span>
<span class="keyword">function</span> <span class="function">createHandler</span>(index) {
    <span class="keyword">return</span> <span class="keyword">function</span>() {
        console.log(`索引: ${index}`);
    };
}

<span class="keyword">function</span> <span class="function">setupGoodHandlers3</span>() {
    <span class="keyword">for</span> (<span class="keyword">var</span> i = 0; i < 5; i++) {
        setTimeout(createHandler(i), i * 100);
    }
    <span class="comment">// 输出: 0, 1, 2, 3, 4</span>
}

setupGoodHandlers1();
<span class="comment">// setupGoodHandlers2(); // 取消注释测试</span>
<span class="comment">// setupGoodHandlers3(); // 取消注释测试</span>
                </div>
            </div>
        </div>

        <h3>5.3 性能考虑</h3>
        <div class="explanation">
            <ul>
                <li><strong>内存消耗</strong>：闭包会保留外部变量，即使这些变量不再需要，这可能导致内存占用增加</li>
                <li><strong>执行效率</strong>：闭包涉及到作用域链的查找，可能比直接访问局部变量稍慢</li>
                <li><strong>频繁创建</strong>：在循环中频繁创建闭包可能导致性能问题</li>
            </ul>
        </div>

        <h3>5.4 最佳实践</h3>
        <div class="code-block">
<span class="comment">// 闭包最佳实践</span>

<span class="comment">// 1. 只捕获必要的变量</span>
<span class="keyword">function</span> <span class="function">bestPractice1</span>() {
    <span class="keyword">const</span> neededVariable = "需要的值";
    <span class="keyword">const</span> largeUnneededData = <span class="keyword">new</span> Array(1000000).fill('data');
    
    <span class="comment">// 只返回需要用到 neededVariable 的函数</span>
    <span class="keyword">return</span> <span class="keyword">function</span>() {
        <span class="keyword">return</span> neededVariable;
    };
    
    <span class="comment">// 注意: 实际上 largeUnneededData 仍会被保留在闭包中</span>
    <span class="comment">// 更好的做法是将不需要的变量放在闭包外部</span>
}

<span class="comment">// 更好的写法</span>
<span class="keyword">function</span> <span class="function">betterPractice1</span>() {
    <span class="comment">// largeUnneededData 不再被闭包捕获</span>
    
    <span class="keyword">function</span> <span class="function">createInnerFunction</span>() {
        <span class="keyword">const</span> neededVariable = "需要的值";
        <span class="keyword">return</span> <span class="keyword">function</span>() {
            <span class="keyword">return</span> neededVariable;
        };
    }
    
    <span class="keyword">return</span> createInnerFunction();
}

<span class="comment">// 2. 使用完闭包后释放引用</span>
<span class="keyword">function</span> <span class="function">useAndRelease</span>() {
    <span class="keyword">let</span> heavyClosure = createHeavyObject();
    
    <span class="comment">// 使用闭包</span>
    console.log(heavyClosure());
    
    <span class="comment">// 使用完毕后释放引用，允许垃圾回收</span>
    heavyClosure = null;
}

<span class="comment">// 3. 避免在循环中创建闭包</span>
<span class="keyword">function</span> <span class="function">loopWithClosures</span>() {
    <span class="comment">// 预先定义处理函数</span>
    <span class="keyword">function</span> <span class="function">handleItem</span>(item) {
        console.log(item);
    }
    
    <span class="keyword">const</span> items = [1, 2, 3, 4, 5];
    
    <span class="comment">// 使用 forEach 或 map 代替手动循环</span>
    items.forEach(handleItem);
    
    <span class="comment">// 或者使用 let 创建块级作用域</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = 0; i < items.length; i++) {
        setTimeout(<span class="keyword">function</span>() {
            console.log(items[i]);
        }, i * 100);
    }
}
        </div>
        
        <button onclick="runPitfallsDemo()">运行陷阱演示</button>
        <div id="pitfallsResult" class="result">点击按钮查看运行结果...</div>
    </section>

    <!-- 6. 作用域链与执行上下文 -->
    <section class="demo-section">
        <h2>6. 作用域链与执行上下文</h2>
        <div class="explanation">
            <p>要深入理解闭包，需要了解作用域链和执行上下文的概念。</p>
        </div>

        <h3>6.1 执行上下文</h3>
        <div class="explanation">
            <p>执行上下文是 JavaScript 代码执行时的环境，它包含以下内容：</p>
            <ul>
                <li><strong>变量对象（Variable Object）</strong>：包含函数参数、变量和函数声明</li>
                <li><strong>作用域链（Scope Chain）</strong>：用于解析变量引用的链状结构</li>
                <li><strong>this 值</strong>：当前执行上下文的 this 绑定</li>
            </ul>
        </div>

        <div class="code-block">
<span class="comment">// 执行上下文示例</span>
<span class="keyword">var</span> globalVar = "全局变量";

<span class="keyword">function</span> <span class="function">outerFunction</span>(param) {
    <span class="keyword">var</span> outerVar = "外部变量";
    
    <span class="keyword">function</span> <span class="function">innerFunction</span>() {
        <span class="keyword">var</span> innerVar = "内部变量";
        console.log(innerVar);  <span class="comment">// 内部变量</span>
        console.log(outerVar);  <span class="comment">// 外部变量</span>
        console.log(param);     <span class="comment">// 参数</span>
        console.log(globalVar); <span class="comment">// 全局变量</span>
    }
    
    <span class="keyword">return</span> innerFunction;
}

<span class="keyword">const</span> closure = outerFunction("函数参数");
closure();
        </div>

        <h3>6.2 作用域链</h3>
        <div class="explanation">
            <p>作用域链是一个对象列表，用于在标识符解析过程中查找变量。当查找一个变量时，JavaScript 会从当前作用域开始，如果找不到，就会沿着作用域链向上查找，直到找到变量或者达到全局作用域。</p>
        </div>

        <div class="diagram">
            <h4>作用域链结构</h4>
            <p>innerFunction 作用域</p>
            <p>    ↓ 包含: innerVar</p>
            <p>    ↓ 引用父级作用域</p>
            <p>outerFunction 作用域</p>
            <p>    ↓ 包含: outerVar, param</p>
            <p>    ↓ 引用父级作用域</p>
            <p>全局作用域</p>
            <p>    ↓ 包含: globalVar, outerFunction</p>
        </div>

        <h3>6.3 变量提升与函数提升</h3>
        <div class="code-block">
<span class="comment">// 变量提升（Hoisting）</span>
<span class="comment">// 变量声明会被提升到作用域顶部，但赋值不会</span>

console.log(x); <span class="comment">// 输出: undefined - 变量已声明但未赋值</span>
<span class="keyword">var</span> x = 5;
console.log(x); <span class="comment">// 输出: 5</span>

<span class="comment">// 上面的代码在执行前会被解释为:</span>
<span class="comment">// var x; // 变量声明被提升</span>
<span class="comment">// console.log(x);</span>
<span class="comment">// x = 5;</span>
<span class="comment">// console.log(x);</span>

<span class="comment">// let 和 const 不会被提升到作用域顶部</span>
<span class="keyword">try</span> {
    console.log(y); <span class="comment">// 引用错误: Cannot access 'y' before initialization</span>
    <span class="keyword">let</span> y = 10;
} <span class="keyword">catch</span> (e) {
    console.log("错误: " + e.message);
}

<span class="comment">// 函数提升（Function Hoisting）</span>
<span class="comment">// 函数声明会被完全提升（包括函数体）</span>

sayHello(); <span class="comment">// 输出: Hello! - 函数可以在声明前调用</span>

<span class="keyword">function</span> <span class="function">sayHello</span>() {
    console.log("Hello!");
}

<span class="comment">// 函数表达式不会被提升</span>
<span class="keyword">try</span> {
    sayHi(); <span class="comment">// 类型错误: sayHi is not a function</span>
    <span class="keyword">var</span> sayHi = <span class="keyword">function</span>() {
        console.log("Hi!");
    };
} <span class="keyword">catch</span> (e) {
    console.log("错误: " + e.message);
}
        </div>
        
        <button onclick="runScopeChainDemo()">运行作用域链演示</button>
        <div id="scopeChainResult" class="result">点击按钮查看运行结果...</div>
    </section>

    <!-- 7. 闭包与现代 JavaScript -->
    <section class="demo-section">
        <h2>7. 闭包与现代 JavaScript</h2>
        <div class="explanation">
            <p>在现代 JavaScript 中，闭包仍然是核心概念，但 ES6+ 提供了一些新的特性，可以让我们以更优雅的方式实现一些模式。</p>
        </div>

        <h3>7.1 ES6+ 中的闭包应用</h3>
        <div class="code-block">
<span class="comment">// 使用箭头函数简化闭包</span>
<span class="keyword">function</span> <span class="function">createCounterES6</span>() {
    <span class="keyword">let</span> count = 0;
    
    <span class="keyword">return</span> {
        increment: () => ++count,
        decrement: () => --count,
        getCount: () => count
    };
}

<span class="comment">// 使用类实现封装</span>
<span class="keyword">class</span> <span class="function">CounterClass</span> {
    <span class="comment">// 使用私有字段（需要现代浏览器支持）</span>
    #count = 0;
    
    increment() {
        <span class="keyword">return</span> ++this.#count;
    }
    
    decrement() {
        <span class="keyword">return</span> --this.#count;
    }
    
    getCount() {
        <span class="keyword">return</span> this.#count;
    }
}

<span class="comment">// 使用 Symbol 实现私有属性</span>
<span class="keyword">const</span> _count = Symbol('count');

<span class="keyword">class</span> <span class="function">CounterWithSymbol</span> {
    constructor() {
        this[_count] = 0;
    }
    
    increment() {
        <span class="keyword">return</span> ++this[_count];
    }
    
    getCount() {
        <span class="keyword">return</span> this[_count];
    }
}

<span class="comment">// 使用 WeakMap 实现私有属性</span>
<span class="keyword">const</span> privateData = <span class="keyword">new</span> WeakMap();

<span class="keyword">class</span> <span class="function">CounterWithWeakMap</span> {
    constructor() {
        privateData.set(this, { count: 0 });
    }
    
    increment() {
        <span class="keyword">const</span> data = privateData.get(this);
        data.count++;
        <span class="keyword">return</span> data.count;
    }
    
    getCount() {
        <span class="keyword">return</span> privateData.get(this).count;
    }
}

<span class="comment">// 使用示例</span>
<span class="keyword">const</span> counterES6 = createCounterES6();
<span class="keyword">const</span> counterClass = <span class="keyword">new</span> CounterClass();

console.log(counterES6.increment()); <span class="comment">// 输出: 1</span>
console.log(counterES6.getCount());  <span class="comment">// 输出: 1</span>
console.log(counterClass.increment()); <span class="comment">// 输出: 1</span>
console.log(counterClass.getCount());  <span class="comment">// 输出: 1</span>
        </div>

        <h3>7.2 React 中的闭包应用</h3>
        <div class="code-block">
<span class="comment">// React 中闭包的应用示例</span>

<span class="comment">// 1. 使用 useState 钩子</span>
<span class="comment">// function Counter() {
//     const [count, setCount] = useState(0);
//     
//     // increment 函数形成闭包，捕获 count 状态
//     const increment = () => {
//         setCount(count + 1);
//     };
//     
//     return (
//         <div>
//             <p>Count: {count}</p>
//             <button onClick={increment}>Increment</button>
//         </div>
//     );
// }</span>

<span class="comment">// 2. useEffect 依赖数组</span>
<span class="comment">// function UserProfile({ userId }) {
//     const [user, setUser] = useState(null);
//     
//     useEffect(() => {
//         // 这里的函数形成闭包，依赖于 userId
//         const fetchUser = async () => {
//             const userData = await fetchUserData(userId);
//             setUser(userData);
//         };
//         
//         fetchUser();
//     }, [userId]); // 依赖数组确保 userId 变化时重新执行
//     
//     // ...
// }</span>

<span class="comment">// 3. 使用 useCallback 避免不必要的重新渲染</span>
<span class="comment">// function ParentComponent() {
//     const [count, setCount] = useState(0);
//     
//     // useCallback 创建一个记忆化的回调函数，避免每次渲染都创建新函数
//     const handleClick = useCallback(() => {
//         setCount(count + 1);
//     }, [count]); // 依赖数组
//     
//     return <ChildComponent onClick={handleClick} />;
// }</span>
        </div>

        <h3>7.3 Node.js 中的闭包应用</h3>
        <div class="code-block">
<span class="comment">// Node.js 中闭包的应用示例</span>

<span class="comment">// 1. 中间件模式</span>
<span class="comment">// const express = require('express');
// const app = express();</span>

<span class="comment">// // 认证中间件 - 使用闭包保存配置
// function authMiddleware(options = {}) {
//     const { allowGuest = false } = options;
//     
//     return function(req, res, next) {
//         // 可以访问 allowGuest 配置
//         if (req.session.user || allowGuest) {
//             next(); // 认证通过
//         } else {
//             res.status(401).send('Unauthorized');
//         }
//     };
// }

// // 使用不同配置的中间件
// app.get('/public', authMiddleware({ allowGuest: true }), (req, res) => {
//     res.send('Public content');
// });

// app.get('/private', authMiddleware(), (req, res) => {
//     res.send('Private content');
// });</span>

<span class="comment">// 2. 数据库连接池</span>
<span class="comment">// function createDbConnectionPool(config) {
//     const pool = new DatabasePool(config);
//     
//     return {
//         query: async (sql, params) => {
//             const connection = await pool.getConnection();
//             try {
//                 const result = await connection.query(sql, params);
//                 return result;
//             } finally {
//                 pool.releaseConnection(connection);
//             }
//         },
//         close: () => pool.close()
//     };
// }

// // 创建连接池并导出
// const db = createDbConnectionPool({
//     host: 'localhost',
//     user: 'root',
//     password: 'password',
//     database: 'mydb'
// });

// module.exports = db;</span>
        </div>
        
        <button onclick="runModernDemo()">运行现代JavaScript演示</button>
        <div id="modernResult" class="result">点击按钮查看运行结果...</div>
    </section>

    <!-- JavaScript 代码 -->
    <script>
        // 代码高亮辅助函数
        function highlightCode() {
            const codeBlocks = document.querySelectorAll('.code-block');
            codeBlocks.forEach(block => {
                block.innerHTML = block.innerHTML
                    .replace(/\/\/.*$/gm, '<span class="comment">$&</span>')
                    .replace(/\b(function|const|let|var|return|if|else|for|while|class|extends|import|export|default|async|await|try|catch|throw|new|typeof|instanceof|in|of)\b/gm, '<span class="keyword">$&</span>')
                    .replace(/('.*?'|\".*?\")/gm, '<span class="string">$&</span>')
                    .replace(/\b([A-Z][a-zA-Z0-9]+)\b/gm, '<span class="function">$&</span>');
            });
        }

        // 作用域演示函数
        function runScopeDemo() {
            const resultDiv = document.getElementById('scopeResult');
            const results = [];
            
            // 全局作用域演示
            const globalVar = "我是全局变量";
            results.push(`全局变量: ${globalVar}`);
            
            // 函数作用域演示
            function functionScope() {
                var localVar = "我是局部变量";
                let blockVar = "我是块变量";
                results.push(`函数内部可以访问: ${localVar}, ${blockVar}`);
            }
            functionScope();
            
            // 块级作用域演示
            if (true) {
                var varVar = "使用 var 声明";
                let letVar = "使用 let 声明";
                results.push(`块内部可以访问: ${varVar}, ${letVar}`);
            }
            results.push(`块外部可以访问 varVar: ${varVar}`);
            results.push(`块外部不能访问 letVar: 尝试访问会抛出引用错误`);
            
            resultDiv.textContent = results.join('\n');
        }

        // 词法作用域演示函数
        function runLexicalScopeDemo() {
            const resultDiv = document.getElementById('lexicalScopeResult');
            const results = [];
            
            const globalVar = "全局变量";
            
            function outer() {
                const outerVar = "外部函数变量";
                
                function inner() {
                    const innerVar = "内部函数变量";
                    results.push(`内部函数可以访问 innerVar: ${innerVar}`);
                    results.push(`内部函数可以访问 outerVar: ${outerVar}`);
                    results.push(`内部函数可以访问 globalVar: ${globalVar}`);
                }
                
                inner();
                results.push(`外部函数可以访问 outerVar: ${outerVar}`);
                results.push(`外部函数可以访问 globalVar: ${globalVar}`);
                results.push("外部函数不能访问 innerVar: 尝试访问会抛出引用错误");
            }
            
            outer();
            resultDiv.textContent = results.join('\n');
        }

        // 闭包演示函数
        function runClosureDemo() {
            const resultDiv = document.getElementById('closureResult');
            const results = [];
            
            function createCounter() {
                let count = 0;
                
                return {
                    increment: function() { count++; return count; },
                    decrement: function() { count--; return count; },
                    getCount: function() { return count; }
                };
            }
            
            const counter = createCounter();
            results.push(`初始计数: ${counter.getCount()}`);
            results.push(`增加后: ${counter.increment()}`);
            results.push(`增加后: ${counter.increment()}`);
            results.push(`减少后: ${counter.decrement()}`);
            results.push(`当前计数: ${counter.getCount()}`);
            results.push(`直接访问 count 属性: ${counter.count}`);
            
            const counter1 = createCounter();
            const counter2 = createCounter();
            counter1.increment();
            results.push(`counter1 计数: ${counter1.getCount()}`);
            results.push(`counter2 计数: ${counter2.getCount()}`);
            
            resultDiv.textContent = results.join('\n');
        }

        // 实际应用演示函数
        function runApplicationDemo() {
            const resultDiv = document.getElementById('applicationResult');
            const results = [];
            
            // 数据私有化示例
            function createPerson(name, age) {
                let _name = name;
                let _age = age;
                
                return {
                    getName: () => _name,
                    getAge: () => _age,
                    setName: (newName) => { if (typeof newName === 'string' && newName.trim() !== '') _name = newName; },
                    setAge: (newAge) => { if (typeof newAge === 'number' && newAge >= 0) _age = newAge; }
                };
            }
            
            const person = createPerson("张三", 30);
            results.push(`创建人物: ${person.getName()}, ${person.getAge()}岁`);
            person.setName("李四");
            person.setAge(35);
            results.push(`更新后: ${person.getName()}, ${person.getAge()}岁`);
            
            // 函数工厂示例
            function createMultiplier(multiplier) {
                return function(number) { return number * multiplier; };
            }
            
            const double = createMultiplier(2);
            const triple = createMultiplier(3);
            results.push(`5 的 2 倍: ${double(5)}`);
            results.push(`5 的 3 倍: ${triple(5)}`);
            
            resultDiv.textContent = results.join('\n');
        }

        // 陷阱演示函数
        function runPitfallsDemo() {
            const resultDiv = document.getElementById('pitfallsResult');
            const results = [];
            
            // 循环中的闭包问题
            results.push("循环中的闭包问题演示:");
            
            function setupBadHandlers() {
                const output = [];
                for (var i = 0; i < 3; i++) {
                    setTimeout(() => {
                        output.push(`索引: ${i}`);
                        if (output.length === 3) {
                            results.push("问题代码输出:", ...output);
                        }
                    }, 10 * i);
                }
            }
            
            function setupGoodHandlers() {
                const output = [];
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        output.push(`索引: ${i}`);
                        if (output.length === 3) {
                            results.push("\n解决方案输出:", ...output);
                            resultDiv.textContent = results.join('\n');
                        }
                    }, 10 * i);
                }
            }
            
            setupBadHandlers();
            setTimeout(() => setupGoodHandlers(), 50);
        }

        // 作用域链演示函数
        function runScopeChainDemo() {
            const resultDiv = document.getElementById('scopeChainResult');
            const results = [];
            
            // 变量提升演示
            results.push("变量提升演示:");
            try {
                console.log(typeof x); // undefined
                results.push(`访问未声明的 var 变量: ${typeof x}`);
            } catch (e) {
                results.push(`错误: ${e.message}`);
            }
            var x = 5;
            results.push(`赋值后: ${x}`);
            
            results.push("\n函数提升演示:");
            function testFunction() {
                results.push("函数可以在声明前调用");
            }
            testFunction();
            
            resultDiv.textContent = results.join('\n');
        }

        // 现代JavaScript演示函数
        function runModernDemo() {
            const resultDiv = document.getElementById('modernResult');
            const results = [];
            
            // ES6+闭包演示
            function createCounterES6() {
                let count = 0;
                return {
                    increment: () => ++count,
                    getCount: () => count
                };
            }
            
            const counterES6 = createCounterES6();
            counterES6.increment();
            results.push(`ES6箭头函数闭包: ${counterES6.getCount()}`);
            
            // 私有字段模拟
            class CounterClass {
                constructor() {
                    this._count = 0; // 模拟私有字段
                }
                increment() {
                    return ++this._count;
                }
                getCount() {
                    return this._count;
                }
            }
            
            const counterClass = new CounterClass();
            counterClass.increment();
            results.push(`类封装: ${counterClass.getCount()}`);
            
            resultDiv.textContent = results.join('\n');
        }

        // 页面加载时执行
        document.addEventListener('DOMContentLoaded', () => {
            highlightCode();
        });
    </script>
</body>
</html>