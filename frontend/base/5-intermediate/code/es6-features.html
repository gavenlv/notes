<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript ES6+ 新特性详解</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        
        h1, h2, h3 {
            color: #2c3e50;
        }
        
        h1 {
            text-align: center;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 40px;
        }
        
        h2 {
            border-left: 4px solid #3498db;
            padding-left: 15px;
            margin-top: 50px;
        }
        
        .container {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .feature-section {
            margin-bottom: 40px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 6px;
        }
        
        .demo-box {
            background-color: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 6px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .result {
            background-color: #e8f4f8;
            border: 1px solid #b3e5fc;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-item {
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #ddd;
        }
        
        .es5 {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
        }
        
        .es6 {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
        }
        
        .highlight {
            background-color: #ffeb3b;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        @media (max-width: 768px) {
            .comparison {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 15px;
            }
            
            body {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <h1>JavaScript ES6+ 新特性详解</h1>
    
    <div class="container">
        <p>本教程详细介绍 JavaScript ES6 (ES2015) 及更新版本中引入的重要特性，帮助开发者编写更简洁、高效的现代 JavaScript 代码。点击每个部分的按钮可以运行演示代码。</p>
    </div>
    
    <!-- 1. let 和 const 声明 -->
    <section class="feature-section">
        <h2>1. let 和 const 声明</h2>
        <p>ES6 引入了 <span class="highlight">let</span> 和 <span class="highlight">const</span> 关键字，用于替代传统的 <span class="highlight">var</span> 声明，提供了更好的变量作用域控制。</p>
        
        <div class="comparison">
            <div class="comparison-item es5">
                <h3>ES5 (var)</h3>
                <div class="demo-box">// var 声明的变量具有函数作用域
// 存在变量提升
var x = 10;
if (true) {
    var x = 20; // 修改了外部的 x
    console.log(x); // 20
}
console.log(x); // 20</div>
            </div>
            <div class="comparison-item es6">
                <h3>ES6 (let/const)</h3>
                <div class="demo-box">// let 声明的变量具有块级作用域
// 不存在变量提升
let y = 10;
if (true) {
    let y = 20; // 这是一个新的变量
    console.log(y); // 20
}
console.log(y); // 10

// const 声明常量
const PI = 3.14159;
// PI = 3.14; // 尝试修改会报错</div>
            </div>
        </div>
        
        <button onclick="runLetConstDemo()">运行演示</button>
        <div id="letConstResult" class="result">点击按钮查看运行结果...</div>
    </section>
    
    <!-- 2. 箭头函数 -->
    <section class="feature-section">
        <h2>2. 箭头函数</h2>
        <p>箭头函数提供了一种更简洁的函数语法，并且不会绑定自己的 <span class="highlight">this</span>、<span class="highlight">arguments</span>、<span class="highlight">super</span> 或 <span class="highlight">new.target</span>。</p>
        
        <div class="comparison">
            <div class="comparison-item es5">
                <h3>ES5 函数</h3>
                <div class="demo-box">// 常规函数声明
function add(a, b) {
    return a + b;
}

// 函数表达式
const multiply = function(a, b) {
    return a * b;
};

// this 指向问题
const obj = {
    value: 10,
    getValue: function() {
        setTimeout(function() {
            console.log(this.value); // undefined
        }, 100);
    }
};</div>
            </div>
            <div class="comparison-item es6">
                <h3>ES6 箭头函数</h3>
                <div class="demo-box">// 基本箭头函数
const add = (a, b) => a + b;

// 单行可以省略大括号和 return
const square = x => x * x;

// 无参数
const getRandom = () => Math.random();

// this 继承自父作用域
const obj = {
    value: 10,
    getValue: function() {
        setTimeout(() => {
            console.log(this.value); // 10
        }, 100);
    }
};</div>
            </div>
        </div>
        
        <button onclick="runArrowFunctionDemo()">运行演示</button>
        <div id="arrowFunctionResult" class="result">点击按钮查看运行结果...</div>
    </section>
    
    <!-- 3. 模板字符串 -->
    <section class="feature-section">
        <h2>3. 模板字符串</h2>
        <p>模板字符串使用反引号 (`) 代替普通引号，允许嵌入表达式、多行文本和字符串插值。</p>
        
        <div class="comparison">
            <div class="comparison-item es5">
                <h3>ES5 字符串</h3>
                <div class="demo-box">// 字符串连接
var name = "John";
var greeting = "Hello, " + name + "!";

// 多行字符串
var multiline = "第一行\n" + 
                "第二行\n" + 
                "第三行";

// 表达式计算
var price = 10;
var quantity = 3;
var total = "Total: $" + (price * quantity);</div>
            </div>
            <div class="comparison-item es6">
                <h3>ES6 模板字符串</h3>
                <div class="demo-box">// 字符串插值
const name = "John";
const greeting = `Hello, ${name}!`;

// 多行字符串
const multiline = `第一行
第二行
第三行`;

// 嵌入表达式
const price = 10;
const quantity = 3;
const total = `Total: $${price * quantity}`;

// 嵌入函数调用
const getName = () => "Alice";
const greeting2 = `Hello, ${getName()}!`;</div>
            </div>
        </div>
        
        <button onclick="runTemplateStringDemo()">运行演示</button>
        <div id="templateStringResult" class="result">点击按钮查看运行结果...</div>
    </section>
    
    <!-- 4. 解构赋值 -->
    <section class="feature-section">
        <h2>4. 解构赋值</h2>
        <p>解构赋值允许从数组或对象中提取数据并直接赋值给变量，大大简化了代码。</p>
        
        <div class="comparison">
            <div class="comparison-item es5">
                <h3>ES5 赋值方式</h3>
                <div class="demo-box">// 数组赋值
var arr = [1, 2, 3];
var a = arr[0];
var b = arr[1];
var c = arr[2];

// 对象赋值
var obj = { name: "John", age: 30 };
var name = obj.name;
var age = obj.age;</div>
            </div>
            <div class="comparison-item es6">
                <h3>ES6 解构赋值</h3>
                <div class="demo-box">// 数组解构
const arr = [1, 2, 3];
const [a, b, c] = arr;

// 对象解构
const obj = { name: "John", age: 30 };
const { name, age } = obj;

// 默认值
const [x, y = 5, z = 10] = [1, 2];

// 重命名变量
const { name: username, age: userAge } = obj;

// 嵌套解构
const person = {
    name: "Alice",
    address: {
        city: "New York",
        zip: "10001"
    }
};
const { address: { city, zip } } = person;</div>
            </div>
        </div>
        
        <button onclick="runDestructuringDemo()">运行演示</button>
        <div id="destructuringResult" class="result">点击按钮查看运行结果...</div>
    </section>
    
    <!-- 5. 展开运算符 -->
    <section class="feature-section">
        <h2>5. 展开运算符</h2>
        <p>展开运算符 (<code>...</code>) 允许一个表达式在期望多个参数（用于函数调用）或多个元素（用于数组字面量）的位置展开。</p>
        
        <div class="comparison">
            <div class="comparison-item es5">
                <h3>ES5 数组操作</h3>
                <div class="demo-box">// 合并数组
var arr1 = [1, 2, 3];
var arr2 = [4, 5, 6];
var merged = arr1.concat(arr2);

// 复制数组
var copy = arr1.slice();

// 函数调用
function sum(a, b, c) {
    return a + b + c;
}
var args = [1, 2, 3];
var result = sum.apply(null, args);</div>
            </div>
            <div class="comparison-item es6">
                <h3>ES6 展开运算符</h3>
                <div class="demo-box">// 合并数组
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const merged = [...arr1, ...arr2];

// 复制数组
const copy = [...arr1];

// 函数调用
function sum(a, b, c) {
    return a + b + c;
}
const args = [1, 2, 3];
const result = sum(...args);

// 数组字面量中使用
const newArr = [0, ...arr1, 4];

// 对象展开 (ES2018)
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, ...obj1 }; // { c: 3, a: 1, b: 2 }</div>
            </div>
        </div>
        
        <button onclick="runSpreadOperatorDemo()">运行演示</button>
        <div id="spreadOperatorResult" class="result">点击按钮查看运行结果...</div>
    </section>
    
    <!-- 6. 剩余参数 -->
    <section class="feature-section">
        <h2>6. 剩余参数</h2>
        <p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组，是 arguments 对象的更现代替代方案。</p>
        
        <div class="comparison">
            <div class="comparison-item es5">
                <h3>ES5 arguments 对象</h3>
                <div class="demo-box">// 使用 arguments 对象
function sumAll() {
    var args = Array.prototype.slice.call(arguments);
    return args.reduce(function(total, num) {
        return total + num;
    }, 0);
}

// arguments 不是真正的数组
function showArgs() {
    console.log(typeof arguments); // object
    console.log(Array.isArray(arguments)); // false
}</div>
            </div>
            <div class="comparison-item es6">
                <h3>ES6 剩余参数</h3>
                <div class="demo-box">// 使用剩余参数
function sumAll(...args) {
    return args.reduce((total, num) => total + num, 0);
}

// 剩余参数是真正的数组
function showArgs(...args) {
    console.log(typeof args); // object
    console.log(Array.isArray(args)); // true
    // 可以使用数组方法
    args.forEach(arg => console.log(arg));
}

// 与普通参数结合使用
function log(first, second, ...rest) {
    console.log(first, second);
    console.log(rest); // 剩余参数组成的数组
}</div>
            </div>
        </div>
        
        <button onclick="runRestParamsDemo()">运行演示</button>
        <div id="restParamsResult" class="result">点击按钮查看运行结果...</div>
    </section>
    
    <!-- 7. 类 -->
    <section class="feature-section">
        <h2>7. 类</h2>
        <p>ES6 引入了 class 关键字，提供了更清晰的面向对象编程语法，虽然本质上仍然是基于原型的。</p>
        
        <div class="comparison">
            <div class="comparison-item es5">
                <h3>ES5 构造函数</h3>
                <div class="demo-box">// 构造函数
function Person(name, age) {
    this.name = name;
    this.age = age;
}

// 原型方法
Person.prototype.sayHello = function() {
    return "Hello, my name is " + this.name;
};

// 静态方法
Person.createAdult = function(name) {
    return new Person(name, 18);
};

// 继承
function Employee(name, age, jobTitle) {
    Person.call(this, name, age);
    this.jobTitle = jobTitle;
}

// 设置原型链
Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;

// 重写方法
Employee.prototype.sayHello = function() {
    return Person.prototype.sayHello.call(this) + 
           ". I am a " + this.jobTitle;
};</div>
            </div>
            <div class="comparison-item es6">
                <h3>ES6 类语法</h3>
                <div class="demo-box">// 类定义
class Person {
    // 构造函数
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    // 实例方法
    sayHello() {
        return `Hello, my name is ${this.name}`;
    }
    
    // 静态方法
    static createAdult(name) {
        return new Person(name, 18);
    }
}

// 继承
class Employee extends Person {
    constructor(name, age, jobTitle) {
        super(name, age); // 调用父类构造函数
        this.jobTitle = jobTitle;
    }
    
    // 重写方法
    sayHello() {
        return `${super.sayHello()}. I am a ${this.jobTitle}`;
    }
}</div>
            </div>
        </div>
        
        <button onclick="runClassDemo()">运行演示</button>
        <div id="classResult" class="result">点击按钮查看运行结果...</div>
    </section>
    
    <!-- 8. 模块化 -->
    <section class="feature-section">
        <h2>8. 模块化</h2>
        <p>ES6 引入了官方的模块化系统，使用 <code>import</code> 和 <code>export</code> 关键字来实现模块间的代码共享。</p>
        
        <div class="comparison">
            <div class="comparison-item es5">
                <h3>ES5 模块模式</h3>
                <div class="demo-box">// 使用 IIFE 和闭包实现模块
var myModule = (function() {
    // 私有变量
    var privateVar = "私有变量";
    
    // 私有方法
    function privateMethod() {
        return "这是私有方法";
    }
    
    // 公共 API
    return {
        publicVar: "公共变量",
        publicMethod: function() {
            return "这是公共方法，" + privateVar;
        }
    };
})();

// 使用模块
console.log(myModule.publicVar);
console.log(myModule.publicMethod());
// console.log(myModule.privateVar); // undefined</div>
            </div>
            <div class="comparison-item es6">
                <h3>ES6 模块化</h3>
                <div class="demo-box">// 导出模块 (module.js)
// 命名导出
const PI = 3.14159;

export function calculateArea(radius) {
    return PI * radius * radius;
}

export function calculateCircumference(radius) {
    return 2 * PI * radius;
}

// 默认导出
export default {
    calculateArea,
    calculateCircumference,
    PI
};

// 导入模块 (app.js)
// 导入默认导出
import Circle from './module.js';

// 导入命名导出
import { calculateArea, PI } from './module.js';

// 导入所有内容
import * as CircleUtils from './module.js';

// 使用导入的内容
console.log(Circle.calculateArea(5));
console.log(calculateArea(5));
console.log(CircleUtils.PI);</div>
            </div>
        </div>
        
        <p class="note">注意：由于浏览器安全限制，完整的模块导入导出需要在服务器环境中运行。以下演示使用模拟的方式展示模块化概念。</p>
        <button onclick="runModuleDemo()">运行模拟演示</button>
        <div id="moduleResult" class="result">点击按钮查看运行结果...</div>
    </section>
    
    <!-- 9. Promise -->
    <section class="feature-section">
        <h2>9. Promise</h2>
        <p>Promise 是一种异步编程的解决方案，用于处理异步操作，避免回调地狱。</p>
        
        <div class="comparison">
            <div class="comparison-item es5">
                <h3>ES5 回调方式</h3>
                <div class="demo-box">// 回调地狱示例
function loadUserData(userId, callback) {
    setTimeout(() => {
        callback(null, { id: userId, name: 'John' });
    }, 100);
}

function loadUserPosts(userId, callback) {
    setTimeout(() => {
        callback(null, [{ id: 1, title: 'Post 1' }]);
    }, 100);
}

function loadPostComments(postId, callback) {
    setTimeout(() => {
        callback(null, [{ id: 1, text: 'Comment 1' }]);
    }, 100);
}

// 回调嵌套
loadUserData(1, function(err, user) {
    if (err) return console.error(err);
    loadUserPosts(user.id, function(err, posts) {
        if (err) return console.error(err);
        if (posts.length > 0) {
            loadPostComments(posts[0].id, function(err, comments) {
                if (err) return console.error(err);
                console.log('Comments:', comments);
            });
        }
    });
});</div>
            </div>
            <div class="comparison-item es6">
                <h3>ES6 Promise</h3>
                <div class="demo-box">// Promise 版本
function loadUserData(userId) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve({ id: userId, name: 'John' });
            // reject(new Error('Failed to load user'));
        }, 100);
    });
}

function loadUserPosts(userId) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve([{ id: 1, title: 'Post 1' }]);
        }, 100);
    });
}

function loadPostComments(postId) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve([{ id: 1, text: 'Comment 1' }]);
        }, 100);
    });
}

// Promise 链式调用
loadUserData(1)
    .then(user => {
        console.log('User:', user);
        return loadUserPosts(user.id);
    })
    .then(posts => {
        console.log('Posts:', posts);
        if (posts.length > 0) {
            return loadPostComments(posts[0].id);
        }
        throw new Error('No posts found');
    })
    .then(comments => {
        console.log('Comments:', comments);
    })
    .catch(error => {
        console.error('Error:', error.message);
    });

// Promise 组合方法
Promise.all([
    loadUserData(1),
    loadUserPosts(1)
]).then(([user, posts]) => {
    console.log('All data loaded:', user, posts);
});</div>
            </div>
        </div>
        
        <button onclick="runPromiseDemo()">运行演示</button>
        <div id="promiseResult" class="result">点击按钮查看运行结果...</div>
    </section>
    
    <!-- 10. async/await -->
    <section class="feature-section">
        <h2>10. async/await</h2>
        <p>ES2017 引入了 async/await 语法，使异步代码看起来更像同步代码，简化了 Promise 的使用。</p>
        
        <div class="comparison">
            <div class="comparison-item es6">
                <h3>ES6 Promise 链</h3>
                <div class="demo-box">// 使用 Promise 链
function fetchData() {
    return fetch('https://api.example.com/data')
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => {
            console.log(data);
            return processData(data);
        })
        .catch(error => {
            console.error('There was a problem:', error);
        });
}</div>
            </div>
            <div class="comparison-item es6">
                <h3>ES2017 async/await</h3>
                <div class="demo-box">// 使用 async/await
async function fetchData() {
    try {
        const response = await fetch('https://api.example.com/data');
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        const data = await response.json();
        console.log(data);
        return await processData(data);
    } catch (error) {
        console.error('There was a problem:', error);
    }
}

// async 函数返回 Promise
async function getData() {
    return { id: 1, name: 'Alice' };
}

// 调用 async 函数
getData().then(data => console.log(data));

// 在 async 函数中使用
async function displayData() {
    const data = await getData();
    console.log(data);
}</div>
            </div>
        </div>
        
        <button onclick="runAsyncAwaitDemo()">运行演示</button>
        <div id="asyncAwaitResult" class="result">点击按钮查看运行结果...</div>
    </section>
    
    <!-- 11. 新的数组方法 -->
    <section class="feature-section">
        <h2>11. 新的数组方法</h2>
        <p>ES6 为数组添加了许多新的内置方法，使数组操作更加便捷。</p>
        
        <div class="demo-box">// Array.from() - 将类数组对象或可迭代对象转换为数组
const nodeList = document.querySelectorAll('div');
const array = Array.from(nodeList);

// 带映射函数
const squares = Array.from([1, 2, 3], x => x * x); // [1, 4, 9]

// Array.of() - 创建一个具有可变数量参数的新数组
Array.of(1, 2, 3); // [1, 2, 3]
Array(3); // [undefined, undefined, undefined]

// Array.prototype.find() - 返回数组中满足条件的第一个元素
const numbers = [5, 12, 8, 130, 44];
const found = numbers.find(element => element > 10); // 12

// Array.prototype.findIndex() - 返回数组中满足条件的第一个元素的索引
const index = numbers.findIndex(element => element > 10); // 1

// Array.prototype.includes() - 判断数组是否包含指定值
numbers.includes(8); // true

// Array.prototype.flat() - 扁平化数组 (ES2019)
const nested = [1, [2, [3, [4]]]];
nested.flat(); // [1, 2, [3, [4]]]
nested.flat(2); // [1, 2, 3, [4]]
nested.flat(Infinity); // [1, 2, 3, 4]

// Array.prototype.flatMap() - 先映射后扁平化 (ES2019)
const arr = [1, 2, 3];
arr.flatMap(x => [x, x * 2]); // [1, 2, 2, 4, 3, 6]

// Array.prototype.entries() - 返回数组的键值对
for (const [index, value] of numbers.entries()) {
    console.log(index, value);
}

// Array.prototype.keys() - 返回数组的索引
for (const index of numbers.keys()) {
    console.log(index);
}

// Array.prototype.values() - 返回数组的值
for (const value of numbers.values()) {
    console.log(value);
}</div>
        
        <button onclick="runArrayMethodsDemo()">运行演示</button>
        <div id="arrayMethodsResult" class="result">点击按钮查看运行结果...</div>
    </section>
    
    <!-- 12. 新的对象方法 -->
    <section class="feature-section">
        <h2>12. 新的对象方法</h2>
        <p>ES6 为对象添加了一系列新的静态方法，简化了对象的操作。</p>
        
        <div class="demo-box">// Object.assign() - 将所有可枚举属性从一个或多个源对象复制到目标对象
const target = { a: 1 };
const source1 = { b: 2 };
const source2 = { c: 3, a: 4 };
const merged = Object.assign(target, source1, source2);
// merged: { a: 4, b: 2, c: 3 }

// Object.create() - 创建一个新对象，使用现有对象作为新对象的原型
const person = { name: "Unknown", greet() { return `Hello, ${this.name}`; } };
const john = Object.create(person);
john.name = "John";

// Object.keys() - 返回一个包含对象所有可枚举属性名称的数组
const obj = { a: 1, b: 2, c: 3 };
Object.keys(obj); // ['a', 'b', 'c']

// Object.values() - 返回一个包含对象所有可枚举属性值的数组
Object.values(obj); // [1, 2, 3]

// Object.entries() - 返回一个包含对象所有可枚举属性键值对的数组
Object.entries(obj); // [['a', 1], ['b', 2], ['c', 3]]

// Object.fromEntries() - 将键值对数组转换为对象 (ES2019)
const entries = [['a', 1], ['b', 2]];
const newObj = Object.fromEntries(entries); // { a: 1, b: 2 }

// Object.getOwnPropertyDescriptors() - 获取对象所有自身属性的描述符
const descriptor = Object.getOwnPropertyDescriptors(obj);

// Object.freeze() - 冻结对象，禁止修改
const frozen = Object.freeze({ a: 1 });
// frozen.a = 2; // 无效

// Object.seal() - 密封对象，允许修改现有属性但禁止添加/删除属性
const sealed = Object.seal({ a: 1 });
sealed.a = 2; // 有效
// sealed.b = 3; // 无效

// Object.is() - 判断两个值是否为同一个值
Object.is(NaN, NaN); // true
Object.is(+0, -0); // false
Object.is(5, '5'); // false</div>
        
        <button onclick="runObjectMethodsDemo()">运行演示</button>
        <div id="objectMethodsResult" class="result">点击按钮查看运行结果...</div>
    </section>
    
    <!-- 13. Symbol -->
    <section class="feature-section">
        <h2>13. Symbol</h2>
        <p>Symbol 是一种新的原始数据类型，表示唯一的标识符，常用于对象的属性名以避免命名冲突。</p>
        
        <div class="demo-box">// 创建 Symbol
const sym1 = Symbol();
const sym2 = Symbol('description'); // 可选描述

// 每个 Symbol 都是唯一的
const symA = Symbol('same');
const symB = Symbol('same');
symA === symB; // false

// 作为对象属性名
const user = {
    name: 'John',
    [sym1]: '这是一个 Symbol 属性',
    [sym2]: 42
};

// Symbol 属性不会出现在 for...in 循环和 Object.keys() 中
Object.keys(user); // ['name']

// 访问 Symbol 属性
console.log(user[sym1]); // '这是一个 Symbol 属性'

// 获取所有 Symbol 属性
const symbolProps = Object.getOwnPropertySymbols(user);

// 共享 Symbol
const sharedSym = Symbol.for('shared');
const anotherSym = Symbol.for('shared');
sharedSym === anotherSym; // true

// Symbol.iterator - 使对象可迭代
const iterable = {
    items: [1, 2, 3],
    [Symbol.iterator]() {
        let index = 0;
        return {
            next: () => ({
                value: this.items[index++],
                done: index > this.items.length
            })
        };
    }
};

// 现在可以使用 for...of 循环
for (const item of iterable) {
    console.log(item);
}</div>
        
        <button onclick="runSymbolDemo()">运行演示</button>
        <div id="symbolResult" class="result">点击按钮查看运行结果...</div>
    </section>
    
    <!-- 14. Set 和 Map -->
    <section class="feature-section">
        <h2>14. Set 和 Map</h2>
        <p>ES6 引入了 Set 和 Map 两种新的数据结构，提供了更高效的数据存储和检索方式。</p>
        
        <div class="comparison">
            <div class="comparison-item">
                <h3>Set</h3>
                <div class="demo-box">// 创建 Set
const set = new Set([1, 2, 3, 3, 4]); // 自动去重
console.log(set); // Set { 1, 2, 3, 4 }

// 添加元素
set.add(5);
set.add('text');

// 检查元素是否存在
set.has(3); // true
set.has(10); // false

// 删除元素
set.delete(3);

// 清除所有元素
// set.clear();

// 遍历 Set
for (const item of set) {
    console.log(item);
}

// 获取大小
console.log(set.size); // 4

// 使用 Set 去重数组
const uniqueArray = [...new Set([1, 2, 2, 3, 4, 4])]; // [1, 2, 3, 4]

// Set 与数组转换
const arrayFromSet = Array.from(set);
const setFromArray = new Set(arrayFromSet);</div>
            </div>
            <div class="comparison-item">
                <h3>Map</h3>
                <div class="demo-box">// 创建 Map
const map = new Map([
    ['key1', 'value1'],
    ['key2', 'value2']
]);

// 设置键值对
map.set('key3', 'value3');
map.set(42, 'number key');
const objKey = { id: 1 };
map.set(objKey, 'object key'); // 可以使用对象作为键

// 获取值
console.log(map.get('key1')); // 'value1'
console.log(map.get(objKey)); // 'object key'

// 检查键是否存在
map.has('key1'); // true

// 删除键值对
map.delete('key2');

// 清除所有键值对
// map.clear();

// 遍历 Map
for (const [key, value] of map) {
    console.log(key, value);
}

// 分别遍历键和值
for (const key of map.keys()) {
    console.log(key);
}

for (const value of map.values()) {
    console.log(value);
}

// 获取大小
console.log(map.size); // 3

// Map 与对象转换
const obj = Object.fromEntries(map);
const mapFromObj = new Map(Object.entries(obj));</div>
            </div>
        </div>
        
        <button onclick="runSetMapDemo()">运行演示</button>
        <div id="setMapResult" class="result">点击按钮查看运行结果...</div>
    </section>
    
    <!-- 15. 可选链和空值合并 -->
    <section class="feature-section">
        <h2>15. 可选链和空值合并</h2>
        <p>ES2020 引入了可选链操作符 (?.) 和空值合并操作符 (??)，简化了对象属性访问和默认值处理。</p>
        
        <div class="comparison">
            <div class="comparison-item es6">
                <h3>ES6 及之前的方式</h3>
                <div class="demo-box">// 安全访问嵌套属性
const user = {
    profile: {
        name: 'John'
    }
};

// 检查属性是否存在
let city;
if (user && user.address && user.address.city) {
    city = user.address.city;
} else {
    city = 'Unknown';
}

// 或使用短路求值
const country = user && user.address && user.address.country;

// 默认值处理
function printValue(value) {
    // || 会将 falsy 值（0, '', false, null, undefined, NaN）都视为假值
    console.log(value || 'Default');
}</div>
            </div>
            <div class="comparison-item es6">
                <h3>ES2020 新特性</h3>
                <div class="demo-box">// 可选链操作符 (?.)
const user = {
    profile: {
        name: 'John'
    }
};

// 安全访问嵌套属性
const city = user?.address?.city;

// 可选链与函数调用
const result = user?.profile?.getName?.();

// 可选链与数组访问
const firstTag = user?.tags?.[0];

// 空值合并操作符 (??)
function printValue(value) {
    // ?? 只对 null 和 undefined 视为空值
    console.log(value ?? 'Default');
}

// 结合使用
const defaultCity = user?.address?.city ?? 'Unknown';

// 实际应用示例
const config = {
    timeout: 0, // 合法值，但使用 || 会被视为假
    retries: null
};

// 使用 ??
const timeout = config.timeout ?? 3000; // 0 (不是 3000)
const retries = config.retries ?? 3; // 3

// 使用 ||
const timeout2 = config.timeout || 3000; // 3000 (因为 0 被视为假)</div>
            </div>
        </div>
        
        <button onclick="runOptionalChainingDemo()">运行演示</button>
        <div id="optionalChainingResult" class="result">点击按钮查看运行结果...</div>
    </section>
    
    <script>
        // 演示代码实现
        function runLetConstDemo() {
            const result = document.getElementById('letConstResult');
            let output = '=== let 和 const 演示 ===\n\n';
            
            try {
                // var 演示
                output += 'var 演示:\n';
                var x = 10;
                output += `初始 x = ${x}\n`;
                {
                    var x = 20; // 修改了外部的 x
                    output += `在块内重新赋值 x = ${x}\n`;
                }
                output += `块外 x = ${x} (注意值被改变了)\n\n`;
                
                // let 演示
                output += 'let 演示:\n';
                let y = 10;
                output += `初始 y = ${y}\n`;
                {
                    let y = 20; // 这是一个新的变量
                    output += `在块内声明新的 y = ${y}\n`;
                }
                output += `块外 y = ${y} (保持不变)\n\n`;
                
                // const 演示
                output += 'const 演示:\n';
                const PI = 3.14159;
                output += `定义常量 PI = ${PI}\n`;
                
                try {
                    PI = 3.14; // 尝试修改常量
                    output += '修改常量成功 (不应该发生)';
                } catch (e) {
                    output += `尝试修改常量: ${e.message}\n`;
                }
                
                // const 对象可以修改属性
                const user = { name: 'John' };
                output += `\nconst 对象 user = ${JSON.stringify(user)}\n`;
                user.name = 'Alice'; // 允许修改属性
                output += `修改对象属性后 user = ${JSON.stringify(user)}\n`;
                
                try {
                    user = { name: 'Bob' }; // 但不能重新赋值整个对象
                    output += '重新赋值对象成功 (不应该发生)';
                } catch (e) {
                    output += `尝试重新赋值对象: ${e.message}\n`;
                }
            } catch (error) {
                output += `演示过程中出错: ${error.message}`;
            }
            
            result.textContent = output;
        }
        
        function runArrowFunctionDemo() {
            const result = document.getElementById('arrowFunctionResult');
            let output = '=== 箭头函数演示 ===\n\n';
            
            try {
                // 基本箭头函数
                const add = (a, b) => a + b;
                output += `add(5, 3) = ${add(5, 3)}\n`;
                
                // 单行省略大括号和 return
                const square = x => x * x;
                output += `square(4) = ${square(4)}\n`;
                
                // 无参数
                const getRandom = () => Math.random();
                output += `getRandom() = ${getRandom()}\n`;
                
                // 多行箭头函数需要大括号和 return
                const complexCalc = (a, b) => {
                    const sum = a + b;
                    const product = a * b;
                    return sum + product;
                };
                output += `complexCalc(2, 3) = ${complexCalc(2, 3)}\n\n`;
                
                // this 指向问题演示
                output += 'this 指向演示:\n';
                
                // 普通函数的 this
                const obj1 = {
                    value: 10,
                    getValue: function() {
                        const self = this; // 传统解决方案
                        setTimeout(function() {
                            output += `普通函数中 this.value = ${this.value || 'undefined'}\n`;
                            output += `使用 self.value = ${self.value}\n`;
                        }, 0); // 使用 0 延迟立即执行
                    }
                };
                obj1.getValue();
                
                // 箭头函数的 this
                const obj2 = {
                    value: 10,
                    getValue: function() {
                        setTimeout(() => {
                            output += `箭头函数中 this.value = ${this.value}\n`;
                        }, 0); // 使用 0 延迟立即执行
                    }
                };
                obj2.getValue();
                
                // 因为 setTimeout 是异步的，我们需要等待一下再更新结果
                setTimeout(() => {
                    result.textContent = output;
                }, 10);
            } catch (error) {
                output += `演示过程中出错: ${error.message}`;
                result.textContent = output;
            }
        }
        
        function runTemplateStringDemo() {
            const result = document.getElementById('templateStringResult');
            let output = '=== 模板字符串演示 ===\n\n';
            
            try {
                // 字符串插值
                const name = "John";
                const greeting = `Hello, ${name}!`;
                output += `greeting = "${greeting}"\n`;
                
                // 多行字符串
                const multiline = `第一行
第二行
第三行`;
                output += `\nmultiline = """${multiline}"""\n`;
                
                // 嵌入表达式
                const price = 10;
                const quantity = 3;
                const total = `Total: $${price * quantity}`;
                output += `\n${total}\n`;
                
                // 嵌入函数调用
                const getName = () => "Alice";
                const greeting2 = `Hello, ${getName()}!`;
                output += `\ngreeting2 = "${greeting2}"\n`;
                
                // 嵌套模板字符串
                const outer = `Outer: ${`Inner: ${1 + 1}`}`;
                output += `\n嵌套模板字符串: "${outer}"\n`;
                
                // HTML 模板
                const user = { name: "Bob", age: 25 };
                const html = `
<div class="user">
  <h2>${user.name}</h2>
  <p>Age: ${user.age}</p>
</div>`;
                output += `\nHTML 模板:\n${html}`;
            } catch (error) {
                output += `演示过程中出错: ${error.message}`;
            }
            
            result.textContent = output;
        }
        
        function runDestructuringDemo() {
            const result = document.getElementById('destructuringResult');
            let output = '=== 解构赋值演示 ===\n\n';
            
            try {
                // 数组解构
                output += '数组解构:\n';
                const arr = [1, 2, 3];
                const [a, b, c] = arr;
                output += `从 [${arr}] 解构得到 a=${a}, b=${b}, c=${c}\n\n`;
                
                // 跳过元素
                const [first, , third] = arr;
                output += `跳过第二个元素: first=${first}, third=${third}\n\n`;
                
                // 默认值
                const [x, y = 5, z = 10] = [1, 2];
                output += `带默认值的解构: x=${x}, y=${y}, z=${z}\n\n`;
                
                // 对象解构
                output += '对象解构:\n';
                const obj = { name: "John", age: 30 };
                const { name, age } = obj;
                output += `从 ${JSON.stringify(obj)} 解构得到 name="${name}", age=${age}\n\n`;
                
                // 重命名变量
                const { name: username, age: userAge } = obj;
                output += `重命名变量: username="${username}", userAge=${userAge}\n\n`;
                
                // 嵌套解构
                output += '嵌套解构:\n';
                const person = {
                    name: "Alice",
                    address: {
                        city: "New York",
                        zip: "10001"
                    }
                };
                const { address: { city, zip } } = person;
                output += `从嵌套对象中解构: city="${city}", zip="${zip}"`;
                
                // 函数参数解构
                output += '\n\n函数参数解构:\n';
                function displayUser({ name, age, address: { city } }) {
                    output += `User: ${name}, ${age} years old, from ${city}`;
                }
                displayUser(person);
            } catch (error) {
                output += `演示过程中出错: ${error.message}`;
            }
            
            result.textContent = output;
        }
        
        function runSpreadOperatorDemo() {
            const result = document.getElementById('spreadOperatorResult');
            let output = '=== 展开运算符演示 ===\n\n';
            
            try {
                // 合并数组
                output += '合并数组:\n';
                const arr1 = [1, 2, 3];
                const arr2 = [4, 5, 6];
                const merged = [...arr1, ...arr2];
                output += `[${arr1}] + [${arr2}] = [${merged}]\n\n`;
                
                // 复制数组
                const copy = [...arr1];
                output += `复制数组: [...${arr1}] = [${copy}]\n\n`;
                
                // 向数组添加元素
                const newArr = [0, ...arr1, 4];
                output += `在数组中插入元素: [0, ...${arr1}, 4] = [${newArr}]\n\n`;
                
                // 函数调用
                output += '函数调用中使用:\n';
                function sum(a, b, c) {
                    return a + b + c;
                }
                const args = [1, 2, 3];
                const resultSum = sum(...args);
                output += `sum(...[${args}]) = ${resultSum}\n\n`;
                
                // Math.max 示例
                const numbers = [5, 3, 9, 1, 7];
                const max = Math.max(...numbers);
                output += `Math.max(...[${numbers}]) = ${max}\n\n`;
                
                // 对象展开
                output += '对象展开:\n';
                const obj1 = { a: 1, b: 2 };
                const obj2 = { c: 3, ...obj1 };
                output += `{ c: 3, ...${JSON.stringify(obj1)} } = ${JSON.stringify(obj2)}\n\n`;
                
                // 对象合并和覆盖
                const obj3 = { a: 100, d: 4 };
                const mergedObj = { ...obj1, ...obj3 };
                output += `合并对象: { ...${JSON.stringify(obj1)}, ...${JSON.stringify(obj3)} } = ${JSON.stringify(mergedObj)}\n`;
                output += '注意: 后面的对象会覆盖相同键的值';
            } catch (error) {
                output += `演示过程中出错: ${error.message}`;
            }
            
            result.textContent = output;
        }
        
        function runRestParamsDemo() {
            const result = document.getElementById('restParamsResult');
            let output = '=== 剩余参数演示 ===\n\n';
            
            try {
                // 基本使用
                output += '基本使用:\n';
                function sumAll(...args) {
                    output += `参数数组: [${args}]\n`;
                    return args.reduce((total, num) => total + num, 0);
                }
                
                const sumResult = sumAll(1, 2, 3, 4, 5);
                output += `sumAll(1, 2, 3, 4, 5) = ${sumResult}\n\n`;
                
                // 与普通参数结合
                output += '与普通参数结合:\n';
                function log(first, second, ...rest) {
                    output += `first: ${first}, second: ${second}\n`;
                    output += `rest: [${rest}]\n`;
                }
                
                log('a', 'b', 'c', 'd', 'e');
                
                // 剩余参数是真正的数组
                output += '\n剩余参数是真正的数组:\n';
                function processArgs(...args) {
                    output += `Array.isArray(args): ${Array.isArray(args)}\n`;
                    output += `args.length: ${args.length}\n`;
                    output += `使用 map: ${args.map(x => x * 2)}\n`;
                    output += `使用 filter: ${args.filter(x => x % 2 === 0)}\n`;
                }
                
                processArgs(1, 2, 3, 4, 5);
                
                // 箭头函数中的剩余参数
                output += '\n箭头函数中的剩余参数:\n';
                const multiplyAll = (...numbers) => numbers.reduce((product, num) => product * num, 1);
                output += `multiplyAll(2, 3, 4) = ${multiplyAll(2, 3, 4)}`;
            } catch (error) {
                output += `演示过程中出错: ${error.message}`;
            }
            
            result.textContent = output;
        }
        
        function runClassDemo() {
            const result = document.getElementById('classResult');
            let output = '=== 类语法演示 ===\n\n';
            
            try {
                // 类定义
                class Person {
                    constructor(name, age) {
                        this.name = name;
                        this.age = age;
                    }
                    
                    sayHello() {
                        return `Hello, my name is ${this.name}`;
                    }
                    
                    static createAdult(name) {
                        return new Person(name, 18);
                    }
                }
                
                // 创建实例
                const john = new Person('John', 30);
                output += `创建实例: new Person('John', 30)\n`;
                output += `john.name: ${john.name}\n`;
                output += `john.age: ${john.age}\n`;
                output += `john.sayHello(): "${john.sayHello()}"\n\n`;
                
                // 使用静态方法
                const adult = Person.createAdult('Bob');
                output += `静态方法创建: Person.createAdult('Bob')\n`;
                output += `adult.name: ${adult.name}\n`;
                output += `adult.age: ${adult.age}\n\n`;
                
                // 继承
                class Employee extends Person {
                    constructor(name, age, jobTitle) {
                        super(name, age); // 调用父类构造函数
                        this.jobTitle = jobTitle;
                    }
                    
                    sayHello() {
                        return `${super.sayHello()}. I am a ${this.jobTitle}`;
                    }
                    
                    getInfo() {
                        return `${this.name}, ${this.age} years old, works as ${this.jobTitle}`;
                    }
                }
                
                // 创建子类实例
                const alice = new Employee('Alice', 28, 'Developer');
                output += `创建子类实例: new Employee('Alice', 28, 'Developer')\n`;
                output += `alice.name: ${alice.name}\n`;
                output += `alice.age: ${alice.age}\n`;
                output += `alice.jobTitle: ${alice.jobTitle}\n`;
                output += `alice.sayHello(): "${alice.sayHello()}" (重写的方法)\n`;
                output += `alice.getInfo(): "${alice.getInfo()}" (子类特有方法)`;
            } catch (error) {
                output += `演示过程中出错: ${error.message}`;
            }
            
            result.textContent = output;
        }
        
        function runModuleDemo() {
            const result = document.getElementById('moduleResult');
            let output = '=== 模块化演示（模拟） ===\n\n';
            
            try {
                // 模拟模块导出和导入
                // 模拟 module.js
                output += '模拟 module.js 模块:\n';
                const PI = 3.14159;
                
                function calculateArea(radius) {
                    return PI * radius * radius;
                }
                
                function calculateCircumference(radius) {
                    return 2 * PI * radius;
                }
                
                const circleModule = {
                    calculateArea,
                    calculateCircumference,
                    PI
                };
                
                output += `- 命名导出: PI, calculateArea, calculateCircumference\n`;
                output += `- 默认导出: { calculateArea, calculateCircumference, PI }\n\n`;
                
                // 模拟 app.js 导入
                output += '模拟 app.js 导入使用:\n';
                
                // 模拟默认导入
                const Circle = circleModule;
                const area1 = Circle.calculateArea(5);
                output += `// 默认导入\n`;
                output += `import Circle from './module.js';\n`;
                output += `Circle.calculateArea(5) = ${area1.toFixed(2)}\n\n`;
                
                // 模拟命名导入
                const { calculateArea, PI: IMPORTED_PI } = circleModule;
                const area2 = calculateArea(5);
                output += `// 命名导入\n`;
                output += `import { calculateArea, PI } from './module.js';\n`;
                output += `calculateArea(5) = ${area2.toFixed(2)}\n`;
                output += `PI = ${IMPORTED_PI}\n\n`;
                
                // 模拟导入所有内容
                const CircleUtils = circleModule;
                const circumference = CircleUtils.calculateCircumference(5);
                output += `// 导入所有内容\n`;
                output += `import * as CircleUtils from './module.js';\n`;
                output += `CircleUtils.calculateCircumference(5) = ${circumference.toFixed(2)}\n\n`;
                
                output += '注意：在实际项目中，需要在支持 ES 模块的环境中运行，如使用 script 标签的 type="module" 属性或通过打包工具（如 Webpack、Rollup、Vite）构建。';
            } catch (error) {
                output += `演示过程中出错: ${error.message}`;
            }
            
            result.textContent = output;
        }
        
        function runPromiseDemo() {
            const result = document.getElementById('promiseResult');
            let output = '=== Promise 演示 ===\n\n';
            
            try {
                // 模拟异步操作
                function loadUserData(userId) {
                    return new Promise((resolve, reject) => {
                        setTimeout(() => {
                            output += `加载用户数据: ID ${userId}\n`;
                            resolve({ id: userId, name: 'John' });
                        }, 100);
                    });
                }
                
                function loadUserPosts(userId) {
                    return new Promise((resolve, reject) => {
                        setTimeout(() => {
                            output += `加载用户文章: 用户 ${userId}\n`;
                            resolve([{ id: 1, title: 'Post 1' }, { id: 2, title: 'Post 2' }]);
                        }, 100);
                    });
                }
                
                function loadPostComments(postId) {
                    return new Promise((resolve, reject) => {
                        setTimeout(() => {
                            output += `加载文章评论: 文章 ${postId}\n`;
                            resolve([{ id: 1, text: 'Comment 1' }, { id: 2, text: 'Comment 2' }]);
                        }, 100);
                    });
                }
                
                output += '开始 Promise 链式调用...\n';
                
                // 链式调用
                loadUserData(1)
                    .then(user => {
                        output += `获取到用户: ${JSON.stringify(user)}\n`;
                        return loadUserPosts(user.id);
                    })
                    .then(posts => {
                        output += `获取到文章: ${JSON.stringify(posts)}\n`;
                        if (posts.length > 0) {
                            return loadPostComments(posts[0].id);
                        }
                        throw new Error('No posts found');
                    })
                    .then(comments => {
                        output += `获取到评论: ${JSON.stringify(comments)}\n`;
                        output += 'Promise 链式调用完成!\n\n';
                        
                        // 展示 Promise.all
                        output += '\nPromise.all 演示:\n';
                        return Promise.all([
                            loadUserData(2),
                            loadUserPosts(2)
                        ]);
                    })
                    .then(([user, posts]) => {
                        output += `Promise.all 完成!\n`;
                        output += `同时获取到:\n`;
                        output += `- 用户: ${JSON.stringify(user)}\n`;
                        output += `- 文章: ${JSON.stringify(posts)}\n`;
                        
                        // 更新结果显示
                        result.textContent = output;
                    })
                    .catch(error => {
                        output += `发生错误: ${error.message}`;
                        result.textContent = output;
                    });
                
                // 由于异步操作，我们会在最后一个 then 中更新结果
                output += '(异步操作进行中...)\n';
                result.textContent = output;
            } catch (error) {
                output += `演示过程中出错: ${error.message}`;
                result.textContent = output;
            }
        }
        
        function runAsyncAwaitDemo() {
            const result = document.getElementById('asyncAwaitResult');
            let output = '=== async/await 演示 ===\n\n';
            
            try {
                // 模拟异步操作
                function delay(ms, value) {
                    return new Promise(resolve => setTimeout(() => resolve(value), ms));
                }
                
                // async 函数返回 Promise
                async function getData() {
                    output += 'getData() 开始执行\n';
                    const data = await delay(100, { id: 1, name: 'Alice' });
                    output += `getData() 获取到数据: ${JSON.stringify(data)}\n`;
                    return data;
                }
                
                // 在 async 函数中使用 await
                async function displayData() {
                    try {
                        output += 'displayData() 开始执行\n';
                        
                        // 顺序执行异步操作
                        output += '\n顺序执行异步操作:\n';
                        const user = await delay(100, { name: 'Bob' });
                        output += `获取用户: ${JSON.stringify(user)}\n`;
                        
                        const posts = await delay(100, ['Post 1', 'Post 2']);
                        output += `获取文章: ${JSON.stringify(posts)}\n`;
                        
                        // 并行执行
                        output += '\n并行执行异步操作:\n';
                        const [comments, tags] = await Promise.all([
                            delay(100, ['Comment 1', 'Comment 2']),
                            delay(150, ['JavaScript', 'ES6'])
                        ]);
                        output += `同时获取到:\n`;
                        output += `- 评论: ${JSON.stringify(comments)}\n`;
                        output += `- 标签: ${JSON.stringify(tags)}\n`;
                        
                        // 错误处理
                        output += '\n错误处理演示:\n';
                        try {
                            await delay(50, null).then(val => {
                                if (val === null) throw new Error('数据为空');
                                return val;
                            });
                        } catch (err) {
                            output += `捕获到错误: ${err.message}\n`;
                        }
                        
                        output += '\nasync/await 演示完成!\n';
                    } catch (error) {
                        output += `演示过程中出错: ${error.message}\n`;
                    }
                    
                    // 更新结果显示
                    result.textContent = output;
                }
                
                // 开始演示
                output += '开始 async/await 演示...\n';
                result.textContent = output;
                
                // 运行演示函数
                displayData();
            } catch (error) {
                output += `演示过程中出错: ${error.message}`;
                result.textContent = output;
            }
        }
        
        function runArrayMethodsDemo() {
            const result = document.getElementById('arrayMethodsResult');
            let output = '=== 新的数组方法演示 ===\n\n';
            
            try {
                // Array.from
                output += 'Array.from() - 将类数组或可迭代对象转换为数组:\n';
                const arrayLike = { 0: 'a', 1: 'b', 2: 'c', length: 3 };
                const arrFrom = Array.from(arrayLike);
                output += `Array.from({0: 'a', 1: 'b', 2: 'c', length: 3}) = [${arrFrom}]\n`;
                
                // 带映射函数
                const squares = Array.from([1, 2, 3], x => x * x);
                output += `Array.from([1, 2, 3], x => x * x) = [${squares}]\n\n`;
                
                // Array.of
                output += 'Array.of() - 创建包含指定参数的数组:\n';
                output += `Array.of(1, 2, 3) = [${Array.of(1, 2, 3)}]\n`;
                output += `Array(3) = [${Array(3).join(', ')}] (注意区别)\n\n`;
                
                // Array.prototype.find
                output += 'Array.prototype.find() - 查找满足条件的第一个元素:\n';
                const numbers = [5, 12, 8, 130, 44];
                const found = numbers.find(element => element > 10);
                output += `[5, 12, 8, 130, 44].find(x > 10) = ${found}\n\n`;
                
                // Array.prototype.findIndex
                output += 'Array.prototype.findIndex() - 查找满足条件的第一个元素的索引:\n';
                const index = numbers.findIndex(element => element > 10);
                output += `[5, 12, 8, 130, 44].findIndex(x > 10) = ${index}\n\n`;
                
                // Array.prototype.includes
                output += 'Array.prototype.includes() - 判断是否包含指定值:\n';
                output += `[5, 12, 8, 130, 44].includes(8) = ${numbers.includes(8)}\n`;
                output += `[5, 12, 8, 130, 44].includes(9) = ${numbers.includes(9)}\n\n`;
                
                // Array.prototype.flat
                output += 'Array.prototype.flat() - 扁平化数组:\n';
                const nested = [1, [2, [3, [4]]]];
                output += `[1, [2, [3, [4]]]].flat() = [${nested.flat()}]\n`;
                output += `[1, [2, [3, [4]]]].flat(2) = [${nested.flat(2)}]\n`;
                output += `[1, [2, [3, [4]]]].flat(Infinity) = [${nested.flat(Infinity)}]\n\n`;
                
                // Array.prototype.flatMap
                output += 'Array.prototype.flatMap() - 映射后扁平化:\n';
                const arr = [1, 2, 3];
                const flatMapped = arr.flatMap(x => [x, x * 2]);
                output += `[1, 2, 3].flatMap(x => [x, x*2]) = [${flatMapped}]\n\n`;
                
                // 迭代方法
                output += '迭代方法 (entries, keys, values):\n';
                output += 'entries() - 键值对:\n';
                const entries = Array.from(numbers.entries());
                output += `[${numbers}].entries() = ${JSON.stringify(entries)}\n\n`;
                
                output += 'keys() - 索引:\n';
                const keys = Array.from(numbers.keys());
                output += `[${numbers}].keys() = [${keys}]\n\n`;
                
                output += 'values() - 值:\n';
                const values = Array.from(numbers.values());
                output += `[${numbers}].values() = [${values}]`;
            } catch (error) {
                output += `演示过程中出错: ${error.message}`;
            }
            
            result.textContent = output;
        }
        
        function runObjectMethodsDemo() {
            const result = document.getElementById('objectMethodsResult');
            let output = '=== 新的对象方法演示 ===\n\n';
            
            try {
                // Object.assign
                output += 'Object.assign() - 合并对象:\n';
                const target = { a: 1 };
                const source1 = { b: 2 };
                const source2 = { c: 3, a: 4 }; // 注意这里会覆盖 a
                const merged = Object.assign(target, source1, source2);
                output += `Object.assign({a:1}, {b:2}, {c:3,a:4}) = ${JSON.stringify(merged)}\n\n`;
                
                // Object.keys, values, entries
                output += 'Object.keys(), values(), entries():\n';
                const obj = { a: 1, b: 2, c: 3 };
                output += `Object.keys({a:1,b:2,c:3}) = [${Object.keys(obj)}]\n`;
                output += `Object.values({a:1,b:2,c:3}) = [${Object.values(obj)}]\n`;
                output += `Object.entries({a:1,b:2,c:3}) = ${JSON.stringify(Object.entries(obj))}\n\n`;
                
                // Object.fromEntries
                output += 'Object.fromEntries() - 从键值对创建对象:\n';
                const entries = [['a', 1], ['b', 2]];
                const newObj = Object.fromEntries(entries);
                output += `Object.fromEntries([['a',1],['b',2]]) = ${JSON.stringify(newObj)}\n\n`;
                
                // Object.is
                output += 'Object.is() - 判断两个值是否为同一个值:\n';
                output += `Object.is(5, 5) = ${Object.is(5, 5)}\n`;
                output += `Object.is('5', 5) = ${Object.is('5', 5)}\n`;
                output += `Object.is(NaN, NaN) = ${Object.is(NaN, NaN)} (与 === 不同)\n`;
                output += `Object.is(+0, -0) = ${Object.is(+0, -0)} (与 === 不同)\n\n`;
                
                // 对象保护方法
                output += '对象保护方法:\n';
                
                // Object.freeze
                const frozen = Object.freeze({ a: 1, b: 2 });
                try {
                    frozen.a = 10; // 在严格模式下会抛出错误
                    output += `尝试修改冻结对象: ${JSON.stringify(frozen)} (值未改变)\n`;
                } catch (e) {
                    output += `修改冻结对象抛出错误: ${e.message}\n`;
                }
                
                // Object.seal
                const sealed = Object.seal({ a: 1, b: 2 });
                sealed.a = 10; // 可以修改现有属性
                sealed.c = 3; // 不能添加新属性
                output += `修改密封对象属性: ${JSON.stringify(sealed)} (a被修改，c未添加)\n\n`;
                
                // Object.getOwnPropertyDescriptors
                output += 'Object.getOwnPropertyDescriptors() - 获取属性描述符:\n';
                const descriptors = Object.getOwnPropertyDescriptors({ a: 1 });
                output += `Object.getOwnPropertyDescriptors({a:1}) = ${JSON.stringify(descriptors, null, 2)}`;
            } catch (error) {
                output += `演示过程中出错: ${error.message}`;
            }
            
            result.textContent = output;
        }
        
        function runSymbolDemo() {
            const result = document.getElementById('symbolResult');
            let output = '=== Symbol 演示 ===\n\n';
            
            try {
                // 创建 Symbol
                output += '创建 Symbol:\n';
                const sym1 = Symbol();
                const sym2 = Symbol('description');
                output += `Symbol() = ${sym1.toString()}\n`;
                output += `Symbol('description') = ${sym2.toString()}\n\n`;
                
                // 唯一性
                output += 'Symbol 的唯一性:\n';
                const symA = Symbol('same');
                const symB = Symbol('same');
                output += `Symbol('same') === Symbol('same') = ${symA === symB}\n\n`;
                
                // 作为对象属性
                output += 'Symbol 作为对象属性:\n';
                const user = {
                    name: 'John',
                    [sym1]: '这是一个 Symbol 属性',
                    [sym2]: 42
                };
                output += `user = ${JSON.stringify(user)} (Symbol 属性不会在 JSON.stringify 中显示)\n`;
                output += `user[sym1] = "${user[sym1]}"\n`;
                output += `user[sym2] = ${user[sym2]}\n\n`;
                
                // Symbol 属性不可枚举
                output += 'Symbol 属性不可枚举:\n';
                output += `Object.keys(user) = [${Object.keys(user)}]\n`;
                output += `Object.getOwnPropertySymbols(user) = ${JSON.stringify(Object.getOwnPropertySymbols(user).map(sym => sym.toString()))}\n\n`;
                
                // 共享 Symbol
                output += '共享 Symbol (Symbol.for):\n';
                const sharedSym = Symbol.for('shared');
                const anotherSym = Symbol.for('shared');
                output += `Symbol.for('shared') === Symbol.for('shared') = ${sharedSym === anotherSym}\n`;
                output += `Symbol.keyFor(sharedSym) = "${Symbol.keyFor(sharedSym)}\n"\n`;
                
                // Symbol.iterator 使对象可迭代
                output += 'Symbol.iterator - 使对象可迭代:\n';
                const iterable = {
                    items: [1, 2, 3],
                    [Symbol.iterator]() {
                        let index = 0;
                        const self = this;
                        return {
                            next: () => ({
                                value: self.items[index++],
                                done: index > self.items.length
                            })
                        };
                    }
                };
                
                // 模拟 for...of 遍历
                const iterator = iterable[Symbol.iterator]();
                let next = iterator.next();
                const iteratedValues = [];
                
                while (!next.done) {
                    iteratedValues.push(next.value);
                    next = iterator.next();
                }
                
                output += `可迭代对象遍历结果: [${iteratedValues}]\n`;
                output += '这使我们可以在对象上使用 for...of 循环和展开运算符';
            } catch (error) {
                output += `演示过程中出错: ${error.message}`;
            }
            
            result.textContent = output;
        }
        
        function runSetMapDemo() {
            const result = document.getElementById('setMapResult');
            let output = '=== Set 和 Map 演示 ===\n\n';
            
            try {
                // Set 演示
                output += '=== Set 演示 ===\n';
                output += '创建 Set:\n';
                const set = new Set([1, 2, 3, 3, 4]); // 自动去重
                output += `new Set([1, 2, 3, 3, 4]) = ${Array.from(set)}\n`;
                output += `set.size = ${set.size}\n\n`;
                
                output += 'Set 操作:\n';
                set.add(5);
                set.add('text');
                output += '添加元素后: ' + Array.from(set) + '\n';
                
                output += `set.has(3) = ${set.has(3)}\n`;
                output += `set.has(10) = ${set.has(10)}\n`;
                
                set.delete(3);
                output += '删除元素 3 后: ' + Array.from(set) + '\n\n';
                
                output += 'Set 遍历:\n';
                const setValues = [];
                for (const item of set) {
                    setValues.push(item);
                }
                output += `遍历结果: [${setValues}]\n\n`;
                
                output += 'Set 去重数组:\n';
                const uniqueArray = [...new Set([1, 2, 2, 3, 4, 4])];
                output += `[...new Set([1, 2, 2, 3, 4, 4])] = [${uniqueArray}]\n\n`;
                
                // Map 演示
                output += '=== Map 演示 ===\n';
                output += '创建 Map:\n';
                const map = new Map([
                    ['key1', 'value1'],
                    ['key2', 'value2']
                ]);
                output += `new Map([['key1','value1'],['key2','value2']])\n`;
                output += `map.size = ${map.size}\n\n`;
                
                output += 'Map 操作:\n';
                map.set('key3', 'value3');
                map.set(42, 'number key');
                const objKey = { id: 1 };
                map.set(objKey, 'object key');
                
                output += `map.get('key1') = "${map.get('key1')}"\n`;
                output += `map.get(42) = "${map.get(42)}"\n`;
                output += `map.get(objKey) = "${map.get(objKey)}"\n`;
                
                output += `map.has('key1') = ${map.has('key1')}\n`;
                
                map.delete('key2');
                output += '删除 key2 后:\n';
                
                // 显示 Map 内容
                output += 'Map 内容:\n';
                for (const [key, value] of map) {
                    const keyStr = typeof key === 'object' ? JSON.stringify(key) : String(key);
                    output += `  ${keyStr}: "${value}"\n`;
                }
            } catch (error) {
                output += `演示过程中出错: ${error.message}`;
            }
            
            result.textContent = output;
        }
        
        function runOptionalChainingDemo() {
            const result = document.getElementById('optionalChainingResult');
            let output = '=== 可选链和空值合并操作符演示 ===\n\n';
            
            try {
                // 可选链操作符
                output += '可选链操作符 (?.)\n';
                
                const user = {
                    profile: {
                        name: 'John'
                    }
                };
                
                output += `用户对象: ${JSON.stringify(user)}\n\n`;
                
                // 安全访问嵌套属性
                const city = user?.address?.city;
                output += `user?.address?.city = ${city}\n`;
                
                // 访问存在的属性
                const name = user?.profile?.name;
                output += `user?.profile?.name = "${name}"\n\n`;
                
                // 可选链与函数调用
                output += '可选链与函数调用:\n';
                const user1 = { getInfo: () => 'Info available' };
                const user2 = {};
                
                output += `user1?.getInfo?.() = "${user1?.getInfo?.()}"\n`;
                output += `user2?.getInfo?.() = ${user2?.getInfo?.()}\n\n`;
                
                // 空值合并操作符
                output += '空值合并操作符 (??)\n';
                
                // 与 || 对比
                output += '与 || 的对比:\n';
                const config = {
                    timeout: 0, // 合法值，但使用 || 会被视为假
                    retries: null,
                    name: ''
                };
                
                output += `配置对象: ${JSON.stringify(config)}\n\n`;
                
                output += '使用 ??:\n';
                output += `config.timeout ?? 3000 = ${config.timeout ?? 3000} (保留 0)\n`;
                output += `config.retries ?? 3 = ${config.retries ?? 3} (使用默认值)\n`;
                output += `config.name ?? "Anonymous" = "${config.name ?? "Anonymous"}" (保留空字符串)\n\n`;
                
                output += '使用 ||:\n';
                output += `config.timeout || 3000 = ${config.timeout || 3000} (0 被视为假值)\n`;
                output += `config.retries || 3 = ${config.retries || 3} (使用默认值)\n`;
                output += `config.name || "Anonymous" = "${config.name || "Anonymous"}" (空字符串被视为假值)\n\n`;
                
                // 结合使用
                output += '可选链与空值合并结合使用:\n';
                const defaultCity = user?.address?.city ?? 'Unknown';
                const defaultCountry = user?.address?.country ?? 'Default Country';
                
                output += `user?.address?.city ?? 'Unknown' = "${defaultCity}"\n`;
                output += `user?.address?.country ?? 'Default Country' = "${defaultCountry}"`;
            } catch (error) {
                output += `演示过程中出错: ${error.message}`;
            }
            
            result.textContent = output;
        }
        
        // 辅助函数：代码高亮
        function highlightCode() {
            const codeBlocks = document.querySelectorAll('.demo-box');
            codeBlocks.forEach(block => {
                // 在实际项目中可以使用更复杂的代码高亮库
                // 这里简单处理一下特殊字符
                const content = block.textContent
                    .replace(/(\/\/.*$)/gm, '<span style="color: #6a9955">$1</span>')
                    .replace(/('.*?'|"{1}.*?")/g, '<span style="color: #ce9178">$1</span>')
                    .replace(/(\bconst\b|\blet\b|\bvar\b|\bfunction\b|\bclass\b|\bextends\b|\bsuper\b|\bstatic\b|\breturn\b|\bif\b|\belse\b|\bfor\b|\bwhile\b|\bswitch\b|\bcase\b|\bdefault\b|\btry\b|\bcatch\b|\bfinally\b|\basync\b|\bawait\b|\bnew\b|\bthis\b|\bnull\b|\bundefined\b|\btrue\b|\bfalse\b)/g, '<span style="color: #569cd6">$1</span>')
                    .replace(/(\d+)/g, '<span style="color: #b5cea8">$1</span>')
                    .replace(/(\.\.\.|\?\.|\?\?|=\>|\*\*|\/\/)/g, '<span style="color: #d4d4d4">$1</span>');
                
                // 检查是否支持 innerHTML
                if (block.tagName === 'PRE' || block.tagName === 'CODE') {
                    block.innerHTML = content;
                }
            });
        }
        
        // 页面加载时执行
        document.addEventListener('DOMContentLoaded', function() {
            // 这里可以添加页面加载时的初始化逻辑
            console.log('ES6+ Features Demo Loaded');
        });
    </script>
</body>
</html>