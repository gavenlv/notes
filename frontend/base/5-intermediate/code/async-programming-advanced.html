\u003c!DOCTYPE html\u003e
\u003chtml lang="zh-CN"\u003e
\u003chead\u003e
    \u003cmeta charset="UTF-8"\u003e
    \u003cmeta name="viewport" content="width=device-width, initial-scale=1.0"\u003e
    \u003ctitle\u003eJavaScript 异步编程进阶详解\u003c/title\u003e
    \u003cstyle\u003e
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        
        h1, h2, h3, h4 {
            color: #2c3e50;
        }
        
        h1 {
            text-align: center;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 40px;
        }
        
        h2 {
            border-left: 4px solid #3498db;
            padding-left: 15px;
            margin-top: 50px;
        }
        
        h3 {
            color: #3498db;
            margin-top: 30px;
        }
        
        .container {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .code-block {
            background-color: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 6px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        
        .code-line {
            display: block;
        }
        
        .comment {
            color: #98c379;
        }
        
        .keyword {
            color: #c678dd;
        }
        
        .string {
            color: #e5c07b;
        }
        
        .function {
            color: #61afef;
        }
        
        .demo-section {
            margin-bottom: 40px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 6px;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .result {
            background-color: #e8f4f8;
            border: 1px solid #b3e5fc;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            min-height: 100px;
        }
        
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-item {
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #ddd;
        }
        
        .before {
            background-color: #f8d7da;
            border-left: 4px solid #dc3545;
        }
        
        .after {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
        }
        
        .explanation {
            background-color: #e7f3ff;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 4px solid #0d6efd;
        }
        
        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }
        
        .pros {
            background-color: #d4edda;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #28a745;
        }
        
        .cons {
            background-color: #f8d7da;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #dc3545;
        }
        
        ul {
            padding-left: 20px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        .diagram {
            background-color: #f0f0f0;
            padding: 20px;
            border-radius: 6px;
            text-align: center;
            margin: 20px 0;
            font-family: monospace;
            white-space: pre;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background-color: #f2f2f2;
        }
        
        tr:hover {
            background-color: #f5f5f5;
        }
        
        .highlight {
            background-color: #ffeb3b;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .note {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 4px solid #ffc107;
            font-weight: bold;
        }
        
        .timeline {
            position: relative;
            padding: 20px 0;
            margin: 20px 0;
        }
        
        .timeline-item {
            padding: 10px 30px;
            position: relative;
            background-color: #fff;
            border-radius: 6px;
            margin-bottom: 10px;
            border-left: 3px solid #3498db;
        }
        
        .timeline-item::before {
            content: '';
            position: absolute;
            left: -8px;
            top: 15px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #3498db;
        }
        
        @media (max-width: 768px) {
            .comparison,
            .pros-cons {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 15px;
            }
            
            body {
                padding: 10px;
            }
        }
    \u003c/style\u003e
\u003c/head\u003e
\u003cbody\u003e
    \u003ch1\u003eJavaScript 异步编程进阶详解\u003c/h1\u003e
    \u003cdiv class="container"\u003e
        \u003cp\u003e本教程深入探讨 JavaScript 异步编程的高级概念和技术，包括 Promise 高级用法、async/await 深度解析、事件循环机制、并发控制模式以及现代异步编程最佳实践。掌握这些概念对于构建高性能、可靠的 JavaScript 应用至关重要。\u003c/p\u003e
    \u003c/div\u003e

    \u003c!-- 1. Promise 深入理解 --\u003e
    \u003csection class="demo-section"\u003e
        \u003ch2\u003e1. Promise 深入理解\u003c/h2\u003e
        \u003cdiv class="explanation"\u003e
            \u003cp\u003ePromise 是 JavaScript 处理异步操作的标准方式，理解 Promise 的内部工作原理和高级用法对于掌握异步编程至关重要。\u003c/p\u003e
        \u003c/div\u003e

        \u003ch3\u003e1.1 Promise 内部状态与工作原理\u003c/h3\u003e
        \u003cdiv class="code-block"\u003e
\u003cspan class="comment"\u003e// Promise 的三种状态：pending, fulfilled, rejected\u003c/span\u003e
\u003cspan class="keyword"\u003efunction\u003c/span\u003e \u003cspan class="function"\u003esimulatePromiseImplementation\u003c/span\u003e() {
    \u003cspan class="comment"\u003e// 模拟 Promise 的内部实现原理\u003c/span\u003e
    \u003cspan class="keyword"\u003efunction\u003c/span\u003e \u003cspan class="function"\u003eSimplePromise\u003c/span\u003e(executor) {
        \u003cspan class="keyword"\u003econst\u003c/span\u003e that = this;
        that.state = 'pending';
        that.value = null;
        that.reason = null;
        that.onFulfilledCallbacks = [];
        that.onRejectedCallbacks = [];
        \u003cspan class="comment"\u003e// 状态只能从 pending 转换到 fulfilled 或 rejected，且一旦转换就不能再变\u003c/span\u003e
        
        \u003cspan class="keyword"\u003efunction\u003c/span\u003e \u003cspan class="function"\u003eresolve\u003c/span\u003e(value) {
            \u003cspan class="keyword"\u003eif\u003c/span\u003e (that.state === 'pending') {
                that.state = 'fulfilled';
                that.value = value;
                that.onFulfilledCallbacks.forEach(callback =\u003e callback(that.value));
            }
        }
        
        \u003cspan class="keyword"\u003efunction\u003c/span\u003e \u003cspan class="function"\u003ereject\u003c/span\u003e(reason) {
            \u003cspan class="keyword"\u003eif\u003c/span\u003e (that.state === 'pending') {
                that.state = 'rejected';
                that.reason = reason;
                that.onRejectedCallbacks.forEach(callback =\u003e callback(that.reason));
            }
        }
        
        \u003cspan class="keyword"\u003etry\u003c/span\u003e {
            executor(resolve, reject);
        } \u003cspan class="keyword"\u003ecatch\u003e/span\u003e (e) {
            reject(e);
        }
    }
    
    SimplePromise.prototype.then = \u003cspan class="keyword"\u003efunction\u003c/span\u003e(onFulfilled, onRejected) {
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : \u003cspan class="keyword"\u003efunction\u003c/span\u003e(value) {\u003cspan class="keyword"\u003ereturn\u003c/span\u003e value; };
        onRejected = typeof onRejected === 'function' ? onRejected : \u003cspan class="keyword"\u003efunction\u003c/span\u003e(reason) {\u003cspan class="keyword"\u003ethrow\u003c/span\u003e reason; };
        
        \u003cspan class="keyword"\u003econst\u003c/span\u003e promise2 = \u003cspan class="keyword"\u003enew\u003c/span\u003e SimplePromise(\u003cspan class="keyword"\u003efunction\u003c/span\u003e(resolve, reject) {
            \u003cspan class="keyword"\u003eif\u003c/span\u003e (this.state === 'fulfilled') {
                setTimeout(\u003cspan class="keyword"\u003efunction\u003c/span\u003e() {
                    \u003cspan class="keyword"\u003etry\u003c/span\u003e {
                        \u003cspan class="keyword"\u003econst\u003c/span\u003e x = onFulfilled(this.value);
                        resolve(x);
                    } \u003cspan class="keyword"\u003ecatch\u003e/span\u003e (e) {
                        reject(e);
                    }
                }, 0);
            }
            
            \u003cspan class="keyword"\u003eif\u003c/span\u003e (this.state === 'rejected') {
                setTimeout(\u003cspan class="keyword"\u003efunction\u003c/span\u003e() {
                    \u003cspan class="keyword"\u003etry\u003c/span\u003e {
                        \u003cspan class="keyword"\u003econst\u003c/span\u003e x = onRejected(this.reason);
                        resolve(x);
                    } \u003cspan class="keyword"\u003ecatch\u003e/span\u003e (e) {
                        reject(e);
                    }
                }, 0);
            }
            \u003cspan class="keyword"\u003eif\u003c/span\u003e (this.state === 'pending') {
                this.onFulfilledCallbacks.push(\u003cspan class="keyword"\u003efunction\u003c/span\u003e(value) {
                    \u003cspan class="keyword"\u003etry\u003c/span\u003e {
                        \u003cspan class="keyword"\u003econst\u003c/span\u003e x = onFulfilled(value);
                        resolve(x);
                    } \u003cspan class="keyword"\u003ecatch\u003e/span\u003e (e) {
                        reject(e);
                    }
                });
                
                this.onRejectedCallbacks.push(\u003cspan class="keyword"\u003efunction\u003c/span\u003e(reason) {
                    \u003cspan class="keyword"\u003etry\u003c/span\u003e {
                        \u003cspan class="keyword"\u003econst\u003c/span\u003e x = onRejected(reason);
                        resolve(x);
                    } \u003cspan class="keyword"\u003ecatch\u003e/span\u003e (e) {
                        reject(e);
                    }
                });
            }
        }.bind(this));
        
        \u003cspan class="keyword"\u003ereturn\u003c/span\u003e promise2;
    };
    
    \u003cspan class="keyword"\u003ereturn\u003c/span\u003e SimplePromise;
}

\u003cspan class="comment"\u003e// Promise 链式调用的核心原理：每次 then 都会返回一个新的 Promise\u003c/span\u003e
\u003cspan class="keyword"\u003enew\u003c/span\u003e Promise(\u003cspan class="keyword"\u003efunction\u003c/span\u003e(resolve, reject) {
    setTimeout(() =\u003e resolve(1), 100);
})
.then(value =\u003e {
    console.log(value); // 输出: 1
    \u003cspan class="keyword"\u003ereturn\u003c/span\u003e value + 1;
})
.then(value =\u003e {
    console.log(value); // 输出: 2
    \u003cspan class="keyword"\u003ereturn\u003c/span\u003e value + 1;
})
.then(value =\u003e {
    console.log(value); // 输出: 3
    \u003cspan class="keyword"\u003ethrow\u003c/span\u003e new Error('出错了');
})
.catch(error =\u003e {
    console.log('捕获错误:', error.message); // 输出: 捕获错误: 出错了
    \u003cspan class="keyword"\u003ereturn\u003c/span\u003e 0; // 恢复链式调用
})
.then(value =\u003e {
    console.log('恢复后的值:', value); // 输出: 恢复后的值: 0
});
        \u003c/div\u003e

        \u003ch3\u003e1.2 Promise 静态方法详解\u003c/h3\u003e
        \u003cdiv class="code-block"\u003e
\u003cspan class="comment"\u003e// Promise.all - 等待所有 Promise 完成，返回所有结果的数组\u003c/span\u003e
\u003cspan class="keyword"\u003efunction\u003c/span\u003e \u003cspan class="function"\u003edemoPromiseAll\u003c/span\u003e() {
    \u003cspan class="keyword"\u003econst\u003c/span\u003e promise1 = Promise.resolve(3);
    \u003cspan class="keyword"\u003econst\u003c/span\u003e promise2 = 42;
    \u003cspan class="keyword"\u003econst\u003c/span\u003e promise3 = new Promise(\u003cspan class="keyword"\u003efunction\u003c/span\u003e(resolve, reject) {
        setTimeout(resolve, 100, 'foo');
    });
    
    \u003cspan class="keyword"\u003ereturn\u003c/span\u003e Promise.all([promise1, promise2, promise3])
        .then(values =\u003e {
            console.log(values); // 输出: [3, 42, "foo"]
            \u003cspan class="keyword"\u003ereturn\u003c/span\u003e values;
        })
        .catch(error =\u003e {
            console.error('Promise.all 错误:', error);
        });
}

\u003cspan class="comment"\u003e// Promise.race - 返回第一个完成的 Promise 的结果或错误\u003c/span\u003e
\u003cspan class="keyword"\u003efunction\u003c/span\u003e \u003cspan class="function"\u003edemoPromiseRace\u003c/span\u003e() {
    \u003cspan class="keyword"\u003econst\u003c/span\u003e promise1 = new Promise(\u003cspan class="keyword"\u003efunction\u003c/span\u003e(resolve, reject) {
        setTimeout(resolve, 500, '一个较慢的 Promise');
    });
    
    \u003cspan class="keyword"\u003econst\u003c/span\u003e promise2 = new Promise(\u003cspan class="keyword"\u003efunction\u003c/span\u003e(resolve, reject) {
        setTimeout(resolve, 100, '一个较快的 Promise');
    });
    
    \u003cspan class="keyword"\u003econst\u003c/span\u003e promise3 = new Promise(\u003cspan class="keyword"\u003efunction\u003c/span\u003e(resolve, reject) {
        setTimeout(reject, 200, '一个会失败的 Promise');
    });
    
    \u003cspan class="comment"\u003e// 演示成功的情况
    Promise.race([promise1, promise2])
        .then(value =\u003e {
            console.log('Promise.race 结果:', value); // 输出: 一个较快的 Promise
        });
    
    \u003cspan class="comment"\u003e// 演示失败的情况
    \u003cspan class="keyword"\u003ereturn\u003c/span\u003e Promise.race([promise1, promise3])
        .then(value =\u003e {
            console.log('不会执行到这里');
        })
        .catch(error =\u003e {
            console.log('Promise.race 错误:', error); // 输出: 一个会失败的 Promise
            \u003cspan class="keyword"\u003ereturn\u003c/span\u003e error;
        });
}

\u003cspan class="comment"\u003e// Promise.allSettled - 返回所有 Promise 的结果，无论成功还是失败\u003c/span\u003e
\u003cspan class="keyword"\u003efunction\u003c/span\u003e \u003cspan class="function"\u003edemoPromiseAllSettled\u003c/span\u003e() {
    \u003cspan class="keyword"\u003econst\u003c/span\u003e promise1 = Promise.resolve(3);
    \u003cspan class="keyword"\u003econst\u003c/span\u003e promise2 = new Promise(\u003cspan class="keyword"\u003efunction\u003c/span\u003e(resolve, reject) {
        setTimeout(reject, 100, '失败了');
    });
    
    \u003cspan class="keyword"\u003ereturn\u003c/span\u003e Promise.allSettled([promise1, promise2])
        .then(results =\u003e {
            console.log('Promise.allSettled 结果:');
            results.forEach(result =\u003e {
                console.log(result);
                // 输出:
                // { status: "fulfilled", value: 3 }
                // { status: "rejected", reason: "失败了" }
            });
            \u003cspan class="keyword"\u003ereturn\u003c/span\u003e results;
        });
}

\u003cspan class="comment"\u003e// Promise.any - 返回第一个成功的 Promise 的结果，如果所有都失败则返回 AggregateError\u003c/span\u003e
\u003cspan class="keyword"\u003efunction\u003c/span\u003e \u003cspan class="function"\u003edemoPromiseAny\u003c/span\u003e() {
    \u003cspan class="keyword"\u003econst\u003c/span\u003e promise1 = new Promise(\u003cspan class="keyword"\u003efunction\u003c/span\u003e(resolve, reject) {
        setTimeout(reject, 100, '首先失败');
    });
    
    \u003cspan class="keyword"\u003econst\u003c/span\u003e promise2 = new Promise(\u003cspan class="keyword"\u003efunction\u003c/span\u003e(resolve, reject) {
        setTimeout(resolve, 200, '成功了');
    });
    
    \u003cspan class="keyword"\u003econst\u003c/span\u003e promise3 = new Promise(\u003cspan class="keyword"\u003efunction\u003c/span\u003e(resolve, reject) {
        setTimeout(resolve, 300, '也成功了');
    });
    
    \u003cspan class="keyword"\u003ereturn\u003c/span\u003e Promise.any([promise1, promise2, promise3])
        .then(value =\u003e {
            console.log('Promise.any 结果:', value); // 输出: 成功了
            \u003cspan class="keyword"\u003ereturn\u003c/span\u003e value;
        })
        .catch(error =\u003e {
            console.error('Promise.any 错误:', error);
        });
}

\u003cspan class="comment"\u003e// Promise.resolve 和 Promise.reject - 创建已解析或已拒绝的 Promise\u003c/span\u003e
\u003cspan class="keyword"\u003efunction\u003c/span\u003e \u003cspan class="function"\u003edemoPromiseStaticMethods\u003c/span\u003e() {
    \u003cspan class="comment"\u003e// Promise.resolve
    const resolvedPromise = Promise.resolve('直接成功');
    resolvedPromise.then(value =\u003e {
        console.log('Promise.resolve 结果:', value); // 输出: 直接成功
    });
    
    \u003cspan class="comment"\u003e// 如果传递给 Promise.resolve 的是一个 Promise，它会直接返回该 Promise
    const anotherPromise = Promise.resolve(resolvedPromise);
    console.log('是否是同一个 Promise:', resolvedPromise === anotherPromise); // 输出: true
    
    \u003cspan class="comment"\u003e// Promise.reject
    const rejectedPromise = Promise.reject(new Error('直接失败'));
    \u003cspan class="keyword"\u003ereturn\u003c/span\u003e rejectedPromise
        .catch(error =\u003e {
            console.log('Promise.reject 错误:', error.message); // 输出: 直接失败
            \u003cspan class="keyword"\u003ereturn\u003c/span\u003e error;
        });
}
        \u003c/div\u003e

        \u003cdiv class="comparison"\u003e
            \u003cdiv class="comparison-item before"\u003e
                \u003ch4\u003ePromise.all vs Promise.race vs Promise.allSettled vs Promise.any\u003c/h4\u003e
                \u003ctable\u003e
                    \u003ctr\u003e
                        \u003cth\u003e方法\u003c/th\u003e
                        \u003cth\u003e行为\u003c/th\u003e
                        \u003cth\u003e成功条件\u003c/th\u003e
                        \u003cth\u003e失败条件\u003c/th\u003e
                    \u003c/tr\u003e
                    \u003ctr\u003e
                        \u003ctd\u003ePromise.all()\u003c/td\u003e
                        \u003ctd\u003e等待所有完成\u003c/td\u003e
                        \u003ctd\u003e所有 Promise 都成功\u003c/td\u003e
                        \u003ctd\u003e任一 Promise 失败即失败\u003c/td\u003e
                    \u003c/tr\u003e
                    \u003ctr\u003e
                        \u003ctd\u003ePromise.race()\u003c/td\u003e
                        \u003ctd\u003e等待第一个完成
                        \u003c/td\u003e
                        \u003ctd\u003e第一个完成的 Promise 成功
                        \u003c/td\u003e
                        \u003ctd\u003e第一个完成的 Promise 失败
                        \u003c/td\u003e
                    \u003c/tr\u003e
                    \u003ctr\u003e
                        \u003ctd\u003ePromise.allSettled()\u003c/td\u003e
                        \u003ctd\u003e等待所有完成
                        \u003c/td\u003e
                        \u003ctd\u003e总是成功，返回所有结果
                        \u003c/td\u003e
                        \u003ctd\u003e永远不会失败
                        \u003c/td\u003e
                    \u003c/tr\u003e
                    \u003ctr\u003e
                        \u003ctd\u003ePromise.any()\u003c/td\u003e
                        \u003ctd\u003e等待第一个成功
                        \u003c/td\u003e
                        \u003ctd\u003e任一 Promise 成功即成功
                        \u003c/td\u003e
                        \u003ctd\u003e所有 Promise 都失败才失败
                        \u003c/td\u003e
                    \u003c/tr\u003e
                \u003ctable\u003e
            \u003c/div\u003e
        \u003c/div\u003e
        \u003c/section\u003e

        \u003cbutton onclick="runPromiseDemo()"\u003e运行 Promise 演示\u003c/button\u003e
        \u003cdiv id="promiseResult" class="result"\u003e点击按钮查看运行结果...\u003c/div\u003e
    \u003c/section\u003e

    \u003c!-- 3. 事件循环机制 --\u003e
    \u003csection class="demo-section"\u003e
        \u003ch2\u003e3. 事件循环机制 (Event Loop)\u003c/h2\u003e
        \u003cdiv class="explanation"\u003e
            \u003cp\u003e事件循环是 JavaScript 异步编程的核心机制，它决定了代码的执行顺序。理解事件循环对于掌握异步编程至关重要。\u003c/p\u003e
        \u003c/div\u003e

        \u003ch3\u003e3.1 事件循环的基本概念\u003c/h3\u003e
        \u003cdiv class="diagram"\u003e
事件循环 (Event Loop) 架构：

┌───────────────────────────────────────┐
│           调用栈 (Call Stack)          │
└───────────────────────────┬───────────┘
                            │
┌───────────────────────────▼───────────┐
│            Web API 环境                │
│  (setTimeout, fetch, DOM 事件等)      │
└───────────────────────────┬───────────┘
                            │
┌───────────────────────────▼───────────┐
│           任务队列 (Task Queue)        │
└───────────────────────────┬───────────┘
                            │
┌───────────────────────────▼───────────┐
│         微任务队列 (Microtask Queue)   │
└───────────────────────────┬───────────┘
                            │
┌───────────────────────────▼───────────┐
│           渲染阶段 (Render Phase)      │
└───────────────────────────────────────┘
        \u003c/div\u003e

        \u003cdiv class="explanation"\u003e
            \u003cp\u003e事件循环的执行过程：\u003c/p\u003e
            \u003col\u003e
                \u003cli\u003e执行调用栈中的同步代码，直到栈为空\u003c/li\u003e
                \u003cli\u003e处理所有微任务队列中的任务，按照先进先出的顺序执行，直到队列为空\u003c/li\u003e
                \u003cli\u003e必要时渲染 UI\u003c/li\u003e
                \u003cli\u003e从任务队列中取出一个任务执行\u003c/li\u003e
                \u003cli\u003e重复步骤 1-4
                \u003c/li\u003e
            \u003c/ol\u003e
        \u003c/div\u003e

        \u003ch3\u003e3.2 宏任务与微任务\u003c/h3\u003e
        \u003cdiv class="code-block"\u003e
// 宏任务 (MacroTask) 和微任务 (MicroTask) 示例
console.log('1. 开始同步代码');

// 宏任务 - setTimeout
setTimeout(() => {
    console.log('4. 这是一个宏任务 (setTimeout)');
    
    // 在宏任务中创建微任务
    Promise.resolve().then(() => {
        console.log('5. 宏任务中的微任务');
    });
}, 0);

// 微任务 - Promise.then
Promise.resolve().then(() => {
    console.log('3. 这是一个微任务 (Promise.then)');
    
    // 在微任务中创建新的微任务
    Promise.resolve().then(() => {
        console.log('3.1 微任务中的微任务');
    });
});

console.log('2. 结束同步代码');

// 输出顺序：
// 1. 开始同步代码
// 2. 结束同步代码
// 3. 这是一个微任务 (Promise.then)
// 3.1 微任务中的微任务
// 4. 这是一个宏任务 (setTimeout)
// 5. 宏任务中的微任务
        \u003c/div\u003e

        \u003cdiv class="comparison"\u003e
            \u003cdiv class="comparison-item before"\u003e
                \u003ch4\u003e宏任务 (MacroTask)\u003c/h4\u003e
                \u003cul\u003e
                    \u003cli\u003esetTimeout/setInterval
                    \u003c/li\u003e
                    \u003cli\u003esetImmediate (Node.js)
                    \u003c/li\u003e
                    \u003cli\u003erequestAnimationFrame
                    \u003c/li\u003e
                    \u003cli\u003eI/O 操作
                    \u003c/li\u003e
                    \u003cli\u003eUI 渲染事件
                    \u003c/li\u003e
                    \u003cli\u003escript 标签的执行
                    \u003c/li\u003e
                \u003c/ul\u003e
            \u003c/div\u003e
            \u003cdiv class="comparison-item after"\u003e
                \u003ch4\u003e微任务 (MicroTask)\u003c/h4\u003e
                \u003cul\u003e
                    \u003cli\u003ePromise 的 then/catch/finally 回调
                    \u003c/li\u003e
                    \u003cli\u003equeueMicrotask
                    \u003c/li\u003e
                    \u003cli\u003eMutationObserver
                    \u003c/li\u003e
                    \u003cli\u003eprocess.nextTick (Node.js)
                    \u003c/li\u003e
                \u003c/ul\u003e
            \u003c/div\u003e
        \u003c/div\u003e

        \u003ch3\u003e3.3 事件循环演示\u003c/h3\u003e
        \u003cbutton onclick="runEventLoopDemo()"\u003e运行事件循环演示\u003c/button\u003e
        \u003cdiv id="eventLoopResult" class="result"\u003e点击按钮查看运行结果...\u003c/div\u003e
    \u003c/section\u003e

    \u003c!-- 4. 并发控制模式 --\u003e
    \u003csection class="demo-section"\u003e
        \u003ch2\u003e4. 并发控制模式\u003c/h2\u003e
        \u003cdiv class="explanation"\u003e
            \u003cp\u003e在处理大量异步操作时，合理的并发控制可以避免资源耗尽，提高系统稳定性和性能。\u003c/p\u003e
        \u003c/div\u003e

        \u003ch3\u003e4.1 限制并发数量\u003c/h3\u003e
        \u003cdiv class="code-block"\u003e
// 并发控制 - 限制同时执行的异步任务数量
class ConcurrencyLimiter {
    constructor(maxConcurrent) {
        this.maxConcurrent = maxConcurrent;
        this.activeTasks = 0;
        this.queue = [];
    }

    async run(task) {
        return new Promise((resolve, reject) => {
            // 创建一个包装任务，包含原始任务和解析/拒绝函数
            const wrappedTask = async () => {
                try {
                    const result = await task();
                    resolve(result);
                } catch (error) {
                    reject(error);
                } finally {
                    // 任务完成后减少活跃任务计数，并处理队列中的下一个任务
                    this.activeTasks--;
                    this._processQueue();
                }
            };

            // 添加到队列
            this.queue.push(wrappedTask);
            // 尝试处理队列
            this._processQueue();
        });
    }

    _processQueue() {
        // 如果活跃任务数量小于最大限制且队列不为空，则执行队列中的任务
        while (this.activeTasks < this.maxConcurrent && this.queue.length > 0) {
            const task = this.queue.shift();
            this.activeTasks++;
            // 使用异步函数立即执行任务
            (async () => {
                await task();
            })();
        }
    }

    // 获取当前等待的任务数量
    get queueLength() {
        return this.queue.length;
    }
}

// 演示并发控制
async function demoConcurrencyControl() {
    const resultElement = document.getElementById('concurrencyResult');
    resultElement.textContent = '开始执行并发控制演示...\n';
    
    const log = (message) => {
        resultElement.textContent += message + '\n';
        console.log(message);
    };

    // 创建一个并发限制器，最多同时执行2个任务
    const limiter = new ConcurrencyLimiter(2);

    // 创建模拟异步任务的函数
    const createTask = (id, delay) => () => {
        log(`任务 ${id} 开始执行`);
        return new Promise(resolve => {
            setTimeout(() => {
                log(`任务 ${id} 执行完成，耗时 ${delay}ms`);
                resolve(`任务 ${id} 结果`);
            }, delay);
        });
    };

    // 创建多个任务
    const tasks = [
        createTask(1, 2000),
        createTask(2, 1000),
        createTask(3, 3000),
        createTask(4, 1500),
        createTask(5, 2500)
    ];

    log('所有任务开始提交...');
    
    // 使用限制器执行所有任务
    const promises = tasks.map((task, index) => 
        limiter.run(task).then(result => {
            log(`成功获取 ${result}`);
            return result;
        })
    );

    // 等待所有任务完成
    const results = await Promise.all(promises);
    log('所有任务已完成');
    log(`最终结果: ${results.join(', ')}`);
}
        \u003c/div\u003e

        \u003ch3\u003e4.2 批量处理与重试机制\u003c/h3\u003e
        \u003cdiv class="code-block"\u003e
// 批量处理异步任务
async function batchProcess(items, batchSize, processor) {
    const results = [];
    
    // 将数组分成多个批次
    for (let i = 0; i < items.length; i += batchSize) {
        const batch = items.slice(i, i + batchSize);
        // 并行处理当前批次的所有项目
        const batchResults = await Promise.all(
            batch.map(item => processor(item))
        );
        results.push(...batchResults);
    }
    
    return results;
}

// 带重试机制的异步操作
async function withRetry(operation, maxRetries = 3, delay = 1000) {
    try {
        return await operation();
    } catch (error) {
        if (maxRetries > 0) {
            console.log(`操作失败，${delay}ms 后重试，剩余重试次数: ${maxRetries}`);
            // 等待一段时间后重试
            await new Promise(resolve => setTimeout(resolve, delay));
            // 递归调用，减少重试次数，增加延迟时间（指数退避）
            return withRetry(operation, maxRetries - 1, delay * 2);
        } else {
            console.error('所有重试都失败了');
            throw error;
        }
    }
}

// 演示批量处理和重试机制
async function demoBatchAndRetry() {
    const resultElement = document.getElementById('batchResult');
    resultElement.textContent = '开始执行批量处理和重试机制演示...\n';
    
    const log = (message) => {
        resultElement.textContent += message + '\n';
        console.log(message);
    };

    // 模拟不稳定的API调用，有30%的概率失败
    const unstableApiCall = (id) => {
        log(`调用API处理ID: ${id}`);
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                if (Math.random() < 0.3) {
                    reject(new Error(`API调用失败，ID: ${id}`));
                } else {
                    resolve(`处理成功，ID: ${id}`);
                }
            }, Math.random() * 1000 + 500); // 500-1500ms的随机延迟
        });
    };

    // 创建ID数组
    const ids = Array.from({ length: 10 }, (_, i) => i + 1);
    log(`准备处理 ${ids.length} 个ID，批量大小为3`);

    try {
        // 批量处理，每批3个，并且每个操作都有重试机制
        const results = await batchProcess(
            ids,
            3,
            id => withRetry(() => unstableApiCall(id), 3, 500)
        );
        
        log('所有批量处理完成');
        log(`结果: ${results.join(', ')}`);
    } catch (error) {
        log(`批量处理发生错误: ${error.message}`);
    }
}
        \u003c/div\u003e

        \u003cdiv class="pros-cons"\u003e
            \u003cdiv class="pros"\u003e
                \u003ch4\u003e并发控制的优势\u003c/h4\u003e
                \u003cul\u003e
                    \u003cli\u003e避免系统资源耗尽（内存、网络连接等）
                    \u003c/li\u003e
                    \u003cli\u003e减少对外部API的压力，避免触发限流
                    \u003c/li\u003e
                    \u003cli\u003e提高系统稳定性和可靠性
                    \u003c/li\u003e
                    \u003cli\u003e更好地控制和预测系统负载
                    \u003c/li\u003e
                    \u003cli\u003e通过重试机制提高操作成功率
                    \u003c/li\u003e
                \u003c/ul\u003e
            \u003c/div\u003e
            \u003cdiv class="cons"\u003e
                \u003ch4\u003e需要注意的问题\u003c/h4\u003e
                \u003cul\u003e
                    \u003cli\u003e过多的任务排队可能导致内存占用增加
                    \u003c/li\u003e
                    \u003cli\u003e并发度过低可能导致性能下降
                    \u003c/li\u003e
                    \u003cli\u003e重试机制需要谨慎设计，避免雪崩效应
                    \u003c/li\u003e
                    \u003cli\u003e需要合理设置超时时间，避免长时间阻塞
                    \u003c/li\u003e
                    \u003cli\u003e复杂的错误处理和状态管理
                    \u003c/li\u003e
                \u003c/ul\u003e
            \u003c/div\u003e
        \u003c/div\u003e

        \u003cbutton onclick="demoConcurrencyControl()"\u003e运行并发控制演示\u003c/button\u003e
        \u003cdiv id="concurrencyResult" class="result"\u003e点击按钮查看运行结果...\u003c/div\u003e
        
        \u003cbutton onclick="demoBatchAndRetry()"\u003e运行批量处理和重试演示\u003c/button\u003e
        \u003cdiv id="batchResult" class="result"\u003e点击按钮查看运行结果...\u003c/div\u003e
    \u003c/section\u003e

    \u003c!-- 5. 异步编程最佳实践 --\u003e
    \u003csection class="demo-section"\u003e
        \u003ch2\u003e5. 异步编程最佳实践\u003c/h2\u003e
        \u003cdiv class="explanation"\u003e
            \u003cp\u003e遵循以下最佳实践可以帮助您编写更可靠、更易维护的异步代码。\u003c/p\u003e
        \u003c/div\u003e

        \u003ch3\u003e5.1 错误处理与调试\u003c/h3\u003e
        \u003cdiv class="code-block"\u003e
// 全面的错误处理
async function fetchDataWithErrorHandling(url) {
    try {
        const controller = new AbortController();
        const { signal } = controller;
        
        // 设置超时
        const timeoutId = setTimeout(() => controller.abort(), 5000);
        
        try {
            const response = await fetch(url, { signal });
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                // 处理HTTP错误
                const errorData = await response.json().catch(() => ({}));
                const error = new Error(`HTTP错误 ${response.status}: ${response.statusText}`);
                error.status = response.status;
                error.data = errorData;
                throw error;
            }
            
            return await response.json();
        } catch (error) {
            clearTimeout(timeoutId);
            
            // 特殊处理中止错误
            if (error.name === 'AbortError') {
                throw new Error('请求超时');
            }
            
            // 处理网络错误
            if (!error.status) {
                throw new Error(`网络错误: ${error.message || '未知错误'}`);
            }
            
            throw error;
        }
    } catch (error) {
        // 记录详细错误信息
        console.error('获取数据失败:', {
            url,
            error: {
                name: error.name,
                message: error.message,
                status: error.status,
                stack: error.stack
            }
        });
        
        // 重新抛出错误以便调用者处理
        throw error;
    }
}

// 调用示例
async function exampleErrorHandling() {
    try {
        const data = await fetchDataWithErrorHandling('https://api.example.com/data');
        console.log('成功获取数据:', data);
    } catch (error) {
        // 根据错误类型进行不同的处理
        if (error.message.includes('超时')) {
            console.error('请求超时，请检查网络连接');
        } else if (error.status === 404) {
            console.error('请求的资源不存在');
        } else if (error.status === 401) {
            console.error('未授权，请登录');
        } else {
            console.error('发生错误:', error.message);
        }
    }
}
        \u003c/div\u003e

        \u003ch3\u003e5.2 性能优化技巧\u003c/h3\u003e
        \u003cdiv class="code-block"\u003e
// 性能优化技巧示例

// 1. 避免不必要的Promise创建
function badExample() {
    // 不必要的Promise包装
    return new Promise(resolve => {
        resolve(42);
    });
}

function goodExample() {
    // 直接返回值，JavaScript会自动包装成Promise
    return 42;
}

// 2. 合理使用Promise.all进行并行操作
async function fetchMultipleResources() {
    // 同时发起多个请求，等待所有结果
    const [users, posts, comments] = await Promise.all([
        fetch('/api/users').then(r => r.json()),
        fetch('/api/posts').then(r => r.json()),
        fetch('/api/comments').then(r => r.json())
    ]);
    
    return { users, posts, comments };
}

// 3. 使用缓存避免重复请求
const cache = new Map();

async function fetchWithCache(url) {
    // 检查缓存
    if (cache.has(url)) {
        console.log('从缓存获取:', url);
        return cache.get(url);
    }
    
    // 发起请求并缓存结果
    const response = await fetch(url);
    const data = await response.json();
    
    // 设置缓存，这里可以添加过期逻辑
    cache.set(url, data);
    
    return data;
}

// 4. 使用防抖和节流控制异步操作频率
function debounce(fn, delay) {
    let timeoutId;
    return function (...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => fn.apply(this, args), delay);
    };
}

function throttle(fn, limit) {
    let inThrottle;
    return function (...args) {
        if (!inThrottle) {
            fn.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// 5. 使用Web Workers处理复杂计算，避免阻塞主线程
function runInWorker(computeFn, data) {
    return new Promise((resolve, reject) => {
        // 创建Worker
        const workerCode = `
            self.onmessage = function(e) {
                const computeFn = ${computeFn.toString()};
                try {
                    const result = computeFn(e.data);
                    self.postMessage({ result });
                } catch (error) {
                    self.postMessage({ error: error.message });
                }
            };
        `;
        
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const worker = new Worker(URL.createObjectURL(blob));
        
        // 处理结果
        worker.onmessage = function(e) {
            if (e.data.error) {
                reject(new Error(e.data.error));
            } else {
                resolve(e.data.result);
            }
            worker.terminate();
        };
        
        // 处理错误
        worker.onerror = function(error) {
            reject(error);
            worker.terminate();
        };
        
        // 发送数据
        worker.postMessage(data);
    });
}
        \u003c/div\u003e

        \u003ch3\u003e5.3 代码组织与可读性\u003c/h3\u003e
        \u003cdiv class="code-block"\u003e
// 良好的异步代码组织示例

// 1. 将复杂的异步逻辑拆分为小型、专注的函数
async function getUserProfile(userId) {
    // 专注于获取用户资料
    const userData = await fetchUserData(userId);
    const preferences = await fetchUserPreferences(userId);
    const activity = await fetchUserActivity(userId, 10); // 最近10条活动
    
    return {
        ...userData,
        preferences,
        recentActivity: activity
    };
}

// 2. 使用描述性的函数名
async function validateUserCredentials(email, password) {
    // 验证逻辑...
}

// 3. 使用 async/await 替代 Promise 链，提高可读性
async function processOrder(orderId) {
    try {
        const order = await fetchOrder(orderId);
        const inventoryStatus = await checkInventory(order.items);
        
        if (!inventoryStatus.inStock) {
            await notifyCustomerOutOfStock(order.customerId, inventoryStatus.outOfStockItems);
            return { success: false, reason: 'out_of_stock' };
        }
        
        await reserveInventory(order.items);
        const paymentResult = await processPayment(order.paymentDetails);
        
        if (!paymentResult.success) {
            await releaseInventory(order.items);
            return { success: false, reason: 'payment_failed' };
        }
        
        await shipOrder(order);
        await sendConfirmationEmail(order.customerId, orderId);
        
        return { success: true, orderId };
    } catch (error) {
        console.error('处理订单失败:', error);
        return { success: false, error: error.message };
    }
}

// 4. 使用工具函数处理重复模式
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function retry(fn, retries = 3, delayMs = 1000) {
    return fn().catch(error => {
        if (retries > 0) {
            console.log(`操作失败，${retries}次重试机会剩余，${delayMs}ms后重试`);
            return delay(delayMs).then(() => retry(fn, retries - 1, delayMs * 2));
        }
        throw error;
    });
}
        \u003c/div\u003e

        \u003cdiv class="note"\u003e
            \u003cp\u003e关键要点：\u003c/p\u003e
            \u003cul\u003e
                \u003cli\u003e始终处理Promise rejection，避免未处理的Promise错误
                \u003c/li\u003e
                \u003cli\u003e优先使用 async/await 语法，提高代码可读性
                \u003c/li\u003e
                \u003cli\u003e合理使用 Promise.all 进行并行操作，提高性能
                \u003c/li\u003e
                \u003cli\u003e设置适当的超时和中止机制
                \u003c/li\u003e
                \u003cli\u003e考虑使用并发控制处理大量异步操作
                \u003c/li\u003e
                \u003cli\u003e拆分复杂的异步逻辑为小型、专注的函数
                \u003c/li\u003e
            \u003c/ul\u003e
        \u003c/div\u003e
    \u003c/section\u003e

    \u003cscript\u003e
        // Promise 演示函数
        async function runPromiseDemo() {
            const resultElement = document.getElementById('promiseResult');
            resultElement.textContent = '开始运行 Promise 演示...\n';
            
            const log = (message) => {
                resultElement.textContent += message + '\n';
                console.log(message);
            };
            
            try {
                log('--- 运行 Promise.all 演示 ---');
                const allResult = await demoPromiseAll();
                log(`Promise.all 结果: ${JSON.stringify(allResult)}`);
                
                log('\n--- 运行 Promise.race 演示 ---');
                const raceResult = await demoPromiseRace();
                log(`Promise.race 结果: ${raceResult}`);
                
                log('\n--- 运行 Promise.allSettled 演示 ---');
                const allSettledResult = await demoPromiseAllSettled();
                log(`Promise.allSettled 结果数量: ${allSettledResult.length}`);
                
                log('\n--- 运行 Promise.any 演示 ---');
                const anyResult = await demoPromiseAny();
                log(`Promise.any 结果: ${anyResult}`);
                
                log('\n--- 运行 Promise.resolve/reject 演示 ---');
                const staticResult = await demoPromiseStaticMethods();
                log(`Promise.reject 结果: ${staticResult.message}`);
                
                log('\nPromise 演示完成！');
            } catch (error) {
                log(`演示出错: ${error.message}`);
            }
        }
        
        // async/await 演示函数
        async function runAsyncAwaitDemo() {
            const resultElement = document.getElementById('asyncAwaitResult');
            resultElement.textContent = '开始运行 async/await 演示...\n';
            
            const log = (message) => {
                resultElement.textContent += message + '\n';
                console.log(message);
            };
            
            try {
                log('--- 运行 await 基本演示 ---');
                const result = await awaitExample();
                log(`awaitExample 结果: ${result}`);
                
                log('\n--- 运行错误处理演示 ---');
                const errorResult = await errorHandlingExample();
                log(`errorHandlingExample 结果: ${errorResult}`);
                
                log('\n--- 运行异步生成器演示 ---');
                await consumeAsyncGenerator();
                
                log('\n--- 运行异步迭代器演示 ---');
                await useAsyncIterator();
                
                log('\nasync/await 演示完成！');
            } catch (error) {
                log(`演示出错: ${error.message}`);
            }
        }
        
        // 辅助函数定义
        function demoPromiseAll() {
            const promise1 = Promise.resolve(3);
            const promise2 = 42;
            const promise3 = new Promise(function(resolve, reject) {
                setTimeout(resolve, 100, 'foo');
            });
            
            return Promise.all([promise1, promise2, promise3]);
        }
        
        function demoPromiseRace() {
            const promise1 = new Promise(function(resolve, reject) {
                setTimeout(resolve, 500, '一个较慢的 Promise');
            });
            
            const promise2 = new Promise(function(resolve, reject) {
                setTimeout(resolve, 100, '一个较快的 Promise');
            });
            
            const promise3 = new Promise(function(resolve, reject) {
                setTimeout(reject, 200, '一个会失败的 Promise');
            });
            
            // 返回会失败的那个演示
            return Promise.race([promise1, promise3]).catch(error => error);
        }
        
        function demoPromiseAllSettled() {
            const promise1 = Promise.resolve(3);
            const promise2 = new Promise(function(resolve, reject) {
                setTimeout(reject, 100, '失败了');
            });
            
            return Promise.allSettled([promise1, promise2]);
        }
        
        function demoPromiseAny() {
            const promise1 = new Promise(function(resolve, reject) {
                setTimeout(reject, 100, '首先失败');
            });
            
            const promise2 = new Promise(function(resolve, reject) {
                setTimeout(resolve, 200, '成功了');
            });
            
            const promise3 = new Promise(function(resolve, reject) {
                setTimeout(resolve, 300, '也成功了');
            });
            
            return Promise.any([promise1, promise2, promise3]);
        }
        
        function demoPromiseStaticMethods() {
            const rejectedPromise = Promise.reject(new Error('直接失败'));
            return rejectedPromise.catch(error => error);
        }
        
        async function awaitExample() {
            const log = (msg) => {
                console.log(msg);
                const resultElement = document.getElementById('asyncAwaitResult');
                resultElement.textContent += msg + '\n';
            };
            
            log('开始执行 awaitExample');
            
            const value1 = await new Promise(resolve => {
                setTimeout(() => resolve('值 1'), 500);
            });
            log(`获得值 1: ${value1}`);
            
            const value2 = await new Promise(resolve => {
                setTimeout(() => resolve('值 2'), 300);
            });
            log(`获得值 2: ${value2}`);
            
            return `最终结果: ${value1} 和 ${value2}`;
        }
        
        async function errorHandlingExample() {
            const log = (msg) => {
                console.log(msg);
                const resultElement = document.getElementById('asyncAwaitResult');
                resultElement.textContent += msg + '\n';
            };
            
            try {
                log('尝试异步操作');
                await new Promise((resolve, reject) => {
                    setTimeout(() => reject(new Error('异步操作失败')), 300);
                });
                return '不会执行到这里';
            } catch (error) {
                log(`捕获到错误: ${error.message}`);
                return '恢复执行';
            } finally {
                log('无论成功失败都会执行');
            }
        }
        
        async function* asyncGenerator(items) {
            for (const item of items) {
                // 模拟异步操作
                const result = await new Promise(resolve => {
                    setTimeout(() => resolve(`处理: ${item}`), 100);
                });
                
                yield result;
            }
        }
        
        async function consumeAsyncGenerator() {
            const log = (msg) => {
                console.log(msg);
                const resultElement = document.getElementById('asyncAwaitResult');
                resultElement.textContent += msg + '\n';
            };
            
            log('开始消费异步生成器');
            
            const items = [1, 2, 3, 4, 5];
            for await (const result of asyncGenerator(items)) {
                log(result);
            }
            
            log('异步生成器消费完毕');
        }
        
        class AsyncCollection {
            constructor(data) {
                this.data = data;
                this.index = 0;
            }
            
            [Symbol.asyncIterator]() {
                return this;
            }
            
            async next() {
                if (this.index < this.data.length) {
                    // 模拟异步获取数据
                    await new Promise(resolve => setTimeout(resolve, 100));
                    return {
                        value: this.data[this.index++],
                        done: false
                    };
                } else {
                    return {
                        done: true
                    };
                }
            }
        }
        
        async function useAsyncIterator() {
            const log = (msg) => {
                console.log(msg);
                const resultElement = document.getElementById('asyncAwaitResult');
                resultElement.textContent += msg + '\n';
            };
            
            const collection = new AsyncCollection([10, 20, 30, 40, 50]);
            
            log('开始异步迭代');
            for await (const item of collection) {
                log(`获取到: ${item}`);
            }
            
            log('异步迭代结束');
        }
        
        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', function() {
            console.log('异步编程进阶教程页面已加载');
        });
    \u003c/script\u003e
\u003c/body\u003e
\u003c/html\u003e

    \u003c!-- 2. async/await 深度解析 --\u003e
    \u003csection class="demo-section"\u003e
        \u003ch2\u003e2. async/await 深度解析\u003c/h2\u003e
        \u003cdiv class="explanation"\u003e
            \u003cp\u003easync/await 是 ES2017 引入的异步编程语法糖，它基于 Promise，使异步代码更接近同步代码的写法，提高了代码的可读性和可维护性。\u003c/p\u003e
        \u003c/div\u003e

        \u003ch3\u003e2.1 async/await 的工作原理\u003c/h3\u003e
        \u003cdiv class="code-block"\u003e
\u003cspan class="comment"\u003e// async 函数返回的是一个 Promise\u003c/span\u003e
\u003cspan class="keyword"\u003easync\u003c/span\u003e \u003cspan class="keyword"\u003efunction\u003c/span\u003e \u003cspan class="function"\u003easyncFunctionExample\u003c/span\u003e() {
    \u003cspan class="keyword"\u003ereturn\u003c/span\u003e 'Hello Async';
}

\u003cspan class="keyword"\u003econst\u003c/span\u003e result = asyncFunctionExample();
console.log(result instanceof Promise); // 输出: true
result.then(value =\u003e console.log(value)); // 输出: Hello Async

\u003cspan class="comment"\u003e// await 表达式暂停 async 函数的执行，等待 Promise 解决\u003c/span\u003e
\u003cspan class="keyword"\u003easync\u003c/span\u003e \u003cspan class="keyword"\u003efunction\u003c/span\u003e \u003cspan class="function"\u003eawaitExample\u003c/span\u003e() {
    console.log('开始执行');
    
    \u003cspan class="keyword"\u003econst\u003c/span\u003e value1 = await new Promise(resolve =\u003e {
        setTimeout(() =\u003e resolve('值 1'), 1000);
    });
    console.log('获得值 1:', value1);
    
    \u003cspan class="keyword"\u003econst\u003c/span\u003e value2 = await new Promise(resolve =\u003e {
        setTimeout(() =\u003e resolve('值 2'), 500);
    });
    console.log('获得值 2:', value2);
    
    \u003cspan class="keyword"\u003ereturn\u003c/span\u003e `最终结果: ${value1} 和 ${value2}`;
}

awaitExample().then(finalResult =\u003e {
    console.log(finalResult); // 输出: 最终结果: 值 1 和 值 2
});

\u003cspan class="comment"\u003e// async/await 错误处理 - 使用 try/catch 捕获错误\u003c/span\u003e
\u003cspan class="keyword"\u003easync\u003c/span\u003e \u003cspan class="keyword"\u003efunction\u003c/span\u003e \u003cspan class="function"\u003eerrorHandlingExample\u003c/span\u003e() {
    \u003cspan class="keyword"\u003etry\u003c/span\u003e {
        console.log('尝试异步操作');
        \u003cspan class="keyword"\u003econst\u003c/span\u003e result = await new Promise((resolve, reject) =\u003e {
            setTimeout(() =\u003e reject(new Error('异步操作失败')), 500);
        });
        return result; // 不会执行到这里
    } \u003cspan class="keyword"\u003ecatch\u003e/span\u003e (error) {
        console.error('捕获到错误:', error.message);
        \u003cspan class="keyword"\u003ereturn\u003c/span\u003e '恢复执行';
    } \u003cspan class="keyword"\u003efinally\u003e/span\u003e {
        console.log('无论成功失败都会执行');
    }
}

errorHandlingExample().then(result =\u003e {
    console.log('最终结果:', result); // 输出: 最终结果: 恢复执行
});
        \u003c/div\u003e

        \u003cdiv class="comparison"\u003e
            \u003cdiv class="comparison-item before"\u003e
                \u003ch4\u003e使用 Promise 链\u003c/h4\u003e
                \u003cdiv class="code-block"\u003e
function fetchData() {
    return fetch('https://api.example.com/data')
        .then(response =\u003e {
            if (!response.ok) {
                throw new Error('HTTP 错误 ' + response.status);
            }
            return response.json();
        })
        .then(data =\u003e {
            return fetch('https://api.example.com/details/' + data.id)
                .then(response =\u003e {
                    if (!response.ok) {
                        throw new Error('HTTP 错误 ' + response.status);
                    }
                    return response.json();
                })
                .then(details =\u003e {
                    return { data: data, details: details };
                });
        })
        .catch(error =\u003e {
            console.error('获取数据失败:', error);
            throw error;
        });
}
                \u003c/div\u003e
            \u003c/div\u003e
            \u003cdiv class="comparison-item after"\u003e
                \u003ch4\u003e使用 async/await\u003c/h4\u003e
                \u003cdiv class="code-block"\u003e
async function fetchData() {
    try {
        const response = await fetch('https://api.example.com/data');
        if (!response.ok) {
            throw new Error('HTTP 错误 ' + response.status);
        }
        const data = await response.json();
        
        const detailsResponse = await fetch('https://api.example.com/details/' + data.id);
        if (!detailsResponse.ok) {
            throw new Error('HTTP 错误 ' + detailsResponse.status);
        }
        const details = await detailsResponse.json();
        
        return { data: data, details: details };
    } catch (error) {
        console.error('获取数据失败:', error);
        throw error;
    }
}
                \u003c/div\u003e
            \u003c/div\u003e
        \u003c/div\u003e

        \u003ch3\u003e2.2 async/await 与 Promise 链的性能对比\u003c/h3\u003e
        \u003cdiv class="explanation"\u003e
            \u003cp\u003e从性能角度来看，async/await 和 Promise 链本质上是相同的，因为 async/await 最终会被编译成 Promise 链。但在使用方式上有一些注意事项：\u003c/p\u003e
            \u003cul\u003e
                \u003cli\u003e使用 await 顺序执行会导致不必要的等待时间，特别是当异步操作之间没有依赖关系时\u003c/li\u003e
                \u003cli\u003e对于相互独立的异步操作，应该使用 Promise.all 来并行执行，提高效率\u003c/li\u003e
            \u003c/ul\u003e
        \u003c/div\u003e

        \u003cdiv class="code-block"\u003e
\u003cspan class="comment"\u003e// 示例：顺序执行 vs 并行执行\u003c/span\u003e
\u003cspan class="keyword"\u003easync\u003c/span\u003e \u003cspan class="keyword"\u003efunction\u003c/span\u003e \u003cspan class="function"\u003esequentialExecution\u003c/span\u003e() {
    console.time('顺序执行');
    
    \u003cspan class="keyword"\u003econst\u003c/span\u003e result1 = await new Promise(resolve =\u003e setTimeout(() =\u003e resolve('结果1'), 1000));
    \u003cspan class="keyword"\u003econst\u003c/span\u003e result2 = await new Promise(resolve =\u003e setTimeout(() =\u003e resolve('结果2'), 1000));
    \u003cspan class="keyword"\u003econst\u003c/span\u003e result3 = await new Promise(resolve =\u003e setTimeout(() =\u003e resolve('结果3'), 1000));
    
    console.timeEnd('顺序执行'); // 大约 3000ms
    \u003cspan class="keyword"\u003ereturn\u003c/span\u003e [result1, result2, result3];
}

\u003cspan class="keyword"\u003easync\u003c/span\u003e \u003cspan class="keyword"\u003efunction\u003c/span\u003e \u003cspan class="function"\u003eparallelExecution\u003c/span\u003e() {
    console.time('并行执行');
    
    \u003cspan class="keyword"\u003econst\u003c/span\u003e promise1 = new Promise(resolve =\u003e setTimeout(() =\u003e resolve('结果1'), 1000));
    \u003cspan class="keyword"\u003econst\u003c/span\u003e promise2 = new Promise(resolve =\u003e setTimeout(() =\u003e resolve('结果2'), 1000));
    \u003cspan class="keyword"\u003econst\u003c/span\u003e promise3 = new Promise(resolve =\u003e setTimeout(() =\u003e resolve('结果3'), 1000));
    
    \u003cspan class="keyword"\u003econst\u003c/span\u003e [result1, result2, result3] = await Promise.all([promise1, promise2, promise3]);
    
    console.timeEnd('并行执行'); // 大约 1000ms
    \u003cspan class="keyword"\u003ereturn\u003c/span\u003e [result1, result2, result3];
}

\u003cspan class="keyword"\u003easync\u003c/span\u003e \u003cspan class="keyword"\u003efunction\u003c/span\u003e \u003cspan class="function"\u003erunPerformanceTest\u003c/span\u003e() {
    \u003cspan class="keyword"\u003econst\u003c/span\u003e seqResult = await sequentialExecution();
    \u003cspan class="keyword"\u003econst\u003c/span\u003e parResult = await parallelExecution();
    
    console.log('顺序执行结果:', seqResult);
    console.log('并行执行结果:', parResult);
}

// runPerformanceTest(); // 取消注释运行性能测试
        \u003c/div\u003e

        \u003ch3\u003e2.3 async/await 高级模式\u003c/h3\u003e
        \u003cdiv class="code-block"\u003e
\u003cspan class="comment"\u003e// 1. 异步生成器 (Async Generators)\u003c/span\u003e
\u003cspan class="keyword"\u003easync\u003c/span\u003e \u003cspan class="keyword"\u003egenerator\u003c/span\u003e \u003cspan class="keyword"\u003efunction\u003c/span\u003e*\u003cspan class="function"\u003easyncGenerator\u003c/span\u003e(items) {
    for (const item of items) {
        \u003cspan class="comment"\u003e// 模拟异步操作
        const result = await new Promise(resolve =\u003e {
            setTimeout(() =\u003e resolve(`处理: ${item}`), 100);
        });
        
        yield result;
    }
}

\u003cspan class="keyword"\u003easync\u003c/span\u003e \u003cspan class="keyword"\u003efunction\u003c/span\u003e \u003cspan class="function"\u003econsumeAsyncGenerator\u003c/span\u003e() {
    console.log('开始消费异步生成器');
    
    \u003cspan class="keyword"\u003econst\u003c/span\u003e items = [1, 2, 3, 4, 5];
    \u003cspan class="keyword"\u003efor\u003c/span\u003e await (const result of asyncGenerator(items)) {
        console.log(result);
        // 输出:
        // 处理: 1
        // 处理: 2
        // 处理: 3
        // 处理: 4
        // 处理: 5
    }
    
    console.log('异步生成器消费完毕');
}

\u003cspan class="comment"\u003e// 2. 异步迭代器 (Async Iterators)\u003c/span\u003e
\u003cspan class="keyword"\u003eclass\u003e/span\u003e \u003cspan class="function"\u003eAsyncCollection\u003c/span\u003e {
    constructor(data) {
        this.data = data;
        this.index = 0;
    }
    
    [Symbol.asyncIterator]() {
        return this;
    }
    
    \u003cspan class="keyword"\u003easync\u003c/span\u003e next() {
        \u003cspan class="keyword"\u003eif\u003c/span\u003e (this.index \u003c this.data.length) {
            \u003cspan class="comment"\u003e// 模拟异步获取数据
            await new Promise(resolve =\u003e setTimeout(resolve, 100));
            \u003cspan class="keyword"\u003ereturn\u003c/span\u003e {
                value: this.data[this.index++],
                done: false
            };
        } \u003cspan class="keyword"\u003eelse\u003c/span\u003e {
            \u003cspan class="keyword"\u003ereturn\u003c/span\u003e {
                done: true
            };
        }
    }
}

\u003cspan class="keyword"\u003easync\u003c/span\u003e \u003cspan class="keyword"\u003efunction\u003c/span\u003e \u003cspan class="function"\u003euseAsyncIterator\u003c/span\u003e() {
    \u003cspan class="keyword"\u003econst\u003c/span\u003e collection = new AsyncCollection([10, 20, 30, 40, 50]);
    
    console.log('开始异步迭代');
    \u003cspan class="keyword"\u003efor\u003c/span\u003e await (const item of collection) {
        console.log('获取到:', item);
        // 输出:
        // 获取到: 10
        // 获取到: 20
        // 获取到: 30
        // 获取到: 40
        // 获取到: 50
    }
    
    console.log('异步迭代结束');
}

\u003cspan class="comment"\u003e// 3. 异步 IIFE (Async IIFE)\u003c/span\u003e
(\u003cspan class="keyword"\u003easync\u003c/span\u003e \u003cspan class="keyword"\u003efunction\u003c/span\u003e() {
    \u003cspan class="keyword"\u003etry\u003c/span\u003e {
        // 可以直接使用 await 而不需要额外的函数包装
        \u003cspan class="keyword"\u003econst\u003c/span\u003e data = await fetch('https://api.example.com/data').then(r =\u003e r.json());
        console.log('使用异步 IIFE 获取数据:', data);
    } \u003cspan class="keyword"\u003ecatch\u003e/span\u003e (error) {
        console.error('错误:', error);
    }
})();

\u003cspan class="comment"\u003e// 4. 使用 Promise.allSettled 处理多个异步操作，无论成功失败都继续\u003c/span\u003e
\u003cspan class="keyword"\u003easync\u003c/span\u003e \u003cspan class="keyword"\u003efunction\u003c/span\u003e \u003cspan class="function"\u003eprocessAllRequests\u003c/span\u003e(urls) {
    \u003cspan class="keyword"\u003econst\u003c/span\u003e promises = urls.map(url =\u003e 
        fetch(url)
            .then(response =\u003e {
                if (!response.ok) {
                    throw new Error(`HTTP 错误 ${response.status}`);
                }
                return response.json();
            })
            .catch(error =\u003e {
                console.error(`处理 ${url} 失败:`, error);
                return { error: error.message, url: url };
            })
    );
    
    \u003cspan class="keyword"\u003ereturn\u003c/span\u003e await Promise.all(promises);
}
        \u003c/div\u003e
        
        \u003cbutton onclick="runAsyncAwaitDemo()"\u003e运行 async/await 演示\u003c/button\u003e
        \u003cdiv id="asyncAwaitResult" class="result"\u003e点击按钮查看运行结果...\u003c/div\u003e
    \u003c/section\u003e

    \u003c!-- 3. 事件循环机制 --\u003e
    \u003csection class="demo-section"\u003e
        \u003ch2\u003e3. 事件循环机制 (Event Loop)\u003c/h2\u003e
        \u003cdiv class="explanation"\u003e
            \u003cp\u003e事件循环是 JavaScript 异步编程的核心机制，它决定了代码的执行顺序。理解事件循环对于掌握异步编程至关重要。\u003c/p\u003e
        \u003c/div\u003e

        \u003ch3\u003e3.1 事件循环的基本概念\u003c/h3\u003e
        \u003cdiv class="diagram"\u003e
事件循环 (Event Loop) 架构：

┌───────────────────────────────────────┐
│           调用栈 (Call Stack)          │
└───────────────────────────┬───────────┘
                            │
┌───────────────────────────▼───────────┐
│            Web API 环境                │
│  (setTimeout, fetch, DOM 事件等)      │
└───────────────────────────┬───────────┘
                            │
┌───────────────────────────▼───────────┐
│           任务队列 (Task Queue)        │
└───────────────────────────┬───────────┘
                            │
┌───────────────────────────▼───────────┐
│         微任务队列 (Microtask Queue)   │
└───────────────────────────┬───────────┘
                            │
┌───────────────────────────▼───────────┐
│           渲染阶段 (Render Phase)      │
└───────────────────────────────────────┘
        \u003c/div\u003e

        \u003cdiv class="explanation"\u003e
            \u003cp\u003e事件循环的执行过程：\u003c/p\u003e
            \u003col\u003e
                \u003cli\u003e执行调用栈中的同步代码，直到栈为空\u003c/li\u003e
                \u003cli\u003e处理所有微任务队列中的任务，按照先进先出的顺序执行，直到队列为空\u003c/li\u003e
                \u003cli\u003e必要时渲染 UI\u003c/li\u003e
                \u003cli\u003e从任务队列中取出一个任务执行\u003c/li\u003e
                \u003cli\u003e重复步骤 1-4
                \u003c/li\u003e
            \u003c/ol\u003e
        \u003c/div\u003e

        \u003ch3\u003e3.2 宏任务与微任务\u003c/h3\u003e
        \u003cdiv class="code-block"\u003e
\u003cspan class="comment"\u003e// 宏任务 (MacroTask) 和微任务 (MicroTask) 示例\u003c/span\u003e
console.log('1. 开始同步代码');

\u003cspan class="comment"\u003e// 宏任务 - setTimeout\u003c/span\u003e
setTimeout(() =\u003e {
    console.log('4. 这是一个宏任务 (setTimeout)');
    
    \u003cspan class="comment"\u003e// 在宏任务中创建微任务\u003e
    Promise.resolve().then(() =\u003e {
        console.log('5. 宏任务中的微任务');
    });
}, 0);

\u003cspan class="comment"\u003e// 微任务 - Promise.then\u003c/span\u003e
Promise.resolve().then(() =\u003e {
    console.log('3. 这是一个微任务 (Promise.then)');
    
    \u003cspan class="comment"\u003e// 在微任务中创建新的微任务\u003c/span\u003e
    Promise.resolve().then(() =\u003e {
        console.log('3.1 微任务中的微任务');
    });
});

console.log('2. 结束同步代码');

\u003cspan class="comment"\u003e// 输出顺序：
// 1. 开始同步代码
// 2. 结束同步代码
// 3. 这是一个微任务 (Promise.then)
// 3.1 微任务中的微任务
// 4. 这是一个宏任务 (setTimeout)
// 5. 宏任务中的微任务
        \u003c/div\u003e

        \u003cdiv class="comparison"\u003e
            \u003cdiv class="comparison-item before"\u003e
                \u003ch4\u003e宏任务 (MacroTask)\u003c/h4\u003e
                \u003cul\u003e
                    \u003cli\u003esetTimeout/setInterval
                    \u003c/li\u003e
                    \u003cli\u003esetImmediate (Node.js)
                    \u003c/li\u003e
                    \u003cli\u003erequestAnimationFrame
                    \u003c/li\u003e
                    \u003cli\u003eI/O 操作
                    \u003c/li\u003e
                    \u003cli\u003eUI 渲染事件
                    \u003c/li\u003e
                    \u003cli\u003escript 标签的执行
                    \u003c/li\u003e
                \u003c/ul\u003e
            \u003c/div\u003e
            \u003cdiv class="comparison-item after"\u003e
                \u003ch4\u003e微任务 (MicroTask)\u003c/h4\u003e
                \u003cul\u003e
                    \u003cli\u003ePromise 的 then/catch/finally 回调
                    \u003c/li\u003e
                    \u003cli\u003equeueMicrotask
                    \u003c/li\u003e
                    \u003cli\u003eMutationObserver
                    \u003c/li\u003e
                    \u003cli\u003eprocess.nextTick (Node.js)
                    \u003c/li\u003e
                \u003c/ul\u003e
            \u003c/div\u003e
        \u003c/div\u003e

        \u003ch3\u003e3.3 事件循环高级示例\u003c/h3\u003e
        \u003cdiv class="code-block"\u003e
\u003cspan class="comment"\u003e// 复杂的事件循环示例 - 展示执行顺序\u003c/span\u003e
console.log('1. 同步代码开始');

setTimeout(() =\u003e {
    console.log('10. 宏任务 1');
    Promise.resolve().then(() =\u003e {
        console.log('11. 宏任务 1 中的微任务');
    });
}, 0);

Promise.resolve().then(() =\u003e {
    console.log('3. 微任务 1');
    
    setTimeout(() =\u003e {
        console.log('12. 微任务 1 中创建的宏任务');
    }, 0);
    
    Promise.resolve().then(() =\u003e {
        console.log('4. 微任务 1 中的微任务');
    });
});

console.log('2. 同步代码结束');

setTimeout(() =\u003e {
    console.log('8. 宏任务 2');
    
    Promise.resolve().then(() =\u003e {
        console.log('9. 宏任务 2 中的微任务');
    });
}, 0);

Promise.resolve().then(() =\u003e {
    console.log('5. 微任务 2');
    
    Promise.resolve().then(() =\u003e {
        console.log('6. 微任务 2 中的微任务');
    });
});

Promise.resolve().then(() =\u003e {
    console.log('7. 微任务 3');
});

\u003cspan class="comment"\u003e// 输出顺序：
// 1. 同步代码开始
// 2. 同步代码结束
// 3. 微任务 1
// 4. 微任务 1 中的微任务
// 5. 微任务 2
//
    </section>
    
    <!-- 事件循环演示按钮 -->
    <section class="demo-section">
        <h3>事件循环演示</h3>
        <button onclick="runEventLoopDemo()">运行事件循环演示</button>
        <div id="eventLoopResult" class="result">点击按钮查看运行结果...</div>
    </section>
    
    <script>
        // 事件循环演示函数
        async function runEventLoopDemo() {
            const resultElement = document.getElementById('eventLoopResult');
            resultElement.textContent = '开始运行事件循环演示...\n';
            
            const log = (message) => {
                resultElement.textContent += message + '\n';
                console.log(message);
            };
            
            log('演示事件循环的执行顺序:');
            log('-------------------------');
            log('1. 执行同步代码');
            
            // 同步代码
            console.log('1. 这是同步代码');
            
            // 微任务 - Promise.then
            Promise.resolve().then(() => {
                log('3. 这是一个微任务 (Promise.then)');
                
                // 在微任务中创建新的微任务
                Promise.resolve().then(() => {
                    log('3.1 微任务中的微任务');
                });
            });
            
            // 微任务 - queueMicrotask
            queueMicrotask(() => {
                log('3.2 这是另一个微任务 (queueMicrotask)');
            });
            
            // 宏任务 - setTimeout (0ms)
            setTimeout(() => {
                log('4. 这是一个宏任务 (setTimeout)');
                
                // 在宏任务中创建微任务
                Promise.resolve().then(() => {
                    log('5. 宏任务中的微任务');
                });
            }, 0);
            
            // 另一个宏任务 - setTimeout (10ms)
            setTimeout(() => {
                log('6. 这是第二个宏任务 (setTimeout with 10ms)');
            }, 10);
            
            log('2. 结束同步代码');
            
            // 等待所有微任务和宏任务执行完成
            await new Promise(resolve => setTimeout(resolve, 50));
            
            log('\n-------------------------');
            log('事件循环演示完成！');
            log('\n事件循环执行顺序总结:');
            log('1. 先执行所有同步代码');
            log('2. 然后执行所有微任务队列中的任务');
            log('3. 接着执行一个宏任务队列中的任务');
            log('4. 执行该宏任务产生的所有微任务');
            log('5. 重复步骤 3-4');
        }
        
        // 其他演示函数实现
        function runPromiseDemo() {
            // 基本实现，避免与现有代码冲突
            console.log('Promise 演示');
        }
        
        function runAsyncAwaitDemo() {
            // 基本实现，避免与现有代码冲突
            console.log('async/await 演示');
        }
        
        function demoConcurrencyControl() {
            // 基本实现，避免与现有代码冲突
            console.log('并发控制演示');
        }
        
        function demoBatchAndRetry() {
            // 基本实现，避免与现有代码冲突
            console.log('批量处理和重试演示');
        }
        
        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', function() {
            console.log('异步编程进阶教程页面已加载');
        });
    </script>
\u003c/body\u003e
\u003c/html>