\u003c!DOCTYPE html\u003e
\u003chtml lang="zh-CN"\u003e
\u003chead\u003e
    \u003cmeta charset="UTF-8"\u003e
    \u003cmeta name="viewport" content="width=device-width, initial-scale=1.0"\u003e
    \u003ctitle\u003eWebAssembly 技术详解\u003c/title\u003e
    \u003cstyle\u003e
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        
        h1, h2, h3, h4 {
            color: #2c3e50;
        }
        
        h1 {
            text-align: center;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 40px;
        }
        
        h2 {
            border-left: 4px solid #3498db;
            padding-left: 15px;
            margin-top: 50px;
        }
        
        h3 {
            color: #3498db;
            margin-top: 30px;
        }
        
        .container {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .code-block {
            background-color: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 6px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        
        .demo-section {
            margin-bottom: 40px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 6px;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .result {
            background-color: #e8f4f8;
            border: 1px solid #b3e5fc;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        
        .concept-box {
            background-color: #f0f0f0;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 4px solid #3498db;
        }
        
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-item {
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #ddd;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background-color: #f2f2f2;
        }
        
        tr:hover {
            background-color: #f5f5f5;
        }
        
        .highlight {
            background-color: #ffeb3b;
            padding: 2px 5px;
            border-radius: 3px;
        }
    \u003c/style\u003e
\u003c/head\u003e
\u003cbody\u003e
    \u003cdiv class="container"\u003e
        \u003ch1\u003eWebAssembly 技术详解\u003c/h1\u003e
        \u003c
        \u003cdiv class="demo-section"\u003e
            \u003ch2\u003e1. WebAssembly 基础概念\u003c/h2\u003e
            \u003c
            \u003cdiv class="concept-box"\u003e
                \u003cp\u003eWebAssembly（简称 WASM）是一种低级的类汇编语言，它是一种二进制格式，可以在现代浏览器中运行。WebAssembly 设计为一种可移植、高效的字节码格式，使客户端应用能够以接近原生的速度运行。\u003c/p\u003e
                \u003cp\u003eWebAssembly 的核心目标是：\u003c/span class="highlight"\u003e提供一种可以在 Web 平台上以接近原生性能运行代码的方式，同时保持与 JavaScript 的互操作性\u003c/span\u003e。\u003c/p\u003e
            \u003c/div\u003e
            \u003c
            \u003ch3\u003e1.1 WebAssembly 的特点\u003c/h3\u003e
            \u003cul\u003e
                \u003cli\u003e\u003cstrong\u003e高性能：\u003c/strong\u003e接近原生的执行速度，比 JavaScript 快数倍甚至数十倍\u003c/li\u003e
                \u003cli\u003e\u003cstrong\u003e内存安全：\u003c/strong\u003e使用线性内存模型，提供内存隔离和安全边界\u003c/li\u003e
                \u003cli\u003e\u003cstrong\u003e跨平台：\u003c/strong\u003e在所有现代浏览器中都能运行，不依赖特定硬件平台\u003c/li\u003e
                \u003cli\u003e\u003cstrong\u003e紧凑体积：\u003c/strong\u003e二进制格式体积小，加载速度快\u003c/li\u003e
                \u003cli\u003e\u003cstrong\u003e多语言支持：\u003c/strong\u003e可由 C/C++、Rust、AssemblyScript 等多种语言编译而成\u003c/li\u003e
                \u003cli\u003e\u003cstrong\u003e与 JavaScript 互操作：\u003c/strong\u003e可以与 JavaScript 无缝集成，共享功能和数据\u003c/li\u003e
            \u003c/ul\u003e
            \u003c
            \u003ch3\u003e1.2 WebAssembly 应用场景\u003c/h3\u003e
            \u003cul\u003e
                \u003cli\u003e\u003cstrong\u003e计算密集型应用：\u003c/strong\u003e图像处理、视频编码解码、音频处理\u003c/li\u003e
                \u003cli\u003e\u003cstrong\u003e游戏和 3D 应用：\u003c/strong\u003eWebGL 游戏、3D 渲染引擎\u003c/li\u003e
                \u003cli\u003e\u003cstrong\u003e科学计算：\u003c/strong\u003e数据分析、数值模拟、物理引擎\u003c/li\u003e
                \u003cli\u003e\u003cstrong\u003e密码学和安全应用：\u003c/strong\u003e加密算法、数字签名、安全通信\u003c/li\u003e
                \u003cli\u003e\u003cstrong\u003e工具链移植：\u003c/strong\u003e将桌面应用或库移植到 Web 平台\u003c/li\u003e
                \u003cli\u003e\u003cstrong\u003e实时协作应用：\u003c/strong\u003e实时编辑、多人协作工具\u003c/li\u003e
            \u003c/ul\u003e
            \u003c
            \u003cbutton onclick="runBasicConceptDemo()"\u003e运行基础概念演示\u003c/button\u003e
            \u003cdiv id="basicConceptResult" class="result"\u003e点击按钮查看 WebAssembly 基础概念演示结果...\u003c/div\u003e
        \u003c/div\u003e
        \u003c
        \u003cdiv class="demo-section"\u003e
            \u003ch2\u003e2. WebAssembly 工作原理\u003c/h2\u003e
            \u003c
            \u003ch3\u003e2.1 WebAssembly 执行模型\u003c/h3\u003e
            \u003cdiv class="code-block"\u003e
// WebAssembly 执行流程示意图
/*
高级语言代码 → 编译器 → WebAssembly 二进制格式 (.wasm) → 浏览器加载 → 编译为机器码 → 执行
*/

// JavaScript 中加载和使用 WebAssembly 的基本流程
async function loadAndUseWasm() {
  try {
    // 1. 加载 WebAssembly 模块
    const response = await fetch('module.wasm');
    const buffer = await response.arrayBuffer();
    
    // 2. 编译 WebAssembly 模块
    const module = await WebAssembly.compile(buffer);
    
    // 3. 创建 WebAssembly 实例
    // 需要提供 JavaScript 环境函数作为导入
    const imports = {
      env: {
        // WebAssembly 模块可能需要的函数和变量
        memoryBase: 0,
        tableBase: 0,
        memory: new WebAssembly.Memory({ initial: 256, maximum: 256 }),
        table: new WebAssembly.Table({
          initial: 0,
          maximum: 0,
          element: 'anyfunc'
        }),
        // 自定义函数，供 WebAssembly 调用
        consoleLog: (offset) =\u003e {
          // 从内存读取字符串并打印
          const bytes = new Uint8Array(imports.env.memory.buffer, offset);
          let i = 0;
          while (bytes[i] !== 0) i++;
          const str = new TextDecoder('utf8').decode(bytes.subarray(0, i));
          console.log(str);
        }
      }
    };
    
    // 实例化模块
    const instance = await WebAssembly.instantiate(module, imports);
    
    // 4. 使用 WebAssembly 导出的函数
    const { add, multiply, factorial } = instance.exports;
    
    // 调用 WebAssembly 函数
    console.log('2 + 3 =', add(2, 3));
    console.log('4 * 5 =', multiply(4, 5));
    console.log('5! =', factorial(5));
    
    return instance;
  } catch (error) {
    console.error('加载 WebAssembly 失败:', error);
  }
}

// 简化的加载方式
async function loadWasmSimplified() {
  try {
    // 一步完成获取、编译和实例化
    const { instance } = await WebAssembly.instantiateStreaming(
      fetch('module.wasm'),
      {
        env: {
          // 导入函数
          consoleLog: (value) =\u003e console.log(value)
        }
      }
    );
    
    // 使用实例的导出函数
    return instance.exports;
  } catch (error) {
    console.error('加载失败:', error);
  }
}
            \u003c/div\u003e
            \u003c
            \u003ch3\u003e2.2 WebAssembly 内存模型\u003c/h3\u003e
            \u003cdiv class="code-block"\u003e
// WebAssembly 内存操作示例
async function demonstrateMemoryOperations() {
  // 创建 WebAssembly 内存
  const memory = new WebAssembly.Memory({ 
    initial: 10,  // 初始页面数 (每页 64KB)
    maximum: 100, // 最大页面数
    shared: false // 非共享内存
  });
  
  // 获取内存的视图
  const buffer = memory.buffer;
  const int32Array = new Int32Array(buffer);
  const float64Array = new Float64Array(buffer);
  
  // 在内存中存储数据
  function storeData() {
    // 存储整数
    int32Array[0] = 42;
    int32Array[1] = 100;
    
    // 存储浮点数 (注意：64位浮点数占2个int32位置)
    float64Array[0] = 3.14159;
    float64Array[1] = 2.71828;
    
    // 存储字符串 (UTF-8 编码)
    const str = 'Hello WebAssembly!';
    const encoder = new TextEncoder();
    const bytes = encoder.encode(str);
    const uint8Array = new Uint8Array(buffer);
    
    // 从位置 100 开始存储字符串
    const startPos = 100;
    for (let i = 0; i \u003c bytes.length; i++) {
      uint8Array[startPos + i] = bytes[i];
    }
    uint8Array[startPos + bytes.length] = 0; // 字符串结束符
    
    return {
      integerStart: 0,
      floatStart: 0,
      stringStart: startPos,
      stringLength: bytes.length
    };
  }
  
  // 从内存中读取数据
  function loadData(positions) {
    // 读取整数
    const int1 = int32Array[positions.integerStart];
    const int2 = int32Array[positions.integerStart + 1];
    
    // 读取浮点数
    const float1 = float64Array[positions.floatStart];
    const float2 = float64Array[positions.floatStart + 1];
    
    // 读取字符串
    const uint8Array = new Uint8Array(buffer);
    const decoder = new TextDecoder();
    const str = decoder.decode(
      uint8Array.slice(positions.stringStart, positions.stringStart + positions.stringLength)
    );
    
    return {
      integers: [int1, int2],
      floats: [float1, float2],
      string: str
    };
  }
  
  // 增加内存大小
  function growMemory(pages) {
    try {
      const previousPages = memory.buffer.byteLength / (64 * 1024);
      const result = memory.grow(pages);
      
      if (result === -1) {
        console.log('内存增长失败');
        return -1;
      }
      
      console.log(`内存从 ${previousPages} 页增长到 ${previousPages + pages} 页`);
      return result;
    } catch (error) {
      console.error('内存增长出错:', error);
      return -1;
    }
  }
  
  // 执行演示
  const positions = storeData();
  const data = loadData(positions);
  
  return {
    memoryInfo: {
      currentSize: memory.buffer.byteLength / 1024 + ' KB',
      initialPages: 10,
      maximumPages: 100
    },
    storedData: data
  };
}
            \u003c/div\u003e
            \u003c
            \u003cbutton onclick="runExecutionModelDemo()"\u003e运行执行模型演示\u003c/button\u003e
            \u003cdiv id="executionModelResult" class="result"\u003e点击按钮查看 WebAssembly 执行模型演示结果...\u003c/div\u003e
        \u003c/div\u003e
        \u003c
        \u003cdiv class="demo-section"\u003e
            \u003ch2\u003e3. WebAssembly 开发工具链\u003c/h2\u003e
            \u003c
            \u003ch3\u003e3.1 编译工具介绍\u003c/h3\u003e
            \u003ctable\u003e
                \u003ctr\u003e
                    \u003cth\u003e工具名称\u003c/th\u003e
                    \u003cth\u003e用途\u003c/th\u003e
                    \u003cth\u003e支持语言\u003c/th\u003e
                    \u003cth\u003e主要特点\u003c/th\u003e
                \u003c/tr\u003e
                \u003ctr\u003e
                    \u003ctd\u003eEmscripten\u003c/td\u003e
                    \u003ctd\u003eC/C++ 编译到 WebAssembly\u003c/td\u003e
                    \u003ctd\u003eC, C++\u003c/td\u003e
                    \u003ctd\u003e完整的 libc 支持，成熟稳定\u003c/td\u003e
                \u003c/tr\u003e
                \u003ctr\u003e
                    \u003ctd\u003eRust + wasm-pack\u003c/td\u003e
                    \u003ctd\u003eRust 编译到 WebAssembly\u003c/td\u003e
                    \u003ctd\u003eRust\u003c/td\u003e
                    \u003ctd\u003e内存安全，良好的 JS 互操作性\u003c/td\u003e
                \u003c/tr\u003e
                \u003ctr\u003e
                    \u003ctd\u003eAssemblyScript\u003c/td\u003e
                    \u003ctd\u003eTypeScript 风格语言编译到 WebAssembly\u003c/td\u003e
                    \u003ctd\u003eAssemblyScript (TypeScript 子集)\u003ctd\u003eTypeScript 开发者友好，易于上手\u003c/td\u003e
                \u003c/tr\u003e
                \u003ctr\u003e
                    \u003ctd\u003eBinaryen\u003c/td\u003e
                    \u003ctd\u003eWebAssembly 优化工具\u003c/td\u003e
                    \u003ctd\u003eWebAssembly 二进制\u003c/td\u003e
                    \u003ctd\u003e优化大小和性能，支持降级到 asm.js\u003c/td\u003e
                \u003c/tr\u003e
                \u003ctr\u003e
                    \u003ctd\u003eWABT\u003c/td\u003e
                    \u003ctd\u003eWebAssembly 二进制工具包\u003c/td\u003e
                    \u003ctd\u003eWebAssembly 二进制/文本格式\u003c/td\u003e
                    \u003ctd\u003e格式转换，验证，反汇编等实用工具\u003c/td\u003e
                \u003c/tr\u003e
            \u003c/table\u003e
            \u003c
            \u003ch3\u003e3.2 使用 Emscripten 编译 C/C++\u003c/h3\u003e
            \u003cdiv class="code-block"\u003e
# Emscripten 安装与配置

# 1. 安装 Emscripten SDK
# 获取 Emscripten SDK
git clone https://github.com/emscripten-core/emsdk.git
cd emsdk

# 安装最新的 SDK
./emsdk install latest

# 激活最新的 SDK
./emsdk activate latest

# 配置环境变量 (Linux/macOS)
source ./emsdk_env.sh

# Windows 使用
emsdk_env.bat

# 验证安装
emcc --version

# 2. 编译简单的 C 代码到 WebAssembly
# 创建 C 代码文件 add.c
/*
#include \u003cstdio.h\u003e

int add(int a, int b) {
    return a + b;
}

// 导出函数供 JavaScript 调用
extern "C" {
    EMSCRIPTEN_KEEPALIVE
    int add(int a, int b) {
        return a + b;
    }

    EMSCRIPTEN_KEEPALIVE
    int fibonacci(int n) {
        if (n \u003c= 1) return n;
        return fibonacci(n-1) + fibonacci(n-2);
    }
}
*/

# 编译为 WebAssembly
emcc add.c -o add.js -s WASM=1 -s EXPORTED_FUNCTIONS="['_add', '_fibonacci']" -s EXTRA_EXPORTED_RUNTIME_METHODS="['ccall', 'cwrap']"

# 编译优化选项
emcc add.c -o add.js \
    -O3 \
    -s WASM=1 \
    -s EXPORTED_FUNCTIONS="['_add', '_fibonacci']" \
    -s EXTRA_EXPORTED_RUNTIME_METHODS="['ccall', 'cwrap']" \
    -s ALLOW_MEMORY_GROWTH=1 \
    -s MODULARIZE=1 \
    -s 'EXPORT_NAME="createAddModule"'

# 3. 在 HTML 中使用编译后的模块
/*
\u003c!DOCTYPE html\u003e
\u003chtml\u003e
\u003chead\u003e
    \u003ctitle\u003eWebAssembly 示例\u003c/title\u003e
\u003c/head\u003e
\u003cbody\u003e
    \u003ch1\u003eWebAssembly C/C++ 示例\u003c/h1\u003e
    \u003cscript src="add.js"\u003e\u003c/script\u003e
    \u003cscript\u003e
        // 加载模块
        createAddModule().then(function(module) {
            // 使用 cwrap 封装函数
            const add = module.cwrap('add', 'number', ['number', 'number']);
            const fibonacci = module.cwrap('fibonacci', 'number', ['number']);
            
            // 调用函数
            console.log('2 + 3 =', add(2, 3));
            console.log('fibonacci(10) =', fibonacci(10));
        });
    \u003c/script\u003e
\u003c/body\u003e
\u003c/html\u003e
*/
            \u003c/div\u003e
            \u003c
            \u003ch3\u003e3.3 使用 Rust + wasm-pack 开发\u003c/h3\u003e
            \u003cdiv class="code-block"\u003e
# Rust WebAssembly 开发环境配置

# 1. 安装 Rust 和 wasm-pack
# 安装 Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# 安装 wasm-pack
curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh

# 或使用 Cargo 安装
cargo install wasm-pack

# 2. 创建新的 Rust WebAssembly 项目
# 创建项目目录
mkdir wasm-rust-demo
cd wasm-rust-demo

# 初始化项目
wasm-pack new wasm-utils
cd wasm-utils

# 3. 编写 Rust 代码 - src/lib.rs
/*
use wasm_bindgen::prelude::*;

// 导出函数供 JavaScript 调用
#[wasm_bindgen]
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[wasm_bindgen]
pub fn fibonacci(n: u32) -> u32 {
    match n {
        0 => 0,
        1 => 1,
        _ => fibonacci(n - 1) + fibonacci(n - 2)
    }
}

#[wasm_bindgen]
pub fn calculate_pi(iterations: u32) -> f64 {
    let mut pi: f64 = 0.0;
    let mut sign: f64 = 1.0;
    
    for i in 0..iterations {
        let term: f64 = 1.0 / (2.0 * i as f64 + 1.0);
        pi += sign * term;
        sign *= -1.0;
    }
    
    pi * 4.0
}
*/

# 4. 配置 Cargo.toml
/*
[package]
name = "wasm-utils"
version = "0.1.0"
description = "WebAssembly utilities in Rust"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
wasm-bindgen = "0.2.83"

# 可选：添加 js-sys 和 web-sys 以访问 JavaScript 和 Web API
js-sys = "0.3.60"
web-sys = {
  version = "0.3.60",
  features = [
    "console",
  ]
}
*/

# 5. 构建项目
wasm-pack build --target web

# 6. 在 HTML 中使用
/*
\u003c!DOCTYPE html\u003e
\u003chtml\u003e
\u003chead\u003e
    \u003ctitle\u003eRust WebAssembly 示例\u003c/title\u003e
\u003c/head\u003e
\u003cbody\u003e
    \u003ch1\u003eRust WebAssembly 示例\u003c/h1\u003e
    \u003cscript type="module"\u003e
        // 导入 WebAssembly 模块
        import init, { add, fibonacci, calculate_pi } from './pkg/wasm_utils.js';
        
        async function run() {
            // 初始化模块
            await init();
            
            // 使用导出的函数
            console.log('2 + 3 =', add(2, 3));
            console.log('fibonacci(10) =', fibonacci(10));
            console.log('π (approximated) =', calculate_pi(1000000));
        }
        
        run();
    \u003c/script\u003e
\u003c/body\u003e
\u003c/html\u003e
*/
            \u003c/div\u003e
            \u003c
            \u003cbutton onclick="runToolchainDemo()"\u003e运行开发工具链演示\u003c/button\u003e
            \u003cdiv id="toolchainResult" class="result"\u003e点击按钮查看 WebAssembly 开发工具链演示结果...\u003c/div\u003e
        \u003c/div\u003e
        \u003c
        \u003cdiv class="demo-section"\u003e
            \u003ch2\u003e4. WebAssembly 与 JavaScript 互操作\u003c/h2\u003e
            \u003c
            \u003ch3\u003e4.1 JavaScript 调用 WebAssembly\u003c/h3\u003e
            \u003cdiv class="code-block"\u003e
// JavaScript 调用 WebAssembly 函数
async function jsCallWasmExample() {
  // 简单的 WebAssembly 模块示例（实际中通常从文件加载）
  // 这个模块导出了几个函数：add, subtract, multiply, divide
  const wasmCode = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
    0x01, 0x07, 0x01, 0x60, 0x02, 0x7f, 0x7f, 0x01, 0x7f,
    0x02, 0x08, 0x01, 0x00, 0x03, 0x61, 0x64, 0x64, 0x00,
    0x00, 0x03, 0x73, 0x75, 0x62, 0x00, 0x00, 0x03, 0x6d,
    0x75, 0x6c, 0x00, 0x00, 0x03, 0x64, 0x69, 0x76, 0x00,
    0x00, 0x07, 0x10, 0x01, 0x0a, 0x00, 0x20, 0x00, 0x20,
    0x01, 0x6a, 0x0b, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6b,
    0x0b, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6c, 0x0b, 0x00,
    0x20, 0x00, 0x20, 0x01, 0x6d, 0x0b, 0x04, 0x04, 0x61,
    0x64, 0x64, 0x00, 0x01, 0x04, 0x73, 0x75, 0x62, 0x00,
    0x01, 0x04, 0x6d, 0x75, 0x6c, 0x00, 0x01, 0x04, 0x64,
    0x69, 0x76, 0x00, 0x01
  ]);
  
  // 编译并实例化模块
  const wasmModule = await WebAssembly.instantiate(wasmCode);
  const wasmInstance = wasmModule.instance;
  const exports = wasmInstance.exports;
  
  // 获取导出的函数
  const add = exports.add;
  const subtract = exports.sub;
  const multiply = exports.mul;
  const divide = exports.div;
  
  // 调用 WebAssembly 函数
  const a = 10;
  const b = 5;
  
  const results = {
    add: add(a, b),
    subtract: subtract(a, b),
    multiply: multiply(a, b),
    divide: divide(a, b)
  };
  
  console.log(`计算结果 (${a}, ${b}):`, results);
  
  return results;
}

// 使用 WebAssembly.Memory 共享内存
async function sharedMemoryExample() {
  // 创建内存
  const memory = new WebAssembly.Memory({
    initial: 2,
    maximum: 10
  });
  
  // 假设这是从 WebAssembly 模块导出的内存
  const wasmMemory = memory;
  
  // JavaScript 端操作内存
  function jsWriteToMemory() {
    // 创建视图以访问内存
    const int32Array = new Int32Array(wasmMemory.buffer);
    const float32Array = new Float32Array(wasmMemory.buffer);
    const uint8Array = new Uint8Array(wasmMemory.buffer);
    
    // 写入整数数据
    int32Array[0] = 123;
    int32Array[1] = 456;
    
    // 写入浮点数数据
    float32Array[0] = 3.14159;
    float32Array[1] = 2.71828;
    
    // 写入字符串 (UTF-8)
    const str = "Hello from JS";
    const encoder = new TextEncoder();
    const encoded = encoder.encode(str);
    
    // 从位置 100 开始写入字符串
    const strOffset = 100;
    for (let i = 0; i < encoded.length; i++) {
      uint8Array[strOffset + i] = encoded[i];
    }
    uint8Array[strOffset + encoded.length] = 0; // 结束符
    
    return {
      intOffset: 0,
      floatOffset: 0,
      strOffset: strOffset,
      strLength: encoded.length
    };
  }
  
  // 从内存读取数据
  function jsReadFromMemory(offsets) {
    const int32Array = new Int32Array(wasmMemory.buffer);
    const float32Array = new Float32Array(wasmMemory.buffer);
    const uint8Array = new Uint8Array(wasmMemory.buffer);
    
    // 读取整数
    const int1 = int32Array[offsets.intOffset];
    const int2 = int32Array[offsets.intOffset + 1];
    
    // 读取浮点数
    const float1 = float32Array[offsets.floatOffset];
    const float2 = float32Array[offsets.floatOffset + 1];
    
    // 读取字符串
    const strBytes = uint8Array.slice(offsets.strOffset, offsets.strOffset + offsets.strLength);
    const decoder = new TextDecoder();
    const str = decoder.decode(strBytes);
    
    return {
      integers: [int1, int2],
      floats: [float1, float2],
      string: str
    };
  }
  
  // 执行内存操作
  const offsets = jsWriteToMemory();
  const data = jsReadFromMemory(offsets);
  
  return {
    memoryInfo: {
      size: wasmMemory.buffer.byteLength / 1024 + " KB",
      initialPages: 2,
      maximumPages: 10
    },
    data: data
  };
}
            \u003c/div\u003e
            \u003c
            \u003ch3\u003e4.2 WebAssembly 调用 JavaScript\u003c/h3\u003e
            \u003cdiv class="code-block"\u003e
// WebAssembly 调用 JavaScript 函数示例
async function wasmCallJsExample() {
  // 准备导入对象，包含 JavaScript 函数供 WebAssembly 调用
  const importObject = {
    js: {
      // 简单函数示例
      consoleLog: (value) => {
        console.log(`WebAssembly 调用: ${value}`);
        return value;
      },
      
      // 数学运算函数
      calculateSquare: (x) => {
        return x * x;
      },
      
      // 字符串处理函数
      stringLength: (ptr, len) => {
        // WebAssembly 传递字符串通常是通过内存指针和长度
        return len;
      },
      
      // 复杂对象处理
      processData: (dataPtr) => {
        // 从内存中读取结构化数据的示例
        // 这里只是模拟，实际实现需要根据具体内存布局
        console.log('处理数据指针:', dataPtr);
        return 42; // 模拟返回值
      }
    },
    env: {
      // WebAssembly 可能需要的环境变量和函数
      memoryBase: 0,
      tableBase: 0,
      memory: new WebAssembly.Memory({ initial: 256 }),
      table: new WebAssembly.Table({
        initial: 0,
        element: 'anyfunc'
      }),
      
      // 常见的系统调用函数
      abort: () => {
        console.error('WebAssembly 程序中止');
      }
    }
  };
  
  // 简单的 WebAssembly 模块（实际中通常从文件加载）
  // 这个模块会导入并调用 JavaScript 函数
  const wasmCode = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
    0x01, 0x0e, 0x02, 0x60, 0x01, 0x7f, 0x01, 0x7f,
    0x60, 0x00, 0x01, 0x7f, 0x02, 0x07, 0x01, 0x02,
    0x6a, 0x73, 0x0a, 0x63, 0x6f, 0x6e, 0x73, 0x6f, 0x6c, 0x65, 0x4c, 0x6f, 0x67,
    0x00, 0x00, 0x03, 0x02, 0x01, 0x01, 0x07, 0x07, 0x01, 0x05, 0x63, 0x61, 0x6c,
    0x6c, 0x4a, 0x53, 0x00, 0x01, 0x0a, 0x0a, 0x01, 0x08, 0x00, 49, 0x04, 0x6a,
    0x73, 0x0a, 0x63, 0x6f, 0x6e, 0x73, 0x6f, 0x6c, 0x65, 0x4c, 0x6f, 0x67, 0x03,
    0x00, 0x0b
  ]);
  
  try {
    // 编译并实例化模块
    const wasmModule = await WebAssembly.instantiate(wasmCode, importObject);
    const instance = wasmModule.instance;
    
    // 调用 WebAssembly 导出的函数，该函数会调用 JavaScript 函数
    const callJSFunction = instance.exports.callJS;
    
    if (callJSFunction) {
      const result = callJSFunction(100);
      console.log('WebAssembly 函数返回:', result);
      return { success: true, result };
    } else {
      console.log('模块没有导出 callJS 函数');
      return { success: false, error: '函数未导出' };
    }
  } catch (error) {
    console.error('WebAssembly 实例化失败:', error);
    return { success: false, error: error.message };
  }
}

// 在 Rust 中调用 JavaScript (使用 wasm-bindgen)
/*
// Rust 代码示例
use wasm_bindgen::prelude::*;

// 导入 JavaScript 的 console.log 函数
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);
    
    // 导入自定义 JavaScript 函数
    fn processData(ptr: *const u8, len: usize) -> i32;
}

// 定义 Rust 函数，内部调用 JavaScript 函数
#[wasm_bindgen]
pub fn rustFunction() -> String {
    // 调用 JavaScript 的 console.log
    log("Hello from Rust WebAssembly!");
    
    // 调用自定义 JavaScript 函数处理数据
    let data = [1, 2, 3, 4, 5];
    let result = processData(data.as_ptr(), data.len());
    
    format!("JavaScript 函数返回: {}", result)
}
*/
            \u003c/div\u003e
            \u003c
            \u003cbutton onclick="runInteroperabilityDemo()"\u003e运行互操作演示\u003c/button\u003e
            \u003cdiv id="interoperabilityResult" class="result"\u003e点击按钮查看 WebAssembly 与 JavaScript 互操作演示结果...\u003c/div\u003e
        \u003c/div\u003e
        \u003c
        \u003cdiv class="demo-section"\u003e
            \u003ch2\u003e5. WebAssembly 实际应用案例\u003c/h2\u003e
            \u003c
            \u003ch3\u003e5.1 图像处理应用\u003c/h3\u003e
            \u003cdiv class="code-block"\u003e
// WebAssembly 图像处理示例（概念演示）

// 1. JavaScript 部分 - 图像处理界面和控制
function setupImageProcessingDemo() {
  // 假设我们有一个编译好的 WebAssembly 模块用于图像处理
  // wasmImageProcessor.js - 从 C/C++ 或 Rust 编译而来
  
  async function loadImageProcessor() {
    try {
      // 加载 WebAssembly 模块
      const module = await import('./wasm-image-processor.js');
      await module.default();
      return module;
    } catch (error) {
      console.error('加载图像处理器失败:', error);
      return null;
    }
  }
  
  // 图像处理函数
  async function processImage(imageElement, operation) {
    const processor = await loadImageProcessor();
    if (!processor) return;
    
    // 获取画布和上下文
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    // 设置画布尺寸
    canvas.width = imageElement.width;
    canvas.height = imageElement.height;
    
    // 绘制图像到画布
    ctx.drawImage(imageElement, 0, 0);
    
    // 获取图像数据
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    
    // 创建 WebAssembly 内存视图
    const memory = new Uint8Array(processor.memory.buffer);
    
    // 计算所需内存大小并分配
    const pixelCount = canvas.width * canvas.height;
    const requiredSize = pixelCount * 4; // RGBA
    const memoryPtr = processor.allocateMemory(requiredSize);
    
    // 将图像数据复制到 WebAssembly 内存
    for (let i = 0; i < data.length; i++) {
      memory[memoryPtr + i] = data[i];
    }
    
    // 调用 WebAssembly 中的图像处理函数
    switch (operation) {
      case 'grayscale':
        processor.toGrayscale(memoryPtr, canvas.width, canvas.height);
        break;
      case 'blur':
        processor.blur(memoryPtr, canvas.width, canvas.height, 3); // 模糊半径
        break;
      case 'sharpen':
        processor.sharpen(memoryPtr, canvas.width, canvas.height);
        break;
      case 'edge':
        processor.detectEdges(memoryPtr, canvas.width, canvas.height);
        break;
    }
    
    // 将处理后的数据复制回 imageData
    for (let i = 0; i < data.length; i++) {
      data[i] = memory[memoryPtr + i];
    }
    
    // 释放分配的内存
    processor.freeMemory(memoryPtr);
    
    // 将处理后的图像数据绘制回画布
    ctx.putImageData(imageData, 0, 0);
    
    return canvas;
  }
  
  return {
    loadImageProcessor,
    processImage
  };
}

// 2. Rust 图像处理代码示例
/*
// src/lib.rs
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub struct ImageProcessor {
    memory: Vec<u8>,
}

#[wasm_bindgen]
impl ImageProcessor {
    #[wasm_bindgen(constructor)]
    pub fn new() -> ImageProcessor {
        ImageProcessor {
            memory: Vec::new(),
        }
    }
    
    // 转换为灰度图像
    pub fn to_grayscale(&self, data_ptr: *mut u8, width: u32, height: u32) {
        let len = (width * height * 4) as usize;
        let data = unsafe { std::slice::from_raw_parts_mut(data_ptr, len) };
        
        for i in (0..len).step_by(4) {
            let r = data[i] as f32;
            let g = data[i + 1] as f32;
            let b = data[i + 2] as f32;
            
            // 使用标准灰度转换公式: 0.299*R + 0.587*G + 0.114*B
            let gray = (0.299 * r + 0.587 * g + 0.114 * b) as u8;
            
            data[i] = gray;     // R
            data[i + 1] = gray; // G
            data[i + 2] = gray; // B
            // A (alpha) 保持不变
        }
    }
    
    // 高斯模糊
    pub fn blur(&self, data_ptr: *mut u8, width: u32, height: u32, radius: u32) {
        let len = (width * height * 4) as usize;
        let data = unsafe { std::slice::from_raw_parts_mut(data_ptr, len) };
        
        // 创建临时缓冲区
        let mut temp = vec![0; len];
        
        // 水平方向模糊
        for y in 0..height {
            for x in 0..width {
                let idx = (y * width + x) as usize * 4;
                
                // 计算加权平均
                let mut r = 0.0;
                let mut g = 0.0;
                let mut b = 0.0;
                let mut weight_sum = 0.0;
                
                for dx in -(radius as i32)..=(radius as i32) {
                    let nx = x as i32 + dx;
                    if nx >= 0 && nx < width as i32 {
                        let nidx = (y * width + nx as u32) as usize * 4;
                        let weight = 1.0 - (dx.abs() as f32 / (radius as f32 + 1.0));
                        
                        r += data[nidx] as f32 * weight;
                        g += data[nidx + 1] as f32 * weight;
                        b += data[nidx + 2] as f32 * weight;
                        weight_sum += weight;
                    }
                }
                
                temp[idx] = (r / weight_sum) as u8;
                temp[idx + 1] = (g / weight_sum) as u8;
                temp[idx + 2] = (b / weight_sum) as u8;
                temp[idx + 3] = data[idx + 3]; // 保持 Alpha
            }
        }
        
        // 垂直方向模糊
        for y in 0..height {
            for x in 0..width {
                let idx = (y * width + x) as usize * 4;
                
                let mut r = 0.0;
                let mut g = 0.0;
                let mut b = 0.0;
                let mut weight_sum = 0.0;
                
                for dy in -(radius as i32)..=(radius as i32) {
                    let ny = y as i32 + dy;
                    if ny >= 0 && ny < height as i32 {
                        let nidx = (ny as u32 * width + x) as usize * 4;
                        let weight = 1.0 - (dy.abs() as f32 / (radius as f32 + 1.0));
                        
                        r += temp[nidx] as f32 * weight;
                        g += temp[nidx + 1] as f32 * weight;
                        b += temp[nidx + 2] as f32 * weight;
                        weight_sum += weight;
                    }
                }
                
                data[idx] = (r / weight_sum) as u8;
                data[idx + 1] = (g / weight_sum) as u8;
                data[idx + 2] = (b / weight_sum) as u8;
                // Alpha 已保持不变
            }
        }
    }
    
    // 边缘检测（简单的 Sobel 算子）
    pub fn detect_edges(&self, data_ptr: *mut u8, width: u32, height: u32) {
        // 简化的边缘检测实现...
    }
}
*/
            \u003c/div\u003e
            \u003c
            \u003ch3\u003e5.2 高性能计算应用\u003c/h3\u003e
            \u003cdiv class="code-block"\u003e
// WebAssembly 高性能计算示例

// 1. JavaScript 部分 - 性能测试和比较
async function runPerformanceDemo() {
  // 加载 WebAssembly 模块
  async function loadWasmCalculator() {
    try {
      // 假设这是从 Rust 编译的 WebAssembly 模块
      const module = await import('./wasm-calculator.js');
      await module.default();
      return module;
    } catch (error) {
      console.error('加载计算模块失败:', error);
      return null;
    }
  }
  
  // JavaScript 实现的斐波那契函数
  function fibonacciJs(n) {
    if (n <= 1) return n;
    return fibonacciJs(n - 1) + fibonacciJs(n - 2);
  }
  
  // JavaScript 实现的矩阵乘法
  function multiplyMatricesJs(a, b) {
    const rowsA = a.length;
    const colsA = a[0].length;
    const colsB = b[0].length;
    const result = Array(rowsA).fill(0).map(() => Array(colsB).fill(0));
    
    for (let i = 0; i < rowsA; i++) {
      for (let j = 0; j < colsB; j++) {
        let sum = 0;
        for (let k = 0; k < colsA; k++) {
          sum += a[i][k] * b[k][j];
        }
        result[i][j] = sum;
      }
    }
    
    return result;
  }
  
  // 性能测试函数
  async function runPerformanceTests() {
    const wasmModule = await loadWasmCalculator();
    
    // 测试 1: 斐波那契数列
    console.log('开始性能测试: 斐波那契数列');
    
    // JavaScript 测试
    const jsStartTime = performance.now();
    const jsResult = fibonacciJs(40);
    const jsEndTime = performance.now();
    const jsDuration = jsEndTime - jsStartTime;
    
    // WebAssembly 测试
    let wasmDuration = 0;
    let wasmResult = 0;
    
    if (wasmModule && wasmModule.fibonacci) {
      const wasmStartTime = performance.now();
      wasmResult = wasmModule.fibonacci(40);
      const wasmEndTime = performance.now();
      wasmDuration = wasmEndTime - wasmStartTime;
    }
    
    console.log(`JavaScript 计算斐波那契(40): ${jsResult}, 耗时: ${jsDuration.toFixed(2)}ms`);
    if (wasmDuration > 0) {
      console.log(`WebAssembly 计算斐波那契(40): ${wasmResult}, 耗时: ${wasmDuration.toFixed(2)}ms`);
      console.log(`性能提升: ${(jsDuration / wasmDuration).toFixed(2)}倍`);
    }
    
    // 测试 2: 矩阵乘法
    console.log('\n开始性能测试: 矩阵乘法');
    
    // 创建测试矩阵 (100x100)
    const size = 100;
    const matrixA = Array(size).fill(0).map(() => 
      Array(size).fill(0).map(() => Math.random() * 100)
    );
    const matrixB = Array(size).fill(0).map(() => 
      Array(size).fill(0).map(() => Math.random() * 100)
    );
    
    // JavaScript 测试
    const jsMatrixStart = performance.now();
    const jsMatrixResult = multiplyMatricesJs(matrixA, matrixB);
    const jsMatrixEnd = performance.now();
    const jsMatrixDuration = jsMatrixEnd - jsMatrixStart;
    
    // WebAssembly 测试 (假设模块提供了矩阵乘法)
    let wasmMatrixDuration = 0;
    if (wasmModule && wasmModule.multiplyMatrices) {
      // 需要将 JavaScript 数组转换为 WebAssembly 可处理的格式
      // 这里简化处理，实际需要更多转换逻辑
      const wasmMatrixStart = performance.now();
      // wasmModule.multiplyMatrices(matrixA, matrixB);
      const wasmMatrixEnd = performance.now();
      wasmMatrixDuration = wasmMatrixEnd - wasmMatrixStart;
    }
    
    console.log(`JavaScript ${size}x${size} 矩阵乘法耗时: ${jsMatrixDuration.toFixed(2)}ms`);
    if (wasmMatrixDuration > 0) {
      console.log(`WebAssembly ${size}x${size} 矩阵乘法耗时: ${wasmMatrixDuration.toFixed(2)}ms`);
      console.log(`性能提升: ${(jsMatrixDuration / wasmMatrixDuration).toFixed(2)}倍`);
    }
    
    return {
      fibonacci: {
        js: { result: jsResult, duration: jsDuration },
        wasm: { result: wasmResult, duration: wasmDuration },
        speedup: wasmDuration > 0 ? jsDuration / wasmDuration : 0
      },
      matrix: {
        js: { duration: jsMatrixDuration },
        wasm: { duration: wasmMatrixDuration },
        speedup: wasmMatrixDuration > 0 ? jsMatrixDuration / wasmMatrixDuration : 0
      }
    };
  }
  
  return {
    loadWasmCalculator,
    fibonacciJs,
    multiplyMatricesJs,
    runPerformanceTests
  };
}

// 2. Rust 实现的高性能计算函数
/*
// src/lib.rs
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn fibonacci(n: u32) -> u32 {
    match n {
        0 => 0,
        1 => 1,
        _ => fibonacci(n - 1) + fibonacci(n - 2)
    }
}

#[wasm_bindgen]
pub fn fibonacci_optimized(n: u32) -> u64 {
    if n <= 1 {
        return n as u64;
    }
    
    let mut a: u64 = 0;
    let mut b: u64 = 1;
    let mut temp: u64;
    
    for _ in 2..=n {
        temp = a + b;
        a = b;
        b = temp;
    }
    
    b
}

#[wasm_bindgen]
pub fn multiply_matrices(
    a_ptr: *const f64, b_ptr: *const f64, result_ptr: *mut f64,
    rows_a: usize, cols_a: usize, cols_b: usize
) {
    // 安全地将指针转换为切片
    let a = unsafe { std::slice::from_raw_parts(a_ptr, rows_a * cols_a) };
    let b = unsafe { std::slice::from_raw_parts(b_ptr, cols_a * cols_b) };
    let result = unsafe { std::slice::from_raw_parts_mut(result_ptr, rows_a * cols_b) };
    
    // 执行矩阵乘法
    for i in 0..rows_a {
        for j in 0..cols_b {
            let mut sum = 0.0;
            for k in 0..cols_a {
                sum += a[i * cols_a + k] * b[k * cols_b + j];
            }
            result[i * cols_b + j] = sum;
        }
    }
}

// 计算 π 的近似值（蒙特卡洛方法）
#[wasm_bindgen]
pub fn calculate_pi_monte_carlo(iterations: u64) -> f64 {
    let mut inside_circle = 0;
    let mut rng = rand::thread_rng();
    
    for _ in 0..iterations {
        let x: f64 = rng.gen_range(-1.0..1.0);
        let y: f64 = rng.gen_range(-1.0..1.0);
        
        if x * x + y * y <= 1.0 {
            inside_circle += 1;
        }
    }
    
    4.0 * (inside_circle as f64) / (iterations as f64)
}
*/
            \u003c/div\u003e
            \u003c
            \u003cbutton onclick="runRealWorldDemo()"\u003e运行实际应用案例演示\u003c/button\u003e
            \u003cdiv id="realWorldResult" class="result"\u003e点击按钮查看 WebAssembly 实际应用案例演示结果...\u003c/div\u003e
        \u003c/div\u003e
        \u003c
        \u003cdiv class="demo-section"\u003e
            \u003ch2\u003e6. WebAssembly 最佳实践与优化技巧\u003c/h2\u003e
            \u003c
            \u003ch3\u003e6.1 性能优化建议\u003c/h3\u003e
            \u003cul\u003e
                \u003cli\u003e\u003cstrong\u003e使用适当的优化级别：\u003c/strong\u003e编译时启用高优化级别（如 -O3）\u003c/li\u003e
                \u003cli\u003e\u003cstrong\u003e减少内存复制：\u003c/strong\u003e通过共享内存避免频繁的数据复制\u003c/li\u003e
                \u003cli\u003e\u003cstrong\u003e优化内存使用：\u003c/strong\u003e合理设计数据结构，减少内存占用\u003c/li\u003e
                \u003cli\u003e\u003cstrong\u003e避免频繁的函数调用：\u003c/strong\u003e减少 JavaScript 和 WebAssembly 之间的调用次数\u003c/li\u003e
                \u003cli\u003e\u003cstrong\u003e使用流式编译：\u003c/strong\u003e使用 WebAssembly.instantiateStreaming 进行流式编译和实例化\u003c/li\u003e
                \u003cli\u003e\u003cstrong\u003e代码分割：\u003c/strong\u003e将大型模块拆分为更小的功能模块\u003c/li\u003e
                \u003cli\u003e\u003cstrong\u003e异步加载：\u003c/strong\u003e在不阻塞主线程的情况下加载 WebAssembly 模块\u003c/li\u003e
            \u003c/ul\u003e
            \u003c
            \u003ch3\u003e6.2 安全性考虑\u003c/h3\u003e