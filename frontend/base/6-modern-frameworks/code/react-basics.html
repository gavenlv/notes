<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React 框架基础详解</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        
        h1, h2, h3, h4 {
            color: #2c3e50;
        }
        
        h1 {
            text-align: center;
            border-bottom: 2px solid #61dafb;
            padding-bottom: 10px;
            margin-bottom: 40px;
        }
        
        h2 {
            border-left: 4px solid #61dafb;
            padding-left: 15px;
            margin-top: 50px;
        }
        
        h3 {
            color: #61dafb;
            margin-top: 30px;
        }
        
        .container {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .code-block {
            background-color: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 6px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        
        .demo-section {
            margin-bottom: 40px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 6px;
        }
        
        button {
            background-color: #61dafb;
            color: #282c34;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #4fa8c7;
        }
        
        .result {
            background-color: #e8f4f8;
            border: 1px solid #b3e5fc;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        
        .concept-box {
            background-color: #f0f0f0;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 4px solid #61dafb;
        }
        
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-item {
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>React 框架基础详解</h1>
        
        <div class="demo-section">
            <h2>1. React 核心概念</h2>
            
            <h3>1.1 什么是 React？</h3>
            <div class="concept-box">
                <p>React 是由 Facebook 开发的一个用于构建用户界面的 JavaScript 库。它具有以下特点：</p>
                <ul>
                    <li>声明式：以声明式编写 UI，使代码更可预测、更易调试</li>
                    <li>组件化：构建可复用的 UI 组件</li>
                    <li>一次学习，随处编写：可以使用相同的技能创建 Web 应用、移动应用和 VR 应用</li>
                </ul>
            </div>
            
            <h3>1.2 虚拟 DOM (Virtual DOM)</h3>
            <div class="code-block">
// React 使用虚拟 DOM 来提高性能
// 当组件状态变化时，React 会创建一个新的虚拟 DOM 树
// 然后与旧的虚拟 DOM 树进行比较（Diffing 算法）
// 只更新实际变化的部分到真实 DOM

// 示例：React 内部工作原理简化版
function updateDOM(currentTree, newTree) {
  // 1. 创建新的虚拟 DOM
  const patches = diff(currentTree, newTree);
  // 2. 应用差异到真实 DOM
  applyPatches(realDOM, patches);
}
            </div>
            
            <h3>1.3 JSX 语法</h3>
            <div class="code-block">
// JSX 是 JavaScript 的语法扩展，允许在 JavaScript 中编写 HTML 结构

// 基本示例
const element = <h1>Hello, React!</h1>;

// 使用 JavaScript 表达式
const name = 'React';
const greeting = <h1>Hello, {name}!</h1>;

// 条件渲染
const isLoggedIn = true;
const welcome = isLoggedIn ? 
  <h1>Welcome back!</h1> : 
  <h1>Please sign up.</h1>;

// 列表渲染
const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) => 
  <li key={number}>{number}</li>
);
            </div>
            
            <button onclick="runJSXDemo()">运行 JSX 演示</button>
            <div id="jsxResult" class="result">点击按钮查看 JSX 转换结果...</div>
        </div>
        
        <div class="demo-section">
            <h2>2. React 组件</h2>
            
            <h3>2.1 函数组件</h3>
            <div class="code-block">
// 函数组件是定义组件的最简单方式
// 使用函数接收 props 并返回 React 元素

function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

// 使用 ES6 箭头函数
const WelcomeArrow = (props) => <h1>Hello, {props.name}</h1>;

// 无状态组件（过去的概念，现在函数组件也可以有状态）
const StatelessComponent = () => <div>这是一个无状态组件</div>;

// 使用函数组件
function App() {
  return (
    <div>
      <Welcome name="Alice" />
      <Welcome name="Bob" />
      <Welcome name="Charlie" />
    </div>
  );
}
            </div>
            
            <h3>2.2 类组件</h3>
            <div class="code-block">
// 类组件使用 ES6 的 class 语法定义
// 必须继承 React.Component 并实现 render() 方法

class WelcomeClass extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}

// 有状态的类组件
class CounterClass extends React.Component {
  constructor(props) {
    super(props);
    // 初始化状态
    this.state = {
      count: 0
    };
    // 绑定方法
    this.handleClick = this.handleClick.bind(this);
  }
  
  handleClick() {
    this.setState(prevState => ({
      count: prevState.count + 1
    }));
  }
  
  render() {
    return (
      <div>
        <p>当前计数: {this.state.count}</p>
        <button onClick={this.handleClick}>增加</button>
      </div>
    );
  }
}
            </div>
            
            <button onclick="runComponentsDemo()">运行组件演示</button>
            <div id="componentsResult" class="result">点击按钮查看组件类型对比结果...</div>
        </div>
        
        <div class="demo-section">
            <h2>3. React Hooks</h2>
            
            <h3>3.1 useState Hook</h3>
            <div class="code-block">
// useState 是最基本的 Hook，用于在函数组件中添加状态

import React, { useState } from 'react';

function CounterHooks() {
  // 声明一个状态变量 count，初始值为 0
  // setCount 是更新 count 的函数
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>当前计数: {count}</p>
      <button onClick={() => setCount(count + 1)}>增加</button>
      <button onClick={() => setCount(count - 1)}>减少</button>
      <button onClick={() => setCount(0)}>重置</button>
    </div>
  );
}

// 使用对象作为状态
function UserProfile() {
  const [user, setUser] = useState({
    name: 'Alice',
    age: 30
  });
  
  // 更新对象状态时，需要合并属性
  const updateAge = (newAge) => {
    setUser(prevUser => ({
      ...prevUser,
      age: newAge
    }));
  };
  
  return (
    <div>
      <p>姓名: {user.name}</p>
      <p>年龄: {user.age}</p>
      <button onClick={() => updateAge(user.age + 1)}>增加年龄</button>
    </div>
  );
}
            </div>
            
            <h3>3.2 useEffect Hook</h3>
            <div class="code-block">
// useEffect Hook 用于处理副作用（如数据获取、订阅或手动更改 DOM）
// 相当于类组件中的 componentDidMount, componentDidUpdate 和 componentWillUnmount 的组合

import React, { useState, useEffect } from 'react';

function DataFetching() {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // 副作用函数
    async function fetchData() {
      try {
        setLoading(true);
        const response = await fetch('https://api.example.com/data');
        const jsonData = await response.json();
        setData(jsonData);
      } catch (error) {
        console.error('数据获取失败:', error);
      } finally {
        setLoading(false);
      }
    }
    
    fetchData();
    
    // 清理函数（可选），相当于 componentWillUnmount
    return () => {
      // 清理副作用，如取消订阅、清除定时器等
      console.log('组件卸载或重新渲染前清理');
    };
  }, []); // 依赖数组，空数组表示只在挂载和卸载时执行
  
  if (loading) {
    return <div>加载中...</div>;
  }
  
  return (
    <ul>
      {data.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
            </div>
            
            <h3>3.3 自定义 Hooks</h3>
            <div class="code-block">
// 自定义 Hooks 允许你重用状态逻辑
// 自定义 Hook 是一个函数，其名称以 "use" 开头，可以调用其他 Hook

// 自定义 Hook：处理窗口大小变化
function useWindowSize() {
  const [size, setSize] = useState({
    width: typeof window !== 'undefined' ? window.innerWidth : 0,
    height: typeof window !== 'undefined' ? window.innerHeight : 0,
  });

  useEffect(() => {
    function handleResize() {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    }

    window.addEventListener('resize', handleResize);
    
    // 清理函数
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return size;
}

// 使用自定义 Hook
function ResponsiveComponent() {
  const { width, height } = useWindowSize();

  return (
    <div>
      <p>窗口宽度: {width}px</p>
      <p>窗口高度: {height}px</p>
    </div>
  );
}
            </div>
            
            <button onclick="runHooksDemo()">运行 Hooks 演示</button>
            <div id="hooksResult" class="result">点击按钮查看 Hooks 演示结果...</div>
        </div>
        
        <div class="demo-section">
            <h2>4. React 生命周期</h2>
            
            <h3>4.1 类组件生命周期</h3>
            <div class="comparison">
                <div class="comparison-item">
                    <h4>挂载阶段</h4>
                    <ol>
                        <li><code>constructor()</code>: 初始化状态和绑定方法</li>
                        <li><code>static getDerivedStateFromProps()</code>: 从 props 派生状态</li>
                        <li><code>render()</code>: 渲染 UI</li>
                        <li><code>componentDidMount()</code>: 组件挂载后执行（DOM 可用）</li>
                    </ol>
                </div>
                <div class="comparison-item">
                    <h4>更新阶段</h4>
                    <ol>
                        <li><code>static getDerivedStateFromProps()</code>: 从 props 派生状态</li>
                        <li><code>shouldComponentUpdate()</code>: 决定是否重新渲染</li>
                        <li><code>render()</code>: 渲染 UI</li>
                        <li><code>getSnapshotBeforeUpdate()</code>: 更新前获取 DOM 快照</li>
                        <li><code>componentDidUpdate()</code>: 组件更新后执行</li>
                    </ol>
                </div>
            </div>
            
            <h3>4.2 卸载阶段</h3>
            <div class="concept-box">
                <ul>
                    <li><code>componentWillUnmount()</code>: 组件卸载前执行，用于清理副作用</li>
                </ul>
            </div>
            
            <h3>4.3 函数组件生命周期（使用 Hooks）</h3>
            <div class="code-block">
// 使用 useEffect Hook 模拟类组件生命周期

import React, { useState, useEffect } from 'react';

function LifecycleWithHooks() {
  const [count, setCount] = useState(0);
  
  // componentDidMount + componentDidUpdate 组合
  useEffect(() => {
    console.log('组件挂载或更新后执行');
    // 模拟 componentDidUpdate 中依赖特定状态
    if (count > 0) {
      console.log(`计数更新为: ${count}`);
    }
  });
  
  // 仅 componentDidMount
  useEffect(() => {
    console.log('组件挂载后执行一次');
    return () => {
      console.log('组件卸载前执行'); // componentWillUnmount
    };
  }, []);
  
  // 依赖特定状态的更新
  useEffect(() => {
    console.log(`计数变化: ${count}`);
    // 可以在这里执行基于 count 变化的副作用
  }, [count]);
  
  return (
    <div>
      <p>计数: {count}</p>
      <button onClick={() => setCount(count + 1)}>增加</button>
    </div>
  );
}
            </div>
            
            <button onclick="runLifecycleDemo()">运行生命周期演示</button>
            <div id="lifecycleResult" class="result">点击按钮查看生命周期演示结果...</div>
        </div>
        
        <div class="demo-section">
            <h2>5. React 状态管理最佳实践</h2>
            
            <h3>5.1 状态提升</h3>
            <div class="code-block">
// 当多个组件需要共享状态时，应该将状态提升到它们最近的共同父组件

function TemperatureCalculator() {
  const [temperature, setTemperature] = useState('');
  const [scale, setScale] = useState('celsius');
  
  // 转换温度函数
  function toCelsius(fahrenheit) {
    return (fahrenheit - 32) * 5 / 9;
  }
  
  function toFahrenheit(celsius) {
    return (celsius * 9 / 5) + 32;
  }
  
  // 根据输入和单位转换温度
  function tryConvert(temperature, convert) {
    const input = parseFloat(temperature);
    if (Number.isNaN(input)) {
      return '';
    }
    return Math.round(convert(input) * 1000) / 1000;
  }
  
  // 处理摄氏度输入变化
  const handleCelsiusChange = (value) => {
    setTemperature(value);
    setScale('celsius');
  };
  
  // 处理华氏度输入变化
  const handleFahrenheitChange = (value) => {
    setTemperature(value);
    setScale('fahrenheit');
  };
  
  // 计算两个输入框的值
  const celsius = scale === 'fahrenheit' ? tryConvert(temperature, toCelsius) : temperature;
  const fahrenheit = scale === 'celsius' ? tryConvert(temperature, toFahrenheit) : temperature;
  
  return (
    <div>
      <TemperatureInput
        scale="celsius"
        temperature={celsius}
        onTemperatureChange={handleCelsiusChange}
      />
      <TemperatureInput
        scale="fahrenheit"
        temperature={fahrenheit}
        onTemperatureChange={handleFahrenheitChange}
      />
      <BoilingVerdict
        celsius={parseFloat(celsius)}
      />
    </div>
  );
}
            </div>
            
            <h3>5.2 Context API 跨组件数据共享</h3>
            <div class="code-block">
// Context API 提供了一种在组件之间共享值的方式，无需在组件树中逐层传递 props

// 1. 创建 Context
const ThemeContext = React.createContext('light');

// 2. 提供 Context
function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Toolbar />
    </ThemeContext.Provider>
  );
}

// 3. 消费 Context (Class 组件)
class ThemedButton extends React.Component {
  static contextType = ThemeContext;
  render() {
    return <Button theme={this.context} />;
  }
}

// 4. 消费 Context (Function 组件)
function NavBar() {
  return (
    <ThemeContext.Consumer>
      {theme => (
        <nav style={{ background: theme === 'dark' ? '#333' : '#ccc' }}>
          <ThemedButton />
        </nav>
      )}
    </ThemeContext.Consumer>
  );
}

// 5. 使用 useContext Hook (推荐)
function UserGreeting() {
  const theme = useContext(ThemeContext);
  return <div style={{ color: theme === 'dark' ? 'white' : 'black' }}>Hello!</div>;
}
            </div>
            
            <button onclick="runBestPracticesDemo()">运行最佳实践演示</button>
            <div id="bestPracticesResult" class="result">点击按钮查看最佳实践演示结果...</div>
        </div>
    </div>

    <script>
        // JSX 演示函数
        function runJSXDemo() {
            const resultDiv = document.getElementById('jsxResult');
            const results = [
                'JSX 转换示例:',
                '原始 JSX:',
                'const element = <h1 className="greeting">Hello, React!</h1>;',
                '',
                '转换后的 JavaScript:',
                'const element = React.createElement(',
                '  "h1",',
                '  {className: "greeting"},',
                '  "Hello, React!"',
                ');',
                '',
                'JSX 特点:',
                '- 允许在 JavaScript 中编写 HTML 结构',
                '- 支持 JavaScript 表达式（使用 {} 包裹）',
                '- 自动防注入，更安全',
                '- 提供更好的开发体验和代码可读性'
            ];
            resultDiv.textContent = results.join('\n');
        }
        
        // 组件演示函数
        function runComponentsDemo() {
            const resultDiv = document.getElementById('componentsResult');
            const results = [
                '函数组件 vs 类组件:',
                '',
                '函数组件:',
                '- 语法简洁，代码量少',
                '- 更容易理解和测试',
                '- 使用 Hooks 管理状态和副作用',
                '- 性能略好（避免实例创建开销）',
                '',
                '类组件:',
                '- 使用 ES6 class 语法',
                '- 直接访问 this 和生命周期方法',
                '- 在没有 Hooks 前用于有状态组件',
                '- 代码较为冗长',
                '',
                'React 团队推荐:',
                '- 优先使用函数组件和 Hooks',
                '- 类组件仍然完全支持，但新特性主要针对函数组件'
            ];
            resultDiv.textContent = results.join('\n');
        }
        
        // Hooks 演示函数
        function runHooksDemo() {
            const resultDiv = document.getElementById('hooksResult');
            const results = [
                'React Hooks 主要类型:',
                '',
                '1. useState - 状态管理',
                '   用于在函数组件中添加状态变量',
                '',
                '2. useEffect - 副作用管理',
                '   处理数据获取、订阅、DOM 操作等副作用',
                '',
                '3. useContext - 上下文访问',
                '   读取和订阅上下文，避免 props 层层传递',
                '',
                '4. useReducer - 复杂状态管理',
                '   类似 Redux 的状态管理方式，适合复杂状态逻辑',
                '',
                '5. useCallback - 记忆化函数',
                '   避免函数不必要的重新创建，优化性能',
                '',
                '6. useMemo - 记忆化计算',
                '   缓存计算结果，避免不必要的重新计算',
                '',
                '7. useRef - DOM 引用和持久值',
                '   创建可变引用，在渲染间保持值'
            ];
            resultDiv.textContent = results.join('\n');
        }
        
        // 生命周期演示函数
        function runLifecycleDemo() {
            const resultDiv = document.getElementById('lifecycleResult');
            const results = [
                'React 生命周期对比:',
                '',
                '类组件生命周期:',
                '  - componentDidMount: 组件挂载后',
                '  - componentDidUpdate: 组件更新后',
                '  - componentWillUnmount: 组件卸载前',
                '',
                '函数组件（使用 Hooks）:',
                '  - useEffect(() => {}, []): 等价于 componentDidMount',
                '  - useEffect(() => {',
                '      // 副作用代码',
                '      return () => {',
                '        // 清理代码（componentWillUnmount）',
                '      }',
                '    }, []);',
                '  - useEffect(() => {}, [dependencies]): 依赖项变化时执行（componentDidUpdate）',
                '',
                'Hooks 优势:',
                '  - 按逻辑关注点组织代码，而非生命周期方法',
                '  - 更容易复用状态逻辑',
                '  - 代码更简洁，避免 this 绑定问题'
            ];
            resultDiv.textContent = results.join('\n');
        }
        
        // 最佳实践演示函数
        function runBestPracticesDemo() {
            const resultDiv = document.getElementById('bestPracticesResult');
            const results = [
                'React 状态管理最佳实践:',
                '',
                '1. 状态提升:',
                '   - 将共享状态提升到最近的共同祖先组件',
                '   - 避免状态重复和不一致',
                '',
                '2. Context API 使用场景:',
                '   - 全局主题设置',
                '   - 用户认证状态',
                '   - 应用配置信息',
                '   - 避免 props drilling 问题',
                '',
                '3. 性能优化建议:',
                '   - 使用 React.memo 缓存组件',
                '   - 合理使用 useCallback 和 useMemo',
                '   - 避免在渲染期间创建新对象和函数',
                '   - 虚拟列表处理长列表数据',
                '',
                '4. 代码组织:',
                '   - 按功能模块组织组件',
                '   - 组件职责单一化',
                '   - 合理拆分组件，提高可复用性'
            ];
            resultDiv.textContent = results.join('\n');
        }
        
        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', function() {
            console.log('React 基础演示页面加载完成');
        });
    </script>
</body>
</html>