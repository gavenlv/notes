# 第十四章：微前端安全实践

## 14.1 微前端安全概述

### 14.1.1 安全挑战

微前端架构带来的安全挑战主要包括：

1. **应用隔离性**
   - JavaScript全局变量污染
   - CSS样式冲突
   - DOM元素访问控制
   - 事件监听器隔离

2. **跨域通信安全**
   - 应用间数据传输
   - 身份验证与授权
   - 会话管理
   - CSRF/XSS防护

3. **依赖安全**
   - 第三方库漏洞
   - 版本兼容性
   - 供应链攻击
   - 恶意代码注入

4. **运行时安全**
   - 代码注入防护
   - 沙箱逃逸风险
   - 资源加载安全
   - API访问控制

### 14.1.2 安全目标

微前端安全的主要目标包括：

1. **数据安全**
   - 敏感数据保护
   - 数据传输加密
   - 数据访问控制
   - 数据完整性验证

2. **身份认证与授权**
   - 统一身份认证
   - 细粒度权限控制
   - 单点登录(SSO)
   - 会话安全管理

3. **代码安全**
   - 代码完整性验证
   - 恶意代码检测
   - 代码审计
   - 安全编码规范

4. **运行时安全**
   - 沙箱隔离
   - 资源访问控制
   - 异常处理
   - 安全日志记录

## 14.2 身份认证与授权

### 14.2.1 统一身份认证

```javascript
// 示例：统一身份认证服务
class UnifiedAuthService {
  constructor() {
    this.currentUser = null;
    this.token = null;
    this.tokenExpiry = null;
    this.refreshToken = null;
    this.authListeners = new Set();
    this.tokenRefreshInterval = null;
  }

  // 初始化认证服务
  initialize(config = {}) {
    this.config = {
      tokenRefreshThreshold: 5 * 60 * 1000, // 5分钟
      tokenRefreshInterval: 60 * 1000, // 1分钟
      authEndpoint: '/api/auth',
      tokenStorageKey: 'micro-frontend-token',
      refreshTokenStorageKey: 'micro-frontend-refresh-token',
      ...config,
    };
    
    // 从本地存储恢复认证状态
    this.restoreAuthState();
    
    // 启动令牌刷新检查
    this.startTokenRefreshCheck();
    
    console.log('Unified auth service initialized');
  }

  // 登录
  async login(credentials) {
    try {
      const response = await fetch(`${this.config.authEndpoint}/login`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(credentials),
      });
      
      if (!response.ok) {
        throw new Error(`Login failed: ${response.status}`);
      }
      
      const data = await response.json();
      
      // 保存认证信息
      this.setAuthData(data.token, data.refreshToken, data.user, data.expiresIn);
      
      // 通知监听器
      this.notifyAuthListeners('login', data.user);
      
      return data.user;
    } catch (error) {
      console.error('Login error:', error);
      throw error;
    }
  }

  // 登出
  async logout() {
    try {
      // 调用服务端登出接口
      if (this.token) {
        await fetch(`${this.config.authEndpoint}/logout`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.token}`,
          },
        });
      }
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      // 清除本地认证状态
      this.clearAuthState();
      
      // 通知监听器
      this.notifyAuthListeners('logout');
    }
  }

  // 刷新令牌
  async refreshToken() {
    if (!this.refreshToken) {
      throw new Error('No refresh token available');
    }
    
    try {
      const response = await fetch(`${this.config.authEndpoint}/refresh`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          refreshToken: this.refreshToken,
        }),
      });
      
      if (!response.ok) {
        throw new Error(`Token refresh failed: ${response.status}`);
      }
      
      const data = await response.json();
      
      // 更新认证信息
      this.setAuthData(data.token, data.refreshToken, data.user, data.expiresIn);
      
      return data;
    } catch (error) {
      console.error('Token refresh error:', error);
      
      // 刷新失败，清除认证状态
      this.clearAuthState();
      
      // 通知监听器
      this.notifyAuthListeners('token-expired');
      
      throw error;
    }
  }

  // 检查认证状态
  isAuthenticated() {
    return !!this.token && !!this.currentUser && !this.isTokenExpired();
  }

  // 获取当前用户
  getCurrentUser() {
    return this.currentUser;
  }

  // 获取认证令牌
  getToken() {
    return this.token;
  }

  // 检查令牌是否过期
  isTokenExpired() {
    if (!this.tokenExpiry) {
      return true;
    }
    
    return Date.now() >= this.tokenExpiry;
  }

  // 检查令牌是否需要刷新
  shouldRefreshToken() {
    if (!this.tokenExpiry) {
      return false;
    }
    
    return Date.now() >= (this.tokenExpiry - this.config.tokenRefreshThreshold);
  }

  // 设置认证数据
  setAuthData(token, refreshToken, user, expiresIn) {
    this.token = token;
    this.refreshToken = refreshToken;
    this.currentUser = user;
    this.tokenExpiry = Date.now() + (expiresIn * 1000);
    
    // 保存到本地存储
    localStorage.setItem(this.config.tokenStorageKey, token);
    localStorage.setItem(this.config.refreshTokenStorageKey, refreshToken);
    localStorage.setItem(`${this.config.tokenStorageKey}-expiry`, this.tokenExpiry.toString());
    localStorage.setItem(`${this.config.tokenStorageKey}-user`, JSON.stringify(user));
  }

  // 恢复认证状态
  restoreAuthState() {
    const token = localStorage.getItem(this.config.tokenStorageKey);
    const refreshToken = localStorage.getItem(this.config.refreshTokenStorageKey);
    const tokenExpiry = localStorage.getItem(`${this.config.tokenStorageKey}-expiry`);
    const userStr = localStorage.getItem(`${this.config.tokenStorageKey}-user`);
    
    if (token && refreshToken && tokenExpiry && userStr) {
      try {
        this.token = token;
        this.refreshToken = refreshToken;
        this.tokenExpiry = parseInt(tokenExpiry, 10);
        this.currentUser = JSON.parse(userStr);
        
        // 检查令牌是否过期
        if (this.isTokenExpired()) {
          this.clearAuthState();
          return false;
        }
        
        // 检查是否需要刷新令牌
        if (this.shouldRefreshToken()) {
          this.refreshToken().catch(error => {
            console.error('Failed to refresh token on restore:', error);
          });
        }
        
        return true;
      } catch (error) {
        console.error('Failed to restore auth state:', error);
        this.clearAuthState();
      }
    }
    
    return false;
  }

  // 清除认证状态
  clearAuthState() {
    this.token = null;
    this.refreshToken = null;
    this.currentUser = null;
    this.tokenExpiry = null;
    
    // 从本地存储清除
    localStorage.removeItem(this.config.tokenStorageKey);
    localStorage.removeItem(this.config.refreshTokenStorageKey);
    localStorage.removeItem(`${this.config.tokenStorageKey}-expiry`);
    localStorage.removeItem(`${this.config.tokenStorageKey}-user`);
  }

  // 启动令牌刷新检查
  startTokenRefreshCheck() {
    this.tokenRefreshInterval = setInterval(() => {
      if (this.shouldRefreshToken()) {
        this.refreshToken().catch(error => {
          console.error('Failed to refresh token:', error);
        });
      }
    }, this.config.tokenRefreshInterval);
  }

  // 停止令牌刷新检查
  stopTokenRefreshCheck() {
    if (this.tokenRefreshInterval) {
      clearInterval(this.tokenRefreshInterval);
      this.tokenRefreshInterval = null;
    }
  }

  // 添加认证状态监听器
  addAuthListener(callback) {
    this.authListeners.add(callback);
    
    // 返回移除监听器的函数
    return () => {
      this.authListeners.delete(callback);
    };
  }

  // 通知认证状态监听器
  notifyAuthListeners(event, data) {
    for (const callback of this.authListeners) {
      try {
        callback(event, data);
      } catch (error) {
        console.error('Error in auth listener:', error);
      }
    }
  }

  // 销毁认证服务
  destroy() {
    this.stopTokenRefreshCheck();
    this.authListeners.clear();
  }
}

// 导出单例
export const unifiedAuthService = new UnifiedAuthService();
```

### 14.2.2 权限控制系统

```javascript
// 示例：权限控制系统
class PermissionSystem {
  constructor() {
    this.roles = new Map(); // roleId -> role
    this.permissions = new Map(); // permissionId -> permission
    this.userRoles = new Map(); // userId -> Set(roleId)
    this.rolePermissions = new Map(); // roleId -> Set(permissionId)
    this.userPermissions = new Map(); // userId -> Set(permissionId)
    this.permissionCache = new Map(); // cache key -> boolean
    this.cacheTimeout = 5 * 60 * 1000; // 5分钟
  }

  // 初始化权限系统
  initialize(config = {}) {
    this.config = {
      cacheEnabled: true,
      cacheTimeout: 5 * 60 * 1000, // 5分钟
      ...config,
    };
    
    console.log('Permission system initialized');
  }

  // 添加角色
  addRole(role) {
    if (!role.id || !role.name) {
      throw new Error('Role must have id and name');
    }
    
    this.roles.set(role.id, {
      id: role.id,
      name: role.name,
      description: role.description || '',
      createdAt: new Date(),
      ...role,
    });
    
    // 初始化角色权限映射
    if (!this.rolePermissions.has(role.id)) {
      this.rolePermissions.set(role.id, new Set());
    }
    
    console.log(`Role added: ${role.name} (${role.id})`);
  }

  // 添加权限
  addPermission(permission) {
    if (!permission.id || !permission.name) {
      throw new Error('Permission must have id and name');
    }
    
    this.permissions.set(permission.id, {
      id: permission.id,
      name: permission.name,
      description: permission.description || '',
      resource: permission.resource || '',
      action: permission.action || '',
      createdAt: new Date(),
      ...permission,
    });
    
    console.log(`Permission added: ${permission.name} (${permission.id})`);
  }

  // 为角色分配权限
  assignPermissionToRole(roleId, permissionId) {
    if (!this.roles.has(roleId)) {
      throw new Error(`Role not found: ${roleId}`);
    }
    
    if (!this.permissions.has(permissionId)) {
      throw new Error(`Permission not found: ${permissionId}`);
    }
    
    const rolePermissions = this.rolePermissions.get(roleId);
    rolePermissions.add(permissionId);
    
    // 清除用户权限缓存
    this.clearUserPermissionCache();
    
    console.log(`Permission ${permissionId} assigned to role ${roleId}`);
  }

  // 为用户分配角色
  assignRoleToUser(userId, roleId) {
    if (!this.roles.has(roleId)) {
      throw new Error(`Role not found: ${roleId}`);
    }
    
    if (!this.userRoles.has(userId)) {
      this.userRoles.set(userId, new Set());
    }
    
    const userRoles = this.userRoles.get(userId);
    userRoles.add(roleId);
    
    // 清除用户权限缓存
    this.clearUserPermissionCache(userId);
    
    console.log(`Role ${roleId} assigned to user ${userId}`);
  }

  // 从用户移除角色
  removeRoleFromUser(userId, roleId) {
    if (!this.userRoles.has(userId)) {
      return;
    }
    
    const userRoles = this.userRoles.get(userId);
    userRoles.delete(roleId);
    
    // 清除用户权限缓存
    this.clearUserPermissionCache(userId);
    
    console.log(`Role ${roleId} removed from user ${userId}`);
  }

  // 从角色移除权限
  removePermissionFromRole(roleId, permissionId) {
    if (!this.rolePermissions.has(roleId)) {
      return;
    }
    
    const rolePermissions = this.rolePermissions.get(roleId);
    rolePermissions.delete(permissionId);
    
    // 清除用户权限缓存
    this.clearUserPermissionCache();
    
    console.log(`Permission ${permissionId} removed from role ${roleId}`);
  }

  // 检查用户是否有特定权限
  hasPermission(userId, permissionId) {
    // 检查缓存
    const cacheKey = `${userId}:${permissionId}`;
    if (this.config.cacheEnabled && this.permissionCache.has(cacheKey)) {
      const cached = this.permissionCache.get(cacheKey);
      if (Date.now() - cached.timestamp < this.cacheTimeout) {
        return cached.value;
      }
    }
    
    // 计算权限
    const hasPermission = this.calculateUserPermission(userId, permissionId);
    
    // 更新缓存
    if (this.config.cacheEnabled) {
      this.permissionCache.set(cacheKey, {
        value: hasPermission,
        timestamp: Date.now(),
      });
    }
    
    return hasPermission;
  }

  // 计算用户权限
  calculateUserPermission(userId, permissionId) {
    // 获取用户角色
    if (!this.userRoles.has(userId)) {
      return false;
    }
    
    const userRoles = this.userRoles.get(userId);
    
    // 检查每个角色是否有该权限
    for (const roleId of userRoles) {
      if (this.roleHasPermission(roleId, permissionId)) {
        return true;
      }
    }
    
    return false;
  }

  // 检查角色是否有特定权限
  roleHasPermission(roleId, permissionId) {
    if (!this.rolePermissions.has(roleId)) {
      return false;
    }
    
    const rolePermissions = this.rolePermissions.get(roleId);
    return rolePermissions.has(permissionId);
  }

  // 获取用户所有权限
  getUserPermissions(userId) {
    // 检查缓存
    const cacheKey = `user-permissions:${userId}`;
    if (this.config.cacheEnabled && this.permissionCache.has(cacheKey)) {
      const cached = this.permissionCache.get(cacheKey);
      if (Date.now() - cached.timestamp < this.cacheTimeout) {
        return cached.value;
      }
    }
    
    // 计算用户权限
    const permissions = this.calculateUserPermissions(userId);
    
    // 更新缓存
    if (this.config.cacheEnabled) {
      this.permissionCache.set(cacheKey, {
        value: permissions,
        timestamp: Date.now(),
      });
    }
    
    return permissions;
  }

  // 计算用户所有权限
  calculateUserPermissions(userId) {
    const permissions = new Set();
    
    // 获取用户角色
    if (!this.userRoles.has(userId)) {
      return Array.from(permissions);
    }
    
    const userRoles = this.userRoles.get(userId);
    
    // 收集所有角色的权限
    for (const roleId of userRoles) {
      if (this.rolePermissions.has(roleId)) {
        const rolePermissions = this.rolePermissions.get(roleId);
        for (const permissionId of rolePermissions) {
          permissions.add(permissionId);
        }
      }
    }
    
    return Array.from(permissions);
  }

  // 获取用户所有角色
  getUserRoles(userId) {
    if (!this.userRoles.has(userId)) {
      return [];
    }
    
    const roleIds = Array.from(this.userRoles.get(userId));
    return roleIds.map(roleId => this.roles.get(roleId)).filter(Boolean);
  }

  // 获取角色所有权限
  getRolePermissions(roleId) {
    if (!this.rolePermissions.has(roleId)) {
      return [];
    }
    
    const permissionIds = Array.from(this.rolePermissions.get(roleId));
    return permissionIds.map(permissionId => this.permissions.get(permissionId)).filter(Boolean);
  }

  // 清除用户权限缓存
  clearUserPermissionCache(userId = null) {
    if (userId) {
      // 清除特定用户的缓存
      const keysToDelete = [];
      
      for (const key of this.permissionCache.keys()) {
        if (key.startsWith(`${userId}:`) || key === `user-permissions:${userId}`) {
          keysToDelete.push(key);
        }
      }
      
      for (const key of keysToDelete) {
        this.permissionCache.delete(key);
      }
    } else {
      // 清除所有用户权限缓存
      const keysToDelete = [];
      
      for (const key of this.permissionCache.keys()) {
        if (key.includes(':') || key.startsWith('user-permissions:')) {
          keysToDelete.push(key);
        }
      }
      
      for (const key of keysToDelete) {
        this.permissionCache.delete(key);
      }
    }
  }

  // 清除所有缓存
  clearAllCache() {
    this.permissionCache.clear();
  }

  // 从服务器加载权限数据
  async loadFromServer(endpoint = '/api/permissions') {
    try {
      const response = await fetch(endpoint);
      
      if (!response.ok) {
        throw new Error(`Failed to load permissions: ${response.status}`);
      }
      
      const data = await response.json();
      
      // 加载角色
      if (data.roles) {
        for (const role of data.roles) {
          this.addRole(role);
        }
      }
      
      // 加载权限
      if (data.permissions) {
        for (const permission of data.permissions) {
          this.addPermission(permission);
        }
      }
      
      // 加载角色权限映射
      if (data.rolePermissions) {
        for (const { roleId, permissionId } of data.rolePermissions) {
          this.assignPermissionToRole(roleId, permissionId);
        }
      }
      
      // 加载用户角色映射
      if (data.userRoles) {
        for (const { userId, roleId } of data.userRoles) {
          this.assignRoleToUser(userId, roleId);
        }
      }
      
      console.log('Permissions loaded from server');
    } catch (error) {
      console.error('Failed to load permissions from server:', error);
      throw error;
    }
  }

  // 创建权限检查装饰器
  createPermissionGuard(permissionId) {
    return (target, propertyKey, descriptor) => {
      const originalMethod = descriptor.value;
      
      descriptor.value = function(...args) {
        // 获取当前用户ID
        const userId = this.getCurrentUserId ? this.getCurrentUserId() : null;
        
        if (!userId) {
          throw new Error('User not authenticated');
        }
        
        // 检查权限
        if (!permissionSystem.hasPermission(userId, permissionId)) {
          throw new Error(`Access denied: missing permission ${permissionId}`);
        }
        
        // 执行原方法
        return originalMethod.apply(this, args);
      };
      
      return descriptor;
    };
  }

  // 创建权限检查高阶组件
  withPermission(permissionId) {
    return (Component) => {
      return class PermissionWrapper extends Component {
        componentDidMount() {
          super.componentDidMount && super.componentDidMount();
          
          // 获取当前用户ID
          const userId = this.getCurrentUserId ? this.getCurrentUserId() : null;
          
          if (!userId) {
            // 重定向到登录页
            this.redirectToLogin && this.redirectToLogin();
            return;
          }
          
          // 检查权限
          if (!permissionSystem.hasPermission(userId, permissionId)) {
            // 显示无权限页面
            this.showAccessDenied && this.showAccessDenied();
            return;
          }
        }
        
        render() {
          // 获取当前用户ID
          const userId = this.getCurrentUserId ? this.getCurrentUserId() : null;
          
          if (!userId || !permissionSystem.hasPermission(userId, permissionId)) {
            return null; // 不渲染组件
          }
          
          // 渲染原组件
          return super.render();
        }
      };
    };
  }
}

// 导出单例
export const permissionSystem = new PermissionSystem();
```

## 14.3 代码安全

### 14.3.1 内容安全策略(CSP)

```javascript
// 示例：内容安全策略管理
class ContentSecurityPolicy {
  constructor() {
    this.directives = new Map();
    this.reportUri = null;
    this.reportOnly = false;
    this.isInitialized = false;
  }

  // 初始化CSP
  initialize(config = {}) {
    this.config = {
      reportUri: '/api/csp-report',
      reportOnly: false,
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", 'data:', 'https:'],
      fontSrc: ["'self'", 'https:'],
      connectSrc: ["'self'"],
      frameSrc: ["'none'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      manifestSrc: ["'self'"],
      workerSrc: ["'self'"],
      childSrc: ["'self'"],
      formAction: ["'self'"],
      frameAncestors: ["'none'"],
      baseUri: ["'self'"],
      ...config,
    };
    
    // 设置默认指令
    this.setDefaultDirectives();
    
    // 设置报告URI
    this.reportUri = this.config.reportUri;
    this.reportOnly = this.config.reportOnly;
    
    // 应用CSP
    this.applyCSP();
    
    // 监听CSP违规报告
    this.setupViolationReporting();
    
    this.isInitialized = true;
    
    console.log('Content Security Policy initialized');
  }

  // 设置默认指令
  setDefaultDirectives() {
    // default-src
    this.setDirective('default-src', this.config.defaultSrc);
    
    // script-src
    this.setDirective('script-src', this.config.scriptSrc);
    
    // style-src
    this.setDirective('style-src', this.config.styleSrc);
    
    // img-src
    this.setDirective('img-src', this.config.imgSrc);
    
    // font-src
    this.setDirective('font-src', this.config.fontSrc);
    
    // connect-src
    this.setDirective('connect-src', this.config.connectSrc);
    
    // frame-src
    this.setDirective('frame-src', this.config.frameSrc);
    
    // object-src
    this.setDirective('object-src', this.config.objectSrc);
    
    // media-src
    this.setDirective('media-src', this.config.mediaSrc);
    
    // manifest-src
    this.setDirective('manifest-src', this.config.manifestSrc);
    
    // worker-src
    this.setDirective('worker-src', this.config.workerSrc);
    
    // child-src
    this.setDirective('child-src', this.config.childSrc);
    
    // form-action
    this.setDirective('form-action', this.config.formAction);
    
    // frame-ancestors
    this.setDirective('frame-ancestors', this.config.frameAncestors);
    
    // base-uri
    this.setDirective('base-uri', this.config.baseUri);
  }

  // 设置指令
  setDirective(name, values) {
    if (!Array.isArray(values)) {
      values = [values];
    }
    
    this.directives.set(name, values);
  }

  // 添加指令值
  addDirectiveValue(name, value) {
    if (!this.directives.has(name)) {
      this.directives.set(name, []);
    }
    
    const values = this.directives.get(name);
    if (!values.includes(value)) {
      values.push(value);
    }
  }

  // 移除指令值
  removeDirectiveValue(name, value) {
    if (!this.directives.has(name)) {
      return;
    }
    
    const values = this.directives.get(name);
    const index = values.indexOf(value);
    if (index > -1) {
      values.splice(index, 1);
    }
    
    // 如果没有值了，移除整个指令
    if (values.length === 0) {
      this.directives.delete(name);
    }
  }

  // 获取指令
  getDirective(name) {
    return this.directives.get(name) || [];
  }

  // 生成CSP字符串
  generateCSPString() {
    const directives = [];
    
    for (const [name, values] of this.directives) {
      if (values.length > 0) {
        directives.push(`${name} ${values.join(' ')}`);
      }
    }
    
    // 添加报告URI
    if (this.reportUri) {
      directives.push(`report-uri ${this.reportUri}`);
    }
    
    return directives.join('; ');
  }

  // 应用CSP
  applyCSP() {
    const cspString = this.generateCSPString();
    
    // 创建meta标签
    const meta = document.createElement('meta');
    meta.httpEquiv = this.reportOnly ? 'Content-Security-Policy-Report-Only' : 'Content-Security-Policy';
    meta.content = cspString;
    
    // 添加到head
    document.head.appendChild(meta);
    
    console.log(`CSP applied: ${cspString}`);
  }

  // 设置违规报告
  setupViolationReporting() {
    if (!this.reportUri) {
      return;
    }
    
    // 监听安全策略违规事件
    document.addEventListener('securitypolicyviolation', (event) => {
      const violation = {
        blockedURI: event.blockedURI,
        documentURI: event.documentURI,
        effectiveDirective: event.effectiveDirective,
        originalPolicy: event.originalPolicy,
        referrer: event.referrer,
        sample: event.sample,
        sourceFile: event.sourceFile,
        lineNumber: event.lineNumber,
        columnNumber: event.columnNumber,
        statusCode: event.statusCode,
        disposition: event.disposition,
        timestamp: Date.now(),
      };
      
      // 发送违规报告
      this.sendViolationReport(violation);
    });
  }

  // 发送违规报告
  async sendViolationReport(violation) {
    try {
      const response = await fetch(this.reportUri, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          'csp-report': violation,
        }),
      });
      
      if (!response.ok) {
        throw new Error(`Failed to send violation report: ${response.status}`);
      }
      
      console.log('CSP violation report sent');
    } catch (error) {
      console.error('Failed to send CSP violation report:', error);
    }
  }

  // 为微前端应用创建子CSP
  createSubCsp(appName, config = {}) {
    const subCsp = new ContentSecurityPolicy();
    
    // 继承父CSP的配置
    const parentConfig = { ...this.config };
    
    // 应用子应用特定配置
    const appConfig = {
      ...parentConfig,
      ...config,
    };
    
    // 初始化子CSP
    subCsp.initialize(appConfig);
    
    // 添加子应用特定的script-src
    if (config.scriptSrc) {
      for (const src of config.scriptSrc) {
        subCsp.addDirectiveValue('script-src', src);
      }
    }
    
    // 添加子应用特定的connect-src
    if (config.connectSrc) {
      for (const src of config.connectSrc) {
        subCsp.addDirectiveValue('connect-src', src);
      }
    }
    
    // 添加子应用特定的img-src
    if (config.imgSrc) {
      for (const src of config.imgSrc) {
        subCsp.addDirectiveValue('img-src', src);
      }
    }
    
    console.log(`Sub CSP created for app: ${appName}`);
    
    return subCsp;
  }

  // 生成nonce
  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
  }

  // 为脚本添加nonce
  addScriptNonce(nonce) {
    this.addDirectiveValue('script-src', `'nonce-${nonce}'`);
  }

  // 为样式添加nonce
  addStyleNonce(nonce) {
    this.addDirectiveValue('style-src', `'nonce-${nonce}'`);
  }

  // 更新CSP
  updateCSP() {
    if (!this.isInitialized) {
      return;
    }
    
    // 移除现有的CSP meta标签
    const metaTags = document.querySelectorAll('meta[http-equiv="Content-Security-Policy"], meta[http-equiv="Content-Security-Policy-Report-Only"]');
    for (const meta of metaTags) {
      meta.parentNode.removeChild(meta);
    }
    
    // 重新应用CSP
    this.applyCSP();
  }

  // 销毁CSP
  destroy() {
    // 移除CSP meta标签
    const metaTags = document.querySelectorAll('meta[http-equiv="Content-Security-Policy"], meta[http-equiv="Content-Security-Policy-Report-Only"]');
    for (const meta of metaTags) {
      meta.parentNode.removeChild(meta);
    }
    
    this.directives.clear();
    this.isInitialized = false;
    
    console.log('Content Security Policy destroyed');
  }
}

// 导出单例
export const contentSecurityPolicy = new ContentSecurityPolicy();
```

### 14.3.2 代码沙箱隔离

```javascript
// 示例：代码沙箱隔离
class CodeSandbox {
  constructor() {
    this.sandboxes = new Map();
    this.globalWhitelist = new Set([
      'console',
      'setTimeout',
      'clearTimeout',
      'setInterval',
      'clearInterval',
      'requestAnimationFrame',
      'cancelAnimationFrame',
      'Promise',
      'Array',
      'Object',
      'String',
      'Number',
      'Boolean',
      'Date',
      'Math',
      'JSON',
      'RegExp',
      'Error',
      'Map',
      'Set',
      'WeakMap',
      'WeakSet',
      'ArrayBuffer',
      'DataView',
      'Int8Array',
      'Uint8Array',
      'Uint8ClampedArray',
      'Int16Array',
      'Uint16Array',
      'Int32Array',
      'Uint32Array',
      'Float32Array',
      'Float64Array',
    ]);
    this.domWhitelist = new Set([
      'document.createElement',
      'document.createTextNode',
      'document.getElementById',
      'document.querySelector',
      'document.querySelectorAll',
      'element.appendChild',
      'element.removeChild',
      'element.replaceChild',
      'element.insertBefore',
      'element.addEventListener',
      'element.removeEventListener',
      'element.setAttribute',
      'element.getAttribute',
      'element.removeAttribute',
      'element.classList',
      'element.style',
    ]);
  }

  // 创建沙箱
  createSandbox(appName, config = {}) {
    const sandboxId = `sandbox-${appName}-${Date.now()}`;
    
    const sandbox = {
      id: sandboxId,
      appName,
      config: {
        timeout: 5000, // 5秒超时
        memoryLimit: 50 * 1024 * 1024, // 50MB内存限制
        allowNetworkRequests: false,
        allowedDomains: [],
        allowDOMAccess: false,
        allowedDOMMethods: [],
        allowGlobalAccess: false,
        allowedGlobals: [],
        ...config,
      },
      globals: {},
      memoryUsage: 0,
      isDestroyed: false,
      timers: new Set(),
      networkRequests: new Set(),
      domNodes: new Set(),
    };
    
    // 创建沙箱环境
    this.setupSandboxEnvironment(sandbox);
    
    // 保存沙箱
    this.sandboxes.set(sandboxId, sandbox);
    
    console.log(`Sandbox created for app: ${appName} (${sandboxId})`);
    
    return sandboxId;
  }

  // 设置沙箱环境
  setupSandboxEnvironment(sandbox) {
    // 创建沙箱全局对象
    const sandboxGlobal = {};
    
    // 添加允许的全局对象
    if (sandbox.config.allowGlobalAccess) {
      for (const globalName of this.globalWhitelist) {
        if (sandbox.config.allowedGlobals.length === 0 || sandbox.config.allowedGlobals.includes(globalName)) {
          sandboxGlobal[globalName] = window[globalName];
        }
      }
    }
    
    // 创建受限的console对象
    sandboxGlobal.console = {
      log: (...args) => console.log(`[${sandbox.appName}]`, ...args),
      warn: (...args) => console.warn(`[${sandbox.appName}]`, ...args),
      error: (...args) => console.error(`[${sandbox.appName}]`, ...args),
      info: (...args) => console.info(`[${sandbox.appName}]`, ...args),
    };
    
    // 创建受限的定时器函数
    sandboxGlobal.setTimeout = (callback, delay) => {
      const timerId = setTimeout(() => {
        try {
          callback();
        } catch (error) {
          console.error(`Error in setTimeout callback for ${sandbox.appName}:`, error);
        }
      }, delay);
      
      sandbox.timers.add(timerId);
      return timerId;
    };
    
    sandboxGlobal.clearTimeout = (timerId) => {
      clearTimeout(timerId);
      sandbox.timers.delete(timerId);
    };
    
    sandboxGlobal.setInterval = (callback, interval) => {
      const timerId = setInterval(() => {
        try {
          callback();
        } catch (error) {
          console.error(`Error in setInterval callback for ${sandbox.appName}:`, error);
        }
      }, interval);
      
      sandbox.timers.add(timerId);
      return timerId;
    };
    
    sandboxGlobal.clearInterval = (timerId) => {
      clearInterval(timerId);
      sandbox.timers.delete(timerId);
    };
    
    // 创建受限的fetch函数
    if (sandbox.config.allowNetworkRequests) {
      sandboxGlobal.fetch = async (url, options) => {
        // 检查域名是否在允许列表中
        const urlObj = new URL(url, window.location.origin);
        if (sandbox.config.allowedDomains.length > 0 && !sandbox.config.allowedDomains.includes(urlObj.hostname)) {
          throw new Error(`Domain ${urlObj.hostname} is not allowed`);
        }
        
        const requestId = `request-${Date.now()}`;
        sandbox.networkRequests.add(requestId);
        
        try {
          const response = await fetch(url, options);
          return response;
        } finally {
          sandbox.networkRequests.delete(requestId);
        }
      };
    }
    
    // 创建受限的DOM访问
    if (sandbox.config.allowDOMAccess) {
      // 创建受限的document对象
      sandboxGlobal.document = {};
      
      // 添加允许的DOM方法
      for (const method of this.domWhitelist) {
        if (sandbox.config.allowedDOMMethods.length === 0 || sandbox.config.allowedDOMMethods.includes(method)) {
          const [objName, methodName] = method.split('.');
          
          if (objName === 'document') {
            sandboxGlobal.document[methodName] = (...args) => {
              // 拦截DOM操作
              return this.interceptDOMOperation(sandbox, 'document', methodName, args);
            };
          } else if (objName === 'element') {
            // 这里需要更复杂的处理，因为element是变量
            // 在实际使用中，需要包装DOM元素对象
          }
        }
      }
    }
    
    // 保存沙箱全局对象
    sandbox.globals = sandboxGlobal;
  }

  // 拦截DOM操作
  interceptDOMOperation(sandbox, objectName, methodName, args) {
    console.log(`DOM operation intercepted: ${objectName}.${methodName}`, args);
    
    // 这里可以添加额外的安全检查和日志记录
    
    // 执行原始操作
    if (objectName === 'document') {
      return document[methodName](...args);
    }
    
    return null;
  }

  // 在沙箱中执行代码
  executeCode(sandboxId, code) {
    const sandbox = this.sandboxes.get(sandboxId);
    if (!sandbox) {
      throw new Error(`Sandbox not found: ${sandboxId}`);
    }
    
    if (sandbox.isDestroyed) {
      throw new Error(`Sandbox is destroyed: ${sandboxId}`);
    }
    
    // 创建执行函数
    const executeFunction = new Function(...Object.keys(sandbox.globals), code);
    
    // 设置超时
    const timeoutId = setTimeout(() => {
      throw new Error(`Code execution timeout in sandbox ${sandboxId}`);
    }, sandbox.config.timeout);
    
    try {
      // 在沙箱环境中执行代码
      const result = executeFunction(...Object.values(sandbox.globals));
      
      // 检查内存使用
      this.checkMemoryUsage(sandbox);
      
      return result;
    } catch (error) {
      console.error(`Error executing code in sandbox ${sandboxId}:`, error);
      throw error;
    } finally {
      clearTimeout(timeoutId);
    }
  }

  // 检查内存使用
  checkMemoryUsage(sandbox) {
    // 这里应该实现实际的内存使用检查
    // 在浏览器环境中，这比较困难，可以使用performance.memory API（仅Chrome）
    
    if (window.performance && window.performance.memory) {
      const memoryInfo = window.performance.memory;
      
      // 简单的内存使用估算
      const memoryUsage = memoryInfo.usedJSHeapSize;
      
      if (memoryUsage > sandbox.config.memoryLimit) {
        throw new Error(`Memory limit exceeded in sandbox ${sandbox.id}: ${memoryUsage} bytes`);
      }
      
      sandbox.memoryUsage = memoryUsage;
    }
  }

  // 销毁沙箱
  destroySandbox(sandboxId) {
    const sandbox = this.sandboxes.get(sandboxId);
    if (!sandbox) {
      return;
    }
    
    // 清除所有定时器
    for (const timerId of sandbox.timers) {
      clearTimeout(timerId);
      clearInterval(timerId);
    }
    
    // 取消所有网络请求
    // 在浏览器环境中，这比较困难，因为fetch API没有提供取消方法
    // 可以使用AbortController来取消fetch请求
    
    // 移除所有DOM节点
    for (const node of sandbox.domNodes) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }
    
    // 标记为已销毁
    sandbox.isDestroyed = true;
    
    // 从沙箱列表中移除
    this.sandboxes.delete(sandboxId);
    
    console.log(`Sandbox destroyed: ${sandboxId}`);
  }

  // 获取沙箱信息
  getSandboxInfo(sandboxId) {
    const sandbox = this.sandboxes.get(sandboxId);
    if (!sandbox) {
      return null;
    }
    
    return {
      id: sandbox.id,
      appName: sandbox.appName,
      config: sandbox.config,
      memoryUsage: sandbox.memoryUsage,
      isDestroyed: sandbox.isDestroyed,
      timersCount: sandbox.timers.size,
      networkRequestsCount: sandbox.networkRequests.size,
      domNodesCount: sandbox.domNodes.size,
    };
  }

  // 获取所有沙箱信息
  getAllSandboxInfo() {
    const sandboxInfo = [];
    
    for (const sandboxId of this.sandboxes.keys()) {
      sandboxInfo.push(this.getSandboxInfo(sandboxId));
    }
    
    return sandboxInfo;
  }

  // 清理所有沙箱
  cleanupAllSandboxes() {
    for (const sandboxId of Array.from(this.sandboxes.keys())) {
      this.destroySandbox(sandboxId);
    }
    
    console.log('All sandboxes cleaned up');
  }
}

// 导出单例
export const codeSandbox = new CodeSandbox();
```

## 14.4 依赖安全

### 14.4.1 依赖扫描与漏洞检测

```javascript
// 示例：依赖扫描与漏洞检测
class DependencyScanner {
  constructor() {
    this.dependencies = new Map(); // name -> version -> info
    this.vulnerabilities = new Map(); // cveId -> vulnerability
    this.scanResults = new Map(); // dependencyId -> scanResult
    this.scanInProgress = false;
  }

  // 初始化依赖扫描器
  initialize(config = {}) {
    this.config = {
      vulnerabilityDatabaseEndpoint: '/api/vulnerabilities',
      scanInterval: 24 * 60 * 60 * 1000, // 24小时
      severityThreshold: 'medium', // medium, high, critical
      ...config,
    };
    
    console.log('Dependency scanner initialized');
  }

  // 添加依赖
  addDependency(name, version, info = {}) {
    if (!this.dependencies.has(name)) {
      this.dependencies.set(name, new Map());
    }
    
    const versions = this.dependencies.get(name);
    versions.set(version, {
      name,
      version,
      type: info.type || 'unknown', // npm, cdn, etc.
      source: info.source || '',
      integrity: info.integrity || '',
      addedAt: new Date(),
      ...info,
    });
    
    console.log(`Dependency added: ${name}@${version}`);
  }

  // 移除依赖
  removeDependency(name, version) {
    if (!this.dependencies.has(name)) {
      return false;
    }
    
    const versions = this.dependencies.get(name);
    const removed = versions.delete(version);
    
    if (versions.size === 0) {
      this.dependencies.delete(name);
    }
    
    if (removed) {
      console.log(`Dependency removed: ${name}@${version}`);
    }
    
    return removed;
  }

  // 获取所有依赖
  getAllDependencies() {
    const allDeps = [];
    
    for (const [name, versions] of this.dependencies) {
      for (const [version, info] of versions) {
        allDeps.push(info);
      }
    }
    
    return allDeps;
  }

  // 扫描依赖漏洞
  async scanDependencies() {
    if (this.scanInProgress) {
      throw new Error('Scan already in progress');
    }
    
    this.scanInProgress = true;
    
    try {
      // 加载漏洞数据库
      await this.loadVulnerabilityDatabase();
      
      // 扫描每个依赖
      const scanResults = [];
      
      for (const [name, versions] of this.dependencies) {
        for (const [version, info] of versions) {
          const result = await this.scanDependency(name, version);
          scanResults.push(result);
          
          // 保存扫描结果
          const dependencyId = `${name}@${version}`;
          this.scanResults.set(dependencyId, result);
        }
      }
      
      // 生成扫描报告
      const report = this.generateScanReport(scanResults);
      
      console.log('Dependency scan completed');
      
      return report;
    } finally {
      this.scanInProgress = false;
    }
  }

  // 加载漏洞数据库
  async loadVulnerabilityDatabase() {
    try {
      const response = await fetch(this.config.vulnerabilityDatabaseEndpoint);
      
      if (!response.ok) {
        throw new Error(`Failed to load vulnerability database: ${response.status}`);
      }
      
      const data = await response.json();
      
      // 更新漏洞数据库
      this.vulnerabilities.clear();
      
      for (const vulnerability of data.vulnerabilities) {
        this.vulnerabilities.set(vulnerability.cveId, vulnerability);
      }
      
      console.log(`Loaded ${this.vulnerabilities.size} vulnerabilities`);
    } catch (error) {
      console.error('Failed to load vulnerability database:', error);
      throw error;
    }
  }

  // 扫描单个依赖
  async scanDependency(name, version) {
    const vulnerabilities = [];
    
    // 查找与该依赖相关的漏洞
    for (const [cveId, vulnerability] of this.vulnerabilities) {
      if (this.isDependencyAffected(vulnerability, name, version)) {
        vulnerabilities.push({
          cveId,
          severity: vulnerability.severity,
          title: vulnerability.title,
          description: vulnerability.description,
          patchedVersions: vulnerability.patchedVersions || [],
          recommendation: vulnerability.recommendation || '',
          references: vulnerability.references || [],
        });
      }
    }
    
    // 按严重程度排序
    vulnerabilities.sort((a, b) => {
      const severityOrder = { low: 0, medium: 1, high: 2, critical: 3 };
      return severityOrder[b.severity] - severityOrder[a.severity];
    });
    
    // 计算风险评分
    const riskScore = this.calculateRiskScore(vulnerabilities);
    
    return {
      name,
      version,
      vulnerabilities,
      riskScore,
      scanTime: new Date(),
    };
  }

  // 检查依赖是否受漏洞影响
  isDependencyAffected(vulnerability, name, version) {
    // 检查依赖名称是否匹配
    if (vulnerability.package !== name) {
      return false;
    }
    
    // 检查版本是否在受影响范围内
    if (!vulnerability.affectedVersions) {
      return false;
    }
    
    for (const range of vulnerability.affectedVersions) {
      if (this.isVersionInRange(version, range)) {
        return true;
      }
    }
    
    return false;
  }

  // 检查版本是否在范围内
  isVersionInRange(version, range) {
    // 这里应该实现语义版本比较
    // 简化实现，实际应该使用semver库
    
    if (range === '*') {
      return true;
    }
    
    if (range === version) {
      return true;
    }
    
    // 处理范围表达式，如 ">=1.0.0 <2.0.0"
    if (range.includes(' ')) {
      const parts = range.split(' ');
      for (let i = 0; i < parts.length; i += 2) {
        const operator = parts[i];
        const rangeVersion = parts[i + 1];
        
        if (!this.compareVersions(version, operator, rangeVersion)) {
          return false;
        }
      }
      return true;
    }
    
    // 处理简单比较表达式，如 ">=1.0.0"
    const match = range.match(/^([<>=!]+)(.+)$/);
    if (match) {
      const operator = match[1];
      const rangeVersion = match[2];
      return this.compareVersions(version, operator, rangeVersion);
    }
    
    return false;
  }

  // 比较版本
  compareVersions(version1, operator, version2) {
    // 简化的版本比较，实际应该使用semver库
    const v1Parts = version1.split('.').map(Number);
    const v2Parts = version2.split('.').map(Number);
    
    // 补齐版本号
    const maxLength = Math.max(v1Parts.length, v2Parts.length);
    for (let i = v1Parts.length; i < maxLength; i++) {
      v1Parts.push(0);
    }
    for (let i = v2Parts.length; i < maxLength; i++) {
      v2Parts.push(0);
    }
    
    // 比较每个部分
    for (let i = 0; i < maxLength; i++) {
      if (v1Parts[i] < v2Parts[i]) {
        return operator === '<' || operator === '<=' || operator === '!=';
      } else if (v1Parts[i] > v2Parts[i]) {
        return operator === '>' || operator === '>=' || operator === '!=';
      }
    }
    
    // 版本相等
    return operator === '==' || operator === '>=' || operator === '<=';
  }

  // 计算风险评分
  calculateRiskScore(vulnerabilities) {
    if (vulnerabilities.length === 0) {
      return 0;
    }
    
    const severityWeights = {
      low: 1,
      medium: 3,
      high: 7,
      critical: 10,
    };
    
    let totalScore = 0;
    
    for (const vuln of vulnerabilities) {
      totalScore += severityWeights[vuln.severity] || 0;
    }
    
    // 归一化到0-10的范围
    return Math.min(10, totalScore / vulnerabilities.length);
  }

  // 生成扫描报告
  generateScanReport(scanResults) {
    const totalDependencies = scanResults.length;
    const vulnerableDependencies = scanResults.filter(result => result.vulnerabilities.length > 0);
    const criticalVulnerabilities = [];
    const highVulnerabilities = [];
    const mediumVulnerabilities = [];
    const lowVulnerabilities = [];
    
    for (const result of scanResults) {
      for (const vuln of result.vulnerabilities) {
        switch (vuln.severity) {
          case 'critical':
            criticalVulnerabilities.push({ ...vuln, dependency: `${result.name}@${result.version}` });
            break;
          case 'high':
            highVulnerabilities.push({ ...vuln, dependency: `${result.name}@${result.version}` });
            break;
          case 'medium':
            mediumVulnerabilities.push({ ...vuln, dependency: `${result.name}@${result.version}` });
            break;
          case 'low':
            lowVulnerabilities.push({ ...vuln, dependency: `${result.name}@${result.version}` });
            break;
        }
      }
    }
    
    // 计算总体风险评分
    const totalRiskScore = scanResults.reduce((sum, result) => sum + result.riskScore, 0) / totalDependencies;
    
    return {
      scanTime: new Date(),
      totalDependencies,
      vulnerableDependencies: vulnerableDependencies.length,
      vulnerabilitiesBySeverity: {
        critical: criticalVulnerabilities.length,
        high: highVulnerabilities.length,
        medium: mediumVulnerabilities.length,
        low: lowVulnerabilities.length,
      },
      totalRiskScore,
      criticalVulnerabilities,
      highVulnerabilities,
      mediumVulnerabilities,
      lowVulnerabilities,
      recommendations: this.generateRecommendations(scanResults),
    };
  }

  // 生成修复建议
  generateRecommendations(scanResults) {
    const recommendations = [];
    
    // 按风险评分排序
    const sortedResults = scanResults.sort((a, b) => b.riskScore - a.riskScore);
    
    // 为高风险依赖生成建议
    for (const result of sortedResults) {
      if (result.riskScore >= 7) { // 高风险
        const criticalVulns = result.vulnerabilities.filter(v => v.severity === 'critical');
        const highVulns = result.vulnerabilities.filter(v => v.severity === 'high');
        
        if (criticalVulns.length > 0 || highVulns.length > 0) {
          recommendations.push({
            dependency: `${result.name}@${result.version}`,
            riskScore: result.riskScore,
            action: 'update',
            reason: `Contains ${criticalVulns.length} critical and ${highVulns.length} high severity vulnerabilities`,
            suggestedVersions: this.getSuggestedVersions(result.name, result.vulnerabilities),
          });
        }
      }
    }
    
    return recommendations;
  }

  // 获取建议版本
  getSuggestedVersions(name, vulnerabilities) {
    const suggestedVersions = new Set();
    
    for (const vuln of vulnerabilities) {
      if (vuln.patchedVersions && vuln.patchedVersions.length > 0) {
        for (const version of vuln.patchedVersions) {
          suggestedVersions.add(version);
        }
      }
    }
    
    return Array.from(suggestedVersions);
  }

  // 从package.json加载依赖
  loadFromPackageJson(packageJsonContent) {
    try {
      const packageJson = JSON.parse(packageJsonContent);
      
      // 加载dependencies
      if (packageJson.dependencies) {
        for (const [name, version] of Object.entries(packageJson.dependencies)) {
          this.addDependency(name, version, {
            type: 'npm',
            source: 'package.json',
          });
        }
      }
      
      // 加载devDependencies
      if (packageJson.devDependencies) {
        for (const [name, version] of Object.entries(packageJson.devDependencies)) {
          this.addDependency(name, version, {
            type: 'npm',
            source: 'package.json',
            isDevDependency: true,
          });
        }
      }
      
      console.log('Dependencies loaded from package.json');
    } catch (error) {
      console.error('Failed to load dependencies from package.json:', error);
      throw error;
    }
  }

  // 从HTML加载CDN依赖
  loadFromHtml(htmlContent) {
    try {
      // 创建临时DOM元素
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = htmlContent;
      
      // 查找script标签
      const scripts = tempDiv.querySelectorAll('script[src]');
      for (const script of scripts) {
        const src = script.getAttribute('src');
        const url = new URL(src, window.location.origin);
        
        // 尝试从URL中提取库名和版本
        const match = url.pathname.match(/\/([^\/]+)\/([^\/]+)\/([^\/]+)\.(js|css)$/);
        if (match) {
          const [, , name, version] = match;
          this.addDependency(name, version, {
            type: 'cdn',
            source: src,
            integrity: script.getAttribute('integrity') || '',
          });
        }
      }
      
      // 查找link标签
      const links = tempDiv.querySelectorAll('link[href]');
      for (const link of links) {
        const href = link.getAttribute('href');
        const url = new URL(href, window.location.origin);
        
        // 尝试从URL中提取库名和版本
        const match = url.pathname.match(/\/([^\/]+)\/([^\/]+)\/([^\/]+)\.(js|css)$/);
        if (match) {
          const [, , name, version] = match;
          this.addDependency(name, version, {
            type: 'cdn',
            source: href,
            integrity: link.getAttribute('integrity') || '',
          });
        }
      }
      
      console.log('Dependencies loaded from HTML');
    } catch (error) {
      console.error('Failed to load dependencies from HTML:', error);
      throw error;
    }
  }

  // 获取扫描结果
  getScanResult(dependencyId) {
    return this.scanResults.get(dependencyId);
  }

  // 获取所有扫描结果
  getAllScanResults() {
    return Array.from(this.scanResults.entries()).map(([dependencyId, result]) => ({
      dependencyId,
      ...result,
    }));
  }

  // 清除扫描结果
  clearScanResults() {
    this.scanResults.clear();
    console.log('Scan results cleared');
  }
}

// 导出单例
export const dependencyScanner = new DependencyScanner();
```

## 14.5 安全最佳实践

### 14.5.1 安全编码规范

1. **输入验证**
   - 严格验证所有用户输入
   - 使用白名单而非黑名单
   - 防止SQL注入和XSS攻击
   - 验证文件上传类型和大小

2. **输出编码**
   - 对所有输出进行适当编码
   - 根据上下文选择正确的编码方式
   - 防止HTML、JavaScript和URL注入
   - 使用安全的模板引擎

3. **身份认证与授权**
   - 实施强密码策略
   - 使用多因素认证
   - 实施最小权限原则
   - 定期审查权限设置

4. **会话管理**
   - 使用安全的会话标识符
   - 设置合理的会话超时
   - 实施会话固定防护
   - 安全地终止会话

### 14.5.2 安全检查清单

1. **代码审查**
   - 定期进行安全代码审查
   - 使用自动化安全扫描工具
   - 检查常见安全漏洞
   - 验证第三方库安全性

2. **渗透测试**
   - 定期进行渗透测试
   - 测试所有应用接口
   - 验证访问控制机制
   - 检查数据泄露风险

3. **安全监控**
   - 实施实时安全监控
   - 记录所有安全相关事件
   - 设置安全事件告警
   - 定期分析安全日志

4. **应急响应**
   - 制定安全事件响应计划
   - 建立安全事件处理流程
   - 定期进行应急演练
   - 及时更新安全补丁

## 14.6 总结

微前端安全实践是确保微前端架构安全可靠运行的重要保障。本章介绍了：

1. **身份认证与授权**：通过统一身份认证服务和权限控制系统，实现安全的用户管理和访问控制。

2. **代码安全**：通过内容安全策略和代码沙箱隔离，防止代码注入和恶意代码执行。

3. **依赖安全**：通过依赖扫描和漏洞检测，及时发现和修复第三方库的安全问题。

4. **安全最佳实践**：提供安全编码规范和安全检查清单，帮助开发团队建立完善的安全体系。

通过合理的安全策略和实践，可以有效降低微前端架构的安全风险，保护系统和用户数据的安全。

## 14.7 示例代码

### 14.7.1 文件结构

```
micro-frontend-security/
├── auth/
│   ├── UnifiedAuthService.js     # 统一身份认证服务
│   ├── PermissionSystem.js       # 权限控制系统
│   └── SSOManager.js             # 单点登录管理
├── code-security/
│   ├── ContentSecurityPolicy.js  # 内容安全策略
│   ├── CodeSandbox.js            # 代码沙箱隔离
│   └── InputValidator.js         # 输入验证
├── dependency-security/
│   ├── DependencyScanner.js      # 依赖扫描器
│   ├── VulnerabilityDetector.js  # 漏洞检测
│   └── SecureLoader.js           # 安全加载器
├── monitoring/
│   ├── SecurityMonitor.js        # 安全监控
│   ├── ThreatDetector.js         # 威胁检测
│   └── AuditLogger.js            # 审计日志
└── integration/
    ├── SecurityMiddleware.js      # 安全中间件
    ├── AuthGuard.js              # 认证守卫
    └── SecurityDashboard.js      # 安全仪表板
```

### 14.7.2 运行说明

1. **安装依赖**
   ```bash
   npm install
   ```

2. **初始化安全系统**
   ```javascript
   import { unifiedAuthService, permissionSystem, contentSecurityPolicy, codeSandbox, dependencyScanner } from './security';
   
   // 初始化认证服务
   unifiedAuthService.initialize();
   
   // 初始化权限系统
   permissionSystem.initialize();
   
   // 初始化内容安全策略
   contentSecurityPolicy.initialize({
     scriptSrc: ["'self'", "'unsafe-inline'"],
     connectSrc: ["'self'", 'https://api.example.com'],
   });
   
   // 初始化代码沙箱
   const sandboxId = codeSandbox.createSandbox('app1', {
     allowNetworkRequests: true,
     allowedDomains: ['api.example.com'],
     allowDOMAccess: true,
   });
   
   // 初始化依赖扫描器
   dependencyScanner.initialize();
   ```

3. **加载依赖**
   ```javascript
   // 从package.json加载依赖
   dependencyScanner.loadFromPackageJson(packageJsonContent);
   
   // 从HTML加载CDN依赖
   dependencyScanner.loadFromHtml(htmlContent);
   
   // 扫描依赖漏洞
   const scanReport = await dependencyScanner.scanDependencies();
   console.log('Scan report:', scanReport);
   ```

4. **用户认证与授权**
   ```javascript
   // 用户登录
   const user = await unifiedAuthService.login({
     username: 'user1',
     password: 'password123',
   });
   
   // 检查权限
   const hasPermission = permissionSystem.hasPermission(user.id, 'admin-panel');
   
   // 创建权限守卫
   const AdminPanel = permissionSystem.withPermission('admin-panel')(AdminPanelComponent);
   ```

### 14.7.3 功能演示

1. **身份认证演示**
   - 用户登录/登出
   - 令牌自动刷新
   - 会话管理

2. **权限控制演示**
   - 角色权限分配
   - 权限检查
   - 权限装饰器使用

3. **代码安全演示**
   - CSP策略配置
   - 代码沙箱执行
   - 安全事件监控

4. **依赖安全演示**
   - 依赖扫描
   - 漏洞检测
   - 安全报告生成

通过本章的学习，读者应该能够构建完整的微前端安全体系，有效防范各种安全威胁，保障微前端应用的安全稳定运行。