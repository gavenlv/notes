# 第二章：微前端架构设计

## 2.1 微前端设计原则

### 2.1.1 单一职责原则

单一职责原则（Single Responsibility Principle）是微前端架构设计的核心原则之一。它要求每个微前端应用只负责一个特定的业务领域或功能模块，保持应用的内聚性和独立性。

**原则内涵：：**

1. **业务边界清晰**：每个微前端应用有明确的业务边界，不跨越业务领域。

2. **功能专注**：每个微前端应用专注于特定的业务功能，不承担无关职责。

3. **接口明确**：每个微前端应用提供明确的接口，隐藏内部实现细节。

4. **变更隔离**：一个微前端应用的变更不会影响其他应用。

**实践方法：：**

1. **业务领域划分**：根据业务领域进行应用划分，确保每个应用对应一个业务领域。

2. **功能边界定义**：明确定义每个应用的功能边界，避免功能重叠和交叉。

3. **接口设计**：设计清晰的应用接口，定义输入输出规范。

4. **依赖管理**：管理应用间的依赖关系，避免循环依赖和过度依赖。

**示例代码：：**

```javascript
// 用户管理微前端应用
class UserManagementApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.userService = options.userService;
  }
  
  // 用户列表功能
  showUserList() {
    // 实现用户列表展示
  }
  
  // 用户详情功能
  showUserDetail(userId) {
    // 实现用户详情展示
  }
  
  // 用户编辑功能
  editUser(userId) {
    // 实现用户编辑
  }
  
  // 不应该包含订单相关功能
  // showOrderList() { ... } // 违反单一职责原则
}

// 订单管理微前端应用
class OrderManagementApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.orderService = options.orderService;
  }
  
  // 订单列表功能
  showOrderList() {
    // 实现订单列表展示
  }
  
  // 订单详情功能
  showOrderDetail(orderId) {
    // 实现订单详情展示
  }
  
  // 订单编辑功能
  editOrder(orderId) {
    // 实现订单编辑
  }
  
  // 不应该包含用户管理功能
  // editUser(userId) { ... } // 违反单一职责原则
}
```

### 2.1.2 自治性原则

自治性原则（Autonomy Principle）强调每个微前端应用应该是自治的，能够独立开发、测试、部署和运行，不依赖于其他应用。

**原则内涵：：**

1. **独立开发**：每个微前端应用可以独立开发，不依赖其他应用的开发进度。

2. **独立测试**：每个微前端应用可以独立测试，不依赖其他应用的测试状态。

3. **独立部署**：每个微前端应用可以独立部署，不依赖其他应用的部署状态。

4. **独立运行**：每个微前端应用可以独立运行，不依赖其他应用的运行状态。

**实践方法：：**

1. **技术栈独立**：每个微前端应用可以选择自己的技术栈，不强制统一。

2. **数据存储独立**：每个微前端应用有自己的数据存储，不共享数据存储。

3. **配置独立**：每个微前端应用有自己的配置，不依赖其他应用的配置。

4. **错误隔离**：一个微前端应用的错误不会影响其他应用的运行。

**示例代码：：**

```javascript
// 微前端应用基类
class BaseMicroApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.config = options.config || {};
    this.state = 'unloaded';
  }
  
  // 加载应用
  async load() {
    if (this.state !== 'unloaded') return;
    
    try {
      // 加载应用资源
      await this.loadResources();
      
      // 初始化应用
      await this.init();
      
      this.state = 'loaded';
    } catch (error) {
      this.state = 'error';
      throw error;
    }
  }
  
  // 挂载应用
  async mount() {
    if (this.state !== 'loaded') return;
    
    try {
      // 渲染应用
      await this.render();
      
      // 绑定事件
      this.bindEvents();
      
      this.state = 'mounted';
    } catch (error) {
      this.state = 'error';
      throw error;
    }
  }
  
  // 卸载应用
  async unmount() {
    if (this.state !== 'mounted') return;
    
    try {
      // 解绑事件
      this.unbindEvents();
      
      // 清理DOM
      this.cleanup();
      
      this.state = 'loaded';
    } catch (error) {
      this.state = 'error';
      throw error;
    }
  }
  
  // 子类实现
  async loadResources() {
    throw new Error('loadResources method must be implemented');
  }
  
  async init() {
    throw new Error('init method must be implemented');
  }
  
  async render() {
    throw new Error('render method must be implemented');
  }
  
  bindEvents() {
    // 子类实现
  }
  
  unbindEvents() {
    // 子类实现
  }
  
  cleanup() {
    // 清理DOM
    this.container.innerHTML = '';
  }
}

// 具体应用实现
class DashboardApp extends BaseMicroApp {
  async loadResources() {
    // 加载应用资源
    await this.loadStyles('/apps/dashboard/styles.css');
    await this.loadScripts('/apps/dashboard/bundle.js');
  }
  
  async init() {
    // 初始化应用
    this.data = await this.fetchDashboardData();
  }
  
  async render() {
    // 渲染应用
    this.container.innerHTML = this.getDashboardHTML(this.data);
  }
  
  bindEvents() {
    // 绑定事件
    this.container.addEventListener('click', this.handleClick.bind(this));
  }
  
  unbindEvents() {
    // 解绑事件
    this.container.removeEventListener('click', this.handleClick.bind(this));
  }
  
  async fetchDashboardData() {
    // 获取仪表板数据
    const response = await fetch('/api/dashboard');
    return response.json();
  }
  
  getDashboardHTML(data) {
    // 生成仪表板HTML
    return `
      <div class="dashboard">
        <h1>Dashboard</h1>
        <div class="widgets">
          ${data.widgets.map(widget => `
            <div class="widget">
              <h2>${widget.title}</h2>
              <div class="content">${widget.content}</div>
            </div>
          `).join('')}
        </div>
      </div>
    `;
  }
  
  handleClick(event) {
    // 处理点击事件
    const target = event.target;
    
    if (target.classList.contains('widget')) {
      // 处理小部件点击
      const widgetId = target.dataset.widgetId;
      this.handleWidgetClick(widgetId);
    }
  }
  
  handleWidgetClick(widgetId) {
    // 处理小部件点击
    this.eventBus.emit('widget:click', { widgetId });
  }
  
  async loadStyles(url) {
    return new Promise((resolve, reject) => {
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = url;
      link.onload = resolve;
      link.onerror = reject;
      document.head.appendChild(link);
    });
  }
  
  async loadScripts(url) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.onload = resolve;
      script.onerror = reject;
      document.body.appendChild(script);
    });
  }
}

// 使用示例
const dashboardApp = new DashboardApp({
  container: document.querySelector('#dashboard-container'),
  eventBus: new EventBus(),
  config: {
    apiEndpoint: '/api/dashboard',
    refreshInterval: 30000,
  },
});

// 独立加载和挂载应用
dashboardApp.load().then(() => {
  dashboardApp.mount();
});
```

### 2.1.3 技术无关性原则

技术无关性原则（Technology Agnostic Principle）允许每个微前端应用选择最适合自身业务需求的技术栈，而不强制所有应用使用相同的技术栈。

**原则内涵：：**

1. **技术栈自由**：每个微前端应用可以选择自己的技术栈，如React、Vue、Angular等。

2. **构建工具自由**：每个微前端应用可以选择自己的构建工具，如Webpack、Rollup、Vite等。

3. **状态管理自由**：每个微前端应用可以选择自己的状态管理方案，如Redux、Vuex、MobX等。

4. **样式方案自由**：每个微前端应用可以选择自己的样式方案，如CSS Modules、Styled Components等。

**实践方法：：**

1. **标准化接口**：定义标准化的应用接口，屏蔽技术栈差异。

2. **适配器模式**：使用适配器模式，将不同技术栈的应用适配到统一的接口。

3. **沙箱隔离**：使用沙箱机制，隔离不同技术栈的运行环境。

4. **协议标准化**：定义标准化的通信协议，支持不同技术栈的应用间通信。

**示例代码：：**

```javascript
// 应用适配器接口
class AppAdapter {
  constructor(appConfig) {
    this.config = appConfig;
  }
  
  // 加载应用
  async load() {
    throw new Error('load method must be implemented');
  }
  
  // 挂载应用
  async mount() {
    throw new Error('mount method must be implemented');
  }
  
  // 卸载应用
  async unmount() {
    throw new Error('unmount method must be implemented');
  }
  
  // 获取应用信息
  getInfo() {
    return {
      name: this.config.name,
      version: this.config.version,
      framework: this.config.framework,
    };
  }
}

// React应用适配器
class ReactAppAdapter extends AppAdapter {
  async load() {
    // 动态导入React应用
    const { createRoot } = await import('react-dom/client');
    const App = await import(this.config.entry);
    
    this.createRoot = createRoot;
    this.App = App.default;
  }
  
  async mount() {
    // 创建React根节点
    this.root = this.createRoot(this.config.container);
    
    // 渲染React应用
    this.root.render(this.App(this.config.props));
  }
  
  async unmount() {
    // 卸载React应用
    if (this.root) {
      this.root.unmount();
      this.root = null;
    }
  }
}

// Vue应用适配器
class VueAppAdapter extends AppAdapter {
  async load() {
    // 动态导入Vue应用
    const { createApp } = await import('vue');
    const App = await import(this.config.entry);
    
    this.createApp = createApp;
    this.App = App.default;
  }
  
  async mount() {
    // 创建Vue应用实例
    this.app = this.createApp(this.App, this.config.props);
    
    // 挂载Vue应用
    this.app.mount(this.config.container);
  }
  
  async unmount() {
    // 卸载Vue应用
    if (this.app) {
      this.app.unmount();
      this.app = null;
    }
  }
}

// Angular应用适配器
class AngularAppAdapter extends AppAdapter {
  async load() {
    // 动态导入Angular应用
    const { platformBrowserDynamic } = await import('@angular/platform-browser-dynamic');
    const AppModule = await import(this.config.entry);
    
    this.platformBrowserDynamic = platformBrowserDynamic;
    this.AppModule = AppModule.default;
  }
  
  async mount() {
    // 启动Angular应用
    this.moduleRef = await this.platformBrowserDynamic()
      .bootstrapModule(this.AppModule);
    
    // 获取应用根组件
    this.appRef = this.moduleRef.injector.get(ApplicationRef);
  }
  
  async unmount() {
    // 销毁Angular应用
    if (this.moduleRef) {
      this.moduleRef.destroy();
      this.moduleRef = null;
      this.appRef = null;
    }
  }
}

// 应用适配器工厂
class AppAdapterFactory {
  static create(appConfig) {
    switch (appConfig.framework) {
      case 'react':
        return new ReactAppAdapter(appConfig);
      case 'vue':
        return new VueAppAdapter(appConfig);
      case 'angular':
        return new AngularAppAdapter(appConfig);
      default:
        throw new Error(`Unsupported framework: ${appConfig.framework}`);
    }
  }
}

// 使用示例
const reactAppConfig = {
  name: 'dashboard',
  version: '1.0.0',
  framework: 'react',
  entry: '/apps/dashboard/index.js',
  container: document.querySelector('#dashboard-container'),
  props: {
    userId: 123,
  },
};

const vueAppConfig = {
  name: 'user-profile',
  version: '1.0.0',
  framework: 'vue',
  entry: '/apps/user-profile/index.js',
  container: document.querySelector('#user-profile-container'),
  props: {
    userId: 123,
  },
};

// 创建应用适配器
const reactApp = AppAdapterFactory.create(reactAppConfig);
const vueApp = AppAdapterFactory.create(vueAppConfig);

// 加载和挂载应用
reactApp.load().then(() => reactApp.mount());
vueApp.load().then(() => vueApp.mount());
```

### 2.1.4 隔离性原则

隔离性原则（Isolation Principle）强调微前端应用之间应该相互隔离，避免相互干扰和影响。

**原则内涵：：**

1. **运行时隔离**：微前端应用在运行时相互隔离，避免全局变量污染、样式冲突等问题。

2. **样式隔离**：微前端应用的样式相互隔离，避免样式冲突和覆盖。

3. **事件隔离**：微前端应用的事件相互隔离，避免事件冲突和意外触发。

4. **错误隔离**：微前端应用的错误相互隔离，避免一个应用的错误影响其他应用。

**实践方法：：**

1. **沙箱机制**：使用沙箱机制，隔离微前端应用的运行环境。

2. **样式作用域**：使用样式作用域技术，如CSS Modules、Shadow DOM等，隔离样式。

3. **事件命名空间**：使用事件命名空间，避免事件冲突。

4. **错误边界**：使用错误边界，捕获和处理应用内的错误，防止错误传播。

**示例代码：：**

```javascript
// 沙箱管理器
class SandboxManager {
  constructor() {
    this.sandboxes = new Map();
  }
  
  // 创建沙箱
  createSandbox(name, options = {}) {
    const sandbox = new Sandbox(name, options);
    this.sandboxes.set(name, sandbox);
    return sandbox;
  }
  
  // 获取沙箱
  getSandbox(name) {
    return this.sandboxes.get(name);
  }
  
  // 销毁沙箱
  destroySandbox(name) {
    const sandbox = this.sandboxes.get(name);
    if (sandbox) {
      sandbox.destroy();
      this.sandboxes.delete(name);
    }
  }
}

// 沙箱类
class Sandbox {
  constructor(name, options = {}) {
    this.name = name;
    this.options = options;
    this.active = false;
    this.globalVariables = new Map();
    this.originalWindow = {};
    this.proxyWindow = null;
    this.styleElements = [];
    this.eventListeners = [];
  }
  
  // 激活沙箱
  activate() {
    if (this.active) return;
    
    // 保存原始全局变量
    this.saveOriginalWindow();
    
    // 创建代理Window对象
    this.createProxyWindow();
    
    // 激活样式隔离
    this.activateStyleIsolation();
    
    // 激活事件隔离
    this.activateEventIsolation();
    
    this.active = true;
  }
  
  // 停用沙箱
  deactivate() {
    if (!this.active) return;
    
    // 恢复原始全局变量
    this.restoreOriginalWindow();
    
    // 停用样式隔离
    this.deactivateStyleIsolation();
    
    // 停用事件隔离
    this.deactivateEventIsolation();
    
    this.active = false;
  }
  
  // 销毁沙箱
  destroy() {
    this.deactivate();
    this.globalVariables.clear();
    this.originalWindow = {};
    this.proxyWindow = null;
  }
  
  // 保存原始全局变量
  saveOriginalWindow() {
    const properties = [
      'window', 'document', 'location', 'navigator',
      'history', 'localStorage', 'sessionStorage',
      'setTimeout', 'setInterval', 'clearTimeout', 'clearInterval',
    ];
    
    for (const prop of properties) {
      this.originalWindow[prop] = window[prop];
    }
  }
  
  // 恢复原始全局变量
  restoreOriginalWindow() {
    for (const [prop, value] of Object.entries(this.originalWindow)) {
      window[prop] = value;
    }
  }
  
  // 创建代理Window对象
  createProxyWindow() {
    this.proxyWindow = new Proxy(window, {
      get: (target, prop) => {
        // 如果是沙箱内的变量，返回沙箱内的值
        if (this.globalVariables.has(prop)) {
          return this.globalVariables.get(prop);
        }
        
        // 否则返回原始Window的值
        return target[prop];
      },
      set: (target, prop, value) => {
        // 设置沙箱内的变量
        this.globalVariables.set(prop, value);
        return true;
      },
      has: (target, prop) => {
        // 检查沙箱内是否有该变量
        if (this.globalVariables.has(prop)) {
          return true;
        }
        
        // 否则检查原始Window是否有该属性
        return prop in target;
      },
      deleteProperty: (target, prop) => {
        // 删除沙箱内的变量
        this.globalVariables.delete(prop);
        return true;
      },
    });
    
    // 将代理Window对象设置为沙箱的全局对象
    // 这里需要根据具体框架实现，例如通过eval或with语句
  }
  
  // 激活样式隔离
  activateStyleIsolation() {
    // 创建Shadow DOM容器
    if (this.options.shadowDOM) {
      this.shadowHost = document.createElement('div');
      this.shadowRoot = this.shadowHost.attachShadow({ mode: 'open' });
      
      // 将应用容器移到Shadow DOM中
      const appContainer = document.querySelector(this.options.container);
      if (appContainer) {
        this.shadowRoot.appendChild(appContainer);
      }
    }
    
    // 添加样式前缀
    if (this.options.stylePrefix) {
      this.addStylePrefix();
    }
  }
  
  // 停用样式隔离
  deactivateStyleIsolation() {
    // 移除Shadow DOM容器
    if (this.shadowHost && this.shadowRoot) {
      const appContainer = this.shadowRoot.querySelector(this.options.container);
      if (appContainer) {
        document.body.appendChild(appContainer);
      }
      
      this.shadowHost.remove();
      this.shadowHost = null;
      this.shadowRoot = null;
    }
    
    // 移除样式前缀
    if (this.options.stylePrefix) {
      this.removeStylePrefix();
    }
  }
  
  // 添加样式前缀
  addStylePrefix() {
    const styleElements = document.querySelectorAll('style, link[rel="stylesheet"]');
    
    for (const styleElement of styleElements) {
      // 保存原始样式元素
      this.styleElements.push(styleElement.cloneNode(true));
      
      // 处理样式内容，添加前缀
      if (styleElement.tagName === 'STYLE') {
        const cssText = styleElement.textContent;
        const prefixedCssText = this.prefixCss(cssText, this.options.stylePrefix);
        styleElement.textContent = prefixedCssText;
      }
    }
  }
  
  // 移除样式前缀
  removeStylePrefix() {
    // 恢复原始样式元素
    for (let i = 0; i < this.styleElements.length; i++) {
      const originalElement = this.styleElements[i];
      const currentElement = document.querySelectorAll('style, link[rel="stylesheet"]')[i];
      
      if (currentElement && originalElement) {
        currentElement.parentNode.replaceChild(originalElement, currentElement);
      }
    }
    
    this.styleElements = [];
  }
  
  // 为CSS添加前缀
  prefixCss(cssText, prefix) {
    // 简单的CSS前缀添加实现
    // 实际实现需要更复杂的CSS解析和处理
    return cssText.replace(/([^{}]+){/g, (match, selector) => {
      // 跳过@规则和全局选择器
      if (selector.trim().startsWith('@') || selector.includes(':global')) {
        return match;
      }
      
      // 添加前缀
      const prefixedSelector = selector
        .split(',')
        .map(s => `${prefix} ${s.trim()}`)
        .join(', ');
      
      return `${prefixedSelector}{`;
    });
  }
  
  // 激活事件隔离
  activateEventIsolation() {
    // 保存原始事件监听方法
    this.originalAddEventListener = window.addEventListener;
    this.originalRemoveEventListener = window.removeEventListener;
    
    // 重写事件监听方法，添加命名空间
    window.addEventListener = (type, listener, options) => {
      // 添加命名空间
      const namespacedListener = this.wrapEventListener(listener);
      
      // 保存事件监听器
      this.eventListeners.push({ type, listener: namespacedListener, options });
      
      // 调用原始方法
      return this.originalAddEventListener.call(window, type, namespacedListener, options);
    };
    
    window.removeEventListener = (type, listener, options) => {
      // 查找命名空间的事件监听器
      const namespacedListener = this.findNamespacedListener(listener);
      
      if (namespacedListener) {
        // 调用原始方法
        return this.originalRemoveEventListener.call(window, type, namespacedListener, options);
      }
    };
  }
  
  // 停用事件隔离
  deactivateEventIsolation() {
    // 恢复原始事件监听方法
    window.addEventListener = this.originalAddEventListener;
    window.removeEventListener = this.originalRemoveEventListener;
    
    // 移除所有事件监听器
    for (const { type, listener, options } of this.eventListeners) {
      this.originalRemoveEventListener.call(window, type, listener, options);
    }
    
    this.eventListeners = [];
  }
  
  // 包装事件监听器，添加命名空间
  wrapEventListener(listener) {
    const namespacedListener = (event) => {
      // 添加命名空间信息
      event.sandbox = this.name;
      
      // 调用原始监听器
      return listener.call(this, event);
    };
    
    // 保存原始监听器的引用
    namespacedListener.originalListener = listener;
    
    return namespacedListener;
  }
  
  // 查找命名空间的事件监听器
  findNamespacedListener(originalListener) {
    for (const { listener } of this.eventListeners) {
      if (listener.originalListener === originalListener) {
        return listener;
      }
    }
    
    return null;
  }
}

// 使用示例
const sandboxManager = new SandboxManager();

// 创建沙箱
const appSandbox = sandboxManager.createSandbox('dashboard', {
  container: '#dashboard-container',
  shadowDOM: true,
  stylePrefix: '.dashboard-app',
});

// 激活沙箱
appSandbox.activate();

// 在沙箱中运行应用代码
// 这里需要根据具体框架实现，例如通过eval或with语句
// evalInSandbox(appSandbox, appCode);

// 停用沙箱
appSandbox.deactivate();
```

## 2.2 应用划分策略

### 2.2.1 按业务领域划分

按业务领域划分是微前端应用划分最常用的策略，它根据业务领域的边界来划分微前端应用，确保每个应用专注于特定的业务领域。

**划分原则：：**

1. **业务边界清晰**：每个微前端应用对应一个明确的业务领域，边界清晰。

2. **高内聚低耦合**：应用内部功能高度内聚，应用之间低耦合。

3. **数据一致性**：每个业务领域内的数据保持一致性，跨领域数据通过接口交互。

4. **团队对齐**：应用划分与团队组织结构对齐，每个团队负责一个或多个相关应用。

**实践方法：：**

1. **领域驱动设计**：采用领域驱动设计（DDD）方法，识别业务领域和子域。

2. **限界上下文**：定义限界上下文，明确每个上下文的边界和职责。

3. **事件风暴**：通过事件风暴工作坊，识别业务流程和领域事件。

4. **用户故事映射**：通过用户故事映射，识别功能模块和依赖关系。

**示例场景：：**

以电商平台为例，可以按以下业务领域划分微前端应用：

1. **商品管理**：负责商品信息管理、分类管理、库存管理等。

2. **订单管理**：负责订单创建、支付、发货、退款等。

3. **用户管理**：负责用户注册、登录、个人信息管理等。

4. **购物车**：负责购物车商品添加、删除、数量修改等。

5. **营销活动**：负责优惠券、促销活动、积分等。

**示例代码：：**

```javascript
// 商品管理微前端应用
class ProductManagementApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.productService = options.productService;
  }
  
  // 商品列表
  showProductList() {
    // 实现商品列表展示
  }
  
  // 商品详情
  showProductDetail(productId) {
    // 实现商品详情展示
  }
  
  // 商品编辑
  editProduct(productId) {
    // 实现商品编辑
  }
  
  // 商品分类管理
  manageCategories() {
    // 实现商品分类管理
  }
  
  // 库存管理
  manageInventory() {
    // 实现库存管理
  }
}

// 订单管理微前端应用
class OrderManagementApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.orderService = options.orderService;
  }
  
  // 订单列表
  showOrderList() {
    // 实现订单列表展示
  }
  
  // 订单详情
  showOrderDetail(orderId) {
    // 实现订单详情展示
  }
  
  // 创建订单
  createOrder(orderData) {
    // 实现订单创建
  }
  
  // 支付订单
  payOrder(orderId) {
    // 实现订单支付
  }
  
  // 发货
  shipOrder(orderId) {
    // 实现订单发货
  }
  
  // 退款
  refundOrder(orderId) {
    // 实现订单退款
  }
}

// 用户管理微前端应用
class UserManagementApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.userService = options.userService;
  }
  
  // 用户注册
  register(userData) {
    // 实现用户注册
  }
  
  // 用户登录
  login(credentials) {
    // 实现用户登录
  }
  
  // 用户信息
  showUserProfile(userId) {
    // 实现用户信息展示
  }
  
  // 编辑用户信息
  editUserProfile(userId) {
    // 实现用户信息编辑
  }
  
  // 用户地址管理
  manageAddresses(userId) {
    // 实现用户地址管理
  }
}

// 购物车微前端应用
class ShoppingCartApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.cartService = options.cartService;
  }
  
  // 购物车列表
  showCart() {
    // 实现购物车列表展示
  }
  
  // 添加商品到购物车
  addToCart(productId, quantity) {
    // 实现添加商品到购物车
  }
  
  // 从购物车移除商品
  removeFromCart(productId) {
    // 实现从购物车移除商品
  }
  
  // 修改商品数量
  updateQuantity(productId, quantity) {
    // 实现修改商品数量
  }
  
  // 结算
  checkout() {
    // 实现购物车结算
  }
}

// 营销活动微前端应用
class MarketingApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.marketingService = options.marketingService;
  }
  
  // 优惠券列表
  showCoupons() {
    // 实现优惠券列表展示
  }
  
  // 促销活动列表
  showPromotions() {
    // 实现促销活动列表展示
  }
  
  // 积分兑换
  redeemPoints(pointsData) {
    // 实现积分兑换
  }
  
  // 创建优惠券
  createCoupon(couponData) {
    // 实现创建优惠券
  }
  
  // 创建促销活动
  createPromotion(promotionData) {
    // 实现创建促销活动
  }
}
```

### 2.2.2 按功能模块划分

按功能模块划分是另一种常见的微前端应用划分策略，它根据功能模块的边界来划分微前端应用，每个应用负责特定的功能模块。

**划分原则：：**

1. **功能边界清晰**：每个微前端应用对应一个明确的功能模块，边界清晰。

2. **功能单一**：每个应用专注于单一功能，不承担无关功能。

3. **接口明确**：每个应用提供明确的接口，定义输入输出规范。

4. **复用性高**：功能模块设计考虑复用性，可以在不同场景下复用。

**实践方法：：**

1. **功能分解**：将系统功能分解为多个独立的功能模块。

2. **接口设计**：设计清晰的功能接口，定义模块间的交互方式。

3. **依赖分析**：分析模块间的依赖关系，避免循环依赖。

4. **模块组合**：设计模块组合机制，支持灵活组合不同模块。

**示例场景：：**

以企业管理系统为例，可以按以下功能模块划分微前端应用：

1. **数据表格**：提供通用的数据表格功能，支持排序、筛选、分页等。

2. **表单组件**：提供通用的表单组件，支持验证、提交等。

3. **图表组件**：提供通用的图表组件，支持折线图、柱状图、饼图等。

4. **文件上传**：提供文件上传功能，支持拖拽上传、进度显示等。

5. **通知系统**：提供通知功能，支持消息通知、提醒等。

**示例代码：：**

```javascript
// 数据表格微前端应用
class DataTableApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.config = options.config || {};
  }
  
  // 渲染表格
  render(data, columns) {
    // 实现表格渲染
  }
  
  // 排序
  sort(column, direction) {
    // 实现排序功能
  }
  
  // 筛选
  filter(filters) {
    // 实现筛选功能
  }
  
  // 分页
  paginate(page, pageSize) {
    // 实现分页功能
  }
  
  // 导出数据
  exportData(format) {
    // 实现数据导出功能
  }
}

// 表单组件微前端应用
class FormApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.config = options.config || {};
  }
  
  // 渲染表单
  render(fields) {
    // 实现表单渲染
  }
  
  // 验证表单
  validate() {
    // 实现表单验证
  }
  
  // 提交表单
  submit() {
    // 实现表单提交
  }
  
  // 重置表单
  reset() {
    // 实现表单重置
  }
  
  // 设置字段值
  setFieldValue(fieldName, value) {
    // 实现设置字段值
  }
  
  // 获取字段值
  getFieldValue(fieldName) {
    // 实现获取字段值
  }
}

// 图表组件微前端应用
class ChartApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.config = options.config || {};
  }
  
  // 渲染折线图
  renderLineChart(data, options) {
    // 实现折线图渲染
  }
  
  // 渲染柱状图
  renderBarChart(data, options) {
    // 实现柱状图渲染
  }
  
  // 渲染饼图
  renderPieChart(data, options) {
    // 实现饼图渲染
  }
  
  // 更新图表数据
  updateData(data) {
    // 实现更新图表数据
  }
  
  // 导出图表
  exportChart(format) {
    // 实现图表导出
  }
}

// 文件上传微前端应用
class FileUploadApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.config = options.config || {};
  }
  
  // 渲染上传组件
  render(options) {
    // 实现上传组件渲染
  }
  
  // 上传文件
  uploadFiles(files) {
    // 实现文件上传
  }
  
  // 暂停上传
  pauseUpload(fileId) {
    // 实现暂停上传
  }
  
  // 恢复上传
  resumeUpload(fileId) {
    // 实现恢复上传
  }
  
  // 取消上传
  cancelUpload(fileId) {
    // 实现取消上传
  }
  
  // 删除文件
  deleteFile(fileId) {
    // 实现删除文件
  }
}

// 通知系统微前端应用
class NotificationApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.config = options.config || {};
  }
  
  // 显示通知
  showNotification(notification) {
    // 实现显示通知
  }
  
  // 隐藏通知
  hideNotification(notificationId) {
    // 实现隐藏通知
  }
  
  // 清除所有通知
  clearAllNotifications() {
    // 实现清除所有通知
  }
  
  // 设置提醒
  setReminder(reminder) {
    // 实现设置提醒
  }
  
  // 取消提醒
  cancelReminder(reminderId) {
    // 实现取消提醒
  }
}
```

### 2.2.3 按团队结构划分

按团队结构划分是一种以人为中心的微前端应用划分策略，它根据团队的组织结构来划分微前端应用，确保每个团队有明确的应用边界和职责。

**划分原则：：**

1. **团队边界清晰**：每个微前端应用对应一个明确的团队，边界清晰。

2. **团队自治**：每个团队对自己负责的应用有完全的自主权。

3. **沟通成本最小**：减少团队间的沟通成本，提高开发效率。

4. **责任明确**：每个团队对自己负责的应用的质量和性能负责。

**实践方法：：**

1. **康威定律**：应用康威定律，系统设计应反映组织的沟通结构。

2. **团队拓扑**：采用团队拓扑方法，设计适合团队的组织结构。

3. **领域知识**：根据团队的领域知识划分应用，确保团队对应用有深入理解。

4. **跨团队协作**：建立跨团队协作机制，处理跨应用的需求。

**示例场景：：**

以大型互联网公司为例，可以按以下团队结构划分微前端应用：

1. **用户体验团队**：负责整体用户体验、设计系统、公共组件等。

2. **用户增长团队**：负责用户注册、登录、活动运营等。

3. **商品团队**：负责商品管理、分类、搜索等。

4. **交易团队**：负责购物车、订单、支付等。

5. **数据团队**：负责数据分析、报表、监控等。

**示例代码：：**

```javascript
// 用户体验团队微前端应用
class UXTeamApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.config = options.config || {};
  }
  
  // 设计系统
  renderDesignSystem() {
    // 实现设计系统渲染
  }
  
  // 公共组件
  renderCommonComponents() {
    // 实现公共组件渲染
  }
  
  // 主题系统
  applyTheme(theme) {
    // 实现主题应用
  }
  
  // 响应式布局
  applyResponsiveLayout() {
    // 实现响应式布局
  }
  
  // 无障碍支持
  enableAccessibility() {
    // 实现无障碍支持
  }
}

// 用户增长团队微前端应用
class UserGrowthTeamApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.config = options.config || {};
  }
  
  // 用户注册
  register(userData) {
    // 实现用户注册
  }
  
  // 用户登录
  login(credentials) {
    // 实现用户登录
  }
  
  // 活动运营
  showActivities() {
    // 实现活动运营展示
  }
  
  // 用户推荐
  showReferrals() {
    // 实现用户推荐展示
  }
  
  // 用户留存
  showRetentionStrategies() {
    // 实现用户留存策略展示
  }
}

// 商品团队微前端应用
class ProductTeamApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.config = options.config || {};
  }
  
  // 商品管理
  manageProducts() {
    // 实现商品管理
  }
  
  // 商品分类
  manageCategories() {
    // 实现商品分类管理
  }
  
  // 商品搜索
  searchProducts(query) {
    // 实现商品搜索
  }
  
  // 商品推荐
  recommendProducts(userId) {
    // 实现商品推荐
  }
  
  // 商品评价
  manageReviews() {
    // 实现商品评价管理
  }
}

// 交易团队微前端应用
class TransactionTeamApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.config = options.config || {};
  }
  
  // 购物车
  showCart() {
    // 实现购物车展示
  }
  
  // 订单管理
  manageOrders() {
    // 实现订单管理
  }
  
  // 支付处理
  processPayment(paymentData) {
    // 实现支付处理
  }
  
  // 物流跟踪
  trackLogistics(orderId) {
    // 实现物流跟踪
  }
  
  // 售后服务
  provideAfterSales(serviceType) {
    // 实现售后服务
  }
}

// 数据团队微前端应用
class DataTeamApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.config = options.config || {};
  }
  
  // 数据分析
  analyzeData(dataType) {
    // 实现数据分析
  }
  
  // 报表展示
  showReports() {
    // 实现报表展示
  }
  
  // 监控面板
  showMonitoring() {
    // 实现监控面板展示
  }
  
  // 数据可视化
  visualizeData(data) {
    // 实现数据可视化
  }
  
  // 数据导出
  exportData(format) {
    // 实现数据导出
  }
}
```

### 2.2.4 混合划分策略

混合划分策略是结合多种划分方法的综合策略，它根据具体场景和需求，灵活选择最适合的划分方法。

**划分原则：：**

1. **场景驱动**：根据具体场景和需求选择最适合的划分方法。

2. **灵活组合**：可以组合多种划分方法，形成最适合的划分方案。

3. **渐进优化**：根据实际使用情况，逐步优化划分方案。

4. **平衡考虑**：平衡业务需求、团队结构、技术实现等多个方面。

**实践方法：：**

1. **场景分析**：分析不同场景的需求和特点，选择合适的划分方法。

2. **方案设计**：设计多种划分方案，评估各方案的优缺点。

3. **试点验证**：选择试点应用，验证划分方案的可行性。

4. **持续优化**：根据实际使用情况，持续优化划分方案。

**示例场景：：**

以大型电商平台为例，可以采用以下混合划分策略：

1. **核心业务按业务领域划分**：商品、订单、用户等核心业务按业务领域划分。

2. **公共功能按功能模块划分**：数据表格、表单组件、图表组件等公共功能按功能模块划分。

3. **创新业务按团队结构划分**：直播带货、社区互动等创新业务按团队结构划分。

**示例代码：：**

```javascript
// 核心业务：商品管理微前端应用（按业务领域划分）
class ProductManagementApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.productService = options.productService;
  }
  
  // 商品列表
  showProductList() {
    // 实现商品列表展示
  }
  
  // 商品详情
  showProductDetail(productId) {
    // 实现商品详情展示
  }
  
  // 商品编辑
  editProduct(productId) {
    // 实现商品编辑
  }
}

// 公共功能：数据表格微前端应用（按功能模块划分）
class DataTableApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.config = options.config || {};
  }
  
  // 渲染表格
  render(data, columns) {
    // 实现表格渲染
  }
  
  // 排序
  sort(column, direction) {
    // 实现排序功能
  }
  
  // 筛选
  filter(filters) {
    // 实现筛选功能
  }
}

// 创新业务：直播带货微前端应用（按团队结构划分）
class LiveShoppingApp {
  constructor(options) {
    this.container = options.container;
    this.eventBus = options.eventBus;
    this.liveService = options.liveService;
  }
  
  // 直播列表
  showLiveList() {
    // 实现直播列表展示
  }
  
  // 直播详情
  showLiveDetail(liveId) {
    // 实现直播详情展示
  }
  
  // 开始直播
  startLive(liveData) {
    // 实现开始直播
  }
  
  // 商品推荐
  recommendProducts(liveId) {
    // 实现商品推荐
  }
}

// 应用管理器
class AppManager {
  constructor() {
    this.apps = new Map();
    this.eventBus = new EventBus();
    this.sharedServices = new Map();
  }
  
  // 注册应用
  registerApp(name, config) {
    this.apps.set(name, {
      name,
      ...config,
      status: 'registered',
    });
  }
  
  // 注册共享服务
  registerService(name, service) {
    this.sharedServices.set(name, service);
  }
  
  // 获取共享服务
  getService(name) {
    return this.sharedServices.get(name);
  }
  
  // 加载应用
  async loadApp(name) {
    const app = this.apps.get(name);
    if (!app) {
      throw new Error(`App ${name} not found`);
    }
    
    if (app.status === 'loaded') {
      return app.instance;
    }
    
    try {
      // 动态加载应用代码
      const appModule = await import(app.entry);
      
      // 创建应用实例
      const instance = appModule.default({
        container: app.container,
        eventBus: this.eventBus,
        getSharedService: this.getService.bind(this),
      });
      
      // 保存应用实例
      app.instance = instance;
      app.status = 'loaded';
      
      return instance;
    } catch (error) {
      console.error(`Failed to load app ${name}:`, error);
      app.status = 'error';
      throw error;
    }
  }
  
  // 激活应用
  async activateApp(name) {
    const app = await this.loadApp(name);
    await app.mount();
    app.status = 'active';
  }
  
  // 停用应用
  async deactivateApp(name) {
    const app = this.apps.get(name);
    if (app && app.status === 'active') {
      await app.instance.unmount();
      app.status = 'loaded';
    }
  }
}

// 使用示例
const appManager = new AppManager();

// 注册共享服务
appManager.registerService('productService', new ProductService());
appManager.registerService('liveService', new LiveService());

// 注册核心业务应用（按业务领域划分）
appManager.registerApp('product-management', {
  entry: () => import('./apps/product-management.js'),
  container: '#product-management-container',
});

// 注册公共功能应用（按功能模块划分）
appManager.registerApp('data-table', {
  entry: () => import('./apps/data-table.js'),
  container: '#data-table-container',
});

// 注册创新业务应用（按团队结构划分）
appManager.registerApp('live-shopping', {
  entry: () => import('./apps/live-shopping.js'),
  container: '#live-shopping-container',
});

// 激活应用
appManager.activateApp('product-management');
appManager.activateApp('data-table');
appManager.activateApp('live-shopping');
```

## 2.3 架构演进路径

### 2.3.1 单体应用向微前端演进

从单体应用向微前端演进是一个渐进式的过程，需要根据具体情况选择合适的演进路径。

**演进阶段：：**

1. **评估分析阶段**：评估现有应用，确定微前端改造的可行性和范围。

2. **架构设计阶段**：设计微前端架构，确定应用划分策略和演进路径。

3. **基础设施阶段**：构建微前端基础设施，包括主框架、工具链和规范。

4. **试点改造阶段**：选择合适的模块进行试点改造，验证方案可行性。

5. **逐步推广阶段**：基于试点经验，逐步推广到其他模块。

6. **完全迁移阶段**：完成所有模块迁移，下线旧系统。

**演进策略：：**

1. **绞杀者模式**：逐步用微前端应用替换单体应用的功能，最终完全替换。

2. **并行运行模式**：新旧系统并行运行，逐步迁移用户和功能。

3. **功能隔离模式**：先隔离独立功能模块，进行微前端改造。

4. **界面重构模式**：先重构前端界面，后端保持不变。

**示例代码：：**

```javascript
// 单体应用路由配置
const legacyRoutes = [
  { path: '/dashboard', component: Dashboard },
  { path: '/users', component: Users },
  { path: '/products', component: Products },
  { path: '/orders', component: Orders },
];

// 微前端应用路由配置
const microFrontendRoutes = [
  { path: '/dashboard', app: 'dashboard-app' },
  { path: '/users', app: 'user-management-app' },
  { path: '/products', app: 'product-management-app' },
  { path: '/orders', app: 'order-management-app' },
];

// 路由适配器
class RouteAdapter {
  constructor() {
    this.legacyRoutes = legacyRoutes;
    this.microFrontendRoutes = microFrontendRoutes;
    this.appManager = new AppManager();
  }
  
  // 处理路由
  async handleRoute(path) {
    // 检查是否是微前端路由
    const microFrontendRoute = this.findMicroFrontendRoute(path);
    
    if (microFrontendRoute) {
      // 加载微前端应用
      await this.appManager.activateApp(microFrontendRoute.app);
    } else {
      // 加载单体应用组件
      const legacyRoute = this.findLegacyRoute(path);
      
      if (legacyRoute) {
        this.renderLegacyComponent(legacyRoute.component);
      }
    }
  }
  
  // 查找微前端路由
  findMicroFrontendRoute(path) {
    return this.microFrontendRoutes.find(route => path.startsWith(route.path));
  }
  
  // 查找单体应用路由
  findLegacyRoute(path) {
    return this.legacyRoutes.find(route => path.startsWith(route.path));
  }
  
  // 渲染单体应用组件
  renderLegacyComponent(Component) {
    const container = document.querySelector('#legacy-container');
    ReactDOM.render(<Component />, container);
  }
}

// 使用示例
const routeAdapter = new RouteAdapter();

// 路由监听
window.addEventListener('popstate', () => {
  routeAdapter.handleRoute(window.location.pathname);
});

// 初始路由
routeAdapter.handleRoute(window.location.pathname);
```

### 2.3.2 微前端架构演进

微前端架构本身也需要不断演进，以适应业务发展和技术变化。

**演进方向：：**

1. **架构简化**：简化架构复杂度，提高开发和维护效率。

2. **性能优化**：优化加载性能和运行时性能，提高用户体验。

3. **开发体验**：改善开发体验，提高开发效率。

4. **运维效率**：提高运维效率，降低运维成本。

5. **技术升级**：支持技术栈升级，保持技术先进性。

**演进策略：：**

1. **渐进式改进**：采用渐进式改进策略，避免大规模重构。

2. **数据驱动**：基于数据和指标驱动架构演进，确保改进效果。

3. **社区反馈**：关注社区反馈和最佳实践，引入新的思想和方案。

4. **技术创新**：鼓励技术创新，尝试新的技术和方法。

**示例代码：：**

```javascript
// 早期微前端架构
class EarlyMicroFrontendArchitecture {
  constructor() {
    this.apps = new Map();
    this.eventBus = new EventBus();
    this.globalState = new GlobalState();
  }
  
  // 注册应用
  registerApp(name, config) {
    this.apps.set(name, {
      name,
      ...config,
      status: 'registered',
    });
  }
  
  // 加载应用
  async loadApp(name) {
    const app = this.apps.get(name);
    if (!app) {
      throw new Error(`App ${name} not found`);
    }
    
    if (app.status === 'loaded') {
      return app.instance;
    }
    
    try {
      // 动态加载应用代码
      const appModule = await import(app.entry);
      
      // 创建应用实例
      const instance = appModule.default({
        container: app.container,
        eventBus: this.eventBus,
        globalState: this.globalState,
      });
      
      // 保存应用实例
      app.instance = instance;
      app.status = 'loaded';
      
      return instance;
    } catch (error) {
      console.error(`Failed to load app ${name}:`, error);
      app.status = 'error';
      throw error;
    }
  }
}

// 演进后的微前端架构
class EvolvedMicroFrontendArchitecture {
  constructor() {
    this.apps = new Map();
    this.eventBus = new EnhancedEventBus();
    this.globalState = new OptimizedGlobalState();
    this.performanceMonitor = new PerformanceMonitor();
    this.errorBoundary = new ErrorBoundary();
    this.dependencyManager = new DependencyManager();
  }
  
  // 注册应用
  registerApp(name, config) {
    this.apps.set(name, {
      name,
      ...config,
      status: 'registered',
      dependencies: config.dependencies || [],
      performanceMetrics: {},
    });
  }
  
  // 加载应用
  async loadApp(name) {
    const app = this.apps.get(name);
    if (!app) {
      throw new Error(`App ${name} not found`);
    }
    
    if (app.status === 'loaded') {
      return app.instance;
    }
    
    try {
      // 性能监控开始
      const startTime = performance.now();
      
      // 加载依赖
      await this.dependencyManager.loadDependencies(app.dependencies);
      
      // 动态加载应用代码
      const appModule = await import(app.entry);
      
      // 创建应用实例
      const instance = appModule.default({
        container: app.container,
        eventBus: this.eventBus,
        globalState: this.globalState,
        performanceMonitor: this.performanceMonitor,
        errorBoundary: this.errorBoundary,
      });
      
      // 保存应用实例
      app.instance = instance;
      app.status = 'loaded';
      
      // 性能监控结束
      const loadTime = performance.now() - startTime;
      app.performanceMetrics.loadTime = loadTime;
      this.performanceMonitor.recordAppLoadTime(name, loadTime);
      
      return instance;
    } catch (error) {
      console.error(`Failed to load app ${name}:`, error);
      app.status = 'error';
      this.errorBoundary.handleError(error, { app: name });
      throw error;
    }
  }
  
  // 预加载应用
  async preloadApp(name) {
    const app = this.apps.get(name);
    if (!app || app.status !== 'registered') {
      return;
    }
    
    try {
      // 预加载依赖
      await this.dependencyManager.preloadDependencies(app.dependencies);
      
      // 预加载应用代码
      await import(app.entry);
      
      app.status = 'preloaded';
    } catch (error) {
      console.error(`Failed to preload app ${name}:`, error);
    }
  }
  
  // 批量预加载应用
  async preloadApps(names) {
    const promises = names.map(name => this.preloadApp(name));
    await Promise.allSettled(promises);
  }
  
  // 获取应用性能指标
  getAppPerformanceMetrics(name) {
    const app = this.apps.get(name);
    return app ? app.performanceMetrics : null;
  }
  
  // 获取全局性能指标
  getGlobalPerformanceMetrics() {
    return this.performanceMonitor.getGlobalMetrics();
  }
}

// 增强事件总线
class EnhancedEventBus extends EventBus {
  constructor() {
    super();
    this.eventHistory = [];
    this.eventStats = {};
  }
  
  // 发布事件
  emit(event, data) {
    // 记录事件历史
    this.eventHistory.push({
      event,
      data,
      timestamp: Date.now(),
    });
    
    // 更新事件统计
    this.eventStats[event] = (this.eventStats[event] || 0) + 1;
    
    // 调用父类方法
    super.emit(event, data);
  }
  
  // 获取事件历史
  getEventHistory() {
    return this.eventHistory;
  }
  
  // 获取事件统计
  getEventStats() {
    return this.eventStats;
  }
}

// 优化全局状态
class OptimizedGlobalState extends GlobalState {
  constructor() {
    super();
    this.stateHistory = [];
    this.stateSnapshots = {};
  }
  
  // 设置状态
  setState(key, value) {
    // 记录状态历史
    this.stateHistory.push({
      key,
      value,
      timestamp: Date.now(),
    });
    
    // 调用父类方法
    super.setState(key, value);
  }
  
  // 创建状态快照
  createSnapshot(name) {
    this.stateSnapshots[name] = {
      state: { ...this.state },
      timestamp: Date.now(),
    };
  }
  
  // 恢复状态快照
  restoreSnapshot(name) {
    const snapshot = this.stateSnapshots[name];
    if (snapshot) {
      this.state = { ...snapshot.state };
    }
  }
  
  // 获取状态历史
  getStateHistory() {
    return this.stateHistory;
  }
  
  // 获取状态快照
  getStateSnapshots() {
    return this.stateSnapshots;
  }
}

// 性能监控器
class PerformanceMonitor {
  constructor() {
    this.appLoadTimes = {};
    this.globalMetrics = {
      totalLoadTime: 0,
      appCount: 0,
      errorCount: 0,
    };
  }
  
  // 记录应用加载时间
  recordAppLoadTime(appName, loadTime) {
    this.appLoadTimes[appName] = loadTime;
    this.globalMetrics.totalLoadTime += loadTime;
    this.globalMetrics.appCount += 1;
  }
  
  // 记录错误
  recordError(error) {
    this.globalMetrics.errorCount += 1;
  }
  
  // 获取应用加载时间
  getAppLoadTime(appName) {
    return this.appLoadTimes[appName];
  }
  
  // 获取全局指标
  getGlobalMetrics() {
    const averageLoadTime = this.globalMetrics.appCount > 0
      ? this.globalMetrics.totalLoadTime / this.globalMetrics.appCount
      : 0;
    
    return {
      ...this.globalMetrics,
      averageLoadTime,
    };
  }
}

// 错误边界
class ErrorBoundary {
  constructor() {
    this.errorHandlers = new Map();
    this.errorHistory = [];
  }
  
  // 注册错误处理器
  registerErrorHandler(type, handler) {
    this.errorHandlers.set(type, handler);
  }
  
  // 处理错误
  handleError(error, context = {}) {
    // 记录错误历史
    this.errorHistory.push({
      error,
      context,
      timestamp: Date.now(),
    });
    
    // 获取错误类型
    const errorType = this.getErrorType(error);
    
    // 获取错误处理器
    const handler = this.errorHandlers.get(errorType);
    
    if (handler) {
      handler(error, context);
    } else {
      // 默认错误处理
      this.defaultErrorHandler(error, context);
    }
  }
  
  // 获取错误类型
  getErrorType(error) {
    if (error instanceof NetworkError) {
      return 'network';
    } else if (error instanceof TypeError) {
      return 'type';
    } else if (error instanceof ReferenceError) {
      return 'reference';
    } else {
      return 'unknown';
    }
  }
  
  // 默认错误处理器
  defaultErrorHandler(error, context) {
    console.error('Unhandled error:', error, context);
  }
  
  // 获取错误历史
  getErrorHistory() {
    return this.errorHistory;
  }
}

// 依赖管理器
class DependencyManager {
  constructor() {
    this.loadedDependencies = new Set();
    this.preloadedDependencies = new Set();
    this.dependencyCache = new Map();
  }
  
  // 加载依赖
  async loadDependencies(dependencies) {
    const promises = dependencies.map(dep => this.loadDependency(dep));
    await Promise.all(promises);
  }
  
  // 预加载依赖
  async preloadDependencies(dependencies) {
    const promises = dependencies.map(dep => this.preloadDependency(dep));
    await Promise.allSettled(promises);
  }
  
  // 加载单个依赖
  async loadDependency(name) {
    if (this.loadedDependencies.has(name)) {
      return this.dependencyCache.get(name);
    }
    
    try {
      const dependency = await import(name);
      this.loadedDependencies.add(name);
      this.dependencyCache.set(name, dependency);
      return dependency;
    } catch (error) {
      console.error(`Failed to load dependency ${name}:`, error);
      throw error;
    }
  }
  
  // 预加载单个依赖
  async preloadDependency(name) {
    if (this.preloadedDependencies.has(name)) {
      return;
    }
    
    try {
      await import(name);
      this.preloadedDependencies.add(name);
    } catch (error) {
      console.error(`Failed to preload dependency ${name}:`, error);
    }
  }
  
  // 检查依赖是否已加载
  isDependencyLoaded(name) {
    return this.loadedDependencies.has(name);
  }
  
  // 检查依赖是否已预加载
  isDependencyPreloaded(name) {
    return this.preloadedDependencies.has(name);
  }
}

// 使用示例
const architecture = new EvolvedMicroFrontendArchitecture();

// 注册应用
architecture.registerApp('dashboard', {
  entry: '/apps/dashboard/index.js',
  container: '#dashboard-container',
  dependencies: ['react', 'react-dom'],
});

// 注册错误处理器
architecture.errorBoundary.registerErrorHandler('network', (error, context) => {
  console.error('Network error:', error, context);
  // 显示网络错误提示
});

// 预加载应用
architecture.preloadApps(['dashboard', 'user-management']);

// 加载应用
architecture.loadApp('dashboard').then(app => {
  app.mount();
});

// 获取性能指标
const metrics = architecture.getGlobalPerformanceMetrics();
console.log('Global performance metrics:', metrics);
```

### 2.3.3 混合架构演进

混合架构演进是指在微前端架构中引入其他架构模式，如微服务、Serverless等，形成更加灵活和强大的架构体系。

**演进方向：：**

1. **前后端一体化**：将微前端与微服务结合，实现前后端一体化架构。

2. **边缘计算**：将微前端与边缘计算结合，提高应用性能和用户体验。

3. **Serverless集成**：将微前端与Serverless架构结合，降低运维成本。

4. **低代码平台**：将微前端与低代码平台结合，提高开发效率。

5. **智能化运维**：将微前端与AI/ML技术结合，实现智能化运维。

**演进策略：：**

1. **业务驱动**：根据业务需求选择合适的架构演进方向。

2. **技术评估**：评估新技术的成熟度和适用性。

3. **渐进式集成**：采用渐进式集成策略，避免大规模重构。

4. **风险控制**：控制架构演进的风险，确保系统稳定性。

**示例代码：：**

```javascript
// 微前端与微服务集成的架构
class MicroFrontendMicroServiceArchitecture {
  constructor() {
    this.apps = new Map();
    this.services = new Map();
    this.eventBus = new EventBus();
    this.apiGateway = new ApiGateway();
    this.serviceRegistry = new ServiceRegistry();
  }
  
  // 注册微前端应用
  registerApp(name, config) {
    this.apps.set(name, {
      name,
      ...config,
      status: 'registered',
    });
  }
  
  // 注册微服务
  registerService(name, config) {
    this.services.set(name, {
      name,
      ...config,
      status: 'registered',
    });
    
    // 注册到服务注册中心
    this.serviceRegistry.register(name, config.url);
  }
  
  // 加载微前端应用
  async loadApp(name) {
    const app = this.apps.get(name);
    if (!app) {
      throw new Error(`App ${name} not found`);
    }
    
    if (app.status === 'loaded') {
      return app.instance;
    }
    
    try {
      // 动态加载应用代码
      const appModule = await import(app.entry);
      
      // 创建应用实例
      const instance = appModule.default({
        container: app.container,
        eventBus: this.eventBus,
        apiGateway: this.apiGateway,
        serviceRegistry: this.serviceRegistry,
      });
      
      // 保存应用实例
      app.instance = instance;
      app.status = 'loaded';
      
      return instance;
    } catch (error) {
      console.error(`Failed to load app ${name}:`, error);
      app.status = 'error';
      throw error;
    }
  }
  
  // 调用微服务
  async callService(serviceName, method, data) {
    const service = this.services.get(serviceName);
    if (!service) {
      throw new Error(`Service ${serviceName} not found`);
    }
    
    try {
      // 通过API网关调用服务
      const result = await this.apiGateway.call(serviceName, method, data);
      return result;
    } catch (error) {
      console.error(`Failed to call service ${serviceName}:`, error);
      throw error;
    }
  }
}

// API网关
class ApiGateway {
  constructor() {
    this.routes = new Map();
    this.middlewares = [];
    this.serviceRegistry = null;
  }
  
  // 设置服务注册中心
  setServiceRegistry(serviceRegistry) {
    this.serviceRegistry = serviceRegistry;
  }
  
  // 注册路由
  registerRoute(path, serviceName, method) {
    this.routes.set(path, { serviceName, method });
  }
  
  // 添加中间件
  addMiddleware(middleware) {
    this.middlewares.push(middleware);
  }
  
  // 调用服务
  async call(serviceName, method, data) {
    // 获取服务URL
    const serviceUrl = this.serviceRegistry.getServiceUrl(serviceName);
    
    if (!serviceUrl) {
      throw new Error(`Service ${serviceName} not found in registry`);
    }
    
    // 构建请求URL
    const url = `${serviceUrl}/${method}`;
    
    // 执行中间件
    for (const middleware of this.middlewares) {
      data = await middleware(data);
    }
    
    // 发送请求
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });
    
    if (!response.ok) {
      throw new Error(`Service call failed: ${response.statusText}`);
    }
    
    return response.json();
  }
}

// 服务注册中心
class ServiceRegistry {
  constructor() {
    this.services = new Map();
    this.healthCheckInterval = null;
  }
  
  // 注册服务
  register(name, url) {
    this.services.set(name, {
      name,
      url,
      status: 'healthy',
      lastHealthCheck: Date.now(),
    });
    
    // 启动健康检查
    this.startHealthCheck();
  }
  
  // 注销服务
  unregister(name) {
    this.services.delete(name);
  }
  
  // 获取服务URL
  getServiceUrl(name) {
    const service = this.services.get(name);
    return service ? service.url : null;
  }
  
  // 获取服务状态
  getServiceStatus(name) {
    const service = this.services.get(name);
    return service ? service.status : null;
  }
  
  // 启动健康检查
  startHealthCheck() {
    if (this.healthCheckInterval) {
      return;
    }
    
    this.healthCheckInterval = setInterval(() => {
      this.checkAllServices();
    }, 30000); // 每30秒检查一次
  }
  
  // 停止健康检查
  stopHealthCheck() {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = null;
    }
  }
  
  // 检查所有服务
  async checkAllServices() {
    for (const [name, service] of this.services) {
      try {
        // 发送健康检查请求
        const response = await fetch(`${service.url}/health`, {
          method: 'GET',
        });
        
        if (response.ok) {
          service.status = 'healthy';
        } else {
          service.status = 'unhealthy';
        }
      } catch (error) {
        service.status = 'unhealthy';
      }
      
      service.lastHealthCheck = Date.now();
    }
  }
}

// 微前端与Serverless集成的架构
class MicroFrontendServerlessArchitecture {
  constructor() {
    this.apps = new Map();
    this.functions = new Map();
    this.eventBus = new EventBus();
    this.functionRegistry = new FunctionRegistry();
  }
  
  // 注册微前端应用
  registerApp(name, config) {
    this.apps.set(name, {
      name,
      ...config,
      status: 'registered',
    });
  }
  
  // 注册Serverless函数
  registerFunction(name, config) {
    this.functions.set(name, {
      name,
      ...config,
      status: 'registered',
    });
    
    // 注册到函数注册中心
    this.functionRegistry.register(name, config);
  }
  
  // 加载微前端应用
  async loadApp(name) {
    const app = this.apps.get(name);
    if (!app) {
      throw new Error(`App ${name} not found`);
    }
    
    if (app.status === 'loaded') {
      return app.instance;
    }
    
    try {
      // 动态加载应用代码
      const appModule = await import(app.entry);
      
      // 创建应用实例
      const instance = appModule.default({
        container: app.container,
        eventBus: this.eventBus,
        functionRegistry: this.functionRegistry,
      });
      
      // 保存应用实例
      app.instance = instance;
      app.status = 'loaded';
      
      return instance;
    } catch (error) {
      console.error(`Failed to load app ${name}:`, error);
      app.status = 'error';
      throw error;
    }
  }
  
  // 调用Serverless函数
  async callFunction(functionName, data) {
    const func = this.functions.get(functionName);
    if (!func) {
      throw new Error(`Function ${functionName} not found`);
    }
    
    try {
      // 通过函数注册中心调用函数
      const result = await this.functionRegistry.call(functionName, data);
      return result;
    } catch (error) {
      console.error(`Failed to call function ${functionName}:`, error);
      throw error;
    }
  }
}

// 函数注册中心
class FunctionRegistry {
  constructor() {
    this.functions = new Map();
    this.executions = new Map();
  }
  
  // 注册函数
  register(name, config) {
    this.functions.set(name, {
      name,
      ...config,
      status: 'registered',
      executions: 0,
      errors: 0,
    });
  }
  
  // 注销函数
  unregister(name) {
    this.functions.delete(name);
  }
  
  // 调用函数
  async call(name, data) {
    const func = this.functions.get(name);
    if (!func) {
      throw new Error(`Function ${name} not found`);
    }
    
    try {
      // 增加执行次数
      func.executions += 1;
      
      // 执行函数
      const result = await this.executeFunction(func, data);
      
      return result;
    } catch (error) {
      // 增加错误次数
      func.errors += 1;
      throw error;
    }
  }
  
  // 执行函数
  async executeFunction(func, data) {
    // 根据函数类型执行不同的逻辑
    switch (func.type) {
      case 'http':
        return this.executeHttpFunction(func, data);
      case 'event':
        return this.executeEventFunction(func, data);
      case 'stream':
        return this.executeStreamFunction(func, data);
      default:
        throw new Error(`Unknown function type: ${func.type}`);
    }
  }
  
  // 执行HTTP函数
  async executeHttpFunction(func, data) {
    const response = await fetch(func.url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });
    
    if (!response.ok) {
      throw new Error(`Function execution failed: ${response.statusText}`);
    }
    
    return response.json();
  }
  
  // 执行事件函数
  async executeEventFunction(func, data) {
    // 发布事件
    const eventBus = new EventBus();
    eventBus.emit(func.event, data);
    
    // 返回执行结果
    return { success: true };
  }
  
  // 执行流函数
  async executeStreamFunction(func, data) {
    // 创建流
    const stream = new ReadableStream({
      start(controller) {
        // 处理数据流
        controller.enqueue(data);
        controller.close();
      },
    });
    
    // 返回流
    return stream;
  }
  
  // 获取函数统计信息
  getFunctionStats(name) {
    const func = this.functions.get(name);
    return func ? {
      executions: func.executions,
      errors: func.errors,
      errorRate: func.executions > 0 ? func.errors / func.executions : 0,
    } : null;
  }
}

// 使用示例
const architecture = new MicroFrontendMicroServiceArchitecture();

// 注册微前端应用
architecture.registerApp('dashboard', {
  entry: '/apps/dashboard/index.js',
  container: '#dashboard-container',
});

// 注册微服务
architecture.registerService('user-service', {
  url: 'https://api.example.com/user-service',
});

// 注册API网关路由
architecture.apiGateway.registerRoute('/api/users', 'user-service', 'users');
architecture.apiGateway.registerRoute('/api/users/:id', 'user-service', 'user');

// 加载应用
architecture.loadApp('dashboard').then(app => {
  app.mount();
});

// 调用服务
architecture.callService('user-service', 'users', { page: 1, limit: 10 })
  .then(users => {
    console.log('Users:', users);
  })
  .catch(error => {
    console.error('Error:', error);
  });
```

## 2.4 架构模式选择

### 2.4.1 基座模式

基座模式（Base Pattern）是最常见的微前端架构模式，它有一个主应用（基座）负责加载和管理其他微前端应用。

**模式特点：：**

1. **中心化管理**：由主应用统一管理子应用的加载、卸载和路由。

2. **技术栈统一**：通常主应用和子应用使用相同的技术栈。

3. **依赖共享**：主应用和子应用可以共享依赖，减少重复加载。

4. **全局状态**：主应用可以维护全局状态，供子应用共享。

**适用场景：：**

1. **企业级应用**：适合大型企业级应用，需要统一管理和控制。

2. **技术栈统一**：适合技术栈相对统一的应用场景。

3. **渐进式迁移**：适合从单体应用向微前端迁移的场景。

**实现方式：：**

1. **主应用框架**：使用React、Vue等框架构建主应用。

2. **子应用注册**：在主应用中注册子应用信息。

3. **路由管理**：主应用负责路由管理，根据路由加载对应子应用。

4. **通信机制**：通过事件总线、全局状态等方式实现应用间通信。

**示例代码：：**

```javascript
// 主应用
class MainApplication {
  constructor() {
    this.apps = new Map();
    this.eventBus = new EventBus();
    this.globalState = new GlobalState();
    this.router = new Router();
    this.currentApp = null;
  }
  
  // 初始化应用
  async init() {
    // 初始化路由
    this.initRouter();
    
    // 初始化全局状态
    await this.initGlobalState();
    
    // 加载初始应用
    await this.loadInitialApp();
  }
  
  // 注册子应用
  registerApp(name, config) {
    this.apps.set(name, {
      name,
      ...config,
      status: 'registered',
    });
  }
  
  // 初始化路由
  initRouter() {
    this.router.on('*', async (path) => {
      await this.handleRoute(path);
    });
  }
  
  // 处理路由
  async handleRoute(path) {
    // 查找匹配的子应用
    const app = this.findAppByPath(path);
    
    if (app) {
      // 加载并激活子应用
      await this.activateApp(app.name);
    } else {
      // 处理404
      this.handleNotFound();
    }
  }
  
  // 查找匹配的子应用
  findAppByPath(path) {
    for (const app of this.apps.values()) {
      if (app.activeRule && path.startsWith(app.activeRule)) {
        return app;
      }
    }
    return null;
  }
  
  // 激活子应用
  async activateApp(name) {
    // 如果当前已有激活的应用，先卸载
    if (this.currentApp && this.currentApp.name !== name) {
      await this.deactivateApp(this.currentApp.name);
    }
    
    const app = this.apps.get(name);
    if (!app) {
      throw new Error(`App ${name} not found`);
    }
    
    if (app.status === 'active') {
      return;
    }
    
    try {
      // 加载子应用
      if (app.status !== 'loaded') {
        await this.loadApp(name);
      }
      
      // 挂载子应用
      await app.instance.mount({
        container: app.container,
        eventBus: this.eventBus,
        globalState: this.globalState,
        router: this.createSubRouter(app),
      });
      
      app.status = 'active';
      this.currentApp = app;
    } catch (error) {
      console.error(`Failed to activate app ${name}:`, error);
      app.status = 'error';
      throw error;
    }
  }
  
  // 停用子应用
  async deactivateApp(name) {
    const app = this.apps.get(name);
    if (!app || app.status !== 'active') {
      return;
    }
    
    try {
      // 卸载子应用
      await app.instance.unmount();
      app.status = 'loaded';
      
      if (this.currentApp === app) {
        this.currentApp = null;
      }
    } catch (error) {
      console.error(`Failed to deactivate app ${name}:`, error);
      app.status = 'error';
      throw error;
    }
  }
  
  // 加载子应用
  async loadApp(name) {
    const app = this.apps.get(name);
    if (!app) {
      throw new Error(`App ${name} not found`);
    }
    
    if (app.status === 'loaded') {
      return app.instance;
    }
    
    try {
      // 动态加载子应用代码
      const appModule = await import(app.entry);
      
      // 创建子应用实例
      const instance = appModule.default();
      
      // 保存子应用实例
      app.instance = instance;
      app.status = 'loaded';
      
      return instance;
    } catch (error) {
      console.error(`Failed to load app ${name}:`, error);
      app.status = 'error';
      throw error;
    }
  }
  
  // 创建子路由
  createSubRouter(app) {
    return {
      push: (path) => {
        this.router.push(`${app.activeRule}${path}`);
      },
      replace: (path) => {
        this.router.replace(`${app.activeRule}${path}`);
      },
      go: (n) => {
        this.router.go(n);
      },
      back: () => {
        this.router.back();
      },
      forward: () => {
        this.router.forward();
      },
    };
  }
  
  // 初始化全局状态
  async initGlobalState() {
    // 加载初始状态
    const initialState = await this.loadInitialState();
    this.globalState.setState(initialState);
  }
  
  // 加载初始状态
  async loadInitialState() {
    // 从API加载初始状态
    const response = await fetch('/api/initial-state');
    return response.json();
  }
  
  // 加载初始应用
  async loadInitialApp() {
    const path = window.location.pathname;
    await this.handleRoute(path);
  }
  
  // 处理404
  handleNotFound() {
    // 显示404页面
    const container = document.querySelector('#app-container');
    container.innerHTML = '<h1>404 Not Found</h1>';
  }
}

// 事件总线
class EventBus {
  constructor() {
    this.events = new Map();
  }
  
  // 订阅事件
  on(event, callback) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event).push(callback);
  }
  
  // 取消订阅事件
  off(event, callback) {
    if (!this.events.has(event)) {
      return;
    }
    const callbacks = this.events.get(event);
    const index = callbacks.indexOf(callback);
    if (index !== -1) {
      callbacks.splice(index, 1);
    }
  }
  
  // 发布事件
  emit(event, data) {
    if (!this.events.has(event)) {
      return;
    }
    const callbacks = this.events.get(event);
    callbacks.forEach(callback => callback(data));
  }
}

// 全局状态管理
class GlobalState {
  constructor() {
    this.state = {};
    this.listeners = new Map();
  }
  
  // 设置状态
  setState(key, value) {
    const oldValue = this.state[key];
    this.state[key] = value;
    
    // 通知监听器
    if (this.listeners.has(key)) {
      this.listeners.get(key).forEach(listener => listener(value, oldValue));
    }
  }
  
  // 获取状态
  getState(key) {
    return this.state[key];
  }
  
  // 订阅状态变化
  subscribe(key, listener) {
    if (!this.listeners.has(key)) {
      this.listeners.set(key, []);
    }
    this.listeners.get(key).push(listener);
    
    // 返回取消订阅函数
    return () => {
      const listeners = this.listeners.get(key);
      const index = listeners.indexOf(listener);
      if (index !== -1) {
        listeners.splice(index, 1);
      }
    };
  }
}

// 路由管理器
class Router {
  constructor() {
    this.routes = new Map();
    this.currentPath = window.location.pathname;
    this.history = [];
  }
  
  // 注册路由
  on(path, handler) {
    this.routes.set(path, handler);
  }
  
  // 导航到指定路径
  push(path) {
    if (path !== this.currentPath) {
      this.history.push(this.currentPath);
      window.history.pushState({}, '', path);
      this.currentPath = path;
      this.handleRoute(path);
    }
  }
  
  // 替换当前路径
  replace(path) {
    window.history.replaceState({}, '', path);
    this.currentPath = path;
    this.handleRoute(path);
  }
  
  // 前进或后退
  go(n) {
    window.history.go(n);
  }
  
  // 后退
  back() {
    this.go(-1);
  }
  
  // 前进
  forward() {
    this.go(1);
  }
  
  // 处理路由
  handleRoute(path) {
    // 查找匹配的路由
    for (const [route, handler] of this.routes) {
      if (route === '*' || path.startsWith(route)) {
        handler(path);
        return;
      }
    }
  }
}

// 使用示例
const mainApp = new MainApplication();

// 注册子应用
mainApp.registerApp('dashboard', {
  entry: () => import('./apps/dashboard'),
  container: '#app-container',
  activeRule: '/dashboard',
});

mainApp.registerApp('user-management', {
  entry: () => import('./apps/user-management'),
  container: '#app-container',
  activeRule: '/users',
});

// 初始化应用
mainApp.init().then(() => {
  console.log('Main application initialized');
});
```

### 2.4.2 自组织模式

自组织模式（Self-Organization Pattern）是一种去中心化的微前端架构模式，各个微前端应用可以独立运行，通过协商机制实现协同工作。

**模式特点：：**

1. **去中心化**：没有中心化的主应用，各个应用地位平等。

2. **独立部署**：每个应用可以独立部署和运行。

3. **协商机制**：通过协商机制实现应用间的协调和通信。

4. **动态组合**：应用可以动态组合，形成不同的业务场景。

**适用场景：：**

1. **平台型应用**：适合平台型应用，需要支持多种业务场景。

2. **技术栈多样**：适合技术栈多样化的应用场景。

3. **分布式团队**：适合分布式团队开发，减少团队间依赖。

**实现方式：：**

1. **应用注册表**：维护一个应用注册表，记录所有可用应用。

2. **协商协议**：定义应用间的协商协议，实现动态组合。

3. **通信机制**：通过发布-订阅模式实现应用间通信。

4. **状态同步**：通过状态同步机制保持应用间状态一致。

**示例代码：：**

```javascript
// 应用注册表
class AppRegistry {
  constructor() {
    this.apps = new Map();
    this.instances = new Map();
    this.eventBus = new EventBus();
  }
  
  // 注册应用
  registerApp(name, config) {
    this.apps.set(name, {
      name,
      ...config,
      status: 'registered',
    });
    
    // 发布应用注册事件
    this.eventBus.emit('app:registered', { name, config });
  }
  
  // 注销应用
  unregisterApp(name) {
    if (this.apps.has(name)) {
      this.apps.delete(name);
      
      // 发布应用注销事件
      this.eventBus.emit('app:unregistered', { name });
    }
  }
  
  // 获取应用信息
  getApp(name) {
    return this.apps.get(name);
  }
  
  // 获取所有应用
  getAllApps() {
    return Array.from(this.apps.values());
  }
  
  // 创建应用实例
  async createInstance(name, options = {}) {
    const app = this.apps.get(name);
    if (!app) {
      throw new Error(`App ${name} not found`);
    }
    
    // 检查是否已有实例
    if (this.instances.has(name)) {
      return this.instances.get(name);
    }
    
    try {
      // 动态加载应用代码
      const appModule = await import(app.entry);
      
      // 创建应用实例
      const instance = appModule.default({
        ...options,
        eventBus: this.eventBus,
        appRegistry: this,
      });
      
      // 保存应用实例
      this.instances.set(name, instance);
      
      // 发布实例创建事件
      this.eventBus.emit('instance:created', { name, instance });
      
      return instance;
    } catch (error) {
      console.error(`Failed to create instance for app ${name}:`, error);
      throw error;
    }
  }
  
  // 销毁应用实例
  async destroyInstance(name) {
    const instance = this.instances.get(name);
    if (!instance) {
      return;
    }
    
    try {
      // 销毁实例
      if (instance.destroy) {
        await instance.destroy();
      }
      
      // 移除实例
      this.instances.delete(name);
      
      // 发布实例销毁事件
      this.eventBus.emit('instance:destroyed', { name });
    } catch (error) {
      console.error(`Failed to destroy instance for app ${name}:`, error);
      throw error;
    }
  }
  
  // 获取应用实例
  getInstance(name) {
    return this.instances.get(name);
  }
  
  // 获取所有实例
  getAllInstances() {
    return Array.from(this.instances.entries()).map(([name, instance]) => ({
      name,
      instance,
    }));
  }
}

// 应用协商器
class AppNegotiator {
  constructor(appRegistry) {
    this.appRegistry = appRegistry;
    this.negotiations = new Map();
    this.eventBus = appRegistry.eventBus;
  }
  
  // 发起协商
  async negotiate(request) {
    const negotiationId = this.generateNegotiationId();
    const negotiation = {
      id: negotiationId,
      request,
      status: 'pending',
      responses: [],
      result: null,
    };
    
    this.negotiations.set(negotiationId, negotiation);
    
    // 发布协商请求
    this.eventBus.emit('negotiation:request', {
      id: negotiationId,
      request,
    });
    
    // 等待响应
    await this.waitForResponses(negotiationId);
    
    // 处理协商结果
    const result = await this.processNegotiation(negotiationId);
    
    negotiation.result = result;
    negotiation.status = 'completed';
    
    // 发布协商完成事件
    this.eventBus.emit('negotiation:completed', {
      id: negotiationId,
      request,
      result,
    });
    
    return result;
  }
  
  // 响应协商
  respondToNegotiation(negotiationId, response) {
    const negotiation = this.negotiations.get(negotiationId);
    if (!negotiation) {
      throw new Error(`Negotiation ${negotiationId} not found`);
    }
    
    negotiation.responses.push(response);
    
    // 发布协商响应事件
    this.eventBus.emit('negotiation:response', {
      id: negotiationId,
      response,
    });
  }
  
  // 等待响应
  async waitForResponses(negotiationId) {
    const timeout = 5000; // 5秒超时
    const startTime = Date.now();
    
    return new Promise((resolve) => {
      const checkInterval = setInterval(() => {
        const negotiation = this.negotiations.get(negotiationId);
        
        if (!negotiation) {
          clearInterval(checkInterval);
          resolve();
          return;
        }
        
        // 检查是否超时
        if (Date.now() - startTime > timeout) {
          clearInterval(checkInterval);
          resolve();
          return;
        }
        
        // 检查是否收到所有响应
        const expectedResponders = this.getExpectedResponders(negotiation.request);
        if (negotiation.responses.length >= expectedResponders.length) {
          clearInterval(checkInterval);
          resolve();
        }
      }, 100);
    });
  }
  
  // 处理协商结果
  async processNegotiation(negotiationId) {
    const negotiation = this.negotiations.get(negotiationId);
    if (!negotiation) {
      throw new Error(`Negotiation ${negotiationId} not found`);
    }
    
    const { request, responses } = negotiation;
    
    // 根据请求类型处理协商结果
    switch (request.type) {
      case 'layout':
        return this.processLayoutNegotiation(request, responses);
      case 'route':
        return this.processRouteNegotiation(request, responses);
      case 'resource':
        return this.processResourceNegotiation(request, responses);
      default:
        throw new Error(`Unknown negotiation type: ${request.type}`);
    }
  }
  
  // 处理布局协商
  processLayoutNegotiation(request, responses) {
    // 合并布局配置
    const layoutConfig = {
      type: 'grid',
      areas: {},
    };
    
    for (const response of responses) {
      if (response.layout) {
        Object.assign(layoutConfig.areas, response.layout.areas);
      }
    }
    
    return layoutConfig;
  }
  
  // 处理路由协商
  processRouteNegotiation(request, responses) {
    // 合并路由配置
    const routes = [];
    
    for (const response of responses) {
      if (response.routes) {
        routes.push(...response.routes);
      }
    }
    
    return { routes };
  }
  
  // 处理资源协商
  processResourceNegotiation(request, responses) {
    // 合并资源配置
    const resources = {
      scripts: [],
      styles: [],
    };
    
    for (const response of responses) {
      if (response.resources) {
        resources.scripts.push(...response.resources.scripts);
        resources.styles.push(...response.resources.styles);
      }
    }
    
    return resources;
  }
  
  // 获取预期响应者
  getExpectedResponders(request) {
    // 根据请求类型获取预期响应者
    switch (request.type) {
      case 'layout':
        return this.appRegistry.getAllApps().filter(app => app.capabilities.includes('layout'));
      case 'route':
        return this.appRegistry.getAllApps().filter(app => app.capabilities.includes('routing'));
      case 'resource':
        return this.appRegistry.getAllApps().filter(app => app.capabilities.includes('resource'));
      default:
        return [];
    }
  }
  
  // 生成协商ID
  generateNegotiationId() {
    return `negotiation_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

// 应用基类
class BaseApp {
  constructor(options) {
    this.name = options.name;
    this.eventBus = options.eventBus;
    this.appRegistry = options.appRegistry;
    this.container = options.container;
    this.status = 'created';
  }
  
  // 初始化应用
  async init() {
    this.status = 'initializing';
    
    // 订阅协商请求
    this.eventBus.on('negotiation:request', this.handleNegotiationRequest.bind(this));
    
    // 发布应用初始化事件
    this.eventBus.emit('app:initialized', { name: this.name });
    
    this.status = 'initialized';
  }
  
  // 启动应用
  async start() {
    if (this.status !== 'initialized') {
      await this.init();
    }
    
    this.status = 'starting';
    
    // 渲染应用
    await this.render();
    
    // 发布应用启动事件
    this.eventBus.emit('app:started', { name: this.name });
    
    this.status = 'running';
  }
  
  // 停止应用
  async stop() {
    if (this.status !== 'running') {
      return;
    }
    
    this.status = 'stopping';
    
    // 清理应用
    await this.cleanup();
    
    // 发布应用停止事件
    this.eventBus.emit('app:stopped', { name: this.name });
    
    this.status = 'stopped';
  }
  
  // 销毁应用
  async destroy() {
    if (this.status === 'running') {
      await this.stop();
    }
    
    // 取消订阅事件
    this.eventBus.off('negotiation:request', this.handleNegotiationRequest.bind(this));
    
    // 发布应用销毁事件
    this.eventBus.emit('app:destroyed', { name: this.name });
    
    this.status = 'destroyed';
  }
  
  // 处理协商请求
  async handleNegotiationRequest(data) {
    const { id, request } = data;
    
    // 检查是否需要响应
    if (!this.shouldRespondToNegotiation(request)) {
      return;
    }
    
    // 生成响应
    const response = await this.generateNegotiationResponse(request);
    
    // 响应协商
    const negotiator = new AppNegotiator(this.appRegistry);
    negotiator.respondToNegotiation(id, response);
  }
  
  // 检查是否需要响应协商
  shouldRespondToNegotiation(request) {
    // 子类实现
    return false;
  }
  
  // 生成协商响应
  async generateNegotiationResponse(request) {
    // 子类实现
    return {};
  }
  
  // 渲染应用
  async render() {
    // 子类实现
  }
  
  // 清理应用
  async cleanup() {
    // 子类实现
  }
}

// 布局应用
class LayoutApp extends BaseApp {
  constructor(options) {
    super(options);
    this.layoutConfig = null;
  }
  
  // 检查是否需要响应协商
  shouldRespondToNegotiation(request) {
    return request.type === 'layout';
  }
  
  // 生成协商响应
  async generateNegotiationResponse(request) {
    return {
      app: this.name,
      layout: {
        areas: {
          header: { app: 'header-app' },
          sidebar: { app: 'sidebar-app' },
          main: { app: 'main-app' },
          footer: { app: 'footer-app' },
        },
      },
    };
  }
  
  // 渲染应用
  async render() {
    // 协商布局配置
    const negotiator = new AppNegotiator(this.appRegistry);
    this.layoutConfig = await negotiator.negotiate({
      type: 'layout',
      context: 'main-layout',
    });
    
    // 渲染布局
    this.container.innerHTML = this.getLayoutHTML(this.layoutConfig);
    
    // 启动子应用
    await this.startChildApps();
  }
  
  // 获取布局HTML
  getLayoutHTML(layoutConfig) {
    return `
      <div class="layout">
        <div id="header-area" class="header-area"></div>
        <div class="content-area">
          <div id="sidebar-area" class="sidebar-area"></div>
          <div id="main-area" class="main-area"></div>
        </div>
        <div id="footer-area" class="footer-area"></div>
      </div>
    `;
  }
  
  // 启动子应用
  async startChildApps() {
    const areas = this.layoutConfig.areas;
    
    for (const [areaName, areaConfig] of Object.entries(areas)) {
      const appName = areaConfig.app;
      const container = document.querySelector(`#${areaName}`);
      
      if (container && appName) {
        const instance = await this.appRegistry.createInstance(appName, {
          container,
        });
        
        await instance.start();
      }
    }
  }
  
  // 清理应用
  async cleanup() {
    // 停止子应用
    const instances = this.appRegistry.getAllInstances();
    for (const { instance } of instances) {
      await instance.stop();
    }
    
    // 清理容器
    this.container.innerHTML = '';
  }
}

// 使用示例
const appRegistry = new AppRegistry();

// 注册应用
appRegistry.registerApp('layout-app', {
  entry: () => import('./apps/layout'),
  capabilities: ['layout'],
});

appRegistry.registerApp('header-app', {
  entry: () => import('./apps/header'),
  capabilities: ['ui'],
});

appRegistry.registerApp('sidebar-app', {
  entry: () => import('./apps/sidebar'),
  capabilities: ['ui', 'navigation'],
});

appRegistry.registerApp('main-app', {
  entry: () => import('./apps/main'),
  capabilities: ['ui', 'routing'],
});

appRegistry.registerApp('footer-app', {
  entry: () => import('./apps/footer'),
  capabilities: ['ui'],
});

// 创建并启动布局应用
appRegistry.createInstance('layout-app', {
  container: document.querySelector('#app-container'),
}).then(instance => {
  instance.start();
});
```

### 2.4.3 微应用模式

微应用模式（Micro Application Pattern）是一种细粒度的微前端架构模式，它将前端应用拆分为更小的微应用单元，每个微应用负责一个特定的功能或页面。

**模式特点：：**

1. **细粒度拆分**：将应用拆分为更小的微应用单元，每个单元负责特定功能或页面。

2. **独立部署**：每个微应用可以独立部署和运行。

3. **按需加载**：根据用户需求动态加载微应用。

4. **功能组合**：通过组合不同的微应用实现完整的业务功能。

**适用场景：：**

1. **功能复杂应用**：适合功能复杂的应用，需要细粒度拆分和管理。

2. **多租户应用**：适合多租户应用，不同租户需要不同功能组合。

3. **插件化应用**：适合插件化应用，支持动态添加和移除功能。

**实现方式：：**

1. **微应用注册**：维护一个微应用注册表，记录所有可用微应用。

2. **按需加载**：根据用户需求动态加载微应用。

3. **应用组合**：通过组合不同的微应用实现完整的业务功能。

4. **状态管理**：通过状态管理机制保持微应用间状态一致。

**示例代码：：**

```javascript
// 微应用管理器
class MicroAppManager {
  constructor() {
    this.apps = new Map();
    this.instances = new Map();
    this.eventBus = new EventBus();
    this.stateManager = new StateManager();
  }
  
  // 注册微应用
  registerApp(name, config) {
    this.apps.set(name, {
      name,
      ...config,
      status: 'registered',
    });
    
    // 发布应用注册事件
    this.eventBus.emit('app:registered', { name, config });
  }
  
  // 注销微应用
  unregisterApp(name) {
    if (this.apps.has(name)) {
      this.apps.delete(name);
      
      // 发布应用注销事件
      this.eventBus.emit('app:unregistered', { name });
    }
  }
  
  // 加载微应用
  async loadApp(name, options = {}) {
    const app = this.apps.get(name);
    if (!app) {
      throw new Error(`App ${name} not found`);
    }
    
    // 检查是否已有实例
    if (this.instances.has(name)) {
      return this.instances.get(name);
    }
    
    try {
      // 动态加载应用代码
      const appModule = await import(app.entry);
      
      // 创建应用实例
      const instance = appModule.default({
        ...options,
        eventBus: this.eventBus,
        stateManager: this.stateManager,
      });
      
      // 保存应用实例
      this.instances.set(name, instance);
      
      // 发布实例创建事件
      this.eventBus.emit('instance:created', { name, instance });
      
      return instance;
    } catch (error) {
      console.error(`Failed to load app ${name}:`, error);
      throw error;
    }
  }
  
  // 卸载微应用
  async unloadApp(name) {
    const instance = this.instances.get(name);
    if (!instance) {
      return;
    }
    
    try {
      // 销毁实例
      if (instance.destroy) {
        await instance.destroy();
      }
      
      // 移除实例
      this.instances.delete(name);
      
      // 发布实例销毁事件
      this.eventBus.emit('instance:destroyed', { name });
    } catch (error) {
      console.error(`Failed to unload app ${name}:`, error);
      throw error;
    }
  }
  
  // 获取微应用实例
  getInstance(name) {
    return this.instances.get(name);
  }
  
  // 获取所有实例
  getAllInstances() {
    return Array.from(this.instances.entries()).map(([name, instance]) => ({
      name,
      instance,
    }));
  }
}

// 页面组合器
class PageComposer {
  constructor(microAppManager) {
    this.microAppManager = microAppManager;
    this.pages = new Map();
    this.eventBus = microAppManager.eventBus;
  }
  
  // 注册页面
  registerPage(name, config) {
    this.pages.set(name, {
      name,
      ...config,
      status: 'registered',
    });
    
    // 发布页面注册事件
    this.eventBus.emit('page:registered', { name, config });
  }
  
  // 渲染页面
  async renderPage(name, container) {
    const page = this.pages.get(name);
    if (!page) {
      throw new Error(`Page ${name} not found`);
    }
    
    try {
      // 清空容器
      container.innerHTML = '';
      
      // 渲染页面布局
      const layoutElement = this.createLayoutElement(page.layout);
      container.appendChild(layoutElement);
      
      // 加载并渲染微应用
      await this.renderMicroApps(page.apps);
      
      // 发布页面渲染事件
      this.eventBus.emit('page:rendered', { name });
    } catch (error) {
      console.error(`Failed to render page ${name}:`, error);
      throw error;
    }
  }
  
  // 创建布局元素
  createLayoutElement(layoutConfig) {
    const layoutElement = document.createElement('div');
    layoutElement.className = 'page-layout';
    
    // 根据布局配置创建布局元素
    for (const [areaName, areaConfig] of Object.entries(layoutConfig.areas)) {
      const areaElement = document.createElement('div');
      areaElement.id = areaName;
      areaElement.className = `area ${areaName}`;
      
      // 设置区域样式
      if (areaConfig.style) {
        Object.assign(areaElement.style, areaConfig.style);
      }
      
      layoutElement.appendChild(areaElement);
    }
    
    return layoutElement;
  }
  
  // 渲染微应用
  async renderMicroApps(appConfigs) {
    for (const appConfig of appConfigs) {
      const { name, area, props } = appConfig;
      
      try {
        // 加载微应用
        const instance = await this.microAppManager.loadApp(name, { props });
        
        // 获取容器
        const container = document.querySelector(`#${area}`);
        if (!container) {
          console.warn(`Container ${area} not found for app ${name}`);
          continue;
        }
        
        // 渲染微应用
        await instance.render(container);
      } catch (error) {
        console.error(`Failed to render app ${name}:`, error);
      }
    }
  }
  
  // 卸载页面
  async unmountPage(name) {
    const page = this.pages.get(name);
    if (!page) {
      return;
    }
    
    try {
      // 卸载微应用
      for (const appConfig of page.apps) {
        await this.microAppManager.unloadApp(appConfig.name);
      }
      
      // 发布页面卸载事件
      this.eventBus.emit('page:unmounted', { name });
    } catch (error) {
      console.error(`Failed to unmount page ${name}:`, error);
      throw error;
    }
  }
}

// 状态管理器
class StateManager {
  constructor() {
    this.state = {};
    this.listeners = new Map();
  }
  
  // 设置状态
  setState(key, value) {
    const oldValue = this.state[key];
    this.state[key] = value;
    
    // 通知监听器
    if (this.listeners.has(key)) {
      this.listeners.get(key).forEach(listener => listener(value, oldValue));
    }
  }
  
  // 获取状态
  getState(key) {
    return this.state[key];
  }
  
  // 订阅状态变化
  subscribe(key, listener) {
    if (!this.listeners.has(key)) {
      this.listeners.set(key, []);
    }
    this.listeners.get(key).push(listener);
    
    // 返回取消订阅函数
    return () => {
      const listeners = this.listeners.get(key);
      const index = listeners.indexOf(listener);
      if (index !== -1) {
        listeners.splice(index, 1);
      }
    };
  }
  
  // 批量设置状态
  batchSetState(stateUpdates) {
    const oldValues = {};
    
    // 保存旧值
    for (const key of Object.keys(stateUpdates)) {
      oldValues[key] = this.state[key];
    }
    
    // 设置新值
    Object.assign(this.state, stateUpdates);
    
    // 通知监听器
    for (const [key, value] of Object.entries(stateUpdates)) {
      if (this.listeners.has(key)) {
        this.listeners.get(key).forEach(listener => listener(value, oldValues[key]));
      }
    }
  }
}

// 微应用基类
class BaseMicroApp {
  constructor(options) {
    this.name = options.name;
    this.eventBus = options.eventBus;
    this.stateManager = options.stateManager;
    this.props = options.props || {};
    this.container = null;
    this.status = 'created';
  }
  
  // 渲染应用
  async render(container) {
    if (this.status !== 'created') {
      return;
    }
    
    this.status = 'rendering';
    this.container = container;
    
    try {
      // 渲染应用UI
      await this.renderUI();
      
      // 绑定事件
      this.bindEvents();
      
      // 初始化状态
      await this.initState();
      
      // 发布应用渲染事件
      this.eventBus.emit('app:rendered', { name: this.name });
      
      this.status = 'rendered';
    } catch (error) {
      console.error(`Failed to render app ${this.name}:`, error);
      this.status = 'error';
      throw error;
    }
  }
  
  // 销毁应用
  async destroy() {
    if (this.status !== 'rendered') {
      return;
    }
    
    this.status = 'destroying';
    
    try {
      // 解绑事件
      this.unbindEvents();
      
      // 清理状态
      this.cleanupState();
      
      // 清理UI
      this.cleanupUI();
      
      // 发布应用销毁事件
      this.eventBus.emit('app:destroyed', { name: this.name });
      
      this.status = 'destroyed';
    } catch (error) {
      console.error(`Failed to destroy app ${this.name}:`, error);
      this.status = 'error';
      throw error;
    }
  }
  
  // 渲染UI
  async renderUI() {
    // 子类实现
  }
  
  // 绑定事件
  bindEvents() {
    // 子类实现
  }
  
  // 解绑事件
  unbindEvents() {
    // 子类实现
  }
  
  // 初始化状态
  async initState() {
    // 子类实现
  }
  
  // 清理状态
  cleanupState() {
    // 子类实现
  }
  
  // 清理UI
  cleanupUI() {
    if (this.container) {
      this.container.innerHTML = '';
    }
  }
}

// 用户列表微应用
class UserListMicroApp extends BaseMicroApp {
  constructor(options) {
    super(options);
    this.users = [];
  }
  
  // 渲染UI
  async renderUI() {
    this.container.innerHTML = `
      <div class="user-list">
        <h2>User List</h2>
        <div class="user-filters">
          <input type="text" id="search-input" placeholder="Search users...">
          <select id="role-filter">
            <option value="">All Roles</option>
            <option value="admin">Admin</option>
            <option value="user">User</option>
          </select>
        </div>
        <div class="user-table">
          <table>
            <thead>
              <tr>
                <th>ID</th>
                <th>Name</th>
                <th>Email</th>
                <th>Role</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="user-tbody">
              <!-- User rows will be inserted here -->
            </tbody>
          </table>
        </div>
        <div class="pagination">
          <button id="prev-page">Previous</button>
          <span id="page-info">Page 1 of 1</span>
          <button id="next-page">Next</button>
        </div>
      </div>
    `;
  }
  
  // 绑定事件
  bindEvents() {
    // 搜索输入
    const searchInput = this.container.querySelector('#search-input');
    searchInput.addEventListener('input', this.handleSearch.bind(this));
    
    // 角色筛选
    const roleFilter = this.container.querySelector('#role-filter');
    roleFilter.addEventListener('change', this.handleRoleFilter.bind(this));
    
    // 分页按钮
    const prevButton = this.container.querySelector('#prev-page');
    prevButton.addEventListener('click', this.handlePrevPage.bind(this));
    
    const nextButton = this.container.querySelector('#next-page');
    nextButton.addEventListener('click', this.handleNextPage.bind(this));
  }
  
  // 解绑事件
  unbindEvents() {
    // 搜索输入
    const searchInput = this.container.querySelector('#search-input');
    searchInput.removeEventListener('input', this.handleSearch.bind(this));
    
    // 角色筛选
    const roleFilter = this.container.querySelector('#role-filter');
    roleFilter.removeEventListener('change', this.handleRoleFilter.bind(this));
    
    // 分页按钮
    const prevButton = this.container.querySelector('#prev-page');
    prevButton.removeEventListener('click', this.handlePrevPage.bind(this));
    
    const nextButton = this.container.querySelector('#next-page');
    nextButton.removeEventListener('click', this.handleNextPage.bind(this));
  }
  
  // 初始化状态
  async initState() {
    // 订阅用户状态变化
    this.stateManager.subscribe('users', this.handleUsersChange.bind(this));
    
    // 加载用户数据
    await this.loadUsers();
  }
  
  // 清理状态
  cleanupState() {
    // 取消订阅用户状态变化
    this.stateManager.unsubscribe('users', this.handleUsersChange.bind(this));
  }
  
  // 加载用户数据
  async loadUsers() {
    try {
      // 从API获取用户数据
      const response = await fetch('/api/users');
      const users = await response.json();
      
      // 更新状态
      this.stateManager.setState('users', users);
    } catch (error) {
      console.error('Failed to load users:', error);
    }
  }
  
  // 处理用户状态变化
  handleUsersChange(users) {
    this.users = users;
    this.renderUserTable();
  }
  
  // 渲染用户表格
  renderUserTable() {
    const tbody = this.container.querySelector('#user-tbody');
    tbody.innerHTML = '';
    
    for (const user of this.users) {
      const row = document.createElement('tr');
      row.innerHTML = `
        <td>${user.id}</td>
        <td>${user.name}</td>
        <td>${user.email}</td>
        <td>${user.role}</td>
        <td>
          <button data-user-id="${user.id}" class="edit-btn">Edit</button>
          <button data-user-id="${user.id}" class="delete-btn">Delete</button>
        </td>
      `;
      tbody.appendChild(row);
    }
    
    // 绑定行按钮事件
    const editButtons = tbody.querySelectorAll('.edit-btn');
    editButtons.forEach(button => {
      button.addEventListener('click', this.handleEditUser.bind(this));
    });
    
    const deleteButtons = tbody.querySelectorAll('.delete-btn');
    deleteButtons.forEach(button => {
      button.addEventListener('click', this.handleDeleteUser.bind(this));
    });
  }
  
  // 处理搜索
  handleSearch(event) {
    const searchTerm = event.target.value.toLowerCase();
    const filteredUsers = this.users.filter(user =>
      user.name.toLowerCase().includes(searchTerm) ||
      user.email.toLowerCase().includes(searchTerm)
    );
    
    // 临时渲染过滤后的用户
    this.renderFilteredUsers(filteredUsers);
  }
  
  // 处理角色筛选
  handleRoleFilter(event) {
    const role = event.target.value;
    const filteredUsers = role
      ? this.users.filter(user => user.role === role)
      : this.users;
    
    // 临时渲染过滤后的用户
    this.renderFilteredUsers(filteredUsers);
  }
  
  // 渲染过滤后的用户
  renderFilteredUsers(users) {
    const tbody = this.container.querySelector('#user-tbody');
    tbody.innerHTML = '';
    
    for (const user of users) {
      const row = document.createElement('tr');
      row.innerHTML = `
        <td>${user.id}</td>
        <td>${user.name}</td>
        <td>${user.email}</td>
        <td>${user.role}</td>
        <td>
          <button data-user-id="${user.id}" class="edit-btn">Edit</button>
          <button data-user-id="${user.id}" class="delete-btn">Delete</button>
        </td>
      `;
      tbody.appendChild(row);
    }
  }
  
  // 处理编辑用户
  handleEditUser(event) {
    const userId = event.target.dataset.userId;
    
    // 发布编辑用户事件
    this.eventBus.emit('user:edit', { userId });
  }
  
  // 处理删除用户
  handleDeleteUser(event) {
    const userId = event.target.dataset.userId;
    
    // 发布删除用户事件
    this.eventBus.emit('user:delete', { userId });
  }
  
  // 处理上一页
  handlePrevPage() {
    // 实现分页逻辑
  }
  
  // 处理下一页
  handleNextPage() {
    // 实现分页逻辑
  }
}

// 使用示例
const microAppManager = new MicroAppManager();
const pageComposer = new PageComposer(microAppManager);

// 注册微应用
microAppManager.registerApp('user-list', {
  entry: () => import('./apps/user-list'),
});

microAppManager.registerApp('user-detail', {
  entry: () => import('./apps/user-detail'),
});

// 注册页面
pageComposer.registerPage('user-management', {
  layout: {
    areas: {
      header: { style: { height: '60px' } },
      sidebar: { style: { width: '250px' } },
      main: { style: { flex: 1 } },
      footer: { style: { height: '40px' } },
    },
  },
  apps: [
    { name: 'user-list', area: 'main' },
    { name: 'user-detail', area: 'sidebar' },
  ],
});

// 渲染页面
pageComposer.renderPage('user-management', document.querySelector('#app-container'));
```

## 2.5 架构评估与选择

### 2.5.1 评估维度

微前端架构评估需要从多个维度进行，以确保选择的架构适合项目需求。

**技术维度：：**

1. **技术栈兼容性**：评估架构对现有技术栈的兼容性。

2. **性能影响**：评估架构对应用性能的影响。

3. **开发复杂度**：评估架构对开发复杂度的影响。

4. **维护成本**：评估架构的维护成本。

**业务维度：：**

1. **业务适配性**：评估架构对业务需求的适配性。

2. **扩展性**：评估架构的业务扩展能力。

3. **灵活性**：评估架构对业务变化的灵活性。

4. **上线时间**：评估架构对业务上线时间的影响。

**团队维度：：**

1. **团队结构适配**：评估架构对团队结构的适配性。

2. **技能要求**：评估架构对团队技能的要求。

3. **协作效率**：评估架构对团队协作效率的影响。

4. **学习成本**：评估架构的学习成本。

**运维维度：：**

1. **部署复杂度**：评估架构的部署复杂度。

2. **监控难度**：评估架构的监控难度。

3. **故障排查**：评估架构的故障排查难度。

4. **资源消耗**：评估架构的资源消耗。

### 2.5.2 评估方法

微前端架构评估需要采用科学的方法，确保评估结果的客观性和准确性。

**定性评估：：**

1. **专家评审**：邀请领域专家对架构方案进行评审。

2. **团队讨论**：组织团队讨论，收集各方意见。

3. **案例研究**：研究类似案例，借鉴经验教训。

4. **原型验证**：构建原型，验证架构可行性。

**定量评估：：**

1. **性能测试**：进行性能测试，量化性能影响。

2. **开发效率测试**：进行开发效率测试，量化开发效率变化。

3. **资源消耗测试**：进行资源消耗测试，量化资源消耗。

4. **用户体验测试**：进行用户体验测试，量化用户体验变化。

**综合评估：：**

1. **多维度评分**：对每个维度进行评分，计算综合得分。

2. **权重分配**：根据项目需求，为不同维度分配权重。

3. **决策矩阵**：使用决策矩阵，比较不同架构方案。

4. **成本效益分析**：进行成本效益分析，评估投入产出比。

### 2.5.3 选择策略

微前端架构选择需要综合考虑多种因素，制定合理的选择策略。

**基于业务场景选择：：**

1. **企业级应用**：选择基座模式，便于统一管理和控制。

2. **平台型应用**：选择自组织模式，支持灵活组合和扩展。

3. **功能复杂应用**：选择微应用模式，实现细粒度拆分和管理。

4. **多租户应用**：选择混合模式，支持不同租户的定制需求。

**基于技术栈选择：：**

1. **技术栈统一**：选择基座模式，共享依赖和状态管理。

2. **技术栈多样**：选择自组织模式，支持不同技术栈共存。

3. **技术栈迁移**：选择混合模式，支持渐进式迁移。

4. **技术栈升级**：选择微应用模式，降低升级风险。

**基于团队结构选择：：**

1. **集中式团队**：选择基座模式，便于统一管理和协调。

2. **分布式团队**：选择自组织模式，减少团队间依赖。

3. **混合团队**：选择混合模式，适应不同团队特点。

4. **跨职能团队**：选择微应用模式，提高团队协作效率。

**基于项目阶段选择：：**

1. **项目初期**：选择基座模式，快速搭建基础架构。

2. **项目中期**：选择混合模式，根据需求灵活调整。

3. **项目后期**：选择微应用模式，优化性能和可维护性。

4. **项目重构**：选择自组织模式，支持平滑迁移。

## 2.6 架构设计最佳实践

### 2.6.1 设计原则

微前端架构设计需要遵循一些基本原则，确保架构的合理性和可维护性。

**高内聚低耦合：：**

1. **应用内高内聚**：每个微前端应用内部功能高度内聚。

2. **应用间低耦合**：微前端应用之间保持低耦合。

3. **接口设计**：设计清晰的应用接口，减少不必要的依赖。

4. **通信机制**：采用松耦合的通信机制，避免直接依赖。

**单一职责：：**

1. **应用职责单一**：每个微前端应用只负责单一职责。

2. **功能边界清晰**：明确定义每个应用的功能边界。

3. **变更隔离**：一个应用的变更不影响其他应用。

4. **测试独立**：每个应用可以独立测试。

**可扩展性：：**

1. **水平扩展**：支持通过增加应用实例实现水平扩展。

2. **垂直扩展**：支持通过增强应用功能实现垂直扩展。

3. **插件机制**：提供插件机制，支持功能扩展。

4. **配置驱动**：通过配置驱动应用行为，提高灵活性。

**可维护性：：**

1. **代码组织**：采用清晰的代码组织结构。

2. **文档完善**：提供完善的文档，降低维护成本。

3. **标准化**：制定标准化规范，提高代码质量。

4. **工具支持**：提供工具支持，简化维护工作。

### 2.6.2 设计模式

微前端架构设计可以借鉴一些成熟的设计模式，提高架构的质量和可维护性。

**发布-订阅模式：：**

1. **事件总线**：使用事件总线实现应用间的通信。

2. **解耦通信**：通过事件机制解耦应用间的直接依赖。

3. **异步通信**：支持异步通信，提高系统响应性。

4. **扩展性**：易于添加新的应用和功能。

**适配器模式：：**

1. **接口适配**：使用适配器模式适配不同技术栈的应用。

2. **统一接口**：提供统一的应用接口，屏蔽技术差异。

3. **兼容性**：提高系统对不同技术栈的兼容性。

4. **可插拔**：支持应用的插拔式管理。

**代理模式：：**

1. **沙箱代理**：使用代理模式实现应用沙箱隔离。

2. **资源代理**：代理应用资源访问，实现资源共享。

3. **API代理**：代理API请求，实现统一管理。

4. **缓存代理**：代理数据访问，提高性能。

**策略模式：：**

1. **加载策略**：使用策略模式实现不同的应用加载策略。

2. **路由策略**：使用策略模式实现不同的路由处理策略。

3. **通信策略**：使用策略模式实现不同的通信策略。

4. **部署策略**：使用策略模式实现不同的部署策略。

### 2.6.3 实施建议

微前端架构实施需要遵循一些建议，确保实施过程的顺利进行。

**渐进式实施：：**

1. **试点先行**：选择合适的模块进行试点，验证方案可行性。

2. **逐步推广**：基于试点经验，逐步推广到其他模块。

3. **风险控制**：控制实施风险，确保系统稳定性。

4. **持续优化**：根据实施情况，持续优化架构方案。

**团队培训：：**

1. **技术培训**：提供微前端相关技术培训。

2. **工具培训**：提供微前端工具链培训。

3. **规范培训**：提供微前端开发规范培训。

4. **最佳实践分享**：分享微前端最佳实践。

**工具支持：：**

1. **开发工具**：提供微前端开发工具支持。

2. **调试工具**：提供微前端调试工具支持。

3. **构建工具**：提供微前端构建工具支持。

4. **部署工具**：提供微前端部署工具支持。

**监控与反馈：：**

1. **性能监控**：实施微前端性能监控。

2. **错误监控**：实施微前端错误监控。

3. **用户反馈**：收集用户反馈，持续改进。

4. **数据分析**：分析监控数据，优化架构。

## 总结

本章详细介绍了微前端架构设计的各个方面，包括微前端设计原则、应用划分策略、架构演进路径、架构模式选择、架构评估与选择以及架构设计最佳实践。通过本章的学习，读者可以了解微前端架构设计的核心思想和实践方法，为实际项目中的微前端架构设计提供指导。

微前端架构设计是一个复杂的过程，需要综合考虑业务需求、技术栈、团队结构、运维要求等多个因素。选择合适的架构模式和实施策略，遵循设计原则和最佳实践，可以构建出高质量、可维护的微前端架构，提高开发效率和应用质量。

在下一章中，我们将介绍微前端路由与状态管理，这是微前端架构中的另一个重要方面，对于实现应用间的导航和数据共享至关重要。