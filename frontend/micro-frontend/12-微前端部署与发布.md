# 第十二章：微前端部署与发布

## 12.1 微前端部署概述

### 12.1.1 部署挑战

微前端架构带来的部署挑战主要包括：

1. **独立部署复杂性**
   - 多个应用独立部署的协调
   - 版本管理与兼容性
   - 部署顺序与依赖关系

2. **环境一致性**
   - 开发、测试、生产环境的一致性
   - 配置管理与环境变量
   - 依赖版本同步

3. **发布策略**
   - 灰度发布与蓝绿部署
   - 回滚策略与风险控制
   - 发布窗口与业务影响

4. **资源管理**
   - 静态资源缓存策略
   - CDN配置与优化
   - 资源版本控制

### 12.1.2 部署模式

微前端部署主要有以下几种模式：

1. **独立部署模式**
   - 每个微应用独立部署
   - 主应用通过配置加载子应用
   - 适合团队独立开发场景

2. **统一部署模式**
   - 所有应用统一构建部署
   - 版本一致性保证
   - 适合集中管理场景

3. **混合部署模式**
   - 核心应用统一部署
   - 业务应用独立部署
   - 平衡灵活性与一致性

4. **容器化部署**
   - 使用容器技术封装应用
   - 环境隔离与快速部署
   - 适合云原生场景

## 12.2 独立部署策略

### 12.2.1 配置中心管理

```javascript
// 示例：配置中心管理
class ConfigManager {
  constructor() {
    this.configCache = new Map();
    this.configVersion = new Map();
    this.subscribers = new Map();
  }

  // 获取应用配置
  async getAppConfig(appName, version = 'latest') {
    const cacheKey = `${appName}:${version}`;
    
    // 检查缓存
    if (this.configCache.has(cacheKey)) {
      return this.configCache.get(cacheKey);
    }
    
    // 从远程配置中心获取
    const config = await this.fetchConfig(appName, version);
    
    // 缓存配置
    this.configCache.set(cacheKey, config);
    this.configVersion.set(appName, version);
    
    return config;
  }

  // 更新应用配置
  async updateAppConfig(appName, config) {
    // 上传到配置中心
    const version = await this.uploadConfig(appName, config);
    
    // 更新缓存
    const cacheKey = `${appName}:${version}`;
    this.configCache.set(cacheKey, config);
    this.configVersion.set(appName, version);
    
    // 通知订阅者
    this.notifySubscribers(appName, config, version);
    
    return version;
  }

  // 订阅配置变化
  subscribeConfigChange(appName, callback) {
    if (!this.subscribers.has(appName)) {
      this.subscribers.set(appName, []);
    }
    
    this.subscribers.get(appName).push(callback);
    
    // 返回取消订阅函数
    return () => {
      const callbacks = this.subscribers.get(appName);
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    };
  }

  // 通知订阅者
  notifySubscribers(appName, config, version) {
    const callbacks = this.subscribers.get(appName);
    if (callbacks) {
      callbacks.forEach(callback => {
        try {
          callback(config, version);
        } catch (error) {
          console.error(`Error in config change callback for ${appName}:`, error);
        }
      });
    }
  }

  // 从远程获取配置
  async fetchConfig(appName, version) {
    const response = await fetch(`/api/config/${appName}/${version}`);
    if (!response.ok) {
      throw new Error(`Failed to fetch config for ${appName}:${version}`);
    }
    return response.json();
  }

  // 上传配置到远程
  async uploadConfig(appName, config) {
    const response = await fetch(`/api/config/${appName}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(config),
    });
    
    if (!response.ok) {
      throw new Error(`Failed to upload config for ${appName}`);
    }
    
    const result = await response.json();
    return result.version;
  }
}

// 导出单例
export const configManager = new ConfigManager();
```

### 12.2.2 应用注册与发现

```javascript
// 示例：应用注册与发现
class AppRegistry {
  constructor() {
    this.apps = new Map();
    this.healthCheckInterval = 30000; // 30秒
    this.healthCheckTimers = new Map();
  }

  // 注册应用
  registerApp(appConfig) {
    const { name, entry, activeRule, ...otherConfig } = appConfig;
    
    if (!name || !entry) {
      throw new Error('App name and entry are required');
    }
    
    const app = {
      name,
      entry,
      activeRule,
      ...otherConfig,
      status: 'registered',
      registeredAt: new Date(),
      lastHealthCheck: null,
    };
    
    this.apps.set(name, app);
    
    // 启动健康检查
    this.startHealthCheck(name);
    
    console.log(`App ${name} registered successfully`);
    return app;
  }

  // 注销应用
  unregisterApp(name) {
    if (!this.apps.has(name)) {
      throw new Error(`App ${name} not found`);
    }
    
    // 停止健康检查
    this.stopHealthCheck(name);
    
    this.apps.delete(name);
    console.log(`App ${name} unregistered successfully`);
  }

  // 获取应用信息
  getApp(name) {
    return this.apps.get(name);
  }

  // 获取所有应用
  getAllApps() {
    return Array.from(this.apps.values());
  }

  // 获取健康的应用
  getHealthyApps() {
    return this.getAllApps().filter(app => app.status === 'healthy');
  }

  // 启动健康检查
  startHealthCheck(name) {
    const timer = setInterval(() => {
      this.checkHealth(name);
    }, this.healthCheckInterval);
    
    this.healthCheckTimers.set(name, timer);
  }

  // 停止健康检查
  stopHealthCheck(name) {
    const timer = this.healthCheckTimers.get(name);
    if (timer) {
      clearInterval(timer);
      this.healthCheckTimers.delete(name);
    }
  }

  // 检查应用健康状态
  async checkHealth(name) {
    const app = this.apps.get(name);
    if (!app) return;
    
    try {
      const response = await fetch(`${app.entry}/health`, {
        method: 'GET',
        timeout: 5000,
      });
      
      if (response.ok) {
        const health = await response.json();
        app.status = health.status === 'ok' ? 'healthy' : 'unhealthy';
        app.lastHealthCheck = new Date();
      } else {
        app.status = 'unhealthy';
        app.lastHealthCheck = new Date();
      }
    } catch (error) {
      app.status = 'unhealthy';
      app.lastHealthCheck = new Date();
      console.error(`Health check failed for ${name}:`, error);
    }
  }

  // 更新应用配置
  updateApp(name, updates) {
    const app = this.apps.get(name);
    if (!app) {
      throw new Error(`App ${name} not found`);
    }
    
    Object.assign(app, updates);
    console.log(`App ${name} updated successfully`);
    return app;
  }
}

// 导出单例
export const appRegistry = new AppRegistry();
```

### 12.2.3 版本管理与兼容性

```javascript
// 示例：版本管理与兼容性
class VersionManager {
  constructor() {
    this.appVersions = new Map(); // appName -> [versions]
    this.compatibilityMatrix = new Map(); // version -> { dependencies, compatibleWith }
  }

  // 注册应用版本
  registerVersion(appName, version, metadata = {}) {
    if (!this.appVersions.has(appName)) {
      this.appVersions.set(appName, []);
    }
    
    const versions = this.appVersions.get(appName);
    
    // 检查版本是否已存在
    if (versions.some(v => v.version === version)) {
      throw new Error(`Version ${version} already exists for app ${appName}`);
    }
    
    const versionInfo = {
      version,
      publishedAt: new Date(),
      ...metadata,
    };
    
    versions.push(versionInfo);
    
    // 按版本号排序
    versions.sort((a, b) => this.compareVersions(b.version, a.version));
    
    return versionInfo;
  }

  // 获取应用最新版本
  getLatestVersion(appName) {
    const versions = this.appVersions.get(appName);
    return versions && versions.length > 0 ? versions[0] : null;
  }

  // 获取应用所有版本
  getAllVersions(appName) {
    return this.appVersions.get(appName) || [];
  }

  // 检查版本兼容性
  isCompatible(appName, version, dependencyVersions = {}) {
    const versionInfo = this.getVersionInfo(appName, version);
    if (!versionInfo) return false;
    
    // 检查依赖版本兼容性
    for (const [depApp, depVersion] of Object.entries(dependencyVersions)) {
      if (!this.isDependencyCompatible(appName, version, depApp, depVersion)) {
        return false;
      }
    }
    
    return true;
  }

  // 检查依赖兼容性
  isDependencyCompatible(appName, version, depApp, depVersion) {
    const compatibilityInfo = this.compatibilityMatrix.get(`${appName}:${version}`);
    if (!compatibilityInfo || !compatibilityInfo.dependencies) {
      return true; // 没有明确依赖信息，假设兼容
    }
    
    const depRequirement = compatibilityInfo.dependencies[depApp];
    if (!depRequirement) {
      return true; // 没有对此依赖的要求
    }
    
    return this.satisfiesVersionRange(depVersion, depRequirement);
  }

  // 设置版本兼容性信息
  setCompatibilityInfo(appName, version, compatibilityInfo) {
    this.compatibilityMatrix.set(`${appName}:${version}`, compatibilityInfo);
  }

  // 获取版本信息
  getVersionInfo(appName, version) {
    const versions = this.appVersions.get(appName);
    return versions ? versions.find(v => v.version === version) : null;
  }

  // 比较版本号
  compareVersions(a, b) {
    const aParts = a.split('.').map(Number);
    const bParts = b.split('.').map(Number);
    const maxLength = Math.max(aParts.length, bParts.length);
    
    for (let i = 0; i < maxLength; i++) {
      const aPart = aParts[i] || 0;
      const bPart = bParts[i] || 0;
      
      if (aPart > bPart) return 1;
      if (aPart < bPart) return -1;
    }
    
    return 0;
  }

  // 检查版本是否满足范围
  satisfiesVersionRange(version, range) {
    // 简单实现，实际项目中可以使用semver等库
    if (range === '*') return true;
    
    if (range.startsWith('^')) {
      const minVersion = range.substring(1);
      return this.compareVersions(version, minVersion) >= 0;
    }
    
    if (range.startsWith('~')) {
      const minVersion = range.substring(1);
      const minParts = minVersion.split('.').map(Number);
      const versionParts = version.split('.').map(Number);
      
      // 主版本和次版本必须匹配，补丁版本可以大于等于
      return (
        versionParts[0] === minParts[0] &&
        versionParts[1] === minParts[1] &&
        versionParts[2] >= minParts[2]
      );
    }
    
    // 精确匹配
    return version === range;
  }
}

// 导出单例
export const versionManager = new VersionManager();
```

## 12.3 统一部署策略

### 12.3.1 构建流水线设计

```yaml
# 示例：统一部署构建流水线
name: Micro Frontend Unified Deployment

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      main-app: ${{ steps.changes.outputs.main-app }}
      app1: ${{ steps.changes.outputs.app1 }}
      app2: ${{ steps.changes.outputs.app2 }}
      shared: ${{ steps.changes.outputs.shared }}
    steps:
    - uses: actions/checkout@v3
    - uses: dorny/paths-filter@v2
      id: changes
      with:
        filters: |
          main-app:
            - 'apps/main/**'
          app1:
            - 'apps/app1/**'
          app2:
            - 'apps/app2/**'
          shared:
            - 'packages/shared/**'

  build-shared:
    needs: detect-changes
    if: needs.detect-changes.outputs.shared == 'true'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Build shared packages
      run: npm run build:shared
    
    - name: Publish shared packages
      run: npm run publish:shared
      env:
        NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

  build-main-app:
    needs: [detect-changes, build-shared]
    if: needs.detect-changes.outputs.main-app == 'true' || needs.detect-changes.outputs.shared == 'true'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Build main app
      run: npm run build:main
    
    - name: Build Docker image
      run: |
        docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-main:${{ github.sha }} .
        docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-main:${{ github.sha }} ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-main:latest
    
    - name: Log in to Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Push Docker image
      run: |
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-main:${{ github.sha }}
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-main:latest

  build-app1:
    needs: [detect-changes, build-shared]
    if: needs.detect-changes.outputs.app1 == 'true' || needs.detect-changes.outputs.shared == 'true'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Build app1
      run: npm run build:app1
    
    - name: Build Docker image
      run: |
        docker build -f apps/app1/Dockerfile -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-app1:${{ github.sha }} .
        docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-app1:${{ github.sha }} ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-app1:latest
    
    - name: Log in to Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Push Docker image
      run: |
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-app1:${{ github.sha }}
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-app1:latest

  build-app2:
    needs: [detect-changes, build-shared]
    if: needs.detect-changes.outputs.app2 == 'true' || needs.detect-changes.outputs.shared == 'true'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Build app2
      run: npm run build:app2
    
    - name: Build Docker image
      run: |
        docker build -f apps/app2/Dockerfile -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-app2:${{ github.sha }} .
        docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-app2:${{ github.sha }} ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-app2:latest
    
    - name: Log in to Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Push Docker image
      run: |
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-app2:${{ github.sha }}
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-app2:latest

  deploy-staging:
    needs: [build-main-app, build-app1, build-app2]
    if: github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    steps:
    - name: Deploy to staging
      run: |
        echo "Deploying to staging environment"
        # 部署到测试环境的脚本
        # kubectl apply -f k8s/staging/

  deploy-production:
    needs: [build-main-app, build-app1, build-app2]
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
    - name: Deploy to production
      run: |
        echo "Deploying to production environment"
        # 部署到生产环境的脚本
        # kubectl apply -f k8s/production/
```

### 12.3.2 版本发布管理

```javascript
// 示例：版本发布管理
class ReleaseManager {
  constructor() {
    this.releases = new Map(); // releaseId -> releaseInfo
    this.activeReleases = new Map(); // environment -> releaseId
  }

  // 创建发布版本
  createRelease(releaseInfo) {
    const {
      name,
      version,
      apps, // { appName: version }
      environment,
      description,
      scheduledAt,
    } = releaseInfo;
    
    if (!name || !version || !apps || !environment) {
      throw new Error('Name, version, apps, and environment are required');
    }
    
    const releaseId = `${name}-${version}-${Date.now()}`;
    const release = {
      id: releaseId,
      name,
      version,
      apps,
      environment,
      description,
      status: 'created',
      createdAt: new Date(),
      scheduledAt: scheduledAt ? new Date(scheduledAt) : null,
      deployedAt: null,
      rollbackInfo: null,
    };
    
    this.releases.set(releaseId, release);
    
    console.log(`Release ${releaseId} created successfully`);
    return release;
  }

  // 部署发布版本
  async deployRelease(releaseId) {
    const release = this.releases.get(releaseId);
    if (!release) {
      throw new Error(`Release ${releaseId} not found`);
    }
    
    if (release.status !== 'created') {
      throw new Error(`Release ${releaseId} is not in a deployable state`);
    }
    
    // 检查是否有其他发布正在进行
    const currentRelease = this.activeReleases.get(release.environment);
    if (currentRelease) {
      throw new Error(`Another release ${currentRelease} is already active in ${release.environment}`);
    }
    
    try {
      // 标记发布为进行中
      release.status = 'deploying';
      this.activeReleases.set(release.environment, releaseId);
      
      // 执行部署前检查
      await this.runPreDeploymentChecks(release);
      
      // 执行部署
      await this.executeDeployment(release);
      
      // 执行部署后验证
      await this.runPostDeploymentValidations(release);
      
      // 标记发布为成功
      release.status = 'deployed';
      release.deployedAt = new Date();
      
      console.log(`Release ${releaseId} deployed successfully to ${release.environment}`);
      return release;
    } catch (error) {
      // 部署失败，回滚
      release.status = 'failed';
      console.error(`Release ${releaseId} deployment failed:`, error);
      
      // 尝试自动回滚
      try {
        await this.rollbackRelease(releaseId);
      } catch (rollbackError) {
        console.error(`Auto rollback failed for release ${releaseId}:`, rollbackError);
      }
      
      throw error;
    }
  }

  // 回滚发布版本
  async rollbackRelease(releaseId) {
    const release = this.releases.get(releaseId);
    if (!release) {
      throw new Error(`Release ${releaseId} not found`);
    }
    
    if (release.status !== 'deployed' && release.status !== 'failed') {
      throw new Error(`Cannot rollback release ${releaseId} with status ${release.status}`);
    }
    
    try {
      // 获取上一个成功的发布
      const previousRelease = await this.getPreviousSuccessfulRelease(release.environment);
      if (!previousRelease) {
        throw new Error(`No previous successful release found for ${release.environment}`);
      }
      
      // 执行回滚
      await this.executeDeployment(previousRelease);
      
      // 更新回滚信息
      release.status = 'rolled_back';
      release.rollbackInfo = {
        rolledBackAt: new Date(),
        rolledBackTo: previousRelease.id,
      };
      
      // 更新活动发布
      this.activeReleases.set(release.environment, previousRelease.id);
      
      console.log(`Release ${releaseId} rolled back to ${previousRelease.id}`);
      return release;
    } catch (error) {
      console.error(`Rollback failed for release ${releaseId}:`, error);
      throw error;
    }
  }

  // 获取上一个成功的发布
  async getPreviousSuccessfulRelease(environment) {
    const releases = Array.from(this.releases.values())
      .filter(r => r.environment === environment && r.status === 'deployed')
      .sort((a, b) => b.deployedAt - a.deployedAt);
    
    return releases.length > 0 ? releases[0] : null;
  }

  // 执行部署前检查
  async runPreDeploymentChecks(release) {
    // 检查应用健康状态
    for (const [appName, appVersion] of Object.entries(release.apps)) {
      const isHealthy = await this.checkAppHealth(appName, appVersion);
      if (!isHealthy) {
        throw new Error(`App ${appName} version ${appVersion} is not healthy`);
      }
    }
    
    // 检查依赖兼容性
    const isCompatible = await this.checkCompatibility(release.apps);
    if (!isCompatible) {
      throw new Error('App versions are not compatible');
    }
  }

  // 执行部署
  async executeDeployment(release) {
    // 更新配置中心
    for (const [appName, appVersion] of Object.entries(release.apps)) {
      await configManager.updateAppConfig(appName, { version: appVersion });
    }
    
    // 通知应用注册表
    for (const [appName, appVersion] of Object.entries(release.apps)) {
      await appRegistry.updateApp(appName, { version: appVersion });
    }
  }

  // 执行部署后验证
  async runPostDeploymentValidations(release) {
    // 等待应用启动
    await new Promise(resolve => setTimeout(resolve, 30000));
    
    // 检查应用健康状态
    for (const [appName, appVersion] of Object.entries(release.apps)) {
      const isHealthy = await this.checkAppHealth(appName, appVersion);
      if (!isHealthy) {
        throw new Error(`App ${appName} version ${appVersion} is not healthy after deployment`);
      }
    }
    
    // 运行端到端测试
    const testsPassed = await this.runE2ETests();
    if (!testsPassed) {
      throw new Error('E2E tests failed after deployment');
    }
  }

  // 检查应用健康状态
  async checkAppHealth(appName, version) {
    try {
      const response = await fetch(`/api/apps/${appName}/versions/${version}/health`);
      return response.ok;
    } catch (error) {
      return false;
    }
  }

  // 检查兼容性
  async checkCompatibility(appVersions) {
    // 实现兼容性检查逻辑
    return true;
  }

  // 运行端到端测试
  async runE2ETests() {
    try {
      const response = await fetch('/api/tests/e2e', { method: 'POST' });
      const result = await response.json();
      return result.success;
    } catch (error) {
      return false;
    }
  }

  // 获取发布信息
  getRelease(releaseId) {
    return this.releases.get(releaseId);
  }

  // 获取所有发布
  getAllReleases() {
    return Array.from(this.releases.values());
  }

  // 获取环境的活动发布
  getActiveRelease(environment) {
    const releaseId = this.activeReleases.get(environment);
    return releaseId ? this.releases.get(releaseId) : null;
  }
}

// 导出单例
export const releaseManager = new ReleaseManager();
```

## 12.4 容器化部署

### 12.4.1 Docker容器化

```dockerfile
# 示例：主应用Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# 复制package文件
COPY package*.json ./
COPY apps/main/package*.json ./apps/main/
COPY packages/shared/package*.json ./packages/shared/

# 安装依赖
RUN npm ci --only=production

# 复制源代码
COPY . .

# 构建应用
RUN npm run build:main

# 生产环境镜像
FROM nginx:alpine

# 复制构建产物
COPY --from=builder /app/apps/main/dist /usr/share/nginx/html

# 复制nginx配置
COPY apps/main/nginx.conf /etc/nginx/nginx.conf

# 暴露端口
EXPOSE 80

# 启动nginx
CMD ["nginx", "-g", "daemon off;"]
```

```dockerfile
# 示例：子应用Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# 复制package文件
COPY package*.json ./
COPY apps/app1/package*.json ./apps/app1/
COPY packages/shared/package*.json ./packages/shared/

# 安装依赖
RUN npm ci --only=production

# 复制源代码
COPY . .

# 构建应用
RUN npm run build:app1

# 生产环境镜像
FROM nginx:alpine

# 复制构建产物
COPY --from=builder /app/apps/app1/dist /usr/share/nginx/html

# 复制nginx配置
COPY apps/app1/nginx.conf /etc/nginx/nginx.conf

# 暴露端口
EXPOSE 80

# 启动nginx
CMD ["nginx", "-g", "daemon off;"]
```

### 12.4.2 Kubernetes部署配置

```yaml
# 示例：主应用Kubernetes部署配置
apiVersion: apps/v1
kind: Deployment
metadata:
  name: main-app
  labels:
    app: main-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: main-app
  template:
    metadata:
      labels:
        app: main-app
    spec:
      containers:
      - name: main-app
        image: ghcr.io/your-org/micro-frontend-main:latest
        ports:
        - containerPort: 80
        env:
        - name: NODE_ENV
          value: "production"
        - name: CONFIG_API_URL
          value: "https://config-api.example.com"
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: main-app-service
spec:
  selector:
    app: main-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: main-app-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  tls:
  - hosts:
    - app.example.com
    secretName: main-app-tls
  rules:
  - host: app.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: main-app-service
            port:
              number: 80
```

```yaml
# 示例：子应用Kubernetes部署配置
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app1
  labels:
    app: app1
spec:
  replicas: 2
  selector:
    matchLabels:
      app: app1
  template:
    metadata:
      labels:
        app: app1
    spec:
      containers:
      - name: app1
        image: ghcr.io/your-org/micro-frontend-app1:latest
        ports:
        - containerPort: 80
        env:
        - name: NODE_ENV
          value: "production"
        - name: CONFIG_API_URL
          value: "https://config-api.example.com"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: app1-service
spec:
  selector:
    app: app1
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app1-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/rewrite-target: /app1/
spec:
  tls:
  - hosts:
    - app1.example.com
    secretName: app1-tls
  rules:
  - host: app.example.com
    http:
      paths:
      - path: /app1
        pathType: Prefix
        backend:
          service:
            name: app1-service
            port:
              number: 80
```

## 12.5 灰度发布与蓝绿部署

### 12.5.1 灰度发布实现

```javascript
// 示例：灰度发布实现
class CanaryDeployment {
  constructor() {
    this.canaryConfigs = new Map(); // appName -> canaryConfig
    this.trafficRules = new Map(); // appName -> trafficRules
  }

  // 配置灰度发布
  configureCanary(appName, config) {
    const {
      version,
      percentage = 10, // 默认10%流量
      criteria, // 灰度标准，如用户ID、地区等
      duration = 3600000, // 默认1小时
      autoPromote = true, // 是否自动提升
      successThreshold = 99, // 成功阈值，百分比
    } = config;
    
    const canaryConfig = {
      appName,
      version,
      percentage,
      criteria,
      duration,
      autoPromote,
      successThreshold,
      status: 'configured',
      createdAt: new Date(),
      startedAt: null,
      endedAt: null,
      metrics: {
        totalRequests: 0,
        successRequests: 0,
        errorRequests: 0,
        avgResponseTime: 0,
      },
    };
    
    this.canaryConfigs.set(appName, canaryConfig);
    
    // 设置流量规则
    this.setTrafficRules(appName, version, percentage, criteria);
    
    console.log(`Canary deployment configured for ${appName} version ${version}`);
    return canaryConfig;
  }

  // 启动灰度发布
  startCanary(appName) {
    const canaryConfig = this.canaryConfigs.get(appName);
    if (!canaryConfig) {
      throw new Error(`Canary config not found for ${appName}`);
    }
    
    if (canaryConfig.status !== 'configured') {
      throw new Error(`Cannot start canary for ${appName} with status ${canaryConfig.status}`);
    }
    
    canaryConfig.status = 'running';
    canaryConfig.startedAt = new Date();
    
    // 启动监控
    this.startMonitoring(appName);
    
    // 设置自动结束定时器
    setTimeout(() => {
      this.endCanary(appName);
    }, canaryConfig.duration);
    
    console.log(`Canary deployment started for ${appName}`);
    return canaryConfig;
  }

  // 结束灰度发布
  async endCanary(appName) {
    const canaryConfig = this.canaryConfigs.get(appName);
    if (!canaryConfig) {
      throw new Error(`Canary config not found for ${appName}`);
    }
    
    if (canaryConfig.status !== 'running') {
      return canaryConfig;
    }
    
    canaryConfig.status = 'ending';
    canaryConfig.endedAt = new Date();
    
    // 停止监控
    this.stopMonitoring(appName);
    
    // 计算成功率
    const successRate = canaryConfig.metrics.totalRequests > 0
      ? (canaryConfig.metrics.successRequests / canaryConfig.metrics.totalRequests) * 100
      : 0;
    
    // 判断是否成功
    const isSuccess = successRate >= canaryConfig.successThreshold;
    
    if (isSuccess) {
      // 成功，提升版本
      if (canaryConfig.autoPromote) {
        await this.promoteCanary(appName);
        canaryConfig.status = 'promoted';
      } else {
        canaryConfig.status = 'success';
      }
    } else {
      // 失败，回滚
      await this.rollbackCanary(appName);
      canaryConfig.status = 'failed';
    }
    
    // 清理流量规则
    this.clearTrafficRules(appName);
    
    console.log(`Canary deployment ended for ${appName} with status ${canaryConfig.status}`);
    return canaryConfig;
  }

  // 提升灰度版本
  async promoteCanary(appName) {
    const canaryConfig = this.canaryConfigs.get(appName);
    if (!canaryConfig) {
      throw new Error(`Canary config not found for ${appName}`);
    }
    
    // 更新应用版本
    await appRegistry.updateApp(appName, {
      version: canaryConfig.version,
      status: 'healthy',
    });
    
    // 更新配置中心
    await configManager.updateAppConfig(appName, {
      version: canaryConfig.version,
    });
    
    console.log(`Canary version promoted for ${appName}`);
  }

  // 回滚灰度版本
  async rollbackCanary(appName) {
    const canaryConfig = this.canaryConfigs.get(appName);
    if (!canaryConfig) {
      throw new Error(`Canary config not found for ${appName}`);
    }
    
    // 获取当前稳定版本
    const currentApp = appRegistry.getApp(appName);
    const stableVersion = currentApp && currentApp.version !== canaryConfig.version
      ? currentApp.version
      : await this.getPreviousStableVersion(appName);
    
    if (!stableVersion) {
      throw new Error(`No stable version found for ${appName}`);
    }
    
    // 更新应用版本
    await appRegistry.updateApp(appName, {
      version: stableVersion,
      status: 'healthy',
    });
    
    // 更新配置中心
    await configManager.updateAppConfig(appName, {
      version: stableVersion,
    });
    
    console.log(`Canary version rolled back for ${appName} to ${stableVersion}`);
  }

  // 设置流量规则
  setTrafficRules(appName, version, percentage, criteria) {
    const rules = {
      version,
      percentage,
      criteria,
    };
    
    this.trafficRules.set(appName, rules);
    
    // 这里应该调用实际的流量管理API
    console.log(`Traffic rules set for ${appName}: ${percentage}% to version ${version}`);
  }

  // 清理流量规则
  clearTrafficRules(appName) {
    this.trafficRules.delete(appName);
    
    // 这里应该调用实际的流量管理API
    console.log(`Traffic rules cleared for ${appName}`);
  }

  // 启动监控
  startMonitoring(appName) {
    // 实现监控逻辑，收集指标
    console.log(`Monitoring started for ${appName} canary`);
  }

  // 停止监控
  stopMonitoring(appName) {
    // 实现停止监控逻辑
    console.log(`Monitoring stopped for ${appName} canary`);
  }

  // 获取上一个稳定版本
  async getPreviousStableVersion(appName) {
    // 这里应该从版本管理器获取
    return '1.0.0'; // 示例
  }

  // 获取灰度配置
  getCanaryConfig(appName) {
    return this.canaryConfigs.get(appName);
  }

  // 获取所有灰度配置
  getAllCanaryConfigs() {
    return Array.from(this.canaryConfigs.values());
  }
}

// 导出单例
export const canaryDeployment = new CanaryDeployment();
```

### 12.5.2 蓝绿部署实现

```javascript
// 示例：蓝绿部署实现
class BlueGreenDeployment {
  constructor() {
    this.environments = new Map(); // appName -> { blue, green, active }
    this.deployments = new Map(); // deploymentId -> deploymentInfo
  }

  // 初始化蓝绿环境
  initializeEnvironments(appName) {
    if (this.environments.has(appName)) {
      return this.environments.get(appName);
    }
    
    const environments = {
      blue: {
        version: null,
        status: 'inactive',
        url: `https://${appName}-blue.example.com`,
        healthStatus: 'unknown',
      },
      green: {
        version: null,
        status: 'inactive',
        url: `https://${appName}-green.example.com`,
        healthStatus: 'unknown',
      },
      active: null, // 'blue' or 'green'
      productionUrl: `https://${appName}.example.com`,
    };
    
    this.environments.set(appName, environments);
    return environments;
  }

  // 部署到非活跃环境
  async deployToInactive(appName, version) {
    const environments = this.initializeEnvironments(appName);
    
    // 确定非活跃环境
    const inactiveEnv = environments.active === 'blue' ? 'green' : 'blue';
    
    // 创建部署记录
    const deploymentId = `${appName}-${version}-${Date.now()}`;
    const deployment = {
      id: deploymentId,
      appName,
      version,
      environment: inactiveEnv,
      status: 'deploying',
      createdAt: new Date(),
      completedAt: null,
    };
    
    this.deployments.set(deploymentId, deployment);
    
    try {
      // 更新环境版本
      environments[inactiveEnv].version = version;
      environments[inactiveEnv].status = 'deploying';
      
      // 执行部署
      await this.executeDeployment(appName, inactiveEnv, version);
      
      // 等待部署完成
      await this.waitForDeploymentCompletion(appName, inactiveEnv);
      
      // 更新状态
      environments[inactiveEnv].status = 'deployed';
      deployment.status = 'deployed';
      deployment.completedAt = new Date();
      
      console.log(`Deployment to ${inactiveEnv} environment completed for ${appName} version ${version}`);
      return deployment;
    } catch (error) {
      // 部署失败
      environments[inactiveEnv].status = 'failed';
      deployment.status = 'failed';
      deployment.error = error.message;
      
      console.error(`Deployment to ${inactiveEnv} environment failed for ${appName}:`, error);
      throw error;
    }
  }

  // 执行部署
  async executeDeployment(appName, environment, version) {
    // 这里应该调用实际的部署API
    console.log(`Deploying ${appName} version ${version} to ${environment} environment`);
    
    // 模拟部署过程
    await new Promise(resolve => setTimeout(resolve, 5000));
  }

  // 等待部署完成
  async waitForDeploymentCompletion(appName, environment) {
    const environments = this.environments.get(appName);
    const env = environments[environment];
    
    // 轮询检查部署状态
    const maxAttempts = 30;
    const interval = 10000; // 10秒
    
    for (let i = 0; i < maxAttempts; i++) {
      // 检查健康状态
      const isHealthy = await this.checkHealth(appName, environment);
      env.healthStatus = isHealthy ? 'healthy' : 'unhealthy';
      
      if (isHealthy) {
        return;
      }
      
      // 等待下一次检查
      await new Promise(resolve => setTimeout(resolve, interval));
    }
    
    throw new Error(`Deployment to ${environment} environment did not become healthy within the expected time`);
  }

  // 检查健康状态
  async checkHealth(appName, environment) {
    const environments = this.environments.get(appName);
    const env = environments[environment];
    
    try {
      const response = await fetch(`${env.url}/health`);
      return response.ok;
    } catch (error) {
      return false;
    }
  }

  // 切换流量
  async switchTraffic(appName) {
    const environments = this.environments.get(appName);
    if (!environments) {
      throw new Error(`Environments not initialized for ${appName}`);
    }
    
    // 确定当前活跃和非活跃环境
    const currentActive = environments.active;
    const newActive = currentActive === 'blue' ? 'green' : 'blue';
    
    // 检查新环境是否健康
    const isHealthy = await this.checkHealth(appName, newActive);
    if (!isHealthy) {
      throw new Error(`Cannot switch traffic to ${newActive} environment: not healthy`);
    }
    
    // 切换流量
    await this.updateLoadBalancer(appName, newActive);
    
    // 更新活跃环境
    environments.active = newActive;
    environments[currentActive].status = 'inactive';
    environments[newActive].status = 'active';
    
    console.log(`Traffic switched to ${newActive} environment for ${appName}`);
    return environments;
  }

  // 更新负载均衡器
  async updateLoadBalancer(appName, activeEnvironment) {
    const environments = this.environments.get(appName);
    const activeUrl = environments[activeEnvironment].url;
    
    // 这里应该调用实际的负载均衡器API
    console.log(`Updating load balancer for ${appName} to point to ${activeUrl}`);
  }

  // 回滚
  async rollback(appName) {
    const environments = this.environments.get(appName);
    if (!environments) {
      throw new Error(`Environments not initialized for ${appName}`);
    }
    
    const currentActive = environments.active;
    if (!currentActive) {
      throw new Error(`No active environment for ${appName}`);
    }
    
    // 切换到另一个环境
    const rollbackTo = currentActive === 'blue' ? 'green' : 'blue';
    
    // 检查回滚目标环境是否健康
    const isHealthy = await this.checkHealth(appName, rollbackTo);
    if (!isHealthy) {
      throw new Error(`Cannot rollback to ${rollbackTo} environment: not healthy`);
    }
    
    // 切换流量
    await this.updateLoadBalancer(appName, rollbackTo);
    
    // 更新活跃环境
    environments.active = rollbackTo;
    environments[currentActive].status = 'inactive';
    environments[rollbackTo].status = 'active';
    
    console.log(`Rollback completed for ${appName} to ${rollbackTo} environment`);
    return environments;
  }

  // 获取环境信息
  getEnvironments(appName) {
    return this.environments.get(appName);
  }

  // 获取部署信息
  getDeployment(deploymentId) {
    return this.deployments.get(deploymentId);
  }

  // 获取所有部署
  getAllDeployments() {
    return Array.from(this.deployments.values());
  }
}

// 导出单例
export const blueGreenDeployment = new BlueGreenDeployment();
```

## 12.6 部署监控与告警

### 12.6.1 部署监控系统

```javascript
// 示例：部署监控系统
class DeploymentMonitor {
  constructor() {
    this.metrics = new Map(); // appName -> metrics
    this.alerts = new Map(); // alertId -> alert
    this.alertRules = new Map(); // ruleId -> rule
    this.subscribers = new Map(); // eventType -> [callbacks]
  }

  // 记录部署指标
  recordMetrics(appName, metrics) {
    if (!this.metrics.has(appName)) {
      this.metrics.set(appName, []);
    }
    
    const appMetrics = this.metrics.get(appName);
    const timestampedMetrics = {
      ...metrics,
      timestamp: new Date(),
    };
    
    appMetrics.push(timestampedMetrics);
    
    // 保留最近1000条记录
    if (appMetrics.length > 1000) {
      appMetrics.splice(0, appMetrics.length - 1000);
    }
    
    // 检查告警规则
    this.checkAlertRules(appName, timestampedMetrics);
    
    // 通知订阅者
    this.notifySubscribers('metrics', { appName, metrics: timestampedMetrics });
  }

  // 添加告警规则
  addAlertRule(rule) {
    const {
      id,
      name,
      appName,
      metric,
      condition, // 如: '>', '<', '==', '!='
      threshold,
      duration = 60000, // 默认1分钟
      severity = 'warning', // 'info', 'warning', 'error', 'critical'
      enabled = true,
    } = rule;
    
    if (!id || !name || !appName || !metric || !condition || threshold === undefined) {
      throw new Error('Missing required fields for alert rule');
    }
    
    const alertRule = {
      id,
      name,
      appName,
      metric,
      condition,
      threshold,
      duration,
      severity,
      enabled,
      createdAt: new Date(),
      triggeredAt: null,
      resolvedAt: null,
      status: 'normal', // 'normal', 'triggered', 'resolved'
    };
    
    this.alertRules.set(id, alertRule);
    
    console.log(`Alert rule added: ${name}`);
    return alertRule;
  }

  // 检查告警规则
  checkAlertRules(appName, metrics) {
    for (const rule of this.alertRules.values()) {
      if (!rule.enabled || rule.appName !== appName) {
        continue;
      }
      
      const metricValue = metrics[rule.metric];
      if (metricValue === undefined) {
        continue;
      }
      
      const isTriggered = this.evaluateCondition(metricValue, rule.condition, rule.threshold);
      
      if (isTriggered && rule.status !== 'triggered') {
        // 触发告警
        this.triggerAlert(rule, metrics);
      } else if (!isTriggered && rule.status === 'triggered') {
        // 解决告警
        this.resolveAlert(rule, metrics);
      }
    }
  }

  // 评估条件
  evaluateCondition(value, condition, threshold) {
    switch (condition) {
      case '>':
        return value > threshold;
      case '>=':
        return value >= threshold;
      case '<':
        return value < threshold;
      case '<=':
        return value <= threshold;
      case '==':
        return value === threshold;
      case '!=':
        return value !== threshold;
      default:
        return false;
    }
  }

  // 触发告警
  triggerAlert(rule, metrics) {
    const alertId = `alert-${rule.id}-${Date.now()}`;
    
    const alert = {
      id: alertId,
      ruleId: rule.id,
      ruleName: rule.name,
      appName: rule.appName,
      metric: rule.metric,
      value: metrics[rule.metric],
      threshold: rule.threshold,
      condition: rule.condition,
      severity: rule.severity,
      status: 'triggered',
      triggeredAt: new Date(),
      resolvedAt: null,
      message: `Alert triggered: ${rule.name} - ${rule.metric} ${rule.condition} ${rule.threshold} (current: ${metrics[rule.metric]})`,
    };
    
    this.alerts.set(alertId, alert);
    
    // 更新规则状态
    rule.status = 'triggered';
    rule.triggeredAt = new Date();
    
    // 通知订阅者
    this.notifySubscribers('alert', alert);
    
    console.log(`Alert triggered: ${alert.message}`);
    return alert;
  }

  // 解决告警
  resolveAlert(rule, metrics) {
    // 查找相关的告警
    const relatedAlerts = Array.from(this.alerts.values())
      .filter(alert => alert.ruleId === rule.id && alert.status === 'triggered');
    
    for (const alert of relatedAlerts) {
      alert.status = 'resolved';
      alert.resolvedAt = new Date();
      alert.message = `Alert resolved: ${rule.name} - ${rule.metric} is now ${metrics[rule.metric]} (threshold: ${rule.threshold})`;
      
      // 通知订阅者
      this.notifySubscribers('alert-resolved', alert);
    }
    
    // 更新规则状态
    rule.status = 'resolved';
    rule.resolvedAt = new Date();
    
    console.log(`Alert resolved: ${rule.name}`);
  }

  // 订阅事件
  subscribe(eventType, callback) {
    if (!this.subscribers.has(eventType)) {
      this.subscribers.set(eventType, []);
    }
    
    this.subscribers.get(eventType).push(callback);
    
    // 返回取消订阅函数
    return () => {
      const callbacks = this.subscribers.get(eventType);
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    };
  }

  // 通知订阅者
  notifySubscribers(eventType, data) {
    const callbacks = this.subscribers.get(eventType);
    if (callbacks) {
      callbacks.forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in subscriber callback for ${eventType}:`, error);
        }
      });
    }
  }

  // 获取应用指标
  getAppMetrics(appName, limit = 100) {
    const metrics = this.metrics.get(appName) || [];
    return metrics.slice(-limit);
  }

  // 获取告警
  getAlerts(appName, status) {
    let alerts = Array.from(this.alerts.values());
    
    if (appName) {
      alerts = alerts.filter(alert => alert.appName === appName);
    }
    
    if (status) {
      alerts = alerts.filter(alert => alert.status === status);
    }
    
    return alerts.sort((a, b) => b.triggeredAt - a.triggeredAt);
  }

  // 获取告警规则
  getAlertRules(appName) {
    let rules = Array.from(this.alertRules.values());
    
    if (appName) {
      rules = rules.filter(rule => rule.appName === appName);
    }
    
    return rules;
  }

  // 更新告警规则
  updateAlertRule(ruleId, updates) {
    const rule = this.alertRules.get(ruleId);
    if (!rule) {
      throw new Error(`Alert rule ${ruleId} not found`);
    }
    
    Object.assign(rule, updates);
    
    console.log(`Alert rule ${ruleId} updated`);
    return rule;
  }

  // 删除告警规则
  deleteAlertRule(ruleId) {
    const rule = this.alertRules.get(ruleId);
    if (!rule) {
      throw new Error(`Alert rule ${ruleId} not found`);
    }
    
    this.alertRules.delete(ruleId);
    
    console.log(`Alert rule ${ruleId} deleted`);
    return rule;
  }
}

// 导出单例
export const deploymentMonitor = new DeploymentMonitor();
```

## 12.7 部署最佳实践

### 12.7.1 部署策略选择

1. **独立部署适用场景**
   - 团队独立性要求高
   - 发布频率差异大
   - 技术栈多样化

2. **统一部署适用场景**
   - 版本一致性要求高
   - 发布窗口统一
   - 集中管理需求

3. **灰度发布适用场景**
   - 高风险功能发布
   - 用户体验敏感
   - 需要逐步验证

4. **蓝绿部署适用场景**
   - 零停机要求
   - 快速回滚需求
   - 基础设施充足

### 12.7.2 部署检查清单

1. **部署前检查**
   - 代码审查完成
   - 测试通过
   - 依赖版本确认
   - 配置验证
   - 回滚方案准备

2. **部署中监控**
   - 部署进度跟踪
   - 错误日志监控
   - 性能指标监控
   - 用户体验监控

3. **部署后验证**
   - 功能验证
   - 性能验证
   - 安全验证
   - 用户反馈收集

### 12.7.3 部署自动化

```javascript
// 示例：部署自动化流程
class DeploymentAutomation {
  constructor() {
    this.pipelines = new Map(); // pipelineId -> pipeline
    this.executions = new Map(); // executionId -> execution
  }

  // 创建部署流水线
  createPipeline(pipelineConfig) {
    const {
      name,
      description,
      stages, // 阶段配置
      triggers, // 触发条件
      environment, // 目标环境
      timeout = 3600000, // 默认1小时超时
    } = pipelineConfig;
    
    if (!name || !stages || stages.length === 0) {
      throw new Error('Pipeline name and stages are required');
    }
    
    const pipelineId = `pipeline-${Date.now()}`;
    const pipeline = {
      id: pipelineId,
      name,
      description,
      stages,
      triggers,
      environment,
      timeout,
      createdAt: new Date(),
      enabled: true,
    };
    
    this.pipelines.set(pipelineId, pipeline);
    
    // 设置触发器
    this.setupTriggers(pipelineId);
    
    console.log(`Pipeline created: ${name} (${pipelineId})`);
    return pipeline;
  }

  // 执行部署流水线
  async executePipeline(pipelineId, triggerData = {}) {
    const pipeline = this.pipelines.get(pipelineId);
    if (!pipeline) {
      throw new Error(`Pipeline ${pipelineId} not found`);
    }
    
    if (!pipeline.enabled) {
      throw new Error(`Pipeline ${pipelineId} is disabled`);
    }
    
    const executionId = `exec-${pipelineId}-${Date.now()}`;
    const execution = {
      id: executionId,
      pipelineId,
      pipelineName: pipeline.name,
      status: 'running',
      startedAt: new Date(),
      completedAt: null,
      currentStage: 0,
      stages: pipeline.stages.map(stage => ({
        ...stage,
        status: 'pending',
        startedAt: null,
        completedAt: null,
        output: null,
        error: null,
      })),
      triggerData,
    };
    
    this.executions.set(executionId, execution);
    
    try {
      // 执行所有阶段
      for (let i = 0; i < pipeline.stages.length; i++) {
        execution.currentStage = i;
        await this.executeStage(executionId, i);
      }
      
      // 所有阶段完成
      execution.status = 'success';
      execution.completedAt = new Date();
      
      console.log(`Pipeline execution completed successfully: ${executionId}`);
      return execution;
    } catch (error) {
      // 执行失败
      execution.status = 'failed';
      execution.completedAt = new Date();
      execution.error = error.message;
      
      console.error(`Pipeline execution failed: ${executionId}`, error);
      throw error;
    }
  }

  // 执行阶段
  async executeStage(executionId, stageIndex) {
    const execution = this.executions.get(executionId);
    const pipeline = this.pipelines.get(execution.pipelineId);
    const stageConfig = pipeline.stages[stageIndex];
    const stage = execution.stages[stageIndex];
    
    stage.status = 'running';
    stage.startedAt = new Date();
    
    try {
      // 设置超时
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Stage timeout')), pipeline.timeout);
      });
      
      // 执行阶段
      const stagePromise = this.runStage(stageConfig, execution.triggerData);
      
      // 等待执行完成或超时
      const output = await Promise.race([stagePromise, timeoutPromise]);
      
      // 阶段完成
      stage.status = 'success';
      stage.completedAt = new Date();
      stage.output = output;
      
      console.log(`Stage ${stageIndex} completed: ${stageConfig.name}`);
    } catch (error) {
      // 阶段失败
      stage.status = 'failed';
      stage.completedAt = new Date();
      stage.error = error.message;
      
      console.error(`Stage ${stageIndex} failed: ${stageConfig.name}`, error);
      throw error;
    }
  }

  // 运行阶段
  async runStage(stageConfig, triggerData) {
    const { type, config } = stageConfig;
    
    switch (type) {
      case 'build':
        return this.runBuildStage(config);
      case 'test':
        return this.runTestStage(config);
      case 'deploy':
        return this.runDeployStage(config, triggerData);
      case 'verify':
        return this.runVerifyStage(config);
      case 'notify':
        return this.runNotifyStage(config);
      default:
        throw new Error(`Unknown stage type: ${type}`);
    }
  }

  // 运行构建阶段
  async runBuildStage(config) {
    const { appName, version, buildCommand } = config;
    
    // 这里应该调用实际的构建API
    console.log(`Building ${appName} version ${version} with command: ${buildCommand}`);
    
    // 模拟构建过程
    await new Promise(resolve => setTimeout(resolve, 30000));
    
    return {
      appName,
      version,
      buildTime: new Date(),
      artifacts: [`${appName}-${version}.zip`],
    };
  }

  // 运行测试阶段
  async runTestStage(config) {
    const { appName, version, testTypes } = config;
    
    // 这里应该调用实际的测试API
    console.log(`Running tests for ${appName} version ${version}: ${testTypes.join(', ')}`);
    
    // 模拟测试过程
    await new Promise(resolve => setTimeout(resolve, 60000));
    
    return {
      appName,
      version,
      testResults: {
        unit: { passed: 100, failed: 0 },
        integration: { passed: 50, failed: 2 },
        e2e: { passed: 20, failed: 1 },
      },
    };
  }

  // 运行部署阶段
  async runDeployStage(config, triggerData) {
    const { appName, version, environment, strategy } = config;
    
    // 这里应该调用实际的部署API
    console.log(`Deploying ${appName} version ${version} to ${environment} with strategy: ${strategy}`);
    
    // 模拟部署过程
    await new Promise(resolve => setTimeout(resolve, 120000));
    
    return {
      appName,
      version,
      environment,
      strategy,
      deploymentTime: new Date(),
      url: `https://${appName}-${environment}.example.com`,
    };
  }

  // 运行验证阶段
  async runVerifyStage(config) {
    const { appName, version, environment, checks } = config;
    
    // 这里应该调用实际的验证API
    console.log(`Verifying ${appName} version ${version} in ${environment}: ${checks.join(', ')}`);
    
    // 模拟验证过程
    await new Promise(resolve => setTimeout(resolve, 30000));
    
    return {
      appName,
      version,
      environment,
      verificationResults: {
        health: 'pass',
        performance: 'pass',
        functionality: 'pass',
      },
    };
  }

  // 运行通知阶段
  async runNotifyStage(config) {
    const { channels, message } = config;
    
    // 这里应该调用实际的通知API
    console.log(`Sending notification to ${channels.join(', ')}: ${message}`);
    
    // 模拟通知过程
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    return {
      channels,
      message,
      sentAt: new Date(),
    };
  }

  // 设置触发器
  setupTriggers(pipelineId) {
    const pipeline = this.pipelines.get(pipelineId);
    if (!pipeline || !pipeline.triggers) {
      return;
    }
    
    for (const trigger of pipeline.triggers) {
      switch (trigger.type) {
        case 'webhook':
          this.setupWebhookTrigger(pipelineId, trigger);
          break;
        case 'schedule':
          this.setupScheduleTrigger(pipelineId, trigger);
          break;
        case 'event':
          this.setupEventTrigger(pipelineId, trigger);
          break;
      }
    }
  }

  // 设置Webhook触发器
  setupWebhookTrigger(pipelineId, trigger) {
    // 这里应该设置实际的Webhook端点
    console.log(`Webhook trigger set up for pipeline ${pipelineId}`);
  }

  // 设置计划触发器
  setupScheduleTrigger(pipelineId, trigger) {
    // 这里应该设置实际的计划任务
    console.log(`Schedule trigger set up for pipeline ${pipelineId}: ${trigger.cron}`);
  }

  // 设置事件触发器
  setupEventTrigger(pipelineId, trigger) {
    // 这里应该设置实际的事件监听
    console.log(`Event trigger set up for pipeline ${pipelineId}: ${trigger.event}`);
  }

  // 获取流水线
  getPipeline(pipelineId) {
    return this.pipelines.get(pipelineId);
  }

  // 获取所有流水线
  getAllPipelines() {
    return Array.from(this.pipelines.values());
  }

  // 获取执行记录
  getExecution(executionId) {
    return this.executions.get(executionId);
  }

  // 获取流水线的所有执行记录
  getPipelineExecutions(pipelineId) {
    return Array.from(this.executions.values())
      .filter(execution => execution.pipelineId === pipelineId)
      .sort((a, b) => b.startedAt - a.startedAt);
  }
}

// 导出单例
export const deploymentAutomation = new DeploymentAutomation();
```

## 12.8 总结

微前端部署与发布是微前端架构中的关键环节，需要综合考虑独立性、一致性、安全性和可靠性：

1. **部署策略选择**：根据团队结构、业务需求和技术栈选择合适的部署模式
2. **版本管理**：建立完善的版本控制和兼容性检查机制
3. **发布流程**：设计可靠的发布流程，包括灰度发布和蓝绿部署
4. **监控告警**：建立全面的监控告警系统，及时发现和解决问题
5. **自动化**：尽可能自动化部署流程，减少人为错误

通过合理的部署策略和工具支持，可以有效降低微前端部署的复杂性，提高发布效率和质量。

## 12.9 示例代码

### 12.9.1 代码结构

```
frontend/micro-frontend/code/chapter12/
├── deployment-strategy/
│   ├── independent-deployment/
│   │   ├── config-manager.js
│   │   ├── app-registry.js
│   │   └── version-manager.js
│   ├── unified-deployment/
│   │   ├── build-pipeline.yml
│   │   └── release-manager.js
│   ├── container-deployment/
│   │   ├── main-app/
│   │   │   └── Dockerfile
│   │   ├── app1/
│   │   │   └── Dockerfile
│   │   └── k8s/
│   │       ├── main-app.yaml
│   │       └── app1.yaml
│   ├── canary-deployment/
│   │   └── canary-deployment.js
│   ├── blue-green-deployment/
│   │   └── blue-green-deployment.js
│   ├── monitoring/
│   │   └── deployment-monitor.js
│   └── automation/
│       └── deployment-automation.js
└── README.md
```

### 12.9.2 运行说明

1. 安装依赖：
```bash
npm install
```

2. 运行配置管理器：
```bash
npm run config-manager
```

3. 运行应用注册中心：
```bash
npm run app-registry
```

4. 运行版本管理器：
```bash
npm run version-manager
```

5. 运行发布管理器：
```bash
npm run release-manager
```

6. 运行灰度部署：
```bash
npm run canary-deployment
```

7. 运行蓝绿部署：
```bash
npm run blue-green-deployment
```

8. 运行部署监控：
```bash
npm run deployment-monitor
```

9. 运行部署自动化：
```bash
npm run deployment-automation
```

### 12.9.3 功能演示

1. 独立部署演示：
   - 配置中心管理
   - 应用注册与发现
   - 版本管理与兼容性

2. 统一部署演示：
   - 构建流水线
   - 版本发布管理

3. 容器化部署演示：
   - Docker容器化
   - Kubernetes部署

4. 灰度发布演示：
   - 灰度配置
   - 流量切换
   - 自动提升与回滚

5. 蓝绿部署演示：
   - 环境初始化
   - 部署与切换
   - 快速回滚

6. 监控告警演示：
   - 指标收集
   - 告警规则
   - 通知机制

7. 自动化部署演示：
   - 流水线创建
   - 自动执行
   - 触发器设置