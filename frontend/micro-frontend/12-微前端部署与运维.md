# 第十二章：微前端部署与运维

## 12.1 微前端部署概述

### 12.1.1 微前端部署特点

微前端架构的部署与传统单体应用有显著不同，主要特点包括：

1. **独立部署**：每个微应用可以独立开发、测试和部署，不受其他应用影响
2. **版本管理**：需要管理多个应用的版本兼容性和依赖关系
3. **资源隔离**：各微应用的资源需要独立管理和优化
4. **发布策略**：需要制定灵活的发布策略，支持灰度发布和回滚
5. **环境一致性**：确保开发、测试和生产环境的一致性
6. **监控与日志**：需要统一监控各微应用的运行状态和日志

### 12.1.2 部署挑战

微前端部署面临的主要挑战：

1. **部署复杂性**：多个应用的部署流程需要协调和管理
2. **依赖管理**：微应用间的依赖关系增加了部署复杂性
3. **版本兼容**：不同微应用版本之间的兼容性问题
4. **资源优化**：多个应用的资源加载和缓存策略
5. **回滚机制**：单个微应用的回滚可能影响整体系统
6. **测试验证**：部署后的集成测试和验证更加复杂

### 12.1.3 部署策略

针对微前端的特点，我们需要采用灵活的部署策略：

1. **独立部署**：每个微应用独立部署，互不影响
2. **蓝绿部署**：通过环境切换实现零停机部署
3. **灰度发布**：逐步将流量切换到新版本
4. **A/B测试**：同时运行多个版本进行对比测试
5. **金丝雀发布**：先小范围验证，再全面推广
6. **功能开关**：通过开关控制功能的启用和禁用

## 12.2 微前端部署架构

### 12.2.1 部署架构设计

以下是一个微前端部署架构的设计实现：

```javascript
/**
 * 微前端部署管理器
 */
class MicroFrontendDeploymentManager {
  constructor(config = {}) {
    this.config = {
      // 部署环境配置
      environments: {
        development: {
          name: '开发环境',
          baseUrl: 'http://dev.example.com',
          apiBaseUrl: 'http://dev-api.example.com',
          cdnBaseUrl: 'http://dev-cdn.example.com'
        },
        testing: {
          name: '测试环境',
          baseUrl: 'http://test.example.com',
          apiBaseUrl: 'http://test-api.example.com',
          cdnBaseUrl: 'http://test-cdn.example.com'
        },
        staging: {
          name: '预发布环境',
          baseUrl: 'http://staging.example.com',
          apiBaseUrl: 'http://staging-api.example.com',
          cdnBaseUrl: 'http://staging-cdn.example.com'
        },
        production: {
          name: '生产环境',
          baseUrl: 'http://example.com',
          apiBaseUrl: 'http://api.example.com',
          cdnBaseUrl: 'http://cdn.example.com'
        }
      },
      // 微应用配置
      microApps: [
        {
          name: 'main-app',
          description: '主应用',
          repository: 'git@github.com:example/main-app.git',
          buildCommand: 'npm run build',
          outputDir: 'dist',
          entryFiles: {
            development: 'main.js',
            testing: 'main.js',
            staging: 'main.js',
            production: 'main.[hash].js'
          }
        },
        {
          name: 'dashboard',
          description: '仪表盘应用',
          repository: 'git@github.com:example/dashboard.git',
          buildCommand: 'npm run build',
          outputDir: 'dist',
          entryFiles: {
            development: 'dashboard.js',
            testing: 'dashboard.js',
            staging: 'dashboard.[hash].js',
            production: 'dashboard.[hash].js'
          }
        },
        {
          name: 'user-profile',
          description: '用户资料应用',
          repository: 'git@github.com:example/user-profile.git',
          buildCommand: 'npm run build',
          outputDir: 'dist',
          entryFiles: {
            development: 'user-profile.js',
            testing: 'user-profile.js',
            staging: 'user-profile.[hash].js',
            production: 'user-profile.[hash].js'
          }
        }
      ],
      // 部署配置
      deployment: {
        // 构建工具
        buildTool: 'webpack',
        // 包管理器
        packageManager: 'npm',
        // CI/CD平台
        cicdPlatform: 'jenkins',
        // 容器化
        containerization: {
          enabled: true,
          registry: 'registry.example.com',
          baseImage: 'node:16-alpine'
        },
        // 资源上传
        resourceUpload: {
          enabled: true,
          provider: 'aws-s3',
          bucket: 'micro-frontends',
          cdnEnabled: true
        }
      },
      // 发布策略配置
      releaseStrategy: {
        // 默认策略
        default: 'blue-green',
        // 策略配置
        strategies: {
          'blue-green': {
            description: '蓝绿部署',
            switchDelay: 30000,
            healthCheckPath: '/health',
            healthCheckTimeout: 10000
          },
          'canary': {
            description: '金丝雀发布',
            initialTrafficPercentage: 5,
            incrementPercentage: 5,
            incrementInterval: 300000,
            maxTrafficPercentage: 100
          },
          'rolling': {
            description: '滚动更新',
            batchSize: 1,
            batchInterval: 60000,
            healthCheckPath: '/health',
            healthCheckTimeout: 10000
          }
        }
      },
      ...config
    };
    
    // 环境管理器
    this.environmentManager = null;
    // 构建管理器
    this.buildManager = null;
    // 部署管理器
    this.deployManager = null;
    // 发布管理器
    this.releaseManager = null;
    
    this.init();
  }
  
  /**
   * 初始化部署管理器
   */
  init() {
    // 初始化环境管理器
    this.environmentManager = new EnvironmentManager(this.config.environments);
    
    // 初始化构建管理器
    this.buildManager = new BuildManager(this.config.deployment);
    
    // 初始化部署管理器
    this.deployManager = new DeployManager(this.config.deployment);
    
    // 初始化发布管理器
    this.releaseManager = new ReleaseManager(this.config.releaseStrategy);
  }
  
  /**
   * 部署微应用到指定环境
   */
  async deployMicroApp(appName, targetEnvironment, options = {}) {
    console.log(`开始部署微应用 ${appName} 到 ${targetEnvironment} 环境`);
    
    // 获取微应用配置
    const microApp = this.config.microApps.find(app => app.name === appName);
    if (!microApp) {
      throw new Error(`微应用不存在: ${appName}`);
    }
    
    // 获取环境配置
    const environment = this.environmentManager.getEnvironment(targetEnvironment);
    if (!environment) {
      throw new Error(`环境不存在: ${targetEnvironment}`);
    }
    
    try {
      // 1. 构建应用
      console.log(`  1. 构建 ${appName} 应用...`);
      const buildResult = await this.buildManager.build(microApp, environment);
      
      // 2. 上传资源
      console.log(`  2. 上传 ${appName} 资源...`);
      const uploadResult = await this.deployManager.uploadResources(buildResult, environment);
      
      // 3. 部署应用
      console.log(`  3. 部署 ${appName} 应用...`);
      const deployResult = await this.deployManager.deploy(microApp, buildResult, environment, options);
      
      // 4. 执行发布策略
      console.log(`  4. 执行发布策略...`);
      const releaseResult = await this.releaseManager.release(microApp, deployResult, environment, options);
      
      console.log(`微应用 ${appName} 部署完成`);
      
      return {
        appName,
        environment: targetEnvironment,
        buildResult,
        uploadResult,
        deployResult,
        releaseResult,
        status: 'success',
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error(`微应用 ${appName} 部署失败:`, error);
      
      return {
        appName,
        environment: targetEnvironment,
        status: 'failed',
        error: error.message,
        timestamp: new Date().toISOString()
      };
    }
  }
  
  /**
   * 回滚微应用
   */
  async rollbackMicroApp(appName, targetEnvironment, version) {
    console.log(`开始回滚微应用 ${appName} 到 ${targetEnvironment} 环境的 ${version} 版本`);
    
    // 获取微应用配置
    const microApp = this.config.microApps.find(app => app.name === appName);
    if (!microApp) {
      throw new Error(`微应用不存在: ${appName}`);
    }
    
    // 获取环境配置
    const environment = this.environmentManager.getEnvironment(targetEnvironment);
    if (!environment) {
      throw new Error(`环境不存在: ${targetEnvironment}`);
    }
    
    try {
      // 执行回滚
      const rollbackResult = await this.deployManager.rollback(microApp, environment, version);
      
      console.log(`微应用 ${appName} 回滚完成`);
      
      return {
        appName,
        environment: targetEnvironment,
        version,
        rollbackResult,
        status: 'success',
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error(`微应用 ${appName} 回滚失败:`, error);
      
      return {
        appName,
        environment: targetEnvironment,
        version,
        status: 'failed',
        error: error.message,
        timestamp: new Date().toISOString()
      };
    }
  }
  
  /**
   * 获取微应用部署状态
   */
  async getDeploymentStatus(appName, environment) {
    try {
      return await this.deployManager.getDeploymentStatus(appName, environment);
    } catch (error) {
      console.error(`获取微应用 ${appName} 部署状态失败:`, error);
      return {
        appName,
        environment,
        status: 'error',
        error: error.message
      };
    }
  }
  
  /**
   * 获取微应用部署历史
   */
  async getDeploymentHistory(appName, environment, limit = 10) {
    try {
      return await this.deployManager.getDeploymentHistory(appName, environment, limit);
    } catch (error) {
      console.error(`获取微应用 ${appName} 部署历史失败:`, error);
      return [];
    }
  }
  
  /**
   * 获取部署配置
   */
  getDeploymentConfig() {
    return this.config;
  }
}

/**
 * 环境管理器
 */
class EnvironmentManager {
  constructor(environments) {
    this.environments = environments;
  }
  
  /**
   * 获取环境配置
   */
  getEnvironment(name) {
    return this.environments[name];
  }
  
  /**
   * 获取所有环境
   */
  getAllEnvironments() {
    return Object.keys(this.environments).map(key => ({
      name: key,
      ...this.environments[key]
    }));
  }
  
  /**
   * 验证环境配置
   */
  validateEnvironment(name) {
    const environment = this.environments[name];
    if (!environment) {
      throw new Error(`环境不存在: ${name}`);
    }
    
    const requiredFields = ['name', 'baseUrl', 'apiBaseUrl'];
    for (const field of requiredFields) {
      if (!environment[field]) {
        throw new Error(`环境 ${name} 缺少必要字段: ${field}`);
      }
    }
    
    return true;
  }
}

/**
 * 构建管理器
 */
class BuildManager {
  constructor(config) {
    this.config = config;
  }
  
  /**
   * 构建微应用
   */
  async build(microApp, environment) {
    console.log(`构建微应用 ${microApp.name} (${environment.name})`);
    
    // 1. 准备构建环境
    await this.prepareBuildEnvironment(microApp, environment);
    
    // 2. 执行构建
    const buildResult = await this.executeBuild(microApp, environment);
    
    // 3. 验证构建结果
    await this.validateBuildResult(buildResult);
    
    return buildResult;
  }
  
  /**
   * 准备构建环境
   */
  async prepareBuildEnvironment(microApp, environment) {
    console.log(`  准备构建环境...`);
    
    // 克隆代码仓库
    await this.cloneRepository(microApp.repository);
    
    // 安装依赖
    await this.installDependencies();
    
    // 设置环境变量
    await this.setupEnvironmentVariables(environment);
  }
  
  /**
   * 执行构建
   */
  async executeBuild(microApp, environment) {
    console.log(`  执行构建...`);
    
    const buildCommand = this.getBuildCommand(microApp, environment);
    
    // 模拟构建过程
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        // 模拟构建成功
        const buildResult = {
          appName: microApp.name,
          environment: environment.name,
          version: this.generateVersion(),
          buildTime: new Date().toISOString(),
          outputDir: microApp.outputDir,
          entryFile: microApp.entryFiles[environment.name],
          assets: [
            {
              name: 'main.js',
              size: 1024000,
              hash: 'abc123'
            },
            {
              name: 'main.css',
              size: 256000,
              hash: 'def456'
            },
            {
              name: 'logo.png',
              size: 51200,
              hash: 'ghi789'
            }
          ]
        };
        
        resolve(buildResult);
      }, 5000);
    });
  }
  
  /**
   * 验证构建结果
   */
  async validateBuildResult(buildResult) {
    console.log(`  验证构建结果...`);
    
    if (!buildResult.entryFile) {
      throw new Error('构建结果缺少入口文件');
    }
    
    if (!buildResult.assets || buildResult.assets.length === 0) {
      throw new Error('构建结果缺少资源文件');
    }
    
    return true;
  }
  
  /**
   * 克隆代码仓库
   */
  async cloneRepository(repository) {
    console.log(`    克隆代码仓库: ${repository}`);
    
    // 模拟克隆过程
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, 1000);
    });
  }
  
  /**
   * 安装依赖
   */
  async installDependencies() {
    console.log(`    安装依赖...`);
    
    // 模拟安装过程
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, 2000);
    });
  }
  
  /**
   * 设置环境变量
   */
  async setupEnvironmentVariables(environment) {
    console.log(`    设置环境变量...`);
    
    // 设置环境变量
    process.env.NODE_ENV = environment.name;
    process.env.API_BASE_URL = environment.apiBaseUrl;
    process.env.CDN_BASE_URL = environment.cdnBaseUrl;
  }
  
  /**
   * 获取构建命令
   */
  getBuildCommand(microApp, environment) {
    // 根据环境调整构建命令
    let command = microApp.buildCommand;
    
    if (environment.name === 'production') {
      command += ' --production';
    }
    
    return command;
  }
  
  /**
   * 生成版本号
   */
  generateVersion() {
    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 1000);
    return `v1.0.${timestamp}-${random}`;
  }
}

/**
 * 部署管理器
 */
class DeployManager {
  constructor(config) {
    this.config = config;
    this.deploymentHistory = new Map();
  }
  
  /**
   * 上传资源
   */
  async uploadResources(buildResult, environment) {
    console.log(`上传资源到 ${environment.name} 环境`);
    
    const uploadResults = [];
    
    for (const asset of buildResult.assets) {
      console.log(`  上传资源: ${asset.name}`);
      
      // 模拟上传过程
      const uploadResult = await this.uploadAsset(asset, environment);
      uploadResults.push(uploadResult);
    }
    
    return {
      environment: environment.name,
      assets: uploadResults,
      uploadTime: new Date().toISOString()
    };
  }
  
  /**
   * 部署应用
   */
  async deploy(microApp, buildResult, environment, options = {}) {
    console.log(`部署 ${microApp.name} 到 ${environment.name} 环境`);
    
    // 1. 创建部署记录
    const deploymentId = this.generateDeploymentId();
    const deployment = {
      id: deploymentId,
      appName: microApp.name,
      environment: environment.name,
      version: buildResult.version,
      status: 'deploying',
      startTime: new Date().toISOString(),
      endTime: null,
      assets: buildResult.assets,
      entryFile: buildResult.entryFile
    };
    
    this.saveDeployment(deployment);
    
    try {
      // 2. 执行部署
      await this.executeDeployment(deployment, environment, options);
      
      // 3. 更新部署状态
      deployment.status = 'success';
      deployment.endTime = new Date().toISOString();
      this.updateDeployment(deployment);
      
      return deployment;
    } catch (error) {
      // 部署失败，更新状态
      deployment.status = 'failed';
      deployment.endTime = new Date().toISOString();
      deployment.error = error.message;
      this.updateDeployment(deployment);
      
      throw error;
    }
  }
  
  /**
   * 回滚应用
   */
  async rollback(microApp, environment, version) {
    console.log(`回滚 ${microApp.name} 到 ${environment.name} 环境的 ${version} 版本`);
    
    // 1. 查找目标版本的部署记录
    const targetDeployment = this.findDeploymentByVersion(microApp.name, environment.name, version);
    if (!targetDeployment) {
      throw new Error(`找不到版本 ${version} 的部署记录`);
    }
    
    // 2. 创建回滚记录
    const rollbackId = this.generateDeploymentId();
    const rollback = {
      id: rollbackId,
      appName: microApp.name,
      environment: environment.name,
      version: version,
      status: 'rolling-back',
      startTime: new Date().toISOString(),
      endTime: null,
      type: 'rollback',
      targetDeploymentId: targetDeployment.id
    };
    
    this.saveDeployment(rollback);
    
    try {
      // 3. 执行回滚
      await this.executeRollback(rollback, targetDeployment, environment);
      
      // 4. 更新回滚状态
      rollback.status = 'success';
      rollback.endTime = new Date().toISOString();
      this.updateDeployment(rollback);
      
      return rollback;
    } catch (error) {
      // 回滚失败，更新状态
      rollback.status = 'failed';
      rollback.endTime = new Date().toISOString();
      rollback.error = error.message;
      this.updateDeployment(rollback);
      
      throw error;
    }
  }
  
  /**
   * 获取部署状态
   */
  async getDeploymentStatus(appName, environment) {
    const key = `${appName}-${environment}`;
    const deployments = this.deploymentHistory.get(key) || [];
    
    if (deployments.length === 0) {
      return {
        appName,
        environment,
        status: 'not-deployed'
      };
    }
    
    // 返回最新的部署状态
    const latestDeployment = deployments[deployments.length - 1];
    
    return {
      appName,
      environment,
      deploymentId: latestDeployment.id,
      version: latestDeployment.version,
      status: latestDeployment.status,
      startTime: latestDeployment.startTime,
      endTime: latestDeployment.endTime,
      type: latestDeployment.type || 'deploy'
    };
  }
  
  /**
   * 获取部署历史
   */
  async getDeploymentHistory(appName, environment, limit = 10) {
    const key = `${appName}-${environment}`;
    const deployments = this.deploymentHistory.get(key) || [];
    
    return deployments
      .slice(-limit)
      .reverse()
      .map(deployment => ({
        id: deployment.id,
        version: deployment.version,
        status: deployment.status,
        startTime: deployment.startTime,
        endTime: deployment.endTime,
        type: deployment.type || 'deploy'
      }));
  }
  
  /**
   * 上传单个资源
   */
  async uploadAsset(asset, environment) {
    // 模拟上传过程
    return new Promise(resolve => {
      setTimeout(() => {
        resolve({
          name: asset.name,
          size: asset.size,
          hash: asset.hash,
          url: `${environment.cdnBaseUrl}/${asset.name}?v=${asset.hash}`,
          uploadTime: new Date().toISOString()
        });
      }, 1000);
    });
  }
  
  /**
   * 执行部署
   */
  async executeDeployment(deployment, environment, options) {
    console.log(`  执行部署...`);
    
    // 模拟部署过程
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        // 模拟部署成功
        resolve();
      }, 3000);
    });
  }
  
  /**
   * 执行回滚
   */
  async executeRollback(rollback, targetDeployment, environment) {
    console.log(`  执行回滚...`);
    
    // 模拟回滚过程
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        // 模拟回滚成功
        resolve();
      }, 2000);
    });
  }
  
  /**
   * 生成部署ID
   */
  generateDeploymentId() {
    return `deploy-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
  }
  
  /**
   * 保存部署记录
   */
  saveDeployment(deployment) {
    const key = `${deployment.appName}-${deployment.environment}`;
    
    if (!this.deploymentHistory.has(key)) {
      this.deploymentHistory.set(key, []);
    }
    
    this.deploymentHistory.get(key).push(deployment);
  }
  
  /**
   * 更新部署记录
   */
  updateDeployment(deployment) {
    const key = `${deployment.appName}-${deployment.environment}`;
    const deployments = this.deploymentHistory.get(key) || [];
    
    const index = deployments.findIndex(d => d.id === deployment.id);
    if (index !== -1) {
      deployments[index] = deployment;
    }
  }
  
  /**
   * 查找指定版本的部署记录
   */
  findDeploymentByVersion(appName, environment, version) {
    const key = `${appName}-${environment}`;
    const deployments = this.deploymentHistory.get(key) || [];
    
    return deployments.find(d => d.version === version && d.status === 'success');
  }
}

/**
 * 发布管理器
 */
class ReleaseManager {
  constructor(config) {
    this.config = config;
    this.releaseStrategies = new Map();
    
    // 初始化发布策略
    this.initReleaseStrategies();
  }
  
  /**
   * 初始化发布策略
   */
  initReleaseStrategies() {
    // 蓝绿部署策略
    this.releaseStrategies.set('blue-green', new BlueGreenReleaseStrategy(this.config.strategies['blue-green']));
    
    // 金丝雀发布策略
    this.releaseStrategies.set('canary', new CanaryReleaseStrategy(this.config.strategies['canary']));
    
    // 滚动更新策略
    this.releaseStrategies.set('rolling', new RollingReleaseStrategy(this.config.strategies['rolling']));
  }
  
  /**
   * 执行发布
   */
  async release(microApp, deployment, environment, options = {}) {
    const strategyName = options.strategy || this.config.default;
    const strategy = this.releaseStrategies.get(strategyName);
    
    if (!strategy) {
      throw new Error(`不支持的发布策略: ${strategyName}`);
    }
    
    console.log(`使用 ${strategyName} 策略发布 ${microApp.name}`);
    
    return await strategy.execute(microApp, deployment, environment, options);
  }
}

/**
 * 蓝绿部署策略
 */
class BlueGreenReleaseStrategy {
  constructor(config) {
    this.config = config;
  }
  
  /**
   * 执行蓝绿部署
   */
  async execute(microApp, deployment, environment, options = {}) {
    console.log(`  执行蓝绿部署...`);
    
    // 1. 准备绿色环境
    console.log(`    准备绿色环境...`);
    const greenEnvironment = await this.prepareGreenEnvironment(environment);
    
    // 2. 部署到绿色环境
    console.log(`    部署到绿色环境...`);
    await this.deployToGreenEnvironment(microApp, deployment, greenEnvironment);
    
    // 3. 健康检查
    console.log(`    执行健康检查...`);
    await this.performHealthCheck(greenEnvironment);
    
    // 4. 等待一段时间确保稳定
    console.log(`    等待应用稳定...`);
    await this.waitForStability();
    
    // 5. 切换流量
    console.log(`    切换流量到绿色环境...`);
    await this.switchTraffic(greenEnvironment);
    
    // 6. 验证切换结果
    console.log(`    验证切换结果...`);
    await this.verifySwitch();
    
    return {
      strategy: 'blue-green',
      status: 'success',
      greenEnvironment: greenEnvironment.name,
      switchTime: new Date().toISOString()
    };
  }
  
  /**
   * 准备绿色环境
   */
  async prepareGreenEnvironment(blueEnvironment) {
    // 创建绿色环境配置
    const greenEnvironment = {
      name: `${blueEnvironment.name}-green`,
      baseUrl: `${blueEnvironment.baseUrl}-green`,
      apiBaseUrl: blueEnvironment.apiBaseUrl,
      cdnBaseUrl: blueEnvironment.cdnBaseUrl
    };
    
    return greenEnvironment;
  }
  
  /**
   * 部署到绿色环境
   */
  async deployToGreenEnvironment(microApp, deployment, environment) {
    // 模拟部署过程
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, 2000);
    });
  }
  
  /**
   * 执行健康检查
   */
  async performHealthCheck(environment) {
    // 模拟健康检查
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        // 模拟健康检查成功
        resolve();
      }, 1000);
    });
  }
  
  /**
   * 等待应用稳定
   */
  async waitForStability() {
    // 等待一段时间
    return new Promise(resolve => {
      setTimeout(resolve, this.config.switchDelay);
    });
  }
  
  /**
   * 切换流量
   */
  async switchTraffic(environment) {
    // 模拟流量切换
    return new Promise(resolve => {
      setTimeout(resolve, 1000);
    });
  }
  
  /**
   * 验证切换结果
   */
  async verifySwitch() {
    // 模拟验证过程
    return new Promise(resolve => {
      setTimeout(resolve, 1000);
    });
  }
}

/**
 * 金丝雀发布策略
 */
class CanaryReleaseStrategy {
  constructor(config) {
    this.config = config;
  }
  
  /**
   * 执行金丝雀发布
   */
  async execute(microApp, deployment, environment, options = {}) {
    console.log(`  执行金丝雀发布...`);
    
    let currentTrafficPercentage = this.config.initialTrafficPercentage;
    
    // 逐步增加流量
    while (currentTrafficPercentage <= this.config.maxTrafficPercentage) {
      console.log(`    将 ${currentTrafficPercentage}% 的流量切换到新版本...`);
      
      // 1. 切换部分流量
      await this.switchTraffic(currentTrafficPercentage);
      
      // 2. 等待一段时间
      await this.waitForInterval();
      
      // 3. 监控指标
      const metrics = await this.monitorMetrics();
      
      // 4. 检查是否需要回滚
      if (this.shouldRollback(metrics)) {
        console.log(`    检测到异常，执行回滚...`);
        await this.rollback();
        throw new Error('金丝雀发布失败，已回滚');
      }
      
      // 5. 增加流量
      currentTrafficPercentage += this.config.incrementPercentage;
    }
    
    // 6. 切换全部流量
    console.log(`    将 100% 的流量切换到新版本...`);
    await this.switchTraffic(100);
    
    return {
      strategy: 'canary',
      status: 'success',
      finalTrafficPercentage: 100,
      releaseTime: new Date().toISOString()
    };
  }
  
  /**
   * 切换流量
   */
  async switchTraffic(percentage) {
    // 模拟流量切换
    return new Promise(resolve => {
      setTimeout(resolve, 1000);
    });
  }
  
  /**
   * 等待间隔
   */
  async waitForInterval() {
    // 等待一段时间
    return new Promise(resolve => {
      setTimeout(resolve, this.config.incrementInterval);
    });
  }
  
  /**
   * 监控指标
   */
  async monitorMetrics() {
    // 模拟监控指标
    return {
      errorRate: Math.random() * 5, // 错误率 0-5%
      responseTime: Math.random() * 100 + 50, // 响应时间 50-150ms
      throughput: Math.random() * 1000 + 500 // 吞吐量 500-1500 req/s
    };
  }
  
  /**
   * 检查是否需要回滚
   */
  shouldRollback(metrics) {
    // 如果错误率超过1%，回滚
    return metrics.errorRate > 1;
  }
  
  /**
   * 回滚
   */
  async rollback() {
    // 模拟回滚过程
    return new Promise(resolve => {
      setTimeout(resolve, 2000);
    });
  }
}

/**
 * 滚动更新策略
 */
class RollingReleaseStrategy {
  constructor(config) {
    this.config = config;
  }
  
  /**
   * 执行滚动更新
   */
  async execute(microApp, deployment, environment, options = {}) {
    console.log(`  执行滚动更新...`);
    
    // 1. 获取实例列表
    const instances = await this.getInstances(environment);
    
    // 2. 分批更新
    const batchSize = this.config.batchSize;
    for (let i = 0; i < instances.length; i += batchSize) {
      const batch = instances.slice(i, i + batchSize);
      
      console.log(`    更新批次 ${Math.floor(i / batchSize) + 1}/${Math.ceil(instances.length / batchSize)}...`);
      
      // 3. 更新当前批次
      await this.updateBatch(batch, deployment);
      
      // 4. 健康检查
      await this.performHealthCheck(batch);
      
      // 5. 等待间隔
      if (i + batchSize < instances.length) {
        await this.waitForInterval();
      }
    }
    
    return {
      strategy: 'rolling',
      status: 'success',
      instanceCount: instances.length,
      batchCount: Math.ceil(instances.length / batchSize),
      releaseTime: new Date().toISOString()
    };
  }
  
  /**
   * 获取实例列表
   */
  async getInstances(environment) {
    // 模拟获取实例列表
    return new Promise(resolve => {
      setTimeout(() => {
        // 模拟5个实例
        resolve([
          { id: 'instance-1', host: 'host-1', port: 3001 },
          { id: 'instance-2', host: 'host-2', port: 3001 },
          { id: 'instance-3', host: 'host-3', port: 3001 },
          { id: 'instance-4', host: 'host-4', port: 3001 },
          { id: 'instance-5', host: 'host-5', port: 3001 }
        ]);
      }, 1000);
    });
  }
  
  /**
   * 更新批次
   */
  async updateBatch(batch, deployment) {
    // 模拟更新批次
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, 2000);
    });
  }
  
  /**
   * 执行健康检查
   */
  async performHealthCheck(instances) {
    // 模拟健康检查
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        // 模拟健康检查成功
        resolve();
      }, 1000);
    });
  }
  
  /**
   * 等待间隔
   */
  async waitForInterval() {
    // 等待一段时间
    return new Promise(resolve => {
      setTimeout(resolve, this.config.batchInterval);
    });
  }
}

// 使用示例
const deploymentManager = new MicroFrontendDeploymentManager();

// 部署应用到测试环境
deploymentManager.deployMicroApp('dashboard', 'testing', {
  strategy: 'blue-green'
})
.then(result => {
  console.log('部署结果:', result);
})
.catch(error => {
  console.error('部署失败:', error);
});

// 部署应用到生产环境，使用金丝雀发布
deploymentManager.deployMicroApp('user-profile', 'production', {
  strategy: 'canary'
})
.then(result => {
  console.log('部署结果:', result);
})
.catch(error => {
  console.error('部署失败:', error);
});

// 获取部署状态
deploymentManager.getDeploymentStatus('dashboard', 'testing')
.then(status => {
  console.log('部署状态:', status);
});

// 获取部署历史
deploymentManager.getDeploymentHistory('dashboard', 'testing', 5)
.then(history => {
  console.log('部署历史:', history);
});

// 回滚应用
deploymentManager.rollbackMicroApp('dashboard', 'testing', 'v1.0.1640000000000-123')
.then(result => {
  console.log('回滚结果:', result);
})
.catch(error => {
  console.error('回滚失败:', error);
});
```

## 12.3 微前端运维管理

### 12.3.1 运维管理概述

微前端运维管理主要包括以下方面：

1. **监控与告警**：实时监控微应用的运行状态，及时发现和解决问题
2. **日志管理**：集中收集和管理微应用的日志，便于问题排查
3. **性能优化**：持续优化微应用的性能，提升用户体验
4. **容量规划**：根据业务增长预测，合理规划资源
5. **故障处理**：快速响应和处理系统故障，减少影响范围
6. **版本管理**：管理微应用的版本发布和回滚

### 12.3.2 监控与告警系统

以下是一个微前端监控与告警系统的实现：

```javascript
/**
 * 微前端监控与告警系统
 */
class MicroFrontendMonitoringSystem {
  constructor(config = {}) {
    this.config = {
      // 监控配置
      monitoring: {
        // 数据收集间隔（毫秒）
        collectInterval: 60000,
        // 数据保留天数
        retentionDays: 30,
        // 告警规则
        alertRules: [
          {
            name: '高错误率',
            metric: 'errorRate',
            threshold: 5,
            operator: '>',
            duration: 300000, // 5分钟
            severity: 'high'
          },
          {
            name: '高响应时间',
            metric: 'responseTime',
            threshold: 1000,
            operator: '>',
            duration: 300000, // 5分钟
            severity: 'medium'
          },
          {
            name: '低可用性',
            metric: 'availability',
            threshold: 99,
            operator: '<',
            duration: 300000, // 5分钟
            severity: 'high'
          }
        ]
      },
      // 通知配置
      notification: {
        // 通知渠道
        channels: [
          {
            name: 'email',
            type: 'email',
            enabled: true,
            recipients: ['admin@example.com', 'ops@example.com']
          },
          {
            name: 'slack',
            type: 'slack',
            enabled: true,
            webhook: 'https://hooks.slack.com/services/xxx/yyy/zzz'
          },
          {
            name: 'sms',
            type: 'sms',
            enabled: false,
            recipients: ['+1234567890']
          }
        ]
      },
      // 微应用配置
      microApps: [
        {
          name: 'main-app',
          url: 'http://main-app.example.com',
          healthCheckPath: '/health',
          metricsPath: '/metrics'
        },
        {
          name: 'dashboard',
          url: 'http://dashboard.example.com',
          healthCheckPath: '/health',
          metricsPath: '/metrics'
        },
        {
          name: 'user-profile',
          url: 'http://user-profile.example.com',
          healthCheckPath: '/health',
          metricsPath: '/metrics'
        }
      ],
      ...config
    };
    
    // 数据收集器
    this.dataCollector = null;
    // 告警管理器
    this.alertManager = null;
    // 通知管理器
    this.notificationManager = null;
    // 数据存储
    this.dataStore = null;
    
    this.init();
  }
  
  /**
   * 初始化监控系统
   */
  init() {
    // 初始化数据存储
    this.dataStore = new MonitoringDataStore(this.config.monitoring.retentionDays);
    
    // 初始化数据收集器
    this.dataCollector = new DataCollector(this.config.microApps, this.config.monitoring.collectInterval);
    
    // 初始化告警管理器
    this.alertManager = new AlertManager(this.config.monitoring.alertRules);
    
    // 初始化通知管理器
    this.notificationManager = new NotificationManager(this.config.notification.channels);
    
    // 设置事件监听
    this.setupEventListeners();
  }
  
  /**
   * 启动监控系统
   */
  start() {
    console.log('启动微前端监控系统...');
    
    // 启动数据收集
    this.dataCollector.start();
    
    // 启动告警检查
    this.alertManager.start();
    
    console.log('微前端监控系统已启动');
  }
  
  /**
   * 停止监控系统
   */
  stop() {
    console.log('停止微前端监控系统...');
    
    // 停止数据收集
    this.dataCollector.stop();
    
    // 停止告警检查
    this.alertManager.stop();
    
    console.log('微前端监控系统已停止');
  }
  
  /**
   * 设置事件监听
   */
  setupEventListeners() {
    // 监听数据收集事件
    this.dataCollector.on('dataCollected', (data) => {
      // 存储数据
      this.dataStore.store(data);
      
      // 检查告警
      this.alertManager.checkAlerts(data);
    });
    
    // 监听告警事件
    this.alertManager.on('alert', (alert) => {
      // 发送通知
      this.notificationManager.sendNotification(alert);
    });
  }
  
  /**
   * 获取微应用状态
   */
  async getMicroAppStatus(appName) {
    const latestData = await this.dataStore.getLatestData(appName);
    
    if (!latestData) {
      return {
        appName,
        status: 'unknown',
        message: '无数据'
      };
    }
    
    // 计算状态
    let status = 'healthy';
    let message = '运行正常';
    
    if (latestData.errorRate > 5) {
      status = 'unhealthy';
      message = `错误率过高: ${latestData.errorRate.toFixed(2)}%`;
    } else if (latestData.responseTime > 1000) {
      status = 'degraded';
      message = `响应时间过长: ${latestData.responseTime.toFixed(2)}ms`;
    } else if (latestData.availability < 99) {
      status = 'unhealthy';
      message = `可用性过低: ${latestData.availability.toFixed(2)}%`;
    }
    
    return {
      appName,
      status,
      message,
      metrics: latestData,
      timestamp: latestData.timestamp
    };
  }
  
  /**
   * 获取微应用历史数据
   */
  async getMicroAppHistory(appName, startTime, endTime) {
    return await this.dataStore.getHistoryData(appName, startTime, endTime);
  }
  
  /**
   * 获取告警历史
   */
  async getAlertHistory(appName, startTime, endTime) {
    return await this.alertManager.getAlertHistory(appName, startTime, endTime);
  }
  
  /**
   * 添加告警规则
   */
  addAlertRule(rule) {
    this.alertManager.addRule(rule);
  }
  
  /**
   * 删除告警规则
   */
  removeAlertRule(ruleId) {
    this.alertManager.removeRule(ruleId);
  }
  
  /**
   * 更新告警规则
   */
  updateAlertRule(ruleId, updates) {
    this.alertManager.updateRule(ruleId, updates);
  }
}

/**
 * 数据收集器
 */
class DataCollector extends EventEmitter {
  constructor(microApps, collectInterval) {
    super();
    this.microApps = microApps;
    this.collectInterval = collectInterval;
    this.isRunning = false;
    this.intervalId = null;
  }
  
  /**
   * 启动数据收集
   */
  start() {
    if (this.isRunning) {
      return;
    }
    
    console.log('启动数据收集...');
    
    this.isRunning = true;
    
    // 立即收集一次数据
    this.collectData();
    
    // 设置定时收集
    this.intervalId = setInterval(() => {
      this.collectData();
    }, this.collectInterval);
  }
  
  /**
   * 停止数据收集
   */
  stop() {
    if (!this.isRunning) {
      return;
    }
    
    console.log('停止数据收集...');
    
    this.isRunning = false;
    
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
  
  /**
   * 收集数据
   */
  async collectData() {
    console.log('收集微应用数据...');
    
    const collectPromises = this.microApps.map(app => this.collectAppData(app));
    
    try {
      const results = await Promise.allSettled(collectPromises);
      
      results.forEach((result, index) => {
        const app = this.microApps[index];
        
        if (result.status === 'fulfilled') {
          // 发送数据收集事件
          this.emit('dataCollected', result.value);
        } else {
          console.error(`收集 ${app.name} 数据失败:`, result.reason);
          
          // 发送错误数据
          this.emit('dataCollected', {
            appName: app.name,
            timestamp: new Date().toISOString(),
            error: result.reason.message,
            status: 'error'
          });
        }
      });
    } catch (error) {
      console.error('数据收集失败:', error);
    }
  }
  
  /**
   * 收集单个应用数据
   */
  async collectAppData(app) {
    // 1. 健康检查
    const healthStatus = await this.performHealthCheck(app);
    
    // 2. 收集指标
    const metrics = await this.collectMetrics(app);
    
    // 3. 计算综合指标
    const calculatedMetrics = this.calculateMetrics(healthStatus, metrics);
    
    return {
      appName: app.name,
      timestamp: new Date().toISOString(),
      healthStatus,
      metrics,
      ...calculatedMetrics
    };
  }
  
  /**
   * 执行健康检查
   */
  async performHealthCheck(app) {
    try {
      const response = await fetch(`${app.url}${app.healthCheckPath}`, {
        method: 'GET',
        timeout: 5000
      });
      
      return {
        status: response.ok ? 'healthy' : 'unhealthy',
        statusCode: response.status,
        responseTime: response.headers.get('x-response-time') || null
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        error: error.message
      };
    }
  }
  
  /**
   * 收集指标
   */
  async collectMetrics(app) {
    try {
      const response = await fetch(`${app.url}${app.metricsPath}`, {
        method: 'GET',
        timeout: 5000
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      return {
        error: error.message
      };
    }
  }
  
  /**
   * 计算综合指标
   */
  calculateMetrics(healthStatus, metrics) {
    // 默认值
    let errorRate = 0;
    let responseTime = 0;
    let availability = 100;
    
    // 从指标中提取数据
    if (metrics && typeof metrics === 'object') {
      errorRate = metrics.errorRate || 0;
      responseTime = metrics.responseTime || 0;
      availability = metrics.availability || 100;
    }
    
    // 如果健康检查失败，设置可用性为0
    if (healthStatus.status === 'unhealthy') {
      availability = 0;
    }
    
    return {
      errorRate,
      responseTime,
      availability
    };
  }
}

/**
 * 告警管理器
 */
class AlertManager extends EventEmitter {
  constructor(alertRules) {
    super();
    this.alertRules = alertRules;
    this.activeAlerts = new Map();
    this.alertHistory = [];
    this.isRunning = false;
    this.intervalId = null;
  }
  
  /**
   * 启动告警检查
   */
  start() {
    if (this.isRunning) {
      return;
    }
    
    console.log('启动告警检查...');
    
    this.isRunning = true;
    
    // 设置定时检查
    this.intervalId = setInterval(() => {
      this.checkActiveAlerts();
    }, 60000); // 每分钟检查一次
  }
  
  /**
   * 停止告警检查
   */
  stop() {
    if (!this.isRunning) {
      return;
    }
    
    console.log('停止告警检查...');
    
    this.isRunning = false;
    
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
  
  /**
   * 检查告警
   */
  checkAlerts(data) {
    // 如果数据有错误，跳过检查
    if (data.status === 'error') {
      return;
    }
    
    for (const rule of this.alertRules) {
      this.checkRule(rule, data);
    }
  }
  
  /**
   * 检查单个规则
   */
  checkRule(rule, data) {
    // 获取指标值
    const metricValue = data[rule.metric];
    
    if (metricValue === undefined) {
      return;
    }
    
    // 检查阈值
    let isTriggered = false;
    
    switch (rule.operator) {
      case '>':
        isTriggered = metricValue > rule.threshold;
        break;
      case '<':
        isTriggered = metricValue < rule.threshold;
        break;
      case '>=':
        isTriggered = metricValue >= rule.threshold;
        break;
      case '<=':
        isTriggered = metricValue <= rule.threshold;
        break;
      case '==':
        isTriggered = metricValue === rule.threshold;
        break;
      case '!=':
        isTriggered = metricValue !== rule.threshold;
        break;
    }
    
    const alertKey = `${data.appName}-${rule.name}`;
    
    if (isTriggered) {
      // 触发告警
      this.triggerAlert(alertKey, rule, data);
    } else {
      // 恢复告警
      this.resolveAlert(alertKey, rule, data);
    }
  }
  
  /**
   * 触发告警
   */
  triggerAlert(alertKey, rule, data) {
    const existingAlert = this.activeAlerts.get(alertKey);
    
    if (existingAlert) {
      // 更新现有告警
      existingAlert.lastTriggered = new Date().toISOString();
      existingAlert.count++;
      return;
    }
    
    // 创建新告警
    const alert = {
      id: this.generateAlertId(),
      key: alertKey,
      appName: data.appName,
      ruleName: rule.name,
      metric: rule.metric,
      value: data[rule.metric],
      threshold: rule.threshold,
      operator: rule.operator,
      severity: rule.severity,
      status: 'active',
      firstTriggered: new Date().toISOString(),
      lastTriggered: new Date().toISOString(),
      count: 1
    };
    
    // 添加到活动告警
    this.activeAlerts.set(alertKey, alert);
    
    // 添加到历史记录
    this.alertHistory.push(alert);
    
    // 发送告警事件
    this.emit('alert', alert);
    
    console.log(`触发告警: ${alert.appName} - ${alert.ruleName} - ${alert.metric} ${alert.operator} ${alert.threshold} (当前值: ${alert.value})`);
  }
  
  /**
   * 恢复告警
   */
  resolveAlert(alertKey, rule, data) {
    const existingAlert = this.activeAlerts.get(alertKey);
    
    if (!existingAlert) {
      return;
    }
    
    // 更新告警状态
    existingAlert.status = 'resolved';
    existingAlert.resolvedAt = new Date().toISOString();
    existingAlert.resolvedValue = data[rule.metric];
    
    // 从活动告警中移除
    this.activeAlerts.delete(alertKey);
    
    // 添加到历史记录
    this.alertHistory.push({
      ...existingAlert,
      type: 'resolved'
    });
    
    // 发送告警恢复事件
    this.emit('alertResolved', existingAlert);
    
    console.log(`告警已恢复: ${existingAlert.appName} - ${existingAlert.ruleName}`);
  }
  
  /**
   * 检查活动告警
   */
  checkActiveAlerts() {
    // 检查长时间未恢复的告警
    const now = new Date();
    
    for (const [alertKey, alert] of this.activeAlerts) {
      const lastTriggered = new Date(alert.lastTriggered);
      const duration = now - lastTriggered;
      
      // 如果告警持续时间超过阈值，发送升级通知
      if (duration > 3600000) { // 1小时
        this.emit('alertEscalated', alert);
      }
    }
  }
  
  /**
   * 获取告警历史
   */
  getAlertHistory(appName, startTime, endTime) {
    let history = this.alertHistory;
    
    // 按应用名称过滤
    if (appName) {
      history = history.filter(alert => alert.appName === appName);
    }
    
    // 按时间范围过滤
    if (startTime) {
      const start = new Date(startTime);
      history = history.filter(alert => new Date(alert.firstTriggered) >= start);
    }
    
    if (endTime) {
      const end = new Date(endTime);
      history = history.filter(alert => new Date(alert.firstTriggered) <= end);
    }
    
    return history;
  }
  
  /**
   * 添加告警规则
   */
  addRule(rule) {
    this.alertRules.push(rule);
  }
  
  /**
   * 删除告警规则
   */
  removeRule(ruleId) {
    this.alertRules = this.alertRules.filter(rule => rule.id !== ruleId);
  }
  
  /**
   * 更新告警规则
   */
  updateRule(ruleId, updates) {
    const ruleIndex = this.alertRules.findIndex(rule => rule.id === ruleId);
    
    if (ruleIndex !== -1) {
      this.alertRules[ruleIndex] = {
        ...this.alertRules[ruleIndex],
        ...updates
      };
    }
  }
  
  /**
   * 生成告警ID
   */
  generateAlertId() {
    return `alert-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
  }
}

/**
 * 通知管理器
 */
class NotificationManager {
  constructor(channels) {
    this.channels = channels;
    this.notifiers = new Map();
    
    // 初始化通知器
    this.initNotifiers();
  }
  
  /**
   * 初始化通知器
   */
  initNotifiers() {
    for (const channel of this.channels) {
      if (!channel.enabled) {
        continue;
      }
      
      switch (channel.type) {
        case 'email':
          this.notifiers.set(channel.name, new EmailNotifier(channel));
          break;
        case 'slack':
          this.notifiers.set(channel.name, new SlackNotifier(channel));
          break;
        case 'sms':
          this.notifiers.set(channel.name, new SMSNotifier(channel));
          break;
      }
    }
  }
  
  /**
   * 发送通知
   */
  async sendNotification(alert) {
    const promises = [];
    
    for (const [name, notifier] of this.notifiers) {
      promises.push(this.sendNotificationToChannel(notifier, alert));
    }
    
    try {
      await Promise.allSettled(promises);
    } catch (error) {
      console.error('发送通知失败:', error);
    }
  }
  
  /**
   * 发送通知到指定渠道
   */
  async sendNotificationToChannel(notifier, alert) {
    try {
      await notifier.send(alert);
      console.log(`通知已发送到 ${notifier.channel.name}`);
    } catch (error) {
      console.error(`发送通知到 ${notifier.channel.name} 失败:`, error);
    }
  }
}

/**
 * 邮件通知器
 */
class EmailNotifier {
  constructor(channel) {
    this.channel = channel;
  }
  
  /**
   * 发送邮件通知
   */
  async send(alert) {
    // 构建邮件内容
    const subject = `[${alert.severity.toUpperCase()}] 微前端告警: ${alert.appName} - ${alert.ruleName}`;
    const body = this.buildEmailBody(alert);
    
    // 模拟发送邮件
    console.log(`发送邮件通知: ${subject}`);
    console.log(`收件人: ${this.channel.recipients.join(', ')}`);
    console.log(`内容: ${body}`);
    
    // 实际实现中，这里应该调用邮件服务API
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, 1000);
    });
  }
  
  /**
   * 构建邮件内容
   */
  buildEmailBody(alert) {
    return `
      <h2>微前端告警通知</h2>
      <p><strong>应用名称:</strong> ${alert.appName}</p>
      <p><strong>告警规则:</strong> ${alert.ruleName}</p>
      <p><strong>严重程度:</strong> ${alert.severity}</p>
      <p><strong>指标:</strong> ${alert.metric}</p>
      <p><strong>当前值:</strong> ${alert.value}</p>
      <p><strong>阈值:</strong> ${alert.operator} ${alert.threshold}</p>
      <p><strong>触发时间:</strong> ${alert.firstTriggered}</p>
      <p><strong>触发次数:</strong> ${alert.count}</p>
      
      <p>请及时处理此告警。</p>
    `;
  }
}

/**
 * Slack通知器
 */
class SlackNotifier {
  constructor(channel) {
    this.channel = channel;
  }
  
  /**
   * 发送Slack通知
   */
  async send(alert) {
    // 构建Slack消息
    const message = this.buildSlackMessage(alert);
    
    // 模拟发送Slack消息
    console.log(`发送Slack通知: ${JSON.stringify(message)}`);
    
    // 实际实现中，这里应该调用Slack Webhook API
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, 1000);
    });
  }
  
  /**
   * 构建Slack消息
   */
  buildSlackMessage(alert) {
    const color = this.getColorBySeverity(alert.severity);
    
    return {
      attachments: [
        {
          color,
          title: `微前端告警: ${alert.appName} - ${alert.ruleName}`,
          fields: [
            {
              title: '严重程度',
              value: alert.severity,
              short: true
            },
            {
              title: '指标',
              value: `${alert.metric} ${alert.operator} ${alert.threshold}`,
              short: true
            },
            {
              title: '当前值',
              value: alert.value,
              short: true
            },
            {
              title: '触发时间',
              value: alert.firstTriggered,
              short: true
            },
            {
              title: '触发次数',
              value: alert.count,
              short: true
            }
          ],
          footer: '微前端监控系统',
          ts: Math.floor(new Date(alert.firstTriggered).getTime() / 1000)
        }
      ]
    };
  }
  
  /**
   * 根据严重程度获取颜色
   */
  getColorBySeverity(severity) {
    switch (severity) {
      case 'high':
        return 'danger';
      case 'medium':
        return 'warning';
      case 'low':
        return 'good';
      default:
        return 'good';
    }
  }
}

/**
 * 短信通知器
 */
class SMSNotifier {
  constructor(channel) {
    this.channel = channel;
  }
  
  /**
   * 发送短信通知
   */
  async send(alert) {
    // 构建短信内容
    const message = this.buildSMSMessage(alert);
    
    // 模拟发送短信
    console.log(`发送短信通知: ${message}`);
    console.log(`收件人: ${this.channel.recipients.join(', ')}`);
    
    // 实际实现中，这里应该调用短信服务API
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, 1000);
    });
  }
  
  /**
   * 构建短信内容
   */
  buildSMSMessage(alert) {
    return `[${alert.severity.toUpperCase()}] 微前端告警: ${alert.appName} - ${alert.ruleName}。${alert.metric} 当前值 ${alert.value}，阈值 ${alert.operator} ${alert.threshold}。`;
  }
}

/**
 * 监控数据存储
 */
class MonitoringDataStore {
  constructor(retentionDays) {
    this.retentionDays = retentionDays;
    this.data = new Map();
  }
  
  /**
   * 存储数据
   */
  store(data) {
    const appName = data.appName;
    
    if (!this.data.has(appName)) {
      this.data.set(appName, []);
    }
    
    const appData = this.data.get(appName);
    appData.push(data);
    
    // 清理过期数据
    this.cleanupOldData(appData);
  }
  
  /**
   * 获取最新数据
   */
  async getLatestData(appName) {
    const appData = this.data.get(appName);
    
    if (!appData || appData.length === 0) {
      return null;
    }
    
    return appData[appData.length - 1];
  }
  
  /**
   * 获取历史数据
   */
  async getHistoryData(appName, startTime, endTime) {
    const appData = this.data.get(appName) || [];
    
    let filteredData = appData;
    
    // 按时间范围过滤
    if (startTime) {
      const start = new Date(startTime);
      filteredData = filteredData.filter(data => new Date(data.timestamp) >= start);
    }
    
    if (endTime) {
      const end = new Date(endTime);
      filteredData = filteredData.filter(data => new Date(data.timestamp) <= end);
    }
    
    return filteredData;
  }
  
  /**
   * 清理过期数据
   */
  cleanupOldData(appData) {
    const now = new Date();
    const retentionTime = this.retentionDays * 24 * 60 * 60 * 1000; // 转换为毫秒
    
    // 找出需要保留的数据
    const validData = appData.filter(data => {
      const dataTime = new Date(data.timestamp);
      return now - dataTime <= retentionTime;
    });
    
    // 更新数据
    appData.length = 0;
    appData.push(...validData);
  }
}

// 使用示例
const monitoringSystem = new MicroFrontendMonitoringSystem();

// 启动监控系统
monitoringSystem.start();

// 获取微应用状态
monitoringSystem.getMicroAppStatus('dashboard')
  .then(status => {
    console.log('微应用状态:', status);
  });

// 获取微应用历史数据
const endTime = new Date();
const startTime = new Date(endTime.getTime() - 24 * 60 * 60 * 1000); // 24小时前

monitoringSystem.getMicroAppHistory('dashboard', startTime.toISOString(), endTime.toISOString())
  .then(history => {
    console.log('微应用历史数据:', history);
  });

// 获取告警历史
monitoringSystem.getAlertHistory('dashboard', startTime.toISOString(), endTime.toISOString())
  .then(alerts => {
    console.log('告警历史:', alerts);
  });

// 添加自定义告警规则
monitoringSystem.addAlertRule({
  name: 'CPU使用率过高',
  metric: 'cpuUsage',
  threshold: 80,
  operator: '>',
  duration: 300000,
  severity: 'medium'
});

// 停止监控系统
// monitoringSystem.stop();
```

## 12.4 微前端日志管理

### 12.4.1 日志管理概述

微前端日志管理的主要挑战和需求：

1. **分布式日志收集**：从多个微应用收集日志数据
2. **日志格式统一**：确保不同微应用的日志格式一致
3. **日志关联分析**：将不同微应用的日志关联起来分析问题
4. **日志存储与检索**：高效存储和检索大量日志数据
5. **实时日志监控**：实时监控日志，及时发现异常
6. **日志安全与隐私**：确保日志中的敏感信息得到保护

### 12.4.2 日志管理系统实现

以下是一个微前端日志管理系统的实现：

```javascript
/**
 * 微前端日志管理系统
 */
class MicroFrontendLogManager {
  constructor(config = {}) {
    this.config = {
      // 日志配置
      logging: {
        // 日志级别
        level: 'info',
        // 日志格式
        format: 'json',
        // 日志收集间隔（毫秒）
        collectInterval: 30000,
        // 日志批量大小
        batchSize: 100,
        // 日志保留天数
        retentionDays: 30
      },
      // 微应用配置
      microApps: [
        {
          name: 'main-app',
          logEndpoint: '/api/logs',
          logLevels: ['error', 'warn', 'info', 'debug']
        },
        {
          name: 'dashboard',
          logEndpoint: '/api/logs',
          logLevels: ['error', 'warn', 'info']
        },
        {
          name: 'user-profile',
          logEndpoint: '/api/logs',
          logLevels: ['error', 'warn', 'info']
        }
      ],
      // 存储配置
      storage: {
        type: 'elasticsearch',
        host: 'http://localhost:9200',
        index: 'micro-frontend-logs'
      },
      // 搜索配置
      search: {
        type: 'elasticsearch',
        host: 'http://localhost:9200',
        index: 'micro-frontend-logs'
      },
      ...config
    };
    
    // 日志收集器
    this.logCollector = null;
    // 日志存储
    this.logStorage = null;
    // 日志搜索
    this.logSearch = null;
    // 日志分析器
    this.logAnalyzer = null;
    
    this.init();
  }
  
  /**
   * 初始化日志管理系统
   */
  init() {
    // 初始化日志存储
    this.logStorage = new LogStorage(this.config.storage);
    
    // 初始化日志搜索
    this.logSearch = new LogSearch(this.config.search);
    
    // 初始化日志收集器
    this.logCollector = new LogCollector(this.config.microApps, this.config.logging);
    
    // 初始化日志分析器
    this.logAnalyzer = new LogAnalyzer();
    
    // 设置事件监听
    this.setupEventListeners();
  }
  
  /**
   * 启动日志管理系统
   */
  start() {
    console.log('启动微前端日志管理系统...');
    
    // 启动日志收集
    this.logCollector.start();
    
    console.log('微前端日志管理系统已启动');
  }
  
  /**
   * 停止日志管理系统
   */
  stop() {
    console.log('停止微前端日志管理系统...');
    
    // 停止日志收集
    this.logCollector.stop();
    
    console.log('微前端日志管理系统已停止');
  }
  
  /**
   * 设置事件监听
   */
  setupEventListeners() {
    // 监听日志收集事件
    this.logCollector.on('logsCollected', (logs) => {
      // 存储日志
      this.logStorage.store(logs);
      
      // 分析日志
      this.logAnalyzer.analyze(logs);
    });
  }
  
  /**
   * 搜索日志
   */
  async searchLogs(query, options = {}) {
    return await this.logSearch.search(query, options);
  }
  
  /**
   * 获取日志统计
   */
  async getLogStatistics(startTime, endTime, groupBy = 'app') {
    return await this.logSearch.getStatistics(startTime, endTime, groupBy);
  }
  
  /**
   * 获取错误日志
   */
  async getErrorLogs(startTime, endTime, appName = null) {
    return await this.logSearch.getErrorLogs(startTime, endTime, appName);
  }
  
  /**
   * 获取日志趋势
   */
  async getLogTrends(startTime, endTime, interval = '1h') {
    return await this.logSearch.getTrends(startTime, endTime, interval);
  }
}

/**
 * 日志收集器
 */
class LogCollector extends EventEmitter {
  constructor(microApps, config) {
    super();
    this.microApps = microApps;
    this.config = config;
    this.isRunning = false;
    this.intervalId = null;
    this.logBuffer = [];
  }
  
  /**
   * 启动日志收集
   */
  start() {
    if (this.isRunning) {
      return;
    }
    
    console.log('启动日志收集...');
    
    this.isRunning = true;
    
    // 设置定时收集
    this.intervalId = setInterval(() => {
      this.collectLogs();
    }, this.config.collectInterval);
  }
  
  /**
   * 停止日志收集
   */
  stop() {
    if (!this.isRunning) {
      return;
    }
    
    console.log('停止日志收集...');
    
    this.isRunning = false;
    
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
    
    // 处理剩余日志
    if (this.logBuffer.length > 0) {
      this.processLogs(this.logBuffer);
      this.logBuffer = [];
    }
  }
  
  /**
   * 收集日志
   */
  async collectLogs() {
    console.log('收集微应用日志...');
    
    const collectPromises = this.microApps.map(app => this.collectAppLogs(app));
    
    try {
      const results = await Promise.allSettled(collectPromises);
      
      const allLogs = [];
      
      results.forEach((result, index) => {
        const app = this.microApps[index];
        
        if (result.status === 'fulfilled' && result.value) {
          allLogs.push(...result.value);
        } else {
          console.error(`收集 ${app.name} 日志失败:`, result.reason);
        }
      });
      
      // 添加到缓冲区
      this.logBuffer.push(...allLogs);
      
      // 如果缓冲区达到批量大小，处理日志
      if (this.logBuffer.length >= this.config.batchSize) {
        this.processLogs(this.logBuffer.slice(0, this.config.batchSize));
        this.logBuffer = this.logBuffer.slice(this.config.batchSize);
      }
    } catch (error) {
      console.error('日志收集失败:', error);
    }
  }
  
  /**
   * 收集单个应用日志
   */
  async collectAppLogs(app) {
    try {
      // 构建请求URL
      const url = `${app.url || ''}${app.logEndpoint}`;
      
      // 构建请求参数
      const params = {
        level: app.logLevels.join(','),
        limit: 100,
        format: this.config.format
      };
      
      // 发送请求
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      const logs = await response.json();
      
      // 添加应用名称和时间戳
      return logs.map(log => ({
        ...log,
        appName: app.name,
        collectedAt: new Date().toISOString()
      }));
    } catch (error) {
      console.error(`收集 ${app.name} 日志失败:`, error);
      return [];
    }
  }
  
  /**
   * 处理日志
   */
  processLogs(logs) {
    if (logs.length === 0) {
      return;
    }
    
    // 标准化日志格式
    const standardizedLogs = logs.map(log => this.standardizeLog(log));
    
    // 发送日志收集事件
    this.emit('logsCollected', standardizedLogs);
  }
  
  /**
   * 标准化日志格式
   */
  standardizeLog(log) {
    return {
      timestamp: log.timestamp || log.time || new Date().toISOString(),
      level: log.level || 'info',
      message: log.message || log.msg || '',
      appName: log.appName || 'unknown',
      userId: log.userId || null,
      sessionId: log.sessionId || null,
      requestId: log.requestId || null,
      url: log.url || null,
      userAgent: log.userAgent || null,
      ip: log.ip || null,
      error: log.error || null,
      stack: log.stack || null,
      metadata: log.metadata || {},
      collectedAt: log.collectedAt
    };
  }
}

/**
 * 日志存储
 */
class LogStorage {
  constructor(config) {
    this.config = config;
  }
  
  /**
   * 存储日志
   */
  async store(logs) {
    if (logs.length === 0) {
      return;
    }
    
    console.log(`存储 ${logs.length} 条日志`);
    
    try {
      // 根据存储类型选择存储方法
      switch (this.config.type) {
        case 'elasticsearch':
          await this.storeToElasticsearch(logs);
          break;
        case 'mongodb':
          await this.storeToMongoDB(logs);
          break;
        case 'file':
          await this.storeToFile(logs);
          break;
        default:
          throw new Error(`不支持的存储类型: ${this.config.type}`);
      }
    } catch (error) {
      console.error('日志存储失败:', error);
    }
  }
  
  /**
   * 存储到Elasticsearch
   */
  async storeToElasticsearch(logs) {
    // 模拟存储到Elasticsearch
    console.log(`存储 ${logs.length} 条日志到 Elasticsearch: ${this.config.host}/${this.config.index}`);
    
    // 实际实现中，这里应该调用Elasticsearch API
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, 1000);
    });
  }
  
  /**
   * 存储到MongoDB
   */
  async storeToMongoDB(logs) {
    // 模拟存储到MongoDB
    console.log(`存储 ${logs.length} 条日志到 MongoDB`);
    
    // 实际实现中，这里应该调用MongoDB驱动
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, 1000);
    });
  }
  
  /**
   * 存储到文件
   */
  async storeToFile(logs) {
    // 模拟存储到文件
    console.log(`存储 ${logs.length} 条日志到文件`);
    
    // 实际实现中，这里应该写入文件系统
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, 1000);
    });
  }
}

/**
 * 日志搜索
 */
class LogSearch {
  constructor(config) {
    this.config = config;
  }
  
  /**
   * 搜索日志
   */
  async search(query, options = {}) {
    console.log(`搜索日志: ${JSON.stringify(query)}`);
    
    try {
      // 根据搜索类型选择搜索方法
      switch (this.config.type) {
        case 'elasticsearch':
          return await this.searchInElasticsearch(query, options);
        case 'mongodb':
          return await this.searchInMongoDB(query, options);
        default:
          throw new Error(`不支持的搜索类型: ${this.config.type}`);
      }
    } catch (error) {
      console.error('日志搜索失败:', error);
      return [];
    }
  }
  
  /**
   * 在Elasticsearch中搜索
   */
  async searchInElasticsearch(query, options) {
    // 模拟在Elasticsearch中搜索
    console.log(`在 Elasticsearch 中搜索日志: ${this.config.host}/${this.config.index}`);
    
    // 实际实现中，这里应该调用Elasticsearch API
    return new Promise(resolve => {
      setTimeout(() => {
        // 模拟搜索结果
        resolve([
          {
            id: 'log-1',
            timestamp: '2023-01-01T12:00:00Z',
            level: 'error',
            message: '数据库连接失败',
            appName: 'dashboard',
            userId: 'user-123',
            metadata: {
              component: 'database',
              action: 'connect'
            }
          },
          {
            id: 'log-2',
            timestamp: '2023-01-01T12:05:00Z',
            level: 'warn',
            message: 'API响应时间过长',
            appName: 'user-profile',
            userId: 'user-456',
            metadata: {
              endpoint: '/api/users',
              responseTime: 1500
            }
          }
        ]);
      }, 1000);
    });
  }
  
  /**
   * 在MongoDB中搜索
   */
  async searchInMongoDB(query, options) {
    // 模拟在MongoDB中搜索
    console.log('在 MongoDB 中搜索日志');
    
    // 实际实现中，这里应该调用MongoDB驱动
    return new Promise(resolve => {
      setTimeout(() => {
        // 模拟搜索结果
        resolve([]);
      }, 1000);
    });
  }
  
  /**
   * 获取日志统计
   */
  async getStatistics(startTime, endTime, groupBy = 'app') {
    console.log(`获取日志统计: ${startTime} - ${endTime}, 分组: ${groupBy}`);
    
    // 模拟统计数据
    return {
      totalLogs: 10000,
      errorLogs: 100,
      warnLogs: 500,
      infoLogs: 8000,
      debugLogs: 1400,
      groupBy: groupBy,
      groups: [
        {
          name: 'main-app',
          totalLogs: 4000,
          errorLogs: 40,
          warnLogs: 200,
          infoLogs: 3200,
          debugLogs: 560
        },
        {
          name: 'dashboard',
          totalLogs: 3000,
          errorLogs: 30,
          warnLogs: 150,
          infoLogs: 2400,
          debugLogs: 420
        },
        {
          name: 'user-profile',
          totalLogs: 3000,
          errorLogs: 30,
          warnLogs: 150,
          infoLogs: 2400,
          debugLogs: 420
        }
      ]
    };
  }
  
  /**
   * 获取错误日志
   */
  async getErrorLogs(startTime, endTime, appName = null) {
    console.log(`获取错误日志: ${startTime} - ${endTime}, 应用: ${appName}`);
    
    // 模拟错误日志
    return [
      {
        id: 'error-1',
        timestamp: '2023-01-01T12:00:00Z',
        level: 'error',
        message: '数据库连接失败',
        appName: appName || 'dashboard',
        userId: 'user-123',
        error: {
          name: 'ConnectionError',
          message: '无法连接到数据库',
          stack: 'Error: 无法连接到数据库\n    at connect (db.js:45:10)\n    at processTicksAndRejections (internal/process/task_queues.js:93:5)'
        },
        metadata: {
          component: 'database',
          action: 'connect',
          retryCount: 3
        }
      },
      {
        id: 'error-2',
        timestamp: '2023-01-01T12:30:00Z',
        level: 'error',
        message: '用户认证失败',
        appName: appName || 'user-profile',
        userId: null,
        error: {
          name: 'AuthenticationError',
          message: '无效的认证令牌',
          stack: 'Error: 无效的认证令牌\n    at verifyToken (auth.js:78:15)\n    at authenticate (middleware.js:23:12)'
        },
        metadata: {
          component: 'auth',
          action: 'verify',
          token: 'invalid-token'
        }
      }
    ];
  }
  
  /**
   * 获取日志趋势
   */
  async getTrends(startTime, endTime, interval = '1h') {
    console.log(`获取日志趋势: ${startTime} - ${endTime}, 间隔: ${interval}`);
    
    // 模拟趋势数据
    return {
      interval,
      data: [
        {
          timestamp: '2023-01-01T00:00:00Z',
          total: 400,
          error: 5,
          warn: 20,
          info: 320,
          debug: 55
        },
        {
          timestamp: '2023-01-01T01:00:00Z',
          total: 350,
          error: 3,
          warn: 18,
          info: 280,
          debug: 49
        },
        {
          timestamp: '2023-01-01T02:00:00Z',
          total: 300,
          error: 2,
          warn: 15,
          info: 240,
          debug: 43
        }
      ]
    };
  }
}

/**
 * 日志分析器
 */
class LogAnalyzer {
  constructor() {
    this.analysisResults = [];
  }
  
  /**
   * 分析日志
   */
  analyze(logs) {
    if (logs.length === 0) {
      return;
    }
    
    console.log(`分析 ${logs.length} 条日志`);
    
    // 1. 错误分析
    this.analyzeErrors(logs);
    
    // 2. 性能分析
    this.analyzePerformance(logs);
    
    // 3. 用户行为分析
    this.analyzeUserBehavior(logs);
    
    // 4. 安全分析
    this.analyzeSecurity(logs);
  }
  
  /**
   * 错误分析
   */
  analyzeErrors(logs) {
    const errorLogs = logs.filter(log => log.level === 'error');
    
    if (errorLogs.length === 0) {
      return;
    }
    
    // 按错误类型分组
    const errorTypes = {};
    
    errorLogs.forEach(log => {
      const errorType = log.error?.name || 'UnknownError';
      
      if (!errorTypes[errorType]) {
        errorTypes[errorType] = {
          count: 0,
          apps: new Set(),
          messages: new Set()
        };
      }
      
      errorTypes[errorType].count++;
      errorTypes[errorType].apps.add(log.appName);
      errorTypes[errorType].messages.add(log.message);
    });
    
    // 转换为数组格式
    const errorAnalysis = Object.entries(errorTypes).map(([type, data]) => ({
      type,
      count: data.count,
      apps: Array.from(data.apps),
      messages: Array.from(data.messages)
    }));
    
    // 添加到分析结果
    this.analysisResults.push({
      type: 'error',
      timestamp: new Date().toISOString(),
      data: errorAnalysis
    });
    
    console.log('错误分析结果:', errorAnalysis);
  }
  
  /**
   * 性能分析
   */
  analyzePerformance(logs) {
    // 筛选性能相关日志
    const performanceLogs = logs.filter(log => 
      log.metadata?.responseTime || 
      log.metadata?.duration || 
      log.message.includes('性能') ||
      log.message.includes('响应时间')
    );
    
    if (performanceLogs.length === 0) {
      return;
    }
    
    // 计算平均响应时间
    const responseTimes = performanceLogs
      .filter(log => log.metadata?.responseTime)
      .map(log => log.metadata.responseTime);
    
    if (responseTimes.length > 0) {
      const avgResponseTime = responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length;
      const maxResponseTime = Math.max(...responseTimes);
      const minResponseTime = Math.min(...responseTimes);
      
      // 添加到分析结果
      this.analysisResults.push({
        type: 'performance',
        timestamp: new Date().toISOString(),
        data: {
          avgResponseTime,
          maxResponseTime,
          minResponseTime,
          sampleCount: responseTimes.length
        }
      });
      
      console.log('性能分析结果:', {
        avgResponseTime,
        maxResponseTime,
        minResponseTime,
        sampleCount: responseTimes.length
      });
    }
  }
  
  /**
   * 用户行为分析
   */
  analyzeUserBehavior(logs) {
    // 筛选用户相关日志
    const userLogs = logs.filter(log => log.userId);
    
    if (userLogs.length === 0) {
      return;
    }
    
    // 按用户分组
    const userActivities = {};
    
    userLogs.forEach(log => {
      if (!userActivities[log.userId]) {
        userActivities[log.userId] = {
          count: 0,
          apps: new Set(),
          actions: new Set(),
          errors: 0
        };
      }
      
      userActivities[log.userId].count++;
      userActivities[log.userId].apps.add(log.appName);
      
      if (log.metadata?.action) {
        userActivities[log.userId].actions.add(log.metadata.action);
      }
      
      if (log.level === 'error') {
        userActivities[log.userId].errors++;
      }
    });
    
    // 转换为数组格式
    const userBehaviorAnalysis = Object.entries(userActivities)
      .map(([userId, data]) => ({
        userId,
        count: data.count,
        apps: Array.from(data.apps),
        actions: Array.from(data.actions),
        errors: data.errors
      }))
      .sort((a, b) => b.count - a.count) // 按活动次数降序排序
      .slice(0, 10); // 取前10个最活跃用户
    
    // 添加到分析结果
    this.analysisResults.push({
      type: 'userBehavior',
      timestamp: new Date().toISOString(),
      data: userBehaviorAnalysis
    });
    
    console.log('用户行为分析结果:', userBehaviorAnalysis);
  }
  
  /**
   * 安全分析
   */
  analyzeSecurity(logs) {
    // 筛选安全相关日志
    const securityLogs = logs.filter(log => 
      log.level === 'error' && (
        log.message.includes('认证') ||
        log.message.includes('授权') ||
        log.message.includes('登录') ||
        log.message.includes('权限') ||
        log.error?.name === 'AuthenticationError' ||
        log.error?.name === 'AuthorizationError'
      )
    );
    
    if (securityLogs.length === 0) {
      return;
    }
    
    // 按IP地址分组
    const ipActivities = {};
    
    securityLogs.forEach(log => {
      const ip = log.ip || 'unknown';
      
      if (!ipActivities[ip]) {
        ipActivities[ip] = {
          count: 0,
          users: new Set(),
          errors: []
        };
      }
      
      ipActivities[ip].count++;
      
      if (log.userId) {
        ipActivities[ip].users.add(log.userId);
      }
      
      ipActivities[ip].errors.push({
        timestamp: log.timestamp,
        message: log.message,
        userId: log.userId
      });
    });
    
    // 转换为数组格式
    const securityAnalysis = Object.entries(ipActivities)
      .map(([ip, data]) => ({
        ip,
        count: data.count,
        users: Array.from(data.users),
        errors: data.errors
      }))
      .filter(item => item.count > 5) // 只关注失败次数超过5次的IP
      .sort((a, b) => b.count - a.count);
    
    if (securityAnalysis.length > 0) {
      // 添加到分析结果
      this.analysisResults.push({
        type: 'security',
        timestamp: new Date().toISOString(),
        data: securityAnalysis
      });
      
      console.log('安全分析结果:', securityAnalysis);
    }
  }
  
  /**
   * 获取分析结果
   */
  getAnalysisResults(type = null, limit = 10) {
    let results = this.analysisResults;
    
    // 按类型过滤
    if (type) {
      results = results.filter(result => result.type === type);
    }
    
    // 按时间降序排序
    results.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    
    // 限制数量
    return results.slice(0, limit);
  }
}

// 使用示例
const logManager = new MicroFrontendLogManager();

// 启动日志管理系统
logManager.start();

// 搜索日志
logManager.searchLogs({
  level: 'error',
  appName: 'dashboard',
  startTime: '2023-01-01T00:00:00Z',
  endTime: '2023-01-01T23:59:59Z'
})
.then(logs => {
  console.log('搜索结果:', logs);
});

// 获取日志统计
const endTime = new Date();
const startTime = new Date(endTime.getTime() - 24 * 60 * 60 * 1000); // 24小时前

logManager.getLogStatistics(startTime.toISOString(), endTime.toISOString())
.then(stats => {
  console.log('日志统计:', stats);
});

// 获取错误日志
logManager.getErrorLogs(startTime.toISOString(), endTime.toISOString(), 'dashboard')
.then(errorLogs => {
  console.log('错误日志:', errorLogs);
});

// 获取日志趋势
logManager.getLogTrends(startTime.toISOString(), endTime.toISOString(), '1h')
.then(trends => {
  console.log('日志趋势:', trends);
});

// 停止日志管理系统
// logManager.stop();
```

## 12.5 微前端性能优化

### 12.5.1 性能优化概述

微前端性能优化是确保用户体验的关键环节，主要包括以下方面：

1. **加载性能**：减少初始加载时间，提高首屏渲染速度
2. **运行时性能**：优化应用运行时的资源使用和响应速度
3. **资源管理**：合理管理微应用的资源加载和释放
4. **缓存策略**：设计有效的缓存策略，减少重复请求
5. **代码分割**：合理分割代码，按需加载微应用
6. **监控与分析**：持续监控性能指标，分析瓶颈并优化

### 12.5.2 性能优化策略

以下是一个微前端性能优化系统的实现：

```javascript
/**
 * 微前端性能优化系统
 */
class MicroFrontendPerformanceOptimizer {
  constructor(config = {}) {
    this.config = {
      // 性能监控配置
      monitoring: {
        // 性能指标收集间隔（毫秒）
        collectInterval: 30000,
        // 性能数据保留天数
        retentionDays: 7,
        // 性能阈值配置
        thresholds: {
          // 首屏渲染时间（毫秒）
          firstContentfulPaint: 1500,
          // 最大内容绘制时间（毫秒）
          largestContentfulPaint: 2500,
          // 首次输入延迟（毫秒）
          firstInputDelay: 100,
          // 累积布局偏移
          cumulativeLayoutShift: 0.1,
          // 内存使用（MB）
          memoryUsage: 100,
          // CPU使用率（百分比）
          cpuUsage: 70
        }
      },
      // 微应用配置
      microApps: [
        {
          name: 'main-app',
          url: 'http://main-app.example.com',
          entry: 'main.js',
          preload: true,
          lazy: false
        },
        {
          name: 'dashboard',
          url: 'http://dashboard.example.com',
          entry: 'dashboard.js',
          preload: false,
          lazy: true
        },
        {
          name: 'user-profile',
          url: 'http://user-profile.example.com',
          entry: 'user-profile.js',
          preload: false,
          lazy: true
        }
      ],
      // 优化配置
      optimization: {
        // 代码分割
        codeSplitting: {
          enabled: true,
          chunkSize: 200000, // 200KB
          maxChunks: 10
        },
        // 资源压缩
        compression: {
          enabled: true,
          algorithm: 'gzip',
          level: 6
        },
        // 缓存配置
        caching: {
          enabled: true,
          strategy: 'cache-first',
          maxAge: 86400000, // 24小时
          maxSize: 50000000 // 50MB
        },
        // 预加载配置
        preloading: {
          enabled: true,
          priority: 'high',
          timeout: 10000
        }
      },
      ...config
    };
    
    // 性能监控器
    this.performanceMonitor = null;
    // 资源管理器
    this.resourceManager = null;
    // 缓存管理器
    this.cacheManager = null;
    // 预加载管理器
    this.preloadManager = null;
    
    this.init();
  }
  
  /**
   * 初始化性能优化系统
   */
  init() {
    // 初始化性能监控器
    this.performanceMonitor = new PerformanceMonitor(this.config.monitoring);
    
    // 初始化资源管理器
    this.resourceManager = new ResourceManager(this.config.microApps);
    
    // 初始化缓存管理器
    this.cacheManager = new CacheManager(this.config.optimization.caching);
    
    // 初始化预加载管理器
    this.preloadManager = new PreloadManager(this.config.optimization.preloading);
    
    // 设置事件监听
    this.setupEventListeners();
  }
  
  /**
   * 启动性能优化系统
   */
  start() {
    console.log('启动微前端性能优化系统...');
    
    // 启动性能监控
    this.performanceMonitor.start();
    
    // 初始化资源管理
    this.resourceManager.init();
    
    // 预加载关键资源
    this.preloadCriticalResources();
    
    console.log('微前端性能优化系统已启动');
  }
  
  /**
   * 停止性能优化系统
   */
  stop() {
    console.log('停止微前端性能优化系统...');
    
    // 停止性能监控
    this.performanceMonitor.stop();
    
    // 清理资源
    this.resourceManager.cleanup();
    
    console.log('微前端性能优化系统已停止');
  }
  
  /**
   * 设置事件监听
   */
  setupEventListeners() {
    // 监听性能指标事件
    this.performanceMonitor.on('metricsCollected', (metrics) => {
      // 分析性能指标
      this.analyzePerformanceMetrics(metrics);
    });
    
    // 监听性能警告事件
    this.performanceMonitor.on('performanceWarning', (warning) => {
      // 处理性能警告
      this.handlePerformanceWarning(warning);
    });
  }
  
  /**
   * 预加载关键资源
   */
  preloadCriticalResources() {
    console.log('预加载关键资源...');
    
    // 获取需要预加载的应用
    const preloadApps = this.config.microApps.filter(app => app.preload);
    
    // 预加载每个应用
    preloadApps.forEach(app => {
      this.preloadManager.preloadApp(app);
    });
  }
  
  /**
   * 加载微应用
   */
  async loadMicroApp(appName) {
    console.log(`加载微应用: ${appName}`);
    
    // 获取应用配置
    const app = this.config.microApps.find(a => a.name === appName);
    if (!app) {
      throw new Error(`微应用不存在: ${appName}`);
    }
    
    try {
      // 1. 检查缓存
      const cachedApp = await this.cacheManager.get(appName);
      if (cachedApp) {
        console.log(`从缓存加载微应用: ${appName}`);
        return cachedApp;
      }
      
      // 2. 加载应用资源
      const appResources = await this.resourceManager.loadApp(app);
      
      // 3. 缓存应用
      await this.cacheManager.set(appName, appResources);
      
      // 4. 返回应用
      return appResources;
    } catch (error) {
      console.error(`加载微应用 ${appName} 失败:`, error);
      throw error;
    }
  }
  
  /**
   * 卸载微应用
   */
  async unloadMicroApp(appName) {
    console.log(`卸载微应用: ${appName}`);
    
    try {
      // 1. 卸载应用
      await this.resourceManager.unloadApp(appName);
      
      // 2. 清理缓存（可选）
      // await this.cacheManager.remove(appName);
      
      console.log(`微应用 ${appName} 卸载完成`);
    } catch (error) {
      console.error(`卸载微应用 ${appName} 失败:`, error);
      throw error;
    }
  }
  
  /**
   * 分析性能指标
   */
  analyzePerformanceMetrics(metrics) {
    // 检查是否超过阈值
    const warnings = [];
    
    for (const [metric, value] of Object.entries(metrics)) {
      const threshold = this.config.monitoring.thresholds[metric];
      
      if (threshold !== undefined && value > threshold) {
        warnings.push({
          metric,
          value,
          threshold,
          percentage: ((value - threshold) / threshold * 100).toFixed(2)
        });
      }
    }
    
    // 如果有警告，发出警告事件
    if (warnings.length > 0) {
      this.performanceMonitor.emit('performanceWarning', {
        appName: metrics.appName,
        warnings,
        timestamp: new Date().toISOString()
      });
    }
  }
  
  /**
   * 处理性能警告
   */
  handlePerformanceWarning(warning) {
    console.warn('性能警告:', warning);
    
    // 根据警告类型采取优化措施
    warning.warnings.forEach(w => {
      switch (w.metric) {
        case 'memoryUsage':
          // 内存使用过高，尝试清理资源
          this.resourceManager.cleanup();
          break;
        case 'firstContentfulPaint':
        case 'largestContentfulPaint':
          // 加载时间过长，优化资源加载
          this.optimizeResourceLoading(warning.appName);
          break;
        case 'cpuUsage':
          // CPU使用率过高，降低更新频率
          this.reduceUpdateFrequency(warning.appName);
          break;
      }
    });
  }
  
  /**
   * 优化资源加载
   */
  optimizeResourceLoading(appName) {
    console.log(`优化 ${appName} 的资源加载`);
    
    // 实现资源加载优化逻辑
    // 1. 启用代码分割
    // 2. 压缩资源
    // 3. 优化缓存策略
  }
  
  /**
   * 降低更新频率
   */
  reduceUpdateFrequency(appName) {
    console.log(`降低 ${appName} 的更新频率`);
    
    // 实现降低更新频率的逻辑
  }
  
  /**
   * 获取性能报告
   */
  async getPerformanceReport(appName, startTime, endTime) {
    return await this.performanceMonitor.getReport(appName, startTime, endTime);
  }
  
  /**
   * 获取优化建议
   */
  async getOptimizationSuggestions(appName) {
    const metrics = await this.performanceMonitor.getLatestMetrics(appName);
    
    if (!metrics) {
      return [];
    }
    
    const suggestions = [];
    
    // 根据性能指标生成优化建议
    if (metrics.firstContentfulPaint > this.config.monitoring.thresholds.firstContentfulPaint) {
      suggestions.push({
        type: 'loading',
        priority: 'high',
        description: '首屏渲染时间过长，建议启用代码分割和资源压缩',
        actions: [
          '启用代码分割，按需加载模块',
          '压缩CSS和JavaScript资源',
          '优化图片资源，使用WebP格式',
          '启用CDN加速'
        ]
      });
    }
    
    if (metrics.memoryUsage > this.config.monitoring.thresholds.memoryUsage) {
      suggestions.push({
        type: 'memory',
        priority: 'medium',
        description: '内存使用过高，建议优化内存管理',
        actions: [
          '及时清理不需要的对象和事件监听器',
          '使用对象池减少对象创建和销毁',
          '优化数据结构，减少内存占用',
          '启用虚拟滚动，减少DOM节点数量'
        ]
      });
    }
    
    if (metrics.cumulativeLayoutShift > this.config.monitoring.thresholds.cumulativeLayoutShift) {
      suggestions.push({
        type: 'layout',
        priority: 'medium',
        description: '布局稳定性较差，建议优化布局',
        actions: [
          '为图片和视频设置明确的尺寸',
          '为动态内容预留空间',
          '避免插入内容到现有内容上方',
          '使用transform动画代替改变布局的动画'
        ]
      });
    }
    
    return suggestions;
  }
}

/**
 * 性能监控器
 */
class PerformanceMonitor extends EventEmitter {
  constructor(config) {
    super();
    this.config = config;
    this.isRunning = false;
    this.intervalId = null;
    this.metricsHistory = [];
  }
  
  /**
   * 启动性能监控
   */
  start() {
    if (this.isRunning) {
      return;
    }
    
    console.log('启动性能监控...');
    
    this.isRunning = true;
    
    // 立即收集一次性能指标
    this.collectMetrics();
    
    // 设置定时收集
    this.intervalId = setInterval(() => {
      this.collectMetrics();
    }, this.config.collectInterval);
  }
  
  /**
   * 停止性能监控
   */
  stop() {
    if (!this.isRunning) {
      return;
    }
    
    console.log('停止性能监控...');
    
    this.isRunning = false;
    
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
  
  /**
   * 收集性能指标
   */
  collectMetrics() {
    // 获取当前活跃的应用
    const activeApps = this.getActiveApps();
    
    // 为每个应用收集性能指标
    activeApps.forEach(appName => {
      const metrics = this.collectAppMetrics(appName);
      
      // 保存到历史记录
      this.metricsHistory.push({
        appName,
        ...metrics,
        timestamp: new Date().toISOString()
      });
      
      // 清理过期数据
      this.cleanupOldData();
      
      // 发送指标收集事件
      this.emit('metricsCollected', {
        appName,
        ...metrics,
        timestamp: new Date().toISOString()
      });
    });
  }
  
  /**
   * 收集单个应用的性能指标
   */
  collectAppMetrics(appName) {
    // 获取Web Vitals指标
    const vitals = this.getWebVitals();
    
    // 获取资源使用情况
    const resourceUsage = this.getResourceUsage();
    
    // 获取自定义指标
    const customMetrics = this.getCustomMetrics(appName);
    
    return {
      ...vitals,
      ...resourceUsage,
      ...customMetrics
    };
  }
  
  /**
   * 获取Web Vitals指标
   */
  getWebVitals() {
    // 模拟获取Web Vitals指标
    // 实际实现中，应该使用web-vitals库或其他性能监控工具
    
    return {
      firstContentfulPaint: Math.random() * 2000 + 500, // 500-2500ms
      largestContentfulPaint: Math.random() * 3000 + 1000, // 1000-4000ms
      firstInputDelay: Math.random() * 150 + 20, // 20-170ms
      cumulativeLayoutShift: Math.random() * 0.2, // 0-0.2
      timeToInteractive: Math.random() * 3000 + 1500 // 1500-4500ms
    };
  }
  
  /**
   * 获取资源使用情况
   */
  getResourceUsage() {
    // 模拟获取资源使用情况
    // 实际实现中，应该使用Performance API或其他工具
    
    return {
      memoryUsage: Math.random() * 150 + 50, // 50-200MB
      cpuUsage: Math.random() * 80 + 10, // 10-90%
      networkUsage: Math.random() * 1000 + 100 // 100-1100KB/s
    };
  }
  
  /**
   * 获取自定义指标
   */
  getCustomMetrics(appName) {
    // 模拟获取自定义指标
    // 实际实现中，应该根据应用特点收集特定指标
    
    return {
      appName,
      renderTime: Math.random() * 500 + 100, // 100-600ms
      apiResponseTime: Math.random() * 1000 + 200, // 200-1200ms
      errorRate: Math.random() * 5, // 0-5%
      userSatisfaction: Math.random() * 2 + 3 // 3-5分
    };
  }
  
  /**
   * 获取当前活跃的应用
   */
  getActiveApps() {
    // 模拟获取当前活跃的应用
    // 实际实现中，应该根据实际运行的应用列表
    
    return ['main-app', 'dashboard', 'user-profile'];
  }
  
  /**
   * 清理过期数据
   */
  cleanupOldData() {
    const now = new Date();
    const retentionTime = this.config.retentionDays * 24 * 60 * 60 * 1000; // 转换为毫秒
    
    // 找出需要保留的数据
    const validData = this.metricsHistory.filter(data => {
      const dataTime = new Date(data.timestamp);
      return now - dataTime <= retentionTime;
    });
    
    // 更新数据
    this.metricsHistory = validData;
  }
  
  /**
   * 获取最新指标
   */
  getLatestMetrics(appName) {
    const appMetrics = this.metricsHistory
      .filter(data => data.appName === appName)
      .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    
    return appMetrics.length > 0 ? appMetrics[0] : null;
  }
  
  /**
   * 获取性能报告
   */
  async getReport(appName, startTime, endTime) {
    // 筛选指定应用和时间范围的数据
    const reportData = this.metricsHistory.filter(data => {
      const dataTime = new Date(data.timestamp);
      const start = new Date(startTime);
      const end = new Date(endTime);
      
      return data.appName === appName && dataTime >= start && dataTime <= end;
    });
    
    if (reportData.length === 0) {
      return {
        appName,
        startTime,
        endTime,
        message: '无数据'
      };
    }
    
    // 计算统计数据
    const metrics = {};
    const metricKeys = Object.keys(reportData[0]).filter(key => 
      key !== 'appName' && key !== 'timestamp' && typeof reportData[0][key] === 'number'
    );
    
    metricKeys.forEach(key => {
      const values = reportData.map(data => data[key]);
      metrics[key] = {
        min: Math.min(...values),
        max: Math.max(...values),
        avg: values.reduce((sum, value) => sum + value, 0) / values.length,
        latest: values[values.length - 1]
      };
    });
    
    return {
      appName,
      startTime,
      endTime,
      dataPoints: reportData.length,
      metrics
    };
  }
}

/**
 * 资源管理器
 */
class ResourceManager {
  constructor(microApps) {
    this.microApps = microApps;
    this.loadedApps = new Map();
    this.appInstances = new Map();
  }
  
  /**
   * 初始化资源管理器
   */
  init() {
    console.log('初始化资源管理器...');
    
    // 注册全局错误处理
    window.addEventListener('error', this.handleGlobalError.bind(this));
    
    // 注册未处理的Promise拒绝
    window.addEventListener('unhandledrejection', this.handleUnhandledRejection.bind(this));
  }
  
  /**
   * 加载应用
   */
  async loadApp(app) {
    if (this.loadedApps.has(app.name)) {
      return this.loadedApps.get(app.name);
    }
    
    console.log(`加载应用资源: ${app.name}`);
    
    try {
      // 1. 加载应用入口文件
      const entryScript = await this.loadScript(app.url + '/' + app.entry);
      
      // 2. 获取应用生命周期钩子
      const appLifecycle = window[app.name] || entryScript;
      
      // 3. 创建应用实例
      const appInstance = await appLifecycle.bootstrap();
      
      // 4. 保存应用实例
      this.appInstances.set(app.name, appInstance);
      this.loadedApps.set(app.name, appLifecycle);
      
      console.log(`应用 ${app.name} 加载完成`);
      
      return appLifecycle;
    } catch (error) {
      console.error(`加载应用 ${app.name} 失败:`, error);
      throw error;
    }
  }
  
  /**
   * 卸载应用
   */
  async unloadApp(appName) {
    if (!this.loadedApps.has(appName)) {
      return;
    }
    
    console.log(`卸载应用: ${appName}`);
    
    try {
      // 1. 获取应用实例
      const appInstance = this.appInstances.get(appName);
      
      // 2. 调用应用卸载钩子
      if (appInstance && typeof appInstance.unmount === 'function') {
        await appInstance.unmount();
      }
      
      // 3. 清理资源
      this.cleanupAppResources(appName);
      
      // 4. 移除应用记录
      this.appInstances.delete(appName);
      this.loadedApps.delete(appName);
      
      console.log(`应用 ${appName} 卸载完成`);
    } catch (error) {
      console.error(`卸载应用 ${appName} 失败:`, error);
      throw error;
    }
  }
  
  /**
   * 加载脚本
   */
  async loadScript(url) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.async = true;
      
      script.onload = () => {
        document.head.removeChild(script);
        resolve();
      };
      
      script.onerror = () => {
        document.head.removeChild(script);
        reject(new Error(`加载脚本失败: ${url}`));
      };
      
      document.head.appendChild(script);
    });
  }
  
  /**
   * 清理应用资源
   */
  cleanupAppResources(appName) {
    // 清理DOM元素
    const appElements = document.querySelectorAll(`[data-app="${appName}"]`);
    appElements.forEach(element => {
      element.remove();
    });
    
    // 清理事件监听器
    // 注意：这里需要根据实际的事件管理机制来实现
    
    // 清理定时器
    // 注意：这里需要根据实际的定时器管理机制来实现
    
    console.log(`应用 ${appName} 资源清理完成`);
  }
  
  /**
   * 清理所有资源
   */
  cleanup() {
    console.log('清理所有应用资源...');
    
    // 卸载所有应用
    for (const appName of this.loadedApps.keys()) {
      this.unloadApp(appName);
    }
    
    // 强制垃圾回收（如果支持）
    if (window.gc) {
      window.gc();
    }
  }
  
  /**
   * 处理全局错误
   */
  handleGlobalError(event) {
    console.error('全局错误:', event.error);
    
    // 可以在这里实现错误上报逻辑
  }
  
  /**
   * 处理未处理的Promise拒绝
   */
  handleUnhandledRejection(event) {
    console.error('未处理的Promise拒绝:', event.reason);
    
    // 可以在这里实现错误上报逻辑
  }
}

/**
 * 缓存管理器
 */
class CacheManager {
  constructor(config) {
    this.config = config;
    this.cache = new Map();
    this.cacheStats = {
      hits: 0,
      misses: 0,
      size: 0
    };
  }
  
  /**
   * 获取缓存项
   */
  async get(key) {
    if (!this.config.enabled) {
      return null;
    }
    
    const item = this.cache.get(key);
    
    if (!item) {
      this.cacheStats.misses++;
      return null;
    }
    
    // 检查是否过期
    if (this.isExpired(item)) {
      this.cache.delete(key);
      this.cacheStats.misses++;
      return null;
    }
    
    // 更新访问时间
    item.lastAccessed = Date.now();
    this.cacheStats.hits++;
    
    console.log(`缓存命中: ${key}`);
    return item.data;
  }
  
  /**
   * 设置缓存项
   */
  async set(key, data) {
    if (!this.config.enabled) {
      return;
    }
    
    // 检查缓存大小限制
    if (this.cache.size >= this.config.maxSize) {
      this.evictLRU();
    }
    
    // 创建缓存项
    const item = {
      data,
      createdAt: Date.now(),
      lastAccessed: Date.now(),
      size: this.calculateSize(data)
    };
    
    // 添加到缓存
    this.cache.set(key, item);
    this.cacheStats.size += item.size;
    
    console.log(`缓存设置: ${key}`);
  }
  
  /**
   * 删除缓存项
   */
  async remove(key) {
    const item = this.cache.get(key);
    
    if (item) {
      this.cache.delete(key);
      this.cacheStats.size -= item.size;
      console.log(`缓存删除: ${key}`);
    }
  }
  
  /**
   * 清空缓存
   */
  async clear() {
    this.cache.clear();
    this.cacheStats.size = 0;
    console.log('缓存已清空');
  }
  
  /**
   * 检查缓存项是否过期
   */
  isExpired(item) {
    if (!this.config.maxAge) {
      return false;
    }
    
    return Date.now() - item.createdAt > this.config.maxAge;
  }
  
  /**
   * 计算数据大小
   */
  calculateSize(data) {
    // 简单估算，实际实现中应该使用更精确的方法
    return JSON.stringify(data).length;
  }
  
  /**
   * 淘汰最近最少使用的缓存项
   */
  evictLRU() {
    let oldestKey = null;
    let oldestTime = Date.now();
    
    for (const [key, item] of this.cache) {
      if (item.lastAccessed < oldestTime) {
        oldestTime = item.lastAccessed;
        oldestKey = key;
      }
    }
    
    if (oldestKey) {
      const item = this.cache.get(oldestKey);
      this.cache.delete(oldestKey);
      this.cacheStats.size -= item.size;
      console.log(`LRU淘汰: ${oldestKey}`);
    }
  }
  
  /**
   * 获取缓存统计
   */
  getStats() {
    const hitRate = this.cacheStats.hits + this.cacheStats.misses > 0
      ? (this.cacheStats.hits / (this.cacheStats.hits + this.cacheStats.misses) * 100).toFixed(2)
      : 0;
    
    return {
      ...this.cacheStats,
      hitRate: `${hitRate}%`,
      itemCount: this.cache.size
    };
  }
}

/**
 * 预加载管理器
 */
class PreloadManager {
  constructor(config) {
    this.config = config;
    this.preloadedApps = new Set();
    this.preloadQueue = [];
    this.isProcessing = false;
  }
  
  /**
   * 预加载应用
   */
  preloadApp(app) {
    if (!this.config.enabled || this.preloadedApps.has(app.name)) {
      return;
    }
    
    console.log(`预加载应用: ${app.name}`);
    
    // 添加到预加载队列
    this.preloadQueue.push({
      app,
      priority: this.config.priority,
      timestamp: Date.now()
    });
    
    // 处理预加载队列
    this.processQueue();
  }
  
  /**
   * 处理预加载队列
   */
  async processQueue() {
    if (this.isProcessing || this.preloadQueue.length === 0) {
      return;
    }
    
    this.isProcessing = true;
    
    // 按优先级和时间排序
    this.preloadQueue.sort((a, b) => {
      if (a.priority !== b.priority) {
        const priorityOrder = { high: 3, medium: 2, low: 1 };
        return priorityOrder[b.priority] - priorityOrder[a.priority];
      }
      return a.timestamp - b.timestamp;
    });
    
    // 处理队列中的第一个应用
    const { app } = this.preloadQueue.shift();
    
    try {
      // 预加载应用资源
      await this.preloadAppResources(app);
      
      // 标记为已预加载
      this.preloadedApps.add(app.name);
      
      console.log(`应用 ${app.name} 预加载完成`);
    } catch (error) {
      console.error(`应用 ${app.name} 预加载失败:`, error);
    }
    
    this.isProcessing = false;
    
    // 继续处理队列
    if (this.preloadQueue.length > 0) {
      this.processQueue();
    }
  }
  
  /**
   * 预加载应用资源
   */
  async preloadAppResources(app) {
    // 预加载入口脚本
    await this.preloadScript(app.url + '/' + app.entry);
    
    // 预加载其他资源（CSS、图片等）
    // 这里可以根据应用配置预加载其他资源
  }
  
  /**
   * 预加载脚本
   */
  async preloadScript(url) {
    return new Promise((resolve, reject) => {
      const link = document.createElement('link');
      link.rel = 'preload';
      link.as = 'script';
      link.href = url;
      
      link.onload = () => {
        resolve();
      };
      
      link.onerror = () => {
        reject(new Error(`预加载脚本失败: ${url}`));
      };
      
      document.head.appendChild(link);
    });
  }
  
  /**
   * 检查应用是否已预加载
   */
  isPreloaded(appName) {
    return this.preloadedApps.has(appName);
  }
  
  /**
   * 取消预加载
   */
  cancelPreload(appName) {
    // 从队列中移除
    this.preloadQueue = this.preloadQueue.filter(item => item.app.name !== appName);
    
    // 从已预加载集合中移除
    this.preloadedApps.delete(appName);
    
    console.log(`取消预加载应用: ${appName}`);
  }
}

// 使用示例
const performanceOptimizer = new MicroFrontendPerformanceOptimizer();

// 启动性能优化系统
performanceOptimizer.start();

// 加载微应用
performanceOptimizer.loadMicroApp('dashboard')
  .then(app => {
    console.log('微应用加载成功:', app);
  })
  .catch(error => {
    console.error('微应用加载失败:', error);
  });

// 获取性能报告
const endTime = new Date();
const startTime = new Date(endTime.getTime() - 24 * 60 * 60 * 1000); // 24小时前

performanceOptimizer.getPerformanceReport('dashboard', startTime.toISOString(), endTime.toISOString())
  .then(report => {
    console.log('性能报告:', report);
  });

// 获取优化建议
performanceOptimizer.getOptimizationSuggestions('dashboard')
  .then(suggestions => {
    console.log('优化建议:', suggestions);
  });

// 停止性能优化系统
// performanceOptimizer.stop();
```

## 12.6 微前端运维最佳实践

### 12.6.1 部署最佳实践

1. **自动化部署流程**
   - 建立完整的CI/CD流水线，实现从代码提交到生产部署的全自动化
   - 使用容器化技术（如Docker）确保环境一致性
   - 实施基础设施即代码（IaC）管理部署环境

2. **渐进式发布策略**
   - 优先采用蓝绿部署或金丝雀发布，降低发布风险
   - 设置合理的流量切换策略，逐步验证新版本稳定性
   - 建立快速回滚机制，确保问题出现时能迅速恢复

3. **版本兼容性管理**
   - 建立清晰的版本号规范和依赖关系管理
   - 实施接口契约测试，确保微应用间的兼容性
   - 定期进行依赖更新和安全补丁应用

### 12.6.2 监控与告警最佳实践

1. **全方位监控体系**
   - 建立多层次监控：基础设施、应用性能、业务指标
   - 实现端到端监控，覆盖用户请求的完整链路
   - 采用分布式追踪技术，快速定位跨应用问题

2. **智能告警策略**
   - 设置合理的告警阈值，避免告警风暴
   - 实施告警分级和聚合，提高告警有效性
   - 建立告警响应流程和值班制度

3. **性能基线与趋势分析**
   - 建立性能基线，及时发现性能异常
   - 定期进行性能趋势分析，预测潜在问题
   - 实施容量规划，确保系统可扩展性

### 12.6.3 日志管理最佳实践

1. **标准化日志格式**
   - 统一日志格式，包含关键上下文信息
   - 实施结构化日志，便于自动化分析
   - 确保日志中不包含敏感信息

2. **集中式日志管理**
   - 建立集中式日志收集和存储系统
   - 实施日志分级和分类存储策略
   - 提供高效的日志检索和分析工具

3. **日志分析与洞察**
   - 利用机器学习技术进行异常检测
   - 建立日志分析仪表板，可视化关键指标
   - 定期进行日志审计，发现潜在问题

## 12.7 总结

微前端部署与运维是确保微前端架构稳定运行的关键环节。本章详细介绍了微前端的部署架构、运维管理、日志管理、性能优化以及最佳实践。

通过本章的学习，我们了解到：

1. 微前端部署需要考虑独立部署、版本管理、资源隔离等特殊需求
2. 灵活的部署策略（如蓝绿部署、金丝雀发布）可以降低发布风险
3. 全方位的监控与告警系统是保障微前端稳定运行的基础
4. 标准化的日志管理对于问题排查和系统优化至关重要
5. 性能优化是提升用户体验的关键，需要持续监控和改进

在实际应用中，需要根据业务需求和技术特点，选择合适的部署策略和运维方案，并不断优化和改进，以确保微前端系统的高可用性和高性能。