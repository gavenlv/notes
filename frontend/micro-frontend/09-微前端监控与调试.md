# 第九章：微前端监控与调试

## 9.1 微前端监控概述

### 9.1.1 监控的重要性

微前端架构的复杂性使得监控和调试变得尤为重要。良好的监控系统可以帮助我们：

1. **快速定位问题**：及时发现和定位微应用中的错误和性能瓶颈
2. **优化用户体验**：通过监控关键指标，持续优化应用性能
3. **预防潜在风险**：提前发现可能导致系统崩溃的问题
4. **数据驱动决策**：基于监控数据做出技术决策和优化方向
5. **团队协作支持**：为不同团队提供统一的监控视图和问题定位工具

### 9.1.2 微前端监控挑战

微前端架构带来了独特的监控挑战：

1. **多应用环境**：需要同时监控多个独立部署的微应用
2. **跨应用追踪**：用户操作可能跨越多个微应用，需要全链路追踪
3. **资源隔离**：微应用的资源隔离使得监控更加复杂
4. **版本管理**：不同微应用可能处于不同版本，需要版本感知的监控
5. **沙箱环境**：沙箱隔离可能影响监控数据的收集和上报

### 9.1.3 监控指标体系

微前端监控应包含以下关键指标：

1. **性能指标**：
   - 首屏加载时间(FCP)
   - 最大内容绘制时间(LCP)
   - 首次输入延迟(FID)
   - 累积布局偏移(CLS)
   - 应用加载时间
   - 路由切换时间

2. **错误指标**：
   - JavaScript错误率
   - 资源加载失败率
   - API请求失败率
   - 沙箱异常率

3. **用户行为指标**：
   - 页面访问量
   - 用户停留时间
   - 功能使用频率
   - 跨应用跳转路径

4. **资源指标**：
   - 内存使用量
   - CPU使用率
   - 网络请求数量
   - 资源加载大小

## 9.2 微前端监控系统设计

### 9.2.1 监控系统架构

```javascript
// 微前端监控系统架构
class MicroFrontendMonitoringSystem {
  constructor(config) {
    this.config = {
      endpoint: config.endpoint || '/api/monitoring',
      appId: config.appId || 'unknown',
      userId: config.userId || 'anonymous',
      environment: config.environment || 'production',
      enablePerformanceMonitoring: config.enablePerformanceMonitoring !== false,
      enableErrorMonitoring: config.enableErrorMonitoring !== false,
      enableUserBehaviorTracking: config.enableUserBehaviorTracking !== false,
      batchSize: config.batchSize || 10,
      flushInterval: config.flushInterval || 5000,
      ...config
    };
    
    this.dataQueue = [];
    this.sessionId = this.generateSessionId();
    this.startTime = Date.now();
    
    // 初始化监控模块
    this.performanceMonitor = new PerformanceMonitor(this.config);
    this.errorMonitor = new ErrorMonitor(this.config);
    this.userBehaviorTracker = new UserBehaviorTracker(this.config);
    this.resourceMonitor = new ResourceMonitor(this.config);
    
    // 初始化数据上报
    this.initDataReporting();
    
    // 初始化监控
    this.initMonitoring();
  }
  
  // 生成会话ID
  generateSessionId() {
    return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }
  
  // 初始化数据上报
  initDataReporting() {
    // 定期上报数据
    this.flushTimer = setInterval(() => {
      this.flushData();
    }, this.config.flushInterval);
    
    // 页面卸载前上报剩余数据
    window.addEventListener('beforeunload', () => {
      this.flushData(true);
    });
    
    // 页面隐藏时上报数据
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        this.flushData();
      }
    });
  }
  
  // 初始化监控
  initMonitoring() {
    // 性能监控
    if (this.config.enablePerformanceMonitoring) {
      this.performanceMonitor.init();
    }
    
    // 错误监控
    if (this.config.enableErrorMonitoring) {
      this.errorMonitor.init();
    }
    
    // 用户行为追踪
    if (this.config.enableUserBehaviorTracking) {
      this.userBehaviorTracker.init();
    }
    
    // 资源监控
    this.resourceMonitor.init();
  }
  
  // 添加监控数据
  addData(data) {
    // 添加公共字段
    const enrichedData = {
      ...data,
      timestamp: Date.now(),
      sessionId: this.sessionId,
      appId: this.config.appId,
      userId: this.config.userId,
      environment: this.config.environment,
      pageUrl: window.location.href,
      userAgent: navigator.userAgent
    };
    
    this.dataQueue.push(enrichedData);
    
    // 如果达到批量大小，立即上报
    if (this.dataQueue.length >= this.config.batchSize) {
      this.flushData();
    }
  }
  
  // 上报数据
  flushData(isSync = false) {
    if (this.dataQueue.length === 0) {
      return;
    }
    
    const data = [...this.dataQueue];
    this.dataQueue = [];
    
    const reportData = {
      data,
      meta: {
        sessionId: this.sessionId,
        appId: this.config.appId,
        userId: this.config.userId,
        environment: this.config.environment,
        sessionDuration: Date.now() - this.startTime
      }
    };
    
    if (isSync) {
      // 同步上报，使用sendBeacon
      if (navigator.sendBeacon) {
        navigator.sendBeacon(this.config.endpoint, JSON.stringify(reportData));
      } else {
        // 降级处理
        const xhr = new XMLHttpRequest();
        xhr.open('POST', this.config.endpoint, false);
        xhr.setRequestHeader('Content-Type', 'application/json');
        xhr.send(JSON.stringify(reportData));
      }
    } else {
      // 异步上报
      fetch(this.config.endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(reportData),
        keepalive: true
      }).catch(error => {
        console.error('Failed to send monitoring data:', error);
        // 上报失败，将数据重新加入队列
        this.dataQueue.unshift(...data);
      });
    }
  }
  
  // 获取当前会话信息
  getSessionInfo() {
    return {
      sessionId: this.sessionId,
      appId: this.config.appId,
      userId: this.config.userId,
      environment: this.config.environment,
      startTime: this.startTime,
      duration: Date.now() - this.startTime,
      dataCount: this.dataQueue.length
    };
  }
  
  // 销毁监控系统
  destroy() {
    // 清除定时器
    if (this.flushTimer) {
      clearInterval(this.flushTimer);
    }
    
    // 上报剩余数据
    this.flushData(true);
    
    // 销毁各监控模块
    if (this.performanceMonitor) {
      this.performanceMonitor.destroy();
    }
    
    if (this.errorMonitor) {
      this.errorMonitor.destroy();
    }
    
    if (this.userBehaviorTracker) {
      this.userBehaviorTracker.destroy();
    }
    
    if (this.resourceMonitor) {
      this.resourceMonitor.destroy();
    }
  }
}

// 性能监控模块
class PerformanceMonitor {
  constructor(config) {
    this.config = config;
    this.monitoringSystem = null;
    this.observers = [];
  }
  
  // 设置监控系统引用
  setMonitoringSystem(system) {
    this.monitoringSystem = system;
  }
  
  // 初始化性能监控
  init() {
    // 监控页面加载性能
    this.observePageLoad();
    
    // 监控路由变化性能
    this.observeRouteChanges();
    
    // 监控Web Vitals
    this.observeWebVitals();
    
    // 监控微应用生命周期
    this.observeMicroAppLifecycle();
  }
  
  // 监控页面加载性能
  observePageLoad() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.entryType === 'navigation') {
            this.reportNavigationMetrics(entry);
          }
        }
      });
      
      observer.observe({ entryTypes: ['navigation'] });
      this.observers.push(observer);
    } else {
      // 降级处理
      this.reportNavigationMetricsFallback();
    }
  }
  
  // 报告导航指标
  reportNavigationMetrics(entry) {
    const metrics = {
      type: 'navigation',
      dns: entry.domainLookupEnd - entry.domainLookupStart,
      tcp: entry.connectEnd - entry.connectStart,
      ssl: entry.secureConnectionStart > 0 ? entry.connectEnd - entry.secureConnectionStart : 0,
      ttfb: entry.responseStart - entry.requestStart,
      response: entry.responseEnd - entry.responseStart,
      domParse: entry.domContentLoadedEventStart - entry.responseEnd,
      domReady: entry.domContentLoadedEventEnd - entry.domContentLoadedEventStart,
      loadComplete: entry.loadEventEnd - entry.loadEventStart,
      total: entry.loadEventEnd - entry.navigationStart
    };
    
    this.report('performance', metrics);
  }
  
  // 降级处理导航指标
  reportNavigationMetricsFallback() {
    const timing = performance.timing;
    const metrics = {
      type: 'navigation',
      dns: timing.domainLookupEnd - timing.domainLookupStart,
      tcp: timing.connectEnd - timing.connectStart,
      ssl: timing.secureConnectionStart > 0 ? timing.connectEnd - timing.secureConnectionStart : 0,
      ttfb: timing.responseStart - timing.requestStart,
      response: timing.responseEnd - timing.responseStart,
      domParse: timing.domContentLoadedEventStart - timing.responseEnd,
      domReady: timing.domContentLoadedEventEnd - timing.domContentLoadedEventStart,
      loadComplete: timing.loadEventEnd - timing.loadEventStart,
      total: timing.loadEventEnd - timing.navigationStart
    };
    
    this.report('performance', metrics);
  }
  
  // 监控路由变化性能
  observeRouteChanges() {
    // 监听hash变化
    window.addEventListener('hashchange', () => {
      const startTime = performance.now();
      
      // 延迟测量，确保路由切换完成
      setTimeout(() => {
        const endTime = performance.now();
        const metrics = {
          type: 'routeChange',
          method: 'hash',
          url: window.location.href,
          path: window.location.pathname,
          duration: endTime - startTime
        };
        
        this.report('performance', metrics);
      }, 100);
    });
    
    // 监听history API
    const originalPushState = history.pushState;
    const originalReplaceState = history.replaceState;
    
    history.pushState = function(...args) {
      const startTime = performance.now();
      const result = originalPushState.apply(this, args);
      
      setTimeout(() => {
        const endTime = performance.now();
        const metrics = {
          type: 'routeChange',
          method: 'pushState',
          url: window.location.href,
          path: window.location.pathname,
          duration: endTime - startTime
        };
        
        this.report('performance', metrics);
      }, 100);
      
      return result;
    };
    
    history.replaceState = function(...args) {
      const startTime = performance.now();
      const result = originalReplaceState.apply(this, args);
      
      setTimeout(() => {
        const endTime = performance.now();
        const metrics = {
          type: 'routeChange',
          method: 'replaceState',
          url: window.location.href,
          path: window.location.pathname,
          duration: endTime - startTime
        };
        
        this.report('performance', metrics);
      }, 100);
      
      return result;
    };
  }
  
  // 监控Web Vitals
  observeWebVitals() {
    // 监控FCP
    this.observeFCP();
    
    // 监控LCP
    this.observeLCP();
    
    // 监控FID
    this.observeFID();
    
    // 监控CLS
    this.observeCLS();
  }
  
  // 监控FCP
  observeFCP() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.name === 'first-contentful-paint') {
            this.report('performance', {
              type: 'fcp',
              value: entry.startTime
            });
            
            observer.disconnect();
            break;
          }
        }
      });
      
      observer.observe({ entryTypes: ['paint'] });
      this.observers.push(observer);
    }
  }
  
  // 监控LCP
  observeLCP() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        const lastEntry = entries[entries.length - 1];
        
        this.report('performance', {
          type: 'lcp',
          value: lastEntry.startTime,
          element: lastEntry.element ? lastEntry.element.tagName : '',
          url: lastEntry.url || ''
        });
      });
      
      observer.observe({ entryTypes: ['largest-contentful-paint'] });
      this.observers.push(observer);
    }
  }
  
  // 监控FID
  observeFID() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.entryType === 'first-input') {
            this.report('performance', {
              type: 'fid',
              value: entry.processingStart - entry.startTime,
              eventType: entry.name
            });
            
            observer.disconnect();
            break;
          }
        }
      });
      
      observer.observe({ entryTypes: ['first-input'] });
      this.observers.push(observer);
    }
  }
  
  // 监控CLS
  observeCLS() {
    if ('PerformanceObserver' in window) {
      let clsValue = 0;
      
      const observer = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (!entry.hadRecentInput) {
            clsValue += entry.value;
            this.report('performance', {
              type: 'cls',
              value: clsValue
            });
          }
        }
      });
      
      observer.observe({ entryTypes: ['layout-shift'] });
      this.observers.push(observer);
    }
  }
  
  // 监控微应用生命周期
  observeMicroAppLifecycle() {
    // 监听应用加载
    window.addEventListener('micro-app-loaded', (event) => {
      this.report('performance', {
        type: 'appLoad',
        appName: event.detail.name,
        loadTime: event.detail.loadTime
      });
    });
    
    // 监听应用挂载
    window.addEventListener('micro-app-mounted', (event) => {
      this.report('performance', {
        type: 'appMount',
        appName: event.detail.name,
        mountTime: event.detail.mountTime
      });
    });
    
    // 监听应用卸载
    window.addEventListener('micro-app-unmounted', (event) => {
      this.report('performance', {
        type: 'appUnmount',
        appName: event.detail.name,
        unmountTime: event.detail.unmountTime
      });
    });
  }
  
  // 报告数据
  report(category, data) {
    if (this.monitoringSystem) {
      this.monitoringSystem.addData({
        category,
        data
      });
    }
  }
  
  // 销毁性能监控
  destroy() {
    this.observers.forEach(observer => {
      observer.disconnect();
    });
    this.observers = [];
  }
}

// 错误监控模块
class ErrorMonitor {
  constructor(config) {
    this.config = config;
    this.monitoringSystem = null;
  }
  
  // 设置监控系统引用
  setMonitoringSystem(system) {
    this.monitoringSystem = system;
  }
  
  // 初始化错误监控
  init() {
    // 监控JavaScript错误
    this.observeJavaScriptErrors();
    
    // 监控资源加载错误
    this.observeResourceErrors();
    
    // 监控Promise错误
    this.observePromiseRejections();
    
    // 监控微应用错误
    this.observeMicroAppErrors();
  }
  
  // 监控JavaScript错误
  observeJavaScriptErrors() {
    window.addEventListener('error', (event) => {
      this.report('error', {
        type: 'javascript',
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error ? event.error.stack : '',
        timestamp: Date.now()
      });
    });
  }
  
  // 监控资源加载错误
  observeResourceErrors() {
    window.addEventListener('error', (event) => {
      if (event.target !== window) {
        const element = event.target;
        this.report('error', {
          type: 'resource',
          elementType: element.tagName.toLowerCase(),
          source: element.src || element.href,
          timestamp: Date.now()
        });
      }
    }, true);
  }
  
  // 监控Promise错误
  observePromiseRejections() {
    window.addEventListener('unhandledrejection', (event) => {
      this.report('error', {
        type: 'promise',
        reason: event.reason ? (event.reason.stack || event.reason.toString()) : '',
        timestamp: Date.now()
      });
    });
  }
  
  // 监控微应用错误
  observeMicroAppErrors() {
    window.addEventListener('micro-app-error', (event) => {
      this.report('error', {
        type: 'microApp',
        appName: event.detail.name,
        error: event.detail.error ? event.detail.error.toString() : '',
        stack: event.detail.error ? event.detail.error.stack : '',
        timestamp: Date.now()
      });
    });
  }
  
  // 报告数据
  report(category, data) {
    if (this.monitoringSystem) {
      this.monitoringSystem.addData({
        category,
        data
      });
    }
  }
  
  // 销毁错误监控
  destroy() {
    // 移除事件监听器
    // 实际实现中需要保存事件处理函数的引用，以便移除
  }
}

// 用户行为追踪模块
class UserBehaviorTracker {
  constructor(config) {
    this.config = config;
    this.monitoringSystem = null;
    this.clickHandlers = new Map();
    this.routeChanges = [];
  }
  
  // 设置监控系统引用
  setMonitoringSystem(system) {
    this.monitoringSystem = system;
  }
  
  // 初始化用户行为追踪
  init() {
    // 追踪页面访问
    this.trackPageView();
    
    // 追踪点击事件
    this.trackClicks();
    
    // 追踪路由变化
    this.trackRouteChanges();
    
    // 追踪表单提交
    this.trackFormSubmissions();
    
    // 追踪页面停留时间
    this.trackPageDwellTime();
  }
  
  // 追踪页面访问
  trackPageView() {
    const reportPageView = () => {
      this.report('userBehavior', {
        type: 'pageView',
        url: window.location.href,
        path: window.location.pathname,
        referrer: document.referrer,
        title: document.title,
        timestamp: Date.now()
      });
    };
    
    // 初始页面访问
    reportPageView();
    
    // 监听路由变化
    window.addEventListener('hashchange', reportPageView);
    window.addEventListener('popstate', reportPageView);
    
    // 监听history API
    const originalPushState = history.pushState;
    const originalReplaceState = history.replaceState;
    
    history.pushState = function(...args) {
      const result = originalPushState.apply(this, args);
      setTimeout(reportPageView, 0);
      return result;
    };
    
    history.replaceState = function(...args) {
      const result = originalReplaceState.apply(this, args);
      setTimeout(reportPageView, 0);
      return result;
    };
  }
  
  // 追踪点击事件
  trackClicks() {
    document.addEventListener('click', (event) => {
      const target = event.target;
      const elementInfo = this.getElementInfo(target);
      
      this.report('userBehavior', {
        type: 'click',
        ...elementInfo,
        timestamp: Date.now()
      });
    });
  }
  
  // 获取元素信息
  getElementInfo(element) {
    const info = {
      tagName: element.tagName.toLowerCase(),
      id: element.id || '',
      className: element.className || '',
      textContent: element.textContent ? element.textContent.substring(0, 50) : '',
      attributes: {}
    };
    
    // 添加重要属性
    const importantAttributes = ['data-track', 'data-action', 'data-category', 'href', 'value'];
    importantAttributes.forEach(attr => {
      if (element.hasAttribute(attr)) {
        info.attributes[attr] = element.getAttribute(attr);
      }
    });
    
    return info;
  }
  
  // 追踪路由变化
  trackRouteChanges() {
    const reportRouteChange = (method) => {
      const routeChange = {
        type: 'routeChange',
        method,
        from: this.routeChanges.length > 0 ? this.routeChanges[this.routeChanges.length - 1].to : '',
        to: window.location.pathname,
        url: window.location.href,
        timestamp: Date.now()
      };
      
      this.routeChanges.push(routeChange);
      this.report('userBehavior', routeChange);
    };
    
    // 监听hash变化
    window.addEventListener('hashchange', () => reportRouteChange('hash'));
    
    // 监听history API
    window.addEventListener('popstate', () => reportRouteChange('popstate'));
    
    const originalPushState = history.pushState;
    const originalReplaceState = history.replaceState;
    
    history.pushState = function(...args) {
      const result = originalPushState.apply(this, args);
      setTimeout(() => reportRouteChange('pushState'), 0);
      return result;
    };
    
    history.replaceState = function(...args) {
      const result = originalReplaceState.apply(this, args);
      setTimeout(() => reportRouteChange('replaceState'), 0);
      return result;
    };
  }
  
  // 追踪表单提交
  trackFormSubmissions() {
    document.addEventListener('submit', (event) => {
      const form = event.target;
      const formInfo = {
        type: 'formSubmit',
        formId: form.id || '',
        formClass: form.className || '',
        formAction: form.action || '',
        formMethod: form.method || 'get',
        timestamp: Date.now()
      };
      
      this.report('userBehavior', formInfo);
    });
  }
  
  // 追踪页面停留时间
  trackPageDwellTime() {
    let pageStartTime = Date.now();
    let lastActiveTime = Date.now();
    
    const reportDwellTime = () => {
      const dwellTime = Date.now() - pageStartTime;
      const activeTime = Date.now() - lastActiveTime;
      
      this.report('userBehavior', {
        type: 'pageDwellTime',
        url: window.location.href,
        path: window.location.pathname,
        dwellTime,
        activeTime,
        timestamp: Date.now()
      });
      
      // 重置计时器
      pageStartTime = Date.now();
      lastActiveTime = Date.now();
    };
    
    // 页面卸载时上报停留时间
    window.addEventListener('beforeunload', reportDwellTime);
    
    // 页面隐藏时上报停留时间
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        reportDwellTime();
      } else {
        // 页面重新可见，重置活动时间
        lastActiveTime = Date.now();
      }
    });
    
    // 监听用户活动
    const activityEvents = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'];
    activityEvents.forEach(eventType => {
      document.addEventListener(eventType, () => {
        lastActiveTime = Date.now();
      }, true);
    });
  }
  
  // 报告数据
  report(category, data) {
    if (this.monitoringSystem) {
      this.monitoringSystem.addData({
        category,
        data
      });
    }
  }
  
  // 销毁用户行为追踪
  destroy() {
    // 移除事件监听器
    // 实际实现中需要保存事件处理函数的引用，以便移除
  }
}

// 资源监控模块
class ResourceMonitor {
  constructor(config) {
    this.config = config;
    this.monitoringSystem = null;
    this.observers = [];
  }
  
  // 设置监控系统引用
  setMonitoringSystem(system) {
    this.monitoringSystem = system;
  }
  
  // 初始化资源监控
  init() {
    // 监控资源加载
    this.observeResourceLoading();
    
    // 监控内存使用
    this.observeMemoryUsage();
    
    // 监控长任务
    this.observeLongTasks();
  }
  
  // 监控资源加载
  observeResourceLoading() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.entryType === 'resource') {
            this.report('resource', {
              type: 'resourceLoad',
              name: entry.name,
              resourceType: this.getResourceType(entry.name),
              startTime: entry.startTime,
              duration: entry.duration,
              transferSize: entry.transferSize || 0,
              encodedBodySize: entry.encodedBodySize || 0,
              decodedBodySize: entry.decodedBodySize || 0,
              initiatorType: entry.initiatorType,
              nextHopProtocol: entry.nextHopProtocol,
              responseStatus: entry.responseStatus || 0
            });
          }
        }
      });
      
      observer.observe({ entryTypes: ['resource'] });
      this.observers.push(observer);
    }
  }
  
  // 获取资源类型
  getResourceType(url) {
    if (/\.js$/.test(url)) return 'script';
    if (/\.css$/.test(url)) return 'stylesheet';
    if (/\.(png|jpg|jpeg|gif|svg|webp)$/.test(url)) return 'image';
    if (/\.woff2?$/.test(url)) return 'font';
    return 'other';
  }
  
  // 监控内存使用
  observeMemoryUsage() {
    if ('memory' in performance) {
      const reportMemoryUsage = () => {
        this.report('resource', {
          type: 'memoryUsage',
          usedJSHeapSize: performance.memory.usedJSHeapSize,
          totalJSHeapSize: performance.memory.totalJSHeapSize,
          jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
        });
      };
      
      // 初始报告
      reportMemoryUsage();
      
      // 定期报告
      setInterval(reportMemoryUsage, 30000); // 每30秒报告一次
    }
  }
  
  // 监控长任务
  observeLongTasks() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.entryType === 'longtask') {
            this.report('resource', {
              type: 'longTask',
              startTime: entry.startTime,
              duration: entry.duration,
              attribution: entry.attribution || []
            });
          }
        }
      });
      
      observer.observe({ entryTypes: ['longtask'] });
      this.observers.push(observer);
    }
  }
  
  // 报告数据
  report(category, data) {
    if (this.monitoringSystem) {
      this.monitoringSystem.addData({
        category,
        data
      });
    }
  }
  
  // 销毁资源监控
  destroy() {
    this.observers.forEach(observer => {
      observer.disconnect();
    });
    this.observers = [];
  }
}

// 使用示例
const monitoringSystem = new MicroFrontendMonitoringSystem({
  endpoint: '/api/monitoring',
  appId: 'main-app',
  userId: 'user123',
  environment: 'production',
  enablePerformanceMonitoring: true,
  enableErrorMonitoring: true,
  enableUserBehaviorTracking: true,
  batchSize: 10,
  flushInterval: 5000
});

// 设置各监控模块的引用
monitoringSystem.performanceMonitor.setMonitoringSystem(monitoringSystem);
monitoringSystem.errorMonitor.setMonitoringSystem(monitoringSystem);
monitoringSystem.userBehaviorTracker.setMonitoringSystem(monitoringSystem);
monitoringSystem.resourceMonitor.setMonitoringSystem(monitoringSystem);
```

## 9.3 微前端调试工具

### 9.3.1 微前端调试面板

```javascript
// 微前端调试面板
class MicroFrontendDebugPanel {
  constructor() {
    this.isOpen = false;
    this.panel = null;
    this.apps = new Map();
    this.events = [];
    this.maxEvents = 100;
    
    this.init();
  }
  
  // 初始化调试面板
  init() {
    this.createPanel();
    this.bindEvents();
    this.setupKeyboardShortcut();
  }
  
  // 创建面板
  createPanel() {
    // 创建面板容器
    this.panel = document.createElement('div');
    this.panel.id = 'micro-frontend-debug-panel';
    this.panel.className = 'micro-frontend-debug-panel';
    this.panel.innerHTML = `
      <div class="debug-panel-header">
        <h3>微前端调试面板</h3>
        <button class="debug-panel-close">&times;</button>
      </div>
      <div class="debug-panel-tabs">
        <button class="tab-button active" data-tab="apps">应用</button>
        <button class="tab-button" data-tab="events">事件</button>
        <button class="tab-button" data-tab="performance">性能</button>
        <button class="tab-button" data-tab="console">控制台</button>
      </div>
      <div class="debug-panel-content">
        <div class="tab-content active" id="apps-tab">
          <div class="apps-list"></div>
          <div class="app-details"></div>
        </div>
        <div class="tab-content" id="events-tab">
          <div class="events-controls">
            <button class="clear-events">清空事件</button>
            <label>
              <input type="checkbox" id="auto-scroll" checked> 自动滚动
            </label>
          </div>
          <div class="events-list"></div>
        </div>
        <div class="tab-content" id="performance-tab">
          <div class="performance-metrics"></div>
        </div>
        <div class="tab-content" id="console-tab">
          <div class="console-controls">
            <button class="clear-console">清空控制台</button>
            <select class="log-level">
              <option value="all">全部</option>
              <option value="error">错误</option>
              <option value="warn">警告</option>
              <option value="info">信息</option>
              <option value="log">日志</option>
            </select>
          </div>
          <div class="console-output"></div>
        </div>
      </div>
    `;
    
    // 添加样式
    this.addStyles();
    
    // 默认隐藏
    this.panel.style.display = 'none';
    document.body.appendChild(this.panel);
  }
  
  // 添加样式
  addStyles() {
    const style = document.createElement('style');
    style.textContent = `
      .micro-frontend-debug-panel {
        position: fixed;
        top: 0;
        right: 0;
        width: 400px;
        height: 100vh;
        background: #fff;
        border-left: 1px solid #ddd;
        box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
        z-index: 10000;
        font-family: monospace;
        font-size: 12px;
        display: flex;
        flex-direction: column;
      }
      
      .debug-panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        background: #f5f5f5;
        border-bottom: 1px solid #ddd;
      }
      
      .debug-panel-header h3 {
        margin: 0;
        font-size: 14px;
      }
      
      .debug-panel-close {
        background: none;
        border: none;
        font-size: 18px;
        cursor: pointer;
      }
      
      .debug-panel-tabs {
        display: flex;
        background: #f0f0f0;
        border-bottom: 1px solid #ddd;
      }
      
      .tab-button {
        flex: 1;
        padding: 8px;
        background: none;
        border: none;
        cursor: pointer;
      }
      
      .tab-button.active {
        background: #fff;
        border-bottom: 2px solid #1890ff;
      }
      
      .debug-panel-content {
        flex: 1;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }
      
      .tab-content {
        display: none;
        flex: 1;
        overflow: auto;
        padding: 10px;
      }
      
      .tab-content.active {
        display: flex;
        flex-direction: column;
      }
      
      .apps-list {
        border-bottom: 1px solid #eee;
        margin-bottom: 10px;
      }
      
      .app-item {
        padding: 8px;
        border-bottom: 1px solid #eee;
        cursor: pointer;
      }
      
      .app-item.active {
        background: #f0f8ff;
      }
      
      .app-details {
        flex: 1;
        overflow: auto;
      }
      
      .app-detail-section {
        margin-bottom: 15px;
      }
      
      .app-detail-section h4 {
        margin: 0 0 5px 0;
        font-size: 13px;
        border-bottom: 1px solid #eee;
        padding-bottom: 3px;
      }
      
      .events-controls {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
      }
      
      .events-list {
        flex: 1;
        overflow: auto;
        border: 1px solid #eee;
      }
      
      .event-item {
        padding: 5px;
        border-bottom: 1px solid #eee;
      }
      
      .event-time {
        color: #888;
        margin-right: 5px;
      }
      
      .event-type {
        font-weight: bold;
        margin-right: 5px;
      }
      
      .performance-metrics {
        flex: 1;
        overflow: auto;
      }
      
      .metric-item {
        display: flex;
        justify-content: space-between;
        padding: 5px 0;
        border-bottom: 1px solid #eee;
      }
      
      .metric-name {
        font-weight: bold;
      }
      
      .console-controls {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
      }
      
      .console-output {
        flex: 1;
        overflow: auto;
        background: #000;
        color: #fff;
        padding: 10px;
        font-family: monospace;
      }
      
      .console-log {
        margin-bottom: 5px;
      }
      
      .console-log.error {
        color: #ff6b6b;
      }
      
      .console-log.warn {
        color: #ffd93d;
      }
      
      .console-log.info {
        color: #6bcf7f;
      }
    `;
    document.head.appendChild(style);
  }
  
  // 绑定事件
  bindEvents() {
    // 关闭按钮
    this.panel.querySelector('.debug-panel-close').addEventListener('click', () => {
      this.hide();
    });
    
    // 标签切换
    this.panel.querySelectorAll('.tab-button').forEach(button => {
      button.addEventListener('click', () => {
        this.switchTab(button.dataset.tab);
      });
    });
    
    // 应用列表点击
    this.panel.querySelector('.apps-list').addEventListener('click', (event) => {
      const appItem = event.target.closest('.app-item');
      if (appItem) {
        this.selectApp(appItem.dataset.appName);
      }
    });
    
    // 清空事件
    this.panel.querySelector('.clear-events').addEventListener('click', () => {
      this.clearEvents();
    });
    
    // 清空控制台
    this.panel.querySelector('.clear-console').addEventListener('click', () => {
      this.clearConsole();
    });
    
    // 日志级别过滤
    this.panel.querySelector('.log-level').addEventListener('change', (event) => {
      this.filterConsoleLogs(event.target.value);
    });
  }
  
  // 设置键盘快捷键
  setupKeyboardShortcut() {
    document.addEventListener('keydown', (event) => {
      // Ctrl+Shift+D 切换调试面板
      if (event.ctrlKey && event.shiftKey && event.key === 'D') {
        this.toggle();
      }
    });
  }
  
  // 切换面板显示/隐藏
  toggle() {
    if (this.isOpen) {
      this.hide();
    } else {
      this.show();
    }
  }
  
  // 显示面板
  show() {
    this.panel.style.display = 'flex';
    this.isOpen = true;
    this.refresh();
  }
  
  // 隐藏面板
  hide() {
    this.panel.style.display = 'none';
    this.isOpen = false;
  }
  
  // 切换标签
  switchTab(tabName) {
    // 更新按钮状态
    this.panel.querySelectorAll('.tab-button').forEach(button => {
      button.classList.toggle('active', button.dataset.tab === tabName);
    });
    
    // 更新内容显示
    this.panel.querySelectorAll('.tab-content').forEach(content => {
      content.classList.toggle('active', content.id === `${tabName}-tab`);
    });
    
    // 刷新当前标签内容
    this.refreshTab(tabName);
  }
  
  // 刷新标签内容
  refreshTab(tabName) {
    switch (tabName) {
      case 'apps':
        this.refreshAppsTab();
        break;
      case 'events':
        this.refreshEventsTab();
        break;
      case 'performance':
        this.refreshPerformanceTab();
        break;
      case 'console':
        this.refreshConsoleTab();
        break;
    }
  }
  
  // 刷新应用标签
  refreshAppsTab() {
    this.updateAppsList();
    this.updateAppDetails();
  }
  
  // 更新应用列表
  updateAppsList() {
    const appsList = this.panel.querySelector('.apps-list');
    appsList.innerHTML = '';
    
    this.apps.forEach((app, name) => {
      const appItem = document.createElement('div');
      appItem.className = 'app-item';
      appItem.dataset.appName = name;
      
      const statusClass = app.status === 'active' ? 'active' : 'inactive';
      
      appItem.innerHTML = `
        <div class="app-name">${name}</div>
        <div class="app-status ${statusClass}">${app.status}</div>
        <div class="app-version">${app.version || 'unknown'}</div>
      `;
      
      appsList.appendChild(appItem);
    });
  }
  
  // 更新应用详情
  updateAppDetails() {
    const appDetails = this.panel.querySelector('.app-details');
    const activeAppItem = this.panel.querySelector('.app-item.active');
    
    if (!activeAppItem) {
      appDetails.innerHTML = '<p>选择一个应用查看详情</p>';
      return;
    }
    
    const appName = activeAppItem.dataset.appName;
    const app = this.apps.get(appName);
    
    appDetails.innerHTML = `
      <div class="app-detail-section">
        <h4>基本信息</h4>
        <div>名称: ${app.name}</div>
        <div>状态: ${app.status}</div>
        <div>版本: ${app.version || 'unknown'}</div>
        <div>入口: ${app.entry || 'unknown'}</div>
      </div>
      
      <div class="app-detail-section">
        <h4>生命周期</h4>
        <div>加载时间: ${app.loadTime || 'unknown'}</div>
        <div>挂载时间: ${app.mountTime || 'unknown'}</div>
        <div>卸载时间: ${app.unmountTime || 'unknown'}</div>
      </div>
      
      <div class="app-detail-section">
        <h4>资源</h4>
        <div>脚本数量: ${app.scripts ? app.scripts.length : 0}</div>
        <div>样式数量: ${app.styles ? app.styles.length : 0}</div>
      </div>
      
      <div class="app-detail-section">
        <h4>操作</h4>
        <button class="reload-app">重新加载</button>
        <button class="unmount-app">卸载应用</button>
      </div>
    `;
    
    // 绑定操作按钮事件
    appDetails.querySelector('.reload-app').addEventListener('click', () => {
      this.reloadApp(appName);
    });
    
    appDetails.querySelector('.unmount-app').addEventListener('click', () => {
      this.unmountApp(appName);
    });
  }
  
  // 选择应用
  selectApp(appName) {
    this.panel.querySelectorAll('.app-item').forEach(item => {
      item.classList.toggle('active', item.dataset.appName === appName);
    });
    
    this.updateAppDetails();
  }
  
  // 刷新事件标签
  refreshEventsTab() {
    const eventsList = this.panel.querySelector('.events-list');
    eventsList.innerHTML = '';
    
    this.events.forEach(event => {
      const eventItem = document.createElement('div');
      eventItem.className = 'event-item';
      
      const time = new Date(event.timestamp).toLocaleTimeString();
      
      eventItem.innerHTML = `
        <span class="event-time">${time}</span>
        <span class="event-type">${event.type}</span>
        <span class="event-detail">${this.formatEventDetail(event)}</span>
      `;
      
      eventsList.appendChild(eventItem);
    });
    
    // 自动滚动到底部
    const autoScroll = this.panel.querySelector('#auto-scroll').checked;
    if (autoScroll) {
      eventsList.scrollTop = eventsList.scrollHeight;
    }
  }
  
  // 格式化事件详情
  formatEventDetail(event) {
    switch (event.type) {
      case 'app-load':
        return `应用 ${event.appName} 加载`;
      case 'app-mount':
        return `应用 ${event.appName} 挂载`;
      case 'app-unmount':
        return `应用 ${event.appName} 卸载`;
      case 'route-change':
        return `路由从 ${event.from} 变为 ${event.to}`;
      case 'error':
        return `${event.errorType}: ${event.message}`;
      default:
        return JSON.stringify(event.data);
    }
  }
  
  // 清空事件
  clearEvents() {
    this.events = [];
    this.refreshEventsTab();
  }
  
  // 刷新性能标签
  refreshPerformanceTab() {
    const metricsContainer = this.panel.querySelector('.performance-metrics');
    metricsContainer.innerHTML = '';
    
    // 获取性能指标
    const metrics = this.getPerformanceMetrics();
    
    Object.entries(metrics).forEach(([name, value]) => {
      const metricItem = document.createElement('div');
      metricItem.className = 'metric-item';
      
      metricItem.innerHTML = `
        <span class="metric-name">${name}</span>
        <span class="metric-value">${value}</span>
      `;
      
      metricsContainer.appendChild(metricItem);
    });
  }
  
  // 获取性能指标
  getPerformanceMetrics() {
    const metrics = {};
    
    // 导航时间
    if (performance.timing) {
      const timing = performance.timing;
      metrics['DNS查询时间'] = `${timing.domainLookupEnd - timing.domainLookupStart}ms`;
      metrics['TCP连接时间'] = `${timing.connectEnd - timing.connectStart}ms`;
      metrics['请求响应时间'] = `${timing.responseEnd - timing.requestStart}ms`;
      metrics['DOM解析时间'] = `${timing.domContentLoadedEventEnd - timing.responseEnd}ms`;
      metrics['页面加载总时间'] = `${timing.loadEventEnd - timing.navigationStart}ms`;
    }
    
    // 内存使用
    if (performance.memory) {
      metrics['JS堆大小使用'] = `${(performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2)}MB`;
      metrics['JS堆大小总计'] = `${(performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2)}MB`;
    }
    
    return metrics;
  }
  
  // 刷新控制台标签
  refreshConsoleTab() {
    const consoleOutput = this.panel.querySelector('.console-output');
    consoleOutput.innerHTML = '';
    
    const logLevel = this.panel.querySelector('.log-level').value;
    
    // 获取控制台日志
    const logs = this.getConsoleLogs(logLevel);
    
    logs.forEach(log => {
      const logItem = document.createElement('div');
      logItem.className = `console-log ${log.level}`;
      
      const time = new Date(log.timestamp).toLocaleTimeString();
      
      logItem.innerHTML = `
        <span class="console-time">[${time}]</span>
        <span class="console-level">[${log.level.toUpperCase()}]</span>
        <span class="console-message">${log.message}</span>
      `;
      
      consoleOutput.appendChild(logItem);
    });
    
    // 自动滚动到底部
    consoleOutput.scrollTop = consoleOutput.scrollHeight;
  }
  
  // 获取控制台日志
  getConsoleLogs(level) {
    // 这里应该从实际的日志存储中获取
    // 为了示例，返回模拟数据
    return [
      {
        level: 'info',
        message: '微前端应用已初始化',
        timestamp: Date.now() - 60000
      },
      {
        level: 'warn',
        message: '检测到重复的依赖库',
        timestamp: Date.now() - 30000
      },
      {
        level: 'error',
        message: '应用加载失败: network error',
        timestamp: Date.now() - 10000
      }
    ].filter(log => level === 'all' || log.level === level);
  }
  
  // 清空控制台
  clearConsole() {
    // 这里应该清空实际的日志存储
    this.refreshConsoleTab();
  }
  
  // 过滤控制台日志
  filterConsoleLogs(level) {
    this.refreshConsoleTab();
  }
  
  // 注册应用
  registerApp(name, config) {
    this.apps.set(name, {
      name,
      status: 'registered',
      ...config
    });
    
    if (this.isOpen) {
      this.refreshAppsTab();
    }
  }
  
  // 更新应用状态
  updateAppStatus(name, status, data = {}) {
    if (this.apps.has(name)) {
      const app = this.apps.get(name);
      app.status = status;
      
      // 添加时间戳
      if (status === 'loaded') {
        app.loadTime = new Date().toISOString();
      } else if (status === 'mounted') {
        app.mountTime = new Date().toISOString();
      } else if (status === 'unmounted') {
        app.unmountTime = new Date().toISOString();
      }
      
      // 合并其他数据
      Object.assign(app, data);
      
      // 添加事件
      this.addEvent(`app-${status}`, { appName: name, ...data });
      
      if (this.isOpen) {
        this.refreshAppsTab();
      }
    }
  }
  
  // 添加事件
  addEvent(type, data = {}) {
    this.events.unshift({
      type,
      data,
      timestamp: Date.now()
    });
    
    // 限制事件数量
    if (this.events.length > this.maxEvents) {
      this.events = this.events.slice(0, this.maxEvents);
    }
    
    if (this.isOpen) {
      this.refreshEventsTab();
    }
  }
  
  // 重新加载应用
  reloadApp(name) {
    // 触发应用重新加载
    window.dispatchEvent(new CustomEvent('micro-app-reload', {
      detail: { appName: name }
    }));
    
    this.addEvent('app-reload', { appName: name });
  }
  
  // 卸载应用
  unmountApp(name) {
    // 触发应用卸载
    window.dispatchEvent(new CustomEvent('micro-app-unmount', {
      detail: { appName: name }
    }));
    
    this.updateAppStatus(name, 'unmounting');
  }
  
  // 刷新所有标签
  refresh() {
    const activeTab = this.panel.querySelector('.tab-button.active').dataset.tab;
    this.refreshTab(activeTab);
  }
}

// 创建全局调试面板实例
const debugPanel = new MicroFrontendDebugPanel();

// 导出调试面板
export default debugPanel;
```

## 9.4 微前端错误追踪与定位

### 9.4.1 错误追踪系统

```javascript
// 微前端错误追踪系统
class MicroFrontendErrorTracker {
  constructor(config) {
    this.config = {
      endpoint: config.endpoint || '/api/errors',
      appId: config.appId || 'unknown',
      userId: config.userId || 'anonymous',
      environment: config.environment || 'production',
      enableSourceMap: config.enableSourceMap !== false,
      maxErrors: config.maxErrors || 50,
      enableStacktrace: config.enableStacktrace !== false,
      ...config
    };
    
    this.errors = [];
    this.errorHandlers = new Map();
    this.sourceMapCache = new Map();
    
    this.init();
  }
  
  // 初始化错误追踪
  init() {
    // 注册错误处理器
    this.registerErrorHandlers();
    
    // 监听微应用错误
    this.listenToMicroAppErrors();
    
    // 设置全局错误处理
    this.setupGlobalErrorHandlers();
  }
  
  // 注册错误处理器
  registerErrorHandlers() {
    // JavaScript错误处理器
    this.errorHandlers.set('javascript', this.handleJavaScriptError.bind(this));
    
    // 资源加载错误处理器
    this.errorHandlers.set('resource', this.handleResourceError.bind(this));
    
    // Promise错误处理器
    this.errorHandlers.set('promise', this.handlePromiseError.bind(this));
    
    // 微应用错误处理器
    this.errorHandlers.set('microapp', this.handleMicroAppError.bind(this));
  }
  
  // 设置全局错误处理
  setupGlobalErrorHandlers() {
    // JavaScript错误
    window.addEventListener('error', (event) => {
      this.trackError('javascript', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        error: event.error
      });
    });
    
    // 资源加载错误
    window.addEventListener('error', (event) => {
      if (event.target !== window) {
        this.trackError('resource', {
          target: event.target,
          src: event.target.src || event.target.href
        });
      }
    }, true);
    
    // Promise错误
    window.addEventListener('unhandledrejection', (event) => {
      this.trackError('promise', {
        reason: event.reason
      });
    });
  }
  
  // 监听微应用错误
  listenToMicroAppErrors() {
    window.addEventListener('micro-app-error', (event) => {
      this.trackError('microapp', {
        appName: event.detail.name,
        error: event.detail.error
      });
    });
  }
  
  // 追踪错误
  async trackError(type, errorData) {
    const handler = this.errorHandlers.get(type);
    if (!handler) {
      console.warn(`No handler for error type: ${type}`);
      return;
    }
    
    try {
      const processedError = await handler(errorData);
      
      // 添加到错误列表
      this.errors.unshift(processedError);
      
      // 限制错误数量
      if (this.errors.length > this.config.maxErrors) {
        this.errors = this.errors.slice(0, this.config.maxErrors);
      }
      
      // 上报错误
      this.reportError(processedError);
    } catch (error) {
      console.error('Error processing error:', error);
    }
  }
  
  // 处理JavaScript错误
  async handleJavaScriptError(errorData) {
    const error = {
      type: 'javascript',
      message: errorData.message,
      filename: errorData.filename,
      lineno: errorData.lineno,
      colno: errorData.colno,
      stack: errorData.error ? errorData.error.stack : '',
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent
    };
    
    // 如果启用源码映射，尝试解析原始位置
    if (this.config.enableSourceMap && error.stack) {
      try {
        error.originalStack = await this.parseStackTrace(error.stack);
      } catch (e) {
        console.warn('Failed to parse stack trace with source map:', e);
      }
    }
    
    return error;
  }
  
  // 处理资源加载错误
  async handleResourceError(errorData) {
    const target = errorData.target;
    const error = {
      type: 'resource',
      elementType: target.tagName.toLowerCase(),
      src: errorData.src,
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent
    };
    
    // 添加特定于元素类型的属性
    if (target.tagName.toLowerCase() === 'img') {
      error.alt = target.alt || '';
    } else if (target.tagName.toLowerCase() === 'script') {
      error.async = target.async;
      error.defer = target.defer;
    } else if (target.tagName.toLowerCase() === 'link') {
      error.rel = target.rel;
      error.media = target.media;
    }
    
    return error;
  }
  
  // 处理Promise错误
  async handlePromiseError(errorData) {
    const error = {
      type: 'promise',
      reason: errorData.reason ? errorData.reason.toString() : '',
      stack: errorData.reason && errorData.reason.stack ? errorData.reason.stack : '',
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent
    };
    
    // 如果启用源码映射，尝试解析原始位置
    if (this.config.enableSourceMap && error.stack) {
      try {
        error.originalStack = await this.parseStackTrace(error.stack);
      } catch (e) {
        console.warn('Failed to parse stack trace with source map:', e);
      }
    }
    
    return error;
  }
  
  // 处理微应用错误
  async handleMicroAppError(errorData) {
    const error = {
      type: 'microapp',
      appName: errorData.appName,
      message: errorData.error ? errorData.error.toString() : '',
      stack: errorData.error && errorData.error.stack ? errorData.error.stack : '',
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent
    };
    
    // 如果启用源码映射，尝试解析原始位置
    if (this.config.enableSourceMap && error.stack) {
      try {
        error.originalStack = await this.parseStackTrace(error.stack);
      } catch (e) {
        console.warn('Failed to parse stack trace with source map:', e);
      }
    }
    
    return error;
  }
  
  // 解析堆栈跟踪
  async parseStackTrace(stack) {
    // 这里应该使用source-map库来解析源码映射
    // 为了示例，简化处理
    
    if (!stack) return '';
    
    const lines = stack.split('\n');
    const parsedLines = [];
    
    for (const line of lines) {
      // 尝试匹配常见的堆栈跟踪格式
      const match = line.match(/at\s+(.+?)\s+\((.+?):(\d+):(\d+)\)/);
      
      if (match) {
        const [, functionName, filename, line, column] = match;
        
        // 尝试从源码映射中获取原始位置
        const originalPosition = await this.getOriginalPosition(filename, parseInt(line), parseInt(column));
        
        if (originalPosition) {
          parsedLines.push(`at ${functionName} (${originalPosition.source}:${originalPosition.line}:${originalPosition.column})`);
        } else {
          parsedLines.push(line);
        }
      } else {
        parsedLines.push(line);
      }
    }
    
    return parsedLines.join('\n');
  }
  
  // 获取原始位置
  async getOriginalPosition(filename, line, column) {
    // 这里应该使用source-map库来解析源码映射
    // 为了示例，返回null
    
    // 实际实现可能类似：
    // const sourceMap = await this.loadSourceMap(filename);
    // if (sourceMap) {
    //   return sourceMap.originalPositionFor({ line, column });
    // }
    
    return null;
  }
  
  // 上报错误
  reportError(error) {
    const reportData = {
      error,
      meta: {
        appId: this.config.appId,
        userId: this.config.userId,
        environment: this.config.environment,
        timestamp: Date.now()
      }
    };
    
    // 使用sendBeacon上报，避免阻塞页面卸载
    if (navigator.sendBeacon) {
      navigator.sendBeacon(this.config.endpoint, JSON.stringify(reportData));
    } else {
      // 降级处理
      fetch(this.config.endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(reportData),
        keepalive: true
      }).catch(err => {
        console.error('Failed to report error:', err);
      });
    }
  }
  
  // 获取错误列表
  getErrors() {
    return [...this.errors];
  }
  
  // 清空错误列表
  clearErrors() {
    this.errors = [];
  }
}

// 使用示例
const errorTracker = new MicroFrontendErrorTracker({
  endpoint: '/api/errors',
  appId: 'main-app',
  userId: 'user123',
  environment: 'production',
  enableSourceMap: true,
  maxErrors: 50
});
```

## 9.4 微前端监控与调试最佳实践

### 9.4.1 监控最佳实践

1. **分层监控**：实施分层监控策略，从基础设施到业务层面全面覆盖
2. **关键指标优先**：优先监控对业务和用户体验影响最大的关键指标
3. **上下文丰富**：为监控数据添加丰富的上下文信息，便于问题定位
4. **可视化展示**：提供直观的数据可视化，便于快速了解系统状态
5. **自动化告警**：设置合理的告警阈值，实现自动化告警

```javascript
/**
 * 微前端监控最佳实践实现
 */
class MicroFrontendMonitoringBestPractices {
  constructor() {
    this.monitoringLevels = ['infrastructure', 'platform', 'application', 'business'];
    this.keyMetrics = new Map();
    this.alertRules = new Map();
    this.dashboard = {};
    this.contextEnrichers = new Map();
    this.config = {
      enableContextEnrichment: true,
      enableAlerting: true,
      enableDashboard: true,
      alertThresholds: {
        errorRate: 5, // 错误率阈值(%)
        responseTime: 3000, // 响应时间阈值(ms)
        loadTime: 5000 // 加载时间阈值(ms)
      }
    };
  }

  // 初始化监控系统
  initialize() {
    this.defineKeyMetrics();
    this.setupAlertRules();
    this.initializeDashboard();
    this.registerContextEnrichers();
  }

  // 定义关键指标
  defineKeyMetrics() {
    // 根据业务需求定义关键指标
    this.keyMetrics.set('user-experience', [
      'first-contentful-paint',
      'largest-contentful-paint',
      'first-input-delay',
      'cumulative-layout-shift'
    ]);
    
    this.keyMetrics.set('system-stability', [
      'error-rate',
      'app-crash-rate',
      'api-failure-rate',
      'memory-leak-rate'
    ]);
    
    this.keyMetrics.set('business-value', [
      'conversion-rate',
      'task-completion-rate',
      'user-engagement',
      'revenue-impact'
    ]);
  }

  // 设置告警规则
  setupAlertRules() {
    // 设置性能告警规则
    this.addAlertRule('performance', {
      name: '页面加载缓慢',
      condition: 'app-load-time > 3000',
      severity: 'warning',
      message: '微应用加载时间超过3秒',
      actions: ['notify-team', 'create-ticket']
    });
    
    this.addAlertRule('performance', {
      name: '高错误率',
      condition: 'error-rate > 5',
      severity: 'critical',
      message: '微应用错误率超过5%',
      actions: ['notify-team', 'create-ticket', 'escalate']
    });
    
    // 设置业务告警规则
    this.addAlertRule('business', {
      name: '转化率下降',
      condition: 'conversion-rate < baseline * 0.8',
      severity: 'warning',
      message: '业务转化率下降超过20%',
      actions: ['notify-team', 'create-ticket']
    });
  }

  // 初始化仪表板
  initializeDashboard() {
    // 创建仪表板配置
    this.dashboard = {
      overview: {
        title: '微前端概览',
        widgets: [
          {
            type: 'metric',
            title: '活跃微应用',
            metrics: ['active-apps'],
            refreshInterval: 60000
          },
          {
            type: 'chart',
            title: '错误率趋势',
            metrics: ['error-rate'],
            chartType: 'line',
            timeRange: '24h'
          },
          {
            type: 'chart',
            title: '性能分布',
            metrics: ['app-load-time'],
            chartType: 'histogram',
            timeRange: '24h'
          }
        ]
      },
      performance: {
        title: '性能监控',
        widgets: [
          {
            type: 'chart',
            title: '加载时间趋势',
            metrics: ['app-load-time', 'first-contentful-paint'],
            chartType: 'line',
            timeRange: '24h'
          },
          {
            type: 'chart',
            title: '核心Web指标',
            metrics: ['lcp', 'fid', 'cls'],
            chartType: 'gauge',
            timeRange: '1h'
          }
        ]
      },
      business: {
        title: '业务指标',
        widgets: [
          {
            type: 'chart',
            title: '转化率趋势',
            metrics: ['conversion-rate'],
            chartType: 'line',
            timeRange: '7d'
          },
          {
            type: 'chart',
            title: '用户参与度',
            metrics: ['user-engagement'],
            chartType: 'bar',
            timeRange: '24h'
          }
        ]
      }
    };
  }

  // 注册上下文增强器
  registerContextEnrichers() {
    // 添加用户上下文
    this.contextEnrichers.set('user', (data) => {
      return {
        ...data,
        context: {
          ...data.context,
          userId: this.getCurrentUserId(),
          sessionId: this.getSessionId(),
          userType: this.getUserType(),
          location: this.getUserLocation()
        }
      };
    });
    
    // 添加应用上下文
    this.contextEnrichers.set('application', (data) => {
      return {
        ...data,
        context: {
          ...data.context,
          appName: this.getCurrentAppName(),
          appVersion: this.getCurrentAppVersion(),
          environment: this.getEnvironment(),
          buildNumber: this.getBuildNumber()
        }
      };
    });
    
    // 添加业务上下文
    this.contextEnrichers.set('business', (data) => {
      return {
        ...data,
        context: {
          ...data.context,
          businessUnit: this.getBusinessUnit(),
          productLine: this.getProductLine(),
          feature: this.getCurrentFeature(),
          aBTestGroup: this.getABTestGroup()
        }
      };
    });
  }

  // 添加指标
  addMetric(level, id, config) {
    if (!this.keyMetrics.has(level)) {
      this.keyMetrics.set(level, new Map());
    }
    
    this.keyMetrics.get(level).set(id, config);
  }

  // 添加告警规则
  addAlertRule(category, rule) {
    if (!this.alertRules.has(category)) {
      this.alertRules.set(category, []);
    }
    
    this.alertRules.get(category).push(rule);
  }

  // 处理监控数据
  processMonitoringData(data) {
    // 应用上下文增强
    let enrichedData = data;
    for (const [name, enricher] of this.contextEnrichers) {
      enrichedData = enricher(enrichedData);
    }
    
    // 检查告警规则
    this.checkAlertRules(enrichedData);
    
    // 更新仪表板
    this.updateDashboard(enrichedData);
    
    return enrichedData;
  }

  // 检查告警规则
  checkAlertRules(data) {
    for (const [category, rules] of this.alertRules) {
      for (const rule of rules) {
        if (this.evaluateCondition(rule.condition, data)) {
          this.triggerAlert(rule, data);
        }
      }
    }
  }

  // 评估条件
  evaluateCondition(condition, data) {
    // 简化的条件评估实现
    // 实际实现可能需要更复杂的表达式解析器
    
    try {
      // 将条件中的指标替换为实际值
      let evalCondition = condition;
      
      // 查找所有指标引用
      const metricRegex = /(\w+)/g;
      const matches = condition.match(metricRegex);
      
      if (matches) {
        for (const match of matches) {
          // 检查是否是数据中的指标
          if (data.metrics && data.metrics[match] !== undefined) {
            evalCondition = evalCondition.replace(
              new RegExp(`\\b${match}\\b`, 'g'),
              data.metrics[match]
            );
          }
        }
      }
      
      // 评估条件
      return eval(evalCondition);
    } catch (error) {
      console.error('评估告警条件失败:', error);
      return false;
    }
  }

  // 触发告警
  triggerAlert(rule, data) {
    const alert = {
      id: this.generateAlertId(),
      rule: rule.name,
      severity: rule.severity,
      message: rule.message,
      timestamp: Date.now(),
      data: data,
      status: 'active'
    };
    
    // 执行告警动作
    for (const action of rule.actions) {
      this.executeAlertAction(action, alert);
    }
    
    // 记录告警
    this.logAlert(alert);
  }

  // 执行告警动作
  executeAlertAction(action, alert) {
    switch (action) {
      case 'notify-team':
        this.notifyTeam(alert);
        break;
      case 'create-ticket':
        this.createTicket(alert);
        break;
      case 'escalate':
        this.escalateAlert(alert);
        break;
      default:
        console.warn('未知的告警动作:', action);
    }
  }

  // 通知团队
  notifyTeam(alert) {
    // 实现团队通知逻辑
    console.log('通知团队:', alert);
    
    // 发送通知到团队聊天工具
    this.sendNotification({
      type: 'alert',
      severity: alert.severity,
      message: alert.message,
      timestamp: alert.timestamp
    });
  }

  // 创建工单
  createTicket(alert) {
    // 实现工单创建逻辑
    console.log('创建工单:', alert);
    
    // 调用工单系统API
    this.createTicketInSystem({
      title: `微前端告警: ${alert.rule}`,
      description: alert.message,
      severity: alert.severity,
      data: alert.data
    });
  }

  // 升级告警
  escalateAlert(alert) {
    // 实现告警升级逻辑
    console.log('升级告警:', alert);
    
    // 通知更高级别的负责人
    this.escalateToManagement({
      alert: alert,
      reason: '告警需要升级处理'
    });
  }

  // 记录告警
  logAlert(alert) {
    // 实现告警记录逻辑
    console.log('记录告警:', alert);
    
    // 存储到数据库
    this.storeAlert(alert);
  }

  // 更新仪表板
  updateDashboard(data) {
    // 实现仪表板更新逻辑
    console.log('更新仪表板:', data);
    
    // 发送数据到仪表板
    this.sendToDashboard(data);
  }

  // 辅助方法
  generateAlertId() {
    return 'alert_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }

  getCurrentUserId() {
    // 实现获取当前用户ID的逻辑
    return window.__USER_ID__ || 'anonymous';
  }

  getSessionId() {
    // 实现获取会话ID的逻辑
    return window.__SESSION_ID__ || 'unknown';
  }

  getUserType() {
    // 实现获取用户类型的逻辑
    return window.__USER_TYPE__ || 'regular';
  }

  getUserLocation() {
    // 实现获取用户位置的逻辑
    return window.__USER_LOCATION__ || 'unknown';
  }

  getCurrentAppName() {
    // 实现获取当前应用名称的逻辑
    return window.__APP_NAME__ || 'unknown';
  }

  getCurrentAppVersion() {
    // 实现获取当前应用版本的逻辑
    return window.__APP_VERSION__ || 'unknown';
  }

  getEnvironment() {
    // 实现获取环境的逻辑
    return window.__ENVIRONMENT__ || 'development';
  }

  getBuildNumber() {
    // 实现获取构建号的逻辑
    return window.__BUILD_NUMBER__ || 'unknown';
  }

  getBusinessUnit() {
    // 实现获取业务单元的逻辑
    return window.__BUSINESS_UNIT__ || 'unknown';
  }

  getProductLine() {
    // 实现获取产品线的逻辑
    return window.__PRODUCT_LINE__ || 'unknown';
  }

  getCurrentFeature() {
    // 实现获取当前功能的逻辑
    return window.__CURRENT_FEATURE__ || 'unknown';
  }

  getABTestGroup() {
    // 实现获取A/B测试组的逻辑
    return window.__AB_TEST_GROUP__ || 'control';
  }

  // 通知相关方法（简化实现）
  sendNotification(notification) {
    // 实现发送通知的逻辑
    console.log('发送通知:', notification);
  }

  createTicketInSystem(ticketData) {
    // 实现创建工单的逻辑
    console.log('创建工单:', ticketData);
  }

  escalateToManagement(escalationData) {
    // 实现升级到管理层的逻辑
    console.log('升级告警:', escalationData);
  }

  storeAlert(alert) {
    // 实现存储告警的逻辑
    console.log('存储告警:', alert);
  }

  sendToDashboard(data) {
    // 实现发送数据到仪表板的逻辑
    console.log('发送到仪表板:', data);
  }
}

// 使用示例
const monitoringBestPractices = new MicroFrontendMonitoringBestPractices();
monitoringBestPractices.initialize();

// 处理监控数据
const sampleMonitoringData = {
  type: 'performance',
  timestamp: Date.now(),
  metrics: {
    'app-load-time': 3500,
    'error-rate': 6,
    'conversion-rate': 2.5
  }
};

const enrichedData = monitoringBestPractices.processMonitoringData(sampleMonitoringData);
console.log('增强后的监控数据:', enrichedData);
```

### 9.4.2 调试最佳实践

1. **分层调试**：实施分层调试策略，从基础设施到应用层面逐层排查
2. **日志标准化**：建立标准化的日志格式和级别，便于问题定位
3. **调试工具链**：提供完整的调试工具链，支持不同场景的调试需求
4. **错误追踪**：实现完整的错误追踪链路，快速定位问题根源
5. **调试文档**：提供详细的调试文档和常见问题解决方案

```javascript
/**
 * 微前端调试最佳实践实现
 */
class MicroFrontendDebuggingBestPractices {
  constructor() {
    this.debugLevels = ['infrastructure', 'platform', 'application', 'feature'];
    this.logLevels = ['debug', 'info', 'warn', 'error', 'fatal'];
    this.logFormatters = new Map();
    this.debugTools = new Map();
    this.errorTracker = new Map();
    this.debuggingDocs = new Map();
    this.config = {
      enableSourceMap: true,
      enableVerboseLogging: false,
      enableErrorTracking: true,
      enablePerformanceProfiling: false,
      maxLogEntries: 1000,
      logRetentionDays: 7
    };
  }

  // 初始化调试系统
  initialize() {
    this.setupDebugLevels();
    this.setupLogFormatters();
    this.setupDebugTools();
    this.setupErrorTracking();
    this.setupDebuggingDocs();
  }

  // 设置调试层级
  setupDebugLevels() {
    // 基础设施层调试
    this.setupInfrastructureDebugging();
    
    // 平台层调试
    this.setupPlatformDebugging();
    
    // 应用层调试
    this.setupApplicationDebugging();
    
    // 功能层调试
    this.setupFeatureDebugging();
  }

  // 设置基础设施层调试
  setupInfrastructureDebugging() {
    this.addDebugTool('infrastructure', 'network-inspector', {
      name: '网络检查器',
      description: '检查网络请求和响应',
      initialize: () => {
        // 初始化网络检查器
        const networkInspector = {
          requests: [],
          
          start: () => {
            // 拦截XMLHttpRequest
            const originalXHROpen = XMLHttpRequest.prototype.open;
            const originalXHRSend = XMLHttpRequest.prototype.send;
            
            XMLHttpRequest.prototype.open = function(method, url, ...args) {
              this._method = method;
              this._url = url;
              return originalXHROpen.apply(this, [method, url, ...args]);
            };
            
            XMLHttpRequest.prototype.send = function(data) {
              const startTime = Date.now();
              
              this.addEventListener('load', () => {
                networkInspector.requests.push({
                  method: this._method,
                  url: this._url,
                  status: this.status,
                  response: this.response,
                  duration: Date.now() - startTime,
                  timestamp: Date.now()
                });
              });
              
              return originalXHRSend.apply(this, [data]);
            };
            
            // 拦截fetch API
            const originalFetch = window.fetch;
            
            window.fetch = function(url, options = {}) {
              const startTime = Date.now();
              
              return originalFetch.apply(this, [url, options])
                .then(response => {
                  networkInspector.requests.push({
                    method: options.method || 'GET',
                    url,
                    status: response.status,
                    duration: Date.now() - startTime,
                    timestamp: Date.now()
                  });
                  
                  return response;
                })
                .catch(error => {
                  networkInspector.requests.push({
                    method: options.method || 'GET',
                    url,
                    error: error.message,
                    duration: Date.now() - startTime,
                    timestamp: Date.now()
                  });
                  
                  throw error;
                });
            };
          },
          
          getRequests: () => networkInspector.requests,
          
          clear: () => {
            networkInspector.requests = [];
          }
        };
        
        networkInspector.start();
        return networkInspector;
      }
    });
    
    this.addDebugTool('infrastructure', 'resource-monitor', {
      name: '资源监控器',
      description: '监控资源加载和使用情况',
      initialize: () => {
        // 初始化资源监控器
        const resourceMonitor = {
          resources: [],
          
          start: () => {
            // 监控资源加载
            if ('PerformanceObserver' in window) {
              const observer = new PerformanceObserver((list) => {
                for (const entry of list.getEntries()) {
                  if (entry.entryType === 'resource') {
                    resourceMonitor.resources.push({
                      name: entry.name,
                      type: getResourceType(entry.name),
                      duration: entry.duration,
                      size: entry.transferSize || 0,
                      timestamp: entry.startTime
                    });
                  }
                }
              });
              
              observer.observe({ entryTypes: ['resource'] });
              resourceMonitor.observer = observer;
            }
            
            // 定期收集内存使用情况
            resourceMonitor.memoryInterval = setInterval(() => {
              if (performance.memory) {
                resourceMonitor.resources.push({
                  type: 'memory',
                  usedJSHeapSize: performance.memory.usedJSHeapSize,
                  totalJSHeapSize: performance.memory.totalJSHeapSize,
                  timestamp: Date.now()
                });
              }
            }, 10000);
          },
          
          getResources: () => resourceMonitor.resources,
          
          clear: () => {
            resourceMonitor.resources = [];
          },
          
          stop: () => {
            if (resourceMonitor.observer) {
              resourceMonitor.observer.disconnect();
            }
            
            if (resourceMonitor.memoryInterval) {
              clearInterval(resourceMonitor.memoryInterval);
            }
          }
        };
        
        resourceMonitor.start();
        return resourceMonitor;
      }
    });
  }

  // 设置平台层调试
  setupPlatformDebugging() {
    this.addDebugTool('platform', 'micro-frontend-inspector', {
      name: '微前端检查器',
      description: '检查微前端应用的状态和交互',
      initialize: () => {
        // 初始化微前端检查器
        const microFrontendInspector = {
          apps: new Map(),
          events: [],
          
          start: () => {
            // 监听微前端生命周期事件
            window.addEventListener('micro-frontend-loaded', (event) => {
              microFrontendInspector.apps.set(event.detail.name, {
                status: 'loaded',
                url: event.detail.url,
                timestamp: Date.now()
              });
              
              microFrontendInspector.events.push({
                type: 'loaded',
                app: event.detail.name,
                timestamp: Date.now()
              });
            });
            
            window.addEventListener('micro-frontend-unloaded', (event) => {
              if (microFrontendInspector.apps.has(event.detail.name)) {
                microFrontendInspector.apps.get(event.detail.name).status = 'unloaded';
              }
              
              microFrontendInspector.events.push({
                type: 'unloaded',
                app: event.detail.name,
                timestamp: Date.now()
              });
            });
            
            // 监听微前端通信事件
            window.addEventListener('micro-frontend-message', (event) => {
              microFrontendInspector.events.push({
                type: 'message',
                from: event.detail.from,
                to: event.detail.to,
                data: event.detail.data,
                timestamp: Date.now()
              });
            });
          },
          
          getApps: () => Array.from(microFrontendInspector.apps.entries()).map(([name, info]) => ({
            name,
            ...info
          })),
          
          getEvents: () => microFrontendInspector.events,
          
          clear: () => {
            microFrontendInspector.events = [];
          }
        };
        
        microFrontendInspector.start();
        return microFrontendInspector;
      }
    });
    
    this.addDebugTool('platform', 'state-inspector', {
      name: '状态检查器',
      description: '检查微前端应用的状态',
      initialize: () => {
        // 初始化状态检查器
        const stateInspector = {
          snapshots: [],
          
          start: () => {
            // 定期收集状态快照
            stateInspector.snapshotInterval = setInterval(() => {
              const snapshot = {
                timestamp: Date.now(),
                globalState: window.__GLOBAL_STATE__ || {},
                microFrontendStates: window.__MICRO_FRONTEND_STATES__ || {}
              };
              
              stateInspector.snapshots.push(snapshot);
              
              // 限制快照数量
              if (stateInspector.snapshots.length > 100) {
                stateInspector.snapshots.shift();
              }
            }, 5000);
          },
          
          getSnapshots: () => stateInspector.snapshots,
          
          clear: () => {
            stateInspector.snapshots = [];
          },
          
          stop: () => {
            if (stateInspector.snapshotInterval) {
              clearInterval(stateInspector.snapshotInterval);
            }
          }
        };
        
        stateInspector.start();
        return stateInspector;
      }
    });
  }

  // 设置应用层调试
  setupApplicationDebugging() {
    this.addDebugTool('application', 'component-tracker', {
      name: '组件追踪器',
      description: '追踪组件的渲染和更新',
      initialize: () => {
        // 初始化组件追踪器
        const componentTracker = {
          components: new Map(),
          renderEvents: [],
          
          start: () => {
            // 拦截React组件渲染（如果使用React）
            if (window.React && window.React.createElement) {
              const originalCreateElement = window.React.createElement;
              
              window.React.createElement = function(type, props, ...children) {
                if (typeof type === 'function' && type.displayName) {
                  const componentName = type.displayName;
                  
                  if (!componentTracker.components.has(componentName)) {
                    componentTracker.components.set(componentName, {
                      renderCount: 0,
                      lastRenderTime: 0
                    });
                  }
                  
                  const component = componentTracker.components.get(componentName);
                  component.renderCount++;
                  component.lastRenderTime = Date.now();
                  
                  componentTracker.renderEvents.push({
                    component: componentName,
                    timestamp: Date.now()
                  });
                }
                
                return originalCreateElement.apply(this, [type, props, ...children]);
              };
            }
          },
          
          getComponents: () => Array.from(componentTracker.components.entries()).map(([name, info]) => ({
            name,
            ...info
          })),
          
          getRenderEvents: () => componentTracker.renderEvents,
          
          clear: () => {
            componentTracker.renderEvents = [];
          }
        };
        
        componentTracker.start();
        return componentTracker;
      }
    });
    
    this.addDebugTool('application', 'performance-profiler', {
      name: '性能分析器',
      description: '分析应用性能',
      initialize: () => {
        // 初始化性能分析器
        const performanceProfiler = {
          profiles: [],
          isProfiling: false,
          startTime: 0,
          measurements: [],
          
          start: () => {
            performanceProfiler.isProfiling = true;
            performanceProfiler.startTime = performance.now();
            performanceProfiler.measurements = [];
            
            // 开始监控性能指标
            if ('PerformanceObserver' in window) {
              const observer = new PerformanceObserver((list) => {
                for (const entry of list.getEntries()) {
                  performanceProfiler.measurements.push({
                    type: entry.entryType,
                    name: entry.name,
                    duration: entry.duration,
                    startTime: entry.startTime
                  });
                }
              });
              
              observer.observe({ entryTypes: ['measure', 'navigation', 'paint', 'longtask'] });
              performanceProfiler.observer = observer;
            }
          },
          
          stop: () => {
            if (!performanceProfiler.isProfiling) {
              return;
            }
            
            performanceProfiler.isProfiling = false;
            const endTime = performance.now();
            const duration = endTime - performanceProfiler.startTime;
            
            if (performanceProfiler.observer) {
              performanceProfiler.observer.disconnect();
            }
            
            const profile = {
              duration,
              measurements: performanceProfiler.measurements,
              timestamp: Date.now()
            };
            
            performanceProfiler.profiles.push(profile);
            
            return profile;
          },
          
          getProfiles: () => performanceProfiler.profiles,
          
          clear: () => {
            performanceProfiler.profiles = [];
          }
        };
        
        return performanceProfiler;
      }
    });
  }

  // 设置功能层调试
  setupFeatureDebugging() {
    this.addDebugTool('feature', 'user-interaction-tracker', {
      name: '用户交互追踪器',
      description: '追踪用户交互行为',
      initialize: () => {
        // 初始化用户交互追踪器
        const userInteractionTracker = {
          interactions: [],
          
          start: () => {
            // 监听点击事件
            document.addEventListener('click', (event) => {
              userInteractionTracker.interactions.push({
                type: 'click',
                target: getSelector(event.target),
                x: event.clientX,
                y: event.clientY,
                timestamp: Date.now()
              });
            });
            
            // 监听表单提交
            document.addEventListener('submit', (event) => {
              userInteractionTracker.interactions.push({
                type: 'submit',
                target: getSelector(event.target),
                timestamp: Date.now()
              });
            });
            
            // 监听输入事件
            document.addEventListener('input', (event) => {
              userInteractionTracker.interactions.push({
                type: 'input',
                target: getSelector(event.target),
                value: event.target.value,
                timestamp: Date.now()
              });
            });
          },
          
          getInteractions: () => userInteractionTracker.interactions,
          
          clear: () => {
            userInteractionTracker.interactions = [];
          }
        };
        
        userInteractionTracker.start();
        return userInteractionTracker;
      }
    });
  }

  // 设置日志格式化器
  setupLogFormatters() {
    // JSON格式化器
    this.logFormatters.set('json', {
      format: (logEntry) => {
        return JSON.stringify(logEntry);
      }
    });
    
    // 简单文本格式化器
    this.logFormatters.set('text', {
      format: (logEntry) => {
        const timestamp = new Date(logEntry.timestamp).toISOString();
        return `[${timestamp}] [${logEntry.level.toUpperCase()}] [${logEntry.microFrontendId}] ${logEntry.message}`;
      }
    });
    
    // 彩色控制台格式化器
    this.logFormatters.set('console', {
      format: (logEntry) => {
        const timestamp = new Date(logEntry.timestamp).toISOString();
        const color = getLogLevelColor(logEntry.level);
        
        return `%c[${timestamp}] [${logEntry.level.toUpperCase()}] [${logEntry.microFrontendId}] ${logEntry.message}`;
      },
      
      getStyle: (logEntry) => {
        return `color: ${getLogLevelColor(logEntry.level)}`;
      }
    });
  }

  // 设置调试工具
  setupDebugTools() {
    // 创建调试面板
    this.createDebugPanel();
    
    // 初始化所有调试工具
    for (const [level, tools] of this.debugTools) {
      for (const [id, tool] of tools) {
        tool.instance = tool.initialize();
      }
    }
  }

  // 设置错误追踪
  setupErrorTracking() {
    // 创建错误追踪器
    this.errorTracker = {
      errors: [],
      
      start: () => {
        // 监听全局错误
        window.addEventListener('error', (event) => {
          this.errorTracker.errors.push({
            type: 'javascript',
            message: event.message,
            filename: event.filename,
            lineno: event.lineno,
            colno: event.colno,
            stack: event.error ? event.error.stack : '',
            timestamp: Date.now(),
            microFrontendId: this.getCurrentMicroFrontendId()
          });
        });
        
        // 监听Promise拒绝
        window.addEventListener('unhandledrejection', (event) => {
          this.errorTracker.errors.push({
            type: 'promise-rejection',
            reason: event.reason,
            stack: event.reason && event.reason.stack ? event.reason.stack : '',
            timestamp: Date.now(),
            microFrontendId: this.getCurrentMicroFrontendId()
          });
        });
      },
      
      getErrors: () => this.errorTracker.errors,
      
      clear: () => {
        this.errorTracker.errors = [];
      }
    };
    
    this.errorTracker.start();
  }

  // 设置调试文档
  setupDebuggingDocs() {
    // 添加常见问题文档
    this.addDebuggingDoc('common-issues', {
      title: '常见问题',
      issues: [
        {
          title: '微应用加载失败',
          symptoms: ['微应用无法加载', '控制台报错', '页面显示空白'],
          causes: ['网络问题', '资源路径错误', '依赖缺失'],
          solutions: [
            '检查网络连接',
            '验证资源路径',
            '确保依赖已加载'
          ]
        },
        {
          title: '微应用间通信失败',
          symptoms: ['消息无法发送', '事件无法监听', '状态无法同步'],
          causes: ['事件名称错误', '监听器未注册', '权限问题'],
          solutions: [
            '检查事件名称',
            '确保监听器已注册',
            '验证通信权限'
          ]
        },
        {
          title: '样式冲突',
          symptoms: ['样式异常', '布局错乱', '组件显示不正确'],
          causes: ['CSS选择器冲突', '全局样式污染', '样式加载顺序'],
          solutions: [
            '使用CSS模块化',
            '添加样式隔离',
            '调整样式加载顺序'
          ]
        }
      ]
    });
    
    // 添加调试指南
    this.addDebuggingDoc('debugging-guide', {
      title: '调试指南',
      steps: [
        {
          title: '1. 确定问题范围',
          description: '确定问题是全局性的还是特定微应用的',
          actions: [
            '检查其他微应用是否正常',
            '尝试在不同浏览器中复现',
            '检查控制台错误信息'
          ]
        },
        {
          title: '2. 收集相关信息',
          description: '收集与问题相关的日志和状态信息',
          actions: [
            '查看浏览器控制台',
            '检查网络请求',
            '分析性能指标'
          ]
        },
        {
          title: '3. 定位问题根源',
          description: '通过分析和实验确定问题的根本原因',
          actions: [
            '使用调试工具',
            '添加调试日志',
            '逐步排除可能原因'
          ]
        },
        {
          title: '4. 验证解决方案',
          description: '实施解决方案并验证问题是否已解决',
          actions: [
            '实施修复',
            '测试修复效果',
            '确保没有引入新问题'
          ]
        }
      ]
    });
  }

  // 创建调试面板
  createDebugPanel() {
    // 创建调试面板HTML
    const debugPanel = document.createElement('div');
    debugPanel.id = 'micro-frontend-debug-panel';
    debugPanel.style.cssText = `
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 350px;
      height: 500px;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      border-radius: 5px;
      padding: 10px;
      font-family: monospace;
      font-size: 12px;
      z-index: 10000;
      overflow: hidden;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      display: none;
    `;
    
    // 创建面板头部
    const panelHeader = document.createElement('div');
    panelHeader.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 1px solid #555;
    `;
    
    const panelTitle = document.createElement('h3');
    panelTitle.textContent = '微前端调试工具';
    panelTitle.style.cssText = `
      margin: 0;
      font-size: 14px;
    `;
    
    const toggleButton = document.createElement('button');
    toggleButton.textContent = '显示/隐藏';
    toggleButton.style.cssText = `
      background: #333;
      border: none;
      color: white;
      padding: 2px 5px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 10px;
    `;
    
    panelHeader.appendChild(panelTitle);
    panelHeader.appendChild(toggleButton);
    
    // 创建标签页
    const tabContainer = document.createElement('div');
    tabContainer.style.cssText = `
      display: flex;
      margin-bottom: 10px;
    `;
    
    const tabs = [
      { id: 'tools', name: '工具' },
      { id: 'logs', name: '日志' },
      { id: 'errors', name: '错误' },
      { id: 'docs', name: '文档' }
    ];
    
    const tabContents = {};
    
    tabs.forEach(tab => {
      // 创建标签按钮
      const tabButton = document.createElement('button');
      tabButton.textContent = tab.name;
      tabButton.style.cssText = `
        flex: 1;
        padding: 5px;
        background: #333;
        border: none;
        color: white;
        cursor: pointer;
        border-radius: 3px;
        margin-right: 2px;
        font-size: 10px;
      `;
      
      // 创建标签内容
      const tabContent = document.createElement('div');
      tabContent.id = `debug-tab-${tab.id}`;
      tabContent.style.cssText = `
        display: none;
        height: 420px;
        overflow: auto;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px;
        border-radius: 3px;
      `;
      
      // 添加点击事件
      tabButton.addEventListener('click', () => {
        // 隐藏所有标签内容
        Object.values(tabContents).forEach(content => {
          content.style.display = 'none';
        });
        
        // 重置所有标签按钮样式
        tabs.forEach(t => {
          document.getElementById(`debug-tab-btn-${t.id}`).style.background = '#333';
        });
        
        // 显示当前标签内容
        tabContent.style.display = 'block';
        tabButton.style.background = '#555';
      });
      
      tabContainer.appendChild(tabButton);
      tabButton.id = `debug-tab-btn-${tab.id}`;
      tabContents[tab.id] = tabContent;
    });
    
    // 默认显示第一个标签
    tabContents[tabs[0].id].style.display = 'block';
    document.getElementById(`debug-tab-btn-${tabs[0].id}`).style.background = '#555';
    
    // 组装面板
    debugPanel.appendChild(panelHeader);
    debugPanel.appendChild(tabContainer);
    
    Object.values(tabContents).forEach(content => {
      debugPanel.appendChild(content);
    });
    
    // 添加到页面
    document.body.appendChild(debugPanel);
    
    // 初始化标签内容
    this.initializeToolsTab(tabContents.tools);
    this.initializeLogsTab(tabContents.logs);
    this.initializeErrorsTab(tabContents.errors);
    this.initializeDocsTab(tabContents.docs);
    
    // 添加切换按钮事件
    toggleButton.addEventListener('click', () => {
      debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
    });
    
    // 创建浮动按钮
    const floatingButton = document.createElement('div');
    floatingButton.textContent = '调试';
    floatingButton.style.cssText = `
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      z-index: 9999;
      font-size: 12px;
    `;
    
    floatingButton.addEventListener('click', () => {
      debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
    });
    
    document.body.appendChild(floatingButton);
    
    // 保存面板引用
    this.debugPanel = {
      element: debugPanel,
      floatingButton,
      tabs: tabContents
    };
  }

  // 初始化工具标签
  initializeToolsTab(tabElement) {
    tabElement.innerHTML = `
      <div style="margin-bottom: 5px;">
        <select id="debug-tool-select">
          <option value="">选择调试工具</option>
        </select>
        <button id="debug-tool-execute" style="margin-left: 5px;">执行</button>
      </div>
      <div id="debug-tool-result" style="height: 380px; overflow: auto; background: rgba(0, 0, 0, 0.3); padding: 5px; border-radius: 3px;"></div>
    `;
    
    // 填充调试工具选项
    const toolSelect = document.getElementById('debug-tool-select');
    
    for (const [level, tools] of this.debugTools) {
      const levelGroup = document.createElement('optgroup');
      levelGroup.label = level;
      
      for (const [id, tool] of tools) {
        const option = document.createElement('option');
        option.value = `${level}:${id}`;
        option.textContent = tool.name;
        levelGroup.appendChild(option);
      }
      
      toolSelect.appendChild(levelGroup);
    }
    
    // 添加执行按钮事件
    document.getElementById('debug-tool-execute').addEventListener('click', () => {
      const selectedTool = document.getElementById('debug-tool-select').value;
      if (!selectedTool) {
        return;
      }
      
      const [level, id] = selectedTool.split(':');
      const tool = this.debugTools.get(level).get(id);
      
      if (tool && tool.instance) {
        let result;
        
        // 根据工具类型获取结果
        if (tool.instance.getRequests) {
          result = tool.instance.getRequests();
        } else if (tool.instance.getResources) {
          result = tool.instance.getResources();
        } else if (tool.instance.getApps) {
          result = tool.instance.getApps();
        } else if (tool.instance.getEvents) {
          result = tool.instance.getEvents();
        } else if (tool.instance.getSnapshots) {
          result = tool.instance.getSnapshots();
        } else if (tool.instance.getComponents) {
          result = tool.instance.getComponents();
        } else if (tool.instance.getProfiles) {
          result = tool.instance.getProfiles();
        } else if (tool.instance.getInteractions) {
          result = tool.instance.getInteractions();
        }
        
        // 显示结果
        const resultContainer = document.getElementById('debug-tool-result');
        resultContainer.innerHTML = `<pre style="font-size: 10px; margin: 0;">${JSON.stringify(result, null, 2)}</pre>`;
      }
    });
  }

  // 初始化日志标签
  initializeLogsTab(tabElement) {
    tabElement.innerHTML = `
      <div style="margin-bottom: 5px;">
        <select id="log-level-filter">
          <option value="all">所有级别</option>
          <option value="debug">调试</option>
          <option value="info">信息</option>
          <option value="warn">警告</option>
          <option value="error">错误</option>
          <option value="fatal">致命</option>
        </select>
        <button id="clear-logs" style="margin-left: 5px;">清除日志</button>
      </div>
      <div id="log-container" style="height: 380px; overflow: auto; background: rgba(0, 0, 0, 0.3); padding: 5px; border-radius: 3px;"></div>
    `;
    
    // 初始化日志数组
    this.logs = [];
    
    // 添加事件监听
    document.getElementById('log-level-filter').addEventListener('change', (e) => {
      this.filterLogs(e.target.value);
    });
    
    document.getElementById('clear-logs').addEventListener('click', () => {
      document.getElementById('log-container').innerHTML = '';
      this.logs = [];
    });
  }

  // 初始化错误标签
  initializeErrorsTab(tabElement) {
    tabElement.innerHTML = `
      <div style="margin-bottom: 5px;">
        <button id="clear-errors">清除错误</button>
      </div>
      <div id="error-container" style="height: 380px; overflow: auto; background: rgba(0, 0, 0, 0.3); padding: 5px; border-radius: 3px;"></div>
    `;
    
    // 添加事件监听
    document.getElementById('clear-errors').addEventListener('click', () => {
      document.getElementById('error-container').innerHTML = '';
      if (this.errorTracker) {
        this.errorTracker.clear();
      }
    });
  }

  // 初始化文档标签
  initializeDocsTab(tabElement) {
    tabElement.innerHTML = `
      <div style="margin-bottom: 5px;">
        <select id="debug-doc-select">
          <option value="">选择文档</option>
        </select>
      </div>
      <div id="debug-doc-content" style="height: 380px; overflow: auto; background: rgba(0, 0, 0, 0.3); padding: 5px; border-radius: 3px;"></div>
    `;
    
    // 填充文档选项
    const docSelect = document.getElementById('debug-doc-select');
    
    for (const [id, doc] of this.debuggingDocs) {
      const option = document.createElement('option');
      option.value = id;
      option.textContent = doc.title;
      docSelect.appendChild(option);
    }
    
    // 添加选择事件
    docSelect.addEventListener('change', (e) => {
      const docId = e.target.value;
      if (!docId) {
        document.getElementById('debug-doc-content').innerHTML = '';
        return;
      }
      
      const doc = this.debuggingDocs.get(docId);
      if (doc) {
        this.displayDebugDoc(doc);
      }
    });
  }

  // 显示调试文档
  displayDebugDoc(doc) {
    const contentContainer = document.getElementById('debug-doc-content');
    let html = `<h4>${doc.title}</h4>`;
    
    if (doc.issues) {
      // 显示常见问题
      html += '<div>';
      for (const issue of doc.issues) {
        html += `
          <div style="margin-bottom: 15px; border-bottom: 1px solid #444; padding-bottom: 10px;">
            <h5 style="margin-top: 0; color: #6cf;">${issue.title}</h5>
            
            <div style="margin-bottom: 5px;">
              <strong>症状:</strong>
              <ul style="margin: 5px 0; padding-left: 20px;">
                ${issue.symptoms.map(symptom => `<li>${symptom}</li>`).join('')}
              </ul>
            </div>
            
            <div style="margin-bottom: 5px;">
              <strong>可能原因:</strong>
              <ul style="margin: 5px 0; padding-left: 20px;">
                ${issue.causes.map(cause => `<li>${cause}</li>`).join('')}
              </ul>
            </div>
            
            <div>
              <strong>解决方案:</strong>
              <ul style="margin: 5px 0; padding-left: 20px;">
                ${issue.solutions.map(solution => `<li>${solution}</li>`).join('')}
              </ul>
            </div>
          </div>
        `;
      }
      html += '</div>';
    }
    
    if (doc.steps) {
      // 显示调试指南
      html += '<div>';
      for (const step of doc.steps) {
        html += `
          <div style="margin-bottom: 15px; border-bottom: 1px solid #444; padding-bottom: 10px;">
            <h5 style="margin-top: 0; color: #6cf;">${step.title}</h5>
            <p style="margin-bottom: 5px;">${step.description}</p>
            <ul style="margin: 5px 0; padding-left: 20px;">
              ${step.actions.map(action => `<li>${action}</li>`).join('')}
            </ul>
          </div>
        `;
      }
      html += '</div>';
    }
    
    contentContainer.innerHTML = html;
  }

  // 添加调试工具
  addDebugTool(level, id, tool) {
    if (!this.debugTools.has(level)) {
      this.debugTools.set(level, new Map());
    }
    
    this.debugTools.get(level).set(id, tool);
  }

  // 添加调试文档
  addDebuggingDoc(id, doc) {
    this.debuggingDocs.set(id, doc);
  }

  // 记录日志
  log(level, message, data = {}) {
    if (!this.logLevels.includes(level)) {
      throw new Error(`无效的日志级别: ${level}`);
    }
    
    const logEntry = {
      level,
      message,
      data,
      timestamp: Date.now(),
      microFrontendId: this.getCurrentMicroFrontendId()
    };
    
    this.logs.push(logEntry);
    
    // 限制日志数量
    if (this.logs.length > this.config.maxLogEntries) {
      this.logs.shift();
    }
    
    // 更新日志显示
    this.updateLogDisplay();
    
    // 使用格式化器输出到控制台
    if (this.config.enableVerboseLogging || level === 'error' || level === 'fatal') {
      const formatter = this.logFormatters.get('console');
      if (formatter) {
        console.log(formatter.format(logEntry), formatter.getStyle(logEntry));
      }
    }
  }

  // 更新日志显示
  updateLogDisplay() {
    if (!this.debugPanel) {
      return;
    }
    
    const logContainer = document.getElementById('log-container');
    if (!logContainer) {
      return;
    }
    
    const filterValue = document.getElementById('log-level-filter')?.value || 'all';
    
    let html = '';
    
    // 过滤日志
    const filteredLogs = filterValue === 'all' 
      ? this.logs 
      : this.logs.filter(log => log.level === filterValue);
    
    // 显示最近的日志
    const recentLogs = filteredLogs.slice(-100).reverse();
    
    for (const log of recentLogs) {
      const time = new Date(log.timestamp).toLocaleTimeString();
      const color = getLogLevelColor(log.level);
      
      html += `<div style="margin-bottom: 3px; color: ${color};">
        <span style="color: #999;">[${time}]</span>
        <span style="color: #ccc;">[${log.microFrontendId}]</span>
        ${log.message}
      </div>`;
    }
    
    logContainer.innerHTML = html;
    
    // 滚动到底部
    logContainer.scrollTop = logContainer.scrollHeight;
  }

  // 过滤日志
  filterLogs(level) {
    this.updateLogDisplay();
  }

  // 更新错误显示
  updateErrorDisplay() {
    if (!this.debugPanel || !this.errorTracker) {
      return;
    }
    
    const errorContainer = document.getElementById('error-container');
    if (!errorContainer) {
      return;
    }
    
    const errors = this.errorTracker.getErrors();
    
    let html = '';
    
    // 显示最近的错误
    const recentErrors = errors.slice(-20).reverse();
    
    for (const error of recentErrors) {
      const time = new Date(error.timestamp).toLocaleTimeString();
      
      html += `<div style="margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 5px;">
        <div style="color: #f66; font-weight: bold;">${error.message}</div>
        <div style="color: #999; font-size: 10px;">
          <span>[${time}]</span>
          <span style="margin-left: 5px;">[${error.microFrontendId}]</span>
        </div>
        ${error.stack ? `<pre style="font-size: 10px; margin: 5px 0; color: #ccc;">${error.stack}</pre>` : ''}
      </div>`;
    }
    
    errorContainer.innerHTML = html;
  }

  // 获取当前微应用ID
  getCurrentMicroFrontendId() {
    // 实现获取当前微应用ID的逻辑
    return window.__MICRO_FRONTEND_ID__ || 'unknown';
  }

  // 辅助方法
  debug(...args) {
    this.log('debug', args.join(' '));
  }

  info(...args) {
    this.log('info', args.join(' '));
  }

  warn(...args) {
    this.log('warn', args.join(' '));
  }

  error(...args) {
    this.log('error', args.join(' '));
  }

  fatal(...args) {
    this.log('fatal', args.join(' '));
  }
}

// 辅助函数
function getResourceType(url) {
  if (url.match(/\.js$/)) {
    return 'script';
  } else if (url.match(/\.css$/)) {
    return 'stylesheet';
  } else if (url.match(/\.(png|jpg|jpeg|gif|webp|svg)$/)) {
    return 'image';
  } else if (url.match(/\.(woff|woff2|ttf|eot)$/)) {
    return 'font';
  } else {
    return 'other';
  }
}

function getSelector(element) {
  if (!element) return '';
  
  if (element.id) {
    return `#${element.id}`;
  }
  
  if (element.dataset && element.dataset.testid) {
    return `[data-testid="${element.dataset.testid}"]`;
  }
  
  let path = [];
  let current = element;
  
  while (current && current.nodeType === Node.ELEMENT_NODE) {
    let selector = current.nodeName.toLowerCase();
    
    if (current.className) {
      selector += '.' + current.className.split(' ').join('.');
    }
    
    path.unshift(selector);
    current = current.parentNode;
    
    if (path.length >= 5) {
      break;
    }
  }
  
  return path.join(' > ');
}

function getLogLevelColor(level) {
  switch (level) {
    case 'debug': return '#999';
    case 'info': return '#6cf';
    case 'warn': return '#fc6';
    case 'error': return '#f66';
    case 'fatal': return '#f00';
    default: return '#ccc';
  }
}

// 使用示例
const debuggingBestPractices = new MicroFrontendDebuggingBestPractices();
debuggingBestPractices.initialize();

// 添加调试API到全局对象
window.__MICRO_FRONTEND_DEBUGGING__ = debuggingBestPractices;

// 提供便捷方法
window.debugMicroFrontend = {
  debug: (...args) => debuggingBestPractices.debug(...args),
  info: (...args) => debuggingBestPractices.info(...args),
  warn: (...args) => debuggingBestPractices.warn(...args),
  error: (...args) => debuggingBestPractices.error(...args),
  fatal: (...args) => debuggingBestPractices.fatal(...args),
  
  getDebugTool: (level, id) => {
    const tools = debuggingBestPractices.debugTools.get(level);
    return tools ? tools.get(id) : null;
  },
  
  getErrors: () => debuggingBestPractices.errorTracker.getErrors(),
  
  getLogs: () => debuggingBestPractices.logs
};
```

## 9.5 总结

### 9.5.1 监控与调试的重要性

微前端架构的复杂性使得监控与调试变得尤为重要。通过有效的监控与调试，可以：

1. **及时发现问题**：快速发现并定位微前端应用中的问题
2. **优化性能**：持续监控和优化微前端应用的性能
3. **提升用户体验**：确保用户获得一致且高质量的体验
4. **降低维护成本**：减少问题排查和修复的时间成本

### 9.5.2 监控与调试的关键要素

1. **分层监控**：从基础设施到业务层面的全面监控
2. **数据采集**：高效、准确的数据采集策略
3. **上下文丰富**：为监控数据添加丰富的上下文信息
4. **可视化展示**：直观的数据可视化，便于快速了解系统状态
5. **自动化告警**：设置合理的告警阈值，实现自动化告警

### 9.5.3 最佳实践总结

1. **监控最佳实践**：
   - 实施分层监控策略
   - 优先监控关键业务指标
   - 为监控数据添加丰富的上下文信息
   - 设置合理的告警阈值
   - 提供直观的数据可视化

2. **调试最佳实践**：
   - 实施分层调试策略
   - 建立标准化的日志格式和级别
   - 提供完整的调试工具链
   - 实现完整的错误追踪链路
   - 提供详细的调试文档和常见问题解决方案

通过实施这些监控与调试策略和最佳实践，可以显著提高微前端应用的稳定性、性能和可维护性，为用户提供更好的体验。