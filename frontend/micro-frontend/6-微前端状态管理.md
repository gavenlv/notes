# 第六章：微前端状态管理

## 6.1 状态管理概述

在微前端架构中，状态管理是一个复杂但至关重要的话题。与单体应用不同，微前端应用的状态分布在多个独立的应用中，需要特殊的机制来协调和同步这些状态。

### 6.1.1 微前端状态管理的挑战

1. **状态隔离**：每个微应用需要维护自己的状态，同时避免与其他应用的状态冲突
2. **状态共享**：某些状态需要在多个微应用间共享，如用户信息、主题设置等
3. **状态同步**：当共享状态发生变化时，需要及时通知所有相关应用
4. **状态持久化**：确保状态在页面刷新或应用切换后能够恢复
5. **性能优化**：避免不必要的状态更新和重复渲染

### 6.1.2 状态分类

在微前端架构中，我们可以将状态分为以下几类：

1. **应用内部状态**：仅在单个微应用内部使用，不需要与其他应用共享
2. **共享全局状态**：需要在多个微应用间共享的状态，如用户信息、权限数据等
3. **会话状态**：与用户会话相关的状态，如登录状态、购物车内容等
4. **临时状态**：短暂的UI状态，如表单输入、弹窗状态等

## 6.2 状态管理方案

### 6.2.1 基于全局变量的状态管理

最简单的状态管理方式是使用全局变量来存储共享状态：

```javascript
// 在主应用中定义全局状态
window.__MF_GLOBAL_STATE__ = {
  user: null,
  theme: 'light',
  language: 'zh-CN'
};

// 提供更新状态的方法
window.__MF_UPDATE_GLOBAL_STATE__ = (key, value) => {
  window.__MF_GLOBAL_STATE__[key] = value;
  // 通知所有微应用状态已更新
  window.dispatchEvent(new CustomEvent('global-state-changed', {
    detail: { key, value }
  }));
};

// 在微应用中访问和更新状态
const user = window.__MF_GLOBAL_STATE__.user;
window.__MF_UPDATE_GLOBAL_STATE__('user', newUser);
```

**优点**：
- 实现简单，无需额外依赖
- 所有应用都可以直接访问

**缺点**：
- 缺乏类型检查和约束
- 状态变更难以追踪和调试
- 容易出现命名冲突

### 6.2.2 基于事件的状态管理

通过自定义事件机制实现状态同步：

```javascript
// 定义状态管理器
class StateManager {
  constructor() {
    this.state = {};
    this.listeners = {};
  }
  
  setState(key, value) {
    const oldValue = this.state[key];
    this.state[key] = value;
    
    // 通知所有监听者
    if (this.listeners[key]) {
      this.listeners[key].forEach(callback => {
        callback(value, oldValue);
      });
    }
    
    // 触发自定义事件
    window.dispatchEvent(new CustomEvent('state-changed', {
      detail: { key, value, oldValue }
    }));
  }
  
  getState(key) {
    return this.state[key];
  }
  
  subscribe(key, callback) {
    if (!this.listeners[key]) {
      this.listeners[key] = [];
    }
    this.listeners[key].push(callback);
    
    // 返回取消订阅函数
    return () => {
      this.listeners[key] = this.listeners[key].filter(cb => cb !== callback);
    };
  }
}

// 创建全局状态管理器实例
window.__MF_STATE_MANAGER__ = new StateManager();

// 在微应用中使用
class UserComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      user: window.__MF_STATE_MANAGER__.getState('user') || null
    };
    
    // 订阅状态变化
    this.unsubscribe = window.__MF_STATE_MANAGER__.subscribe('user', (user) => {
      this.setState({ user });
    });
  }
  
  componentWillUnmount() {
    // 取消订阅
    this.unsubscribe();
  }
  
  handleLogin = (userData) => {
    window.__MF_STATE_MANAGER__.setState('user', userData);
  };
  
  render() {
    const { user } = this.state;
    return (
      <div>
        {user ? <div>欢迎, {user.name}</div> : <button onClick={this.handleLogin}>登录</button>}
      </div>
    );
  }
}
```

**优点**：
- 实现了观察者模式，状态变化可以自动通知
- 支持订阅/取消订阅机制
- 可以追踪状态变化历史

**缺点**：
- 需要手动管理订阅和取消订阅
- 复杂状态逻辑处理起来较为困难

### 6.2.3 基于Redux的状态管理

使用Redux等状态管理库来管理微前端的全局状态：

```javascript
// 在主应用中创建Redux store
import { createStore, combineReducers } from 'redux';

// 定义全局状态reducer
const globalReducer = combineReducers({
  user: (state = null, action) => {
    switch (action.type) {
      case 'SET_USER':
        return action.payload;
      case 'CLEAR_USER':
        return null;
      default:
        return state;
    }
  },
  theme: (state = 'light', action) => {
    switch (action.type) {
      case 'SET_THEME':
        return action.payload;
      default:
        return state;
    }
  }
});

// 创建store
const store = createStore(globalReducer);

// 将store暴露到全局
window.__MF_STORE__ = store;

// 在微应用中使用Redux
import { Provider, connect } from 'react-redux';

// 创建容器组件
const UserContainer = connect(
  state => ({ user: state.user }),
  dispatch => ({
    setUser: (user) => dispatch({ type: 'SET_USER', payload: user }),
    clearUser: () => dispatch({ type: 'CLEAR_USER' })
  })
)(({ user, setUser, clearUser }) => (
  <div>
    {user ? (
      <div>
        欢迎, {user.name}
        <button onClick={clearUser}>退出</button>
      </div>
    ) : (
      <button onClick={() => setUser({ name: 'John' })}>登录</button>
    )}
  </div>
));

// 在微应用根组件中使用Provider
const App = () => (
  <Provider store={window.__MF_STORE__}>
    <UserContainer />
  </Provider>
);
```

**优点**：
- 成熟的状态管理方案，有丰富的生态系统
- 支持时间旅行调试
- 严格的单向数据流，状态变更可预测

**缺点**：
- 增加了应用复杂度和学习成本
- 需要确保所有应用使用相同版本的Redux
- 可能在某些场景下显得过于重量级

### 6.2.4 基于qiankun的全局状态

qiankun框架提供了内置的全局状态管理机制：

```javascript
// 在主应用中设置全局状态
import { initGlobalState } from 'qiankun';

// 初始化全局状态
const actions = initGlobalState({
  user: null,
  theme: 'light',
  language: 'zh-CN'
});

// 监听全局状态变化
actions.onGlobalStateChange((state, prev) => {
  console.log('全局状态变化:', state, prev);
});

// 在微应用中使用全局状态
export async function mount(props) {
  const { onGlobalStateChange, setGlobalState } = props;
  
  // 监听全局状态变化
  const offGlobalStateChange = onGlobalStateChange((state, prev) => {
    console.log('微应用接收到全局状态变化:', state, prev);
    // 更新组件状态
    store.dispatch({ type: 'UPDATE_GLOBAL_STATE', payload: state });
  });
  
  // 获取当前全局状态
  const { user, theme } = props.getGlobalState();
  
  // 设置全局状态
  setGlobalState({ user: { name: 'John' } });
  
  // 渲染应用
  render(props);
}

export async function unmount(props) {
  // 卸载应用
  const { container } = props;
  ReactDOM.unmountComponentAtNode(container ? container.querySelector('#root') : document.querySelector('#root'));
}
```

**优点**：
- qiankun内置支持，无需额外引入
- 与微前端生命周期无缝集成
- 提供了完整的API，包括获取、设置和监听状态

**缺点**：
- 仅适用于qiankun框架
- 状态管理功能相对简单，复杂场景可能不够用

## 6.3 状态隔离策略

在微前端架构中，状态隔离是确保各应用独立运行的关键。以下是几种常见的状态隔离策略：

### 6.3.1 命名空间隔离

通过命名空间来避免状态冲突：

```javascript
// 为每个微应用分配独立的命名空间
window.__MF_APP_STATES__ = {
  'react-app': {
    counter: 0,
    user: null
  },
  'vue-app': {
    products: [],
    cart: []
  }
};

// 提供访问器函数
function getAppState(appName) {
  return window.__MF_APP_STATES__[appName] || {};
}

function setAppState(appName, state) {
  window.__MF_APP_STATES__[appName] = { ...getAppState(appName), ...state };
}

// 在微应用中使用
const reactAppState = getAppState('react-app');
setAppState('react-app', { counter: reactAppState.counter + 1 });
```

### 6.3.2 作用域隔离

通过作用域链来隔离状态：

```javascript
// 使用IIFE创建独立作用域
(function() {
  // 微应用私有状态
  let privateState = {
    counter: 0,
    user: null
  };
  
  // 暴露公共接口
  window.ReactApp = {
    getState: () => ({ ...privateState }),
    setState: (newState) => {
      privateState = { ...privateState, ...newState };
      // 触发内部更新
      updateUI();
    },
    init: () => {
      // 初始化应用
      console.log('React应用初始化');
    }
  };
})();

// 在微应用内部访问
window.ReactApp.setState({ counter: 1 });
const currentState = window.ReactApp.getState();
```

### 6.3.3 沙箱隔离

利用沙箱机制实现状态隔离：

```javascript
// 创建沙箱环境
function createSandbox(appName) {
  const sandbox = {
    name: appName,
    state: {},
    originalWindow: window
  };
  
  // 创建代理对象
  const proxyWindow = new Proxy(window, {
    get(target, prop) {
      // 访问全局状态时重定向到沙箱状态
      if (prop === '__STATE__') {
        return sandbox.state;
      }
      return target[prop];
    },
    set(target, prop, value) {
      // 设置全局状态时保存到沙箱状态
      if (prop === '__STATE__') {
        sandbox.state = value;
        return true;
      }
      target[prop] = value;
      return true;
    }
  });
  
  sandbox.window = proxyWindow;
  return sandbox;
}

// 在微应用中使用沙箱
const reactSandbox = createSandbox('react-app');

// 在沙箱环境中执行代码
function executeInSandbox(sandbox, code) {
  const { window } = sandbox;
  const func = new Function('window', code);
  return func(window);
}

// 执行微应用代码
executeInSandbox(reactSandbox, `
  window.__STATE__.counter = 0;
  console.log('沙箱中的状态:', window.__STATE__);
`);
```

## 6.4 状态同步机制

### 6.4.1 发布-订阅模式

使用发布-订阅模式实现状态同步：

```javascript
// 创建事件总线
class EventBus {
  constructor() {
    this.events = {};
  }
  
  // 订阅事件
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(callback);
    
    // 返回取消订阅函数
    return () => {
      this.events[eventName] = this.events[eventName].filter(cb => cb !== callback);
    };
  }
  
  // 发布事件
  emit(eventName, data) {
    if (this.events[eventName]) {
      this.events[eventName].forEach(callback => callback(data));
    }
  }
  
  // 取消所有订阅
  off(eventName) {
    if (eventName) {
      delete this.events[eventName];
    } else {
      this.events = {};
    }
  }
}

// 创建全局事件总线
window.__MF_EVENT_BUS__ = new EventBus();

// 在微应用中使用事件总线
class ProductList extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      products: []
    };
    
    // 订阅产品更新事件
    this.unsubscribe = window.__MF_EVENT_BUS__.on('product-updated', (product) => {
      this.setState(prevState => ({
        products: prevState.products.map(p => 
          p.id === product.id ? product : p
        )
      }));
    });
  }
  
  componentWillUnmount() {
    // 取消订阅
    this.unsubscribe();
  }
  
  handleUpdateProduct = (product) => {
    // 发布产品更新事件
    window.__MF_EVENT_BUS__.emit('product-updated', product);
  };
  
  render() {
    const { products } = this.state;
    return (
      <div>
        {products.map(product => (
          <div key={product.id}>
            <h3>{product.name}</h3>
            <button onClick={() => this.handleUpdateProduct({...product, price: product.price + 10})}>
              更新价格
            </button>
          </div>
        ))}
      </div>
    );
  }
}
```

### 6.4.2 状态快照与恢复

通过状态快照机制实现状态持久化和恢复：

```javascript
// 状态快照管理器
class StateSnapshotManager {
  constructor() {
    this.snapshots = {};
    this.maxSnapshots = 10;
  }
  
  // 保存状态快照
  saveSnapshot(key, state) {
    const timestamp = Date.now();
    this.snapshots[key] = {
      timestamp,
      state: JSON.parse(JSON.stringify(state)) // 深拷贝
    };
    
    // 限制快照数量
    const keys = Object.keys(this.snapshots);
    if (keys.length > this.maxSnapshots) {
      const oldestKey = keys.reduce((oldest, current) => 
        this.snapshots[oldest].timestamp < this.snapshots[current].timestamp ? oldest : current
      );
      delete this.snapshots[oldestKey];
    }
  }
  
  // 恢复状态快照
  restoreSnapshot(key) {
    if (this.snapshots[key]) {
      return JSON.parse(JSON.stringify(this.snapshots[key].state));
    }
    return null;
  }
  
  // 获取所有快照
  getAllSnapshots() {
    return { ...this.snapshots };
  }
  
  // 清除所有快照
  clearSnapshots() {
    this.snapshots = {};
  }
}

// 创建全局状态快照管理器
window.__MF_SNAPSHOT_MANAGER__ = new StateSnapshotManager();

// 在微应用中使用状态快照
class ShoppingCart extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      items: []
    };
    
    // 尝试恢复状态快照
    const savedState = window.__MF_SNAPSHOT_MANAGER__.restoreSnapshot('shopping-cart');
    if (savedState) {
      this.state = savedState;
    }
  }
  
  componentDidUpdate() {
    // 保存状态快照
    window.__MF_SNAPSHOT_MANAGER__.saveSnapshot('shopping-cart', this.state);
  }
  
  addItem = (item) => {
    this.setState(prevState => ({
      items: [...prevState.items, item]
    }));
  };
  
  render() {
    const { items } = this.state;
    return (
      <div>
        <h2>购物车 ({items.length})</h2>
        <button onClick={() => this.addItem({ id: Date.now(), name: '商品' })}>
          添加商品
        </button>
        <ul>
          {items.map(item => (
            <li key={item.id}>{item.name}</li>
          ))}
        </ul>
      </div>
    );
  }
}
```

### 6.4.3 跨应用状态同步

实现跨应用的状态同步机制：

```javascript
// 跨应用状态同步器
class CrossAppStateSync {
  constructor() {
    this.appStates = {};
    this.syncRules = new Map();
    this.eventBus = new EventBus();
  }
  
  // 注册应用状态
  registerApp(appName, initialState) {
    this.appStates[appName] = initialState;
    
    // 监听状态变化
    this.eventBus.on(`${appName}-state-changed`, (newState) => {
      this.appStates[appName] = { ...this.appStates[appName], ...newState };
      this.syncState(appName, newState);
    });
  }
  
  // 添加同步规则
  addSyncRule(sourceApp, sourceKey, targetApp, targetKey, transform) {
    const ruleId = `${sourceApp}-${sourceKey}-${targetApp}-${targetKey}`;
    this.syncRules.set(ruleId, {
      sourceApp,
      sourceKey,
      targetApp,
      targetKey,
      transform: transform || (value => value)
    });
  }
  
  // 同步状态
  syncState(sourceApp, changedState) {
    this.syncRules.forEach(rule => {
      if (rule.sourceApp === sourceApp && changedState.hasOwnProperty(rule.sourceKey)) {
        const transformedValue = rule.transform(changedState[rule.sourceKey]);
        
        // 发送状态变化事件到目标应用
        this.eventBus.emit(`${rule.targetApp}-sync-state`, {
          [rule.targetKey]: transformedValue
        });
      }
    });
  }
  
  // 更新应用状态
  updateAppState(appName, newState) {
    this.eventBus.emit(`${appName}-state-changed`, newState);
  }
  
  // 获取应用状态
  getAppState(appName) {
    return this.appStates[appName] || {};
  }
}

// 创建全局状态同步器
window.__MF_STATE_SYNC__ = new CrossAppStateSync();

// 在主应用中注册应用和同步规则
window.__MF_STATE_SYNC__.registerApp('user-app', { user: null });
window.__MF_STATE_SYNC__.registerApp('cart-app', { items: [], userId: null });

// 同步用户ID到购物车应用
window.__MF_STATE_SYNC__.addSyncRule('user-app', 'user', 'cart-app', 'userId', (user) => {
  return user ? user.id : null;
});

// 在用户应用中
window.__MF_STATE_SYNC__.updateAppState('user-app', { user: { id: 123, name: 'John' } });

// 在购物车应用中
window.__MF_EVENT_BUS__.on('cart-app-sync-state', (state) => {
  if (state.userId !== undefined) {
    console.log('购物车应用接收到用户ID:', state.userId);
    // 更新购物车状态
    setCartState(prevState => ({ ...prevState, userId: state.userId }));
  }
});
```

## 6.5 状态管理最佳实践

### 6.5.1 状态设计原则

1. **最小化共享状态**：只在必要时共享状态，尽量减少应用间的耦合
2. **明确状态所有权**：每个状态应该有明确的所有者，负责维护和更新
3. **单向数据流**：保持数据流的单向性，避免循环依赖
4. **不可变状态**：使用不可变数据结构，便于追踪变化和优化性能
5. **状态规范化**：避免冗余数据，保持状态的规范化结构

### 6.5.2 性能优化

1. **状态分片**：将大状态拆分为小状态，按需更新
2. **状态缓存**：缓存计算结果，避免重复计算
3. **延迟加载**：延迟加载非关键状态，减少初始加载时间
4. **批量更新**：合并多个状态更新，减少渲染次数

```javascript
// 状态分片示例
const useUserState = () => {
  const [user, setUser] = useState(null);
  const [permissions, setPermissions] = useState([]);
  
  return { user, setUser, permissions, setPermissions };
};

const useCartState = () => {
  const [items, setItems] = useState([]);
  const [total, setTotal] = useState(0);
  
  // 计算总价
  useEffect(() => {
    const newTotal = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
    setTotal(newTotal);
  }, [items]);
  
  return { items, setItems, total };
};

// 批量更新示例
const batchUpdate = (updates) => {
  updates.forEach(({ state, setState, value }) => {
    setState(value);
  });
};
```

### 6.5.3 错误处理

1. **状态验证**：验证状态数据的合法性
2. **错误边界**：使用错误边界捕获状态更新中的错误
3. **降级策略**：在状态管理失败时提供降级方案
4. **状态恢复**：在错误发生后恢复到稳定状态

```javascript
// 状态验证示例
const validateUser = (user) => {
  if (!user) return null;
  
  if (!user.id || typeof user.id !== 'string') {
    console.error('无效的用户ID');
    return null;
  }
  
  if (!user.name || typeof user.name !== 'string') {
    console.error('无效的用户名');
    return null;
  }
  
  return user;
};

// 错误边界示例
class StateErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, info) {
    console.error('状态管理错误:', error, info);
    
    // 尝试恢复状态
    try {
      const lastValidState = localStorage.getItem('lastValidState');
      if (lastValidState) {
        this.props.restoreState(JSON.parse(lastValidState));
      }
    } catch (e) {
      console.error('状态恢复失败:', e);
    }
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h2>状态管理出错</h2>
          <p>正在尝试恢复...</p>
          <button onClick={() => this.setState({ hasError: false, error: null })}>
            重试
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}
```

## 6.6 状态管理工具选择

### 6.6.1 工具对比

| 工具 | 适用场景 | 优点 | 缺点 |
|------|----------|------|------|
| 全局变量 | 简单场景 | 实现简单，无依赖 | 缺乏约束，难以维护 |
| 自定义事件 | 中等复杂度 | 灵活性高，易于理解 | 需要手动管理，功能有限 |
| Redux/Zustand | 复杂应用 | 功能强大，生态丰富 | 学习成本高，增加复杂度 |
| qiankun全局状态 | qiankun框架 | 内置支持，无缝集成 | 仅适用于qiankun |
| RxJS | 实时数据流 | 强大的异步处理能力 | 学习曲线陡峭 |

### 6.6.2 选择建议

1. **小型项目**：使用全局变量或自定义事件，保持简单
2. **中型项目**：考虑使用轻量级状态管理库如Zustand
3. **大型项目**：使用Redux等成熟方案，配合中间件处理复杂逻辑
4. **qiankun项目**：优先使用qiankun内置的全局状态管理
5. **实时数据场景**：考虑使用RxJS处理数据流

## 6.7 本章小结

本章详细介绍了微前端架构中的状态管理问题，包括状态管理的挑战、各种实现方案、状态隔离策略、状态同步机制以及最佳实践。我们通过实际代码示例展示了如何在不同场景下实现状态管理，并提供了工具选择建议。

状态管理是微前端架构中的核心问题，合理的状态管理方案可以显著提高应用的可维护性和可扩展性。在实际项目中，需要根据应用规模、团队技术栈和业务需求来选择合适的状态管理方案。

在下一章中，我们将学习微前端路由管理的相关知识，了解如何在微前端架构中实现统一的路由管理和导航。

## 6.8 思考题

1. 微前端状态管理面临哪些主要挑战？
2. 如何实现跨应用的状态同步？
3. 在微前端架构中，如何平衡状态隔离和状态共享？

## 6.9 示例代码

本章的完整示例代码已经保存在 `frontend/micro-frontend/code/chapter6/state-management` 目录中。

### 6.9.1 代码结构

```
state-management/
├── src/
│   ├── main-app/
│   │   ├── index.js
│   │   └── App.js
│   ├── user-app/
│   │   ├── index.js
│   │   └── components/
│   │       ├── UserProfile.js
│   │       └── LoginForm.js
│   ├── cart-app/
│   │   ├── index.js
│   │   └── components/
│   │       ├── Cart.js
│   │       └── ProductList.js
│   ├── shared/
│   │   ├── StateManager.js
│   │   ├── EventBus.js
│   │   └── CrossAppStateSync.js
│   └── index.html
├── package.json
└── webpack.config.js
```

### 6.9.2 运行示例

1. 进入示例代码目录：
```bash
cd frontend/micro-frontend/code/chapter6/state-management
```

2. 安装依赖：
```bash
npm install
```

3. 启动开发服务器：
```bash
npm start
```

4. 在浏览器中打开 http://localhost:9006

### 6.9.3 示例功能说明

- 主应用负责状态管理器的初始化和应用注册
- 用户应用展示用户登录状态和个人信息
- 购物车应用展示商品列表和购物车功能
- 两个应用通过全局状态管理器共享用户状态
- 演示了状态同步、状态隔离和错误处理等机制

### 6.9.4 路由说明

- `/` - 主页面
- `/user` - 用户应用
- `/cart` - 购物车应用

## 6.10 参考资料

1. Redux官方文档：https://redux.js.org/
2. Zustand文档：https://github.com/pmndrs/zustand
3. qiankun全局状态管理：https://qiankun.umijs.org/zh/guide/global-state
4. 微前端状态管理最佳实践：https://micro-frontends.org/