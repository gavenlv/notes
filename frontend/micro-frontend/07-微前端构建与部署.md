# 第七章：微前端构建与部署

## 7.1 微前端构建概述

### 7.1.1 构建挑战

微前端架构的构建过程相比传统单体应用面临更多挑战：

1. **多项目构建**：需要同时构建多个独立的前端应用
2. **依赖管理**：各应用之间可能存在共享依赖，需要合理管理
3. **构建效率**：如何提高多应用构建速度，减少构建时间
4. **环境一致性**：确保各应用在不同环境中的一致性
5. **版本控制**：管理各应用版本及它们之间的兼容性
6. **资源优化**：优化资源加载，减少重复资源

### 7.1.2 构建流程

微前端构建流程通常包括以下阶段：

1. **代码编译**：将源代码转换为浏览器可执行的代码
2. **依赖处理**：解析和处理模块依赖关系
3. **资源打包**：将代码和资源打包成可部署的文件
4. **代码分割**：按需分割代码，实现懒加载
5. **资源优化**：压缩、混淆、优化资源
6. **环境配置**：根据不同环境配置不同的构建参数

```javascript
// 微前端构建流程示例
class MicroFrontendBuilder {
  constructor(config) {
    this.config = {
      apps: [], // 应用列表
      sharedDeps: {}, // 共享依赖
      buildMode: 'development', // 构建模式
      outputPath: 'dist', // 输出目录
      publicPath: '/', // 公共路径
      ...config
    };
    
    this.buildResults = new Map();
  }
  
  // 构建所有应用
  async buildAll() {
    console.log('开始构建所有微前端应用...');
    
    // 1. 准备构建环境
    await this.prepareBuildEnvironment();
    
    // 2. 构建共享依赖
    await this.buildSharedDependencies();
    
    // 3. 并行构建各应用
    const buildPromises = this.config.apps.map(app => this.buildApp(app));
    const results = await Promise.allSettled(buildPromises);
    
    // 4. 处理构建结果
    this.processBuildResults(results);
    
    // 5. 生成构建报告
    this.generateBuildReport();
    
    console.log('微前端构建完成');
    return this.buildResults;
  }
  
  // 准备构建环境
  async prepareBuildEnvironment() {
    // 创建输出目录
    await fs.ensureDir(this.config.outputPath);
    
    // 清理旧的构建文件
    await fs.emptyDir(this.config.outputPath);
    
    // 创建公共资源目录
    await fs.ensureDir(path.join(this.config.outputPath, 'shared'));
  }
  
  // 构建共享依赖
  async buildSharedDependencies() {
    console.log('构建共享依赖...');
    
    // 提取共享依赖
    const sharedDeps = this.extractSharedDependencies();
    
    // 构建共享依赖包
    for (const [name, version] of Object.entries(sharedDeps)) {
      await this.buildSharedDependency(name, version);
    }
  }
  
  // 提取共享依赖
  extractSharedDependencies() {
    const dependencyMap = new Map();
    
    // 统计各应用的依赖
    this.config.apps.forEach(app => {
      const packageJson = this.readPackageJson(app.path);
      
      Object.entries(packageJson.dependencies || {}).forEach(([name, version]) => {
        if (!dependencyMap.has(name)) {
          dependencyMap.set(name, new Set());
        }
        dependencyMap.get(name).add(version);
      });
    });
    
    // 筛选出被多个应用使用的依赖
    const sharedDeps = {};
    dependencyMap.forEach((versions, name) => {
      if (versions.size > 1) {
        // 选择最常见的版本
        const versionCount = {};
        versions.forEach(v => {
          versionCount[v] = (versionCount[v] || 0) + 1;
        });
        
        const mostCommonVersion = Object.entries(versionCount)
          .sort(([,a], [,b]) => b - a)[0][0];
        
        sharedDeps[name] = mostCommonVersion;
      }
    });
    
    return { ...sharedDeps, ...this.config.sharedDeps };
  }
  
  // 构建单个共享依赖
  async buildSharedDependency(name, version) {
    console.log(`构建共享依赖: ${name}@${version}`);
    
    // 创建临时目录
    const tempDir = path.join(os.tmpdir(), `mf-shared-${name}-${Date.now()}`);
    await fs.ensureDir(tempDir);
    
    try {
      // 创建package.json
      const packageJson = {
        name: `mf-shared-${name}`,
        version: '1.0.0',
        dependencies: {
          [name]: version
        }
      };
      
      await fs.writeJson(path.join(tempDir, 'package.json'), packageJson);
      
      // 创建入口文件
      const entryContent = `
        // 导出共享依赖
        export { default } from '${name}';
        export * from '${name}';
      `;
      
      await fs.writeFile(path.join(tempDir, 'index.js'), entryContent);
      
      // 使用webpack构建
      const webpackConfig = this.createWebpackConfig({
        entry: path.join(tempDir, 'index.js'),
        output: {
          path: path.join(this.config.outputPath, 'shared'),
          filename: `${name}.js`,
          library: {
            name: this.toPascalCase(name),
            type: 'umd'
          }
        },
        externals: {},
        optimization: {
          minimize: this.config.buildMode === 'production'
        }
      });
      
      await this.runWebpack(webpackConfig);
      
      console.log(`共享依赖 ${name} 构建完成`);
    } finally {
      // 清理临时目录
      await fs.remove(tempDir);
    }
  }
  
  // 构建单个应用
  async buildApp(app) {
    console.log(`构建应用: ${app.name}`);
    
    const startTime = Date.now();
    
    try {
      // 创建应用构建配置
      const webpackConfig = this.createAppWebpackConfig(app);
      
      // 运行webpack构建
      const stats = await this.runWebpack(webpackConfig);
      
      // 记录构建结果
      const buildTime = Date.now() - startTime;
      this.buildResults.set(app.name, {
        success: true,
        buildTime,
        stats
      });
      
      console.log(`应用 ${app.name} 构建完成，耗时: ${buildTime}ms`);
      return { app: app.name, success: true, buildTime };
    } catch (error) {
      console.error(`应用 ${app.name} 构建失败:`, error);
      
      // 记录构建失败
      this.buildResults.set(app.name, {
        success: false,
        error: error.message
      });
      
      return { app: app.name, success: false, error: error.message };
    }
  }
  
  // 创建应用webpack配置
  createAppWebpackConfig(app) {
    const sharedDeps = this.extractSharedDependencies();
    
    return {
      name: app.name,
      mode: this.config.buildMode,
      entry: app.entry,
      output: {
        path: path.join(this.config.outputPath, app.name),
        filename: this.config.buildMode === 'production' 
          ? '[name].[contenthash].js' 
          : '[name].js',
        publicPath: this.config.publicPath,
        library: {
          name: app.name,
          type: 'umd'
        }
      },
      externals: Object.keys(sharedDeps).reduce((externals, name) => {
        externals[name] = this.toPascalCase(name);
        return externals;
      }, {}),
      module: {
        rules: [
          {
            test: /\.js$/,
            exclude: /node_modules/,
            use: {
              loader: 'babel-loader',
              options: {
                presets: ['@babel/preset-env'],
                plugins: ['@babel/plugin-transform-runtime']
              }
            }
          },
          {
            test: /\.css$/,
            use: [
              this.config.buildMode === 'production' 
                ? MiniCssExtractPlugin.loader 
                : 'style-loader',
              'css-loader',
              'postcss-loader'
            ]
          },
          {
            test: /\.(png|jpe?g|gif|svg)$/,
            type: 'asset/resource',
            generator: {
              filename: 'images/[name].[hash][ext]'
            }
          }
        ]
      },
      plugins: [
        new HtmlWebpackPlugin({
          template: app.template || path.join(__dirname, 'templates', 'app.html'),
          filename: 'index.html',
          inject: 'body',
          minify: this.config.buildMode === 'production' ? {
            removeComments: true,
            collapseWhitespace: true,
            removeRedundantAttributes: true,
            useShortDoctype: true,
            removeEmptyAttributes: true,
            removeStyleLinkTypeAttributes: true,
            keepClosingSlash: true,
            minifyJS: true,
            minifyCSS: true,
            minifyURLs: true
          } : false
        }),
        ...(this.config.buildMode === 'production' ? [
          new MiniCssExtractPlugin({
            filename: '[name].[contenthash].css'
          })
        ] : [])
      ],
      optimization: {
        minimize: this.config.buildMode === 'production',
        splitChunks: {
          chunks: 'all',
          cacheGroups: {
            vendor: {
              test: /[\\/]node_modules[\\/]/,
              name: 'vendors',
              chunks: 'all'
            }
          }
        }
      },
      devtool: this.config.buildMode === 'production' ? 'source-map' : 'eval-source-map'
    };
  }
  
  // 创建webpack配置
  createWebpackConfig(config) {
    return {
      mode: this.config.buildMode,
      ...config,
      module: {
        rules: [
          {
            test: /\.js$/,
            exclude: /node_modules/,
            use: {
              loader: 'babel-loader',
              options: {
                presets: ['@babel/preset-env']
              }
            }
          },
          ...(config.module?.rules || [])
        ]
      },
      plugins: [
        ...(config.plugins || [])
      ],
      optimization: {
        minimize: this.config.buildMode === 'production',
        ...(config.optimization || {})
      }
    };
  }
  
  // 运行webpack
  runWebpack(config) {
    return new Promise((resolve, reject) => {
      const compiler = webpack(config);
      
      compiler.run((err, stats) => {
        if (err) {
          return reject(err);
        }
        
        if (stats.hasErrors()) {
          const info = stats.toJson();
          return reject(new Error(info.errors.join('\n')));
        }
        
        resolve(stats);
      });
    });
  }
  
  // 处理构建结果
  processBuildResults(results) {
    console.log('\n构建结果汇总:');
    
    results.forEach((result, index) => {
      const app = this.config.apps[index];
      
      if (result.status === 'fulfilled') {
        const { success, buildTime } = result.value;
        console.log(`✓ ${app.name}: 成功 (${buildTime}ms)`);
      } else {
        console.log(`✗ ${app.name}: 失败`);
        console.error(`  错误: ${result.reason.message}`);
      }
    });
  }
  
  // 生成构建报告
  generateBuildReport() {
    const report = {
      buildTime: new Date().toISOString(),
      mode: this.config.buildMode,
      apps: [],
      sharedDependencies: this.extractSharedDependencies()
    };
    
    this.buildResults.forEach((result, appName) => {
      report.apps.push({
        name: appName,
        success: result.success,
        buildTime: result.buildTime,
        error: result.error
      });
    });
    
    const reportPath = path.join(this.config.outputPath, 'build-report.json');
    fs.writeJson(reportPath, report, { spaces: 2 });
    
    console.log(`\n构建报告已生成: ${reportPath}`);
  }
  
  // 读取package.json
  readPackageJson(appPath) {
    const packageJsonPath = path.join(appPath, 'package.json');
    return fs.readJsonSync(packageJsonPath);
  }
  
  // 转换为PascalCase
  toPascalCase(str) {
    return str.replace(/(^|-)(\w)/g, (match, dash, letter) => letter.toUpperCase());
  }
}

// 使用示例
const builder = new MicroFrontendBuilder({
  apps: [
    {
      name: 'dashboard',
      path: './apps/dashboard',
      entry: './apps/dashboard/src/index.js',
      template: './apps/dashboard/public/index.html'
    },
    {
      name: 'settings',
      path: './apps/settings',
      entry: './apps/settings/src/index.js'
    }
  ],
  buildMode: 'production',
  outputPath: './dist',
  publicPath: '/',
  sharedDeps: {
    'react': '^17.0.0',
    'react-dom': '^17.0.0'
  }
});

// 构建所有应用
builder.buildAll().then(results => {
  console.log('构建完成');
}).catch(error => {
  console.error('构建失败:', error);
});
```

## 7.2 微前端构建工具

### 7.2.1 Webpack配置

Webpack是微前端构建的核心工具，通过合理的配置可以实现高效的构建流程：

```javascript
// 微前端Webpack基础配置
const path = require('path');
const { ModuleFederationPlugin } = require('@module-federation/webpack');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const deps = require('./package.json').dependencies;

module.exports = (env, argv) => {
  const isProduction = argv.mode === 'production';
  
  return {
    mode: isProduction ? 'production' : 'development',
    entry: './src/index.js',
    output: {
      path: path.resolve(__dirname, 'dist'),
      filename: isProduction ? '[name].[contenthash].js' : '[name].js',
      publicPath: 'auto',
      clean: true
    },
    resolve: {
      extensions: ['.js', '.jsx', '.ts', '.tsx', '.json']
    },
    module: {
      rules: [
        {
          test: /\.(js|jsx|ts|tsx)$/,
          exclude: /node_modules/,
          use: {
            loader: 'babel-loader',
            options: {
              presets: [
                '@babel/preset-env',
                '@babel/preset-react',
                '@babel/preset-typescript'
              ],
              plugins: [
                '@babel/plugin-transform-runtime'
              ]
            }
          }
        },
        {
          test: /\.css$/,
          use: [
            isProduction ? MiniCssExtractPlugin.loader : 'style-loader',
            'css-loader',
            'postcss-loader'
          ]
        },
        {
          test: /\.(png|jpe?g|gif|svg|ico)$/,
          type: 'asset/resource',
          generator: {
            filename: 'images/[name].[hash][ext]'
          }
        },
        {
          test: /\.(woff|woff2|eot|ttf|otf)$/,
          type: 'asset/resource',
          generator: {
            filename: 'fonts/[name].[hash][ext]'
          }
        }
      ]
    },
    plugins: [
      new CleanWebpackPlugin(),
      new ModuleFederationPlugin({
        name: 'microApp',
        filename: 'remoteEntry.js',
        exposes: {
          './App': './src/App'
        },
        shared: {
          ...deps,
          react: {
            singleton: true,
            requiredVersion: deps.react
          },
          'react-dom': {
            singleton: true,
            requiredVersion: deps['react-dom']
          }
        }
      }),
      new HtmlWebpackPlugin({
        template: './public/index.html',
        filename: 'index.html',
        inject: 'body',
        minify: isProduction ? {
          removeComments: true,
          collapseWhitespace: true,
          removeRedundantAttributes: true,
          useShortDoctype: true,
          removeEmptyAttributes: true,
          removeStyleLinkTypeAttributes: true,
          keepClosingSlash: true,
          minifyJS: true,
          minifyCSS: true,
          minifyURLs: true
        } : false
      }),
      ...(isProduction ? [
        new MiniCssExtractPlugin({
          filename: '[name].[contenthash].css'
        })
      ] : [])
    ],
    optimization: {
      minimize: isProduction,
      splitChunks: {
        chunks: 'all',
        cacheGroups: {
          vendor: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            chunks: 'all'
          }
        }
      }
    },
    devtool: isProduction ? 'source-map' : 'eval-source-map',
    devServer: {
      port: 3001,
      historyApiFallback: true,
      hot: true,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, PATCH, OPTIONS',
        'Access-Control-Allow-Headers': 'X-Requested-With, content-type, Authorization'
      }
    }
  };
};
```

### 7.2.2 Vite配置

Vite是新一代前端构建工具，提供了更快的开发体验和构建速度：

```javascript
// 微前端Vite配置
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { vitePluginForArco } from '@arco-plugins/vite-react';
import federation from '@originjs/vite-plugin-federation';

export default defineConfig({
  plugins: [
    react(),
    vitePluginForArco({
      style: 'css'
    }),
    federation({
      name: 'microApp',
      filename: 'remoteEntry.js',
      exposes: {
        './App': './src/App'
      },
      shared: ['react', 'react-dom', 'arco-design']
    })
  ],
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    sourcemap: true,
    rollupOptions: {
      output: {
        manualChunks: {
          'vendor': ['react', 'react-dom'],
          'arco': ['@arco-design/web-react']
        }
      }
    },
    chunkSizeWarningLimit: 1000
  },
  server: {
    port: 3001,
    cors: true,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, PATCH, OPTIONS',
      'Access-Control-Allow-Headers': 'X-Requested-With, content-type, Authorization'
    }
  },
  preview: {
    port: 3001,
    cors: true
  },
  css: {
    preprocessorOptions: {
      less: {
        javascriptEnabled: true
      }
    }
  },
  resolve: {
    alias: {
      '@': '/src'
    }
  }
});
```

### 7.2.3 构建工具对比

| 特性 | Webpack | Vite | Rollup | Parcel |
|------|---------|------|--------|--------|
| 启动速度 | 慢 | 快 | 中 | 快 |
| 热更新 | 中 | 快 | 中 | 快 |
| 构建速度 | 中 | 快 | 快 | 中 |
| 配置复杂度 | 高 | 低 | 中 | 低 |
| 生态丰富度 | 高 | 中 | 中 | 低 |
| 微前端支持 | 好 | 好 | 中 | 中 |

## 7.3 微前端部署策略

### 7.3.1 独立部署

独立部署是微前端的核心特性之一，每个微应用可以独立部署，不受其他应用影响：

```javascript
// 微前端独立部署脚本
const fs = require('fs-extra');
const path = require('path');
const axios = require('axios');
const FormData = require('form-data');

class MicroFrontendDeployer {
  constructor(config) {
    this.config = {
      apps: [],
      deploymentServer: '',
      credentials: {},
      rollbackEnabled: true,
      healthCheckEnabled: true,
      ...config
    };
    
    this.deploymentResults = new Map();
  }
  
  // 部署所有应用
  async deployAll(apps = null) {
    const appsToDeploy = apps || this.config.apps;
    console.log('开始部署微前端应用...');
    
    // 1. 验证部署环境
    await this.validateDeploymentEnvironment();
    
    // 2. 并行部署各应用
    const deployPromises = appsToDeploy.map(app => this.deployApp(app));
    const results = await Promise.allSettled(deployPromises);
    
    // 3. 处理部署结果
    this.processDeploymentResults(results);
    
    // 4. 生成部署报告
    this.generateDeploymentReport();
    
    console.log('微前端部署完成');
    return this.deploymentResults;
  }
  
  // 验证部署环境
  async validateDeploymentEnvironment() {
    try {
      // 检查部署服务器连接
      await axios.get(`${this.config.deploymentServer}/health`);
      console.log('部署服务器连接正常');
    } catch (error) {
      throw new Error(`无法连接到部署服务器: ${error.message}`);
    }
    
    // 验证认证信息
    if (!this.config.credentials.token) {
      throw new Error('缺少部署认证令牌');
    }
  }
  
  // 部署单个应用
  async deployApp(app) {
    console.log(`部署应用: ${app.name}`);
    
    const startTime = Date.now();
    
    try {
      // 1. 准备部署文件
      const deployFiles = await this.prepareDeployFiles(app);
      
      // 2. 上传文件
      const uploadResult = await this.uploadFiles(app, deployFiles);
      
      // 3. 执行部署
      const deployResult = await this.executeDeployment(app, uploadResult);
      
      // 4. 健康检查
      if (this.config.healthCheckEnabled) {
        await this.performHealthCheck(app);
      }
      
      // 5. 保存部署历史
      await this.saveDeploymentHistory(app, deployResult);
      
      // 记录部署结果
      const deployTime = Date.now() - startTime;
      this.deploymentResults.set(app.name, {
        success: true,
        deployTime,
        version: app.version,
        deployResult
      });
      
      console.log(`应用 ${app.name} 部署完成，耗时: ${deployTime}ms`);
      return { app: app.name, success: true, deployTime, version: app.version };
    } catch (error) {
      console.error(`应用 ${app.name} 部署失败:`, error);
      
      // 回滚操作
      if (this.config.rollbackEnabled) {
        await this.rollbackApp(app);
      }
      
      // 记录部署失败
      this.deploymentResults.set(app.name, {
        success: false,
        error: error.message
      });
      
      return { app: app.name, success: false, error: error.message };
    }
  }
  
  // 准备部署文件
  async prepareDeployFiles(app) {
    const distPath = path.resolve(app.path, 'dist');
    const tempDir = path.join(os.tmpdir(), `deploy-${app.name}-${Date.now()}`);
    
    // 创建临时目录
    await fs.ensureDir(tempDir);
    
    // 复制构建文件
    await fs.copy(distPath, tempDir);
    
    // 创建部署清单
    const manifest = {
      name: app.name,
      version: app.version,
      deployTime: new Date().toISOString(),
      files: await this.getFileList(tempDir)
    };
    
    await fs.writeJson(path.join(tempDir, 'deploy-manifest.json'), manifest);
    
    return tempDir;
  }
  
  // 获取文件列表
  async getFileList(dir) {
    const files = [];
    
    async function traverse(currentDir) {
      const items = await fs.readdir(currentDir);
      
      for (const item of items) {
        const fullPath = path.join(currentDir, item);
        const stat = await fs.stat(fullPath);
        
        if (stat.isDirectory()) {
          await traverse(fullPath);
        } else {
          const relativePath = path.relative(dir, fullPath);
          files.push({
            path: relativePath,
            size: stat.size,
            hash: await this.calculateFileHash(fullPath)
          });
        }
      }
    }
    
    await traverse(dir);
    return files;
  }
  
  // 计算文件哈希
  async calculateFileHash(filePath) {
    const crypto = require('crypto');
    const content = await fs.readFile(filePath);
    return crypto.createHash('md5').update(content).digest('hex');
  }
  
  // 上传文件
  async uploadFiles(app, deployFiles) {
    const form = new FormData();
    
    // 添加部署文件
    await this.addFilesToForm(form, deployFiles, '');
    
    // 添加应用信息
    form.append('appName', app.name);
    form.append('version', app.version);
    form.append('environment', app.environment || 'production');
    
    try {
      const response = await axios.post(
        `${this.config.deploymentServer}/upload`,
        form,
        {
          headers: {
            ...form.getHeaders(),
            'Authorization': `Bearer ${this.config.credentials.token}`
          },
          maxContentLength: Infinity,
          maxBodyLength: Infinity
        }
      );
      
      return response.data;
    } finally {
      // 清理临时目录
      await fs.remove(deployFiles);
    }
  }
  
  // 添加文件到表单
  async addFilesToForm(form, dir, prefix) {
    const items = await fs.readdir(dir);
    
    for (const item of items) {
      const fullPath = path.join(dir, item);
      const stat = await fs.stat(fullPath);
      
      if (stat.isDirectory()) {
        await this.addFilesToForm(form, fullPath, `${prefix}${item}/`);
      } else {
        const relativePath = `${prefix}${item}`;
        form.append('files', fs.createReadStream(fullPath), relativePath);
      }
    }
  }
  
  // 执行部署
  async executeDeployment(app, uploadResult) {
    const response = await axios.post(
      `${this.config.deploymentServer}/deploy`,
      {
        appName: app.name,
        version: app.version,
        uploadId: uploadResult.uploadId,
        deploymentConfig: app.deploymentConfig || {}
      },
      {
        headers: {
          'Authorization': `Bearer ${this.config.credentials.token}`
        }
      }
    );
    
    return response.data;
  }
  
  // 健康检查
  async performHealthCheck(app) {
    const maxAttempts = 5;
    const delay = 5000; // 5秒
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        const response = await axios.get(
          `${app.url}/health`,
          { timeout: 10000 }
        );
        
        if (response.status === 200) {
          console.log(`应用 ${app.name} 健康检查通过`);
          return true;
        }
      } catch (error) {
        console.log(`应用 ${app.name} 健康检查失败 (尝试 ${attempt}/${maxAttempts}): ${error.message}`);
        
        if (attempt < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, delay));
        } else {
          throw new Error(`应用 ${app.name} 健康检查失败，已达到最大尝试次数`);
        }
      }
    }
  }
  
  // 保存部署历史
  async saveDeploymentHistory(app, deployResult) {
    const historyPath = path.join(app.path, '.deploy-history.json');
    let history = [];
    
    // 读取现有历史
    if (await fs.pathExists(historyPath)) {
      history = await fs.readJson(historyPath);
    }
    
    // 添加新记录
    history.push({
      version: app.version,
      deployTime: new Date().toISOString(),
      deployResult,
      success: true
    });
    
    // 限制历史记录数量
    if (history.length > 10) {
      history = history.slice(-10);
    }
    
    // 保存历史
    await fs.writeJson(historyPath, history, { spaces: 2 });
  }
  
  // 回滚应用
  async rollbackApp(app) {
    console.log(`回滚应用: ${app.name}`);
    
    try {
      const response = await axios.post(
        `${this.config.deploymentServer}/rollback`,
        {
          appName: app.name
        },
        {
          headers: {
            'Authorization': `Bearer ${this.config.credentials.token}`
          }
        }
      );
      
      console.log(`应用 ${app.name} 回滚成功`);
      return response.data;
    } catch (error) {
      console.error(`应用 ${app.name} 回滚失败:`, error.message);
      throw error;
    }
  }
  
  // 处理部署结果
  processDeploymentResults(results) {
    console.log('\n部署结果汇总:');
    
    results.forEach((result, index) => {
      const app = this.config.apps[index];
      
      if (result.status === 'fulfilled') {
        const { success, deployTime, version } = result.value;
        console.log(`✓ ${app.name}: 成功 (${version}, ${deployTime}ms)`);
      } else {
        console.log(`✗ ${app.name}: 失败`);
        console.error(`  错误: ${result.reason.message}`);
      }
    });
  }
  
  // 生成部署报告
  generateDeploymentReport() {
    const report = {
      deployTime: new Date().toISOString(),
      apps: []
    };
    
    this.deploymentResults.forEach((result, appName) => {
      report.apps.push({
        name: appName,
        success: result.success,
        deployTime: result.deployTime,
        version: result.version,
        error: result.error
      });
    });
    
    const reportPath = path.join(process.cwd(), 'deployment-report.json');
    fs.writeJsonSync(reportPath, report, { spaces: 2 });
    
    console.log(`\n部署报告已生成: ${reportPath}`);
  }
}

// 使用示例
const deployer = new MicroFrontendDeployer({
  apps: [
    {
      name: 'dashboard',
      path: './apps/dashboard',
      version: '1.2.0',
      url: 'https://dashboard.example.com',
      environment: 'production'
    },
    {
      name: 'settings',
      path: './apps/settings',
      version: '1.1.5',
      url: 'https://settings.example.com',
      environment: 'production'
    }
  ],
  deploymentServer: 'https://deploy.example.com/api',
  credentials: {
    token: 'your-deployment-token'
  },
  rollbackEnabled: true,
  healthCheckEnabled: true
});

// 部署所有应用
deployer.deployAll().then(results => {
  console.log('部署完成');
}).catch(error => {
  console.error('部署失败:', error);
});
```

### 7.3.2 灰度发布

灰度发布是微前端部署的重要策略，可以逐步将新版本推送给用户，降低风险：

```javascript
// 微前端灰度发布实现
class MicroFrontendCanaryDeployer {
  constructor(config) {
    this.config = {
      apps: [],
      deploymentServer: '',
      credentials: {},
      trafficRules: {},
      ...config
    };
    
    this.deploymentResults = new Map();
  }
  
  // 灰度发布
  async canaryDeploy(appName, newVersion, trafficPercentage) {
    console.log(`开始灰度发布应用: ${appName}, 版本: ${newVersion}, 流量比例: ${trafficPercentage}%`);
    
    try {
      // 1. 部署新版本
      const deployResult = await this.deployNewVersion(appName, newVersion);
      
      // 2. 配置流量规则
      await this.configureTrafficRules(appName, newVersion, trafficPercentage);
      
      // 3. 监控应用状态
      await this.monitorCanaryDeployment(appName, newVersion);
      
      return {
        success: true,
        appName,
        newVersion,
        trafficPercentage,
        deployResult
      };
    } catch (error) {
      console.error(`应用 ${appName} 灰度发布失败:`, error.message);
      
      // 回滚流量规则
      await this.rollbackTrafficRules(appName);
      
      return {
        success: false,
        appName,
        newVersion,
        error: error.message
      };
    }
  }
  
  // 部署新版本
  async deployNewVersion(appName, newVersion) {
    const app = this.config.apps.find(a => a.name === appName);
    if (!app) {
      throw new Error(`应用 ${appName} 不存在`);
    }
    
    // 创建临时应用配置
    const tempApp = {
      ...app,
      version: newVersion,
      name: `${appName}-canary`
    };
    
    // 部署新版本
    const deployer = new MicroFrontendDeployer(this.config);
    return await deployer.deployApp(tempApp);
  }
  
  // 配置流量规则
  async configureTrafficRules(appName, newVersion, trafficPercentage) {
    const response = await axios.post(
      `${this.config.deploymentServer}/traffic-rules`,
      {
        appName,
        rules: [
          {
            version: newVersion,
            percentage: trafficPercentage,
            conditions: this.config.trafficRules[appName] || {}
          },
          {
            version: 'stable',
            percentage: 100 - trafficPercentage
          }
        ]
      },
      {
        headers: {
          'Authorization': `Bearer ${this.config.credentials.token}`
        }
      }
    );
    
    console.log(`应用 ${appName} 流量规则配置完成`);
    return response.data;
  }
  
  // 监控灰度部署
  async monitorCanaryDeployment(appName, newVersion) {
    const monitoringDuration = 5 * 60 * 1000; // 5分钟
    const checkInterval = 30 * 1000; // 30秒
    const startTime = Date.now();
    
    while (Date.now() - startTime < monitoringDuration) {
      try {
        // 获取应用指标
        const metrics = await this.getAppMetrics(appName, newVersion);
        
        // 检查是否满足继续条件
        if (this.shouldContinueCanary(metrics)) {
          console.log(`应用 ${appName} 灰度发布监控正常`);
        } else {
          throw new Error(`应用 ${appName} 灰度发布监控异常: ${JSON.stringify(metrics)}`);
        }
        
        // 等待下一次检查
        await new Promise(resolve => setTimeout(resolve, checkInterval));
      } catch (error) {
        console.error(`应用 ${appName} 灰度发布监控失败:`, error.message);
        throw error;
      }
    }
    
    console.log(`应用 ${appName} 灰度发布监控完成`);
  }
  
  // 获取应用指标
  async getAppMetrics(appName, version) {
    const response = await axios.get(
      `${this.config.deploymentServer}/metrics/${appName}/${version}`,
      {
        headers: {
          'Authorization': `Bearer ${this.config.credentials.token}`
        }
      }
    );
    
    return response.data;
  }
  
  // 判断是否继续灰度发布
  shouldContinueCanary(metrics) {
    // 错误率不超过1%
    if (metrics.errorRate > 0.01) {
      return false;
    }
    
    // 平均响应时间不超过500ms
    if (metrics.avgResponseTime > 500) {
      return false;
    }
    
    // CPU使用率不超过80%
    if (metrics.cpuUsage > 0.8) {
      return false;
    }
    
    return true;
  }
  
  // 回滚流量规则
  async rollbackTrafficRules(appName) {
    console.log(`回滚应用 ${appName} 的流量规则`);
    
    try {
      const response = await axios.post(
        `${this.config.deploymentServer}/traffic-rules`,
        {
          appName,
          rules: [
            {
              version: 'stable',
              percentage: 100
            }
          ]
        },
        {
          headers: {
            'Authorization': `Bearer ${this.config.credentials.token}`
          }
        }
      );
      
      console.log(`应用 ${appName} 流量规则回滚完成`);
      return response.data;
    } catch (error) {
      console.error(`应用 ${appName} 流量规则回滚失败:`, error.message);
      throw error;
    }
  }
  
  // 全量发布
  async fullDeploy(appName, newVersion) {
    console.log(`开始全量发布应用: ${appName}, 版本: ${newVersion}`);
    
    try {
      // 1. 更新流量规则，将所有流量指向新版本
      await this.configureTrafficRules(appName, newVersion, 100);
      
      // 2. 等待流量切换完成
      await new Promise(resolve => setTimeout(resolve, 10000));
      
      // 3. 验证应用状态
      await this.validateFullDeployment(appName, newVersion);
      
      return {
        success: true,
        appName,
        newVersion
      };
    } catch (error) {
      console.error(`应用 ${appName} 全量发布失败:`, error.message);
      
      // 回滚到稳定版本
      await this.rollbackTrafficRules(appName);
      
      return {
        success: false,
        appName,
        newVersion,
        error: error.message
      };
    }
  }
  
  // 验证全量部署
  async validateFullDeployment(appName, version) {
    const maxAttempts = 3;
    const delay = 5000; // 5秒
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        const response = await axios.get(
          `${this.config.deploymentServer}/validate/${appName}/${version}`,
          {
            headers: {
              'Authorization': `Bearer ${this.config.credentials.token}`
            }
          }
        );
        
        if (response.data.valid) {
          console.log(`应用 ${appName} 全量发布验证通过`);
          return true;
        }
      } catch (error) {
        console.log(`应用 ${appName} 全量发布验证失败 (尝试 ${attempt}/${maxAttempts}): ${error.message}`);
        
        if (attempt < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, delay));
        } else {
          throw new Error(`应用 ${appName} 全量发布验证失败，已达到最大尝试次数`);
        }
      }
    }
  }
}

// 使用示例
const canaryDeployer = new MicroFrontendCanaryDeployer({
  apps: [
    {
      name: 'dashboard',
      path: './apps/dashboard',
      stableVersion: '1.2.0',
      url: 'https://dashboard.example.com'
    }
  ],
  deploymentServer: 'https://deploy.example.com/api',
  credentials: {
    token: 'your-deployment-token'
  },
  trafficRules: {
    dashboard: {
      userAgent: {
        includes: ['Chrome/90']
      },
      geo: {
        includes: ['US', 'CA']
      }
    }
  }
});

// 灰度发布
canaryDeployer.canaryDeploy('dashboard', '1.3.0', 10)
  .then(result => {
    if (result.success) {
      console.log('灰度发布成功，可以继续增加流量或全量发布');
      
      // 全量发布
      return canaryDeployer.fullDeploy('dashboard', '1.3.0');
    } else {
      console.error('灰度发布失败');
    }
  })
  .then(result => {
    if (result && result.success) {
      console.log('全量发布成功');
    }
  })
  .catch(error => {
    console.error('发布失败:', error);
  });
```

## 7.4 CI/CD集成

### 7.4.1 GitHub Actions配置

GitHub Actions是常用的CI/CD工具，可以轻松集成微前端的构建和部署流程：

```yaml
# .github/workflows/micro-frontend-ci.yml
name: Micro Frontend CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  NODE_VERSION: '16'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # 检测变更的应用
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      dashboard: ${{ steps.changes.outputs.dashboard }}
      settings: ${{ steps.changes.outputs.settings }}
      common: ${{ steps.changes.outputs.common }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 2

      - name: Check for file changes
        uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            dashboard:
              - 'apps/dashboard/**'
            settings:
              - 'apps/settings/**'
            common:
              - 'packages/common/**'
              - 'package.json'
              - 'yarn.lock'

  # 构建共享依赖
  build-common:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.common == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Build common package
        run: yarn build:common

      - name: Upload common build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: common-build
          path: packages/common/dist

  # 构建和测试Dashboard应用
  build-dashboard:
    runs-on: ubuntu-latest
    needs: [detect-changes, build-common]
    if: needs.detect-changes.outputs.dashboard == 'true' || needs.detect-changes.outputs.common == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Download common build artifacts
        if: needs.detect-changes.outputs.common == 'true'
        uses: actions/download-artifact@v3
        with:
          name: common-build
          path: packages/common/dist

      - name: Run tests
        run: yarn test:dashboard

      - name: Build dashboard
        run: yarn build:dashboard

      - name: Upload dashboard build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: dashboard-build
          path: apps/dashboard/dist

  # 构建和测试Settings应用
  build-settings:
    runs-on: ubuntu-latest
    needs: [detect-changes, build-common]
    if: needs.detect-changes.outputs.settings == 'true' || needs.detect-changes.outputs.common == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Download common build artifacts
        if: needs.detect-changes.outputs.common == 'true'
        uses: actions/download-artifact@v3
        with:
          name: common-build
          path: packages/common/dist

      - name: Run tests
        run: yarn test:settings

      - name: Build settings
        run: yarn build:settings

      - name: Upload settings build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: settings-build
          path: apps/settings/dist

  # 部署到开发环境
  deploy-dev:
    runs-on: ubuntu-latest
    needs: [detect-changes, build-dashboard, build-settings]
    if: github.ref == 'refs/heads/develop' && (
      needs.detect-changes.outputs.dashboard == 'true' || 
      needs.detect-changes.outputs.settings == 'true' || 
      needs.detect-changes.outputs.common == 'true'
    )
    environment: development
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Download dashboard build artifacts
        if: needs.detect-changes.outputs.dashboard == 'true' || needs.detect-changes.outputs.common == 'true'
        uses: actions/download-artifact@v3
        with:
          name: dashboard-build
          path: apps/dashboard/dist

      - name: Download settings build artifacts
        if: needs.detect-changes.outputs.settings == 'true' || needs.detect-changes.outputs.common == 'true'
        uses: actions/download-artifact@v3
        with:
          name: settings-build
          path: apps/settings/dist

      - name: Deploy to development
        run: |
          # 部署脚本
          node scripts/deploy.js --env=development

      - name: Run smoke tests
        run: |
          # 冒烟测试
          node scripts/smoke-test.js --env=development

  # 部署到生产环境
  deploy-prod:
    runs-on: ubuntu-latest
    needs: [detect-changes, build-dashboard, build-settings]
    if: github.ref == 'refs/heads/main' && (
      needs.detect-changes.outputs.dashboard == 'true' || 
      needs.detect-changes.outputs.settings == 'true' || 
      needs.detect-changes.outputs.common == 'true'
    )
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Download dashboard build artifacts
        if: needs.detect-changes.outputs.dashboard == 'true' || needs.detect-changes.outputs.common == 'true'
        uses: actions/download-artifact@v3
        with:
          name: dashboard-build
          path: apps/dashboard/dist

      - name: Download settings build artifacts
        if: needs.detect-changes.outputs.settings == 'true' || needs.detect-changes.outputs.common == 'true'
        uses: actions/download-artifact@v3
        with:
          name: settings-build
          path: apps/settings/dist

      - name: Canary deploy to production
        run: |
          # 灰度发布脚本
          node scripts/canary-deploy.js --env=production --traffic=10

      - name: Wait for canary deployment
        run: |
          # 等待灰度部署稳定
          sleep 300

      - name: Validate canary deployment
        run: |
          # 验证灰度部署
          node scripts/validate-canary.js --env=production

      - name: Full deploy to production
        run: |
          # 全量发布脚本
          node scripts/full-deploy.js --env=production

      - name: Run smoke tests
        run: |
          # 冒烟测试
          node scripts/smoke-test.js --env=production

      - name: Notify deployment
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        if: always()
```

### 7.4.2 Jenkins Pipeline配置

Jenkins是另一种常用的CI/CD工具，适合企业内部使用：

```groovy
// Jenkinsfile
pipeline {
    agent any
    
    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['development', 'staging', 'production'],
            description: '选择部署环境'
        )
        choice(
            name: 'DEPLOYMENT_TYPE',
            choices: ['full', 'canary'],
            description: '选择部署类型'
        )
        string(
            name: 'CANARY_PERCENTAGE',
            defaultValue: '10',
            description: '灰度发布流量百分比 (仅当部署类型为canary时有效)'
        )
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: '是否跳过测试'
        )
    }
    
    environment {
        NODE_VERSION = '16'
        REGISTRY = 'your-registry.com'
        CREDENTIALS_ID = 'micro-frontend-credentials'
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Setup Node.js') {
            steps {
                sh 'nvm use ${NODE_VERSION}'
                sh 'node --version'
                sh 'npm --version'
            }
        }
        
        stage('Install Dependencies') {
            steps {
                sh 'npm ci'
            }
        }
        
        stage('Detect Changes') {
            steps {
                script {
                    // 检测哪些应用发生了变更
                    def changedApps = sh(
                        script: 'node scripts/detect-changes.js',
                        returnStdout: true
                    ).trim()
                    
                    env.CHANGED_APPS = changedApps
                    echo "变更的应用: ${changedApps}"
                }
            }
        }
        
        stage('Build Common') {
            when {
                expression {
                    return env.CHANGED_APPS.contains('common')
                }
            }
            steps {
                sh 'npm run build:common'
                
                archiveArtifacts artifacts: 'packages/common/dist/**/*', fingerprint: true
            }
        }
        
        stage('Build Apps') {
            parallel {
                stage('Build Dashboard') {
                    when {
                        expression {
                            return env.CHANGED_APPS.contains('dashboard') || env.CHANGED_APPS.contains('common')
                        }
                    }
                    steps {
                        script {
                            // 如果common有变更，先恢复构建产物
                            if (env.CHANGED_APPS.contains('common')) {
                                unarchive mapping: ['packages/common/dist/': 'packages/common/dist/']
                            }
                            
                            sh 'npm run build:dashboard'
                            archiveArtifacts artifacts: 'apps/dashboard/dist/**/*', fingerprint: true
                        }
                    }
                }
                
                stage('Build Settings') {
                    when {
                        expression {
                            return env.CHANGED_APPS.contains('settings') || env.CHANGED_APPS.contains('common')
                        }
                    }
                    steps {
                        script {
                            // 如果common有变更，先恢复构建产物
                            if (env.CHANGED_APPS.contains('common')) {
                                unarchive mapping: ['packages/common/dist/': 'packages/common/dist/']
                            }
                            
                            sh 'npm run build:settings'
                            archiveArtifacts artifacts: 'apps/settings/dist/**/*', fingerprint: true
                        }
                    }
                }
            }
        }
        
        stage('Test') {
            when {
                not {
                    equals expected: true, actual: params.SKIP_TESTS
                }
            }
            parallel {
                stage('Test Dashboard') {
                    when {
                        expression {
                            return env.CHANGED_APPS.contains('dashboard') || env.CHANGED_APPS.contains('common')
                        }
                    }
                    steps {
                        sh 'npm run test:dashboard'
                        
                        publishTestResults testResultsPattern: 'apps/dashboard/test-results/**/*'
                        publishHTML([
                            allowMissing: false,
                            alwaysLinkToLastBuild: true,
                            keepAll: true,
                            reportDir: 'apps/dashboard/coverage',
                            reportFiles: 'lcov-report/index.html',
                            reportName: 'Dashboard Coverage Report'
                        ])
                    }
                }
                
                stage('Test Settings') {
                    when {
                        expression {
                            return env.CHANGED_APPS.contains('settings') || env.CHANGED_APPS.contains('common')
                        }
                    }
                    steps {
                        sh 'npm run test:settings'
                        
                        publishTestResults testResultsPattern: 'apps/settings/test-results/**/*'
                        publishHTML([
                            allowMissing: false,
                            alwaysLinkToLastBuild: true,
                            keepAll: true,
                            reportDir: 'apps/settings/coverage',
                            reportFiles: 'lcov-report/index.html',
                            reportName: 'Settings Coverage Report'
                        ])
                    }
                }
            }
        }
        
        stage('Deploy') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'main'
                }
            }
            parallel {
                stage('Deploy Dashboard') {
                    when {
                        expression {
                            return env.CHANGED_APPS.contains('dashboard') || env.CHANGED_APPS.contains('common')
                        }
                    }
                    steps {
                        script {
                            // 恢复构建产物
                            unarchive mapping: ['apps/dashboard/dist/': 'apps/dashboard/dist/']
                            
                            // 部署应用
                            if (params.DEPLOYMENT_TYPE == 'canary') {
                                sh "node scripts/canary-deploy.js --app=dashboard --env=${params.ENVIRONMENT} --traffic=${params.CANARY_PERCENTAGE}"
                            } else {
                                sh "node scripts/deploy.js --app=dashboard --env=${params.ENVIRONMENT}"
                            }
                        }
                    }
                }
                
                stage('Deploy Settings') {
                    when {
                        expression {
                            return env.CHANGED_APPS.contains('settings') || env.CHANGED_APPS.contains('common')
                        }
                    }
                    steps {
                        script {
                            // 恢复构建产物
                            unarchive mapping: ['apps/settings/dist/': 'apps/settings/dist/']
                            
                            // 部署应用
                            if (params.DEPLOYMENT_TYPE == 'canary') {
                                sh "node scripts/canary-deploy.js --app=settings --env=${params.ENVIRONMENT} --traffic=${params.CANARY_PERCENTAGE}"
                            } else {
                                sh "node scripts/deploy.js --app=settings --env=${params.ENVIRONMENT}"
                            }
                        }
                    }
                }
            }
        }
        
        stage('Validate Deployment') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'main'
                }
            }
            steps {
                script {
                    // 验证部署
                    def apps = []
                    
                    if (env.CHANGED_APPS.contains('dashboard') || env.CHANGED_APPS.contains('common')) {
                        apps.add('dashboard')
                    }
                    
                    if (env.CHANGED_APPS.contains('settings') || env.CHANGED_APPS.contains('common')) {
                        apps.add('settings')
                    }
                    
                    for (app in apps) {
                        sh "node scripts/validate-deployment.js --app=${app} --env=${params.ENVIRONMENT}"
                    }
                }
            }
        }
        
        stage('Full Deploy (Canary Only)') {
            when {
                allOf {
                    expression { params.DEPLOYMENT_TYPE == 'canary' }
                    anyOf {
                        branch 'develop'
                        branch 'main'
                    }
                }
            }
            input {
                message "是否继续全量发布?"
                ok "继续"
                submitter "admin,devops"
            }
            steps {
                script {
                    def apps = []
                    
                    if (env.CHANGED_APPS.contains('dashboard') || env.CHANGED_APPS.contains('common')) {
                        apps.add('dashboard')
                    }
                    
                    if (env.CHANGED_APPS.contains('settings') || env.CHANGED_APPS.contains('common')) {
                        apps.add('settings')
                    }
                    
                    for (app in apps) {
                        sh "node scripts/full-deploy.js --app=${app} --env=${params.ENVIRONMENT}"
                    }
                }
            }
        }
    }
    
    post {
        always {
            // 清理工作空间
            cleanWs()
        }
        
        success {
            script {
                if (params.ENVIRONMENT == 'production') {
                    // 发送成功通知
                    slackSend(
                        channel: '#deployments',
                        color: 'good',
                        message: "✅ 微前端部署成功: ${env.JOB_NAME} - ${env.BUILD_NUMBER} (${params.ENVIRONMENT})"
                    )
                }
            }
        }
        
        failure {
            script {
                // 发送失败通知
                slackSend(
                    channel: '#deployments',
                    color: 'danger',
                    message: "❌ 微前端部署失败: ${env.JOB_NAME} - ${env.BUILD_NUMBER} (${params.ENVIRONMENT})\n查看详情: ${env.BUILD_URL}"
                )
            }
        }
    }
}
```

## 总结

本章详细介绍了微前端架构中的构建与部署策略，包括：

1. **微前端构建概述**：分析了微前端构建面临的挑战和基本流程
2. **微前端构建工具**：介绍了Webpack、Vite等构建工具的配置和使用
3. **微前端部署策略**：详细讲解了独立部署和灰度发布的实现方案
4. **CI/CD集成**：提供了GitHub Actions和Jenkins Pipeline的配置示例

通过这些构建和部署策略，微前端应用可以实现高效的构建流程和灵活的部署方案，提高开发效率和应用可靠性。在实际项目中，应根据团队需求和技术栈选择合适的构建工具和部署策略，并结合CI/CD流程实现自动化部署。