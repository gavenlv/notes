# 第十章：微前端安全实践

## 10.1 安全概述

### 10.1.1 微前端安全的重要性

在微前端架构中，安全性是一个至关重要的考虑因素。由于微前端将单体应用拆分为多个独立开发、部署和维护的小型应用，这带来了新的安全挑战和风险。微前端安全的重要性主要体现在以下几个方面：

1. **攻击面扩大**：微前端架构增加了应用的入口点和组件数量，每个微应用都可能成为潜在的攻击入口。

2. **第三方依赖风险**：微前端通常依赖多个第三方库和框架，增加了供应链攻击的风险。

3. **跨域通信风险**：微应用之间的通信需要跨越不同的域或子域，增加了跨站脚本攻击(XSS)和跨站请求伪造(CSRF)的风险。

4. **数据隔离挑战**：确保不同微应用之间的数据隔离和安全访问变得更加复杂。

5. **安全策略一致性**：确保所有微应用遵循一致的安全策略和标准变得更加困难。

### 10.1.2 微前端安全的目标

微前端安全的主要目标包括：

1. **保护用户数据**：确保用户敏感数据不被未经授权的访问、修改或泄露。

2. **防止恶意代码执行**：防止恶意脚本在用户浏览器中执行，避免XSS攻击。

3. **确保通信安全**：保护微应用之间的通信，防止数据被窃听或篡改。

4. **维护应用完整性**：确保应用代码和资源不被篡改，维护应用的完整性。

5. **实现访问控制**：确保只有授权的用户和微应用能够访问特定的资源和功能。

6. **保障可用性**：防止拒绝服务攻击，确保应用的持续可用性。

### 10.1.3 微前端安全的挑战

微前端架构带来了以下主要安全挑战：

1. **沙箱隔离不彻底**：JavaScript沙箱可能存在绕过风险，导致恶意代码影响主应用或其他微应用。

2. **样式污染**：CSS样式可能在不同微应用之间相互影响，导致UI异常或信息泄露。

3. **全局变量污染**：不同微应用可能使用相同的全局变量名，导致数据污染或意外行为。

4. **依赖冲突**：不同微应用可能依赖不同版本的同一库，导致安全漏洞或功能异常。

5. **认证和授权复杂性**：在微前端架构中实现统一的认证和授权机制更加复杂。

6. **安全策略不一致**：不同团队开发的微应用可能采用不同的安全策略和标准，导致整体安全性降低。

## 10.2 安全架构设计

### 10.2.1 安全架构原则

微前端安全架构设计应遵循以下原则：

1. **深度防御**：采用多层安全机制，确保即使一层被突破，其他层仍能提供保护。

2. **最小权限原则**：每个微应用只应获得完成其功能所需的最小权限。

3. **零信任架构**：不默认信任任何微应用或请求，所有请求都需要经过验证和授权。

4. **安全默认设置**：所有安全相关配置应采用最安全的默认设置。

5. **透明性**：安全机制应对开发者和用户尽可能透明，不影响正常开发和用户体验。

6. **可审计性**：所有安全相关操作应可记录和审计，便于安全事件追踪和分析。

### 10.2.2 安全架构设计

以下是一个微前端安全架构的设计示例：

```javascript
/**
 * 微前端安全架构设计
 */
class MicroFrontendSecurityArchitecture {
  constructor(options = {}) {
    this.options = {
      // 安全策略配置
      cspPolicy: this.getDefaultCspPolicy(),
      sandboxConfig: this.getDefaultSandboxConfig(),
      authenticationConfig: this.getDefaultAuthenticationConfig(),
      authorizationConfig: this.getDefaultAuthorizationConfig(),
      encryptionConfig: this.getDefaultEncryptionConfig(),
      ...options
    };
    
    // 安全组件初始化
    this.cspManager = new ContentSecurityPolicyManager(this.options.cspPolicy);
    this.sandboxManager = new SandboxManager(this.options.sandboxConfig);
    this.authManager = new AuthenticationManager(this.options.authenticationConfig);
    this.authzManager = new AuthorizationManager(this.options.authorizationConfig);
    this.cryptoManager = new CryptographyManager(this.options.encryptionConfig);
    this.securityMonitor = new SecurityMonitor();
    
    // 安全策略注册
    this.securityPolicies = new Map();
    this.registerDefaultSecurityPolicies();
  }
  
  /**
   * 获取默认内容安全策略
   */
  getDefaultCspPolicy() {
    return {
      'default-src': ["'self'"],
      'script-src': ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
      'style-src': ["'self'", "'unsafe-inline'"],
      'img-src': ["'self'", 'data:', 'https:'],
      'font-src': ["'self'", 'data:', 'https:'],
      'connect-src': ["'self'"],
      'frame-src': ["'none'"],
      'object-src': ["'none'"],
      'media-src': ["'self'"],
      'manifest-src': ["'self'"],
      'worker-src': ["'self'"],
      'child-src': ["'none'"],
      'form-action': ["'self'"],
      'frame-ancestors': ["'none'"],
      'base-uri': ["'self'"],
      'upgrade-insecure-requests': []
    };
  }
  
  /**
   * 获取默认沙箱配置
   */
  getDefaultSandboxConfig() {
    return {
      allowScripts: true,
      allowSameOrigin: true,
      allowForms: true,
      allowPopups: false,
      allowModals: false,
      allowOrientationLock: false,
      allowPointerLock: false,
      allowPresentation: false,
      allowDownloads: false,
      allowTopNavigation: false,
      allowTopNavigationByUserActivation: false
    };
  }
  
  /**
   * 获取默认认证配置
   */
  getDefaultAuthenticationConfig() {
    return {
      tokenStorage: 'localStorage',
      tokenRefreshThreshold: 300000, // 5分钟
      logoutUrl: '/logout',
      loginUrl: '/login',
      unauthorizedUrl: '/unauthorized',
      tokenValidationInterval: 60000 // 1分钟
    };
  }
  
  /**
   * 获取默认授权配置
   */
  getDefaultAuthorizationConfig() {
    return {
      defaultPolicy: 'deny',
      roleHierarchy: {
        'admin': ['editor', 'viewer'],
        'editor': ['viewer'],
        'viewer': []
      },
      permissions: {
        'read': ['viewer', 'editor', 'admin'],
        'write': ['editor', 'admin'],
        'delete': ['admin']
      }
    };
  }
  
  /**
   * 获取默认加密配置
   */
  getDefaultEncryptionConfig() {
    return {
      algorithm: 'AES-GCM',
      keyLength: 256,
      ivLength: 12,
      tagLength: 16,
      keyDerivationFunction: 'PBKDF2',
      keyDerivationIterations: 100000,
      saltLength: 16
    };
  }
  
  /**
   * 注册默认安全策略
   */
  registerDefaultSecurityPolicies() {
    // XSS防护策略
    this.registerSecurityPolicy('xss-protection', {
      name: 'XSS Protection',
      description: '防止跨站脚本攻击',
      priority: 1,
      apply: (context) => {
        return this.applyXssProtection(context);
      }
    });
    
    // CSRF防护策略
    this.registerSecurityPolicy('csrf-protection', {
      name: 'CSRF Protection',
      description: '防止跨站请求伪造攻击',
      priority: 2,
      apply: (context) => {
        return this.applyCsrfProtection(context);
      }
    });
    
    // 数据验证策略
    this.registerSecurityPolicy('data-validation', {
      name: 'Data Validation',
      description: '验证输入和输出数据',
      priority: 3,
      apply: (context) => {
        return this.applyDataValidation(context);
      }
    });
    
    // 安全头策略
    this.registerSecurityPolicy('security-headers', {
      name: 'Security Headers',
      description: '添加安全相关的HTTP头',
      priority: 4,
      apply: (context) => {
        return this.applySecurityHeaders(context);
      }
    });
  }
  
  /**
   * 注册安全策略
   */
  registerSecurityPolicy(id, policy) {
    this.securityPolicies.set(id, policy);
  }
  
  /**
   * 应用安全策略
   */
  applySecurityPolicies(context) {
    const results = [];
    
    // 按优先级排序策略
    const sortedPolicies = Array.from(this.securityPolicies.values())
      .sort((a, b) => a.priority - b.priority);
    
    // 应用每个策略
    for (const policy of sortedPolicies) {
      try {
        const result = policy.apply(context);
        results.push({
          policy: policy.name,
          success: true,
          result
        });
      } catch (error) {
        console.error(`安全策略 ${policy.name} 应用失败:`, error);
        results.push({
          policy: policy.name,
          success: false,
          error: error.message
        });
      }
    }
    
    return results;
  }
  
  /**
   * 应用XSS防护
   */
  applyXssProtection(context) {
    // 输入过滤
    const inputFilter = new InputFilter();
    const sanitizedInput = inputFilter.sanitize(context.input);
    
    // 输出编码
    const outputEncoder = new OutputEncoder();
    const encodedOutput = outputEncoder.encode(context.output);
    
    // 内容安全策略
    this.cspManager.enforcePolicy(context.request, context.response);
    
    return {
      sanitizedInput,
      encodedOutput,
      cspPolicy: this.cspManager.getCurrentPolicy()
    };
  }
  
  /**
   * 应用CSRF防护
   */
  applyCsrfProtection(context) {
    // 生成CSRF令牌
    const csrfToken = this.generateCsrfToken();
    
    // 验证CSRF令牌
    const isValid = this.validateCsrfToken(context.request, csrfToken);
    
    if (!isValid) {
      throw new Error('CSRF token validation failed');
    }
    
    // 设置CSRF Cookie
    this.setCsrfCookie(context.response, csrfToken);
    
    return {
      csrfToken,
      isValid
    };
  }
  
  /**
   * 应用数据验证
   */
  applyDataValidation(context) {
    const validator = new DataValidator();
    
    // 验证输入数据
    const inputValidation = validator.validate(context.input, context.inputSchema);
    
    // 验证输出数据
    const outputValidation = validator.validate(context.output, context.outputSchema);
    
    return {
      inputValidation,
      outputValidation
    };
  }
  
  /**
   * 应用安全头
   */
  applySecurityHeaders(context) {
    const headers = {
      'X-Content-Type-Options': 'nosniff',
      'X-Frame-Options': 'DENY',
      'X-XSS-Protection': '1; mode=block',
      'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
      'Referrer-Policy': 'strict-origin-when-cross-origin',
      'Permissions-Policy': 'geolocation=(), microphone=(), camera=()'
    };
    
    // 设置响应头
    for (const [name, value] of Object.entries(headers)) {
      context.response.setHeader(name, value);
    }
    
    return headers;
  }
  
  /**
   * 生成CSRF令牌
   */
  generateCsrfToken() {
    const bytes = new Uint8Array(32);
    crypto.getRandomValues(bytes);
    return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join('');
  }
  
  /**
   * 验证CSRF令牌
   */
  validateCsrfToken(request, expectedToken) {
    const token = request.headers['x-csrf-token'] || 
                  request.body._csrf || 
                  request.query._csrf;
    
    return token === expectedToken;
  }
  
  /**
   * 设置CSRF Cookie
   */
  setCsrfCookie(response, token) {
    response.cookie('XSRF-TOKEN', token, {
      httpOnly: false, // 允许JavaScript读取
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 24 * 60 * 60 * 1000 // 24小时
    });
  }
}

// 使用示例
const securityArchitecture = new MicroFrontendSecurityArchitecture({
  cspPolicy: {
    'script-src': ["'self'", "'unsafe-inline'", "https://trusted.cdn.com"],
    'connect-src': ["'self'", "https://api.example.com"]
  },
  sandboxConfig: {
    allowEval: false,
    allowExternalRequests: true,
    allowStringCallbacks: false
  }
});

// 创建微应用沙箱
const appSandbox = securityArchitecture.sandboxManager.createSandbox('micro-app-1', {
  allowEval: false,
  allowExternalRequests: true
});

// 应用安全策略
const context = {
  request: { headers: {} },
  response: { setHeader: () => {} },
  input: '<script>alert("xss")</script>',
  output: 'User data: <script>alert("xss")</script>',
  inputSchema: { type: 'string', maxLength: 100 },
  outputSchema: { type: 'string', maxLength: 200 }
};

const securityResults = securityArchitecture.applySecurityPolicies(context);
console.log('安全策略应用结果:', securityResults);
```

## 10.3 身份认证与授权

### 10.3.1 身份认证策略

在微前端架构中，身份认证需要考虑以下策略：

1. **集中式认证**：所有微应用共享统一的认证系统，由主应用负责认证流程。

2. **令牌传递**：使用JWT等令牌机制在微应用间传递身份信息。

3. **单点登录(SSO)**：实现一次登录，所有微应用均可访问。

4. **会话管理**：统一管理用户会话，处理会话过期和刷新。

5. **多因素认证**：对于敏感操作，支持多因素认证机制。

### 10.3.2 授权机制设计

微前端授权机制设计应考虑：

1. **基于角色的访问控制(RBAC)**：根据用户角色分配权限。

2. **基于属性的访问控制(ABAC)**：根据用户属性和环境条件动态授权。

3. **微应用级授权**：控制用户对不同微应用的访问权限。

4. **功能级授权**：控制用户对微应用内特定功能的访问权限。

5. **数据级授权**：控制用户对特定数据的访问权限。

### 10.3.3 身份认证与授权实现

以下是一个微前端身份认证与授权的实现示例：

```javascript
/**
 * 微前端身份认证管理器
 */
class AuthenticationManager {
  constructor(config = {}) {
    this.config = {
      // 认证服务端点
      authEndpoint: '/api/auth',
      // 令牌刷新端点
      refreshEndpoint: '/api/auth/refresh',
      // 登出端点
      logoutEndpoint: '/api/auth/logout',
      // 令牌存储位置
      tokenStorage: 'localStorage', // 'localStorage', 'sessionStorage', 'cookie'
      // 令牌刷新阈值（毫秒）
      refreshThreshold: 5 * 60 * 1000, // 5分钟
      // 令牌验证间隔（毫秒）
      validationInterval: 60 * 1000, // 1分钟
      // 自动刷新令牌
      autoRefresh: true,
      ...config
    };
    
    // 当前用户信息
    this.currentUser = null;
    // 当前令牌
    this.currentToken = null;
    // 令牌过期时间
    this.tokenExpiry = null;
    // 刷新令牌
    this.refreshToken = null;
    // 验证定时器
    this.validationTimer = null;
    // 事件监听器
    this.eventListeners = new Map();
    
    this.init();
  }
  
  /**
   * 初始化认证管理器
   */
  init() {
    // 尝试从存储中恢复令牌
    this.restoreTokenFromStorage();
    
    // 如果有令牌，验证其有效性
    if (this.currentToken) {
      this.validateToken()
        .then(isValid => {
          if (!isValid) {
            this.clearToken();
            this.emit('auth-expired');
          }
        })
        .catch(error => {
          console.error('令牌验证失败:', error);
          this.clearToken();
          this.emit('auth-error', error);
        });
    }
    
    // 启动令牌验证定时器
    if (this.config.autoRefresh) {
      this.startValidationTimer();
    }
    
    // 监听存储事件（跨标签页同步）
    window.addEventListener('storage', this.handleStorageChange.bind(this));
  }
  
  /**
   * 登录
   */
  async login(credentials) {
    try {
      const response = await fetch(this.config.authEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(credentials)
      });
      
      if (!response.ok) {
        throw new Error(`登录失败: ${response.statusText}`);
      }
      
      const data = await response.json();
      
      // 保存令牌
      this.setToken(data.token, data.refreshToken, data.expiresIn);
      
      // 设置用户信息
      this.currentUser = data.user;
      
      // 保存到存储
      this.saveTokenToStorage();
      
      // 发出登录成功事件
      this.emit('login-success', this.currentUser);
      
      return this.currentUser;
    } catch (error) {
      console.error('登录失败:', error);
      this.emit('login-error', error);
      throw error;
    }
  }
  
  /**
   * 登出
   */
  async logout() {
    try {
      // 调用登出API
      if (this.currentToken) {
        await fetch(this.config.logoutEndpoint, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.currentToken}`
          }
        });
      }
    } catch (error) {
      console.error('登出API调用失败:', error);
    } finally {
      // 清除本地令牌和用户信息
      this.clearToken();
      this.currentUser = null;
      
      // 发出登出事件
      this.emit('logout');
    }
  }
  
  /**
   * 刷新令牌
   */
  async refreshToken() {
    if (!this.refreshToken) {
      throw new Error('没有可用的刷新令牌');
    }
    
    try {
      const response = await fetch(this.config.refreshEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ refreshToken: this.refreshToken })
      });
      
      if (!response.ok) {
        throw new Error(`令牌刷新失败: ${response.statusText}`);
      }
      
      const data = await response.json();
      
      // 更新令牌
      this.setToken(data.token, data.refreshToken, data.expiresIn);
      
      // 保存到存储
      this.saveTokenToStorage();
      
      // 发出令牌刷新事件
      this.emit('token-refreshed');
      
      return data.token;
    } catch (error) {
      console.error('令牌刷新失败:', error);
      this.clearToken();
      this.emit('auth-expired');
      throw error;
    }
  }
  
  /**
   * 验证令牌
   */
  async validateToken() {
    if (!this.currentToken) {
      return false;
    }
    
    try {
      // 检查令牌是否过期
      if (this.tokenExpiry && Date.now() >= this.tokenExpiry) {
        return false;
      }
      
      // 解析JWT令牌
      const payload = this.parseJWT(this.currentToken);
      
      // 验证令牌格式
      if (!payload || !payload.sub || !payload.iat || !payload.exp) {
        return false;
      }
      
      // 验证令牌是否在有效期内
      const now = Math.floor(Date.now() / 1000);
      if (payload.exp < now) {
        return false;
      }
      
      // 如果接近过期，尝试刷新
      if (this.config.autoRefresh && payload.exp - now < this.config.refreshThreshold / 1000) {
        await this.refreshToken();
      }
      
      return true;
    } catch (error) {
      console.error('令牌验证失败:', error);
      return false;
    }
  }
  
  /**
   * 设置令牌
   */
  setToken(token, refreshToken, expiresIn) {
    this.currentToken = token;
    this.refreshToken = refreshToken;
    this.tokenExpiry = Date.now() + expiresIn * 1000;
  }
  
  /**
   * 清除令牌
   */
  clearToken() {
    this.currentToken = null;
    this.refreshToken = null;
    this.tokenExpiry = null;
    
    // 从存储中清除
    this.removeTokenFromStorage();
    
    // 停止验证定时器
    if (this.validationTimer) {
      clearInterval(this.validationTimer);
      this.validationTimer = null;
    }
  }
  
  /**
   * 保存令牌到存储
   */
  saveTokenToStorage() {
    const tokenData = {
      token: this.currentToken,
      refreshToken: this.refreshToken,
      expiry: this.tokenExpiry
    };
    
    const storage = this.getStorage();
    storage.setItem('auth_token', JSON.stringify(tokenData));
  }
  
  /**
   * 从存储中恢复令牌
   */
  restoreTokenFromStorage() {
    const storage = this.getStorage();
    const tokenDataStr = storage.getItem('auth_token');
    
    if (tokenDataStr) {
      try {
        const tokenData = JSON.parse(tokenDataStr);
        this.currentToken = tokenData.token;
        this.refreshToken = tokenData.refreshToken;
        this.tokenExpiry = tokenData.expiry;
      } catch (error) {
        console.error('恢复令牌失败:', error);
        this.removeTokenFromStorage();
      }
    }
  }
  
  /**
   * 从存储中移除令牌
   */
  removeTokenFromStorage() {
    const storage = this.getStorage();
    storage.removeItem('auth_token');
  }
  
  /**
   * 获取存储对象
   */
  getStorage() {
    switch (this.config.tokenStorage) {
      case 'localStorage':
        return window.localStorage;
      case 'sessionStorage':
        return window.sessionStorage;
      case 'cookie':
        return new CookieStorage();
      default:
        return window.localStorage;
    }
  }
  
  /**
   * 解析JWT令牌
   */
  parseJWT(token) {
    try {
      const parts = token.split('.');
      if (parts.length !== 3) {
        throw new Error('无效的JWT格式');
      }
      
      const payload = JSON.parse(atob(parts[1]));
      return payload;
    } catch (error) {
      console.error('JWT解析失败:', error);
      return null;
    }
  }
  
  /**
   * 启动验证定时器
   */
  startValidationTimer() {
    if (this.validationTimer) {
      clearInterval(this.validationTimer);
    }
    
    this.validationTimer = setInterval(async () => {
      const isValid = await this.validateToken();
      if (!isValid) {
        this.clearToken();
        this.emit('auth-expired');
      }
    }, this.config.validationInterval);
  }
  
  /**
   * 处理存储变化
   */
  handleStorageChange(event) {
    if (event.key === 'auth_token') {
      if (!event.newValue) {
        // 令牌被清除（可能在其他标签页登出）
        this.clearToken();
        this.emit('auth-expired');
      } else {
        // 令牌被更新（可能在其他标签页登录）
        this.restoreTokenFromStorage();
        this.emit('token-updated');
      }
    }
  }
  
  /**
   * 添加事件监听器
   */
  on(event, callback) {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, []);
    }
    this.eventListeners.get(event).push(callback);
  }
  
  /**
   * 移除事件监听器
   */
  off(event, callback) {
    if (this.eventListeners.has(event)) {
      const listeners = this.eventListeners.get(event);
      const index = listeners.indexOf(callback);
      if (index !== -1) {
        listeners.splice(index, 1);
      }
    }
  }
  
  /**
   * 发出事件
   */
  emit(event, data) {
    if (this.eventListeners.has(event)) {
      this.eventListeners.get(event).forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`事件处理器执行失败 (${event}):`, error);
        }
      });
    }
  }
  
  /**
   * 获取当前用户
   */
  getCurrentUser() {
    return this.currentUser;
  }
  
  /**
   * 获取当前令牌
   */
  getCurrentToken() {
    return this.currentToken;
  }
  
  /**
   * 检查是否已认证
   */
  isAuthenticated() {
    return !!this.currentToken;
  }
}

/**
 * 微前端授权管理器
 */
class AuthorizationManager {
  constructor(config = {}) {
    this.config = {
      // 默认策略
      defaultPolicy: 'deny',
      // 角色层次结构
      roleHierarchy: {
        'admin': ['editor', 'viewer'],
        'editor': ['viewer'],
        'viewer': []
      },
      // 权限定义
      permissions: {
        'read': ['viewer', 'editor', 'admin'],
        'write': ['editor', 'admin'],
        'delete': ['admin']
      },
      // 微应用权限
      appPermissions: {},
      // 功能权限
      featurePermissions: {},
      ...config
    };
    
    // 当前用户角色
    this.userRoles = [];
    // 当前用户权限
    this.userPermissions = new Set();
  }
  
  /**
   * 设置用户角色
   */
  setUserRoles(roles) {
    this.userRoles = Array.isArray(roles) ? roles : [roles];
    this.updateUserPermissions();
  }
  
  /**
   * 更新用户权限
   */
  updateUserPermissions() {
    this.userPermissions.clear();
    
    // 添加直接权限
    for (const role of this.userRoles) {
      for (const [permission, allowedRoles] of Object.entries(this.config.permissions)) {
        if (allowedRoles.includes(role)) {
          this.userPermissions.add(permission);
        }
      }
    }
    
    // 添加继承权限
    for (const role of this.userRoles) {
      const inheritedRoles = this.config.roleHierarchy[role] || [];
      for (const inheritedRole of inheritedRoles) {
        for (const [permission, allowedRoles] of Object.entries(this.config.permissions)) {
          if (allowedRoles.includes(inheritedRole)) {
            this.userPermissions.add(permission);
          }
        }
      }
    }
  }
  
  /**
   * 检查用户是否有指定权限
   */
  hasPermission(permission) {
    return this.userPermissions.has(permission);
  }
  
  /**
   * 检查用户是否有指定角色
   */
  hasRole(role) {
    return this.userRoles.includes(role);
  }
  
  /**
   * 检查用户是否可以访问微应用
   */
  canAccessApp(appName) {
    const appPermissions = this.config.appPermissions[appName];
    
    if (!appPermissions) {
      // 如果没有定义微应用权限，使用默认策略
      return this.config.defaultPolicy === 'allow';
    }
    
    // 检查角色权限
    if (appPermissions.roles) {
      for (const role of this.userRoles) {
        if (appPermissions.roles.includes(role)) {
          return true;
        }
      }
    }
    
    // 检查功能权限
    if (appPermissions.permissions) {
      for (const permission of appPermissions.permissions) {
        if (this.hasPermission(permission)) {
          return true;
        }
      }
    }
    
    // 检查自定义权限检查函数
    if (appPermissions.check && typeof appPermissions.check === 'function') {
      return appPermissions.check(this.userRoles, Array.from(this.userPermissions));
    }
    
    return this.config.defaultPolicy === 'allow';
  }
  
  /**
   * 检查用户是否可以访问功能
   */
  canAccessFeature(featureName) {
    const featurePermissions = this.config.featurePermissions[featureName];
    
    if (!featurePermissions) {
      // 如果没有定义功能权限，使用默认策略
      return this.config.defaultPolicy === 'allow';
    }
    
    // 检查角色权限
    if (featurePermissions.roles) {
      for (const role of this.userRoles) {
        if (featurePermissions.roles.includes(role)) {
          return true;
        }
      }
    }
    
    // 检查功能权限
    if (featurePermissions.permissions) {
      for (const permission of featurePermissions.permissions) {
        if (this.hasPermission(permission)) {
          return true;
        }
      }
    }
    
    // 检查自定义权限检查函数
    if (featurePermissions.check && typeof featurePermissions.check === 'function') {
      return featurePermissions.check(this.userRoles, Array.from(this.userPermissions));
    }
    
    return this.config.defaultPolicy === 'allow';
  }
  
  /**
   * 添加微应用权限配置
   */
  addAppPermission(appName, permission) {
    this.config.appPermissions[appName] = permission;
  }
  
  /**
   * 添加功能权限配置
   */
  addFeaturePermission(featureName, permission) {
    this.config.featurePermissions[featureName] = permission;
  }
  
  /**
   * 获取用户所有权限
   */
  getUserPermissions() {
    return Array.from(this.userPermissions);
  }
}

// 使用示例
const authManager = new AuthenticationManager({
  authEndpoint: '/api/auth/login',
  refreshEndpoint: '/api/auth/refresh',
  logoutEndpoint: '/api/auth/logout',
  tokenStorage: 'localStorage',
  autoRefresh: true
});

const authzManager = new AuthorizationManager({
  defaultPolicy: 'deny',
  roleHierarchy: {
    'super-admin': ['admin', 'editor', 'viewer'],
    'admin': ['editor', 'viewer'],
    'editor': ['viewer'],
    'viewer': []
  },
  permissions: {
    'read': ['viewer', 'editor', 'admin', 'super-admin'],
    'write': ['editor', 'admin', 'super-admin'],
    'delete': ['admin', 'super-admin'],
    'manage-users': ['super-admin']
  },
  appPermissions: {
    'user-management': {
      roles: ['admin', 'super-admin'],
      permissions: ['manage-users']
    },
    'content-editor': {
      roles: ['editor', 'admin', 'super-admin'],
      permissions: ['write']
    },
    'analytics': {
      roles: ['viewer', 'editor', 'admin', 'super-admin'],
      permissions: ['read']
    }
  },
  featurePermissions: {
    'delete-content': {
      roles: ['admin', 'super-admin'],
      permissions: ['delete']
    },
    'publish-content': {
      roles: ['editor', 'admin', 'super-admin'],
      permissions: ['write']
    }
  }
});

// 监听认证事件
authManager.on('login-success', (user) => {
  console.log('用户登录成功:', user);
  // 设置用户角色
  authzManager.setUserRoles(user.roles);
});

authManager.on('logout', () => {
  console.log('用户已登出');
  // 清除用户角色
  authzManager.setUserRoles([]);
});

// 登录示例
authManager.login({
  username: 'admin@example.com',
  password: 'password'
}).then(user => {
  console.log('登录成功:', user);
}).catch(error => {
  console.error('登录失败:', error);
});

// 检查权限示例
function checkAccess(appName, featureName) {
  const canAccessApp = authzManager.canAccessApp(appName);
  const canAccessFeature = authzManager.canAccessFeature(featureName);
  
  console.log(`可以访问微应用 ${appName}:`, canAccessApp);
  console.log(`可以访问功能 ${featureName}:`, canAccessFeature);
  
  return canAccessApp && canAccessFeature;
}

// 在微应用中使用
function loadMicroApp(appName) {
  if (!authzManager.canAccessApp(appName)) {
    console.error(`没有权限访问微应用: ${appName}`);
    return;
  }
  
  // 加载微应用
  console.log(`加载微应用: ${appName}`);
}

// 在功能中使用
function executeFeature(featureName) {
  if (!authzManager.canAccessFeature(featureName)) {
    console.error(`没有权限执行功能: ${featureName}`);
    return;
  }
  
  // 执行功能
  console.log(`执行功能: ${featureName}`);
}
```

## 10.4 数据安全与加密

### 10.4.1 数据安全挑战

在微前端架构中，数据安全面临以下挑战：

1. **跨应用数据传输**：微应用间的数据传输可能被截获或篡改。

2. **敏感数据存储**：客户端存储的敏感数据可能被恶意脚本访问。

3. **第三方依赖风险**：第三方依赖可能包含恶意代码，窃取用户数据。

4. **数据泄露风险**：微应用可能意外暴露不应访问的数据。

5. **数据完整性**：确保数据在传输和存储过程中不被篡改。

6. **数据隐私保护**：遵守数据隐私法规，保护用户个人信息。

### 10.4.2 数据安全策略

针对上述挑战，可以采取以下数据安全策略：

1. **数据加密**：对敏感数据进行加密存储和传输。

2. **数据脱敏**：对非必要敏感数据进行脱敏处理。

3. **数据访问控制**：严格控制对敏感数据的访问权限。

4. **数据传输安全**：使用HTTPS等安全协议传输数据。

5. **数据生命周期管理**：管理数据的创建、存储、使用和销毁全过程。

6. **数据审计**：记录数据访问和操作日志，便于追踪和审计。

### 10.4.3 数据安全与加密实现

以下是一个微前端数据安全与加密的实现示例：

```javascript
/**
 * 微前端加密管理器
 */
class CryptographyManager {
  constructor(config = {}) {
    this.config = {
      // 默认加密算法
      algorithm: 'AES-GCM',
      // 密钥长度
      keyLength: 256,
      // IV长度
      ivLength: 12,
      // 标签长度
      tagLength: 16,
      // 密钥派生函数
      keyDerivationFunction: 'PBKDF2',
      // 密钥派生迭代次数
      keyDerivationIterations: 100000,
      // 盐长度
      saltLength: 16,
      // 哈希算法
      hashAlgorithm: 'SHA-256',
      // 密钥存储位置
      keyStorage: 'sessionStorage', // 'localStorage', 'sessionStorage', 'memory'
      // 自动密钥轮换间隔（毫秒）
      keyRotationInterval: 24 * 60 * 60 * 1000, // 24小时
      ...config
    };
    
    // 当前密钥
    this.currentKey = null;
    // 密钥创建时间
    this.keyCreationTime = null;
    // 密钥轮换定时器
    this.keyRotationTimer = null;
    
    this.init();
  }
  
  /**
   * 初始化加密管理器
   */
  async init() {
    // 尝试从存储中恢复密钥
    await this.restoreKeyFromStorage();
    
    // 如果没有密钥或密钥过期，生成新密钥
    if (!this.currentKey || this.isKeyExpired()) {
      await this.generateKey();
    }
    
    // 启动密钥轮换定时器
    this.startKeyRotationTimer();
  }
  
  /**
   * 生成新密钥
   */
  async generateKey() {
    try {
      // 生成随机密钥
      this.currentKey = await crypto.subtle.generateKey(
        {
          name: this.config.algorithm,
          length: this.config.keyLength
        },
        true, // 可导出
        ['encrypt', 'decrypt'] // 用途
      );
      
      // 记录密钥创建时间
      this.keyCreationTime = Date.now();
      
      // 保存密钥到存储
      await this.saveKeyToStorage();
      
      return this.currentKey;
    } catch (error) {
      console.error('密钥生成失败:', error);
      throw error;
    }
  }
  
  /**
   * 从密码派生密钥
   */
  async deriveKeyFromPassword(password, salt) {
    try {
      // 如果没有提供盐，生成随机盐
      if (!salt) {
        salt = crypto.getRandomValues(new Uint8Array(this.config.saltLength));
      }
      
      // 导入密码
      const passwordKey = await crypto.subtle.importKey(
        'raw',
        new TextEncoder().encode(password),
        { name: 'PBKDF2' },
        false,
        ['deriveBits', 'deriveKey']
      );
      
      // 派生密钥
      const derivedKey = await crypto.subtle.deriveKey(
        {
          name: this.config.keyDerivationFunction,
          salt: salt,
          iterations: this.config.keyDerivationIterations,
          hash: this.config.hashAlgorithm
        },
        passwordKey,
        {
          name: this.config.algorithm,
          length: this.config.keyLength
        },
        true,
        ['encrypt', 'decrypt']
      );
      
      return { key: derivedKey, salt };
    } catch (error) {
      console.error('密钥派生失败:', error);
      throw error;
    }
  }
  
  /**
   * 加密数据
   */
  async encrypt(data, key = null) {
    try {
      const encryptionKey = key || this.currentKey;
      
      if (!encryptionKey) {
        throw new Error('没有可用的加密密钥');
      }
      
      // 生成随机IV
      const iv = crypto.getRandomValues(new Uint8Array(this.config.ivLength));
      
      // 将数据转换为字节数组
      let dataBytes;
      if (typeof data === 'string') {
        dataBytes = new TextEncoder().encode(data);
      } else if (data instanceof ArrayBuffer) {
        dataBytes = new Uint8Array(data);
      } else {
        dataBytes = new TextEncoder().encode(JSON.stringify(data));
      }
      
      // 加密数据
      const encryptedData = await crypto.subtle.encrypt(
        {
          name: this.config.algorithm,
          iv: iv
        },
        encryptionKey,
        dataBytes
      );
      
      // 组合IV和加密数据
      const result = new Uint8Array(iv.length + encryptedData.byteLength);
      result.set(iv);
      result.set(new Uint8Array(encryptedData), iv.length);
      
      // 返回Base64编码的结果
      return this.arrayBufferToBase64(result);
    } catch (error) {
      console.error('数据加密失败:', error);
      throw error;
    }
  }
  
  /**
   * 解密数据
   */
  async decrypt(encryptedData, key = null) {
    try {
      const decryptionKey = key || this.currentKey;
      
      if (!decryptionKey) {
        throw new Error('没有可用的解密密钥');
      }
      
      // 将Base64字符串转换为字节数组
      const dataBytes = this.base64ToArrayBuffer(encryptedData);
      const dataArray = new Uint8Array(dataBytes);
      
      // 提取IV和加密数据
      const iv = dataArray.slice(0, this.config.ivLength);
      const encrypted = dataArray.slice(this.config.ivLength);
      
      // 解密数据
      const decryptedData = await crypto.subtle.decrypt(
        {
          name: this.config.algorithm,
          iv: iv
        },
        decryptionKey,
        encrypted
      );
      
      // 尝试将解密数据转换为JSON，如果失败则返回字符串
      try {
        return JSON.parse(new TextDecoder().decode(decryptedData));
      } catch {
        return new TextDecoder().decode(decryptedData);
      }
    } catch (error) {
      console.error('数据解密失败:', error);
      throw error;
    }
  }
  
  /**
   * 计算数据哈希
   */
  async hash(data) {
    try {
      let dataBytes;
      if (typeof data === 'string') {
        dataBytes = new TextEncoder().encode(data);
      } else if (data instanceof ArrayBuffer) {
        dataBytes = new Uint8Array(data);
      } else {
        dataBytes = new TextEncoder().encode(JSON.stringify(data));
      }
      
      const hashBuffer = await crypto.subtle.digest(this.config.hashAlgorithm, dataBytes);
      return this.arrayBufferToBase64(hashBuffer);
    } catch (error) {
      console.error('哈希计算失败:', error);
      throw error;
    }
  }
  
  /**
   * 生成HMAC
   */
  async hmac(data, key) {
    try {
      let dataBytes;
      if (typeof data === 'string') {
        dataBytes = new TextEncoder().encode(data);
      } else if (data instanceof ArrayBuffer) {
        dataBytes = new Uint8Array(data);
      } else {
        dataBytes = new TextEncoder().encode(JSON.stringify(data));
      }
      
      const hmacKey = await crypto.subtle.importKey(
        'raw',
        typeof key === 'string' ? new TextEncoder().encode(key) : key,
        { name: 'HMAC', hash: this.config.hashAlgorithm },
        false,
        ['sign']
      );
      
      const hmacBuffer = await crypto.subtle.sign('HMAC', hmacKey, dataBytes);
      return this.arrayBufferToBase64(hmacBuffer);
    } catch (error) {
      console.error('HMAC计算失败:', error);
      throw error;
    }
  }
  
  /**
   * 安全随机数生成
   */
  generateSecureRandom(length) {
    const randomValues = crypto.getRandomValues(new Uint8Array(length));
    return this.arrayBufferToBase64(randomValues);
  }
  
  /**
   * 保存密钥到存储
   */
  async saveKeyToStorage() {
    if (!this.currentKey) return;
    
    try {
      // 导出密钥
      const exportedKey = await crypto.subtle.exportKey('raw', this.currentKey);
      
      // 准备保存数据
      const keyData = {
        key: this.arrayBufferToBase64(exportedKey),
        algorithm: this.config.algorithm,
        length: this.config.keyLength,
        creationTime: this.keyCreationTime
      };
      
      // 保存到存储
      const storage = this.getStorage();
      storage.setItem('encryption_key', JSON.stringify(keyData));
    } catch (error) {
      console.error('密钥保存失败:', error);
      throw error;
    }
  }
  
  /**
   * 从存储中恢复密钥
   */
  async restoreKeyFromStorage() {
    try {
      const storage = this.getStorage();
      const keyDataStr = storage.getItem('encryption_key');
      
      if (!keyDataStr) return;
      
      const keyData = JSON.parse(keyDataStr);
      
      // 导入密钥
      this.currentKey = await crypto.subtle.importKey(
        'raw',
        this.base64ToArrayBuffer(keyData.key),
        { name: keyData.algorithm, length: keyData.length },
        true,
        ['encrypt', 'decrypt']
      );
      
      this.keyCreationTime = keyData.creationTime;
    } catch (error) {
      console.error('密钥恢复失败:', error);
      // 清除可能损坏的密钥
      const storage = this.getStorage();
      storage.removeItem('encryption_key');
    }
  }
  
  /**
   * 从存储中移除密钥
   */
  removeKeyFromStorage() {
    const storage = this.getStorage();
    storage.removeItem('encryption_key');
  }
  
  /**
   * 获取存储对象
   */
  getStorage() {
    switch (this.config.keyStorage) {
      case 'localStorage':
        return window.localStorage;
      case 'sessionStorage':
        return window.sessionStorage;
      case 'memory':
        return new MemoryStorage();
      default:
        return window.sessionStorage;
    }
  }
  
  /**
   * 检查密钥是否过期
   */
  isKeyExpired() {
    return this.keyCreationTime && 
           Date.now() - this.keyCreationTime > this.config.keyRotationInterval;
  }
  
  /**
   * 启动密钥轮换定时器
   */
  startKeyRotationTimer() {
    if (this.keyRotationTimer) {
      clearInterval(this.keyRotationTimer);
    }
    
    // 计算下次轮换时间（剩余时间的80%）
    const nextRotation = this.keyCreationTime ? 
      (this.config.keyRotationInterval - (Date.now() - this.keyCreationTime)) * 0.8 : 
      this.config.keyRotationInterval * 0.8;
    
    this.keyRotationTimer = setTimeout(async () => {
      await this.rotateKey();
      this.startKeyRotationTimer();
    }, nextRotation);
  }
  
  /**
   * 轮换密钥
   */
  async rotateKey() {
    try {
      // 生成新密钥
      const oldKey = this.currentKey;
      await this.generateKey();
      
      // 触发密钥轮换事件
      this.emit('key-rotated', { oldKey, newKey: this.currentKey });
    } catch (error) {
      console.error('密钥轮换失败:', error);
      this.emit('key-rotation-error', error);
    }
  }
  
  /**
   * ArrayBuffer转Base64
   */
  arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }
  
  /**
   * Base64转ArrayBuffer
   */
  base64ToArrayBuffer(base64) {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes.buffer;
  }
  
  /**
   * 添加事件监听器
   */
  on(event, callback) {
    if (!this.eventListeners) {
      this.eventListeners = new Map();
    }
    
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, []);
    }
    this.eventListeners.get(event).push(callback);
  }
  
  /**
   * 移除事件监听器
   */
  off(event, callback) {
    if (this.eventListeners && this.eventListeners.has(event)) {
      const listeners = this.eventListeners.get(event);
      const index = listeners.indexOf(callback);
      if (index !== -1) {
        listeners.splice(index, 1);
      }
    }
  }
  
  /**
   * 发出事件
   */
  emit(event, data) {
    if (this.eventListeners && this.eventListeners.has(event)) {
      this.eventListeners.get(event).forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`事件处理器执行失败 (${event}):`, error);
        }
      });
    }
  }
}

/**
 * 微前端数据安全管理器
 */
class DataSecurityManager {
  constructor(cryptoManager, config = {}) {
    this.cryptoManager = cryptoManager;
    this.config = {
      // 敏感字段列表
      sensitiveFields: [
        'password', 'token', 'secret', 'key', 'creditCard', 
        'ssn', 'socialSecurityNumber', 'bankAccount', 'phoneNumber'
      ],
      // 是否自动加密敏感数据
      autoEncryptSensitiveData: true,
      // 是否自动脱敏敏感数据
      autoMaskSensitiveData: true,
      // 脱敏规则
      maskingRules: {
        'email': (value) => {
          const [username, domain] = value.split('@');
          const maskedUsername = username.substring(0, 2) + '*'.repeat(username.length - 2);
          return `${maskedUsername}@${domain}`;
        },
        'phoneNumber': (value) => {
          return value.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
        },
        'creditCard': (value) => {
          return value.replace(/\d(?=\d{4})/g, '*');
        },
        'default': (value) => {
          if (value.length <= 2) return '*'.repeat(value.length);
          return value.substring(0, 1) + '*'.repeat(value.length - 2) + value.substring(value.length - 1);
        }
      },
      // 数据访问控制
      accessControl: {
        enabled: true,
        defaultPolicy: 'deny',
        policies: {}
      },
      // 数据审计
      audit: {
        enabled: true,
        logLevel: 'info', // 'debug', 'info', 'warn', 'error'
        excludeFields: ['password', 'token', 'secret']
      },
      ...config
    };
    
    // 数据访问日志
    this.accessLogs = [];
    // 数据加密缓存
    this.encryptionCache = new Map();
  }
  
  /**
   * 处理数据安全
   */
  async processData(data, operation = 'read') {
    try {
      // 记录访问日志
      this.logAccess(data, operation);
      
      // 应用访问控制
      if (this.config.accessControl.enabled) {
        const accessResult = this.applyAccessControl(data, operation);
        if (!accessResult.allowed) {
          throw new Error(`访问被拒绝: ${accessResult.reason}`);
        }
      }
      
      // 处理敏感数据
      let processedData = this.handleSensitiveData(data, operation);
      
      // 加密敏感数据
      if (operation === 'write' && this.config.autoEncryptSensitiveData) {
        processedData = await this.encryptSensitiveData(processedData);
      }
      
      // 脱敏敏感数据
      if (operation === 'read' && this.config.autoMaskSensitiveData) {
        processedData = this.maskSensitiveData(processedData);
      }
      
      return processedData;
    } catch (error) {
      console.error('数据处理失败:', error);
      throw error;
    }
  }
  
  /**
   * 处理敏感数据
   */
  handleSensitiveData(data, operation) {
    if (!data || typeof data !== 'object') {
      return data;
    }
    
    const result = Array.isArray(data) ? [] : {};
    
    for (const [key, value] of Object.entries(data)) {
      if (typeof value === 'object' && value !== null) {
        // 递归处理嵌套对象
        result[key] = this.handleSensitiveData(value, operation);
      } else {
        result[key] = value;
      }
    }
    
    return result;
  }
  
  /**
   * 加密敏感数据
   */
  async encryptSensitiveData(data) {
    const result = Array.isArray(data) ? [] : {};
    
    for (const [key, value] of Object.entries(data)) {
      if (typeof value === 'object' && value !== null) {
        // 递归处理嵌套对象
        result[key] = await this.encryptSensitiveData(value);
      } else if (this.isSensitiveField(key) && typeof value === 'string') {
        // 检查缓存
        const cacheKey = `${key}:${value}`;
        if (this.encryptionCache.has(cacheKey)) {
          result[key] = this.encryptionCache.get(cacheKey);
        } else {
          // 加密敏感字段
          const encryptedValue = await this.cryptoManager.encrypt(value);
          result[key] = encryptedValue;
          this.encryptionCache.set(cacheKey, encryptedValue);
        }
      } else {
        result[key] = value;
      }
    }
    
    return result;
  }
  
  /**
   * 脱敏敏感数据
   */
  maskSensitiveData(data) {
    const result = Array.isArray(data) ? [] : {};
    
    for (const [key, value] of Object.entries(data)) {
      if (typeof value === 'object' && value !== null) {
        // 递归处理嵌套对象
        result[key] = this.maskSensitiveData(value);
      } else if (this.isSensitiveField(key) && typeof value === 'string') {
        // 脱敏敏感字段
        result[key] = this.maskValue(key, value);
      } else {
        result[key] = value;
      }
    }
    
    return result;
  }
  
  /**
   * 检查是否为敏感字段
   */
  isSensitiveField(fieldName) {
    const lowerFieldName = fieldName.toLowerCase();
    return this.config.sensitiveFields.some(field => 
      lowerFieldName.includes(field.toLowerCase())
    );
  }
  
  /**
   * 脱敏值
   */
  maskValue(fieldName, value) {
    // 根据字段名选择脱敏规则
    const lowerFieldName = fieldName.toLowerCase();
    
    if (lowerFieldName.includes('email')) {
      return this.config.maskingRules.email(value);
    } else if (lowerFieldName.includes('phone')) {
      return this.config.maskingRules.phoneNumber(value);
    } else if (lowerFieldName.includes('creditcard') || lowerFieldName.includes('card')) {
      return this.config.maskingRules.creditCard(value);
    } else {
      return this.config.maskingRules.default(value);
    }
  }
  
  /**
   * 应用访问控制
   */
  applyAccessControl(data, operation) {
    // 这里简化实现，实际应用中应该根据用户角色、数据类型等进行复杂判断
    const policy = this.config.accessControl.policies[operation] || 
                  this.config.accessControl.defaultPolicy;
    
    return {
      allowed: policy === 'allow',
      reason: policy === 'deny' ? '默认拒绝策略' : '允许访问'
    };
  }
  
  /**
   * 记录访问日志
   */
  logAccess(data, operation) {
    if (!this.config.audit.enabled) return;
    
    const logEntry = {
      timestamp: new Date().toISOString(),
      operation,
      dataType: Array.isArray(data) ? 'array' : typeof data,
      // 不记录敏感字段值
      dataKeys: Object.keys(data).filter(key => 
        !this.config.audit.excludeFields.some(exclude => 
          key.toLowerCase().includes(exclude.toLowerCase())
        )
      )
    };
    
    this.accessLogs.push(logEntry);
    
    // 限制日志数量
    if (this.accessLogs.length > 1000) {
      this.accessLogs = this.accessLogs.slice(-500);
    }
    
    // 根据日志级别输出
    switch (this.config.audit.logLevel) {
      case 'debug':
        console.debug('数据访问日志:', logEntry);
        break;
      case 'info':
        console.info('数据访问日志:', logEntry);
        break;
      case 'warn':
        console.warn('数据访问日志:', logEntry);
        break;
      case 'error':
        console.error('数据访问日志:', logEntry);
        break;
    }
  }
  
  /**
   * 获取访问日志
   */
  getAccessLogs(filter = {}) {
    let logs = [...this.accessLogs];
    
    if (filter.operation) {
      logs = logs.filter(log => log.operation === filter.operation);
    }
    
    if (filter.startTime) {
      logs = logs.filter(log => new Date(log.timestamp) >= new Date(filter.startTime));
    }
    
    if (filter.endTime) {
      logs = logs.filter(log => new Date(log.timestamp) <= new Date(filter.endTime));
    }
    
    return logs;
  }
  
  /**
   * 清除访问日志
   */
  clearAccessLogs() {
    this.accessLogs = [];
  }
  
  /**
   * 清除加密缓存
   */
  clearEncryptionCache() {
    this.encryptionCache.clear();
  }
}

// 内存存储实现
class MemoryStorage {
  constructor() {
    this.data = new Map();
  }
  
  getItem(key) {
    return this.data.get(key) || null;
  }
  
  setItem(key, value) {
    this.data.set(key, value);
  }
  
  removeItem(key) {
    this.data.delete(key);
  }
  
  clear() {
    this.data.clear();
  }
}

// 使用示例
const cryptoManager = new CryptographyManager({
  algorithm: 'AES-GCM',
  keyLength: 256,
  keyStorage: 'sessionStorage',
  keyRotationInterval: 24 * 60 * 60 * 1000 // 24小时
});

const dataSecurityManager = new DataSecurityManager(cryptoManager, {
  sensitiveFields: [
    'password', 'token', 'secret', 'key', 'creditCard', 
    'ssn', 'socialSecurityNumber', 'bankAccount', 'phoneNumber', 'email'
  ],
  autoEncryptSensitiveData: true,
  autoMaskSensitiveData: true,
  accessControl: {
    enabled: true,
    defaultPolicy: 'allow',
    policies: {
      'write': 'allow',
      'delete': 'deny'
    }
  },
  audit: {
    enabled: true,
    logLevel: 'info',
    excludeFields: ['password', 'token', 'secret']
  }
});

// 示例数据
const userData = {
  id: '12345',
  username: 'john.doe',
  email: 'john.doe@example.com',
  phoneNumber: '12345678901',
  password: 'super-secret-password',
  profile: {
    firstName: 'John',
    lastName: 'Doe',
    address: {
      street: '123 Main St',
      city: 'Anytown',
      zipCode: '12345'
    }
  }
};

// 处理读取操作
async function handleReadData() {
  try {
    const maskedData = await dataSecurityManager.processData(userData, 'read');
    console.log('脱敏后的数据:', maskedData);
    return maskedData;
  } catch (error) {
    console.error('读取数据处理失败:', error);
  }
}

// 处理写入操作
async function handleWriteData() {
  try {
    const encryptedData = await dataSecurityManager.processData(userData, 'write');
    console.log('加密后的数据:', encryptedData);
    return encryptedData;
  } catch (error) {
    console.error('写入数据处理失败:', error);
  }
}

// 直接加密数据
async function encryptData(data) {
  try {
    const encrypted = await cryptoManager.encrypt(data);
    console.log('加密结果:', encrypted);
    return encrypted;
  } catch (error) {
    console.error('数据加密失败:', error);
  }
}

// 直接解密数据
async function decryptData(encryptedData) {
  try {
    const decrypted = await cryptoManager.decrypt(encryptedData);
    console.log('解密结果:', decrypted);
    return decrypted;
  } catch (error) {
    console.error('数据解密失败:', error);
  }
}

// 计算数据哈希
async function hashData(data) {
  try {
    const hash = await cryptoManager.hash(data);
    console.log('哈希结果:', hash);
    return hash;
  } catch (error) {
    console.error('哈希计算失败:', error);
  }
}

// 示例使用
handleReadData();
handleWriteData();

// 加密示例
encryptData('这是敏感数据').then(encrypted => {
  decryptData(encrypted);
});

// 哈希示例
hashData('这是要验证的数据');

// 监听密钥轮换事件
cryptoManager.on('key-rotated', ({ oldKey, newKey }) => {
  console.log('密钥已轮换');
  
  // 重新加密使用旧密钥加密的数据
  // 这里应该有重新加密所有数据的逻辑
});

// 获取访问日志
const logs = dataSecurityManager.getAccessLogs({
  operation: 'read',
  startTime: new Date(Date.now() - 24 * 60 * 60 * 1000) // 最近24小时
});
console.log('访问日志:', logs);
```

## 10.5 安全最佳实践

### 10.5.1 代码安全最佳实践

在微前端开发中，遵循以下代码安全最佳实践：

1. **输入验证与输出编码**：
   - 对所有用户输入进行验证和清理
   - 对输出到HTML的内容进行适当编码
   - 使用安全的API进行DOM操作

2. **依赖安全管理**：
   - 定期扫描第三方依赖的安全漏洞
   - 使用固定版本号避免依赖自动更新带来的风险
   - 使用内容安全策略(CSP)限制第三方脚本执行

3. **安全编码规范**：
   - 避免使用eval()、Function()等危险函数
   - 谨慎使用innerHTML、outerHTML等属性
   - 使用textContent代替innerHTML处理文本内容

4. **错误处理**：
   - 避免在生产环境暴露敏感错误信息
   - 实现统一的错误处理机制
   - 记录安全相关错误但不暴露详细信息

5. **API安全**：
   - 使用HTTPS进行所有API通信
   - 实现适当的API认证和授权
   - 对API请求进行速率限制

### 10.5.2 配置安全最佳实践

1. **环境配置安全**：
   - 使用环境变量存储敏感配置
   - 区分开发和生产环境配置
   - 定期轮换密钥和令牌

2. **构建与部署安全**：
   - 实施代码审查流程
   - 使用自动化安全扫描工具
   - 确保构建过程的安全性

3. **运行时安全**：
   - 配置适当的内容安全策略(CSP)
   - 实现跨域资源共享(CORS)策略
   - 使用安全的Cookie设置

### 10.5.3 安全最佳实践实现

以下是一个微前端安全最佳实践的综合实现：

```javascript
/**
 * 微前端安全最佳实践管理器
 */
class SecurityBestPracticesManager {
  constructor(config = {}) {
    this.config = {
      // 输入验证配置
      inputValidation: {
        enabled: true,
        // 允许的HTML标签
        allowedTags: ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li'],
        // 允许的属性
        allowedAttributes: ['class', 'id'],
        // 最大输入长度
        maxLength: 10000,
        // 自定义验证规则
        customValidators: {}
      },
      // 依赖安全配置
      dependencySecurity: {
        enabled: true,
        // 依赖扫描间隔（毫秒）
        scanInterval: 24 * 60 * 60 * 1000, // 24小时
        // 漏洞数据库URL
        vulnerabilityDbUrl: 'https://services.nvd.nist.gov/rest/json/cves/1.0',
        // 忽略的漏洞
        ignoredVulnerabilities: []
      },
      // CSP配置
      csp: {
        enabled: true,
        // 默认策略
        defaultSrc: "'self'",
        // 脚本策略
        scriptSrc: ["'self'", "'unsafe-inline'"],
        // 样式策略
        styleSrc: ["'self'", "'unsafe-inline'"],
        // 图片策略
        imgSrc: ["'self'", "data:", "https:"],
        // 连接策略
        connectSrc: ["'self'"],
        // 字体策略
        fontSrc: ["'self'"],
        // 对象策略
        objectSrc: "'none'",
        // 媒体策略
        mediaSrc: "'self'",
        // 框架策略
        frameSrc: "'none'",
        // 自定义策略
        customDirectives: {}
      },
      // CORS配置
      cors: {
        enabled: true,
        // 允许的源
        allowedOrigins: ["'self'"],
        // 允许的方法
        allowedMethods: ['GET', 'POST', 'PUT', 'DELETE'],
        // 允许的头部
        allowedHeaders: ['Content-Type', 'Authorization'],
        // 暴露的头部
        exposedHeaders: [],
        // 允许凭证
        allowCredentials: false,
        // 预检请求缓存时间（秒）
        maxAge: 86400
      },
      // 错误处理配置
      errorHandling: {
        enabled: true,
        // 是否记录错误
        logErrors: true,
        // 是否显示错误详情
        showErrorDetails: false,
        // 错误上报URL
        errorReportingUrl: null,
        // 错误上报间隔（毫秒）
        errorReportingInterval: 60000, // 1分钟
        // 忽略的错误类型
        ignoredErrorTypes: []
      },
      // 安全监控配置
      securityMonitoring: {
        enabled: true,
        // 监控事件
        monitoredEvents: [
          'securitypolicyviolation',
          'unhandledrejection',
          'error'
        ],
        // 异常行为检测阈值
        anomalyThresholds: {
          // 每分钟错误数阈值
          errorsPerMinute: 10,
          // 每分钟安全策略违规数阈值
          cspViolationsPerMinute: 5,
          // 每分钟未处理的Promise拒绝数阈值
          rejectionsPerMinute: 5
        }
      },
      ...config
    };
    
    // 安全事件计数器
    this.eventCounters = {
      errors: [],
      cspViolations: [],
      rejections: []
    };
    
    // 错误上报队列
    this.errorQueue = [];
    // 错误上报定时器
    this.errorReportingTimer = null;
    
    this.init();
  }
  
  /**
   * 初始化安全管理器
   */
  init() {
    // 初始化输入验证
    if (this.config.inputValidation.enabled) {
      this.initInputValidation();
    }
    
    // 初始化依赖安全扫描
    if (this.config.dependencySecurity.enabled) {
      this.initDependencySecurity();
    }
    
    // 初始化CSP
    if (this.config.csp.enabled) {
      this.initCSP();
    }
    
    // 初始化CORS
    if (this.config.cors.enabled) {
      this.initCORS();
    }
    
    // 初始化错误处理
    if (this.config.errorHandling.enabled) {
      this.initErrorHandling();
    }
    
    // 初始化安全监控
    if (this.config.securityMonitoring.enabled) {
      this.initSecurityMonitoring();
    }
  }
  
  /**
   * 初始化输入验证
   */
  initInputValidation() {
    // 添加输入验证函数到全局
    window.validateInput = (input, options = {}) => {
      return this.validateInput(input, options);
    };
    
    // 添加安全HTML函数到全局
    window.sanitizeHTML = (html, options = {}) => {
      return this.sanitizeHTML(html, options);
    };
    
    // 添加安全编码函数到全局
    window.encodeForHTML = (str) => {
      return this.encodeForHTML(str);
    };
  }
  
  /**
   * 验证输入
   */
  validateInput(input, options = {}) {
    const config = { ...this.config.inputValidation, ...options };
    
    // 检查输入长度
    if (input.length > config.maxLength) {
      throw new Error(`输入长度超过限制: ${input.length} > ${config.maxLength}`);
    }
    
    // 应用自定义验证器
    for (const [name, validator] of Object.entries(config.customValidators)) {
      if (!validator(input)) {
        throw new Error(`自定义验证失败: ${name}`);
      }
    }
    
    return true;
  }
  
  /**
   * 清理HTML
   */
  sanitizeHTML(html, options = {}) {
    const config = { ...this.config.inputValidation, ...options };
    
    // 创建临时DOM元素
    const temp = document.createElement('div');
    temp.innerHTML = html;
    
    // 递归清理元素
    const sanitizeNode = (node) => {
      // 处理元素节点
      if (node.nodeType === Node.ELEMENT_NODE) {
        const tagName = node.tagName.toLowerCase();
        
        // 检查标签是否允许
        if (!config.allowedTags.includes(tagName)) {
          // 将不允许的元素替换为其文本内容
          const textNode = document.createTextNode(node.textContent);
          node.parentNode.replaceChild(textNode, node);
          return;
        }
        
        // 清理属性
        const attributes = Array.from(node.attributes);
        for (const attr of attributes) {
          if (!config.allowedAttributes.includes(attr.name)) {
            node.removeAttribute(attr.name);
          }
        }
      }
      
      // 递归处理子节点
      const children = Array.from(node.childNodes);
      for (const child of children) {
        sanitizeNode(child);
      }
    };
    
    // 清理所有子节点
    const children = Array.from(temp.childNodes);
    for (const child of children) {
      sanitizeNode(child);
    }
    
    return temp.innerHTML;
  }
  
  /**
   * HTML编码
   */
  encodeForHTML(str) {
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }
  
  /**
   * 初始化依赖安全扫描
   */
  initDependencySecurity() {
    // 启动定期扫描
    setInterval(() => {
      this.scanDependencies();
    }, this.config.dependencySecurity.scanInterval);
    
    // 立即执行一次扫描
    this.scanDependencies();
  }
  
  /**
   * 扫描依赖漏洞
   */
  async scanDependencies() {
    try {
      // 获取package.json
      const packageJsonResponse = await fetch('/package.json');
      const packageJson = await packageJsonResponse.json();
      
      // 获取所有依赖
      const dependencies = {
        ...packageJson.dependencies,
        ...packageJson.devDependencies
      };
      
      // 检查每个依赖的漏洞
      const vulnerabilities = [];
      
      for (const [name, version] of Object.entries(dependencies)) {
        const vulns = await this.checkVulnerability(name, version);
        if (vulns.length > 0) {
          vulnerabilities.push({ name, version, vulnerabilities: vulns });
        }
      }
      
      // 报告漏洞
      if (vulnerabilities.length > 0) {
        console.warn('发现依赖漏洞:', vulnerabilities);
        this.emit('vulnerabilities-found', vulnerabilities);
      }
      
      return vulnerabilities;
    } catch (error) {
      console.error('依赖扫描失败:', error);
      this.emit('dependency-scan-error', error);
      return [];
    }
  }
  
  /**
   * 检查特定依赖的漏洞
   */
  async checkVulnerability(name, version) {
    try {
      // 这里简化实现，实际应用中应该调用专业的漏洞数据库API
      // 例如Snyk、OSS Index等
      
      // 模拟API调用
      const response = await fetch(
        `${this.config.dependencySecurity.vulnerabilityDbUrl}?keyword=${name}`
      );
      
      if (!response.ok) {
        throw new Error(`API请求失败: ${response.status}`);
      }
      
      const data = await response.json();
      
      // 筛选相关漏洞
      const vulnerabilities = data.result.CVE_Items.filter(item => {
        // 检查漏洞是否影响当前版本
        // 这里简化实现，实际应该使用更复杂的版本比较逻辑
        return item.cve.description.description_data.some(desc => 
          desc.value.toLowerCase().includes(name.toLowerCase())
        );
      });
      
      // 过滤忽略的漏洞
      return vulnerabilities.filter(vuln => 
        !this.config.dependencySecurity.ignoredVulnerabilities.includes(vuln.cve.CVE_data_meta.ID)
      );
    } catch (error) {
      console.error(`检查依赖漏洞失败 (${name}@${version}):`, error);
      return [];
    }
  }
  
  /**
   * 初始化CSP
   */
  initCSP() {
    // 构建CSP策略
    const cspPolicy = this.buildCSPPolicy();
    
    // 应用CSP策略
    const meta = document.createElement('meta');
    meta.httpEquiv = 'Content-Security-Policy';
    meta.content = cspPolicy;
    document.head.appendChild(meta);
    
    // 监听CSP违规事件
    document.addEventListener('securitypolicyviolation', (event) => {
      this.handleCSPViolation(event);
    });
  }
  
  /**
   * 构建CSP策略
   */
  buildCSPPolicy() {
    const csp = this.config.csp;
    let policy = [];
    
    // 默认策略
    policy.push(`default-src ${csp.defaultSrc}`);
    
    // 脚本策略
    policy.push(`script-src ${csp.scriptSrc.join(' ')}`);
    
    // 样式策略
    policy.push(`style-src ${csp.styleSrc.join(' ')}`);
    
    // 图片策略
    policy.push(`img-src ${csp.imgSrc.join(' ')}`);
    
    // 连接策略
    policy.push(`connect-src ${csp.connectSrc.join(' ')}`);
    
    // 字体策略
    policy.push(`font-src ${csp.fontSrc.join(' ')}`);
    
    // 对象策略
    policy.push(`object-src ${csp.objectSrc}`);
    
    // 媒体策略
    policy.push(`media-src ${csp.mediaSrc}`);
    
    // 框架策略
    policy.push(`frame-src ${csp.frameSrc}`);
    
    // 自定义指令
    for (const [directive, value] of Object.entries(csp.customDirectives)) {
      policy.push(`${directive} ${value}`);
    }
    
    return policy.join('; ');
  }
  
  /**
   * 处理CSP违规事件
   */
  handleCSPViolation(event) {
    // 记录违规事件
    const violation = {
      timestamp: new Date().toISOString(),
      blockedURI: event.blockedURI,
      documentURI: event.documentURI,
      referrer: event.referrer,
      violatedDirective: event.violatedDirective,
      effectiveDirective: event.effectiveDirective,
      originalPolicy: event.originalPolicy,
      sourceFile: event.sourceFile,
      lineNumber: event.lineNumber,
      columnNumber: event.columnNumber,
      statusCode: event.statusCode
    };
    
    // 添加到计数器
    this.eventCounters.cspViolations.push(violation);
    
    // 限制计数器大小
    if (this.eventCounters.cspViolations.length > 100) {
      this.eventCounters.cspViolations = this.eventCounters.cspViolations.slice(-50);
    }
    
    // 检查是否超过阈值
    this.checkAnomalyThresholds();
    
    // 发出事件
    this.emit('csp-violation', violation);
    
    // 记录日志
    console.warn('CSP违规:', violation);
  }
  
  /**
   * 初始化CORS
   */
  initCORS() {
    // 在实际应用中，CORS通常在服务器端配置
    // 这里提供客户端CORS请求的安全封装
    
    // 添加安全的fetch函数到全局
    window.secureFetch = (url, options = {}) => {
      return this.secureFetch(url, options);
    };
  }
  
  /**
   * 安全的fetch函数
   */
  async secureFetch(url, options = {}) {
    // 检查URL是否在允许的源列表中
    const urlObj = new URL(url, window.location.origin);
    const origin = urlObj.origin;
    
    if (!this.isAllowedOrigin(origin)) {
      throw new Error(`不允许的请求源: ${origin}`);
    }
    
    // 设置默认选项
    const secureOptions = {
      // 不包含凭证
      credentials: this.config.cors.allowCredentials ? 'include' : 'omit',
      // 设置适当的头部
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      ...options
    };
    
    try {
      const response = await fetch(url, secureOptions);
      
      // 检查响应状态
      if (!response.ok) {
        throw new Error(`请求失败: ${response.status} ${response.statusText}`);
      }
      
      return response;
    } catch (error) {
      console.error('安全请求失败:', error);
      throw error;
    }
  }
  
  /**
   * 检查源是否被允许
   */
  isAllowedOrigin(origin) {
    const allowedOrigins = this.config.cors.allowedOrigins;
    
    // 检查是否在允许列表中
    for (const allowedOrigin of allowedOrigins) {
      if (allowedOrigin === "'self'" && origin === window.location.origin) {
        return true;
      } else if (allowedOrigin !== "'self'" && origin === allowedOrigin) {
        return true;
      }
    }
    
    return false;
  }
  
  /**
   * 初始化错误处理
   */
  initErrorHandling() {
    // 监听全局错误
    window.addEventListener('error', (event) => {
      this.handleError(event.error || new Error(event.message), {
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno
      });
    });
    
    // 监听未处理的Promise拒绝
    window.addEventListener('unhandledrejection', (event) => {
      this.handleRejection(event.reason);
    });
    
    // 启动错误上报定时器
    this.startErrorReporting();
  }
  
  /**
   * 处理错误
   */
  handleError(error, context = {}) {
    // 检查是否应该忽略此错误类型
    if (this.shouldIgnoreError(error)) {
      return;
    }
    
    // 创建错误对象
    const errorInfo = {
      timestamp: new Date().toISOString(),
      message: error.message,
      stack: error.stack,
      ...context
    };
    
    // 添加到计数器
    this.eventCounters.errors.push(errorInfo);
    
    // 限制计数器大小
    if (this.eventCounters.errors.length > 100) {
      this.eventCounters.errors = this.eventCounters.errors.slice(-50);
    }
    
    // 检查是否超过阈值
    this.checkAnomalyThresholds();
    
    // 记录日志
    if (this.config.errorHandling.logErrors) {
      console.error('应用错误:', errorInfo);
    }
    
    // 添加到上报队列
    this.errorQueue.push(errorInfo);
    
    // 发出事件
    this.emit('error', errorInfo);
    
    // 显示用户友好的错误信息
    if (this.config.errorHandling.showErrorDetails) {
      this.showUserError(error);
    }
  }
  
  /**
   * 处理Promise拒绝
   */
  handleRejection(reason) {
    // 检查是否应该忽略此拒绝类型
    if (this.shouldIgnoreRejection(reason)) {
      return;
    }
    
    // 创建拒绝对象
    const rejectionInfo = {
      timestamp: new Date().toISOString(),
      reason: reason instanceof Error ? reason.message : String(reason),
      stack: reason instanceof Error ? reason.stack : null
    };
    
    // 添加到计数器
    this.eventCounters.rejections.push(rejectionInfo);
    
    // 限制计数器大小
    if (this.eventCounters.rejections.length > 100) {
      this.eventCounters.rejections = this.eventCounters.rejections.slice(-50);
    }
    
    // 检查是否超过阈值
    this.checkAnomalyThresholds();
    
    // 记录日志
    console.warn('未处理的Promise拒绝:', rejectionInfo);
    
    // 添加到上报队列
    this.errorQueue.push(rejectionInfo);
    
    // 发出事件
    this.emit('rejection', rejectionInfo);
  }
  
  /**
   * 检查是否应该忽略错误
   */
  shouldIgnoreError(error) {
    return this.config.errorHandling.ignoredErrorTypes.some(type => 
      error instanceof Error && error.name === type
    );
  }
  
  /**
   * 检查是否应该忽略Promise拒绝
   */
  shouldIgnoreRejection(reason) {
    return this.config.errorHandling.ignoredErrorTypes.some(type => 
      reason instanceof Error && reason.name === type
    );
  }
  
  /**
   * 显示用户友好的错误信息
   */
  showUserError(error) {
    // 创建错误提示元素
    const errorElement = document.createElement('div');
    errorElement.className = 'security-error-notification';
    errorElement.textContent = '应用发生错误，请刷新页面重试';
    errorElement.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #f44336;
      color: white;
      padding: 10px 20px;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 9999;
      max-width: 300px;
    `;
    
    // 添加关闭按钮
    const closeButton = document.createElement('button');
    closeButton.textContent = '×';
    closeButton.style.cssText = `
      background: none;
      border: none;
      color: white;
      font-size: 16px;
      margin-left: 10px;
      cursor: pointer;
    `;
    
    closeButton.addEventListener('click', () => {
      document.body.removeChild(errorElement);
    });
    
    errorElement.appendChild(closeButton);
    document.body.appendChild(errorElement);
    
    // 自动关闭
    setTimeout(() => {
      if (document.body.contains(errorElement)) {
        document.body.removeChild(errorElement);
      }
    }, 5000);
  }
  
  /**
   * 启动错误上报
   */
  startErrorReporting() {
    if (!this.config.errorHandling.errorReportingUrl) {
      return;
    }
    
    // 启动定时上报
    this.errorReportingTimer = setInterval(() => {
      this.reportErrors();
    }, this.config.errorHandling.errorReportingInterval);
  }
  
  /**
   * 上报错误
   */
  async reportErrors() {
    if (this.errorQueue.length === 0) {
      return;
    }
    
    // 复制并清空队列
    const errors = [...this.errorQueue];
    this.errorQueue = [];
    
    try {
      // 上报错误
      await fetch(this.config.errorHandling.errorReportingUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          errors,
          userAgent: navigator.userAgent,
          url: window.location.href,
          timestamp: new Date().toISOString()
        })
      });
    } catch (error) {
      console.error('错误上报失败:', error);
      // 将错误重新加入队列
      this.errorQueue.unshift(...errors);
    }
  }
  
  /**
   * 初始化安全监控
   */
  initSecurityMonitoring() {
    // 监听配置的事件
    for (const eventType of this.config.securityMonitoring.monitoredEvents) {
      document.addEventListener(eventType, (event) => {
        this.handleSecurityEvent(eventType, event);
      });
    }
    
    // 启动定期检查
    setInterval(() => {
      this.checkAnomalyThresholds();
    }, 60000); // 每分钟检查一次
  }
  
  /**
   * 处理安全事件
   */
  handleSecurityEvent(eventType, event) {
    // 创建事件对象
    const securityEvent = {
      timestamp: new Date().toISOString(),
      type: eventType,
      details: event
    };
    
    // 发出事件
    this.emit('security-event', securityEvent);
    
    // 记录日志
    console.warn('安全事件:', securityEvent);
  }
  
  /**
   * 检查异常阈值
   */
  checkAnomalyThresholds() {
    const now = Date.now();
    const oneMinuteAgo = now - 60000;
    const thresholds = this.config.securityMonitoring.anomalyThresholds;
    
    // 检查错误数
    const recentErrors = this.eventCounters.errors.filter(
      error => new Date(error.timestamp).getTime() > oneMinuteAgo
    );
    
    if (recentErrors.length > thresholds.errorsPerMinute) {
      this.emit('anomaly-detected', {
        type: 'high-error-rate',
        count: recentErrors.length,
        threshold: thresholds.errorsPerMinute
      });
    }
    
    // 检查CSP违规数
    const recentViolations = this.eventCounters.cspViolations.filter(
      violation => new Date(violation.timestamp).getTime() > oneMinuteAgo
    );
    
    if (recentViolations.length > thresholds.cspViolationsPerMinute) {
      this.emit('anomaly-detected', {
        type: 'high-csp-violation-rate',
        count: recentViolations.length,
        threshold: thresholds.cspViolationsPerMinute
      });
    }
    
    // 检查Promise拒绝数
    const recentRejections = this.eventCounters.rejections.filter(
      rejection => new Date(rejection.timestamp).getTime() > oneMinuteAgo
    );
    
    if (recentRejections.length > thresholds.rejectionsPerMinute) {
      this.emit('anomaly-detected', {
        type: 'high-rejection-rate',
        count: recentRejections.length,
        threshold: thresholds.rejectionsPerMinute
      });
    }
  }
  
  /**
   * 添加事件监听器
   */
  on(event, callback) {
    if (!this.eventListeners) {
      this.eventListeners = new Map();
    }
    
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, []);
    }
    this.eventListeners.get(event).push(callback);
  }
  
  /**
   * 移除事件监听器
   */
  off(event, callback) {
    if (this.eventListeners && this.eventListeners.has(event)) {
      const listeners = this.eventListeners.get(event);
      const index = listeners.indexOf(callback);
      if (index !== -1) {
        listeners.splice(index, 1);
      }
    }
  }
  
  /**
   * 发出事件
   */
  emit(event, data) {
    if (this.eventListeners && this.eventListeners.has(event)) {
      this.eventListeners.get(event).forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`事件处理器执行失败 (${event}):`, error);
        }
      });
    }
  }
  
  /**
   * 获取安全状态
   */
  getSecurityStatus() {
    return {
      inputValidation: this.config.inputValidation.enabled,
      dependencySecurity: this.config.dependencySecurity.enabled,
      csp: this.config.csp.enabled,
      cors: this.config.cors.enabled,
      errorHandling: this.config.errorHandling.enabled,
      securityMonitoring: this.config.securityMonitoring.enabled,
      eventCounters: {
        errors: this.eventCounters.errors.length,
        cspViolations: this.eventCounters.cspViolations.length,
        rejections: this.eventCounters.rejections.length
      },
      errorQueueSize: this.errorQueue.length
    };
  }
  
  /**
   * 清理资源
   */
  cleanup() {
    // 清除错误上报定时器
    if (this.errorReportingTimer) {
      clearInterval(this.errorReportingTimer);
      this.errorReportingTimer = null;
    }
    
    // 上报剩余错误
    this.reportErrors();
  }
}

// 使用示例
const securityManager = new SecurityBestPracticesManager({
  inputValidation: {
    enabled: true,
    maxLength: 5000,
    allowedTags: ['p', 'br', 'strong', 'em'],
    customValidators: {
      noScript: (input) => !/<script/i.test(input),
      noIframe: (input) => !/<iframe/i.test(input)
    }
  },
  csp: {
    enabled: true,
    defaultSrc: "'self'",
    scriptSrc: ["'self'"],
    styleSrc: ["'self'", "'unsafe-inline'"],
    imgSrc: ["'self'", "data:", "https:"],
    connectSrc: ["'self'"],
    customDirectives: {
      'upgrade-insecure-requests': ''
    }
  },
  errorHandling: {
    enabled: true,
    logErrors: true,
    showErrorDetails: false,
    errorReportingUrl: '/api/errors',
    ignoredErrorTypes: ['ChunkLoadError']
  },
  securityMonitoring: {
    enabled: true,
    anomalyThresholds: {
      errorsPerMinute: 5,
      cspViolationsPerMinute: 2,
      rejectionsPerMinute: 3
    }
  }
});

// 监听安全事件
securityManager.on('csp-violation', (violation) => {
  console.warn('CSP违规检测:', violation);
});

securityManager.on('vulnerabilities-found', (vulnerabilities) => {
  console.warn('依赖漏洞检测:', vulnerabilities);
});

securityManager.on('anomaly-detected', (anomaly) => {
  console.warn('异常行为检测:', anomaly);
});

// 示例：验证用户输入
try {
  const userInput = '<script>alert("XSS")</script>';
  securityManager.validateInput(userInput);
} catch (error) {
  console.error('输入验证失败:', error.message);
}

// 示例：清理HTML
const unsafeHTML = '<div><script>alert("XSS")</script><p>安全内容</p></div>';
const safeHTML = securityManager.sanitizeHTML(unsafeHTML);
console.log('清理后的HTML:', safeHTML);

// 示例：安全编码
const unsafeString = '<script>alert("XSS")</script>';
const safeString = securityManager.encodeForHTML(unsafeString);
console.log('编码后的字符串:', safeString);

// 示例：安全请求
try {
  const response = await securityManager.secureFetch('/api/data', {
    method: 'POST',
    body: JSON.stringify({ data: 'example' })
  });
  const data = await response.json();
  console.log('请求成功:', data);
} catch (error) {
  console.error('安全请求失败:', error);
}

// 获取安全状态
const securityStatus = securityManager.getSecurityStatus();
console.log('安全状态:', securityStatus);

// 页面卸载时清理资源
window.addEventListener('beforeunload', () => {
  securityManager.cleanup();
});
```

## 10.6 总结

微前端安全是一个复杂而重要的领域，需要从多个维度进行全面考虑。本章介绍了微前端安全的关键方面，包括安全概述、安全架构设计、身份认证与授权、数据安全与加密以及安全最佳实践。

### 10.6.1 微前端安全的重要性

微前端架构的安全挑战主要来自于：

1. **攻击面扩大**：多个微应用增加了潜在的安全风险点。
2. **第三方依赖风险**：每个微应用可能引入不同的第三方依赖。
3. **跨应用通信**：微应用间的数据交换增加了安全风险。
4. **运行时隔离**：确保微应用间的安全隔离是关键挑战。
5. **统一安全策略**：在分布式架构中实施统一的安全策略。

### 10.6.2 微前端安全的关键要素

1. **安全架构设计**：
   - 深度防御原则
   - 最小权限原则
   - 安全默认设置
   - 零信任架构
   - 纵深防御
   - 安全分层

2. **身份认证与授权**：
   - 集中式认证
   - 令牌传递
   - 单点登录
   - 权限控制
   - 会话管理
   - 多因素认证

3. **数据安全与加密**：
   - 数据加密
   - 数据脱敏
   - 访问控制
   - 安全传输
   - 生命周期管理
   - 数据审计

4. **安全最佳实践**：
   - 代码安全
   - 配置安全
   - 依赖安全
   - 错误处理
   - 安全监控
   - 异常检测

### 10.6.3 微前端安全实践建议

1. **建立全面的安全策略**：从架构设计到实现细节，全面考虑安全因素。

2. **实施最小权限原则**：确保每个微应用只拥有完成其功能所需的最小权限。

3. **加强数据保护**：对敏感数据进行加密和脱敏处理，严格控制数据访问。

4. **定期安全审计**：定期进行安全扫描和审计，及时发现和修复安全漏洞。

5. **建立安全监控体系**：实时监控安全事件，及时发现异常行为。

6. **持续安全培训**：提高开发团队的安全意识和技能。

通过实施这些安全措施，可以大大提高微前端应用的安全性，保护用户数据和系统资源，确保应用的稳定运行。安全是一个持续的过程，需要不断更新和改进安全策略，以应对不断变化的安全威胁。
}

// 使用示例
const cspManager = new MicroFrontendCSPManager({
  defaultPolicy: {
    'default-src': ["'self'"],
    'script-src': ["'self'", "'unsafe-inline'"],
    'style-src': ["'self'", "'unsafe-inline'"],
    'img-src': ["'self'", 'data:', 'https:'],
    'connect-src': ["'self'"]
  },
  appPolicies: {
    'app1': {
      'script-src': ["'self'", "'unsafe-inline'", 'https://cdn.trusted.com'],
      'connect-src': ["'self'", 'https://api.app1.com']
    },
    'app2': {
      'script-src': ["'self'", "'unsafe-inline'", 'https://cdn.trusted.com'],
      'connect-src': ["'self'", 'https://api.app2.com']
    }
  },
  reportOnly: false,
  reportURI: '/api/csp-report'
});
```

### 10.2.2 安全沙箱实现

安全的JavaScript沙箱是微前端安全的核心：

```javascript
// 安全沙箱实现
class SecureSandbox {
  constructor(options = {}) {
    this.options = {
      // 是否启用严格模式
      strictMode: options.strictMode !== false,
      // 是否允许eval
      allowEval: options.allowEval || false,
      // 是否允许Function构造函数
      allowFunctionConstructor: options.allowFunctionConstructor || false,
      // 是否允许定时器
      allowTimers: options.allowTimers !== false,
      // 是否允许XMLHttpRequest
      allowXHR: options.allowXHR !== false,
      // 是否允许fetch
      allowFetch: options.allowFetch !== false,
      // 是否允许WebSocket
      allowWebSocket: options.allowWebSocket || false,
      // 是否允许localStorage
      allowLocalStorage: options.allowLocalStorage !== false,
      // 是否允许sessionStorage
      allowSessionStorage: options.allowSessionStorage !== false,
      // 是否允许indexedDB
      allowIndexedDB: options.allowIndexedDB || false,
      // 白名单域名
      whitelist: options.whitelist || [],
      // 黑名单域名
      blacklist: options.blacklist || [],
      // 自定义安全检查函数
      customSecurityCheck: options.customSecurityCheck || null,
      ...options
    };
    
    this.sandboxWindow = null;
    this.originalWindow = window;
    this.securedObjects = new Map();
    this.eventListeners = new Map();
    
    this.init();
  }
  
  // 初始化沙箱
  init() {
    // 创建沙箱环境
    this.createSandboxEnvironment();
    
    // 拦截危险API
    this.interceptDangerousAPIs();
    
    // 设置安全检查
    this.setupSecurityChecks();
  }
  
  // 创建沙箱环境
  createSandboxEnvironment() {
    // 创建iframe作为沙箱容器
    const iframe = document.createElement('iframe');
    iframe.style.display = 'none';
    document.body.appendChild(iframe);
    
    // 获取iframe的window对象作为沙箱环境
    this.sandboxWindow = iframe.contentWindow;
    
    // 重置iframe内容，确保是干净的环境
    iframe.src = 'about:blank';
    
    // 等待iframe加载完成
    iframe.onload = () => {
      this.setupSandboxWindow();
    };
  }
  
  // 设置沙箱window
  setupSandboxWindow() {
    // 保存原始window的引用
    this.originalWindow = window;
    
    // 创建代理对象
    const sandboxProxy = new Proxy(this.sandboxWindow, {
      get: (target, prop) => {
        // 检查属性访问权限
        if (!this.isPropertyAllowed(prop)) {
          return undefined;
        }
        
        const value = target[prop];
        
        // 如果是函数，需要绑定到沙箱环境
        if (typeof value === 'function') {
          return this.createSecureFunction(value, prop);
        }
        
        // 如果是对象，需要递归代理
        if (value && typeof value === 'object') {
          return this.createSecureProxy(value, prop);
        }
        
        return value;
      },
      
      set: (target, prop, value) => {
        // 检查属性设置权限
        if (!this.isPropertyAllowed(prop)) {
          throw new Error(`Setting property '${prop}' is not allowed in the sandbox`);
        }
        
        target[prop] = value;
        return true;
      },
      
      has: (target, prop) => {
        return this.isPropertyAllowed(prop) && prop in target;
      },
      
      deleteProperty: (target, prop) => {
        if (!this.isPropertyAllowed(prop)) {
          throw new Error(`Deleting property '${prop}' is not allowed in the sandbox`);
        }
        
        delete target[prop];
        return true;
      }
    });
    
    // 替换全局window引用
    this.sandboxWindow = sandboxProxy;
  }
  
  // 检查属性是否允许访问
  isPropertyAllowed(prop) {
    // 禁止访问的属性列表
    const forbiddenProps = [
      'top', 'parent', 'frames', 'self', 'window',
      'document', 'location', 'history', 'navigator'
    ];
    
    // 检查是否在禁止列表中
    if (forbiddenProps.includes(prop)) {
      return false;
    }
    
    // 检查是否以_开头，通常表示内部属性
    if (typeof prop === 'string' && prop.startsWith('_')) {
      return false;
    }
    
    // 检查是否是危险API
    if (this.isDangerousAPI(prop)) {
      return false;
    }
    
    // 执行自定义安全检查
    if (this.options.customSecurityCheck) {
      return this.options.customSecurityCheck(prop);
    }
    
    return true;
  }
  
  // 检查是否是危险API
  isDangerousAPI(prop) {
    const dangerousAPIs = {
      eval: !this.options.allowEval,
      Function: !this.options.allowFunctionConstructor,
      setTimeout: !this.options.allowTimers,
      setInterval: !this.options.allowTimers,
      setImmediate: !this.options.allowTimers,
      XMLHttpRequest: !this.options.allowXHR,
      fetch: !this.options.allowFetch,
      WebSocket: !this.options.allowWebSocket,
      localStorage: !this.options.allowLocalStorage,
      sessionStorage: !this.options.allowSessionStorage,
      indexedDB: !this.options.allowIndexedDB
    };
    
    return dangerousAPIs[prop] === true;
  }
  
  // 创建安全函数
  createSecureFunction(fn, name) {
    return (...args) => {
      // 检查函数调用权限
      if (!this.isFunctionCallAllowed(name, args)) {
        throw new Error(`Calling function '${name}' with these arguments is not allowed`);
      }
      
      // 执行函数
      return fn.apply(this.sandboxWindow, args);
    };
  }
  
  // 检查函数调用是否允许
  isFunctionCallAllowed(name, args) {
    // 特殊处理某些函数
    switch (name) {
      case 'setTimeout':
      case 'setInterval':
        // 检查回调函数是否安全
        if (args.length > 0 && typeof args[0] === 'string') {
          // 不允许字符串形式的回调
          return false;
        }
        break;
        
      case 'open':
        // 检查URL是否在白名单中
        if (args.length > 0 && typeof args[0] === 'string') {
          return this.isURLAllowed(args[0]);
        }
        break;
    }
    
    return true;
  }
  
  // 检查URL是否允许
  isURLAllowed(url) {
    try {
      const urlObj = new URL(url, window.location.href);
      const hostname = urlObj.hostname;
      
      // 检查黑名单
      if (this.options.blacklist.some(domain => hostname.includes(domain))) {
        return false;
      }
      
      // 检查白名单
      if (this.options.whitelist.length > 0) {
        return this.options.whitelist.some(domain => hostname.includes(domain));
      }
      
      // 默认允许同源请求
      return hostname === window.location.hostname;
    } catch (e) {
      return false;
    }
  }
  
  // 创建安全代理对象
  createSecureProxy(obj, name) {
    // 如果已经代理过，直接返回
    if (this.securedObjects.has(obj)) {
      return this.securedObjects.get(obj);
    }
    
    // 创建代理
    const proxy = new Proxy(obj, {
      get: (target, prop) => {
        const value = target[prop];
        
        // 如果是函数，需要绑定到沙箱环境
        if (typeof value === 'function') {
          return this.createSecureFunction(value, `${name}.${prop}`);
        }
        
        // 如果是对象，需要递归代理
        if (value && typeof value === 'object') {
          return this.createSecureProxy(value, `${name}.${prop}`);
        }
        
        return value;
      }
    });
    
    // 缓存代理对象
    this.securedObjects.set(obj, proxy);
    
    return proxy;
  }
  
  // 拦截危险API
  interceptDangerousAPIs() {
    // 拦截document
    this.sandboxWindow.document = this.createSecureDocumentProxy();
    
    // 拦截location
    this.sandboxWindow.location = this.createSecureLocationProxy();
    
    // 拦截navigator
    this.sandboxWindow.navigator = this.createSecureNavigatorProxy();
  }
  
  // 创建安全的document代理
  createSecureDocumentProxy() {
    return new Proxy(this.sandboxWindow.document, {
      get: (target, prop) => {
        // 允许访问的安全属性
        const allowedProps = [
          'createElement', 'getElementById', 'querySelector', 'querySelectorAll',
          'addEventListener', 'removeEventListener', 'body', 'head', 'title'
        ];
        
        if (!allowedProps.includes(prop)) {
          return undefined;
        }
        
        const value = target[prop];
        
        // 如果是函数，需要绑定到沙箱环境
        if (typeof value === 'function') {
          return this.createSecureFunction(value, `document.${prop}`);
        }
        
        return value;
      }
    });
  }
  
  // 创建安全的location代理
  createSecureLocationProxy() {
    return new Proxy(this.sandboxWindow.location, {
      get: (target, prop) => {
        // 只允许读取属性，不允许修改
        if (prop === 'href' || prop === 'hostname' || prop === 'pathname' || prop === 'search') {
          return target[prop];
        }
        
        return undefined;
      },
      
      set: (target, prop, value) => {
        // 不允许修改location
        throw new Error(`Modifying location.${prop} is not allowed in the sandbox`);
      }
    });
  }
  
  // 创建安全的navigator代理
  createSecureNavigatorProxy() {
    return new Proxy(this.sandboxWindow.navigator, {
      get: (target, prop) => {
        // 允许访问的安全属性
        const allowedProps = [
          'userAgent', 'language', 'languages', 'platform', 'cookieEnabled'
        ];
        
        if (!allowedProps.includes(prop)) {
          return undefined;
        }
        
        return target[prop];
      }
    });
  }
  
  // 设置安全检查
  setupSecurityChecks() {
    // 检查内存使用
    if (performance.memory) {
      const checkMemory = () => {
        const memoryUsage = performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit;
        if (memoryUsage > 0.8) {
          console.warn('High memory usage detected in sandbox:', memoryUsage);
          // 可以在这里采取一些措施，比如清理缓存或重启沙箱
        }
      };
      
      // 定期检查内存使用
      setInterval(checkMemory, 30000);
    }
    
    // 检查执行时间
    const checkExecutionTime = (fn) => {
      const start = performance.now();
      const result = fn();
      const duration = performance.now() - start;
      
      if (duration > 100) {
        console.warn(`Long execution time detected: ${duration}ms`);
      }
      
      return result;
    };
    
    // 包装函数执行
    this.sandboxWindow.eval = new Proxy(this.sandboxWindow.eval, {
      apply: (target, thisArg, args) => {
        return checkExecutionTime(() => target.apply(thisArg, args));
      }
    });
  }
  
  // 执行代码
  execute(code) {
    try {
      // 在沙箱环境中执行代码
      const func = new Function('window', 'document', 'navigator', 'location', code);
      return func(this.sandboxWindow, this.sandboxWindow.document, this.sandboxWindow.navigator, this.sandboxWindow.location);
    } catch (error) {
      console.error('Error executing code in sandbox:', error);
      throw error;
    }
  }
  
  // 销毁沙箱
  destroy() {
    // 清理事件监听器
    this.eventListeners.forEach((handlers, target) => {
      handlers.forEach(({ event, handler }) => {
        target.removeEventListener(event, handler);
      });
    });
    this.eventListeners.clear();
    
    // 清理代理对象
    this.securedObjects.clear();
    
    // 移除iframe
    if (this.sandboxWindow && this.sandboxWindow.frameElement) {
      document.body.removeChild(this.sandboxWindow.frameElement);
    }
    
    this.sandboxWindow = null;
  }
}

// 使用示例
const secureSandbox = new SecureSandbox({
  strictMode: true,
  allowEval: false,
  allowFunctionConstructor: false,
  allowTimers: true,
  allowXHR: true,
  allowFetch: true,
  allowWebSocket: false,
  allowLocalStorage: true,
  allowSessionStorage: true,
  allowIndexedDB: false,
  whitelist: ['api.example.com', 'cdn.example.com'],
  blacklist: ['malicious.com'],
  customSecurityCheck: (prop) => {
    // 自定义安全检查逻辑
    return !prop.startsWith('internal_');
  }
});

// 在沙箱中执行代码
try {
  secureSandbox.execute(`
    // 这里是微应用的代码
    console.log('Hello from sandbox!');
    document.body.innerHTML = '<h1>Secure Micro App</h1>';
  `);
} catch (error) {
  console.error('Failed to execute micro app:', error);
}
```

### 10.2.3 身份认证与授权

微前端环境下的身份认证与授权需要特别处理：

```javascript
// 微前端身份认证管理器
class MicroFrontendAuthManager {
  constructor(config) {
    this.config = {
      // 主应用的认证端点
      authEndpoint: config.authEndpoint || '/api/auth',
      // 令牌刷新端点
      refreshEndpoint: config.refreshEndpoint || '/api/auth/refresh',
      // 令牌存储键名
      tokenKey: config.tokenKey || 'micro_frontend_token',
      // 令牌过期前刷新时间（毫秒）
      refreshBeforeExpiry: config.refreshBeforeExpiry || 5 * 60 * 1000, // 5分钟
      // 是否启用自动刷新
      autoRefresh: config.autoRefresh !== false,
      // 权限检查端点
      permissionEndpoint: config.permissionEndpoint || '/api/permissions',
      // 微应用权限配置
      appPermissions: config.appPermissions || {},
      ...config
    };
    
    this.token = null;
    this.tokenExpiry = null;
    this.refreshTimer = null;
    this.permissionCache = new Map();
    this.authListeners = new Set();
    
    this.init();
  }
  
  // 初始化认证管理器
  init() {
    // 从存储中恢复令牌
    this.restoreToken();
    
    // 设置自动刷新
    if (this.config.autoRefresh) {
      this.setupAutoRefresh();
    }
    
    // 监听微应用事件
    this.listenToMicroAppEvents();
  }
  
  // 从存储中恢复令牌
  restoreToken() {
    try {
      const tokenData = localStorage.getItem(this.config.tokenKey);
      if (tokenData) {
        const { token, expiry } = JSON.parse(tokenData);
        
        // 检查令牌是否过期
        if (expiry && Date.now() < expiry) {
          this.token = token;
          this.tokenExpiry = expiry;
          
          // 设置自动刷新
          if (this.config.autoRefresh) {
            this.setupAutoRefresh();
          }
        } else {
          // 令牌已过期，清除
          this.clearToken();
        }
      }
    } catch (error) {
      console.error('Failed to restore token:', error);
      this.clearToken();
    }
  }
  
  // 设置自动刷新
  setupAutoRefresh() {
    // 清除现有定时器
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
    }
    
    if (!this.tokenExpiry) {
      return;
    }
    
    // 计算刷新时间
    const refreshTime = this.tokenExpiry - this.config.refreshBeforeExpiry;
    const delay = refreshTime - Date.now();
    
    if (delay > 0) {
      // 设置刷新定时器
      this.refreshTimer = setTimeout(() => {
        this.refreshToken();
      }, delay);
    } else {
      // 立即刷新
      this.refreshToken();
    }
  }
  
  // 监听微应用事件
  listenToMicroAppEvents() {
    // 监听认证请求
    window.addEventListener('micro-app-auth-request', (event) => {
      const { appName, callbackId } = event.detail;
      this.handleAuthRequest(appName, callbackId);
    });
    
    // 监听权限检查请求
    window.addEventListener('micro-app-permission-check', (event) => {
      const { appName, permission, callbackId } = event.detail;
      this.handlePermissionCheck(appName, permission, callbackId);
    });
  }
  
  // 处理认证请求
  async handleAuthRequest(appName, callbackId) {
    try {
      const token = await this.getValidToken();
      
      // 返回令牌
      window.dispatchEvent(new CustomEvent('micro-app-auth-response', {
        detail: {
          appName,
          callbackId,
          success: true,
          token
        }
      }));
    } catch (error) {
      console.error('Auth request failed:', error);
      
      // 返回错误
      window.dispatchEvent(new CustomEvent('micro-app-auth-response', {
        detail: {
          appName,
          callbackId,
          success: false,
          error: error.message
        }
      }));
    }
  }
  
  // 处理权限检查
  async handlePermissionCheck(appName, permission, callbackId) {
    try {
      const hasPermission = await this.checkPermission(appName, permission);
      
      // 返回结果
      window.dispatchEvent(new CustomEvent('micro-app-permission-response', {
        detail: {
          appName,
          callbackId,
          hasPermission
        }
      }));
    } catch (error) {
      console.error('Permission check failed:', error);
      
      // 返回错误
      window.dispatchEvent(new CustomEvent('micro-app-permission-response', {
        detail: {
          appName,
          callbackId,
          hasPermission: false,
          error: error.message
        }
      }));
    }
  }
  
  // 获取有效令牌
  async getValidToken() {
    // 检查令牌是否存在
    if (!this.token) {
      throw new Error('No token available');
    }
    
    // 检查令牌是否过期
    if (this.tokenExpiry && Date.now() >= this.tokenExpiry) {
      // 令牌已过期，尝试刷新
      await this.refreshToken();
    }
    
    return this.token;
  }
  
  // 刷新令牌
  async refreshToken() {
    try {
      const response = await fetch(this.config.refreshEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.token}`
        }
      });
      
      if (!response.ok) {
        throw new Error('Token refresh failed');
      }
      
      const data = await response.json();
      this.setToken(data.token, data.expiry);
      
      return data.token;
    } catch (error) {
      console.error('Token refresh failed:', error);
      
      // 刷新失败，清除令牌
      this.clearToken();
      
      // 通知监听器
      this.notifyAuthListeners('tokenExpired');
      
      throw error;
    }
  }
  
  // 设置令牌
  setToken(token, expiry) {
    this.token = token;
    this.tokenExpiry = expiry;
    
    // 存储令牌
    try {
      localStorage.setItem(this.config.tokenKey, JSON.stringify({
        token,
        expiry
      }));
    } catch (error) {
      console.error('Failed to store token:', error);
    }
    
    // 设置自动刷新
    if (this.config.autoRefresh) {
      this.setupAutoRefresh();
    }
    
    // 通知监听器
    this.notifyAuthListeners('tokenUpdated');
  }
  
  // 清除令牌
  clearToken() {
    this.token = null;
    this.tokenExpiry = null;
    
    // 清除存储
    try {
      localStorage.removeItem(this.config.tokenKey);
    } catch (error) {
      console.error('Failed to clear token:', error);
    }
    
    // 清除刷新定时器
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
      this.refreshTimer = null;
    }
    
    // 清除权限缓存
    this.permissionCache.clear();
    
    // 通知监听器
    this.notifyAuthListeners('tokenCleared');
  }
  
  // 检查权限
  async checkPermission(appName, permission) {
    // 检查缓存
    const cacheKey = `${appName}:${permission}`;
    if (this.permissionCache.has(cacheKey)) {
      const { hasPermission, expiry } = this.permissionCache.get(cacheKey);
      
      // 检查缓存是否过期
      if (Date.now() < expiry) {
        return hasPermission;
      }
    }
    
    try {
      // 获取有效令牌
      const token = await this.getValidToken();
      
      // 发送权限检查请求
      const response = await fetch(this.config.permissionEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          appName,
          permission
        })
      });
      
      if (!response.ok) {
        throw new Error('Permission check failed');
      }
      
      const data = await response.json();
      const { hasPermission } = data;
      
      // 缓存结果
      this.permissionCache.set(cacheKey, {
        hasPermission,
        expiry: Date.now() + 5 * 60 * 1000 // 5分钟缓存
      });
      
      return hasPermission;
    } catch (error) {
      console.error('Permission check failed:', error);
      
      // 默认拒绝权限
      return false;
    }
  }
  
  // 添加认证监听器
  addAuthListener(callback) {
    this.authListeners.add(callback);
    
    // 返回移除监听器的函数
    return () => {
      this.authListeners.delete(callback);
    };
  }
  
  // 通知认证监听器
  notifyAuthListeners(event) {
    this.authListeners.forEach(callback => {
      try {
        callback(event);
      } catch (error) {
        console.error('Auth listener error:', error);
      }
    });
  }
  
  // 登录
  async login(credentials) {
    try {
      const response = await fetch(this.config.authEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(credentials)
      });
      
      if (!response.ok) {
        throw new Error('Login failed');
      }
      
      const data = await response.json();
      this.setToken(data.token, data.expiry);
      
      return data;
    } catch (error) {
      console.error('Login failed:', error);
      throw error;
    }
  }
  
  // 登出
  logout() {
    this.clearToken();
    
    // 通知监听器
    this.notifyAuthListeners('logout');
  }
  
  // 获取当前令牌
  getCurrentToken() {
    return this.token;
  }
  
  // 检查是否已认证
  isAuthenticated() {
    return !!this.token && (!this.tokenExpiry || Date.now() < this.tokenExpiry);
  }
}

// 微应用认证助手
class MicroAppAuthHelper {
  constructor(appName, authManager) {
    this.appName = appName;
    this.authManager = authManager;
    this.pendingCallbacks = new Map();
    
    this.init();
  }
  
  // 初始化
  init() {
    // 监听认证响应
    window.addEventListener('micro-app-auth-response', (event) => {
      const { appName, callbackId, success, token, error } = event.detail;
      
      if (appName === this.appName && this.pendingCallbacks.has(callbackId)) {
        const { resolve, reject } = this.pendingCallbacks.get(callbackId);
        this.pendingCallbacks.delete(callbackId);
        
        if (success) {
          resolve(token);
        } else {
          reject(new Error(error));
        }
      }
    });
    
    // 监听权限响应
    window.addEventListener('micro-app-permission-response', (event) => {
      const { appName, callbackId, hasPermission, error } = event.detail;
      
      if (appName === this.appName && this.pendingCallbacks.has(callbackId)) {
        const { resolve, reject } = this.pendingCallbacks.get(callbackId);
        this.pendingCallbacks.delete(callbackId);
        
        if (error) {
          reject(new Error(error));
        } else {
          resolve(hasPermission);
        }
      }
    });
  }
  
  // 获取认证令牌
  async getToken() {
    return new Promise((resolve, reject) => {
      const callbackId = this.generateCallbackId();
      this.pendingCallbacks.set(callbackId, { resolve, reject });
      
      // 发送认证请求
      window.dispatchEvent(new CustomEvent('micro-app-auth-request', {
        detail: {
          appName: this.appName,
          callbackId
        }
      }));
    });
  }
  
  // 检查权限
  async checkPermission(permission) {
    return new Promise((resolve, reject) => {
      const callbackId = this.generateCallbackId();
      this.pendingCallbacks.set(callbackId, { resolve, reject });
      
      // 发送权限检查请求
      window.dispatchEvent(new CustomEvent('micro-app-permission-check', {
        detail: {
          appName: this.appName,
          permission,
          callbackId
        }
      }));
    });
  }
  
  // 生成回调ID
  generateCallbackId() {
    return `${this.appName}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  // 创建带认证的请求
  async createAuthenticatedRequest(url, options = {}) {
    try {
      // 获取令牌
      const token = await this.getToken();
      
      // 添加认证头
      const headers = {
        ...options.headers,
        'Authorization': `Bearer ${token}`
      };
      
      // 发送请求
      return fetch(url, {
        ...options,
        headers
      });
    } catch (error) {
      console.error('Authenticated request failed:', error);
      throw error;
    }
  }
}

// 使用示例
// 主应用中
const authManager = new MicroFrontendAuthManager({
  authEndpoint: '/api/auth',
  refreshEndpoint: '/api/auth/refresh',
  tokenKey: 'micro_frontend_token',
  autoRefresh: true,
  permissionEndpoint: '/api/permissions',
  appPermissions: {
    'app1': ['read', 'write'],
    'app2': ['read']
  }
});

// 监听认证状态变化
authManager.addAuthListener((event) => {
  switch (event) {
    case 'tokenExpired':
      // 显示登录界面
      showLoginModal();
      break;
    case 'tokenUpdated':
      // 更新UI
      updateAuthUI();
      break;
    case 'logout':
      // 跳转到登录页
      window.location.href = '/login';
      break;
  }
});

// 微应用中
const appAuthHelper = new MicroAppAuthHelper('app1', authManager);

// 获取令牌
appAuthHelper.getToken().then(token => {
  console.log('Got token:', token);
}).catch(error => {
  console.error('Failed to get token:', error);
});

// 检查权限
appAuthHelper.checkPermission('read').then(hasPermission => {
  if (hasPermission) {
    // 显示读取功能
    showReadFeatures();
  } else {
    // 隐藏读取功能
    hideReadFeatures();
  }
});

// 发送带认证的请求
appAuthHelper.createAuthenticatedRequest('/api/data', {
  method: 'GET'
}).then(response => {
  return response.json();
}).then(data => {
  console.log('Got data:', data);
}).catch(error => {
  console.error('Request failed:', error);
});
```

## 10.3 微前端安全最佳实践

### 10.3.1 安全开发指南

1. **代码审查**：
   - 定期进行代码安全审查
   - 使用静态代码分析工具检测安全漏洞
   - 关注第三方依赖的安全更新

2. **安全编码规范**：
   - 避免使用eval()和Function构造函数
   - 对用户输入进行严格验证和过滤
   - 使用HTTPS进行所有通信
   - 实施最小权限原则

3. **依赖管理**：
   - 定期更新依赖库到最新安全版本
   - 使用工具如npm audit检查依赖漏洞
   - 考虑使用依赖锁定文件确保版本一致性

4. **配置安全**：
   - 不要在前端代码中硬编码敏感信息
   - 使用环境变量管理配置
   - 禁用生产环境的调试功能

### 10.3.2 安全测试策略

```javascript
// 微前端安全测试工具
class MicroFrontendSecurityTester {
  constructor() {
    this.testResults = [];
    this.vulnerabilities = [];
  }
  
  // 运行所有安全测试
  async runAllTests() {
    console.log('Starting security tests...');
    
    // XSS测试
    await this.testXSSVulnerabilities();
    
    // CSRF测试
    await this.testCSRFVulnerabilities();
    
    // 点击劫持测试
    await this.testClickjackingVulnerabilities();
    
    // 信息泄露测试
    await this.testInformationDisclosure();
    
    // 依赖安全测试
    await this.testDependencySecurity();
    
    // 生成报告
    this.generateReport();
  }
  
  // XSS漏洞测试
  async testXSSVulnerabilities() {
    console.log('Testing XSS vulnerabilities...');
    
    const testCases = [
      '<script>alert("XSS")</script>',
      'javascript:alert("XSS")',
      '<img src="x" onerror="alert(\'XSS\')">',
      '<svg onload="alert(\'XSS\')">',
      '"><script>alert("XSS")</script>',
      '\';alert("XSS");//'
    ];
    
    const elements = [
      'input',
      'textarea',
      'div',
      'span',
      'p',
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6'
    ];
    
    for (const element of elements) {
      for (const testCase of testCases) {
        try {
          // 创建元素
          const el = document.createElement(element);
          
          // 设置测试用例
          if (element === 'input' || element === 'textarea') {
            el.value = testCase;
          } else {
            el.textContent = testCase;
          }
          
          // 添加到DOM
          document.body.appendChild(el);
          
          // 检查是否执行了脚本
          const scriptExecuted = this.checkScriptExecution(testCase);
          
          // 移除元素
          document.body.removeChild(el);
          
          // 记录结果
          this.recordTestResult('XSS', `${element} element with ${testCase}`, !scriptExecuted);
          
          if (scriptExecuted) {
            this.vulnerabilities.push({
              type: 'XSS',
              element,
              testCase,
              severity: 'high'
            });
          }
        } catch (error) {
          console.error(`XSS test failed for ${element} with ${testCase}:`, error);
        }
      }
    }
  }
  
  // 检查脚本是否执行
  checkScriptExecution(testCase) {
    // 这里应该检查是否有alert被调用
    // 实际实现可能需要重写alert函数来检测
    return false;
  }
  
  // CSRF漏洞测试
  async testCSRFVulnerabilities() {
    console.log('Testing CSRF vulnerabilities...');
    
    // 获取所有表单
    const forms = document.querySelectorAll('form');
    
    for (const form of forms) {
      try {
        // 检查表单是否有CSRF令牌
        const hasCSRFToken = this.checkCSRFToken(form);
        
        // 检查表单方法
        const method = form.method || 'get';
        const isSafeMethod = ['get', 'head', 'options'].includes(method.toLowerCase());
        
        // 检查表单动作
        const action = form.action || window.location.href;
        const isSameOrigin = this.isSameOrigin(action);
        
        // 判断是否安全
        const isSecure = hasCSRFToken || isSafeMethod || !isSameOrigin;
        
        // 记录结果
        this.recordTestResult('CSRF', `Form ${action}`, isSecure);
        
        if (!isSecure) {
          this.vulnerabilities.push({
            type: 'CSRF',
            element: 'form',
            action,
            severity: 'medium'
          });
        }
      } catch (error) {
        console.error(`CSRF test failed for form ${form.action}:`, error);
      }
    }
    
    // 测试API请求
    await this.testAPIRequestsForCSRF();
  }
  
  // 检查CSRF令牌
  checkCSRFToken(form) {
    // 检查表单中是否有CSRF令牌
    const csrfInputs = form.querySelectorAll('input[name*="csrf"], input[name*="token"]');
    return csrfInputs.length > 0;
  }
  
  // 检查是否同源
  isSameOrigin(url) {
    try {
      const urlObj = new URL(url, window.location.href);
      return urlObj.origin === window.location.origin;
    } catch (error) {
      return false;
    }
  }
  
  // 测试API请求的CSRF防护
  async testAPIRequestsForCSRF() {
    // 这里应该检查API请求是否有适当的CSRF防护
    // 实际实现可能需要拦截fetch/XHR请求
  }
  
  // 点击劫持测试
  async testClickjackingVulnerabilities() {
    console.log('Testing clickjacking vulnerabilities...');
    
    // 检查是否有X-Frame-Options头
    const hasXFrameOptions = await this.checkHeader('X-Frame-Options');
    
    // 检查是否有Content-Security-Policy的frame-ancestors指令
    const hasFrameAncestors = await this.checkCSPDirective('frame-ancestors');
    
    // 判断是否安全
    const isSecure = hasXFrameOptions || hasFrameAncestors;
    
    // 记录结果
    this.recordTestResult('Clickjacking', 'Frame protection', isSecure);
    
    if (!isSecure) {
      this.vulnerabilities.push({
        type: 'Clickjacking',
        element: 'page',
        severity: 'medium'
      });
    }
  }
  
  // 检查响应头
  async checkHeader(headerName) {
    try {
      // 发送请求获取响应头
      const response = await fetch(window.location.href, {
        method: 'HEAD'
      });
      
      return response.headers.has(headerName);
    } catch (error) {
      console.error(`Failed to check header ${headerName}:`, error);
      return false;
    }
  }
  
  // 检查CSP指令
  async checkCSPDirective(directive) {
    try {
      // 获取CSP策略
      const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
      
      if (cspMeta) {
        const cspContent = cspMeta.getAttribute('content');
        return cspContent.includes(directive);
      }
      
      // 检查响应头中的CSP
      const response = await fetch(window.location.href, {
        method: 'HEAD'
      });
      
      const cspHeader = response.headers.get('Content-Security-Policy');
      return cspHeader && cspHeader.includes(directive);
    } catch (error) {
      console.error(`Failed to check CSP directive ${directive}:`, error);
      return false;
    }
  }
  
  // 信息泄露测试
  async testInformationDisclosure() {
    console.log('Testing information disclosure...');
    
    // 检查控制台日志
    const consoleLogs = this.captureConsoleLogs();
    
    // 检查错误消息
    const errorMessages = this.captureErrorMessages();
    
    // 检查HTML注释
    const htmlComments = this.extractHTMLComments();
    
    // 检查隐藏元素
    const hiddenElements = this.findHiddenElements();
    
    // 分析潜在的信息泄露
    const leakedInfo = [
      ...this.analyzeConsoleLogs(consoleLogs),
      ...this.analyzeErrorMessages(errorMessages),
      ...this.analyzeHTMLComments(htmlComments),
      ...this.analyzeHiddenElements(hiddenElements)
    ];
    
    // 记录结果
    const isSecure = leakedInfo.length === 0;
    this.recordTestResult('Information Disclosure', 'Sensitive information', isSecure);
    
    if (!isSecure) {
      this.vulnerabilities.push({
        type: 'Information Disclosure',
        element: 'page',
        details: leakedInfo,
        severity: 'low'
      });
    }
  }
  
  // 捕获控制台日志
  captureConsoleLogs() {
    const logs = [];
    
    // 重写console方法
    const originalConsole = {
      log: console.log,
      warn: console.warn,
      error: console.error,
      info: console.info
    };
    
    // 捕获日志
    ['log', 'warn', 'error', 'info'].forEach(method => {
      console[method] = function(...args) {
        logs.push({
          method,
          args: args.map(arg => String(arg))
        });
        originalConsole[method].apply(console, args);
      };
    });
    
    // 恢复原始console
    setTimeout(() => {
      Object.assign(console, originalConsole);
    }, 1000);
    
    return logs;
  }
  
  // 捕获错误消息
  captureErrorMessages() {
    const errors = [];
    
    // 监听错误事件
    const errorHandler = (event) => {
      errors.push({
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno
      });
    };
    
    window.addEventListener('error', errorHandler);
    
    // 移除监听器
    setTimeout(() => {
      window.removeEventListener('error', errorHandler);
    }, 1000);
    
    return errors;
  }
  
  // 提取HTML注释
  extractHTMLComments() {
    const comments = [];
    const walker = document.createTreeWalker(
      document.body,
      NodeFilter.SHOW_COMMENT,
      null,
      false
    );
    
    let node;
    while (node = walker.nextNode()) {
      comments.push(node.nodeValue);
    }
    
    return comments;
  }
  
  // 查找隐藏元素
  findHiddenElements() {
    const hiddenElements = [];
    
    // 查找display:none的元素
    const hiddenByDisplay = document.querySelectorAll('[style*="display: none"], [style*="display:none"]');
    hiddenElements.push(...Array.from(hiddenByDisplay).map(el => ({
      element: el.tagName,
      content: el.textContent,
      reason: 'display: none'
    })));
    
    // 查找visibility:hidden的元素
    const hiddenByVisibility = document.querySelectorAll('[style*="visibility: hidden"], [style*="visibility:hidden"]');
    hiddenElements.push(...Array.from(hiddenByVisibility).map(el => ({
      element: el.tagName,
      content: el.textContent,
      reason: 'visibility: hidden'
    })));
    
    // 查找hidden属性
    const hiddenByAttribute = document.querySelectorAll('[hidden]');
    hiddenElements.push(...Array.from(hiddenByAttribute).map(el => ({
      element: el.tagName,
      content: el.textContent,
      reason: 'hidden attribute'
    })));
    
    return hiddenElements;
  }
  
  // 分析控制台日志
  analyzeConsoleLogs(logs) {
    const sensitivePatterns = [
      /password/i,
      /token/i,
      /secret/i,
      /api[_-]?key/i,
      /credential/i
    ];
    
    const leakedInfo = [];
    
    logs.forEach(log => {
      const message = log.args.join(' ');
      
      sensitivePatterns.forEach(pattern => {
        if (pattern.test(message)) {
          leakedInfo.push({
            type: 'console',
            method: log.method,
            message,
            pattern: pattern.source
          });
        }
      });
    });
    
    return leakedInfo;
  }
  
  // 分析错误消息
  analyzeErrorMessages(errors) {
    const sensitivePatterns = [
      /password/i,
      /token/i,
      /secret/i,
      /api[_-]?key/i,
      /credential/i,
      /database/i,
      /internal server error/i
    ];
    
    const leakedInfo = [];
    
    errors.forEach(error => {
      sensitivePatterns.forEach(pattern => {
        if (pattern.test(error.message)) {
          leakedInfo.push({
            type: 'error',
            message: error.message,
            filename: error.filename,
            pattern: pattern.source
          });
        }
      });
    });
    
    return leakedInfo;
  }
  
  // 分析HTML注释
  analyzeHTMLComments(comments) {
    const sensitivePatterns = [
      /password/i,
      /token/i,
      /secret/i,
      /api[_-]?key/i,
      /credential/i,
      /todo/i,
      /fixme/i,
      /hack/i
    ];
    
    const leakedInfo = [];
    
    comments.forEach(comment => {
      sensitivePatterns.forEach(pattern => {
        if (pattern.test(comment)) {
          leakedInfo.push({
            type: 'html-comment',
            comment,
            pattern: pattern.source
          });
        }
      });
    });
    
    return leakedInfo;
  }
  
  // 分析隐藏元素
  analyzeHiddenElements(elements) {
    const sensitivePatterns = [
      /password/i,
      /token/i,
      /secret/i,
      /api[_-]?key/i,
      /credential/i
    ];
    
    const leakedInfo = [];
    
    elements.forEach(element => {
      sensitivePatterns.forEach(pattern => {
        if (pattern.test(element.content)) {
          leakedInfo.push({
            type: 'hidden-element',
            element: element.element,
            content: element.content,
            reason: element.reason,
            pattern: pattern.source
          });
        }
      });
    });
    
    return leakedInfo;
  }
  
  // 依赖安全测试
  async testDependencySecurity() {
    console.log('Testing dependency security...');
    
    // 这里应该检查依赖库是否有已知漏洞
    // 实际实现可能需要调用后端API或使用工具如npm audit
    
    // 模拟测试结果
    const hasVulnerabilities = false; // 假设没有漏洞
    
    // 记录结果
    this.recordTestResult('Dependency Security', 'Known vulnerabilities', !hasVulnerabilities);
    
    if (hasVulnerabilities) {
      this.vulnerabilities.push({
        type: 'Dependency Security',
        element: 'dependencies',
        severity: 'high'
      });
    }
  }
  
  // 记录测试结果
  recordTestResult(testName, description, passed) {
    this.testResults.push({
      testName,
      description,
      passed,
      timestamp: new Date().toISOString()
    });
  }
  
  // 生成报告
  generateReport() {
    const report = {
      summary: {
        totalTests: this.testResults.length,
        passedTests: this.testResults.filter(r => r.passed).length,
        failedTests: this.testResults.filter(r => !r.passed).length,
        vulnerabilities: this.vulnerabilities.length
      },
      testResults: this.testResults,
      vulnerabilities: this.vulnerabilities,
      timestamp: new Date().toISOString()
    };
    
    console.log('Security test report:', report);
    
    // 返回报告
    return report;
  }
}

// 使用示例
const securityTester = new MicroFrontendSecurityTester();
securityTester.runAllTests().then(report => {
  console.log('Security test completed:', report.summary);
  
  if (report.summary.vulnerabilities > 0) {
    console.warn('Security vulnerabilities found:', report.vulnerabilities);
  }
});
```

## 总结

本章详细介绍了微前端安全实践的各种技术和策略，包括：

1. **微前端安全概述**：分析了微前端面临的安全挑战、防护原则和威胁模型
2. **微前端安全防护策略**：提供了内容安全策略、安全沙箱实现和身份认证与授权的详细实现
3. **微前端安全最佳实践**：介绍了安全开发指南和安全测试策略

通过这些安全措施，开发者可以构建更加安全的微前端应用，保护用户数据和系统安全。在实际项目中，应根据具体需求和安全要求，选择合适的安全策略，并持续更新和改进安全措施。安全是一个持续的过程，需要开发团队的高度重视和长期投入。