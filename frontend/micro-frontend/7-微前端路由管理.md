# 第七章：微前端路由管理

## 7.1 路由管理概述

在微前端架构中，路由管理是一个核心且复杂的问题。与单体应用不同，微前端应用的路由分布在多个独立的应用中，需要特殊的机制来协调和管理这些路由。

### 7.1.1 微前端路由管理的挑战

1. **路由冲突**：不同微应用可能有相同的路由规则，导致冲突
2. **路由同步**：确保浏览器地址栏与当前激活的应用保持同步
3. **应用切换**：在应用间切换时保持状态和上下文
4. **路由权限**：统一管理路由访问权限
5. **SEO优化**：确保微前端应用具有良好的SEO表现
6. **浏览器兼容性**：处理不同浏览器的历史API兼容性问题

### 7.1.2 路由模式

在微前端架构中，常见的路由模式有以下几种：

1. **前缀路由**：每个微应用有独立的路由前缀，如 `/app1/xxx`、`/app2/xxx`
2. **路径分发**：根据路径规则将请求分发到不同的微应用
3. **组件路由**：将微应用作为组件集成到主应用的路由中
4. **混合路由**：结合多种路由模式，适应不同场景

## 7.2 路由管理方案

### 7.2.1 基于前缀的路由管理

通过为每个微应用分配独立的路由前缀来实现路由管理：

```javascript
// 主应用路由配置
const routes = [
  {
    path: '/',
    component: MainLayout,
    children: [
      {
        path: '/dashboard/*',
        name: 'dashboard',
        microApp: 'dashboard-app'
      },
      {
        path: '/user/*',
        name: 'user',
        microApp: 'user-app'
      },
      {
        path: '/admin/*',
        name: 'admin',
        microApp: 'admin-app'
      }
    ]
  }
];

// 路由管理器
class MicroFrontendRouter {
  constructor(routes) {
    this.routes = routes;
    this.activeApp = null;
    this.init();
  }
  
  init() {
    // 监听路由变化
    window.addEventListener('popstate', this.handleRouteChange.bind(this));
    window.addEventListener('hashchange', this.handleRouteChange.bind(this));
    
    // 处理初始路由
    this.handleRouteChange();
  }
  
  handleRouteChange() {
    const currentPath = window.location.pathname;
    const matchedRoute = this.matchRoute(currentPath);
    
    if (matchedRoute) {
      this.loadMicroApp(matchedRoute);
    }
  }
  
  matchRoute(path) {
    for (const route of this.routes) {
      if (route.children) {
        for (const childRoute of route.children) {
          if (path.startsWith(childRoute.path.replace('/*', ''))) {
            return childRoute;
          }
        }
      }
    }
    return null;
  }
  
  async loadMicroApp(route) {
    if (this.activeApp === route.microApp) {
      return; // 已经是当前激活的应用
    }
    
    // 卸载当前应用
    if (this.activeApp) {
      await this.unloadMicroApp(this.activeApp);
    }
    
    // 加载新应用
    await this.mountMicroApp(route.microApp);
    this.activeApp = route.microApp;
  }
  
  async mountMicroApp(appName) {
    // 动态加载微应用
    const app = await import(`./micro-apps/${appName}/index.js`);
    app.mount();
  }
  
  async unloadMicroApp(appName) {
    // 卸载微应用
    const app = await import(`./micro-apps/${appName}/index.js`);
    app.unmount();
  }
  
  // 导航到指定路径
  navigateTo(path) {
    window.history.pushState({}, '', path);
    this.handleRouteChange();
  }
}

// 创建路由管理器实例
const router = new MicroFrontendRouter(routes);

// 在微应用中处理子路由
class DashboardApp {
  constructor() {
    this.routes = [
      { path: '/dashboard', component: DashboardHome },
      { path: '/dashboard/analytics', component: Analytics },
      { path: '/dashboard/reports', component: Reports }
    ];
    
    this.init();
  }
  
  init() {
    // 监听路由变化
    window.addEventListener('popstate', this.handleRouteChange.bind(this));
    window.addEventListener('hashchange', this.handleRouteChange.bind(this));
    
    // 处理初始路由
    this.handleRouteChange();
  }
  
  handleRouteChange() {
    const currentPath = window.location.pathname;
    const matchedRoute = this.matchRoute(currentPath);
    
    if (matchedRoute) {
      this.renderComponent(matchedRoute.component);
    }
  }
  
  matchRoute(path) {
    return this.routes.find(route => route.path === path);
  }
  
  renderComponent(Component) {
    // 渲染组件
    ReactDOM.render(<Component />, document.getElementById('root'));
  }
  
  mount() {
    console.log('Dashboard应用已挂载');
  }
  
  unmount() {
    console.log('Dashboard应用已卸载');
    ReactDOM.unmountComponentAtNode(document.getElementById('root'));
  }
}

// 导出应用实例
export default new DashboardApp();
```

### 7.2.2 基于Single-SPA的路由管理

使用Single-SPA框架的路由管理功能：

```javascript
// 主应用入口文件
import { registerApplication, start } from 'single-spa';

// 注册微应用
registerApplication({
  name: 'dashboard',
  app: () => import('./dashboard/main.js'),
  activeWhen: ['/dashboard'],
  customProps: {
    domElement: document.getElementById('dashboard-container')
  }
});

registerApplication({
  name: 'user',
  app: () => import('./user/main.js'),
  activeWhen: ['/user'],
  customProps: {
    domElement: document.getElementById('user-container')
  }
});

registerApplication({
  name: 'admin',
  app: () => import('./admin/main.js'),
  activeWhen: ['/admin'],
  customProps: {
    domElement: document.getElementById('admin-container')
  }
});

// 启动Single-SPA
start();

// Dashboard微应用入口
import React from 'react';
import ReactDOM from 'react-dom';
import singleSpaReact from 'single-spa-react';
import { BrowserRouter, Route, Switch, Link } from 'react-router-dom';
import DashboardHome from './components/DashboardHome';
import Analytics from './components/Analytics';
import Reports from './components/Reports';

const App = () => (
  <BrowserRouter>
    <div>
      <nav>
        <ul>
          <li><Link to="/dashboard">首页</Link></li>
          <li><Link to="/dashboard/analytics">分析</Link></li>
          <li><Link to="/dashboard/reports">报告</Link></li>
        </ul>
      </nav>
      
      <Switch>
        <Route exact path="/dashboard" component={DashboardHome} />
        <Route path="/dashboard/analytics" component={Analytics} />
        <Route path="/dashboard/reports" component={Reports} />
      </Switch>
    </div>
  </BrowserRouter>
);

const lifecycles = singleSpaReact({
  React,
  ReactDOM,
  rootComponent: App,
  errorBoundary(err, info, props) {
    return <div>加载出错: {err.message}</div>;
  }
});

export const bootstrap = lifecycles.bootstrap;
export const mount = lifecycles.mount;
export const unmount = lifecycles.unmount;
```

### 7.2.3 基于qiankun的路由管理

使用qiankun框架的路由管理功能：

```javascript
// 主应用路由配置
import { registerMicroApps, start } from 'qiankun';

// 注册微应用
registerMicroApps([
  {
    name: 'dashboard',
    entry: '//localhost:7101',
    container: '#container',
    activeRule: '/dashboard',
    props: {
      routerBase: '/dashboard'
    }
  },
  {
    name: 'user',
    entry: '//localhost:7102',
    container: '#container',
    activeRule: '/user',
    props: {
      routerBase: '/user'
    }
  },
  {
    name: 'admin',
    entry: '//localhost:7103',
    container: '#container',
    activeRule: '/admin',
    props: {
      routerBase: '/admin'
    }
  }
]);

// 启动qiankun
start({
  sandbox: {
    experimentalStyleIsolation: true
  }
});

// Dashboard微应用路由配置
import Vue from 'vue';
import VueRouter from 'vue-router';
import App from './App.vue';
import DashboardHome from './components/DashboardHome.vue';
import Analytics from './components/Analytics.vue';
import Reports from './components/Reports.vue';

Vue.use(VueRouter);

// 获取主应用传递的路由基础路径
const routerBase = window.__POWERED_BY_QIANKUN__ ? window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__ : '/';

const routes = [
  {
    path: `${routerBase}dashboard`,
    name: 'DashboardHome',
    component: DashboardHome
  },
  {
    path: `${routerBase}dashboard/analytics`,
    name: 'Analytics',
    component: Analytics
  },
  {
    path: `${routerBase}dashboard/reports`,
    name: 'Reports',
    component: Reports
  }
];

const router = new VueRouter({
  base: routerBase,
  mode: 'history',
  routes
});

new Vue({
  router,
  render: h => h(App)
}).$mount('#app');

// 导出qiankun生命周期
export async function bootstrap() {
  console.log('Vue应用bootstrap');
}

export async function mount(props) {
  console.log('Vue应用mount', props);
}

export async function unmount() {
  console.log('Vue应用unmount');
}
```

### 7.2.4 基于Module Federation的路由管理

使用Module Federation实现路由管理：

```javascript
// 主应用webpack配置
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  // ...其他配置
  plugins: [
    new ModuleFederationPlugin({
      name: 'shell',
      remotes: {
        dashboard: 'dashboard@http://localhost:3001/remoteEntry.js',
        user: 'user@http://localhost:3002/remoteEntry.js',
        admin: 'admin@http://localhost:3003/remoteEntry.js'
      },
      shared: ['react', 'react-dom', 'react-router-dom']
    })
  ]
};

// 主应用路由配置
import React, { Suspense, lazy } from 'react';
import { BrowserRouter, Route, Switch, Link } from 'react-router-dom';
import { Spin } from 'antd';

// 动态导入远程组件
const DashboardApp = lazy(() => import('dashboard/App'));
const UserApp = lazy(() => import('user/App'));
const AdminApp = lazy(() => import('admin/App'));

const App = () => (
  <BrowserRouter>
    <div>
      <nav>
        <ul>
          <li><Link to="/dashboard">仪表盘</Link></li>
          <li><Link to="/user">用户</Link></li>
          <li><Link to="/admin">管理</Link></li>
        </ul>
      </nav>
      
      <Suspense fallback={<Spin size="large" />}>
        <Switch>
          <Route path="/dashboard" component={DashboardApp} />
          <Route path="/user" component={UserApp} />
          <Route path="/admin" component={AdminApp} />
        </Switch>
      </Suspense>
    </div>
  </BrowserRouter>
);

export default App;

// Dashboard微应用webpack配置
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  // ...其他配置
  plugins: [
    new ModuleFederationPlugin({
      name: 'dashboard',
      filename: 'remoteEntry.js',
      exposes: {
        './App': './src/App'
      },
      shared: ['react', 'react-dom', 'react-router-dom']
    })
  ]
};

// Dashboard微应用路由配置
import React from 'react';
import { Route, Switch, Link, useRouteMatch } from 'react-router-dom';
import DashboardHome from './components/DashboardHome';
import Analytics from './components/Analytics';
import Reports from './components/Reports';

const App = () => {
  const { path, url } = useRouteMatch();
  
  return (
    <div>
      <nav>
        <ul>
          <li><Link to={`${url}`}>首页</Link></li>
          <li><Link to={`${url}/analytics`}>分析</Link></li>
          <li><Link to={`${url}/reports`}>报告</Link></li>
        </ul>
      </nav>
      
      <Switch>
        <Route exact path={path} component={DashboardHome} />
        <Route path={`${path}/analytics`} component={Analytics} />
        <Route path={`${path}/reports`} component={Reports} />
      </Switch>
    </div>
  );
};

export default App;
```

## 7.3 路由权限管理

### 7.3.1 基于角色的路由权限

实现基于角色的路由权限控制：

```javascript
// 权限管理器
class PermissionManager {
  constructor() {
    this.userRoles = [];
    this.routePermissions = new Map();
  }
  
  // 设置用户角色
  setUserRoles(roles) {
    this.userRoles = roles;
  }
  
  // 设置路由权限
  setRoutePermission(route, roles) {
    this.routePermissions.set(route, roles);
  }
  
  // 检查路由权限
  hasPermission(route) {
    const requiredRoles = this.routePermissions.get(route);
    
    // 如果路由没有设置权限要求，则默认允许访问
    if (!requiredRoles || requiredRoles.length === 0) {
      return true;
    }
    
    // 检查用户是否具有所需角色
    return requiredRoles.some(role => this.userRoles.includes(role));
  }
  
  // 获取用户可访问的路由
  getAccessibleRoutes(routes) {
    return routes.filter(route => this.hasPermission(route.path));
  }
}

// 创建全局权限管理器
window.__MF_PERMISSION_MANAGER__ = new PermissionManager();

// 设置路由权限
window.__MF_PERMISSION_MANAGER__.setRoutePermission('/dashboard', ['user', 'admin']);
window.__MF_PERMISSION_MANAGER__.setRoutePermission('/admin', ['admin']);

// 路由守卫
class RouteGuard {
  constructor(router, permissionManager) {
    this.router = router;
    this.permissionManager = permissionManager;
    this.init();
  }
  
  init() {
    // 拦截路由变化
    this.router.beforeEach = (to, from, next) => {
      if (this.permissionManager.hasPermission(to.path)) {
        next();
      } else {
        // 重定向到无权限页面
        next({ path: '/403' });
      }
    };
  }
}

// 创建路由守卫
const routeGuard = new RouteGuard(router, window.__MF_PERMISSION_MANAGER__);

// 在微应用中使用权限
class AdminApp {
  constructor() {
    this.routes = [
      { path: '/admin/users', component: UserManagement, roles: ['admin'] },
      { path: '/admin/settings', component: SystemSettings, roles: ['admin'] },
      { path: '/admin/reports', component: Reports, roles: ['admin', 'manager'] }
    ];
    
    this.init();
  }
  
  init() {
    // 过滤有权限的路由
    this.accessibleRoutes = this.routes.filter(route => {
      const requiredRoles = route.roles || [];
      return requiredRoles.length === 0 || requiredRoles.some(role => 
        window.__MF_PERMISSION_MANAGER__.userRoles.includes(role)
      );
    });
    
    // 初始化路由
    this.initRouter();
  }
  
  initRouter() {
    // 根据有权限的路由初始化路由器
    // ...
  }
}
```

### 7.3.2 动态路由权限

实现动态路由权限管理：

```javascript
// 动态权限管理器
class DynamicPermissionManager {
  constructor() {
    this.userPermissions = [];
    this.dynamicRoutes = [];
  }
  
  // 设置用户权限
  async setUserPermissions(userId) {
    // 从服务器获取用户权限
    const response = await fetch(`/api/users/${userId}/permissions`);
    const permissions = await response.json();
    
    this.userPermissions = permissions;
    
    // 根据权限生成动态路由
    this.generateDynamicRoutes();
  }
  
  // 生成动态路由
  generateDynamicRoutes() {
    this.dynamicRoutes = [];
    
    // 根据权限生成路由
    if (this.hasPermission('dashboard.view')) {
      this.dynamicRoutes.push({
        path: '/dashboard',
        component: 'DashboardApp',
        meta: { title: '仪表盘' }
      });
    }
    
    if (this.hasPermission('user.view')) {
      this.dynamicRoutes.push({
        path: '/user',
        component: 'UserApp',
        meta: { title: '用户管理' }
      });
    }
    
    if (this.hasPermission('admin.view')) {
      this.dynamicRoutes.push({
        path: '/admin',
        component: 'AdminApp',
        meta: { title: '系统管理' }
      });
    }
  }
  
  // 检查权限
  hasPermission(permission) {
    return this.userPermissions.includes(permission);
  }
  
  // 获取动态路由
  getDynamicRoutes() {
    return this.dynamicRoutes;
  }
}

// 创建全局动态权限管理器
window.__MF_DYNAMIC_PERMISSION_MANAGER__ = new DynamicPermissionManager();

// 动态路由加载器
class DynamicRouteLoader {
  constructor(router, permissionManager) {
    this.router = router;
    this.permissionManager = permissionManager;
  }
  
  // 加载动态路由
  async loadDynamicRoutes() {
    // 获取动态路由
    const routes = this.permissionManager.getDynamicRoutes();
    
    // 添加路由到路由器
    routes.forEach(route => {
      this.router.addRoute(route);
    });
  }
  
  // 重新加载路由
  async reloadRoutes() {
    // 清空现有路由
    this.router.clearRoutes();
    
    // 重新加载动态路由
    await this.loadDynamicRoutes();
  }
}

// 在主应用中使用
const dynamicPermissionManager = window.__MF_DYNAMIC_PERMISSION_MANAGER__;
const dynamicRouteLoader = new DynamicRouteLoader(router, dynamicPermissionManager);

// 用户登录后加载权限
async function handleLogin(userId) {
  await dynamicPermissionManager.setUserPermissions(userId);
  await dynamicRouteLoader.loadDynamicRoutes();
  
  // 跳转到首页
  router.push('/dashboard');
}
```

## 7.4 路由状态管理

### 7.4.1 路由状态持久化

实现路由状态的持久化：

```javascript
// 路由状态管理器
class RouteStateManager {
  constructor() {
    this.routeStates = new Map();
    this.maxStates = 10;
  }
  
  // 保存路由状态
  saveRouteState(route, state) {
    const key = this.getRouteKey(route);
    this.routeStates.set(key, {
      state: JSON.parse(JSON.stringify(state)),
      timestamp: Date.now()
    });
    
    // 限制状态数量
    this.limitStates();
  }
  
  // 获取路由状态
  getRouteState(route) {
    const key = this.getRouteKey(route);
    const routeState = this.routeStates.get(key);
    
    if (routeState) {
      return routeState.state;
    }
    
    return null;
  }
  
  // 获取路由键
  getRouteKey(route) {
    return `${route.pathname}${route.search}${route.hash}`;
  }
  
  // 限制状态数量
  limitStates() {
    if (this.routeStates.size > this.maxStates) {
      // 按时间戳排序，删除最旧的状态
      const sortedStates = Array.from(this.routeStates.entries())
        .sort((a, b) => a[1].timestamp - b[1].timestamp);
      
      // 删除最旧的状态
      const toDelete = sortedStates.slice(0, this.routeStates.size - this.maxStates);
      toDelete.forEach(([key]) => {
        this.routeStates.delete(key);
      });
    }
  }
  
  // 清空所有状态
  clearStates() {
    this.routeStates.clear();
  }
}

// 创建全局路由状态管理器
window.__MF_ROUTE_STATE_MANAGER__ = new RouteStateManager();

// 在微应用中使用路由状态管理
class ProductList extends React.Component {
  constructor(props) {
    super(props);
    
    // 尝试恢复路由状态
    const savedState = window.__MF_ROUTE_STATE_MANAGER__.getRouteState(window.location);
    this.state = {
      products: savedState?.products || [],
      currentPage: savedState?.currentPage || 1,
      filters: savedState?.filters || {}
    };
  }
  
  componentWillUnmount() {
    // 保存路由状态
    window.__MF_ROUTE_STATE_MANAGER__.saveRouteState(window.location, this.state);
  }
  
  handlePageChange = (page) => {
    this.setState({ currentPage: page });
  };
  
  handleFilterChange = (filters) => {
    this.setState({ filters });
  };
  
  render() {
    const { products, currentPage, filters } = this.state;
    
    return (
      <div>
        <ProductFilters filters={filters} onChange={this.handleFilterChange} />
        <ProductList products={products} />
        <Pagination currentPage={currentPage} onChange={this.handlePageChange} />
      </div>
    );
  }
}
```

### 7.4.2 跨应用路由状态同步

实现跨应用的路由状态同步：

```javascript
// 跨应用路由状态同步器
class CrossAppRouteSync {
  constructor() {
    this.appRouteStates = new Map();
    this.eventBus = new EventBus();
    this.syncRules = new Map();
  }
  
  // 注册应用
  registerApp(appName) {
    this.appRouteStates.set(appName, {
      currentRoute: null,
      routeParams: {},
      timestamp: null
    });
    
    // 监听应用路由变化
    this.eventBus.on(`${appName}-route-changed`, (routeData) => {
      this.updateAppRouteState(appName, routeData);
      this.syncRouteState(appName, routeData);
    });
  }
  
  // 更新应用路由状态
  updateAppRouteState(appName, routeData) {
    this.appRouteStates.set(appName, {
      ...this.appRouteStates.get(appName),
      ...routeData,
      timestamp: Date.now()
    });
  }
  
  // 添加同步规则
  addSyncRule(sourceApp, targetApp, routeMatcher, transform) {
    const ruleId = `${sourceApp}-${targetApp}`;
    this.syncRules.set(ruleId, {
      sourceApp,
      targetApp,
      routeMatcher,
      transform: transform || (data => data)
    });
  }
  
  // 同步路由状态
  syncRouteState(sourceApp, routeData) {
    this.syncRules.forEach(rule => {
      if (rule.sourceApp === sourceApp && rule.routeMatcher(routeData.currentRoute)) {
        const transformedData = rule.transform(routeData);
        
        // 发送路由同步事件到目标应用
        this.eventBus.emit(`${rule.targetApp}-route-sync`, transformedData);
      }
    });
  }
  
  // 获取应用路由状态
  getAppRouteState(appName) {
    return this.appRouteStates.get(appName);
  }
  
  // 获取所有应用路由状态
  getAllAppRouteStates() {
    const result = {};
    this.appRouteStates.forEach((state, appName) => {
      result[appName] = state;
    });
    return result;
  }
}

// 创建全局跨应用路由状态同步器
window.__MF_CROSS_APP_ROUTE_SYNC__ = new CrossAppRouteSync();

// 在主应用中注册应用和同步规则
window.__MF_CROSS_APP_ROUTE_SYNC__.registerApp('user-app');
window.__MF_CROSS_APP_ROUTE_SYNC__.registerApp('order-app');

// 同步用户ID到订单应用
window.__MF_CROSS_APP_ROUTE_SYNC__.addSyncRule(
  'user-app',
  'order-app',
  (route) => route.startsWith('/user/profile'),
  (routeData) => {
    const userId = routeData.routeParams.userId;
    return {
      currentRoute: `/order/user/${userId}`,
      routeParams: { userId }
    };
  }
);

// 在用户应用中
function navigateToUserProfile(userId) {
  const route = `/user/profile/${userId}`;
  const routeData = {
    currentRoute: route,
    routeParams: { userId }
  };
  
  // 更新本地路由
  window.history.pushState({}, '', route);
  
  // 通知路由变化
  window.__MF_EVENT_BUS__.emit('user-app-route-changed', routeData);
}

// 在订单应用中
window.__MF_EVENT_BUS__.on('order-app-route-sync', (routeData) => {
  // 更新本地路由
  window.history.pushState({}, '', routeData.currentRoute);
  
  // 更新应用状态
  updateOrderAppState(routeData);
});
```

## 7.5 路由性能优化

### 7.5.1 路由懒加载

实现路由的懒加载：

```javascript
// 路由懒加载器
class LazyRouteLoader {
  constructor() {
    this.loadedRoutes = new Set();
    this.loadingPromises = new Map();
  }
  
  // 加载路由
  async loadRoute(routePath) {
    // 如果路由已经加载，直接返回
    if (this.loadedRoutes.has(routePath)) {
      return true;
    }
    
    // 如果路由正在加载，返回加载Promise
    if (this.loadingPromises.has(routePath)) {
      return this.loadingPromises.get(routePath);
    }
    
    // 开始加载路由
    const loadingPromise = this.doLoadRoute(routePath);
    this.loadingPromises.set(routePath, loadingPromise);
    
    try {
      await loadingPromise;
      this.loadedRoutes.add(routePath);
      return true;
    } catch (error) {
      console.error(`加载路由失败: ${routePath}`, error);
      return false;
    } finally {
      this.loadingPromises.delete(routePath);
    }
  }
  
  // 实际加载路由
  async doLoadRoute(routePath) {
    // 根据路由路径动态加载对应的微应用
    const appName = this.getAppByRoute(routePath);
    
    if (!appName) {
      throw new Error(`未找到路由 ${routePath} 对应的应用`);
    }
    
    // 动态导入微应用
    const app = await import(`./micro-apps/${appName}/index.js`);
    
    // 挂载微应用
    await app.mount();
    
    return app;
  }
  
  // 根据路由获取应用名称
  getAppByRoute(routePath) {
    // 路由到应用的映射
    const routeToAppMap = {
      '/dashboard': 'dashboard-app',
      '/user': 'user-app',
      '/admin': 'admin-app'
    };
    
    for (const [route, app] of Object.entries(routeToAppMap)) {
      if (routePath.startsWith(route)) {
        return app;
      }
    }
    
    return null;
  }
}

// 创建全局路由懒加载器
window.__MF_LAZY_ROUTE_LOADER__ = new LazyRouteLoader();

// 路由管理器集成懒加载
class MicroFrontendRouter {
  constructor(routes) {
    this.routes = routes;
    this.activeApp = null;
    this.lazyLoader = window.__MF_LAZY_ROUTE_LOADER__;
    this.init();
  }
  
  init() {
    // 监听路由变化
    window.addEventListener('popstate', this.handleRouteChange.bind(this));
    window.addEventListener('hashchange', this.handleRouteChange.bind(this));
    
    // 处理初始路由
    this.handleRouteChange();
  }
  
  async handleRouteChange() {
    const currentPath = window.location.pathname;
    const matchedRoute = this.matchRoute(currentPath);
    
    if (matchedRoute) {
      // 懒加载路由
      const loaded = await this.lazyLoader.loadRoute(currentPath);
      
      if (loaded) {
        this.loadMicroApp(matchedRoute);
      } else {
        // 加载失败，显示错误页面
        this.showErrorPage();
      }
    }
  }
  
  // 其他方法...
}

// React中的路由懒加载
import { lazy, Suspense } from 'react';

// 懒加载组件
const DashboardApp = lazy(() => import('./micro-apps/dashboard-app'));
const UserApp = lazy(() => import('./micro-apps/user-app'));
const AdminApp = lazy(() => import('./micro-apps/admin-app'));

const App = () => (
  <div>
    <Suspense fallback={<div>加载中...</div>}>
      <Switch>
        <Route path="/dashboard" component={DashboardApp} />
        <Route path="/user" component={UserApp} />
        <Route path="/admin" component={AdminApp} />
      </Switch>
    </Suspense>
  </div>
);
```

### 7.5.2 路由预加载

实现路由的预加载：

```javascript
// 路由预加载器
class RoutePreloader {
  constructor(router) {
    this.router = router;
    this.preloadQueue = [];
    this.isPreloading = false;
  }
  
  // 添加预加载任务
  addPreloadTask(routePath, priority = 0) {
    // 检查是否已经预加载或正在加载
    if (this.isPreloaded(routePath) || this.isPreloading(routePath)) {
      return;
    }
    
    // 添加到预加载队列
    this.preloadQueue.push({
      routePath,
      priority,
      timestamp: Date.now()
    });
    
    // 按优先级排序
    this.preloadQueue.sort((a, b) => b.priority - a.priority);
    
    // 开始预加载
    this.startPreloading();
  }
  
  // 开始预加载
  async startPreloading() {
    if (this.isPreloading || this.preloadQueue.length === 0) {
      return;
    }
    
    this.isPreloading = true;
    
    while (this.preloadQueue.length > 0) {
      const task = this.preloadQueue.shift();
      await this.preloadRoute(task.routePath);
    }
    
    this.isPreloading = false;
  }
  
  // 预加载路由
  async preloadRoute(routePath) {
    try {
      console.log(`预加载路由: ${routePath}`);
      
      // 使用懒加载器加载路由
      const loaded = await window.__MF_LAZY_ROUTE_LOADER__.loadRoute(routePath);
      
      if (loaded) {
        console.log(`路由预加载成功: ${routePath}`);
      } else {
        console.error(`路由预加载失败: ${routePath}`);
      }
    } catch (error) {
      console.error(`路由预加载出错: ${routePath}`, error);
    }
  }
  
  // 检查路由是否已预加载
  isPreloaded(routePath) {
    return window.__MF_LAZY_ROUTE_LOADER__.loadedRoutes.has(routePath);
  }
  
  // 检查路由是否正在预加载
  isPreloading(routePath) {
    return window.__MF_LAZY_ROUTE_LOADER__.loadingPromises.has(routePath);
  }
  
  // 预加载相邻路由
  preloadAdjacentRoutes(currentRoute) {
    // 获取相邻路由
    const adjacentRoutes = this.getAdjacentRoutes(currentRoute);
    
    // 添加到预加载队列
    adjacentRoutes.forEach(route => {
      this.addPreloadTask(route, 1); // 设置较低的优先级
    });
  }
  
  // 获取相邻路由
  getAdjacentRoutes(currentRoute) {
    // 根据当前路由获取相邻路由
    // 这里只是一个示例，实际实现需要根据业务逻辑
    const routeMap = {
      '/dashboard': ['/user', '/admin'],
      '/user': ['/dashboard', '/admin'],
      '/admin': ['/dashboard', '/user']
    };
    
    return routeMap[currentRoute] || [];
  }
}

// 创建全局路由预加载器
window.__MF_ROUTE_PRELOADER__ = new RoutePreloader();

// 在路由管理器中集成预加载
class MicroFrontendRouter {
  constructor(routes) {
    this.routes = routes;
    this.activeApp = null;
    this.lazyLoader = window.__MF_LAZY_ROUTE_LOADER__;
    this.preloader = window.__MF_ROUTE_PRELOADER__;
    this.init();
  }
  
  async handleRouteChange() {
    const currentPath = window.location.pathname;
    const matchedRoute = this.matchRoute(currentPath);
    
    if (matchedRoute) {
      // 懒加载路由
      const loaded = await this.lazyLoader.loadRoute(currentPath);
      
      if (loaded) {
        this.loadMicroApp(matchedRoute);
        
        // 预加载相邻路由
        this.preloader.preloadAdjacentRoutes(currentPath);
      } else {
        this.showErrorPage();
      }
    }
  }
  
  // 其他方法...
}

// 在空闲时间预加载路由
function scheduleRoutePreloading() {
  if ('requestIdleCallback' in window) {
    // 使用requestIdleCallback在浏览器空闲时预加载
    window.requestIdleCallback(() => {
      // 预加载常用路由
      window.__MF_ROUTE_PRELOADER__.addPreloadTask('/dashboard', 2);
      window.__MF_ROUTE_PRELOADER__.addPreloadTask('/user', 2);
    });
  } else {
    // 降级使用setTimeout
    setTimeout(() => {
      window.__MF_ROUTE_PRELOADER__.addPreloadTask('/dashboard', 2);
      window.__MF_ROUTE_PRELOADER__.addPreloadTask('/user', 2);
    }, 2000);
  }
}

// 在应用启动时调度预加载
scheduleRoutePreloading();
```

## 7.6 路由管理最佳实践

### 7.6.1 路由设计原则

1. **统一性**：保持路由设计的一致性，使用相同的命名规范和结构
2. **可预测性**：路由应该直观且易于理解，避免复杂的嵌套结构
3. **可扩展性**：路由设计应该易于扩展，支持新应用和功能的添加
4. **向后兼容**：路由变更时应考虑向后兼容性，避免破坏现有链接
5. **SEO友好**：使用语义化的URL结构，有利于搜索引擎优化

### 7.6.2 路由命名规范

```javascript
// 路由命名规范示例
const routeNamingConventions = {
  // 使用小写字母和连字符
  good: [
    '/user-profile',
    '/order-history',
    '/product-details'
  ],
  
  // 避免使用驼峰命名和下划线
  bad: [
    '/userProfile',
    '/order_history',
    '/productDetails'
  ],
  
  // 使用复数形式表示列表
  good: [
    '/users',
    '/products',
    '/orders'
  ],
  
  // 使用ID表示具体资源
  good: [
    '/users/:id',
    '/products/:id',
    '/orders/:id'
  ],
  
  // 使用嵌套路径表示层级关系
  good: [
    '/users/:id/orders',
    '/products/:id/reviews',
    '/orders/:id/items'
  ]
};

// 路由参数命名规范
const routeParameterConventions = {
  // 使用有意义的参数名
  good: [
    '/users/:userId',
    '/products/:productId',
    '/orders/:orderId'
  ],
  
  // 避免使用通用参数名
  bad: [
    '/users/:id',
    '/products/:id',
    '/orders/:id'
  ],
  
  // 使用一致的命名风格
  good: [
    '/users/:userId',
    '/user-profiles/:userId',
    '/user-settings/:userId'
  ]
};
```

### 7.6.3 路由错误处理

```javascript
// 路由错误处理器
class RouteErrorHandler {
  constructor(router) {
    this.router = router;
    this.errorRoutes = {
      404: '/404',
      403: '/403',
      500: '/500'
    };
    
    this.init();
  }
  
  init() {
    // 添加全局错误处理
    this.router.onError = (error) => {
      console.error('路由错误:', error);
      this.handleError(error);
    };
  }
  
  // 处理路由错误
  handleError(error) {
    // 根据错误类型跳转到对应的错误页面
    if (error.message.includes('404')) {
      this.navigateToErrorPage(404);
    } else if (error.message.includes('403')) {
      this.navigateToErrorPage(403);
    } else {
      this.navigateToErrorPage(500);
    }
  }
  
  // 跳转到错误页面
  navigateToErrorPage(errorCode) {
    const errorRoute = this.errorRoutes[errorCode];
    if (errorRoute) {
      window.history.pushState({}, '', errorRoute);
      this.router.handleRouteChange();
    }
  }
  
  // 自定义错误页面
  registerErrorPage(errorCode, route) {
    this.errorRoutes[errorCode] = route;
  }
}

// 创建全局路由错误处理器
window.__MF_ROUTE_ERROR_HANDLER__ = new RouteErrorHandler(router);

// 在微应用中处理路由错误
class MicroApp {
  constructor() {
    this.init();
  }
  
  init() {
    // 监听路由错误
    window.addEventListener('unhandledrejection', (event) => {
      if (event.reason && event.reason.message.includes('route')) {
        this.handleRouteError(event.reason);
      }
    });
  }
  
  handleRouteError(error) {
    console.error('微应用路由错误:', error);
    
    // 通知主应用处理错误
    window.__MF_EVENT_BUS__.emit('micro-app-route-error', {
      appName: this.appName,
      error
    });
  }
}
```

## 7.7 本章小结

本章详细介绍了微前端架构中的路由管理问题，包括路由管理的挑战、各种实现方案、路由权限管理、路由状态管理、路由性能优化以及最佳实践。我们通过实际代码示例展示了如何在不同场景下实现路由管理，并提供了路由设计原则和错误处理策略。

路由管理是微前端架构中的核心问题，合理的路由管理方案可以显著提高应用的用户体验和可维护性。在实际项目中，需要根据应用规模、团队技术栈和业务需求来选择合适的路由管理方案。

在下一章中，我们将学习微前端通信机制的相关知识，了解如何在微前端架构中实现高效的应用间通信。

## 7.8 思考题

1. 微前端路由管理面临哪些主要挑战？
2. 如何实现跨应用的路由状态同步？
3. 在微前端架构中，如何优化路由加载性能？

## 7.9 示例代码

本章的完整示例代码已经保存在 `frontend/micro-frontend/code/chapter7/route-management` 目录中。

### 7.9.1 代码结构

```
route-management/
├── src/
│   ├── main-app/
│   │   ├── index.js
│   │   ├── router.js
│   │   └── App.js
│   ├── dashboard-app/
│   │   ├── index.js
│   │   ├── router.js
│   │   └── components/
│   │       ├── DashboardHome.js
│   │       ├── Analytics.js
│   │       └── Reports.js
│   ├── user-app/
│   │   ├── index.js
│   │   ├── router.js
│   │   └── components/
│   │       ├── UserProfile.js
│   │       └── UserSettings.js
│   ├── shared/
│   │   ├── MicroFrontendRouter.js
│   │   ├── PermissionManager.js
│   │   ├── RouteStateManager.js
│   │   └── CrossAppRouteSync.js
│   └── index.html
├── package.json
└── webpack.config.js
```

### 7.9.2 运行示例

1. 进入示例代码目录：
```bash
cd frontend/micro-frontend/code/chapter7/route-management
```

2. 安装依赖：
```bash
npm install
```

3. 启动开发服务器：
```bash
npm start
```

4. 在浏览器中打开 http://localhost:9007

### 7.9.3 示例功能说明

- 主应用负责路由管理和应用注册
- 仪表盘应用展示仪表盘相关的页面和路由
- 用户应用展示用户相关的页面和路由
- 演示了基于前缀的路由管理、路由权限控制、路由状态同步和路由预加载等功能

### 7.9.4 路由说明

- `/` - 主页面
- `/dashboard/*` - 仪表盘应用
- `/user/*` - 用户应用

## 7.10 参考资料

1. React Router文档：https://reactrouter.com/
2. Vue Router文档：https://router.vuejs.org/
3. Single-SPA路由文档：https://single-spa.js.org/docs/ecosystem-react-router/
4. qiankun路由文档：https://qiankun.umijs.org/zh/guide/router