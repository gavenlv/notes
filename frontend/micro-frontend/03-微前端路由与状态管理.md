# 第三章：微前端路由与状态管理

## 3.1 微前端路由管理

### 3.1.1 路由管理挑战

在微前端架构中，路由管理面临以下主要挑战：

1. **路由冲突**：多个微应用可能定义相同的路由路径
2. **应用间导航**：跨应用的路由跳转和状态同步
3. **路由权限**：全局路由权限控制与微应用内部权限的协调
4. **路由懒加载**：微应用按需加载与路由预加载的平衡
5. **浏览器历史记录**：统一的浏览器历史记录管理

### 3.1.2 路由管理方案

#### 1. 集中式路由管理

集中式路由管理由主应用统一管理所有路由，微应用不直接操作路由。

```javascript
// 主应用路由管理器
class CentralizedRouter {
  constructor() {
    this.routes = new Map();
    this.currentApp = null;
    this.history = null;
    this.initHistory();
  }

  initHistory() {
    // 使用浏览器 History API
    this.history = window.history;
    window.addEventListener('popstate', this.handlePopState.bind(this));
  }

  // 注册微应用路由
  registerAppRoutes(appName, routes) {
    this.routes.set(appName, routes);
  }

  // 路由导航
  navigate(path, state = {}) {
    const targetApp = this.findAppForRoute(path);
    
    if (targetApp !== this.currentApp) {
      this.switchApp(targetApp, path, state);
    } else {
      // 同应用内导航
      this.updateRoute(path, state);
    }
  }

  // 查找路由对应的微应用
  findAppForRoute(path) {
    for (const [appName, routes] of this.routes.entries()) {
      for (const route of routes) {
        if (this.matchRoute(path, route.path)) {
          return appName;
        }
      }
    }
    return null;
  }

  // 切换应用
  async switchApp(appName, path, state) {
    // 卸载当前应用
    if (this.currentApp) {
      await this.unloadApp(this.currentApp);
    }

    // 加载新应用
    await this.loadApp(appName);
    
    // 更新当前应用
    this.currentApp = appName;
    
    // 更新路由
    this.updateRoute(path, state);
  }

  // 更新路由
  updateRoute(path, state) {
    const url = new URL(path, window.location.origin);
    this.history.pushState(state, '', url);
    
    // 触发路由变化事件
    this.emitRouteChange(path, state);
  }

  // 处理浏览器后退/前进
  handlePopState(event) {
    const path = window.location.pathname;
    const targetApp = this.findAppForRoute(path);
    
    if (targetApp !== this.currentApp) {
      this.switchApp(targetApp, path, event.state || {});
    } else {
      this.emitRouteChange(path, event.state || {});
    }
  }

  // 路由匹配
  matchRoute(path, routePath) {
    // 简单实现，实际项目中可使用 path-to-regexp 等库
    if (routePath instanceof RegExp) {
      return routePath.test(path);
    }
    
    // 将路由参数转换为正则表达式
    const pattern = routePath
      .replace(/:[^/]+/g, '([^/]+)')
      .replace(/\//g, '\\/');
    
    const regex = new RegExp(`^${pattern}$`);
    return regex.test(path);
  }

  // 加载应用
  async loadApp(appName) {
    // 实现应用加载逻辑
    console.log(`Loading app: ${appName}`);
  }

  // 卸载应用
  async unloadApp(appName) {
    // 实现应用卸载逻辑
    console.log(`Unloading app: ${appName}`);
  }

  // 触发路由变化事件
  emitRouteChange(path, state) {
    const event = new CustomEvent('micro-route-change', {
      detail: { path, state, app: this.currentApp }
    });
    window.dispatchEvent(event);
  }
}

// 使用示例
const router = new CentralizedRouter();

// 注册微应用路由
router.registerAppRoutes('dashboard', [
  { path: '/dashboard', component: 'DashboardHome' },
  { path: '/dashboard/analytics', component: 'Analytics' }
]);

router.registerAppRoutes('profile', [
  { path: '/profile', component: 'ProfileHome' },
  { path: '/profile/settings', component: 'Settings' }
]);

// 导航
router.navigate('/dashboard/analytics', { from: 'nav' });
```

#### 2. 分布式路由管理

分布式路由管理允许各微应用管理自己的路由，通过协调机制解决冲突。

```javascript
// 微应用路由管理器
class MicroAppRouter {
  constructor(appName, routerHub) {
    this.appName = appName;
    this.routerHub = routerHub;
    this.routes = new Map();
    this.currentRoute = null;
    this.isActivated = false;
    
    this.init();
  }

  init() {
    // 向路由中心注册
    this.routerHub.registerApp(this.appName, this);
    
    // 监听路由变化
    window.addEventListener('micro-route-change', this.handleRouteChange.bind(this));
  }

  // 注册路由
  registerRoute(path, component, options = {}) {
    this.routes.set(path, {
      path,
      component,
      ...options
    });
  }

  // 导航
  navigate(path, state = {}) {
    if (!this.isActivated) {
      console.warn(`App ${this.appName} is not activated`);
      return;
    }

    const route = this.findRoute(path);
    if (!route) {
      console.warn(`Route not found: ${path}`);
      return;
    }

    // 更新当前路由
    this.currentRoute = { ...route, state };
    
    // 通知路由中心
    this.routerHub.notifyRouteChange(this.appName, path, state);
  }

  // 查找路由
  findRoute(path) {
    for (const [routePath, route] of this.routes.entries()) {
      if (this.matchRoute(path, routePath)) {
        return { ...route, params: this.extractParams(path, routePath) };
      }
    }
    return null;
  }

  // 路由匹配
  matchRoute(path, routePath) {
    if (routePath instanceof RegExp) {
      return routePath.test(path);
    }
    
    const pattern = routePath
      .replace(/:[^/]+/g, '([^/]+)')
      .replace(/\//g, '\\/');
    
    const regex = new RegExp(`^${pattern}$`);
    return regex.test(path);
  }

  // 提取路由参数
  extractParams(path, routePath) {
    if (routePath instanceof RegExp) {
      const match = path.match(routePath);
      return match ? match.slice(1) : [];
    }
    
    const routeParts = routePath.split('/');
    const pathParts = path.split('/');
    const params = {};
    
    for (let i = 0; i < routeParts.length; i++) {
      const routePart = routeParts[i];
      if (routePart.startsWith(':')) {
        const paramName = routePart.substring(1);
        params[paramName] = pathParts[i];
      }
    }
    
    return params;
  }

  // 激活应用
  activate() {
    this.isActivated = true;
  }

  // 停用应用
  deactivate() {
    this.isActivated = false;
  }

  // 处理路由变化
  handleRouteChange(event) {
    const { path, app } = event.detail;
    
    // 如果是当前应用的路由变化，处理路由
    if (app === this.appName) {
      const route = this.findRoute(path);
      if (route) {
        this.currentRoute = { ...route, state: event.detail.state };
        this.renderComponent(route.component, route.params);
      }
    }
  }

  // 渲染组件
  renderComponent(componentName, params) {
    console.log(`Rendering component: ${componentName} with params:`, params);
    // 实际项目中，这里会调用框架的渲染逻辑
  }
}

// 路由中心
class RouterHub {
  constructor() {
    this.apps = new Map();
    this.activeApp = null;
    this.globalRoutes = new Map();
    this.initHistory();
  }

  initHistory() {
    window.addEventListener('popstate', this.handlePopState.bind(this));
  }

  // 注册应用
  registerApp(appName, router) {
    this.apps.set(appName, router);
  }

  // 通知路由变化
  notifyRouteChange(appName, path, state) {
    // 更新浏览器历史
    const url = new URL(path, window.location.origin);
    window.history.pushState(state, '', url);
    
    // 更新当前活跃应用
    this.activeApp = appName;
    
    // 停用其他应用
    for (const [name, router] of this.apps.entries()) {
      if (name !== appName) {
        router.deactivate();
      }
    }
    
    // 激活当前应用
    const activeRouter = this.apps.get(appName);
    if (activeRouter) {
      activeRouter.activate();
    }
    
    // 触发全局路由变化事件
    window.dispatchEvent(new CustomEvent('micro-route-change', {
      detail: { path, state, app: appName }
    }));
  }

  // 处理浏览器后退/前进
  handlePopState(event) {
    const path = window.location.pathname;
    const targetApp = this.findAppForRoute(path);
    
    if (targetApp && targetApp !== this.activeApp) {
      const router = this.apps.get(targetApp);
      if (router) {
        this.notifyRouteChange(targetApp, path, event.state || {});
      }
    } else if (targetApp === this.activeApp) {
      // 同应用内路由变化
      window.dispatchEvent(new CustomEvent('micro-route-change', {
        detail: { path, state: event.state || {}, app: targetApp }
      }));
    }
  }

  // 查找路由对应的应用
  findAppForRoute(path) {
    // 先检查全局路由
    for (const [routePath, appName] of this.globalRoutes.entries()) {
      if (this.matchRoute(path, routePath)) {
        return appName;
      }
    }
    
    // 检查各应用的路由
    for (const [appName, router] of this.apps.entries()) {
      for (const routePath of router.routes.keys()) {
        if (this.matchRoute(path, routePath)) {
          return appName;
        }
      }
    }
    
    return null;
  }

  // 路由匹配
  matchRoute(path, routePath) {
    if (routePath instanceof RegExp) {
      return routePath.test(path);
    }
    
    const pattern = routePath
      .replace(/:[^/]+/g, '([^/]+)')
      .replace(/\//g, '\\/');
    
    const regex = new RegExp(`^${pattern}$`);
    return regex.test(path);
  }

  // 注册全局路由
  registerGlobalRoute(path, appName) {
    this.globalRoutes.set(path, appName);
  }
}

// 使用示例
const routerHub = new RouterHub();

// 创建微应用路由
const dashboardRouter = new MicroAppRouter('dashboard', routerHub);
dashboardRouter.registerRoute('/dashboard', 'DashboardHome');
dashboardRouter.registerRoute('/dashboard/analytics', 'Analytics');

const profileRouter = new MicroAppRouter('profile', routerHub);
profileRouter.registerRoute('/profile', 'ProfileHome');
profileRouter.registerRoute('/profile/settings', 'Settings');

// 注册全局路由
routerHub.registerGlobalRoute('/dashboard', 'dashboard');
routerHub.registerGlobalRoute('/profile', 'profile');

// 导航
dashboardRouter.navigate('/dashboard/analytics', { from: 'nav' });
```

### 3.1.3 路由懒加载与预加载

```javascript
// 路由懒加载管理器
class RouteLazyLoader {
  constructor() {
    this.loadedApps = new Set();
    this.loadingPromises = new Map();
    this.preloadQueue = [];
    this.isPreloading = false;
  }

  // 懒加载应用
  async loadApp(appName, route) {
    // 如果已加载，直接返回
    if (this.loadedApps.has(appName)) {
      return true;
    }

    // 如果正在加载，返回加载 Promise
    if (this.loadingPromises.has(appName)) {
      return this.loadingPromises.get(appName);
    }

    // 开始加载
    const loadingPromise = this.doLoadApp(appName, route);
    this.loadingPromises.set(appName, loadingPromise);

    try {
      await loadingPromise;
      this.loadedApps.add(appName);
      return true;
    } catch (error) {
      console.error(`Failed to load app ${appName}:`, error);
      return false;
    } finally {
      this.loadingPromises.delete(appName);
    }
  }

  // 实际加载应用
  async doLoadApp(appName, route) {
    // 显示加载状态
    this.showLoadingIndicator(appName);

    try {
      // 加载应用资源
      const appConfig = await this.fetchAppConfig(appName);
      await this.loadAppResources(appConfig);
      
      // 初始化应用
      await this.initApp(appName, appConfig, route);
      
      // 隐藏加载状态
      this.hideLoadingIndicator(appName);
      
      console.log(`App ${appName} loaded successfully`);
    } catch (error) {
      this.hideLoadingIndicator(appName);
      throw error;
    }
  }

  // 预加载应用
  preloadApp(appName, priority = 'normal') {
    if (this.loadedApps.has(appName) || this.loadingPromises.has(appName)) {
      return;
    }

    this.preloadQueue.push({ appName, priority });
    this.preloadQueue.sort((a, b) => {
      const priorityOrder = { high: 3, normal: 2, low: 1 };
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });

    if (!this.isPreloading) {
      this.processPreloadQueue();
    }
  }

  // 处理预加载队列
  async processPreloadQueue() {
    this.isPreloading = true;

    while (this.preloadQueue.length > 0) {
      const { appName } = this.preloadQueue.shift();
      
      // 如果用户空闲或网络状况良好，进行预加载
      if (this.shouldPreload()) {
        try {
          await this.loadApp(appName);
        } catch (error) {
          console.warn(`Failed to preload app ${appName}:`, error);
        }
      } else {
        // 如果不满足预加载条件，稍后重试
        setTimeout(() => this.preloadQueue.push({ appName, priority: 'low' }), 5000);
      }
    }

    this.isPreloading = false;
  }

  // 判断是否应该预加载
  shouldPreload() {
    // 检查网络状况
    if (navigator.connection) {
      const { effectiveType, saveData } = navigator.connection;
      if (saveData || effectiveType === 'slow-2g' || effectiveType === '2g') {
        return false;
      }
    }

    // 检查设备内存
    if (navigator.deviceMemory && navigator.deviceMemory < 4) {
      return false;
    }

    // 检查用户是否活跃
    return !document.hidden;
  }

  // 获取应用配置
  async fetchAppConfig(appName) {
    const response = await fetch(`/api/apps/${appName}/config`);
    if (!response.ok) {
      throw new Error(`Failed to fetch config for app ${appName}`);
    }
    return response.json();
  }

  // 加载应用资源
  async loadAppResources(appConfig) {
    const { js, css } = appConfig.assets;
    
    // 加载 CSS
    if (css && css.length > 0) {
      await Promise.all(css.map(url => this.loadCSS(url)));
    }
    
    // 加载 JS
    if (js && js.length > 0) {
      await Promise.all(js.map(url => this.loadScript(url)));
    }
  }

  // 加载 CSS
  loadCSS(url) {
    return new Promise((resolve, reject) => {
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = url;
      link.onload = resolve;
      link.onerror = reject;
      document.head.appendChild(link);
    });
  }

  // 加载 JS
  loadScript(url) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.onload = resolve;
      script.onerror = reject;
      document.body.appendChild(script);
    });
  }

  // 初始化应用
  async initApp(appName, appConfig, route) {
    // 调用应用初始化函数
    if (window[appConfig.mountFunction]) {
      await window[appConfig.mountFunction]({
        container: this.getAppContainer(appName),
        route,
        props: appConfig.props || {}
      });
    } else {
      throw new Error(`Mount function ${appConfig.mountFunction} not found`);
    }
  }

  // 获取应用容器
  getAppContainer(appName) {
    let container = document.getElementById(`app-container-${appName}`);
    if (!container) {
      container = document.createElement('div');
      container.id = `app-container-${appName}`;
      document.body.appendChild(container);
    }
    return container;
  }

  // 显示加载指示器
  showLoadingIndicator(appName) {
    const indicator = document.createElement('div');
    indicator.id = `loading-${appName}`;
    indicator.className = 'micro-app-loading';
    indicator.innerHTML = `
      <div class="loading-spinner"></div>
      <div class="loading-text">Loading ${appName}...</div>
    `;
    document.body.appendChild(indicator);
  }

  // 隐藏加载指示器
  hideLoadingIndicator(appName) {
    const indicator = document.getElementById(`loading-${appName}`);
    if (indicator) {
      indicator.remove();
    }
  }
}

// 使用示例
const lazyLoader = new RouteLazyLoader();

// 路由变化时加载应用
async function handleRouteChange(path) {
  const appName = getAppNameForRoute(path);
  
  if (appName) {
    const success = await lazyLoader.loadApp(appName, { path });
    if (success) {
      // 应用加载成功，激活应用
      activateApp(appName, path);
    } else {
      // 应用加载失败，显示错误页面
      showErrorPage(`Failed to load ${appName}`);
    }
  }
}

// 预加载常用应用
lazyLoader.preloadApp('dashboard', 'high');
lazyLoader.preloadApp('profile', 'normal');

// 监听路由变化
window.addEventListener('popstate', () => {
  handleRouteChange(window.location.pathname);
});
```

## 3.2 微前端状态管理

### 3.2.1 状态管理挑战

在微前端架构中，状态管理面临以下主要挑战：

1. **状态隔离**：各微应用的状态相互隔离，避免冲突
2. **状态共享**：跨应用的状态共享与同步
3. **状态持久化**：全局状态的持久化与恢复
4. **状态一致性**：确保跨应用状态的一致性
5. **性能优化**：减少不必要的状态更新和重渲染

### 3.2.2 状态管理方案

#### 1. 集中式状态管理

集中式状态管理由主应用管理全局状态，微应用通过API访问和更新状态。

```javascript
// 全局状态管理器
class GlobalStateManager {
  constructor() {
    this.state = {};
    this.subscribers = new Map();
    this.middlewares = [];
    this.history = [];
    this.maxHistorySize = 50;
  }

  // 初始化状态
  initState(initialState) {
    this.state = { ...initialState };
    this.saveToHistory('INIT', initialState);
  }

  // 获取状态
  getState(path) {
    if (!path) return this.state;
    
    return this.getNestedValue(this.state, path);
  }

  // 获取嵌套值
  getNestedValue(obj, path) {
    return path.split('.').reduce((current, key) => {
      return current && current[key] !== undefined ? current[key] : undefined;
    }, obj);
  }

  // 设置状态
  setState(path, value, source = 'unknown') {
    const prevState = { ...this.state };
    
    if (path) {
      this.setNestedValue(this.state, path, value);
    } else {
      this.state = { ...value };
    }
    
    this.saveToHistory('SET', { path, value, source });
    this.notifySubscribers(path, value, prevState);
  }

  // 设置嵌套值
  setNestedValue(obj, path, value) {
    const keys = path.split('.');
    const lastKey = keys.pop();
    const target = keys.reduce((current, key) => {
      if (!current[key] || typeof current[key] !== 'object') {
        current[key] = {};
      }
      return current[key];
    }, obj);
    
    target[lastKey] = value;
  }

  // 更新状态
  updateState(path, updater, source = 'unknown') {
    const currentValue = this.getState(path);
    const newValue = typeof updater === 'function' 
      ? updater(currentValue) 
      : { ...currentValue, ...updater };
    
    this.setState(path, newValue, source);
  }

  // 订阅状态变化
  subscribe(path, callback, appId = 'unknown') {
    const id = `${appId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    this.subscribers.set(id, { path, callback, appId });
    
    // 返回取消订阅函数
    return () => {
      this.subscribers.delete(id);
    };
  }

  // 通知订阅者
  notifySubscribers(path, value, prevState) {
    for (const [id, subscriber] of this.subscribers.entries()) {
      if (this.pathMatches(subscriber.path, path)) {
        const prevValue = this.getNestedValue(prevState, subscriber.path);
        const currentValue = this.getNestedValue(this.state, subscriber.path);
        
        // 只有值真正变化时才通知
        if (!this.deepEqual(prevValue, currentValue)) {
          try {
            subscriber.callback(currentValue, prevValue, {
              path,
              changedBy: id,
              timestamp: Date.now()
            });
          } catch (error) {
            console.error(`Error in subscriber ${id}:`, error);
          }
        }
      }
    }
  }

  // 路径匹配
  pathMatches(subscribedPath, changedPath) {
    // 如果订阅的路径是变化路径的前缀，或者完全匹配
    return changedPath.startsWith(subscribedPath + '.') || changedPath === subscribedPath;
  }

  // 深度比较
  deepEqual(obj1, obj2) {
    if (obj1 === obj2) return true;
    
    if (obj1 == null || obj2 == null) return false;
    
    if (typeof obj1 !== typeof obj2) return false;
    
    if (typeof obj1 !== 'object') return obj1 === obj2;
    
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    
    if (keys1.length !== keys2.length) return false;
    
    for (const key of keys1) {
      if (!keys2.includes(key) || !this.deepEqual(obj1[key], obj2[key])) {
        return false;
      }
    }
    
    return true;
  }

  // 添加中间件
  addMiddleware(middleware) {
    this.middlewares.push(middleware);
  }

  // 应用中间件
  applyMiddlewares(action, nextState) {
    let index = 0;
    
    const next = () => {
      if (index >= this.middlewares.length) return;
      
      const middleware = this.middlewares[index++];
      return middleware(action, nextState, next);
    };
    
    return next();
  }

  // 保存到历史记录
  saveToHistory(action, data) {
    this.history.push({
      action,
      data,
      timestamp: Date.now(),
      state: { ...this.state }
    });
    
    // 限制历史记录大小
    if (this.history.length > this.maxHistorySize) {
      this.history.shift();
    }
  }

  // 获取历史记录
  getHistory() {
    return [...this.history];
  }

  // 撤销
  undo() {
    if (this.history.length < 2) return false;
    
    // 移除当前状态
    this.history.pop();
    
    // 恢复上一个状态
    const previousEntry = this.history[this.history.length - 1];
    this.state = { ...previousEntry.state };
    
    // 通知所有订阅者
    this.notifySubscribers('*', this.state, this.state);
    
    return true;
  }

  // 清除应用相关的状态
  clearAppState(appId) {
    const keysToRemove = [];
    
    for (const key of Object.keys(this.state)) {
      if (key.startsWith(`${appId}.`)) {
        keysToRemove.push(key);
      }
    }
    
    const prevState = { ...this.state };
    
    for (const key of keysToRemove) {
      delete this.state[key];
    }
    
    this.saveToHistory('CLEAR_APP', { appId });
    this.notifySubscribers('*', this.state, prevState);
  }

  // 持久化状态
  persistState(key = 'micro-frontend-state') {
    try {
      const stateToPersist = {
        state: this.state,
        timestamp: Date.now()
      };
      localStorage.setItem(key, JSON.stringify(stateToPersist));
    } catch (error) {
      console.error('Failed to persist state:', error);
    }
  }

  // 恢复状态
  restoreState(key = 'micro-frontend-state') {
    try {
      const persistedData = localStorage.getItem(key);
      if (persistedData) {
        const { state, timestamp } = JSON.parse(persistedData);
        
        // 检查状态是否过期（24小时）
        const now = Date.now();
        const maxAge = 24 * 60 * 60 * 1000; // 24小时
        
        if (now - timestamp < maxAge) {
          this.state = { ...state };
          this.saveToHistory('RESTORE', { key });
          this.notifySubscribers('*', this.state, this.state);
          return true;
        }
      }
    } catch (error) {
      console.error('Failed to restore state:', error);
    }
    
    return false;
  }
}

// 微应用状态适配器
class MicroAppStateAdapter {
  constructor(appId, globalStateManager) {
    this.appId = appId;
    this.globalStateManager = globalStateManager;
    this.localState = {};
    this.localSubscribers = new Map();
  }

  // 获取本地状态
  getLocalState(path) {
    if (!path) return this.localState;
    return this.getNestedValue(this.localState, path);
  }

  // 设置本地状态
  setLocalState(path, value) {
    const prevState = { ...this.localState };
    
    if (path) {
      this.setNestedValue(this.localState, path, value);
    } else {
      this.localState = { ...value };
    }
    
    this.notifyLocalSubscribers(path, value, prevState);
  }

  // 获取全局状态
  getGlobalState(path) {
    const fullPath = path ? `${this.appId}.${path}` : this.appId;
    return this.globalStateManager.getState(fullPath);
  }

  // 设置全局状态
  setGlobalState(path, value) {
    const fullPath = path ? `${this.appId}.${path}` : this.appId;
    this.globalStateManager.setState(fullPath, value, this.appId);
  }

  // 订阅本地状态变化
  subscribeLocal(path, callback) {
    const id = `local-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    this.localSubscribers.set(id, { path, callback });
    
    return () => {
      this.localSubscribers.delete(id);
    };
  }

  // 订阅全局状态变化
  subscribeGlobal(path, callback) {
    const fullPath = path ? `${this.appId}.${path}` : this.appId;
    return this.globalStateManager.subscribe(fullPath, callback, this.appId);
  }

  // 通知本地订阅者
  notifyLocalSubscribers(path, value, prevState) {
    for (const [id, subscriber] of this.localSubscribers.entries()) {
      if (this.pathMatches(subscriber.path, path)) {
        const prevValue = this.getNestedValue(prevState, subscriber.path);
        const currentValue = this.getNestedValue(this.localState, subscriber.path);
        
        if (!this.deepEqual(prevValue, currentValue)) {
          try {
            subscriber.callback(currentValue, prevValue);
          } catch (error) {
            console.error(`Error in local subscriber ${id}:`, error);
          }
        }
      }
    }
  }

  // 路径匹配
  pathMatches(subscribedPath, changedPath) {
    return changedPath.startsWith(subscribedPath + '.') || changedPath === subscribedPath;
  }

  // 深度比较
  deepEqual(obj1, obj2) {
    if (obj1 === obj2) return true;
    
    if (obj1 == null || obj2 == null) return false;
    
    if (typeof obj1 !== typeof obj2) return false;
    
    if (typeof obj1 !== 'object') return obj1 === obj2;
    
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    
    if (keys1.length !== keys2.length) return false;
    
    for (const key of keys1) {
      if (!keys2.includes(key) || !this.deepEqual(obj1[key], obj2[key])) {
        return false;
      }
    }
    
    return true;
  }

  // 获取嵌套值
  getNestedValue(obj, path) {
    return path.split('.').reduce((current, key) => {
      return current && current[key] !== undefined ? current[key] : undefined;
    }, obj);
  }

  // 设置嵌套值
  setNestedValue(obj, path, value) {
    const keys = path.split('.');
    const lastKey = keys.pop();
    const target = keys.reduce((current, key) => {
      if (!current[key] || typeof current[key] !== 'object') {
        current[key] = {};
      }
      return current[key];
    }, obj);
    
    target[lastKey] = value;
  }

  // 清理资源
  cleanup() {
    this.globalStateManager.clearAppState(this.appId);
    this.localSubscribers.clear();
    this.localState = {};
  }
}

// 使用示例
const globalStateManager = new GlobalStateManager();

// 初始化全局状态
globalStateManager.initState({
  user: null,
  theme: 'light',
  notifications: []
});

// 添加中间件
globalStateManager.addMiddleware((action, state, next) => {
  console.log(`State action: ${action}`);
  next();
});

// 创建微应用状态适配器
const dashboardAdapter = new MicroAppStateAdapter('dashboard', globalStateManager);

// 订阅全局用户状态变化
globalStateManager.subscribe('user', (user, prevUser) => {
  console.log('User changed:', user);
});

// 设置全局用户状态
globalStateManager.setState('user', { id: 1, name: 'John Doe' });

// 微应用设置自己的全局状态
dashboardAdapter.setGlobalState('filters', { date: '2023-01-01' });

// 微应用使用本地状态
dashboardAdapter.setLocalState('ui', { sidebarOpen: true });

// 订阅本地状态变化
dashboardAdapter.subscribeLocal('ui', (ui, prevUi) => {
  console.log('Dashboard UI changed:', ui);
});
```

#### 2. 分布式状态管理

分布式状态管理允许各微应用管理自己的状态，通过事件机制实现状态同步。

```javascript
// 分布式状态管理器
class DistributedStateManager {
  constructor() {
    this.stores = new Map();
    this.eventBus = new EventTarget();
    this.sharedState = new Map();
    this.stateSyncRules = new Map();
  }

  // 注册应用状态存储
  registerStore(appId, store) {
    this.stores.set(appId, store);
    
    // 监听应用状态变化
    store.on('state-change', (event) => {
      this.handleStateChange(appId, event);
    });
  }

  // 处理状态变化
  handleStateChange(appId, event) {
    const { path, value, prevValue } = event;
    
    // 检查是否有同步规则
    const syncRules = this.findSyncRules(appId, path);
    
    for (const rule of syncRules) {
      this.applySyncRule(rule, appId, path, value);
    }
    
    // 触发全局状态变化事件
    this.eventBus.dispatchEvent(new CustomEvent('global-state-change', {
      detail: { appId, path, value, prevValue }
    }));
  }

  // 查找同步规则
  findSyncRules(appId, path) {
    const rules = [];
    
    for (const [ruleId, rule] of this.stateSyncRules.entries()) {
      if (rule.source.app === appId && this.pathMatches(rule.source.path, path)) {
        rules.push(rule);
      }
    }
    
    return rules;
  }

  // 应用同步规则
  async applySyncRule(rule, sourceApp, sourcePath, value) {
    const { target, transform } = rule;
    
    try {
      // 获取目标应用存储
      const targetStore = this.stores.get(target.app);
      if (!targetStore) {
        console.warn(`Target app ${target.app} not found`);
        return;
      }
      
      // 转换值
      const transformedValue = transform ? transform(value, sourceApp, sourcePath) : value;
      
      // 设置目标状态
      await targetStore.setState(target.path, transformedValue, {
        source: 'sync',
        sourceApp,
        sourcePath
      });
      
      console.log(`Synced state from ${sourceApp}:${sourcePath} to ${target.app}:${target.path}`);
    } catch (error) {
      console.error(`Failed to sync state:`, error);
    }
  }

  // 添加同步规则
  addSyncRule(ruleId, rule) {
    this.stateSyncRules.set(ruleId, rule);
  }

  // 移除同步规则
  removeSyncRule(ruleId) {
    this.stateSyncRules.delete(ruleId);
  }

  // 路径匹配
  pathMatches(rulePath, actualPath) {
    if (rulePath === '*') return true;
    
    if (rulePath.endsWith('*')) {
      const prefix = rulePath.slice(0, -1);
      return actualPath.startsWith(prefix);
    }
    
    return rulePath === actualPath;
  }

  // 设置共享状态
  setSharedState(key, value) {
    this.sharedState.set(key, value);
    
    this.eventBus.dispatchEvent(new CustomEvent('shared-state-change', {
      detail: { key, value }
    }));
  }

  // 获取共享状态
  getSharedState(key) {
    return this.sharedState.get(key);
  }

  // 订阅共享状态变化
  subscribeSharedState(key, callback) {
    const handler = (event) => {
      if (event.detail.key === key) {
        callback(event.detail.value);
      }
    };
    
    this.eventBus.addEventListener('shared-state-change', handler);
    
    // 返回取消订阅函数
    return () => {
      this.eventBus.removeEventListener('shared-state-change', handler);
    };
  }

  // 订阅全局状态变化
  subscribeGlobalState(callback) {
    const handler = (event) => {
      callback(event.detail);
    };
    
    this.eventBus.addEventListener('global-state-change', handler);
    
    // 返回取消订阅函数
    return () => {
      this.eventBus.removeEventListener('global-state-change', handler);
    };
  }
}

// 微应用状态存储
class MicroAppStateStore {
  constructor(appId) {
    this.appId = appId;
    this.state = {};
    this.subscribers = new Map();
    this.eventTarget = new EventTarget();
  }

  // 获取状态
  getState(path) {
    if (!path) return this.state;
    
    return this.getNestedValue(this.state, path);
  }

  // 设置状态
  async setState(path, value, options = {}) {
    const prevState = { ...this.state };
    
    if (path) {
      this.setNestedValue(this.state, path, value);
    } else {
      this.state = { ...value };
    }
    
    // 触发状态变化事件
    this.eventTarget.dispatchEvent(new CustomEvent('state-change', {
      detail: {
        path,
        value,
        prevValue: path ? this.getNestedValue(prevState, path) : prevState,
        options
      }
    }));
    
    // 通知订阅者
    this.notifySubscribers(path, value, prevState);
  }

  // 订阅状态变化
  subscribe(path, callback) {
    const id = `${this.appId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    this.subscribers.set(id, { path, callback });
    
    return () => {
      this.subscribers.delete(id);
    };
  }

  // 监听事件
  on(eventType, listener) {
    this.eventTarget.addEventListener(eventType, listener);
  }

  // 取消监听事件
  off(eventType, listener) {
    this.eventTarget.removeEventListener(eventType, listener);
  }

  // 通知订阅者
  notifySubscribers(path, value, prevState) {
    for (const [id, subscriber] of this.subscribers.entries()) {
      if (this.pathMatches(subscriber.path, path)) {
        const prevValue = this.getNestedValue(prevState, subscriber.path);
        const currentValue = this.getNestedValue(this.state, subscriber.path);
        
        if (!this.deepEqual(prevValue, currentValue)) {
          try {
            subscriber.callback(currentValue, prevValue);
          } catch (error) {
            console.error(`Error in subscriber ${id}:`, error);
          }
        }
      }
    }
  }

  // 路径匹配
  pathMatches(subscribedPath, changedPath) {
    return changedPath.startsWith(subscribedPath + '.') || changedPath === subscribedPath;
  }

  // 深度比较
  deepEqual(obj1, obj2) {
    if (obj1 === obj2) return true;
    
    if (obj1 == null || obj2 == null) return false;
    
    if (typeof obj1 !== typeof obj2) return false;
    
    if (typeof obj1 !== 'object') return obj1 === obj2;
    
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    
    if (keys1.length !== keys2.length) return false;
    
    for (const key of keys1) {
      if (!keys2.includes(key) || !this.deepEqual(obj1[key], obj2[key])) {
        return false;
      }
    }
    
    return true;
  }

  // 获取嵌套值
  getNestedValue(obj, path) {
    return path.split('.').reduce((current, key) => {
      return current && current[key] !== undefined ? current[key] : undefined;
    }, obj);
  }

  // 设置嵌套值
  setNestedValue(obj, path, value) {
    const keys = path.split('.');
    const lastKey = keys.pop();
    const target = keys.reduce((current, key) => {
      if (!current[key] || typeof current[key] !== 'object') {
        current[key] = {};
      }
      return current[key];
    }, obj);
    
    target[lastKey] = value;
  }
}

// 使用示例
const distributedStateManager = new DistributedStateManager();

// 创建微应用状态存储
const dashboardStore = new MicroAppStateStore('dashboard');
const profileStore = new MicroAppStateStore('profile');

// 注册状态存储
distributedStateManager.registerStore('dashboard', dashboardStore);
distributedStateManager.registerStore('profile', profileStore);

// 添加同步规则：dashboard的用户状态变化同步到profile
distributedStateManager.addSyncRule('user-sync', {
  source: { app: 'dashboard', path: 'user' },
  target: { app: 'profile', path: 'currentUser' },
  transform: (user) => ({ ...user, lastSync: Date.now() })
});

// 设置共享状态
distributedStateManager.setSharedState('theme', 'dark');

// 订阅共享状态变化
distributedStateManager.subscribeSharedState('theme', (theme) => {
  console.log('Theme changed:', theme);
  // 应用主题到所有微应用
});

// 设置dashboard应用状态
dashboardStore.setState('user', { id: 1, name: 'John Doe' });
// 这会自动同步到profile应用的currentUser状态

// 订阅profile应用状态变化
profileStore.subscribe('currentUser', (user) => {
  console.log('Profile current user:', user);
});
```

## 3.3 路由与状态管理集成

### 3.3.1 路由状态同步

```javascript
// 路由状态同步管理器
class RouteStateSyncManager {
  constructor(router, stateManager) {
    this.router = router;
    this.stateManager = stateManager;
    this.routeStateMap = new Map();
    this.isInitialized = false;
    
    this.init();
  }

  init() {
    // 监听路由变化
    this.router.on('route-change', this.handleRouteChange.bind(this));
    
    // 监听状态变化
    this.stateManager.subscribe('router', this.handleStateChange.bind(this));
    
    // 初始化路由状态
    this.syncRouteToState();
    
    this.isInitialized = true;
  }

  // 处理路由变化
  handleRouteChange(event) {
    const { path, params, query, state } = event.detail;
    
    // 更新路由状态
    this.stateManager.setState('router.currentPath', path);
    this.stateManager.setState('router.params', params);
    this.stateManager.setState('router.query', query);
    
    // 保存路由特定状态
    if (state) {
      this.saveRouteState(path, state);
    }
    
    // 恢复路由特定状态
    this.restoreRouteState(path);
  }

  // 处理状态变化
  handleStateChange(routerState) {
    if (!this.isInitialized) return;
    
    const { currentPath, params, query } = routerState;
    
    // 如果状态中的路径与当前路径不同，导航到新路径
    if (currentPath !== window.location.pathname) {
      this.router.navigate(currentPath, { replace: true });
    }
  }

  // 同步路由到状态
  syncRouteToState() {
    const currentPath = window.location.pathname;
    const params = this.router.getCurrentParams();
    const query = this.router.getCurrentQuery();
    
    this.stateManager.setState('router.currentPath', currentPath);
    this.stateManager.setState('router.params', params);
    this.stateManager.setState('router.query', query);
  }

  // 保存路由状态
  saveRouteState(path, state) {
    this.routeStateMap.set(path, { ...state, timestamp: Date.now() });
    
    // 限制保存的状态数量
    if (this.routeStateMap.size > 50) {
      const oldestKey = this.routeStateMap.keys().next().value;
      this.routeStateMap.delete(oldestKey);
    }
  }

  // 恢复路由状态
  restoreRouteState(path) {
    const routeState = this.routeStateMap.get(path);
    if (routeState) {
      // 恢复状态到各微应用
      for (const [key, value] of Object.entries(routeState)) {
        if (key !== 'timestamp') {
          this.stateManager.setState(`routeState.${path}.${key}`, value);
        }
      }
    }
  }

  // 清除路由状态
  clearRouteState(path) {
    this.routeStateMap.delete(path);
    this.stateManager.setState(`routeState.${path}`, null);
  }

  // 获取路由状态
  getRouteState(path) {
    return this.routeStateMap.get(path);
  }
}

// 使用示例
const router = new CentralizedRouter();
const stateManager = new GlobalStateManager();

// 创建路由状态同步管理器
const routeStateSync = new RouteStateSyncManager(router, stateManager);

// 导航到新路由
router.navigate('/dashboard/analytics', { 
  filter: 'date',
  dateRange: '2023-01-01,2023-01-31' 
});

// 路由状态会自动同步到状态管理器
// 当用户刷新页面或通过浏览器导航返回时，状态会自动恢复
```

### 3.3.2 路由守卫与权限控制

```javascript
// 路由守卫管理器
class RouteGuardManager {
  constructor(router, stateManager) {
    this.router = router;
    this.stateManager = stateManager;
    this.guards = new Map();
    this.globalGuards = [];
    this.permissionMap = new Map();
    
    this.init();
  }

  init() {
    // 监听路由变化
    this.router.on('before-route-change', this.handleBeforeRouteChange.bind(this));
    
    // 初始化权限状态
    this.initPermissionState();
  }

  // 初始化权限状态
  initPermissionState() {
    // 从状态管理器获取用户权限
    const userPermissions = this.stateManager.getState('user.permissions') || [];
    
    // 更新权限映射
    this.updatePermissionMap(userPermissions);
    
    // 订阅权限变化
    this.stateManager.subscribe('user.permissions', (permissions) => {
      this.updatePermissionMap(permissions);
    });
  }

  // 更新权限映射
  updatePermissionMap(permissions) {
    this.permissionMap.clear();
    
    for (const permission of permissions) {
      // 将权限转换为路由规则
      const routeRules = this.permissionToRouteRules(permission);
      
      for (const rule of routeRules) {
        if (!this.permissionMap.has(rule.path)) {
          this.permissionMap.set(rule.path, []);
        }
        
        this.permissionMap.get(rule.path).push(rule);
      }
    }
  }

  // 权限转换为路由规则
  permissionToRouteRules(permission) {
    const rules = [];
    
    // 基于权限资源生成路由规则
    switch (permission.resource) {
      case 'dashboard':
        rules.push({ path: '/dashboard', allowed: true });
        rules.push({ path: '/dashboard/*', allowed: true });
        break;
        
      case 'analytics':
        rules.push({ path: '/dashboard/analytics', allowed: true });
        break;
        
      case 'profile':
        rules.push({ path: '/profile', allowed: true });
        rules.push({ path: '/profile/*', allowed: true });
        break;
        
      case 'admin':
        rules.push({ path: '/admin/*', allowed: true });
        break;
    }
    
    return rules;
  }

  // 添加全局守卫
  addGlobalGuard(guard) {
    this.globalGuards.push(guard);
  }

  // 添加路由守卫
  addRouteGuard(path, guard) {
    if (!this.guards.has(path)) {
      this.guards.set(path, []);
    }
    
    this.guards.get(path).push(guard);
  }

  // 处理路由变化前事件
  async handleBeforeRouteChange(event) {
    const { path, params, query } = event.detail;
    
    try {
      // 执行全局守卫
      for (const guard of this.globalGuards) {
        const result = await guard({ path, params, query });
        if (!result.allowed) {
          event.preventDefault();
          this.handleGuardFailure(result, path);
          return;
        }
      }
      
      // 执行特定路由守卫
      const routeGuards = this.findRouteGuards(path);
      for (const guard of routeGuards) {
        const result = await guard({ path, params, query });
        if (!result.allowed) {
          event.preventDefault();
          this.handleGuardFailure(result, path);
          return;
        }
      }
      
      // 检查权限
      const hasPermission = await this.checkRoutePermission(path);
      if (!hasPermission) {
        event.preventDefault();
        this.handlePermissionDenied(path);
        return;
      }
      
      // 所有检查通过，允许导航
      console.log(`Navigation to ${path} allowed`);
    } catch (error) {
      console.error('Error in route guard:', error);
      event.preventDefault();
      this.handleGuardError(error, path);
    }
  }

  // 查找路由守卫
  findRouteGuards(path) {
    const guards = [];
    
    // 查找精确匹配的守卫
    if (this.guards.has(path)) {
      guards.push(...this.guards.get(path));
    }
    
    // 查找通配符匹配的守卫
    for (const [guardPath, pathGuards] of this.guards.entries()) {
      if (guardPath.endsWith('*')) {
        const prefix = guardPath.slice(0, -1);
        if (path.startsWith(prefix)) {
          guards.push(...pathGuards);
        }
      }
    }
    
    return guards;
  }

  // 检查路由权限
  async checkRoutePermission(path) {
    // 检查精确匹配的权限
    if (this.permissionMap.has(path)) {
      const rules = this.permissionMap.get(path);
      return rules.some(rule => rule.allowed);
    }
    
    // 检查通配符匹配的权限
    for (const [rulePath, rules] of this.permissionMap.entries()) {
      if (rulePath.endsWith('*')) {
        const prefix = rulePath.slice(0, -1);
        if (path.startsWith(prefix)) {
          return rules.some(rule => rule.allowed);
        }
      }
    }
    
    // 默认允许访问
    return true;
  }

  // 处理守卫失败
  handleGuardFailure(result, path) {
    const { redirectTo, message } = result;
    
    if (redirectTo) {
      this.router.navigate(redirectTo);
    }
    
    if (message) {
      // 显示错误消息
      this.showErrorMessage(message);
    }
    
    console.warn(`Navigation to ${path} blocked by guard:`, result);
  }

  // 处理权限拒绝
  handlePermissionDenied(path) {
    // 重定向到登录页或无权限页面
    const isLoggedIn = this.stateManager.getState('user.isLoggedIn');
    
    if (isLoggedIn) {
      this.router.navigate('/unauthorized');
    } else {
      this.router.navigate('/login', { redirectTo: path });
    }
    
    this.showErrorMessage('您没有权限访问此页面');
  }

  // 处理守卫错误
  handleGuardError(error, path) {
    console.error(`Error checking route guard for ${path}:`, error);
    
    // 显示错误消息
    this.showErrorMessage('路由检查出错，请稍后再试');
    
    // 重定向到安全页面
    this.router.navigate('/');
  }

  // 显示错误消息
  showErrorMessage(message) {
    // 实现错误消息显示逻辑
    console.error(message);
    
    // 可以使用通知组件或状态管理器来显示消息
    this.stateManager.setState('notifications', [{
      id: Date.now(),
      type: 'error',
      message,
      timestamp: Date.now()
    }]);
  }
}

// 使用示例
const router = new CentralizedRouter();
const stateManager = new GlobalStateManager();

// 创建路由守卫管理器
const routeGuardManager = new RouteGuardManager(router, stateManager);

// 添加全局守卫
routeGuardManager.addGlobalGuard(async ({ path }) => {
  // 检查用户是否已登录
  const isLoggedIn = stateManager.getState('user.isLoggedIn');
  
  if (!isLoggedIn && !['/login', '/register'].includes(path)) {
    return {
      allowed: false,
      redirectTo: '/login',
      message: '请先登录'
    };
  }
  
  return { allowed: true };
});

// 添加特定路由守卫
routeGuardManager.addRouteGuard('/admin/*', async ({ path }) => {
  // 检查是否为管理员
  const isAdmin = stateManager.getState('user.isAdmin');
  
  if (!isAdmin) {
    return {
      allowed: false,
      redirectTo: '/unauthorized',
      message: '需要管理员权限'
    };
  }
  
  return { allowed: true };
});

// 设置用户权限
stateManager.setState('user', {
  isLoggedIn: true,
  isAdmin: false,
  permissions: [
    { resource: 'dashboard' },
    { resource: 'profile' }
  ]
});

// 尝试导航到不同路由
router.navigate('/dashboard'); // 允许
router.navigate('/admin/users'); // 拒绝，重定向到 /unauthorized
```

## 3.4 实战案例

### 3.4.1 微前端路由与状态管理实战

下面是一个完整的微前端路由与状态管理实战案例，展示了如何在实际项目中应用这些概念。

```javascript
// 微前端应用管理器
class MicroFrontendAppManager {
  constructor() {
    this.apps = new Map();
    this.router = new CentralizedRouter();
    this.stateManager = new GlobalStateManager();
    this.routeStateSync = new RouteStateSyncManager(this.router, this.stateManager);
    this.routeGuardManager = new RouteGuardManager(this.router, this.stateManager);
    this.currentApp = null;
    
    this.init();
  }

  async init() {
    // 初始化状态
    this.stateManager.initState({
      user: null,
      theme: 'light',
      notifications: [],
      router: {
        currentPath: window.location.pathname,
        params: {},
        query: {}
      }
    });

    // 设置全局路由守卫
    this.setupGlobalGuards();

    // 初始化路由
    this.initRoutes();

    // 加载初始应用
    await this.loadInitialApp();
  }

  // 设置全局守卫
  setupGlobalGuards() {
    // 登录检查守卫
    this.routeGuardManager.addGlobalGuard(async ({ path }) => {
      const publicPaths = ['/login', '/register', '/forgot-password'];
      const isLoggedIn = this.stateManager.getState('user.isLoggedIn');

      if (!isLoggedIn && !publicPaths.includes(path)) {
        return {
          allowed: false,
          redirectTo: '/login',
          message: '请先登录'
        };
      }

      return { allowed: true };
    });

    // 主题同步守卫
    this.routeGuardManager.addGlobalGuard(async ({ path }) => {
      const theme = this.stateManager.getState('theme');
      document.documentElement.setAttribute('data-theme', theme);
      return { allowed: true };
    });
  }

  // 初始化路由
  initRoutes() {
    // 注册应用路由
    this.registerAppRoutes('dashboard', [
      { path: '/dashboard', component: 'DashboardHome' },
      { path: '/dashboard/analytics', component: 'Analytics' },
      { path: '/dashboard/reports', component: 'Reports' }
    ]);

    this.registerAppRoutes('profile', [
      { path: '/profile', component: 'ProfileHome' },
      { path: '/profile/settings', component: 'Settings' },
      { path: '/profile/security', component: 'Security' }
    ]);

    this.registerAppRoutes('admin', [
      { path: '/admin', component: 'AdminHome' },
      { path: '/admin/users', component: 'UserManagement' },
      { path: '/admin/permissions', component: 'PermissionManagement' }
    ]);

    // 设置路由守卫
    this.routeGuardManager.addRouteGuard('/admin/*', async ({ path }) => {
      const isAdmin = this.stateManager.getState('user.isAdmin');
      
      if (!isAdmin) {
        return {
          allowed: false,
          redirectTo: '/unauthorized',
          message: '需要管理员权限'
        };
      }
      
      return { allowed: true };
    });
  }

  // 注册应用路由
  registerAppRoutes(appName, routes) {
    this.router.registerAppRoutes(appName, routes);
  }

  // 加载初始应用
  async loadInitialApp() {
    const currentPath = window.location.pathname;
    const appName = this.router.findAppForRoute(currentPath);
    
    if (appName) {
      await this.loadApp(appName, currentPath);
    }
  }

  // 加载应用
  async loadApp(appName, path) {
    if (this.currentApp === appName) {
      // 同一应用内导航
      this.router.navigate(path);
      return;
    }

    // 卸载当前应用
    if (this.currentApp) {
      await this.unloadApp(this.currentApp);
    }

    // 加载新应用
    try {
      await this.doLoadApp(appName);
      this.currentApp = appName;
      
      // 导航到指定路径
      this.router.navigate(path);
      
      console.log(`App ${appName} loaded successfully`);
    } catch (error) {
      console.error(`Failed to load app ${appName}:`, error);
      
      // 显示错误页面
      this.showErrorPage(`Failed to load ${appName}`, error);
    }
  }

  // 实际加载应用
  async doLoadApp(appName) {
    // 显示加载状态
    this.showLoadingIndicator(appName);

    try {
      // 获取应用配置
      const appConfig = await this.fetchAppConfig(appName);
      
      // 加载应用资源
      await this.loadAppResources(appConfig);
      
      // 初始化应用
      await this.initApp(appName, appConfig);
      
      // 隐藏加载状态
      this.hideLoadingIndicator(appName);
    } catch (error) {
      this.hideLoadingIndicator(appName);
      throw error;
    }
  }

  // 卸载应用
  async unloadApp(appName) {
    try {
      // 调用应用卸载函数
      const appConfig = this.apps.get(appName);
      if (appConfig && window[appConfig.unmountFunction]) {
        await window[appConfig.unmountFunction]();
      }
      
      // 清理应用相关的状态
      this.stateManager.clearAppState(appName);
      
      // 移除应用容器
      const container = document.getElementById(`app-container-${appName}`);
      if (container) {
        container.remove();
      }
      
      console.log(`App ${appName} unloaded successfully`);
    } catch (error) {
      console.error(`Failed to unload app ${appName}:`, error);
    }
  }

  // 获取应用配置
  async fetchAppConfig(appName) {
    const response = await fetch(`/api/apps/${appName}/config`);
    if (!response.ok) {
      throw new Error(`Failed to fetch config for app ${appName}`);
    }
    return response.json();
  }

  // 加载应用资源
  async loadAppResources(appConfig) {
    const { js, css } = appConfig.assets;
    
    // 加载 CSS
    if (css && css.length > 0) {
      await Promise.all(css.map(url => this.loadCSS(url)));
    }
    
    // 加载 JS
    if (js && js.length > 0) {
      await Promise.all(js.map(url => this.loadScript(url)));
    }
  }

  // 加载 CSS
  loadCSS(url) {
    return new Promise((resolve, reject) => {
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = url;
      link.onload = resolve;
      link.onerror = reject;
      document.head.appendChild(link);
    });
  }

  // 加载 JS
  loadScript(url) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.onload = resolve;
      script.onerror = reject;
      document.body.appendChild(script);
    });
  }

  // 初始化应用
  async initApp(appName, appConfig) {
    // 保存应用配置
    this.apps.set(appName, appConfig);
    
    // 创建应用容器
    const container = this.createAppContainer(appName);
    
    // 调用应用初始化函数
    if (window[appConfig.mountFunction]) {
      await window[appConfig.mountFunction]({
        container,
        stateManager: this.createAppStateAdapter(appName),
        router: this.createAppRouter(appName),
        props: appConfig.props || {}
      });
    } else {
      throw new Error(`Mount function ${appConfig.mountFunction} not found`);
    }
  }

  // 创建应用容器
  createAppContainer(appName) {
    let container = document.getElementById(`app-container-${appName}`);
    if (!container) {
      container = document.createElement('div');
      container.id = `app-container-${appName}`;
      container.className = 'micro-app-container';
      document.getElementById('app-root').appendChild(container);
    }
    return container;
  }

  // 创建应用状态适配器
  createAppStateAdapter(appName) {
    return new MicroAppStateAdapter(appName, this.stateManager);
  }

  // 创建应用路由器
  createAppRouter(appName) {
    return {
      navigate: (path, state) => {
        // 确保路径包含应用前缀
        const fullPath = this.ensureAppPrefix(appName, path);
        this.router.navigate(fullPath, state);
      },
      
      getCurrentPath: () => {
        return this.router.getCurrentPath();
      },
      
      getCurrentParams: () => {
        return this.router.getCurrentParams();
      },
      
      getCurrentQuery: () => {
        return this.router.getCurrentQuery();
      }
    };
  }

  // 确保路径包含应用前缀
  ensureAppPrefix(appName, path) {
    // 根据应用配置确定路径前缀
    const appPrefix = this.getAppPrefix(appName);
    
    if (path.startsWith('/')) {
      return path.startsWith(appPrefix) ? path : `${appPrefix}${path}`;
    } else {
      return `${appPrefix}/${path}`;
    }
  }

  // 获取应用前缀
  getAppPrefix(appName) {
    const prefixMap = {
      'dashboard': '/dashboard',
      'profile': '/profile',
      'admin': '/admin'
    };
    
    return prefixMap[appName] || `/${appName}`;
  }

  // 显示加载指示器
  showLoadingIndicator(appName) {
    const indicator = document.createElement('div');
    indicator.id = `loading-${appName}`;
    indicator.className = 'micro-app-loading';
    indicator.innerHTML = `
      <div class="loading-spinner"></div>
      <div class="loading-text">Loading ${appName}...</div>
    `;
    document.body.appendChild(indicator);
  }

  // 隐藏加载指示器
  hideLoadingIndicator(appName) {
    const indicator = document.getElementById(`loading-${appName}`);
    if (indicator) {
      indicator.remove();
    }
  }

  // 显示错误页面
  showErrorPage(message, error) {
    const container = document.getElementById('app-root');
    container.innerHTML = `
      <div class="error-page">
        <h1>出错了</h1>
        <p>${message}</p>
        <details>
          <summary>详细信息</summary>
          <pre>${error.stack || error.toString()}</pre>
        </details>
        <button onclick="location.reload()">重新加载</button>
      </div>
    `;
  }

  // 登录
  async login(credentials) {
    try {
      // 调用登录 API
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(credentials)
      });
      
      if (!response.ok) {
        throw new Error('Login failed');
      }
      
      const userData = await response.json();
      
      // 更新用户状态
      this.stateManager.setState('user', {
        ...userData,
        isLoggedIn: true
      });
      
      // 持久化用户状态
      this.stateManager.persistState();
      
      // 重定向到原始请求的页面或主页
      const redirectTo = this.stateManager.getState('router.redirectTo') || '/dashboard';
      this.router.navigate(redirectTo);
      
      return { success: true };
    } catch (error) {
      console.error('Login error:', error);
      return { success: false, error: error.message };
    }
  }

  // 登出
  async logout() {
    try {
      // 调用登出 API
      await fetch('/api/auth/logout', { method: 'POST' });
      
      // 清除用户状态
      this.stateManager.setState('user', null);
      
      // 清除持久化状态
      localStorage.removeItem('micro-frontend-state');
      
      // 重定向到登录页
      this.router.navigate('/login');
      
      return { success: true };
    } catch (error) {
      console.error('Logout error:', error);
      return { success: false, error: error.message };
    }
  }
}

// 初始化微前端应用管理器
const appManager = new MicroFrontendAppManager();

// 导出全局对象供微应用使用
window.microFrontend = {
  navigate: (path, state) => appManager.router.navigate(path, state),
  getState: (path) => appManager.stateManager.getState(path),
  setState: (path, value) => appManager.stateManager.setState(path, value),
  subscribe: (path, callback) => appManager.stateManager.subscribe(path, callback),
  login: (credentials) => appManager.login(credentials),
  logout: () => appManager.logout()
};

// 监听浏览器导航
window.addEventListener('popstate', () => {
  const currentPath = window.location.pathname;
  const appName = appManager.router.findAppForRoute(currentPath);
  
  if (appName && appName !== appManager.currentApp) {
    appManager.loadApp(appName, currentPath);
  }
});
```

### 3.4.2 微应用实现示例

下面是一个微应用的实现示例，展示了如何在微应用中使用路由和状态管理。

```javascript
// 微应用入口文件
(function() {
  'use strict';

  // 微应用配置
  const appConfig = {
    name: 'dashboard',
    version: '1.0.0',
    dependencies: ['react', 'react-dom', 'react-router-dom'],
    assets: {
      js: ['/apps/dashboard/js/main.js'],
      css: ['/apps/dashboard/css/styles.css']
    },
    mountFunction: 'mountDashboardApp',
    unmountFunction: 'unmountDashboardApp'
  };

  // 微应用状态
  let isMounted = false;
  let rootContainer = null;
  let stateManager = null;
  let router = null;
  let reactRoot = null;

  // 挂载应用
  async function mountDashboardApp(props) {
    if (isMounted) return;
    
    try {
      // 解构传入的属性
      const { container, stateManager: sm, router: r } = props;
      rootContainer = container;
      stateManager = sm;
      router = r;
      
      // 初始化应用状态
      initAppState();
      
      // 渲染应用
      renderApp();
      
      isMounted = true;
      console.log('Dashboard app mounted');
    } catch (error) {
      console.error('Failed to mount dashboard app:', error);
      throw error;
    }
  }

  // 卸载应用
  async function unmountDashboardApp() {
    if (!isMounted) return;
    
    try {
      // 清理 React 组件
      if (reactRoot) {
        reactRoot.unmount();
        reactRoot = null;
      }
      
      // 清理状态订阅
      cleanupStateSubscriptions();
      
      // 清理容器
      if (rootContainer) {
        rootContainer.innerHTML = '';
        rootContainer = null;
      }
      
      isMounted = false;
      console.log('Dashboard app unmounted');
    } catch (error) {
      console.error('Failed to unmount dashboard app:', error);
      throw error;
    }
  }

  // 初始化应用状态
  function initAppState() {
    // 设置初始状态
    stateManager.setLocalState('ui', {
      sidebarOpen: true,
      activeTab: 'overview'
    });
    
    // 订阅全局用户状态变化
    stateManager.subscribeGlobal('user', (user) => {
      if (user) {
        // 用户登录，加载用户数据
        loadUserData(user.id);
      } else {
        // 用户登出，清除应用数据
        clearUserData();
      }
    });
    
    // 订阅路由变化
    stateManager.subscribeGlobal('router.currentPath', (path) => {
      if (path.startsWith('/dashboard')) {
        // 更新活动标签
        const tab = getTabFromPath(path);
        stateManager.setLocalState('ui.activeTab', tab);
      }
    });
  }

  // 渲染应用
  function renderApp() {
    const { createElement } = React;
    const { createRoot } = ReactDOM;
    
    // 创建 React 根节点
    reactRoot = createRoot(rootContainer);
    
    // 渲染应用组件
    reactRoot.render(createElement(DashboardApp));
  }

  // 仪表板应用组件
  function DashboardApp() {
    const [uiState, setUiState] = React.useState(() => 
      stateManager.getLocalState('ui') || { sidebarOpen: true, activeTab: 'overview' }
    );
    const [user, setUser] = React.useState(() => 
      stateManager.getGlobalState('user') || null
    );
    const [data, setData] = React.useState(() => 
      stateManager.getLocalState('data') || {}
    );
    
    // 订阅状态变化
    React.useEffect(() => {
      // 订阅 UI 状态变化
      const unsubscribeUi = stateManager.subscribeLocal('ui', (newUiState) => {
        setUiState(newUiState);
      });
      
      // 订阅用户状态变化
      const unsubscribeUser = stateManager.subscribeGlobal('user', (newUser) => {
        setUser(newUser);
      });
      
      // 订阅数据状态变化
      const unsubscribeData = stateManager.subscribeLocal('data', (newData) => {
        setData(newData);
      });
      
      return () => {
        unsubscribeUi();
        unsubscribeUser();
        unsubscribeData();
      };
    }, []);
    
    // 处理侧边栏切换
    const handleSidebarToggle = () => {
      stateManager.setLocalState('ui.sidebarOpen', !uiState.sidebarOpen);
    };
    
    // 处理标签切换
    const handleTabChange = (tab) => {
      stateManager.setLocalState('ui.activeTab', tab);
      
      // 更新路由
      const path = `/dashboard/${tab === 'overview' ? '' : tab}`;
      router.navigate(path);
    };
    
    // 渲染侧边栏
    const renderSidebar = () => {
      const { createElement } = React;
      
      return createElement('div', { className: `sidebar ${uiState.sidebarOpen ? 'open' : 'closed'}` }, [
        createElement('div', { key: 'header', className: 'sidebar-header' }, [
          createElement('h3', { key: 'title' }, '仪表板'),
          createElement('button', {
            key: 'toggle',
            className: 'sidebar-toggle',
            onClick: handleSidebarToggle
          }, '×')
        ]),
        createElement('nav', { key: 'nav', className: 'sidebar-nav' }, [
          createElement('button', {
            key: 'overview',
            className: `nav-item ${uiState.activeTab === 'overview' ? 'active' : ''}`,
            onClick: () => handleTabChange('overview')
          }, '概览'),
          createElement('button', {
            key: 'analytics',
            className: `nav-item ${uiState.activeTab === 'analytics' ? 'active' : ''}`,
            onClick: () => handleTabChange('analytics')
          }, '分析'),
          createElement('button', {
            key: 'reports',
            className: `nav-item ${uiState.activeTab === 'reports' ? 'active' : ''}`,
            onClick: () => handleTabChange('reports')
          }, '报告')
        ])
      ]);
    };
    
    // 渲染内容区域
    const renderContent = () => {
      const { createElement } = React;
      
      switch (uiState.activeTab) {
        case 'overview':
          return createElement(OverviewTab, { data, user });
        case 'analytics':
          return createElement(AnalyticsTab, { data, user });
        case 'reports':
          return createElement(ReportsTab, { data, user });
        default:
          return createElement('div', { className: 'tab-content' }, '未知标签页');
      }
    };
    
    // 渲染应用
    const { createElement } = React;
    
    return createElement('div', { className: 'dashboard-app' }, [
      renderSidebar(),
      createElement('div', { key: 'content', className: 'dashboard-content' }, [
        createElement('header', { key: 'header', className: 'dashboard-header' }, [
          createElement('h1', { key: 'title' }, '仪表板'),
          createElement('div', { key: 'user', className: 'user-info' }, [
            user ? `欢迎, ${user.name}` : '未登录',
            createElement('button', {
              key: 'logout',
              onClick: () => window.microFrontend.logout()
            }, '登出')
          ])
        ]),
        renderContent()
      ])
    ]);
  }

  // 概览标签页组件
  function OverviewTab({ data, user }) {
    const { createElement } = React;
    
    return createElement('div', { className: 'tab-content' }, [
      createElement('h2', { key: 'title' }, '概览'),
      createElement('div', { key: 'stats', className: 'stats-grid' }, [
        createElement('div', { key: 'users', className: 'stat-card' }, [
          createElement('h3', { key: 'title' }, '用户数'),
          createElement('p', { key: 'value' }, data.userCount || 0)
        ]),
        createElement('div', { key: 'revenue', className: 'stat-card' }, [
          createElement('h3', { key: 'title' }, '收入'),
          createElement('p', { key: 'value' }, `$${data.revenue || 0}`)
        ]),
        createElement('div', { key: 'orders', className: 'stat-card' }, [
          createElement('h3', { key: 'title' }, '订单数'),
          createElement('p', { key: 'value' }, data.orderCount || 0)
        ]),
        createElement('div', { key: 'conversion', className: 'stat-card' }, [
          createElement('h3', { key: 'title' }, '转化率'),
          createElement('p', { key: 'value' }, `${data.conversionRate || 0}%`)
        ])
      ]),
      createElement('div', { key: 'actions', className: 'action-buttons' }, [
        createElement('button', {
          key: 'refresh',
          className: 'btn btn-primary',
          onClick: () => refreshData()
        }, '刷新数据'),
        createElement('button', {
          key: 'export',
          className: 'btn btn-secondary',
          onClick: () => exportData()
        }, '导出报告')
      ])
    ]);
  }

  // 分析标签页组件
  function AnalyticsTab({ data, user }) {
    const { createElement } = React;
    
    return createElement('div', { className: 'tab-content' }, [
      createElement('h2', { key: 'title' }, '分析'),
      createElement('div', { key: 'charts', className: 'charts-container' }, [
        createElement('div', { key: 'chart1', className: 'chart' }, [
          createElement('h3', { key: 'title' }, '用户增长趋势'),
          createElement('div', { key: 'placeholder', className: 'chart-placeholder' }, '图表区域')
        ]),
        createElement('div', { key: 'chart2', className: 'chart' }, [
          createElement('h3', { key: 'title' }, '收入分析'),
          createElement('div', { key: 'placeholder', className: 'chart-placeholder' }, '图表区域')
        ])
      ]),
      createElement('div', { key: 'filters', className: 'filters' }, [
        createElement('label', { key: 'date-label' }, '日期范围:'),
        createElement('input', {
          key: 'date-start',
          type: 'date',
          onChange: (e) => handleDateChange('start', e.target.value)
        }),
        createElement('input', {
          key: 'date-end',
          type: 'date',
          onChange: (e) => handleDateChange('end', e.target.value)
        }),
        createElement('button', {
          key: 'apply',
          className: 'btn btn-primary',
          onClick: () => applyFilters()
        }, '应用')
      ])
    ]);
  }

  // 报告标签页组件
  function ReportsTab({ data, user }) {
    const { createElement } = React;
    
    return createElement('div', { className: 'tab-content' }, [
      createElement('h2', { key: 'title' }, '报告'),
      createElement('div', { key: 'reports-list', className: 'reports-list' }, [
        createElement('div', { key: 'report1', className: 'report-item' }, [
          createElement('h3', { key: 'title' }, '月度销售报告'),
          createElement('p', { key: 'desc' }, '2023年1月销售数据分析'),
          createElement('button', {
            key: 'view',
            className: 'btn btn-secondary',
            onClick: () => viewReport('monthly-sales')
          }, '查看')
        ]),
        createElement('div', { key: 'report2', className: 'report-item' }, [
          createElement('h3', { key: 'title' }, '用户行为分析'),
          createElement('p', { key: 'desc' }, '用户访问路径与转化分析'),
          createElement('button', {
            key: 'view',
            className: 'btn btn-secondary',
            onClick: () => viewReport('user-behavior')
          }, '查看')
        ])
      ]),
      createElement('div', { key: 'actions', className: 'action-buttons' }, [
        createElement('button', {
          key: 'generate',
          className: 'btn btn-primary',
          onClick: () => generateReport()
        }, '生成新报告')
      ])
    ]);
  }

  // 从路径获取标签
  function getTabFromPath(path) {
    if (path === '/dashboard' || path === '/dashboard/') {
      return 'overview';
    }
    
    const parts = path.split('/');
    return parts[parts.length - 1] || 'overview';
  }

  // 加载用户数据
  async function loadUserData(userId) {
    try {
      const response = await fetch(`/api/users/${userId}/dashboard-data`);
      if (!response.ok) {
        throw new Error('Failed to load user data');
      }
      
      const userData = await response.json();
      stateManager.setLocalState('data', userData);
    } catch (error) {
      console.error('Error loading user data:', error);
      stateManager.setLocalState('data.error', error.message);
    }
  }

  // 清除用户数据
  function clearUserData() {
    stateManager.setLocalState('data', {});
  }

  // 刷新数据
  async function refreshData() {
    const user = stateManager.getGlobalState('user');
    if (user) {
      await loadUserData(user.id);
    }
  }

  // 导出数据
  function exportData() {
    const data = stateManager.getLocalState('data');
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'dashboard-data.json';
    a.click();
    
    URL.revokeObjectURL(url);
  }

  // 处理日期变化
  function handleDateChange(type, value) {
    stateManager.setLocalState(`filters.date.${type}`, value);
  }

  // 应用过滤器
  function applyFilters() {
    const dateStart = stateManager.getLocalState('filters.date.start');
    const dateEnd = stateManager.getLocalState('filters.date.end');
    
    // 应用日期过滤器
    console.log('Applying date filter:', { dateStart, dateEnd });
    
    // 这里可以调用API获取过滤后的数据
  }

  // 查看报告
  function viewReport(reportId) {
    // 导航到报告详情页
    router.navigate(`/dashboard/reports/${reportId}`);
  }

  // 生成报告
  async function generateReport() {
    try {
      // 调用API生成报告
      const response = await fetch('/api/reports/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          type: 'dashboard-summary',
          userId: stateManager.getGlobalState('user.id')
        })
      });
      
      if (!response.ok) {
        throw new Error('Failed to generate report');
      }
      
      const report = await response.json();
      
      // 显示成功消息
      stateManager.setState('notifications', [{
        id: Date.now(),
        type: 'success',
        message: '报告生成成功',
        timestamp: Date.now()
      }]);
      
      // 导航到报告详情页
      router.navigate(`/dashboard/reports/${report.id}`);
    } catch (error) {
      console.error('Error generating report:', error);
      
      // 显示错误消息
      stateManager.setState('notifications', [{
        id: Date.now(),
        type: 'error',
        message: '报告生成失败',
        timestamp: Date.now()
      }]);
    }
  }

  // 清理状态订阅
  function cleanupStateSubscriptions() {
    // 这里可以清理所有状态订阅
    // 实际实现中，应该保存所有取消订阅函数并在卸载时调用
  }

  // 将挂载和卸载函数暴露到全局
  window.mountDashboardApp = mountDashboardApp;
  window.unmountDashboardApp = unmountDashboardApp;

  // 注册应用配置
  if (window.registerMicroApp) {
    window.registerMicroApp(appConfig);
  }
})();
```

## 总结

本章详细介绍了微前端架构中的路由与状态管理方案，主要包括：

1. **路由管理**：
   - 集中式路由管理：由主应用统一管理所有路由，微应用不直接操作路由
   - 分布式路由管理：各微应用管理自己的路由，通过协调机制解决冲突
   - 路由懒加载与预加载：按需加载微应用，优化性能

2. **状态管理**：
   - 集中式状态管理：由主应用管理全局状态，微应用通过API访问和更新状态
   - 分布式状态管理：各微应用管理自己的状态，通过事件机制实现状态同步
   - 状态隔离与共享：确保各微应用状态隔离，同时支持跨应用状态共享

3. **路由与状态管理集成**：
   - 路由状态同步：将路由信息同步到状态管理器，实现路由状态持久化
   - 路由守卫与权限控制：实现全局和特定路由的访问控制

4. **实战案例**：
   - 完整的微前端应用管理器实现
   - 微应用实现示例，展示如何在微应用中使用路由和状态管理

通过本章的学习，读者可以掌握微前端架构中路由与状态管理的核心概念和实现方法，为构建复杂的微前端应用打下坚实基础。