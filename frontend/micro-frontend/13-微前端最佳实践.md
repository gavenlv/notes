# 第十三章：微前端最佳实践

## 13.1 微前端最佳实践概述

### 13.1.1 微前端最佳实践的重要性

微前端架构虽然提供了许多优势，但其实施过程中也面临着诸多挑战。最佳实践的重要性体现在以下几个方面：

1. **降低实施风险**：通过借鉴成功经验，避免常见的陷阱和错误
2. **提高开发效率**：标准化的流程和工具可以显著提高团队效率
3. **保证系统质量**：经过验证的方法可以确保系统的稳定性和可维护性
4. **促进团队协作**：统一的规范和实践有助于跨团队协作
5. **加速技术演进**：最佳实践为技术演进提供了坚实的基础

### 13.1.2 微前端最佳实践分类

微前端最佳实践可以分为以下几个类别：

1. **架构设计最佳实践**：关于系统架构设计的原则和方法
2. **开发流程最佳实践**：关于开发流程和协作方式的规范
3. **技术实现最佳实践**：关于具体技术实现的方法和技巧
4. **性能优化最佳实践**：关于系统性能优化的策略和技巧
5. **安全防护最佳实践**：关于系统安全防护的措施和方法
6. **团队协作最佳实践**：关于团队组织和协作的模式和流程

### 13.1.3 最佳实践应用原则

应用微前端最佳实践时应遵循以下原则：

1. **因地制宜**：根据具体业务场景和团队能力选择适合的实践
2. **循序渐进**：逐步引入最佳实践，避免一次性大规模变革
3. **持续改进**：定期评估和调整实践，适应不断变化的需求
4. **平衡取舍**：在不同目标之间找到平衡点，避免极端化
5. **文档沉淀**：将实践经验文档化，促进知识共享和传承

## 13.2 架构设计最佳实践

### 13.2.1 领域驱动设计

领域驱动设计（Domain-Driven Design, DDD）是微前端架构设计的重要指导原则：

```javascript
// 示例：基于领域驱动设计的微前端架构
class DomainDrivenMicroFrontendArchitecture {
  constructor() {
    this.domains = new Map();
    this.boundedContexts = new Map();
    this.contextMaps = new Map();
    this.antiCorruptionLayers = new Map();
  }

  // 添加领域
  addDomain(domainId, domainInfo) {
    this.domains.set(domainId, {
      id: domainId,
      name: domainInfo.name,
      description: domainInfo.description,
      subdomains: domainInfo.subdomains || [],
      coreDomain: domainInfo.coreDomain || false
    });
  }

  // 添加限界上下文
  addBoundedContext(contextId, contextInfo) {
    this.boundedContexts.set(contextId, {
      id: contextId,
      name: contextInfo.name,
      domainId: contextInfo.domainId,
      description: contextInfo.description,
      responsibilities: contextInfo.responsibilities || [],
      models: contextInfo.models || [],
      services: contextInfo.services || []
    });
  }

  // 添加上下文映射
  addContextMap(mapId, mapInfo) {
    this.contextMaps.set(mapId, {
      id: mapId,
      name: mapInfo.name,
      upstream: mapInfo.upstream,
      downstream: mapInfo.downstream,
      relationship: mapInfo.relationship, // 'customer-supplier', 'conformist', 'partnership'
      integrationMechanism: mapInfo.integrationMechanism
    });
  }

  // 添加防腐层
  addAntiCorruptionLayer(layerId, layerInfo) {
    this.antiCorruptionLayers.set(layerId, {
      id: layerId,
      name: layerInfo.name,
      sourceContext: layerInfo.sourceContext,
      targetContext: layerInfo.targetContext,
      adapters: layerInfo.adapters || [],
      translators: layerInfo.translators || []
    });
  }

  // 设计微前端架构
  designArchitecture() {
    const architecture = {
      domains: Array.from(this.domains.values()),
      boundedContexts: Array.from(this.boundedContexts.values()),
      contextMaps: Array.from(this.contextMaps.values()),
      antiCorruptionLayers: Array.from(this.antiCorruptionLayers.values()),
      microFrontends: this.mapBoundedContextsToMicroFrontends()
    };

    return architecture;
  }

  // 将限界上下文映射到微前端
  mapBoundedContextsToMicroFrontends() {
    const microFrontends = [];

    for (const context of this.boundedContexts.values()) {
      const domain = this.domains.get(context.domainId);
      
      microFrontends.push({
        id: `mf-${context.id}`,
        name: context.name,
        domain: domain.name,
        responsibilities: context.responsibilities,
        models: context.models,
        services: context.services,
        dependencies: this.findContextDependencies(context.id)
      });
    }

    return microFrontends;
  }

  // 查找上下文依赖
  findContextDependencies(contextId) {
    const dependencies = [];

    for (const map of this.contextMaps.values()) {
      if (map.downstream === contextId) {
        dependencies.push({
          contextId: map.upstream,
          relationship: map.relationship,
          integrationMechanism: map.integrationMechanism
        });
      }
    }

    return dependencies;
  }
}

// 使用示例
const dddArchitecture = new DomainDrivenMicroFrontendArchitecture();

// 添加领域
dddArchitecture.addDomain('user', {
  name: '用户领域',
  description: '处理用户相关的业务逻辑',
  subdomains: ['身份认证', '用户资料', '权限管理'],
  coreDomain: true
});

dddArchitecture.addDomain('product', {
  name: '产品领域',
  description: '处理产品相关的业务逻辑',
  subdomains: ['产品信息', '产品分类', '产品搜索'],
  coreDomain: true
});

dddArchitecture.addDomain('order', {
  name: '订单领域',
  description: '处理订单相关的业务逻辑',
  subdomains: ['购物车', '订单处理', '支付'],
  coreDomain: false
});

// 添加限界上下文
dddArchitecture.addBoundedContext('user-auth', {
  name: '用户认证',
  domainId: 'user',
  description: '处理用户注册、登录、身份验证',
  responsibilities: ['用户注册', '用户登录', '身份验证', '令牌管理'],
  models: ['User', 'Credential', 'Token'],
  services: ['AuthService', 'TokenService']
});

dddArchitecture.addBoundedContext('user-profile', {
  name: '用户资料',
  domainId: 'user',
  description: '处理用户资料管理',
  responsibilities: ['资料查看', '资料编辑', '头像上传'],
  models: ['UserProfile', 'Avatar'],
  services: ['ProfileService', 'AvatarService']
});

dddArchitecture.addBoundedContext('product-catalog', {
  name: '产品目录',
  domainId: 'product',
  description: '处理产品展示和搜索',
  responsibilities: ['产品列表', '产品详情', '产品搜索'],
  models: ['Product', 'Category', 'SearchCriteria'],
  services: ['ProductService', 'SearchService']
});

dddArchitecture.addBoundedContext('order-management', {
  name: '订单管理',
  domainId: 'order',
  description: '处理订单创建和管理',
  responsibilities: ['购物车管理', '订单创建', '订单查询'],
  models: ['Cart', 'Order', 'OrderItem'],
  services: ['CartService', 'OrderService']
});

// 添加上下文映射
dddArchitecture.addContextMap('user-profile-to-auth', {
  name: '用户资料到认证',
  upstream: 'user-auth',
  downstream: 'user-profile',
  relationship: 'customer-supplier',
  integrationMechanism: 'shared-kernel'
});

dddArchitecture.addContextMap('order-to-user', {
  name: '订单到用户',
  upstream: 'user-auth',
  downstream: 'order-management',
  relationship: 'conformist',
  integrationMechanism: 'api-gateway'
});

dddArchitecture.addContextMap('order-to-product', {
  name: '订单到产品',
  upstream: 'product-catalog',
  downstream: 'order-management',
  relationship: 'partnership',
  integrationMechanism: 'event-bus'
});

// 设计架构
const architecture = dddArchitecture.designArchitecture();
console.log('微前端架构:', architecture);
```

### 13.2.2 单一职责原则

微前端应用应遵循单一职责原则，每个微应用专注于一个特定的业务领域：

```javascript
// 示例：基于单一职责原则的微前端设计
class SingleResponsibilityMicroFrontend {
  constructor() {
    this.microFrontends = new Map();
    this.responsibilityMatrix = new Map();
    this.couplingMetrics = new Map();
  }

  // 添加微前端
  addMicroFrontend(mfId, mfInfo) {
    this.microFrontends.set(mfId, {
      id: mfId,
      name: mfInfo.name,
      description: mfInfo.description,
      responsibilities: mfInfo.responsibilities || [],
      apis: mfInfo.apis || [],
      dependencies: mfInfo.dependencies || []
    });
  }

  // 添加职责矩阵
  addResponsibilityMatrix(mfId, responsibilities) {
    this.responsibilityMatrix.set(mfId, responsibilities);
  }

  // 添加耦合度量
  addCouplingMetric(mfId, metrics) {
    this.couplingMetrics.set(mfId, metrics);
  }

  // 评估单一职责原则遵循情况
  assessSingleResponsibility() {
    const assessment = {
      overallScore: 0,
      microFrontends: []
    };

    let totalScore = 0;
    let count = 0;

    for (const mfId of this.microFrontends.keys()) {
      const mf = this.microFrontends.get(mfId);
      const responsibilities = this.responsibilityMatrix.get(mfId) || {};
      const coupling = this.couplingMetrics.get(mfId) || {};
      
      const score = this.calculateResponsibilityScore(mf, responsibilities, coupling);
      const violations = this.identifyViolations(mf, responsibilities, coupling);
      
      assessment.microFrontends.push({
        id: mfId,
        name: mf.name,
        score: score,
        violations: violations,
        recommendations: this.generateRecommendations(violations)
      });
      
      totalScore += score;
      count++;
    }

    assessment.overallScore = count > 0 ? totalScore / count : 0;
    assessment.grade = this.getGrade(assessment.overallScore);

    return assessment;
  }

  // 计算职责得分
  calculateResponsibilityScore(mf, responsibilities, coupling) {
    let score = 100;
    
    // 职责数量过多扣分
    const responsibilityCount = Object.keys(responsibilities).length;
    if (responsibilityCount > 5) {
      score -= (responsibilityCount - 5) * 10;
    }
    
    // 职责相关性低扣分
    const relevanceScore = this.calculateResponsibilityRelevance(responsibilities);
    score -= (1 - relevanceScore) * 30;
    
    // 耦合度高扣分
    const couplingScore = this.calculateCouplingScore(coupling);
    score -= (1 - couplingScore) * 40;
    
    return Math.max(0, score);
  }

  // 计算职责相关性
  calculateResponsibilityRelevance(responsibilities) {
    if (Object.keys(responsibilities).length <= 1) {
      return 1;
    }
    
    // 简化的相关性计算，实际应用中可能需要更复杂的算法
    const categories = Object.values(responsibilities);
    const uniqueCategories = [...new Set(categories)];
    
    // 如果所有职责属于同一类别，相关性为1
    if (uniqueCategories.length === 1) {
      return 1;
    }
    
    // 否则根据类别数量计算相关性
    return 1 / uniqueCategories.length;
  }

  // 计算耦合得分
  calculateCouplingScore(coupling) {
    if (!coupling.dependencies || coupling.dependencies.length === 0) {
      return 1;
    }
    
    // 简化的耦合计算，实际应用中可能需要更复杂的算法
    let score = 1;
    
    // 依赖数量越多，耦合度越高，得分越低
    score -= coupling.dependencies.length * 0.1;
    
    // 数据耦合比接口耦合更严重
    const dataCouplingCount = coupling.dependencies.filter(d => d.type === 'data').length;
    score -= dataCouplingCount * 0.2;
    
    return Math.max(0, score);
  }

  // 识别违规
  identifyViolations(mf, responsibilities, coupling) {
    const violations = [];
    
    // 检查职责过多
    if (Object.keys(responsibilities).length > 5) {
      violations.push({
        type: 'too-many-responsibilities',
        description: `微前端${mf.name}职责过多，有${Object.keys(responsibilities).length}个职责`,
        severity: 'high'
      });
    }
    
    // 检查职责不相关
    const categories = [...new Set(Object.values(responsibilities))];
    if (categories.length > 2) {
      violations.push({
        type: 'unrelated-responsibilities',
        description: `微前端${mf.name}包含不相关的职责，涉及${categories.length}个不同领域`,
        severity: 'medium'
      });
    }
    
    // 检查耦合度过高
    if (coupling.dependencies && coupling.dependencies.length > 3) {
      violations.push({
        type: 'high-coupling',
        description: `微前端${mf.name}耦合度过高，有${coupling.dependencies.length}个依赖`,
        severity: 'high'
      });
    }
    
    return violations;
  }

  // 生成建议
  generateRecommendations(violations) {
    const recommendations = [];
    
    for (const violation of violations) {
      switch (violation.type) {
        case 'too-many-responsibilities':
          recommendations.push('考虑将部分职责拆分到其他微前端');
          break;
        case 'unrelated-responsibilities':
          recommendations.push('按业务领域重新组织微前端职责');
          break;
        case 'high-coupling':
          recommendations.push('引入防腐层减少直接依赖');
          recommendations.push('使用事件驱动架构减少耦合');
          break;
      }
    }
    
    return recommendations;
  }

  // 获取等级
  getGrade(score) {
    if (score >= 90) return 'A';
    if (score >= 80) return 'B';
    if (score >= 70) return 'C';
    if (score >= 60) return 'D';
    return 'F';
  }
}

// 使用示例
const srpMicroFrontend = new SingleResponsibilityMicroFrontend();

// 添加微前端
srpMicroFrontend.addMicroFrontend('user-auth', {
  name: '用户认证',
  description: '处理用户认证相关功能',
  responsibilities: ['用户注册', '用户登录', '密码重置', '身份验证'],
  apis: ['POST /api/register', 'POST /api/login', 'POST /api/reset-password'],
  dependencies: []
});

srpMicroFrontend.addMicroFrontend('user-profile', {
  name: '用户资料',
  description: '处理用户资料相关功能',
  responsibilities: ['资料查看', '资料编辑', '头像上传'],
  apis: ['GET /api/profile', 'PUT /api/profile', 'POST /api/avatar'],
  dependencies: [{ id: 'user-auth', type: 'interface' }]
});

srpMicroFrontend.addMicroFrontend('product-catalog', {
  name: '产品目录',
  description: '处理产品展示和搜索',
  responsibilities: ['产品列表', '产品详情', '产品搜索', '产品分类', '产品推荐'],
  apis: ['GET /api/products', 'GET /api/products/:id', 'GET /api/search'],
  dependencies: []
});

srpMicroFrontend.addMicroFrontend('order-management', {
  name: '订单管理',
  description: '处理订单相关功能',
  responsibilities: ['购物车管理', '订单创建', '订单查询', '支付处理', '物流跟踪'],
  apis: ['GET /api/cart', 'POST /api/orders', 'GET /api/orders/:id'],
  dependencies: [
    { id: 'user-auth', type: 'interface' },
    { id: 'product-catalog', type: 'interface' },
    { id: 'user-profile', type: 'data' }
  ]
});

// 添加职责矩阵
srpMicroFrontend.addResponsibilityMatrix('user-auth', {
  '用户注册': 'authentication',
  '用户登录': 'authentication',
  '密码重置': 'authentication',
  '身份验证': 'authentication'
});

srpMicroFrontend.addResponsibilityMatrix('user-profile', {
  '资料查看': 'profile',
  '资料编辑': 'profile',
  '头像上传': 'profile'
});

srpMicroFrontend.addResponsibilityMatrix('product-catalog', {
  '产品列表': 'catalog',
  '产品详情': 'catalog',
  '产品搜索': 'search',
  '产品分类': 'catalog',
  '产品推荐': 'recommendation'
});

srpMicroFrontend.addResponsibilityMatrix('order-management', {
  '购物车管理': 'cart',
  '订单创建': 'order',
  '订单查询': 'order',
  '支付处理': 'payment',
  '物流跟踪': 'logistics'
});

// 添加耦合度量
srpMicroFrontend.addCouplingMetric('user-auth', {
  dependencies: [],
  afferent: 2,
  efferent: 0,
  instability: 0
});

srpMicroFrontend.addCouplingMetric('user-profile', {
  dependencies: [{ id: 'user-auth', type: 'interface' }],
  afferent: 1,
  efferent: 1,
  instability: 0.5
});

srpMicroFrontend.addCouplingMetric('product-catalog', {
  dependencies: [],
  afferent: 1,
  efferent: 0,
  instability: 0
});

srpMicroFrontend.addCouplingMetric('order-management', {
  dependencies: [
    { id: 'user-auth', type: 'interface' },
    { id: 'product-catalog', type: 'interface' },
    { id: 'user-profile', type: 'data' }
  ],
  afferent: 0,
  efferent: 3,
  instability: 1
});

// 评估单一职责原则遵循情况
const assessment = srpMicroFrontend.assessSingleResponsibility();
console.log('单一职责原则评估:', assessment);
```

### 13.2.3 依赖倒置原则

依赖倒置原则是微前端架构设计的重要原则，可以减少微应用之间的耦合：

```javascript
// 示例：基于依赖倒置原则的微前端设计
class DependencyInversionMicroFrontend {
  constructor() {
    this.microFrontends = new Map();
    this.abstractions = new Map();
    this.implementations = new Map();
    this.dependencyGraph = new Map();
  }

  // 添加微前端
  addMicroFrontend(mfId, mfInfo) {
    this.microFrontends.set(mfId, {
      id: mfId,
      name: mfInfo.name,
      description: mfInfo.description,
      abstractions: mfInfo.abstractions || [],
      implementations: mfInfo.implementations || [],
      dependencies: mfInfo.dependencies || []
    });
  }

  // 添加抽象
  addAbstraction(abstractionId, abstractionInfo) {
    this.abstractions.set(abstractionId, {
      id: abstractionId,
      name: abstractionInfo.name,
      description: abstractionInfo.description,
      methods: abstractionInfo.methods || [],
      events: abstractionInfo.events || []
    });
  }

  // 添加实现
  addImplementation(implementationId, implementationInfo) {
    this.implementations.set(implementationId, {
      id: implementationId,
      name: implementationInfo.name,
      abstractionId: implementationInfo.abstractionId,
      microFrontendId: implementationInfo.microFrontendId,
      methods: implementationInfo.methods || {},
      events: implementationInfo.events || {}
    });
  }

  // 添加依赖关系
  addDependency(fromMfId, toAbstractionId) {
    if (!this.dependencyGraph.has(fromMfId)) {
      this.dependencyGraph.set(fromMfId, []);
    }
    
    this.dependencyGraph.get(fromMfId).push(toAbstractionId);
  }

  // 分析依赖倒置
  analyzeDependencyInversion() {
    const analysis = {
      violations: [],
      recommendations: [],
      dependencyGraph: this.buildDependencyGraph(),
      abstractionUsage: this.analyzeAbstractionUsage()
    };

    // 检查依赖倒置违规
    for (const mfId of this.microFrontends.keys()) {
      const mf = this.microFrontends.get(mfId);
      const violations = this.checkDependencyInversionViolations(mfId, mf);
      analysis.violations.push(...violations);
    }

    // 生成建议
    analysis.recommendations = this.generateDependencyInversionRecommendations(analysis.violations);

    return analysis;
  }

  // 构建依赖图
  buildDependencyGraph() {
    const graph = {
      nodes: [],
      edges: []
    };

    // 添加节点
    for (const mf of this.microFrontends.values()) {
      graph.nodes.push({
        id: mf.id,
        name: mf.name,
        type: 'micro-frontend'
      });
    }

    for (const abstraction of this.abstractions.values()) {
      graph.nodes.push({
        id: abstraction.id,
        name: abstraction.name,
        type: 'abstraction'
      });
    }

    for (const implementation of this.implementations.values()) {
      graph.nodes.push({
        id: implementation.id,
        name: implementation.name,
        type: 'implementation'
      });
    }

    // 添加边
    for (const [fromMfId, toAbstractionIds] of this.dependencyGraph) {
      for (const toAbstractionId of toAbstractionIds) {
        graph.edges.push({
          from: fromMfId,
          to: toAbstractionId,
          type: 'depends-on'
        });
      }
    }

    for (const implementation of this.implementations.values()) {
      graph.edges.push({
        from: implementation.id,
        to: implementation.abstractionId,
        type: 'implements'
      });

      graph.edges.push({
        from: implementation.microFrontendId,
        to: implementation.id,
        type: 'provides'
      });
    }

    return graph;
  }

  // 分析抽象使用情况
  analyzeAbstractionUsage() {
    const usage = {};

    for (const abstraction of this.abstractions.values()) {
      const implementations = [];
      const dependents = [];

      // 查找实现
      for (const implementation of this.implementations.values()) {
        if (implementation.abstractionId === abstraction.id) {
          implementations.push({
            id: implementation.id,
            name: implementation.name,
            microFrontendId: implementation.microFrontendId
          });
        }
      }

      // 查找依赖者
      for (const [mfId, abstractionIds] of this.dependencyGraph) {
        if (abstractionIds.includes(abstraction.id)) {
          dependents.push(mfId);
        }
      }

      usage[abstraction.id] = {
        name: abstraction.name,
        implementations: implementations,
        dependents: dependents,
        implementationCount: implementations.length,
        dependentCount: dependents.length
      };
    }

    return usage;
  }

  // 检查依赖倒置违规
  checkDependencyInversionViolations(mfId, mf) {
    const violations = [];

    // 检查是否直接依赖具体实现
    for (const dependency of mf.dependencies) {
      if (dependency.type === 'implementation') {
        violations.push({
          type: 'direct-dependency-on-implementation',
          microFrontendId: mfId,
          microFrontendName: mf.name,
          dependencyId: dependency.id,
          description: `${mf.name}直接依赖具体实现${dependency.id}，违反依赖倒置原则`,
          severity: 'high'
        });
      }
    }

    // 检查是否有未定义抽象的实现
    for (const implementationId of mf.implementations) {
      const implementation = this.implementations.get(implementationId);
      if (implementation && !this.abstractions.has(implementation.abstractionId)) {
        violations.push({
          type: 'implementation-without-abstraction',
          microFrontendId: mfId,
          microFrontendName: mf.name,
          implementationId: implementationId,
          description: `${mf.name}提供了实现${implementationId}，但没有定义对应的抽象`,
          severity: 'medium'
        });
      }
    }

    return violations;
  }

  // 生成依赖倒置建议
  generateDependencyInversionRecommendations(violations) {
    const recommendations = [];

    for (const violation of violations) {
      switch (violation.type) {
        case 'direct-dependency-on-implementation':
          recommendations.push({
            type: 'introduce-abstraction',
            description: `为${violation.dependencyId}引入抽象，让${violation.microFrontendName}依赖抽象而非具体实现`,
            steps: [
              `定义${violation.dependencyId}的抽象接口`,
              `修改${violation.microFrontendName}依赖抽象接口`,
              `确保${violation.dependencyId}实现抽象接口`
            ]
          });
          break;
        case 'implementation-without-abstraction':
          recommendations.push({
            type: 'define-abstraction',
            description: `为${violation.implementationId}定义对应的抽象接口`,
            steps: [
              `分析${violation.implementationId}的功能`,
              `定义抽象接口`,
              `让${violation.implementationId}实现抽象接口`
            ]
          });
          break;
      }
    }

    return recommendations;
  }
}

// 使用示例
const diMicroFrontend = new DependencyInversionMicroFrontend();

// 添加微前端
diMicroFrontend.addMicroFrontend('user-auth', {
  name: '用户认证',
  description: '处理用户认证相关功能',
  abstractions: ['auth-service'],
  implementations: ['auth-service-impl'],
  dependencies: []
});

diMicroFrontend.addMicroFrontend('user-profile', {
  name: '用户资料',
  description: '处理用户资料相关功能',
  abstractions: ['profile-service'],
  implementations: ['profile-service-impl'],
  dependencies: [{ id: 'auth-service', type: 'abstraction' }]
});

diMicroFrontend.addMicroFrontend('product-catalog', {
  name: '产品目录',
  description: '处理产品展示和搜索',
  abstractions: ['product-service', 'search-service'],
  implementations: ['product-service-impl', 'search-service-impl'],
  dependencies: []
});

diMicroFrontend.addMicroFrontend('order-management', {
  name: '订单管理',
  description: '处理订单相关功能',
  abstractions: ['order-service', 'payment-service'],
  implementations: ['order-service-impl', 'payment-service-impl'],
  dependencies: [
    { id: 'auth-service', type: 'abstraction' },
    { id: 'product-service', type: 'abstraction' }
  ]
});

// 添加抽象
diMicroFrontend.addAbstraction('auth-service', {
  name: '认证服务',
  description: '用户认证相关服务接口',
  methods: ['login', 'logout', 'register', 'resetPassword'],
  events: ['userLoggedIn', 'userLoggedOut', 'userRegistered']
});

diMicroFrontend.addAbstraction('profile-service', {
  name: '用户资料服务',
  description: '用户资料相关服务接口',
  methods: ['getProfile', 'updateProfile', 'uploadAvatar'],
  events: ['profileUpdated', 'avatarUploaded']
});

diMicroFrontend.addAbstraction('product-service', {
  name: '产品服务',
  description: '产品相关服务接口',
  methods: ['getProduct', 'getProducts', 'getCategories'],
  events: ['productUpdated', 'categoryUpdated']
});

diMicroFrontend.addAbstraction('search-service', {
  name: '搜索服务',
  description: '搜索相关服务接口',
  methods: ['search', 'suggest', 'getIndexStatus'],
  events: ['indexUpdated']
});

diMicroFrontend.addAbstraction('order-service', {
  name: '订单服务',
  description: '订单相关服务接口',
  methods: ['createOrder', 'getOrder', 'getOrders'],
  events: ['orderCreated', 'orderUpdated']
});

diMicroFrontend.addAbstraction('payment-service', {
  name: '支付服务',
  description: '支付相关服务接口',
  methods: ['createPayment', 'getPaymentStatus', 'refund'],
  events: ['paymentCreated', 'paymentCompleted', 'paymentFailed']
});

// 添加实现
diMicroFrontend.addImplementation('auth-service-impl', {
  name: '认证服务实现',
  abstractionId: 'auth-service',
  microFrontendId: 'user-auth',
  methods: {
    login: 'username/password',
    logout: 'token',
    register: 'user info',
    resetPassword: 'email'
  },
  events: {
    userLoggedIn: 'userId',
    userLoggedOut: 'userId',
    userRegistered: 'userId'
  }
});

diMicroFrontend.addImplementation('profile-service-impl', {
  name: '用户资料服务实现',
  abstractionId: 'profile-service',
  microFrontendId: 'user-profile',
  methods: {
    getProfile: 'userId',
    updateProfile: 'userId, profile',
    uploadAvatar: 'userId, file'
  },
  events: {
    profileUpdated: 'userId',
    avatarUploaded: 'userId'
  }
});

diMicroFrontend.addImplementation('product-service-impl', {
  name: '产品服务实现',
  abstractionId: 'product-service',
  microFrontendId: 'product-catalog',
  methods: {
    getProduct: 'productId',
    getProducts: 'criteria',
    getCategories: 'parentId'
  },
  events: {
    productUpdated: 'productId',
    categoryUpdated: 'categoryId'
  }
});

diMicroFrontend.addImplementation('search-service-impl', {
  name: '搜索服务实现',
  abstractionId: 'search-service',
  microFrontendId: 'product-catalog',
  methods: {
    search: 'query, filters',
    suggest: 'query',
    getIndexStatus: 'none'
  },
  events: {
    indexUpdated: 'indexName'
  }
});

diMicroFrontend.addImplementation('order-service-impl', {
  name: '订单服务实现',
  abstractionId: 'order-service',
  microFrontendId: 'order-management',
  methods: {
    createOrder: 'orderData',
    getOrder: 'orderId',
    getOrders: 'userId, status'
  },
  events: {
    orderCreated: 'orderId',
    orderUpdated: 'orderId'
  }
});

diMicroFrontend.addImplementation('payment-service-impl', {
  name: '支付服务实现',
  abstractionId: 'payment-service',
  microFrontendId: 'order-management',
  methods: {
    createPayment: 'paymentData',
    getPaymentStatus: 'paymentId',
    refund: 'paymentId, amount'
  },
  events: {
    paymentCreated: 'paymentId',
    paymentCompleted: 'paymentId',
    paymentFailed: 'paymentId'
  }
});

// 添加依赖关系
diMicroFrontend.addDependency('user-profile', 'auth-service');
diMicroFrontend.addDependency('order-management', 'auth-service');
diMicroFrontend.addDependency('order-management', 'product-service');

// 分析依赖倒置
const analysis = diMicroFrontend.analyzeDependencyInversion();
console.log('依赖倒置分析:', analysis);
```

## 13.3 开发流程最佳实践

### 13.3.1 敏捷开发与微前端

微前端架构与敏捷开发方法天然契合，可以充分发挥敏捷开发的优势：

```javascript
// 示例：微前端敏捷开发流程
class AgileMicroFrontendDevelopment {
  constructor() {
    this.teams = new Map();
    this.sprints = new Map();
    this.backlog = new Map();
    this.workflows = new Map();
    this.metrics = new Map();
  }

  // 添加团队
  addTeam(teamId, teamInfo) {
    this.teams.set(teamId, {
      id: teamId,
      name: teamInfo.name,
      members: teamInfo.members || [],
      microFrontends: teamInfo.microFrontends || [],
      capacity: teamInfo.capacity || 0,
      velocity: teamInfo.velocity || 0
    });
  }

  // 添加冲刺
  addSprint(sprintId, sprintInfo) {
    this.sprints.set(sprintId, {
      id: sprintId,
      name: sprintInfo.name,
      startDate: sprintInfo.startDate,
      endDate: sprintInfo.endDate,
      teamId: sprintInfo.teamId,
      stories: sprintInfo.stories || [],
      goals: sprintInfo.goals || [],
      retrospective: sprintInfo.retrospective || null
    });
  }

  // 添加待办事项
  addBacklogItem(itemId, itemInfo) {
    this.backlog.set(itemId, {
      id: itemId,
      title: itemInfo.title,
      description: itemInfo.description,
      type: itemInfo.type, // 'feature', 'bug', 'enhancement', 'technical-debt'
      priority: itemInfo.priority, // 'high', 'medium', 'low'
      estimate: itemInfo.estimate, // story points
      microFrontendId: itemInfo.microFrontendId,
      dependencies: itemInfo.dependencies || [],
      acceptanceCriteria: itemInfo.acceptanceCriteria || [],
      status: itemInfo.status || 'backlog' // 'backlog', 'in-progress', 'testing', 'done'
    });
  }

  // 添加工作流
  addWorkflow(workflowId, workflowInfo) {
    this.workflows.set(workflowId, {
      id: workflowId,
      name: workflowInfo.name,
      description: workflowInfo.description,
      steps: workflowInfo.steps || [],
      transitions: workflowInfo.transitions || []
    });
  }

  // 添加度量指标
  addMetric(metricId, metricInfo) {
    this.metrics.set(metricId, {
      id: metricId,
      name: metricInfo.name,
      description: metricInfo.description,
      type: metricInfo.type, // 'lead-time', 'cycle-time', 'throughput', 'quality'
      calculation: metricInfo.calculation,
      target: metricInfo.target
    });
  }

  // 规划冲刺
  planSprint(teamId, sprintDuration, backlogItems) {
    const team = this.teams.get(teamId);
    if (!team) {
      throw new Error(`Team ${teamId} not found`);
    }

    // 计算团队容量
    const capacity = team.capacity * sprintDuration;
    
    // 选择待办事项
    const selectedItems = this.selectBacklogItems(backlogItems, capacity);
    
    // 创建冲刺
    const sprintId = `sprint-${Date.now()}`;
    const startDate = new Date();
    const endDate = new Date(startDate.getTime() + sprintDuration * 24 * 60 * 60 * 1000);
    
    this.addSprint(sprintId, {
      name: `Sprint ${this.sprints.size + 1}`,
      startDate: startDate,
      endDate: endDate,
      teamId: teamId,
      stories: selectedItems.map(item => item.id),
      goals: this.generateSprintGoals(selectedItems)
    });

    // 更新待办事项状态
    for (const item of selectedItems) {
      item.status = 'in-progress';
    }

    return {
      sprintId: sprintId,
      selectedItems: selectedItems,
      capacity: capacity,
      utilized: selectedItems.reduce((sum, item) => sum + item.estimate, 0)
    };
  }

  // 选择待办事项
  selectBacklogItems(backlogItems, capacity) {
    // 按优先级排序
    const sortedItems = backlogItems.sort((a, b) => {
      const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });

    // 选择符合容量的项目
    const selectedItems = [];
    let utilized = 0;

    for (const item of sortedItems) {
      // 检查依赖
      const dependenciesMet = this.checkDependencies(item, selectedItems);
      if (!dependenciesMet) {
        continue;
      }

      // 检查容量
      if (utilized + item.estimate > capacity) {
        continue;
      }

      selectedItems.push(item);
      utilized += item.estimate;
    }

    return selectedItems;
  }

  // 检查依赖
  checkDependencies(item, selectedItems) {
    for (const depId of item.dependencies) {
      const depSelected = selectedItems.some(selected => selected.id === depId);
      if (!depSelected) {
        return false;
      }
    }
    return true;
  }

  // 生成冲刺目标
  generateSprintGoals(selectedItems) {
    const goals = [];
    const microFrontendGroups = this.groupByMicroFrontend(selectedItems);

    for (const [mfId, items] of microFrontendGroups) {
      const mf = this.getMicroFrontendById(mfId);
      if (mf) {
        goals.push({
          title: `完成${mf.name}的功能开发`,
          description: `实现${items.length}个功能，包括${items.map(item => item.title).join('、')}`
        });
      }
    }

    return goals;
  }

  // 按微前端分组
  groupByMicroFrontend(items) {
    const groups = new Map();

    for (const item of items) {
      if (!groups.has(item.microFrontendId)) {
        groups.set(item.microFrontendId, []);
      }
      groups.get(item.microFrontendId).push(item);
    }

    return groups;
  }

  // 根据ID获取微前端
  getMicroFrontendById(mfId) {
    for (const team of this.teams.values()) {
      for (const mfId of team.microFrontends) {
        if (mfId === mfId) {
          return { id: mfId, name: mfId }; // 简化，实际应该有完整信息
        }
      }
    }
    return null;
  }

  // 完成冲刺
  completeSprint(sprintId) {
    const sprint = this.sprints.get(sprintId);
    if (!sprint) {
      throw new Error(`Sprint ${sprintId} not found`);
    }

    // 更新团队速度
    const team = this.teams.get(sprint.teamId);
    if (team) {
      const completedPoints = sprint.stories.reduce((sum, storyId) => {
        const item = this.backlog.get(storyId);
        return sum + (item ? item.estimate : 0);
      }, 0);
      
      // 简单的平均速度计算
      team.velocity = (team.velocity * 0.7) + (completedPoints * 0.3);
    }

    // 更新待办事项状态
    for (const storyId of sprint.stories) {
      const item = this.backlog.get(storyId);
      if (item) {
        item.status = 'done';
      }
    }

    // 创建回顾
    sprint.retrospective = {
      whatWentWell: [],
      whatCouldBeImproved: [],
      actionItems: []
    };

    return sprint;
  }

  // 计算度量指标
  calculateMetrics(teamId, timeRange) {
    const team = this.teams.get(teamId);
    if (!team) {
      throw new Error(`Team ${teamId} not found`);
    }

    const metrics = {};
    const now = new Date();
    const startDate = new Date(now.getTime() - timeRange * 24 * 60 * 60 * 1000);

    // 计算各项指标
    for (const [metricId, metric] of this.metrics) {
      try {
        const value = this.calculateMetricValue(metric, teamId, startDate, now);
        metrics[metricId] = {
          name: metric.name,
          value: value,
          target: metric.target,
          status: this.getMetricStatus(value, metric.target)
        };
      } catch (error) {
        metrics[metricId] = {
          name: metric.name,
          value: null,
          target: metric.target,
          status: 'error',
          error: error.message
        };
      }
    }

    return metrics;
  }

  // 计算指标值
  calculateMetricValue(metric, teamId, startDate, endDate) {
    switch (metric.type) {
      case 'lead-time':
        return this.calculateLeadTime(teamId, startDate, endDate);
      case 'cycle-time':
        return this.calculateCycleTime(teamId, startDate, endDate);
      case 'throughput':
        return this.calculateThroughput(teamId, startDate, endDate);
      case 'quality':
        return this.calculateQuality(teamId, startDate, endDate);
      default:
        throw new Error(`Unknown metric type: ${metric.type}`);
    }
  }

  // 计算前置时间
  calculateLeadTime(teamId, startDate, endDate) {
    // 简化计算，实际应该基于实际数据
    return Math.floor(Math.random() * 10) + 5; // 5-15天
  }

  // 计算周期时间
  calculateCycleTime(teamId, startDate, endDate) {
    // 简化计算，实际应该基于实际数据
    return Math.floor(Math.random() * 7) + 3; // 3-10天
  }

  // 计算吞吐量
  calculateThroughput(teamId, startDate, endDate) {
    // 简化计算，实际应该基于实际数据
    return Math.floor(Math.random() * 20) + 10; // 10-30个故事点
  }

  // 计算质量
  calculateQuality(teamId, startDate, endDate) {
    // 简化计算，实际应该基于实际数据
    return Math.floor(Math.random() * 30) + 70; // 70-100%
  }

  // 获取指标状态
  getMetricStatus(value, target) {
    if (typeof target === 'number') {
      if (value <= target) return 'good';
      if (value <= target * 1.2) return 'warning';
      return 'bad';
    } else if (typeof target === 'object' && target.min !== undefined && target.max !== undefined) {
      if (value >= target.min && value <= target.max) return 'good';
      if (value >= target.min * 0.9 && value <= target.max * 1.1) return 'warning';
      return 'bad';
    }
    return 'unknown';
  }
}

// 使用示例
const agileDevelopment = new AgileMicroFrontendDevelopment();

// 添加团队
agileDevelopment.addTeam('user-team', {
  name: '用户团队',
  members: ['Alice', 'Bob', 'Charlie'],
  microFrontends: ['user-auth', 'user-profile'],
  capacity: 30, // 每周30个故事点
  velocity: 25 // 初始速度
});

agileDevelopment.addTeam('product-team', {
  name: '产品团队',
  members: ['David', 'Eve', 'Frank'],
  microFrontends: ['product-catalog', 'search'],
  capacity: 35,
  velocity: 30
});

agileDevelopment.addTeam('order-team', {
  name: '订单团队',
  members: ['Grace', 'Henry', 'Ivy'],
  microFrontends: ['order-management', 'payment'],
  capacity: 32,
  velocity: 28
});

// 添加待办事项
agileDevelopment.addBacklogItem('auth-login', {
  title: '用户登录功能',
  description: '实现用户登录功能，支持用户名密码登录',
  type: 'feature',
  priority: 'high',
  estimate: 8,
  microFrontendId: 'user-auth',
  acceptanceCriteria: [
    '用户可以使用用户名密码登录',
    '登录失败显示错误信息',
    '登录成功跳转到首页'
  ]
});

agileDevelopment.addBacklogItem('auth-register', {
  title: '用户注册功能',
  description: '实现用户注册功能，包括表单验证和邮箱验证',
  type: 'feature',
  priority: 'high',
  estimate: 13,
  microFrontendId: 'user-auth',
  dependencies: ['auth-login'],
  acceptanceCriteria: [
    '用户可以填写注册表单',
    '表单验证用户输入',
    '发送验证邮件',
    '验证邮箱后激活账户'
  ]
});

agileDevelopment.addBacklogItem('profile-view', {
  title: '查看用户资料',
  description: '实现用户资料查看功能',
  type: 'feature',
  priority: 'medium',
  estimate: 5,
  microFrontendId: 'user-profile',
  dependencies: ['auth-login'],
  acceptanceCriteria: [
    '用户可以查看自己的资料',
    '显示用户基本信息',
    '显示用户头像'
  ]
});

agileDevelopment.addBacklogItem('profile-edit', {
  title: '编辑用户资料',
  description: '实现用户资料编辑功能',
  type: 'feature',
  priority: 'medium',
  estimate: 8,
  microFrontendId: 'user-profile',
  dependencies: ['profile-view'],
  acceptanceCriteria: [
    '用户可以编辑自己的资料',
    '保存修改的信息',
    '显示保存成功提示'
  ]
});

agileDevelopment.addBacklogItem('product-list', {
  title: '产品列表页面',
  description: '实现产品列表展示功能',
  type: 'feature',
  priority: 'high',
  estimate: 13,
  microFrontendId: 'product-catalog',
  acceptanceCriteria: [
    '显示产品列表',
    '支持分页',
    '支持排序'
  ]
});

agileDevelopment.addBacklogItem('product-detail', {
  title: '产品详情页面',
  description: '实现产品详情展示功能',
  type: 'feature',
  priority: 'high',
  estimate: 8,
  microFrontendId: 'product-catalog',
  dependencies: ['product-list'],
  acceptanceCriteria: [
    '显示产品详细信息',
    '显示产品图片',
    '显示产品价格'
  ]
});

agileDevelopment.addBacklogItem('order-create', {
  title: '创建订单功能',
  description: '实现订单创建功能',
  type: 'feature',
  priority: 'high',
  estimate: 21,
  microFrontendId: 'order-management',
  dependencies: ['product-detail'],
  acceptanceCriteria: [
    '用户可以从产品页面创建订单',
    '填写订单信息',
    '提交订单',
    '显示订单确认'
  ]
});

// 添加工作流
agileDevelopment.addWorkflow('standard', {
  name: '标准工作流',
  description: '标准的敏捷开发工作流',
  steps: [
    { id: 'backlog', name: '待办事项', status: 'backlog' },
    { id: 'selected', name: '已选择', status: 'selected' },
    { id: 'in-progress', name: '进行中', status: 'in-progress' },
    { id: 'testing', name: '测试中', status: 'testing' },
    { id: 'done', name: '已完成', status: 'done' }
  ],
  transitions: [
    { from: 'backlog', to: 'selected', action: 'select' },
    { from: 'selected', to: 'in-progress', action: 'start' },
    { from: 'in-progress', to: 'testing', action: 'submit-for-review' },
    { from: 'testing', to: 'in-progress', action: 'request-changes' },
    { from: 'testing', to: 'done', action: 'approve' }
  ]
});

// 添加度量指标
agileDevelopment.addMetric('lead-time', {
  name: '前置时间',
  description: '从需求提出到功能上线的时间',
  type: 'lead-time',
  calculation: 'average',
  target: 10 // 天
});

agileDevelopment.addMetric('cycle-time', {
  name: '周期时间',
  description: '从开发开始到功能完成的时间',
  type: 'cycle-time',
  calculation: 'average',
  target: 7 // 天
});

agileDevelopment.addMetric('throughput', {
  name: '吞吐量',
  description: '每个冲刺完成的故事点数',
  type: 'throughput',
  calculation: 'sum',
  target: 30 // 故事点
});

agileDevelopment.addMetric('quality', {
  name: '质量',
  description: '功能质量评分',
  type: 'quality',
  calculation: 'average',
  target: { min: 85, max: 100 } // 百分比
});

// 获取所有待办事项
const backlogItems = Array.from(agileDevelopment.backlog.values());

// 规划用户团队的冲刺
const userTeamSprint = agileDevelopment.planSprint('user-team', 2, backlogItems);
console.log('用户团队冲刺规划:', userTeamSprint);

// 规划产品团队的冲刺
const productTeamSprint = agileDevelopment.planSprint('product-team', 2, backlogItems);
console.log('产品团队冲刺规划:', productTeamSprint);

// 规划订单团队的冲刺
const orderTeamSprint = agileDevelopment.planSprint('order-team', 2, backlogItems);
console.log('订单团队冲刺规划:', orderTeamSprint);

// 完成冲刺
agileDevelopment.completeSprint(userTeamSprint.sprintId);
agileDevelopment.completeSprint(productTeamSprint.sprintId);
agileDevelopment.completeSprint(orderTeamSprint.sprintId);

// 计算度量指标
const userTeamMetrics = agileDevelopment.calculateMetrics('user-team', 30);
console.log('用户团队度量指标:', userTeamMetrics);
```

## 13.4 技术实现最佳实践

### 13.4.1 微前端框架选择

选择合适的微前端框架是微前端实施的关键决策：

```javascript
// 示例：微前端框架选择决策
class MicroFrontendFrameworkSelection {
  constructor() {
    this.frameworks = new Map();
    this.criteria = new Map();
    this.requirements = new Map();
    this.evaluationResults = new Map();
  }

  // 添加框架
  addFramework(frameworkId, frameworkInfo) {
    this.frameworks.set(frameworkId, {
      id: frameworkId,
      name: frameworkInfo.name,
      description: frameworkInfo.description,
      type: frameworkInfo.type, // 'module-federation', 'single-spa', 'qiankun', 'custom'
      features: frameworkInfo.features || [],
      advantages: frameworkInfo.advantages || [],
      disadvantages: frameworkInfo.disadvantages || [],
      compatibility: frameworkInfo.compatibility || {},
      learningCurve: frameworkInfo.learningCurve || 'medium', // 'low', 'medium', 'high'
      community: frameworkInfo.community || 'medium', // 'small', 'medium', 'large'
      maintenance: frameworkInfo.maintenance || 'active' // 'active', 'stable', 'deprecated'
    });
  }

  // 添加评估标准
  addCriterion(criterionId, criterionInfo) {
    this.criteria.set(criterionId, {
      id: criterionId,
      name: criterionInfo.name,
      description: criterionInfo.description,
      type: criterionInfo.type, // 'technical', 'business', 'operational'
      weight: criterionInfo.weight || 1, // 权重
      options: criterionInfo.options || [] // 评估选项
    });
  }

  // 添加需求
  addRequirement(requirementId, requirementInfo) {
    this.requirements.set(requirementId, {
      id: requirementId,
      name: requirementInfo.name,
      description: requirementInfo.description,
      type: requirementInfo.type, // 'must-have', 'should-have', 'could-have', 'wont-have'
      priority: requirementInfo.priority || 'medium', // 'high', 'medium', 'low'
      criteria: requirementInfo.criteria || [] // 相关评估标准
    });
  }

  // 评估框架
  evaluateFrameworks() {
    const evaluation = {
      results: {},
      recommendation: null,
      reasoning: []
    };

    // 评估每个框架
    for (const framework of this.frameworks.values()) {
      const frameworkEvaluation = this.evaluateFramework(framework);
      evaluation.results[framework.id] = frameworkEvaluation;
    }

    // 生成推荐
    evaluation.recommendation = this.generateRecommendation(evaluation.results);
    evaluation.reasoning = this.generateReasoning(evaluation.results, evaluation.recommendation);

    return evaluation;
  }

  // 评估单个框架
  evaluateFramework(framework) {
    const scores = {};
    let totalScore = 0;
    let totalWeight = 0;

    // 对每个标准进行评分
    for (const criterion of this.criteria.values()) {
      const score = this.scoreCriterion(framework, criterion);
      scores[criterion.id] = {
        name: criterion.name,
        score: score,
        weight: criterion.weight,
        weightedScore: score * criterion.weight
      };

      totalScore += score * criterion.weight;
      totalWeight += criterion.weight;
    }

    // 计算总分
    const overallScore = totalWeight > 0 ? totalScore / totalWeight : 0;

    // 检查需求满足情况
    const requirementSatisfaction = this.checkRequirementSatisfaction(framework);

    return {
      frameworkId: framework.id,
      frameworkName: framework.name,
      overallScore: overallScore,
      scores: scores,
      requirementSatisfaction: requirementSatisfaction,
      recommendation: this.getFrameworkRecommendation(overallScore, requirementSatisfaction)
    };
  }

  // 对标准进行评分
  scoreCriterion(framework, criterion) {
    // 这里应该是实际的评分逻辑
    // 为了示例，我们使用简化的评分逻辑
    switch (criterion.id) {
      case 'ease-of-implementation':
        return this.scoreEaseOfImplementation(framework);
      case 'performance':
        return this.scorePerformance(framework);
      case 'scalability':
        return this.scoreScalability(framework);
      case 'compatibility':
        return this.scoreCompatibility(framework);
      case 'community-support':
        return this.scoreCommunitySupport(framework);
      case 'learning-curve':
        return this.scoreLearningCurve(framework);
      default:
        return Math.random() * 5; // 随机评分
    }
  }

  // 评分：实现难度
  scoreEaseOfImplementation(framework) {
    if (framework.type === 'module-federation') {
      return 4; // 相对容易实现
    } else if (framework.type === 'single-spa') {
      return 3; // 中等难度
    } else if (framework.type === 'qiankun') {
      return 4; // 相对容易实现
    } else {
      return 2; // 自定义实现难度高
    }
  }

  // 评分：性能
  scorePerformance(framework) {
    if (framework.type === 'module-federation') {
      return 5; // 性能优秀
    } else if (framework.type === 'single-spa') {
      return 3; // 性能中等
    } else if (framework.type === 'qiankun') {
      return 4; // 性能良好
    } else {
      return 3; // 性能取决于实现
    }
  }

  // 评分：可扩展性
  scoreScalability(framework) {
    if (framework.type === 'module-federation') {
      return 5; // 可扩展性优秀
    } else if (framework.type === 'single-spa') {
      return 4; // 可扩展性良好
    } else if (framework.type === 'qiankun') {
      return 4; // 可扩展性良好
    } else {
      return 3; // 可扩展性取决于实现
    }
  }

  // 评分：兼容性
  scoreCompatibility(framework) {
    if (framework.type === 'module-federation') {
      return 4; // 兼容性良好
    } else if (framework.type === 'single-spa') {
      return 5; // 兼容性优秀
    } else if (framework.type === 'qiankun') {
      return 4; // 兼容性良好
    } else {
      return 3; // 兼容性取决于实现
    }
  }

  // 评分：社区支持
  scoreCommunitySupport(framework) {
    if (framework.community === 'large') {
      return 5;
    } else if (framework.community === 'medium') {
      return 3;
    } else {
      return 1;
    }
  }

  // 评分：学习曲线
  scoreLearningCurve(framework) {
    if (framework.learningCurve === 'low') {
      return 5;
    } else if (framework.learningCurve === 'medium') {
      return 3;
    } else {
      return 1;
    }
  }

  // 检查需求满足情况
  checkRequirementSatisfaction(framework) {
    const satisfaction = {};

    for (const requirement of this.requirements.values()) {
      const isSatisfied = this.checkRequirement(framework, requirement);
      satisfaction[requirement.id] = {
        name: requirement.name,
        type: requirement.type,
        satisfied: isSatisfied,
        priority: requirement.priority
      };
    }

    return satisfaction;
  }

  // 检查单个需求
  checkRequirement(framework, requirement) {
    // 这里应该是实际的需求检查逻辑
    // 为了示例，我们使用简化的检查逻辑
    switch (requirement.id) {
      case 'multi-framework-support':
        return framework.type === 'single-spa' || framework.type === 'qiankun';
      case 'runtime-isolation':
        return framework.type === 'qiankun' || framework.type === 'single-spa';
      case 'shared-dependencies':
        return framework.type === 'module-federation' || framework.type === 'qiankun';
      case 'independent-deployment':
        return true; // 大多数微前端框架都支持
      case 'progressive-migration':
        return framework.type === 'module-federation' || framework.type === 'single-spa';
      default:
        return Math.random() > 0.3; // 70%的概率满足
    }
  }

  // 获取框架推荐
  getFrameworkRecommendation(score, requirementSatisfaction) {
    // 检查必须满足的需求
    const mustHaveRequirements = Object.values(requirementSatisfaction).filter(
      req => req.type === 'must-have' && !req.satisfied
    );

    if (mustHaveRequirements.length > 0) {
      return 'not-recommended';
    }

    // 根据分数推荐
    if (score >= 4) {
      return 'highly-recommended';
    } else if (score >= 3) {
      return 'recommended';
    } else if (score >= 2) {
      return 'conditionally-recommended';
    } else {
      return 'not-recommended';
    }
  }

  // 生成推荐
  generateRecommendation(results) {
    let bestFramework = null;
    let bestScore = 0;

    for (const [frameworkId, result] of Object.entries(results)) {
      if (result.recommendation !== 'not-recommended' && result.overallScore > bestScore) {
        bestFramework = frameworkId;
        bestScore = result.overallScore;
      }
    }

    return bestFramework;
  }

  // 生成推荐理由
  generateReasoning(results, recommendation) {
    const reasoning = [];

    if (!recommendation) {
      reasoning.push('没有找到满足所有需求的框架');
      return reasoning;
    }

    const recommendedResult = results[recommendation];
    const framework = this.frameworks.get(recommendation);

    reasoning.push(`推荐使用${framework.name}，综合评分最高(${recommendedResult.overallScore.toFixed(2)})`);

    // 添加高分项
    const highScoreItems = Object.entries(recommendedResult.scores)
      .filter(([id, score]) => score.score >= 4)
      .map(([id, score]) => score.name);

    if (highScoreItems.length > 0) {
      reasoning.push(`在${highScoreItems.join('、')}方面表现优秀`);
    }

    // 添加满足的关键需求
    const satisfiedMustHaves = Object.entries(recommendedResult.requirementSatisfaction)
      .filter(([id, req]) => req.type === 'must-have' && req.satisfied)
      .map(([id, req]) => req.name);

    if (satisfiedMustHaves.length > 0) {
      reasoning.push(`满足关键需求：${satisfiedMustHaves.join('、')}`);
    }

    return reasoning;
  }
}

// 使用示例
const frameworkSelection = new MicroFrontendFrameworkSelection();

// 添加框架
frameworkSelection.addFramework('module-federation', {
  name: 'Module Federation',
  description: 'Webpack 5的模块联邦功能',
  type: 'module-federation',
  features: [
    '运行时模块加载',
    '依赖共享',
    '独立部署',
    'TypeScript支持'
  ],
  advantages: [
    '原生Webpack支持',
    '性能优秀',
    '依赖共享灵活',
    '渐进式迁移'
  ],
  disadvantages: [
    '仅支持Webpack 5',
    '配置相对复杂',
    '社区相对较小'
  ],
  compatibility: {
    frameworks: ['React', 'Vue', 'Angular'],
    browsers: ['现代浏览器']
  },
  learningCurve: 'medium',
  community: 'medium',
  maintenance: 'active'
});

frameworkSelection.addFramework('single-spa', {
  name: 'Single-SPA',
  description: 'JavaScript微前端框架',
  type: 'single-spa',
  features: [
    '多框架支持',
    '路由管理',
    '生命周期管理',
    '懒加载'
  ],
  advantages: [
    '框架无关',
    '成熟稳定',
    '社区活跃',
    '文档完善'
  ],
  disadvantages: [
    '配置复杂',
    '学习曲线陡峭',
    '性能一般'
  ],
  compatibility: {
    frameworks: ['React', 'Vue', 'Angular', 'Svelte', 'Ember'],
    browsers: ['所有现代浏览器', 'IE11']
  },
  learningCurve: 'high',
  community: 'large',
  maintenance: 'active'
});

frameworkSelection.addFramework('qiankun', {
  name: 'Qiankun',
  description: '基于Single-SPA的微前端框架',
  type: 'qiankun',
  features: [
    'JS沙箱',
    '样式隔离',
    '预加载',
    'HTML Entry'
  ],
  advantages: [
    '开箱即用',
    '文档详细',
    '社区活跃',
    '中文支持好'
  ],
  disadvantages: [
    '主要面向React',
    '定制性有限',
    '性能一般'
  ],
  compatibility: {
    frameworks: ['React', 'Vue', 'Angular'],
    browsers: ['所有现代浏览器', 'IE9+']
  },
  learningCurve: 'medium',
  community: 'large',
  maintenance: 'active'
});

frameworkSelection.addFramework('custom', {
  name: '自定义实现',
  description: '基于业务需求的自定义微前端实现',
  type: 'custom',
  features: [
    '完全定制',
    '业务贴合',
    '性能优化',
    '技术栈灵活'
  ],
  advantages: [
    '完全控制',
    '业务贴合',
    '无第三方依赖',
    '可深度优化'
  ],
  disadvantages: [
    '开发成本高',
    '维护复杂',
    '需要专业团队',
    '风险高'
  ],
  compatibility: {
    frameworks: ['任何框架'],
    browsers: ['任何浏览器']
  },
  learningCurve: 'high',
  community: 'small',
  maintenance: 'self'
});

// 添加评估标准
frameworkSelection.addCriterion('ease-of-implementation', {
  name: '实现难度',
  description: '框架的实施难度和复杂度',
  type: 'technical',
  weight: 0.2
});

frameworkSelection.addCriterion('performance', {
  name: '性能',
  description: '框架的运行时性能',
  type: 'technical',
  weight: 0.25
});

frameworkSelection.addCriterion('scalability', {
  name: '可扩展性',
  description: '框架的可扩展性和灵活性',
  type: 'technical',
  weight: 0.2
});

frameworkSelection.addCriterion('compatibility', {
  name: '兼容性',
  description: '框架与现有技术栈的兼容性',
  type: 'technical',
  weight: 0.15
});

frameworkSelection.addCriterion('community-support', {
  name: '社区支持',
  description: '框架的社区活跃度和支持程度',
  type: 'operational',
  weight: 0.1
});

frameworkSelection.addCriterion('learning-curve', {
  name: '学习曲线',
  description: '团队学习框架的难度',
  type: 'operational',
  weight: 0.1
});

// 添加需求
frameworkSelection.addRequirement('multi-framework-support', {
  name: '多框架支持',
  description: '支持使用多种前端框架',
  type: 'should-have',
  priority: 'medium'
});

frameworkSelection.addRequirement('runtime-isolation', {
  name: '运行时隔离',
  description: '微应用之间的运行时隔离',
  type: 'must-have',
  priority: 'high'
});

frameworkSelection.addRequirement('shared-dependencies', {
  name: '共享依赖',
  description: '微应用之间共享公共依赖',
  type: 'should-have',
  priority: 'medium'
});

frameworkSelection.addRequirement('independent-deployment', {
  name: '独立部署',
  description: '微应用可以独立部署',
  type: 'must-have',
  priority: 'high'
});

frameworkSelection.addRequirement('progressive-migration', {
  name: '渐进式迁移',
  description: '支持渐进式迁移现有应用',
  type: 'should-have',
  priority: 'medium'
});

// 评估框架
const evaluation = frameworkSelection.evaluateFrameworks();
console.log('框架评估结果:', evaluation);
```

## 13.5 性能优化最佳实践

### 13.5.1 资源加载优化

资源加载优化是微前端性能优化的关键环节：

```javascript
// 示例：微前端资源加载优化
class MicroFrontendResourceOptimization {
  constructor() {
    this.loadingStrategies = new Map();
    this.optimizationTechniques = new Map();
    this.performanceMetrics = new Map();
    this.optimizationResults = new Map();
  }

  // 添加加载策略
  addLoadingStrategy(strategyId, strategyInfo) {
    this.loadingStrategies.set(strategyId, {
      id: strategyId,
      name: strategyInfo.name,
      description: strategyInfo.description,
      implementation: strategyInfo.implementation,
      advantages: strategyInfo.advantages || [],
      disadvantages: strategyInfo.disadvantages || [],
      suitableFor: strategyInfo.suitableFor || []
    });
  }

  // 添加优化技术
  addOptimizationTechnique(techniqueId, techniqueInfo) {
    this.optimizationTechniques.set(techniqueId, {
      id: techniqueId,
      name: techniqueInfo.name,
      description: techniqueInfo.description,
      implementation: techniqueInfo.implementation,
      impact: techniqueInfo.impact, // 'high', 'medium', 'low'
      complexity: techniqueInfo.complexity, // 'high', 'medium', 'low'
      compatibility: techniqueInfo.compatibility || []
    });
  }

  // 添加性能指标
  addPerformanceMetric(metricId, metricInfo) {
    this.performanceMetrics.set(metricId, {
      id: metricId,
      name: metricInfo.name,
      description: metricInfo.description,
      unit: metricInfo.unit,
      target: metricInfo.target,
      measurement: metricInfo.measurement
    });
  }

  // 分析资源加载性能
  analyzeResourceLoading(microFrontends) {
    const analysis = {
      overall: {
        totalSize: 0,
        totalRequests: 0,
        loadTime: 0,
        bottlenecks: []
      },
      microFrontends: {},
      recommendations: []
    };

    // 分析每个微前端
    for (const mf of microFrontends) {
      const mfAnalysis = this.analyzeMicroFrontend(mf);
      analysis.microFrontends[mf.id] = mfAnalysis;
      
      // 累计总体数据
      analysis.overall.totalSize += mfAnalysis.totalSize;
      analysis.overall.totalRequests += mfAnalysis.totalRequests;
      analysis.overall.loadTime = Math.max(analysis.overall.loadTime, mfAnalysis.loadTime);
      
      // 识别瓶颈
      if (mfAnalysis.loadTime > 3000) { // 超过3秒
        analysis.overall.bottlenecks.push({
          microFrontendId: mf.id,
          microFrontendName: mf.name,
          issue: 'load-time',
          value: mfAnalysis.loadTime,
          threshold: 3000
        });
      }
      
      if (mfAnalysis.totalSize > 1000000) { // 超过1MB
        analysis.overall.bottlenecks.push({
          microFrontendId: mf.id,
          microFrontendName: mf.name,
          issue: 'bundle-size',
          value: mfAnalysis.totalSize,
          threshold: 1000000
        });
      }
    }

    // 生成优化建议
    analysis.recommendations = this.generateOptimizationRecommendations(analysis);

    return analysis;
  }

  // 分析单个微前端
  analyzeMicroFrontend(mf) {
    const analysis = {
      id: mf.id,
      name: mf.name,
      resources: mf.resources || [],
      totalSize: 0,
      totalRequests: 0,
      loadTime: 0,
      bottlenecks: []
    };

    // 计算资源总大小和请求数
    for (const resource of analysis.resources) {
      analysis.totalSize += resource.size || 0;
      analysis.totalRequests += 1;
    }

    // 估算加载时间（简化计算）
    analysis.loadTime = this.estimateLoadTime(analysis.resources);

    // 识别资源瓶颈
    for (const resource of analysis.resources) {
      if (resource.size > 500000) { // 超过500KB
        analysis.bottlenecks.push({
          type: 'large-resource',
          url: resource.url,
          size: resource.size,
          threshold: 500000
        });
      }
      
      if (resource.loadTime > 2000) { // 超过2秒
        analysis.bottlenecks.push({
          type: 'slow-resource',
          url: resource.url,
          loadTime: resource.loadTime,
          threshold: 2000
        });
      }
    }

    return analysis;
  }

  // 估算加载时间
  estimateLoadTime(resources) {
    // 简化的加载时间计算
    let totalTime = 0;
    
    for (const resource of resources) {
      // 考虑资源大小和网络延迟
      const networkTime = 100 + (resource.size || 0) / 100000; // 100ms基础延迟 + 大小相关时间
      const processingTime = resource.type === 'javascript' ? 200 : 50; // JS处理时间更长
      
      totalTime += Math.max(networkTime, processingTime);
    }
    
    // 考虑并行加载
    const parallelism = 6; // 浏览器通常支持6个并行连接
    const batches = Math.ceil(resources.length / parallelism);
    
    return totalTime * batches / parallelism;
  }

  // 生成优化建议
  generateOptimizationRecommendations(analysis) {
    const recommendations = [];

    // 分析总体瓶颈
    if (analysis.overall.bottlenecks.length > 0) {
      recommendations.push({
        type: 'general',
        title: '优化资源加载',
        description: '检测到多个资源加载瓶颈，建议采取以下优化措施',
        techniques: [
          'resource-compression',
          'resource-caching',
          'lazy-loading',
          'code-splitting'
        ]
      });
    }

    // 分析每个微前端
    for (const [mfId, mfAnalysis] of Object.entries(analysis.microFrontends)) {
      if (mfAnalysis.bottlenecks.length > 0) {
        recommendations.push({
          type: 'micro-frontend-specific',
          microFrontendId: mfId,
          microFrontendName: mfAnalysis.name,
          title: `优化${mfAnalysis.name}的资源加载`,
          description: `${mfAnalysis.name}存在资源加载瓶颈`,
          techniques: this.getRecommendedTechniques(mfAnalysis.bottlenecks)
        });
      }
    }

    // 根据资源类型推荐优化技术
    const resourceTypes = this.analyzeResourceTypes(analysis.microFrontends);
    for (const [type, count] of Object.entries(resourceTypes)) {
      if (count > 5) {
        recommendations.push({
          type: 'resource-type-specific',
          resourceType: type,
          title: `优化${type}资源`,
          description: `检测到大量${type}资源(${count}个)，建议进行优化`,
          techniques: this.getResourceTypeOptimizationTechniques(type)
        });
      }
    }

    return recommendations;
  }

  // 分析资源类型
  analyzeResourceTypes(microFrontends) {
    const resourceTypes = {};

    for (const mfAnalysis of Object.values(microFrontends)) {
      for (const resource of mfAnalysis.resources) {
        const type = resource.type || 'unknown';
        resourceTypes[type] = (resourceTypes[type] || 0) + 1;
      }
    }

    return resourceTypes;
  }

  // 获取推荐技术
  getRecommendedTechniques(bottlenecks) {
    const techniques = new Set();

    for (const bottleneck of bottlenecks) {
      switch (bottleneck.type) {
        case 'large-resource':
          techniques.add('resource-compression');
          techniques.add('code-splitting');
          break;
        case 'slow-resource':
          techniques.add('resource-caching');
          techniques.add('cdn-distribution');
          break;
        case 'load-time':
          techniques.add('lazy-loading');
          techniques.add('preloading');
          break;
        case 'bundle-size':
          techniques.add('tree-shaking');
          techniques.add('code-splitting');
          break;
      }
    }

    return Array.from(techniques);
  }

  // 获取资源类型优化技术
  getResourceTypeOptimizationTechniques(type) {
    switch (type) {
      case 'javascript':
        return ['code-splitting', 'tree-shaking', 'minification', 'compression'];
      case 'css':
        return ['css-minification', 'critical-css', 'css-in-js', 'unused-css-removal'];
      case 'image':
        return ['image-optimization', 'image-compression', 'lazy-loading', 'responsive-images'];
      case 'font':
        return ['font-subsetting', 'font-display', 'font-preloading'];
      default:
        return ['resource-compression', 'resource-caching'];
    }
  }

  // 应用优化技术
  applyOptimizationTechniques(microFrontends, techniques) {
    const results = {};

    for (const mf of microFrontends) {
      const mfResults = {
        original: this.analyzeMicroFrontend(mf),
        optimized: null,
        improvements: []
      };

      // 创建优化后的微前端副本
      const optimizedMf = JSON.parse(JSON.stringify(mf));
      
      // 应用优化技术
      for (const techniqueId of techniques) {
        const technique = this.optimizationTechniques.get(techniqueId);
        if (technique) {
          const improvement = this.applyTechnique(optimizedMf, technique);
          mfResults.improvements.push(improvement);
        }
      }

      // 分析优化后的结果
      mfResults.optimized = this.analyzeMicroFrontend(optimizedMf);
      
      // 计算改进
      mfResults.improvementPercentage = this.calculateImprovement(
        mfResults.original, 
        mfResults.optimized
      );

      results[mf.id] = mfResults;
    }

    return results;
  }

  // 应用单个技术
  applyTechnique(mf, technique) {
    const improvement = {
      techniqueId: technique.id,
      techniqueName: technique.name,
      impact: 'unknown',
      details: {}
    };

    // 根据技术类型应用不同的优化
    switch (technique.id) {
      case 'resource-compression':
        improvement.impact = this.applyResourceCompression(mf);
        break;
      case 'resource-caching':
        improvement.impact = this.applyResourceCaching(mf);
        break;
      case 'lazy-loading':
        improvement.impact = this.applyLazyLoading(mf);
        break;
      case 'code-splitting':
        improvement.impact = this.applyCodeSplitting(mf);
        break;
      case 'tree-shaking':
        improvement.impact = this.applyTreeShaking(mf);
        break;
      case 'cdn-distribution':
        improvement.impact = this.applyCDNDistribution(mf);
        break;
      default:
        improvement.impact = 'not-applied';
    }

    return improvement;
  }

  // 应用资源压缩
  applyResourceCompression(mf) {
    let totalReduction = 0;
    
    for (const resource of mf.resources) {
      if (resource.type === 'javascript' || resource.type === 'css') {
        const originalSize = resource.size || 0;
        const compressedSize = Math.floor(originalSize * 0.7); // 假设压缩30%
        resource.size = compressedSize;
        totalReduction += originalSize - compressedSize;
      } else if (resource.type === 'image') {
        const originalSize = resource.size || 0;
        const compressedSize = Math.floor(originalSize * 0.8); // 假设压缩20%
        resource.size = compressedSize;
        totalReduction += originalSize - compressedSize;
      }
    }

    return {
      type: 'size-reduction',
      value: totalReduction,
      unit: 'bytes'
    };
  }

  // 应用资源缓存
  applyResourceCaching(mf) {
    let cacheableResources = 0;
    
    for (const resource of mf.resources) {
      // 标记可缓存资源
      if (resource.type === 'javascript' || resource.type === 'css' || resource.type === 'image') {
        resource.cacheable = true;
        resource.cacheTime = 86400; // 24小时
        cacheableResources++;
      }
    }

    return {
      type: 'cacheable-resources',
      value: cacheableResources,
      unit: 'count'
    };
  }

  // 应用懒加载
  applyLazyLoading(mf) {
    let lazyLoadedResources = 0;
    
    for (const resource of mf.resources) {
      // 非关键资源标记为懒加载
      if (resource.type === 'image' || (resource.type === 'javascript' && !resource.critical)) {
        resource.lazy = true;
        lazyLoadedResources++;
      }
    }

    return {
      type: 'lazy-loaded-resources',
      value: lazyLoadedResources,
      unit: 'count'
    };
  }

  // 应用代码分割
  applyCodeSplitting(mf) {
    let splitResources = 0;
    
    for (const resource of mf.resources) {
      if (resource.type === 'javascript' && resource.size > 200000) { // 大于200KB的JS文件
        // 模拟代码分割
        const originalSize = resource.size;
        const chunkCount = Math.ceil(originalSize / 100000); // 分割成100KB的块
        
        // 更新原始资源大小为第一个块的大小
        resource.size = Math.floor(originalSize / chunkCount);
        
        // 添加额外的块
        for (let i = 1; i < chunkCount; i++) {
          mf.resources.push({
            url: `${resource.url}.chunk${i}`,
            type: 'javascript',
            size: Math.floor(originalSize / chunkCount),
            lazy: true // 非首屏块标记为懒加载
          });
        }
        
        splitResources++;
      }
    }

    return {
      type: 'split-resources',
      value: splitResources,
      unit: 'count'
    };
  }

  // 应用Tree Shaking
  applyTreeShaking(mf) {
    let totalReduction = 0;
    
    for (const resource of mf.resources) {
      if (resource.type === 'javascript') {
        const originalSize = resource.size || 0;
        const shakenSize = Math.floor(originalSize * 0.85); // 假设Tree Shaking减少15%
        resource.size = shakenSize;
        totalReduction += originalSize - shakenSize;
      }
    }

    return {
      type: 'size-reduction',
      value: totalReduction,
      unit: 'bytes'
    };
  }

  // 应用CDN分发
  applyCDNDistribution(mf) {
    let cdnResources = 0;
    
    for (const resource of mf.resources) {
      // 标记可使用CDN的资源
      if (resource.type === 'javascript' || resource.type === 'css' || resource.type === 'image') {
        resource.cdn = true;
        cdnResources++;
      }
    }

    return {
      type: 'cdn-resources',
      value: cdnResources,
      unit: 'count'
    };
  }

  // 计算改进
  calculateImprovement(original, optimized) {
    const sizeImprovement = original.totalSize > 0 
      ? ((original.totalSize - optimized.totalSize) / original.totalSize) * 100 
      : 0;
    
    const loadTimeImprovement = original.loadTime > 0 
      ? ((original.loadTime - optimized.loadTime) / original.loadTime) * 100 
      : 0;

    return {
      size: sizeImprovement,
      loadTime: loadTimeImprovement,
      overall: (sizeImprovement + loadTimeImprovement) / 2
    };
  }
}

// 使用示例
const resourceOptimization = new MicroFrontendResourceOptimization();

// 添加加载策略
resourceOptimization.addLoadingStrategy('eager-loading', {
  name: '立即加载',
  description: '微应用启动时立即加载所有资源',
  implementation: '在主应用启动时预加载所有微应用资源',
  advantages: ['用户体验好', '后续交互快'],
  disadvantages: ['初始加载时间长', '资源浪费'],
  suitableFor: ['小型应用', '核心功能']
});

resourceOptimization.addLoadingStrategy('lazy-loading', {
  name: '懒加载',
  description: '在需要时才加载微应用资源',
  implementation: '在路由切换或用户交互时加载微应用资源',
  advantages: ['初始加载快', '资源利用率高'],
  disadvantages: ['首次交互有延迟', '需要加载状态'],
  suitableFor: ['大型应用', '非核心功能']
});

resourceOptimization.addLoadingStrategy('prefetching', {
  name: '预加载',
  description: '在空闲时间预加载可能需要的微应用资源',
  implementation: '使用浏览器的空闲时间预加载微应用资源',
  advantages: ['平衡加载时间和交互体验', '资源利用率高'],
  disadvantages: ['实现复杂', '预测准确性影响效果'],
  suitableFor: ['中型应用', '可预测用户行为']
});

// 添加优化技术
resourceOptimization.addOptimizationTechnique('resource-compression', {
  name: '资源压缩',
  description: '压缩JavaScript、CSS和图片等资源',
  impact: 'high',
  complexity: 'low',
  implementation: '使用Gzip或Brotli压缩资源'
});

resourceOptimization.addOptimizationTechnique('resource-caching', {
  name: '资源缓存',
  description: '设置适当的缓存策略，减少重复请求',
  impact: 'high',
  complexity: 'medium',
  implementation: '设置Cache-Control和ETag头'
});

resourceOptimization.addOptimizationTechnique('lazy-loading', {
  name: '懒加载',
  description: '延迟加载非关键资源',
  impact: 'medium',
  complexity: 'medium',
  implementation: '使用Intersection Observer API或动态导入'
});

resourceOptimization.addOptimizationTechnique('code-splitting', {
  name: '代码分割',
  description: '将代码分割成更小的块，按需加载',
  impact: 'high',
  complexity: 'medium',
  implementation: '使用Webpack的代码分割功能'
});

resourceOptimization.addOptimizationTechnique('tree-shaking', {
  name: 'Tree Shaking',
  description: '移除未使用的代码',
  impact: 'medium',
  complexity: 'low',
  implementation: '使用ES6模块和Webpack的Tree Shaking功能'
});

resourceOptimization.addOptimizationTechnique('cdn-distribution', {
  name: 'CDN分发',
  description: '使用CDN分发资源，提高加载速度',
  impact: 'high',
  complexity: 'medium',
  implementation: '配置CDN服务并更新资源URL'
});

// 添加性能指标
resourceOptimization.addPerformanceMetric('first-contentful-paint', {
  name: '首次内容绘制',
  description: '浏览器首次绘制任何文本、图像、非白色canvas的时间',
  unit: 'ms',
  target: 1500,
  measurement: 'performance.getEntriesByType("paint")'
});

resourceOptimization.addPerformanceMetric('largest-contentful-paint', {
  name: '最大内容绘制',
  description: '视口中最大的图像或文本渲染的时间',
  unit: 'ms',
  target: 2500,
  measurement: 'performance.getEntriesByType("largest-contentful-paint")'
});

resourceOptimization.addPerformanceMetric('first-input-delay', {
  name: '首次输入延迟',
  description: '用户首次与页面交互到浏览器响应的时间',
  unit: 'ms',
  target: 100,
  measurement: 'performance.getEntriesByType("first-input")'
});

resourceOptimization.addPerformanceMetric('cumulative-layout-shift', {
  name: '累积布局偏移',
  description: '页面整个生命周期中发生的所有意外布局偏移的分数',
  unit: 'score',
  target: 0.1,
  measurement: 'performance.getEntriesByType("layout-shift")'
});

// 示例微前端数据
const microFrontends = [
  {
    id: 'user-auth',
    name: '用户认证',
    resources: [
      { url: '/static/js/user-auth.js', type: 'javascript', size: 300000, critical: true },
      { url: '/static/css/user-auth.css', type: 'css', size: 50000, critical: true },
      { url: '/static/images/logo.png', type: 'image', size: 25000 }
    ]
  },
  {
    id: 'user-profile',
    name: '用户资料',
    resources: [
      { url: '/static/js/user-profile.js', type: 'javascript', size: 250000 },
      { url: '/static/css/user-profile.css', type: 'css', size: 40000 },
      { url: '/static/images/default-avatar.png', type: 'image', size: 15000 }
    ]
  },
  {
    id: 'product-catalog',
    name: '产品目录',
    resources: [
      { url: '/static/js/product-catalog.js', type: 'javascript', size: 450000 },
      { url: '/static/css/product-catalog.css', type: 'css', size: 80000 },
      { url: '/static/images/product-placeholder.jpg', type: 'image', size: 35000 }
    ]
  },
  {
    id: 'order-management',
    name: '订单管理',
    resources: [
      { url: '/static/js/order-management.js', type: 'javascript', size: 550000 },
      { url: '/static/css/order-management.css', type: 'css', size: 70000 },
      { url: '/static/images/order-icon.svg', type: 'image', size: 5000 }
    ]
  }
];

// 分析资源加载性能
const analysis = resourceOptimization.analyzeResourceLoading(microFrontends);
console.log('资源加载分析:', analysis);

// 应用优化技术
const optimizationResults = resourceOptimization.applyOptimizationTechniques(
  microFrontends, 
  ['resource-compression', 'resource-caching', 'lazy-loading', 'code-splitting']
);
console.log('优化结果:', optimizationResults);
```

## 13.6 总结

微前端最佳实践是成功实施微前端架构的关键。本章介绍了微前端最佳实践的各个方面，包括架构设计、开发流程、技术实现和性能优化等方面的最佳实践。

### 13.6.1 最佳实践的重要性

微前端最佳实践的重要性体现在：

1. **降低实施风险**：通过借鉴成功经验，避免常见的陷阱和错误
2. **提高开发效率**：标准化的流程和工具可以显著提高团队效率
3. **保证系统质量**：经过验证的方法可以确保系统的稳定性和可维护性
4. **促进团队协作**：统一的规范和实践有助于跨团队协作
5. **加速技术演进**：最佳实践为技术演进提供了坚实的基础

### 13.6.2 最佳实践应用原则

应用微前端最佳实践时应遵循以下原则：

1. **因地制宜**：根据具体业务场景和团队能力选择适合的实践
2. **循序渐进**：逐步引入最佳实践，避免一次性大规模变革
3. **持续改进**：定期评估和调整实践，适应不断变化的需求
4. **平衡取舍**：在不同目标之间找到平衡点，避免极端化
5. **文档沉淀**：将实践经验文档化，促进知识共享和传承

### 13.6.3 最佳实践分类

微前端最佳实践可以分为以下几个类别：

1. **架构设计最佳实践**：关于系统架构设计的原则和方法
2. **开发流程最佳实践**：关于开发流程和协作方式的规范
3. **技术实现最佳实践**：关于具体技术实现的方法和技巧
4. **性能优化最佳实践**：关于系统性能优化的策略和技巧
5. **安全防护最佳实践**：关于系统安全防护的措施和方法
6. **团队协作最佳实践**：关于团队组织和协作的模式和流程

### 13.6.4 最佳实践持续演进

微前端最佳实践不是一成不变的，而是随着技术发展和业务需求变化而不断演进的。团队应该：

1. **关注行业趋势**：密切关注微前端领域的最新发展和趋势
2. **参与社区交流**：积极参与微前端社区，分享经验和学习最佳实践
3. **实验新技术**：尝试新的技术和方法，评估其在实际场景中的效果
4. **总结经验教训**：定期总结项目经验，形成团队自己的最佳实践
5. **持续优化改进**：基于实际效果不断优化和改进现有实践

通过遵循这些最佳实践，团队可以更好地实施微前端架构，构建高质量、可维护、可扩展的前端应用系统。