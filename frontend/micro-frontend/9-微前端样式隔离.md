# 第九章：微前端样式隔离

## 9.1 样式隔离概述

在微前端架构中，样式隔离是一个关键问题。由于多个微应用共享同一个页面，样式可能会相互干扰，导致UI显示异常。因此，需要有效的样式隔离机制来确保每个微应用的样式不会影响其他应用。

### 9.1.1 样式冲突的挑战

1. **全局样式污染**：一个应用的全局样式可能影响其他应用
2. **CSS类名冲突**：不同应用可能使用相同的CSS类名
3. **样式优先级问题**：样式规则可能相互覆盖
4. **第三方库样式冲突**：不同应用使用的第三方库可能有样式冲突
5. **主题不一致**：各应用可能使用不同的主题和设计系统
6. **样式加载顺序**：样式加载顺序可能影响最终效果

### 9.1.2 样式隔离场景

在微前端架构中，常见的样式隔离场景包括：

1. **独立运行**：微应用独立运行时样式正常
2. **集成运行**：微应用集成到主应用时样式异常
3. **动态加载**：微应用动态加载时样式可能被覆盖
4. **主题切换**：全局主题切换时各应用样式不一致
5. **样式更新**：一个应用更新样式影响其他应用
6. **第三方组件**：第三方组件样式可能相互干扰

## 9.2 CSS隔离方案

### 9.2.1 命名空间隔离

通过为每个微应用添加唯一的命名空间来隔离样式：

```javascript
// 命名空间处理器
class NamespaceProcessor {
  constructor(options = {}) {
    this.namespace = options.namespace || '';
    this.prefix = options.prefix || 'mf-';
    this.processedStyles = new Map();
  }
  
  // 处理CSS文本
  processCSS(cssText) {
    if (this.processedStyles.has(cssText)) {
      return this.processedStyles.get(cssText);
    }
    
    // 添加命名空间前缀
    const processedCSS = this.addNamespace(cssText);
    this.processedStyles.set(cssText, processedCSS);
    
    return processedCSS;
  }
  
  // 添加命名空间前缀
  addNamespace(cssText) {
    // 使用正则表达式匹配选择器
    const selectorRegex = /([^{}]+)\s*{/g;
    
    return cssText.replace(selectorRegex, (match, selector) => {
      // 跳过已命名空间的选择器
      if (selector.includes(`.${this.prefix}`)) {
        return match;
      }
      
      // 跳过@规则和媒体查询
      if (selector.trim().startsWith('@') || selector.includes(':')) {
        return match;
      }
      
      // 分割多个选择器
      const selectors = selector.split(',').map(s => {
        s = s.trim();
        
        // 跳过全局选择器
        if (s === 'html' || s === 'body' || s === '*') {
          return s;
        }
        
        // 跳过伪元素和伪类
        if (s.includes('::') || s.includes(':')) {
          return s;
        }
        
        // 添加命名空间前缀
        return `.${this.prefix}${this.namespace} ${s}`;
      });
      
      return `${selectors.join(', ')} {`;
    });
  }
  
  // 处理HTML元素
  processHTML(html) {
    // 为根元素添加命名空间类
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    
    // 查找根元素
    const rootElement = doc.body.firstChild;
    if (rootElement && rootElement.nodeType === Node.ELEMENT_NODE) {
      rootElement.classList.add(`${this.prefix}${this.namespace}`);
    }
    
    return doc.body.innerHTML;
  }
}

// 创建命名空间处理器
window.__MF_NAMESPACE_PROCESSOR__ = new NamespaceProcessor({
  namespace: 'user-app',
  prefix: 'mf-'
});

// 在微应用中使用
function loadMicroApp(appContainer, appUrl) {
  fetch(appUrl)
    .then(response => response.text())
    .then(html => {
      // 处理HTML
      const processedHTML = window.__MF_NAMESPACE_PROCESSOR__.processHTML(html);
      
      // 插入到容器
      appContainer.innerHTML = processedHTML;
      
      // 处理样式
      const styles = appContainer.querySelectorAll('style');
      styles.forEach(style => {
        const originalCSS = style.textContent;
        const processedCSS = window.__MF_NAMESPACE_PROCESSOR__.processCSS(originalCSS);
        style.textContent = processedCSS;
      });
    });
}
```

### 9.2.2 Shadow DOM隔离

使用Shadow DOM实现样式隔离：

```javascript
// Shadow DOM微应用加载器
class ShadowDOMAppLoader {
  constructor() {
    this.loadedApps = new Map();
  }
  
  // 加载微应用
  loadApp(appName, appUrl, container) {
    // 如果应用已加载，直接显示
    if (this.loadedApps.has(appName)) {
      const appData = this.loadedApps.get(appName);
      container.appendChild(appData.shadowHost);
      return Promise.resolve(appData.app);
    }
    
    // 创建Shadow Host
    const shadowHost = document.createElement('div');
    shadowHost.id = `mf-${appName}`;
    
    // 创建Shadow DOM
    const shadowRoot = shadowHost.attachShadow({ mode: 'open' });
    
    // 加载应用HTML
    return fetch(appUrl)
      .then(response => response.text())
      .then(html => {
        // 创建文档片段
        const template = document.createElement('template');
        template.innerHTML = html;
        
        // 克隆内容到Shadow DOM
        const clone = document.importNode(template.content, true);
        shadowRoot.appendChild(clone);
        
        // 加载样式
        return this.loadStyles(shadowRoot, appName);
      })
      .then(() => {
        // 加载脚本
        return this.loadScripts(shadowRoot, appName);
      })
      .then(() => {
        // 将Shadow Host添加到容器
        container.appendChild(shadowHost);
        
        // 缓存应用数据
        const appData = {
          shadowHost,
          shadowRoot,
          app: shadowRoot.querySelector('#app')
        };
        
        this.loadedApps.set(appName, appData);
        
        return appData.app;
      });
  }
  
  // 加载样式
  loadStyles(shadowRoot, appName) {
    // 获取应用样式文件
    const styleUrl = `/assets/${appName}/styles.css`;
    
    return fetch(styleUrl)
      .then(response => response.text())
      .then(cssText => {
        // 创建样式元素
        const style = document.createElement('style');
        style.textContent = cssText;
        
        // 添加到Shadow DOM
        shadowRoot.appendChild(style);
      })
      .catch(error => {
        console.warn(`无法加载应用 ${appName} 的样式:`, error);
      });
  }
  
  // 加载脚本
  loadScripts(shadowRoot, appName) {
    // 获取应用脚本文件
    const scriptUrl = `/assets/${appName}/app.js`;
    
    return fetch(scriptUrl)
      .then(response => response.text())
      .then(jsText => {
        // 创建脚本元素
        const script = document.createElement('script');
        script.textContent = jsText;
        
        // 添加到Shadow DOM
        shadowRoot.appendChild(script);
      })
      .catch(error => {
        console.warn(`无法加载应用 ${appName} 的脚本:`, error);
      });
  }
  
  // 卸载应用
  unloadApp(appName) {
    if (this.loadedApps.has(appName)) {
      const appData = this.loadedApps.get(appName);
      
      // 从DOM中移除
      if (appData.shadowHost.parentNode) {
        appData.shadowHost.parentNode.removeChild(appData.shadowHost);
      }
      
      // 从缓存中移除
      this.loadedApps.delete(appName);
    }
  }
}

// 创建全局应用加载器
window.__MF_SHADOW_DOM_LOADER__ = new ShadowDOMAppLoader();

// 在主应用中使用
function loadUserApp() {
  const container = document.getElementById('user-app-container');
  window.__MF_SHADOW_DOM_LOADER__.loadApp('user-app', '/apps/user-app/index.html', container)
    .then(app => {
      console.log('用户应用加载成功');
    })
    .catch(error => {
      console.error('用户应用加载失败:', error);
    });
}

function loadOrderApp() {
  const container = document.getElementById('order-app-container');
  window.__MF_SHADOW_DOM_LOADER__.loadApp('order-app', '/apps/order-app/index.html', container)
    .then(app => {
      console.log('订单应用加载成功');
    })
    .catch(error => {
      console.error('订单应用加载失败:', error);
    });
}
```

### 9.2.3 CSS-in-JS隔离

使用CSS-in-JS库实现样式隔离：

```javascript
// 使用styled-components实现样式隔离
import styled, { createGlobalStyle } from 'styled-components';

// 全局样式
const GlobalStyle = createGlobalStyle`
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
  }
`;

// 用户应用组件
const UserAppContainer = styled.div`
  padding: 20px;
  background-color: #f5f5f5;
  
  .user-profile {
    display: flex;
    align-items: center;
    margin-bottom: 20px;
    
    .avatar {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      margin-right: 15px;
    }
    
    .info {
      h3 {
        margin: 0;
        color: #333;
      }
      
      p {
        margin: 5px 0 0;
        color: #666;
      }
    }
  }
  
  .user-actions {
    button {
      padding: 8px 16px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      
      &:hover {
        background-color: #0069d9;
      }
    }
  }
`;

// 用户应用组件
class UserApp extends React.Component {
  render() {
    return (
      <UserAppContainer>
        <GlobalStyle />
        <div className="user-profile">
          <img className="avatar" src="/avatar.jpg" alt="用户头像" />
          <div className="info">
            <h3>John Doe</h3>
            <p>john.doe@example.com</p>
          </div>
        </div>
        <div className="user-actions">
          <button>编辑资料</button>
          <button>退出登录</button>
        </div>
      </UserAppContainer>
    );
  }
}

// 订单应用组件
const OrderAppContainer = styled.div`
  padding: 20px;
  background-color: #ffffff;
  
  .order-list {
    h2 {
      margin-bottom: 20px;
      color: #333;
    }
    
    .order-item {
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-bottom: 10px;
      
      .order-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
        
        .order-id {
          font-weight: bold;
        }
        
        .order-status {
          color: #28a745;
        }
      }
      
      .order-details {
        p {
          margin: 5px 0;
          color: #666;
        }
      }
      
      .order-actions {
        margin-top: 10px;
        
        button {
          padding: 6px 12px;
          background-color: #17a2b8;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          margin-right: 10px;
          
          &:hover {
            background-color: #138496;
          }
        }
      }
    }
  }
`;

// 订单应用组件
class OrderApp extends React.Component {
  render() {
    return (
      <OrderAppContainer>
        <div className="order-list">
          <h2>订单列表</h2>
          <div className="order-item">
            <div className="order-header">
              <span className="order-id">#12345</span>
              <span className="order-status">已完成</span>
            </div>
            <div className="order-details">
              <p>商品：JavaScript高级程序设计</p>
              <p>价格：￥89.00</p>
              <p>下单时间：2023-05-15 10:30</p>
            </div>
            <div className="order-actions">
              <button>查看详情</button>
              <button>申请售后</button>
            </div>
          </div>
        </div>
      </OrderAppContainer>
    );
  }
}
```

### 9.2.4 CSS Modules隔离

使用CSS Modules实现样式隔离：

```javascript
// 用户应用样式
// styles/UserApp.module.css
.container {
  padding: 20px;
  background-color: #f5f5f5;
}

.profile {
  display: flex;
  align-items: center;
  margin-bottom: 20px;
}

.avatar {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  margin-right: 15px;
}

.info {
  h3 {
    margin: 0;
    color: #333;
  }
  
  p {
    margin: 5px 0 0;
    color: #666;
  }
}

.actions {
  button {
    padding: 8px 16px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    
    &:hover {
      background-color: #0069d9;
    }
  }
}

// 用户应用组件
import React from 'react';
import styles from './styles/UserApp.module.css';

class UserApp extends React.Component {
  render() {
    return (
      <div className={styles.container}>
        <div className={styles.profile}>
          <img className={styles.avatar} src="/avatar.jpg" alt="用户头像" />
          <div className={styles.info}>
            <h3>John Doe</h3>
            <p>john.doe@example.com</p>
          </div>
        </div>
        <div className={styles.actions}>
          <button>编辑资料</button>
          <button>退出登录</button>
        </div>
      </div>
    );
  }
}

// 订单应用样式
// styles/OrderApp.module.css
.container {
  padding: 20px;
  background-color: #ffffff;
}

.list {
  h2 {
    margin-bottom: 20px;
    color: #333;
  }
}

.item {
  padding: 15px;
  border: 1px solid #ddd;
  border-radius: 4px;
  margin-bottom: 10px;
}

.header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 10px;
}

.id {
  font-weight: bold;
}

.status {
  color: #28a745;
}

.details {
  p {
    margin: 5px 0;
    color: #666;
  }
}

.actions {
  margin-top: 10px;
  
  button {
    padding: 6px 12px;
    background-color: #17a2b8;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-right: 10px;
    
    &:hover {
      background-color: #138496;
    }
  }
}

// 订单应用组件
import React from 'react';
import styles from './styles/OrderApp.module.css';

class OrderApp extends React.Component {
  render() {
    return (
      <div className={styles.container}>
        <div className={styles.list}>
          <h2>订单列表</h2>
          <div className={styles.item}>
            <div className={styles.header}>
              <span className={styles.id}>#12345</span>
              <span className={styles.status}>已完成</span>
            </div>
            <div className={styles.details}>
              <p>商品：JavaScript高级程序设计</p>
              <p>价格：￥89.00</p>
              <p>下单时间：2023-05-15 10:30</p>
            </div>
            <div className={styles.actions}>
              <button>查看详情</button>
              <button>申请售后</button>
            </div>
          </div>
        </div>
      </div>
    );
  }
}
```

## 9.3 动态样式隔离

### 9.3.1 动态CSS注入

实现动态CSS注入，确保样式隔离：

```javascript
// 动态CSS注入器
class DynamicCSSInjector {
  constructor() {
    this.injectedStyles = new Map();
    this.styleCounter = 0;
  }
  
  // 注入CSS
  injectCSS(cssText, scope) {
    const styleId = `dynamic-style-${this.styleCounter++}`;
    
    // 创建样式元素
    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = cssText;
    
    // 如果指定了作用域，添加作用域前缀
    if (scope) {
      style.setAttribute('data-scope', scope);
      style.textContent = this.addScopePrefix(cssText, scope);
    }
    
    // 添加到head
    document.head.appendChild(style);
    
    // 缓存样式
    this.injectedStyles.set(styleId, {
      element: style,
      cssText,
      scope
    });
    
    return styleId;
  }
  
  // 移除CSS
  removeCSS(styleId) {
    if (this.injectedStyles.has(styleId)) {
      const styleData = this.injectedStyles.get(styleId);
      
      // 从DOM中移除
      if (styleData.element.parentNode) {
        styleData.element.parentNode.removeChild(styleData.element);
      }
      
      // 从缓存中移除
      this.injectedStyles.delete(styleId);
    }
  }
  
  // 更新CSS
  updateCSS(styleId, cssText) {
    if (this.injectedStyles.has(styleId)) {
      const styleData = this.injectedStyles.get(styleId);
      
      // 更新CSS文本
      styleData.cssText = cssText;
      
      // 如果指定了作用域，添加作用域前缀
      if (styleData.scope) {
        styleData.element.textContent = this.addScopePrefix(cssText, styleData.scope);
      } else {
        styleData.element.textContent = cssText;
      }
    }
  }
  
  // 添加作用域前缀
  addScopePrefix(cssText, scope) {
    // 使用正则表达式匹配选择器
    const selectorRegex = /([^{}]+)\s*{/g;
    
    return cssText.replace(selectorRegex, (match, selector) => {
      // 跳过已作用域的选择器
      if (selector.includes(`[data-scope="${scope}"]`)) {
        return match;
      }
      
      // 跳过@规则和媒体查询
      if (selector.trim().startsWith('@') || selector.includes(':')) {
        return match;
      }
      
      // 分割多个选择器
      const selectors = selector.split(',').map(s => {
        s = s.trim();
        
        // 跳过全局选择器
        if (s === 'html' || s === 'body' || s === '*') {
          return s;
        }
        
        // 添加作用域前缀
        return `[data-scope="${scope}"] ${s}`;
      });
      
      return `${selectors.join(', ')} {`;
    });
  }
  
  // 清除所有样式
  clearAll() {
    this.injectedStyles.forEach((styleData, styleId) => {
      this.removeCSS(styleId);
    });
  }
  
  // 清除指定作用域的样式
  clearScope(scope) {
    const toRemove = [];
    
    this.injectedStyles.forEach((styleData, styleId) => {
      if (styleData.scope === scope) {
        toRemove.push(styleId);
      }
    });
    
    toRemove.forEach(styleId => {
      this.removeCSS(styleId);
    });
  }
}

// 创建全局动态CSS注入器
window.__MF_DYNAMIC_CSS_INJECTOR__ = new DynamicCSSInjector();

// 微应用样式加载器
class MicroAppStyleLoader {
  constructor() {
    this.loadedStyles = new Map();
  }
  
  // 加载应用样式
  loadAppStyles(appName, styleUrls, scope) {
    const promises = styleUrls.map(url => {
      return fetch(url)
        .then(response => response.text())
        .then(cssText => {
          // 注入CSS
          const styleId = window.__MF_DYNAMIC_CSS_INJECTOR__.injectCSS(cssText, scope);
          
          // 缓存样式ID
          if (!this.loadedStyles.has(appName)) {
            this.loadedStyles.set(appName, []);
          }
          this.loadedStyles.get(appName).push(styleId);
          
          return styleId;
        });
    });
    
    return Promise.all(promises);
  }
  
  // 卸载应用样式
  unloadAppStyles(appName) {
    if (this.loadedStyles.has(appName)) {
      const styleIds = this.loadedStyles.get(appName);
      
      styleIds.forEach(styleId => {
        window.__MF_DYNAMIC_CSS_INJECTOR__.removeCSS(styleId);
      });
      
      this.loadedStyles.delete(appName);
    }
  }
}

// 创建全局应用样式加载器
window.__MF_APP_STYLE_LOADER__ = new MicroAppStyleLoader();

// 在微应用中使用
function loadUserApp() {
  const appName = 'user-app';
  const scope = 'user-app';
  const styleUrls = [
    '/assets/user-app/styles.css',
    '/assets/user-app/components.css'
  ];
  
  // 加载应用样式
  window.__MF_APP_STYLE_LOADER__.loadAppStyles(appName, styleUrls, scope)
    .then(() => {
      // 设置应用容器的作用域
      const container = document.getElementById('user-app-container');
      container.setAttribute('data-scope', scope);
      
      // 加载应用HTML和脚本
      return loadAppHTML(appName, container);
    })
    .then(() => {
      console.log('用户应用加载成功');
    })
    .catch(error => {
      console.error('用户应用加载失败:', error);
    });
}

function unloadUserApp() {
  const appName = 'user-app';
  
  // 卸载应用样式
  window.__MF_APP_STYLE_LOADER__.unloadAppStyles(appName);
  
  // 清空应用容器
  const container = document.getElementById('user-app-container');
  container.innerHTML = '';
  
  console.log('用户应用卸载完成');
}
```

### 9.3.2 运行时样式转换

实现运行时样式转换，确保样式隔离：

```javascript
// 运行时样式转换器
class RuntimeStyleTransformer {
  constructor() {
    this.transformedStyles = new Map();
    this.scopePrefix = 'mf-scope-';
  }
  
  // 转换CSS
  transformCSS(cssText, scope) {
    const cacheKey = `${scope}:${cssText}`;
    
    if (this.transformedStyles.has(cacheKey)) {
      return this.transformedStyles.get(cacheKey);
    }
    
    // 转换CSS
    const transformedCSS = this.doTransform(cssText, scope);
    this.transformedStyles.set(cacheKey, transformedCSS);
    
    return transformedCSS;
  }
  
  // 执行转换
  doTransform(cssText, scope) {
    // 处理@import规则
    cssText = this.processImportRules(cssText, scope);
    
    // 处理选择器
    cssText = this.processSelectors(cssText, scope);
    
    // 处理字体规则
    cssText = this.processFontRules(cssText, scope);
    
    // 处理动画规则
    cssText = this.processAnimationRules(cssText, scope);
    
    return cssText;
  }
  
  // 处理@import规则
  processImportRules(cssText, scope) {
    const importRegex = /@import\s+(url\()?['"]([^'"]+)['"]\)?;?/g;
    
    return cssText.replace(importRegex, (match, urlFunc, url) => {
      // 添加作用域参数
      const separator = url.includes('?') ? '&' : '?';
      return match.replace(url, `${url}${separator}scope=${scope}`);
    });
  }
  
  // 处理选择器
  processSelectors(cssText, scope) {
    // 使用正则表达式匹配选择器
    const selectorRegex = /([^{}]+)\s*{/g;
    
    return cssText.replace(selectorRegex, (match, selector) => {
      // 跳过已作用域的选择器
      if (selector.includes(`.${this.scopePrefix}${scope}`)) {
        return match;
      }
      
      // 跳过@规则和媒体查询
      if (selector.trim().startsWith('@') || selector.includes(':')) {
        return match;
      }
      
      // 分割多个选择器
      const selectors = selector.split(',').map(s => {
        s = s.trim();
        
        // 跳过全局选择器
        if (s === 'html' || s === 'body' || s === '*') {
          return s;
        }
        
        // 添加作用域前缀
        return `.${this.scopePrefix}${scope} ${s}`;
      });
      
      return `${selectors.join(', ')} {`;
    });
  }
  
  // 处理字体规则
  processFontRules(cssText, scope) {
    // 处理@font-face规则
    const fontFaceRegex = /@font-face\s*{([^}]*)}/g;
    
    return cssText.replace(fontFaceRegex, (match, fontFaceContent) => {
      // 添加作用域注释
      return `/* scope: ${scope} */ ${match}`;
    });
  }
  
  // 处理动画规则
  processAnimationRules(cssText, scope) {
    // 处理@keyframes规则
    const keyframesRegex = /@keyframes\s+(\w+)\s*{([^}]*)}/g;
    
    return cssText.replace(keyframesRegex, (match, animationName, keyframesContent) => {
      // 重命名动画
      const scopedAnimationName = `${this.scopePrefix}${scope}-${animationName}`;
      return `@keyframes ${scopedAnimationName} {${keyframesContent}}`;
    });
  }
  
  // 转换HTML
  transformHTML(html, scope) {
    // 创建临时元素
    const temp = document.createElement('div');
    temp.innerHTML = html;
    
    // 为根元素添加作用域类
    const rootElement = temp.firstChild;
    if (rootElement && rootElement.nodeType === Node.ELEMENT_NODE) {
      rootElement.classList.add(`${this.scopePrefix}${scope}`);
    }
    
    // 转换style属性
    const elementsWithStyle = temp.querySelectorAll('[style]');
    elementsWithStyle.forEach(element => {
      const style = element.getAttribute('style');
      const transformedStyle = this.transformInlineStyle(style, scope);
      element.setAttribute('style', transformedStyle);
    });
    
    return temp.innerHTML;
  }
  
  // 转换内联样式
  transformInlineStyle(styleText, scope) {
    // 这里可以添加内联样式的转换逻辑
    // 例如添加作用域前缀到类名等
    return styleText;
  }
}

// 创建全局运行时样式转换器
window.__MF_RUNTIME_STYLE_TRANSFORMER__ = new RuntimeStyleTransformer();

// 微应用加载器
class MicroAppLoader {
  constructor() {
    this.loadedApps = new Map();
  }
  
  // 加载微应用
  loadApp(appName, appUrl, container) {
    // 如果应用已加载，直接显示
    if (this.loadedApps.has(appName)) {
      const appData = this.loadedApps.get(appName);
      container.appendChild(appData.element);
      return Promise.resolve(appData.app);
    }
    
    // 加载应用HTML
    return fetch(appUrl)
      .then(response => response.text())
      .then(html => {
        // 转换HTML
        const transformedHTML = window.__MF_RUNTIME_STYLE_TRANSFORMER__.transformHTML(html, appName);
        
        // 创建容器元素
        const appElement = document.createElement('div');
        appElement.innerHTML = transformedHTML;
        
        // 加载样式
        return this.loadAppStyles(appElement, appName)
          .then(() => {
            // 加载脚本
            return this.loadAppScripts(appElement, appName);
          })
          .then(() => {
            // 将应用元素添加到容器
            container.appendChild(appElement);
            
            // 缓存应用数据
            const appData = {
              element: appElement,
              app: appElement.querySelector('#app')
            };
            
            this.loadedApps.set(appName, appData);
            
            return appData.app;
          });
      });
  }
  
  // 加载应用样式
  loadAppStyles(appElement, appName) {
    const promises = [];
    
    // 获取所有样式链接
    const styleLinks = appElement.querySelectorAll('link[rel="stylesheet"]');
    styleLinks.forEach(link => {
      const href = link.getAttribute('href');
      
      // 移除原始链接
      link.parentNode.removeChild(link);
      
      // 加载样式
      const promise = fetch(href)
        .then(response => response.text())
        .then(cssText => {
          // 转换CSS
          const transformedCSS = window.__MF_RUNTIME_STYLE_TRANSFORMER__.transformCSS(cssText, appName);
          
          // 创建样式元素
          const style = document.createElement('style');
          style.textContent = transformedCSS;
          
          // 添加到应用元素
          appElement.appendChild(style);
        });
      
      promises.push(promise);
    });
    
    // 转换内联样式
    const inlineStyles = appElement.querySelectorAll('style');
    inlineStyles.forEach(style => {
      const originalCSS = style.textContent;
      const transformedCSS = window.__MF_RUNTIME_STYLE_TRANSFORMER__.transformCSS(originalCSS, appName);
      style.textContent = transformedCSS;
    });
    
    return Promise.all(promises);
  }
  
  // 加载应用脚本
  loadAppScripts(appElement, appName) {
    const promises = [];
    
    // 获取所有脚本
    const scripts = appElement.querySelectorAll('script');
    scripts.forEach(script => {
      const src = script.getAttribute('src');
      
      if (src) {
        // 外部脚本
        const promise = fetch(src)
          .then(response => response.text())
          .then(jsText => {
            // 创建新脚本元素
            const newScript = document.createElement('script');
            newScript.textContent = jsText;
            
            // 替换原始脚本
            script.parentNode.replaceChild(newScript, script);
          });
        
        promises.push(promise);
      }
    });
    
    return Promise.all(promises);
  }
  
  // 卸载应用
  unloadApp(appName) {
    if (this.loadedApps.has(appName)) {
      const appData = this.loadedApps.get(appName);
      
      // 从DOM中移除
      if (appData.element.parentNode) {
        appData.element.parentNode.removeChild(appData.element);
      }
      
      // 从缓存中移除
      this.loadedApps.delete(appName);
    }
  }
}

// 创建全局应用加载器
window.__MF_APP_LOADER__ = new MicroAppLoader();
```

## 9.4 主题系统与样式隔离

### 9.4.1 主题系统设计

设计支持微前端的主题系统：

```javascript
// 主题管理器
class ThemeManager {
  constructor() {
    this.themes = new Map();
    this.currentTheme = null;
    this.subscribers = [];
  }
  
  // 注册主题
  registerTheme(name, theme) {
    this.themes.set(name, theme);
  }
  
  // 设置当前主题
  setTheme(name) {
    if (this.themes.has(name)) {
      this.currentTheme = name;
      this.applyTheme(name);
      this.notifySubscribers(name);
    }
  }
  
  // 获取当前主题
  getCurrentTheme() {
    return this.currentTheme;
  }
  
  // 获取主题变量
  getThemeVariable(variableName) {
    if (this.currentTheme && this.themes.has(this.currentTheme)) {
      const theme = this.themes.get(this.currentTheme);
      return theme.variables[variableName];
    }
    return null;
  }
  
  // 应用主题
  applyTheme(name) {
    const theme = this.themes.get(name);
    if (!theme) return;
    
    // 设置CSS变量
    const root = document.documentElement;
    Object.entries(theme.variables).forEach(([key, value]) => {
      root.style.setProperty(`--${key}`, value);
    });
    
    // 应用主题类
    document.body.className = document.body.className.replace(/theme-\w+/g, '');
    document.body.classList.add(`theme-${name}`);
  }
  
  // 订阅主题变化
  subscribe(callback) {
    this.subscribers.push(callback);
    
    // 返回取消订阅函数
    return () => {
      this.subscribers = this.subscribers.filter(sub => sub !== callback);
    };
  }
  
  // 通知订阅者
  notifySubscribers(themeName) {
    this.subscribers.forEach(callback => {
      callback(themeName);
    });
  }
}

// 创建全局主题管理器
window.__MF_THEME_MANAGER__ = new ThemeManager();

// 注册默认主题
window.__MF_THEME_MANAGER__.registerTheme('light', {
  name: '浅色主题',
  variables: {
    'primary-color': '#007bff',
    'secondary-color': '#6c757d',
    'success-color': '#28a745',
    'danger-color': '#dc3545',
    'warning-color': '#ffc107',
    'info-color': '#17a2b8',
    'light-color': '#f8f9fa',
    'dark-color': '#343a40',
    'background-color': '#ffffff',
    'text-color': '#212529',
    'border-color': '#dee2e6'
  }
});

window.__MF_THEME_MANAGER__.registerTheme('dark', {
  name: '深色主题',
  variables: {
    'primary-color': '#0d6efd',
    'secondary-color': '#6c757d',
    'success-color': '#198754',
    'danger-color': '#dc3545',
    'warning-color': '#ffc107',
    'info-color': '#0dcaf0',
    'light-color': '#212529',
    'dark-color': '#f8f9fa',
    'background-color': '#121212',
    'text-color': '#ffffff',
    'border-color': '#495057'
  }
});

// 主题感知组件
class ThemedComponent extends React.Component {
  constructor(props) {
    super(props);
    
    this.state = {
      theme: window.__MF_THEME_MANAGER__.getCurrentTheme()
    };
    
    // 订阅主题变化
    this.unsubscribe = window.__MF_THEME_MANAGER__.subscribe(theme => {
      this.setState({ theme });
    });
  }
  
  componentWillUnmount() {
    // 取消订阅
    this.unsubscribe();
  }
  
  render() {
    const { theme } = this.state;
    
    return (
      <div className={`themed-component theme-${theme}`}>
        {/* 组件内容 */}
      </div>
    );
  }
}

// 主题感知样式处理器
class ThemedStyleProcessor {
  constructor() {
    this.processedStyles = new Map();
  }
  
  // 处理CSS
  processCSS(cssText, scope) {
    const cacheKey = `${scope}:${cssText}`;
    
    if (this.processedStyles.has(cacheKey)) {
      return this.processedStyles.get(cacheKey);
    }
    
    // 处理CSS变量
    const processedCSS = this.processCSSVariables(cssText, scope);
    this.processedStyles.set(cacheKey, processedCSS);
    
    return processedCSS;
  }
  
  // 处理CSS变量
  processCSSVariables(cssText, scope) {
    // 替换硬编码颜色为CSS变量
    const colorRegex = /#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})\b/g;
    
    return cssText.replace(colorRegex, (match, color) => {
      // 根据颜色值推断变量名
      const variableName = this.inferVariableName(match);
      
      if (variableName) {
        return `var(--${variableName})`;
      }
      
      return match;
    });
  }
  
  // 推断变量名
  inferVariableName(color) {
    // 颜色到变量名的映射
    const colorMap = {
      '#007bff': 'primary-color',
      '#6c757d': 'secondary-color',
      '#28a745': 'success-color',
      '#dc3545': 'danger-color',
      '#ffc107': 'warning-color',
      '#17a2b8': 'info-color',
      '#f8f9fa': 'light-color',
      '#343a40': 'dark-color',
      '#ffffff': 'background-color',
      '#212529': 'text-color',
      '#dee2e6': 'border-color'
    };
    
    return colorMap[color.toLowerCase()];
  }
}

// 创建全局主题感知样式处理器
window.__MF_THEMED_STYLE_PROCESSOR__ = new ThemedStyleProcessor();
```

### 9.4.2 主题切换与样式隔离

实现主题切换与样式隔离的结合：

```javascript
// 主题切换器
class ThemeSwitcher {
  constructor() {
    this.themeManager = window.__MF_THEME_MANAGER__;
    this.styleProcessor = window.__MF_THEMED_STYLE_PROCESSOR__;
    this.appThemes = new Map();
  }
  
  // 注册应用主题
  registerAppTheme(appName, theme) {
    this.appThemes.set(appName, theme);
  }
  
  // 切换主题
  switchTheme(themeName) {
    // 设置全局主题
    this.themeManager.setTheme(themeName);
    
    // 更新应用主题
    this.updateAppThemes(themeName);
  }
  
  // 更新应用主题
  updateAppThemes(themeName) {
    this.appThemes.forEach((appTheme, appName) => {
      if (appTheme[themeName]) {
        this.applyAppTheme(appName, appTheme[themeName]);
      }
    });
  }
  
  // 应用应用主题
  applyAppTheme(appName, theme) {
    // 获取应用容器
    const container = document.querySelector(`[data-app="${appName}"]`);
    if (!container) return;
    
    // 设置应用特定的CSS变量
    Object.entries(theme.variables).forEach(([key, value]) => {
      container.style.setProperty(`--${key}`, value);
    });
    
    // 更新应用样式
    this.updateAppStyles(container, theme);
  }
  
  // 更新应用样式
  updateAppStyles(container, theme) {
    // 获取应用中的所有样式元素
    const styles = container.querySelectorAll('style[data-app-theme]');
    
    styles.forEach(style => {
      const originalCSS = style.getAttribute('data-original-css');
      if (originalCSS) {
        // 处理原始CSS
        const processedCSS = this.styleProcessor.processCSS(originalCSS, theme.name);
        style.textContent = processedCSS;
      }
    });
  }
  
  // 加载应用主题样式
  loadAppThemeStyles(appName, themeName, styleUrls) {
    const promises = styleUrls.map(url => {
      return fetch(url)
        .then(response => response.text())
        .then(cssText => {
          // 处理CSS
          const processedCSS = this.styleProcessor.processCSS(cssText, themeName);
          
          // 创建样式元素
          const style = document.createElement('style');
          style.textContent = processedCSS;
          style.setAttribute('data-app', appName);
          style.setAttribute('data-app-theme', themeName);
          style.setAttribute('data-original-css', cssText);
          
          // 添加到应用容器
          const container = document.querySelector(`[data-app="${appName}"]`);
          if (container) {
            container.appendChild(style);
          }
          
          return style;
        });
    });
    
    return Promise.all(promises);
  }
}

// 创建全局主题切换器
window.__MF_THEME_SWITCHER__ = new ThemeSwitcher();

// 注册应用主题
window.__MF_THEME_SWITCHER__.registerAppTheme('user-app', {
  light: {
    name: '浅色主题',
    variables: {
      'app-primary-color': '#007bff',
      'app-background-color': '#f8f9fa',
      'app-text-color': '#212529'
    }
  },
  dark: {
    name: '深色主题',
    variables: {
      'app-primary-color': '#0d6efd',
      'app-background-color': '#212529',
      'app-text-color': '#ffffff'
    }
  }
});

window.__MF_THEME_SWITCHER__.registerAppTheme('order-app', {
  light: {
    name: '浅色主题',
    variables: {
      'app-primary-color': '#28a745',
      'app-background-color': '#ffffff',
      'app-text-color': '#212529'
    }
  },
  dark: {
    name: '深色主题',
    variables: {
      'app-primary-color': '#198754',
      'app-background-color': '#121212',
      'app-text-color': '#ffffff'
    }
  }
});

// 主题切换组件
class ThemeSwitcherComponent extends React.Component {
  constructor(props) {
    super(props);
    
    this.state = {
      currentTheme: window.__MF_THEME_MANAGER__.getCurrentTheme() || 'light'
    };
    
    // 订阅主题变化
    this.unsubscribe = window.__MF_THEME_MANAGER__.subscribe(theme => {
      this.setState({ currentTheme: theme });
    });
  }
  
  componentWillUnmount() {
    // 取消订阅
    this.unsubscribe();
  }
  
  handleThemeChange = (event) => {
    const themeName = event.target.value;
    window.__MF_THEME_SWITCHER__.switchTheme(themeName);
  };
  
  render() {
    const { currentTheme } = this.state;
    
    return (
      <div className="theme-switcher">
        <label htmlFor="theme-select">主题：</label>
        <select id="theme-select" value={currentTheme} onChange={this.handleThemeChange}>
          <option value="light">浅色</option>
          <option value="dark">深色</option>
        </select>
      </div>
    );
  }
}
```

## 9.5 样式隔离最佳实践

### 9.5.1 样式隔离策略选择

根据应用场景选择合适的样式隔离策略：

1. **命名空间隔离**：
   - 适用于：简单应用、快速原型、小型项目
   - 优点：实现简单、性能好、兼容性强
   - 缺点：隔离性较弱、需要严格命名规范

2. **Shadow DOM隔离**：
   - 适用于：复杂应用、高隔离要求、第三方组件集成
   - 优点：强隔离性、样式完全隔离、DOM封装
   - 缺点：浏览器兼容性、性能开销、调试困难

3. **CSS-in-JS隔离**：
   - 适用于：React应用、动态样式、主题系统
   - 优点：动态样式、组件级隔离、主题支持
   - 缺点：学习成本、运行时开销、代码体积

4. **CSS Modules隔离**：
   - 适用于：模块化开发、构建工具集成、中大型项目
   - 优点：编译时隔离、局部作用域、构建工具支持
   - 缺点：构建依赖、调试复杂、全局样式处理

### 9.5.2 样式规范与约定

制定样式规范与约定，确保样式隔离：

```javascript
// 样式规范检查器
class StyleConventionChecker {
  constructor() {
    this.rules = [
      {
        name: 'class-naming',
        description: '类名应使用BEM命名规范',
        check: this.checkClassNaming.bind(this)
      },
      {
        name: 'no-global-selectors',
        description: '避免使用全局选择器',
        check: this.checkNoGlobalSelectors.bind(this)
      },
      {
        name: 'specificity-limit',
        description: '选择器特异性不应过高',
        check: this.checkSpecificityLimit.bind(this)
      },
      {
        name: 'no-important',
        description: '避免使用!important',
        check: this.checkNoImportant.bind(this)
      }
    ];
  }
  
  // 检查CSS
  checkCSS(cssText) {
    const results = [];
    
    this.rules.forEach(rule => {
      try {
        const result = rule.check(cssText);
        results.push({
          rule: rule.name,
          description: rule.description,
          passed: result.passed,
          message: result.message,
          line: result.line
        });
      } catch (error) {
        results.push({
          rule: rule.name,
          description: rule.description,
          passed: false,
          message: `检查出错: ${error.message}`
        });
      }
    });
    
    return results;
  }
  
  // 检查类名命名
  checkClassNaming(cssText) {
    const lines = cssText.split('\n');
    const classRegex = /\.([a-zA-Z0-9_-]+)/g;
    let violations = [];
    
    lines.forEach((line, index) => {
      let match;
      while ((match = classRegex.exec(line)) !== null) {
        const className = match[1];
        
        // 检查BEM命名规范
        if (!this.isBEMNaming(className)) {
          violations.push({
            line: index + 1,
            className,
            message: `类名 "${className}" 不符合BEM命名规范`
          });
        }
      }
    });
    
    if (violations.length === 0) {
      return { passed: true, message: '所有类名符合BEM命名规范' };
    } else {
      return {
        passed: false,
        message: `发现 ${violations.length} 个不符合BEM命名规范的类名`,
        violations
      };
    }
  }
  
  // 检查是否为BEM命名
  isBEMNaming(className) {
    // 简单的BEM命名检查
    const bemPattern = /^[a-z]+(-[a-z]+)?(__[a-z]+(-[a-z]+)?(--[a-z]+(-[a-z]+)?)?)?$/;
    return bemPattern.test(className);
  }
  
  // 检查全局选择器
  checkNoGlobalSelectors(cssText) {
    const lines = cssText.split('\n');
    const globalSelectors = ['html', 'body', '*'];
    let violations = [];
    
    lines.forEach((line, index) => {
      globalSelectors.forEach(selector => {
        if (line.includes(selector) && !line.includes(`.${selector}`)) {
          violations.push({
            line: index + 1,
            selector,
            message: `使用了全局选择器 "${selector}"`
          });
        }
      });
    });
    
    if (violations.length === 0) {
      return { passed: true, message: '未发现全局选择器' };
    } else {
      return {
        passed: false,
        message: `发现 ${violations.length} 个全局选择器`,
        violations
      };
    }
  }
  
  // 检查选择器特异性
  checkSpecificityLimit(cssText) {
    const lines = cssText.split('\n');
    const selectorRegex = /([^{}]+)\s*{/g;
    let violations = [];
    
    lines.forEach((line, index) => {
      let match;
      while ((match = selectorRegex.exec(line)) !== null) {
        const selector = match[1].trim();
        const specificity = this.calculateSpecificity(selector);
        
        if (specificity > 20) {
          violations.push({
            line: index + 1,
            selector,
            specificity,
            message: `选择器 "${selector}" 特异性过高 (${specificity})`
          });
        }
      }
    });
    
    if (violations.length === 0) {
      return { passed: true, message: '所有选择器特异性在合理范围内' };
    } else {
      return {
        passed: false,
        message: `发现 ${violations.length} 个高特异性选择器`,
        violations
      };
    }
  }
  
  // 计算选择器特异性
  calculateSpecificity(selector) {
    const ids = (selector.match(/#/g) || []).length;
    const classes = (selector.match(/\./g) || []).length;
    const attributes = (selector.match(/\[/g) || []).length;
    const pseudoClasses = (selector.match(/:/g) || []).length;
    const elements = (selector.match(/^[a-z]|\s+[a-z]|\+[a-z]|\>[a-z]/g) || []).length;
    
    // 简化的特异性计算
    return ids * 100 + (classes + attributes + pseudoClasses) * 10 + elements;
  }
  
  // 检查!important
  checkNoImportant(cssText) {
    const lines = cssText.split('\n');
    const importantRegex = /!important/g;
    let violations = [];
    
    lines.forEach((line, index) => {
      let match;
      while ((match = importantRegex.exec(line)) !== null) {
        violations.push({
          line: index + 1,
          message: '使用了!important'
        });
      }
    });
    
    if (violations.length === 0) {
      return { passed: true, message: '未发现!important' };
    } else {
      return {
        passed: false,
        message: `发现 ${violations.length} 个!important`,
        violations
      };
    }
  }
}

// 创建全局样式规范检查器
window.__MF_STYLE_CONVENTION_CHECKER__ = new StyleConventionChecker();

// 在构建过程中检查样式
function checkStyleConventions(cssText) {
  const results = window.__MF_STYLE_CONVENTION_CHECKER__.checkCSS(cssText);
  
  // 输出检查结果
  console.group('样式规范检查结果');
  results.forEach(result => {
    if (result.passed) {
      console.log(`✓ ${result.rule}: ${result.message}`);
    } else {
      console.error(`✗ ${result.rule}: ${result.message}`);
      if (result.violations) {
        result.violations.forEach(violation => {
          console.error(`  行 ${violation.line}: ${violation.message}`);
        });
      }
    }
  });
  console.groupEnd();
  
  return results;
}
```

### 9.5.3 样式性能优化

优化样式性能，提高微前端应用性能：

```javascript
// 样式性能优化器
class StylePerformanceOptimizer {
  constructor() {
    this.optimizedStyles = new Map();
    this.criticalCSSCache = new Map();
  }
  
  // 优化CSS
  optimizeCSS(cssText, options = {}) {
    const cacheKey = `${JSON.stringify(options)}:${cssText}`;
    
    if (this.optimizedStyles.has(cacheKey)) {
      return this.optimizedStyles.get(cacheKey);
    }
    
    // 应用优化策略
    let optimizedCSS = cssText;
    
    // 移除未使用的CSS
    if (options.removeUnused !== false) {
      optimizedCSS = this.removeUnusedCSS(optimizedCSS, options.usedSelectors);
    }
    
    // 压缩CSS
    if (options.minify !== false) {
      optimizedCSS = this.minifyCSS(optimizedCSS);
    }
    
    // 内联关键CSS
    if (options.inlineCritical !== false) {
      optimizedCSS = this.inlineCriticalCSS(optimizedCSS, options.criticalSelectors);
    }
    
    // 合并相同选择器
    if (options.mergeSelectors !== false) {
      optimizedCSS = this.mergeSelectors(optimizedCSS);
    }
    
    this.optimizedStyles.set(cacheKey, optimizedCSS);
    
    return optimizedCSS;
  }
  
  // 移除未使用的CSS
  removeUnusedCSS(cssText, usedSelectors = []) {
    // 如果没有提供使用的选择器，返回原始CSS
    if (!usedSelectors || usedSelectors.length === 0) {
      return cssText;
    }
    
    // 解析CSS规则
    const rules = this.parseCSSRules(cssText);
    
    // 过滤未使用的规则
    const usedRules = rules.filter(rule => {
      if (rule.type === 'style') {
        // 检查选择器是否被使用
        return rule.selectors.some(selector => {
          return usedSelectors.some(usedSelector => {
            return this.selectorMatches(selector, usedSelector);
          });
        });
      }
      
      // 保留@规则
      return true;
    });
    
    // 重新生成CSS
    return this.generateCSS(usedRules);
  }
  
  // 压缩CSS
  minifyCSS(cssText) {
    return cssText
      // 移除注释
      .replace(/\/\*[\s\S]*?\*\//g, '')
      // 移除多余的空白字符
      .replace(/\s+/g, ' ')
      // 移除分号前的空格
      .replace(/\s*;\s*/g, ';')
      // 移除大括号前后的空格
      .replace(/\s*{\s*/g, '{')
      .replace(/\s*}\s*/g, '}')
      // 移除冒号后的空格
      .replace(/:\s+/g, ':')
      // 移除逗号后的空格
      .replace(/,\s+/g, ',')
      .trim();
  }
  
  // 内联关键CSS
  inlineCriticalCSS(cssText, criticalSelectors = []) {
    if (!criticalSelectors || criticalSelectors.length === 0) {
      return cssText;
    }
    
    // 解析CSS规则
    const rules = this.parseCSSRules(cssText);
    
    // 分离关键CSS和非关键CSS
    const criticalRules = [];
    const nonCriticalRules = [];
    
    rules.forEach(rule => {
      if (rule.type === 'style') {
        const isCritical = rule.selectors.some(selector => {
          return criticalSelectors.some(criticalSelector => {
            return this.selectorMatches(selector, criticalSelector);
          });
        });
        
        if (isCritical) {
          criticalRules.push(rule);
        } else {
          nonCriticalRules.push(rule);
        }
      } else {
        // 保留@规则
        nonCriticalRules.push(rule);
      }
    });
    
    // 生成关键CSS和非关键CSS
    const criticalCSS = this.generateCSS(criticalRules);
    const nonCriticalCSS = this.generateCSS(nonCriticalRules);
    
    return {
      critical: criticalCSS,
      nonCritical: nonCriticalCSS
    };
  }
  
  // 合并相同选择器
  mergeSelectors(cssText) {
    // 解析CSS规则
    const rules = this.parseCSSRules(cssText);
    
    // 按选择器分组
    const selectorGroups = {};
    
    rules.forEach(rule => {
      if (rule.type === 'style') {
        rule.selectors.forEach(selector => {
          if (!selectorGroups[selector]) {
            selectorGroups[selector] = [];
          }
          selectorGroups[selector].push(rule);
        });
      }
    });
    
    // 合并相同选择器的规则
    const mergedRules = [];
    
    Object.entries(selectorGroups).forEach(([selector, rules]) => {
      // 合并属性
      const mergedProperties = {};
      
      rules.forEach(rule => {
        Object.entries(rule.properties).forEach(([property, value]) => {
          mergedProperties[property] = value;
        });
      });
      
      // 创建合并后的规则
      mergedRules.push({
        type: 'style',
        selectors: [selector],
        properties: mergedProperties
      });
    });
    
    // 添加非样式规则
    rules.forEach(rule => {
      if (rule.type !== 'style') {
        mergedRules.push(rule);
      }
    });
    
    // 生成CSS
    return this.generateCSS(mergedRules);
  }
  
  // 解析CSS规则
  parseCSSRules(cssText) {
    // 简化的CSS解析器
    const rules = [];
    
    // 移除注释
    const cleanCSS = cssText.replace(/\/\*[\s\S]*?\*\//g, '');
    
    // 匹配规则
    const ruleRegex = /([^{}]+)\s*{([^{}]*)}/g;
    let match;
    
    while ((match = ruleRegex.exec(cleanCSS)) !== null) {
      const selectorText = match[1].trim();
      const propertyText = match[2].trim();
      
      // 检查是否为@规则
      if (selectorText.startsWith('@')) {
        rules.push({
          type: 'at-rule',
          name: selectorText,
          rules: this.parseCSSRules(propertyText)
        });
      } else {
        // 解析选择器
        const selectors = selectorText.split(',').map(s => s.trim());
        
        // 解析属性
        const properties = {};
        const propertyRegex = /([^:]+):\s*([^;]+)/g;
        let propMatch;
        
        while ((propMatch = propertyRegex.exec(propertyText)) !== null) {
          const property = propMatch[1].trim();
          const value = propMatch[2].trim();
          properties[property] = value;
        }
        
        rules.push({
          type: 'style',
          selectors,
          properties
        });
      }
    }
    
    return rules;
  }
  
  // 生成CSS
  generateCSS(rules) {
    let cssText = '';
    
    rules.forEach(rule => {
      if (rule.type === 'style') {
        cssText += `${rule.selectors.join(', ')} {`;
        
        Object.entries(rule.properties).forEach(([property, value]) => {
          cssText += `${property}: ${value};`;
        });
        
        cssText += '}';
      } else if (rule.type === 'at-rule') {
        cssText += `${rule.name} {`;
        cssText += this.generateCSS(rule.rules);
        cssText += '}';
      }
    });
    
    return cssText;
  }
  
  // 检查选择器是否匹配
  selectorMatches(selector, pattern) {
    // 简化的选择器匹配
    if (selector === pattern) {
      return true;
    }
    
    // 检查类名匹配
    const selectorClasses = selector.match(/\.[a-zA-Z0-9_-]+/g) || [];
    const patternClasses = pattern.match(/\.[a-zA-Z0-9_-]+/g) || [];
    
    if (patternClasses.length > 0) {
      return patternClasses.every(cls => selectorClasses.includes(cls));
    }
    
    return false;
  }
  
  // 提取关键CSS
  extractCriticalCSS(html, cssText) {
    const cacheKey = `${html.length}:${cssText.length}`;
    
    if (this.criticalCSSCache.has(cacheKey)) {
      return this.criticalCSSCache.get(cacheKey);
    }
    
    // 创建临时DOM
    const temp = document.createElement('div');
    temp.innerHTML = html;
    
    // 获取所有元素
    const elements = temp.querySelectorAll('*');
    
    // 提取使用的类名
    const usedClasses = new Set();
    elements.forEach(element => {
      if (element.className) {
        element.className.split(' ').forEach(cls => {
          if (cls.trim()) {
            usedClasses.add(`.${cls.trim()}`);
          }
        });
      }
    });
    
    // 提取关键CSS
    const criticalCSS = this.optimizeCSS(cssText, {
      usedSelectors: Array.from(usedClasses),
      minify: false
    });
    
    this.criticalCSSCache.set(cacheKey, criticalCSS);
    
    return criticalCSS;
  }
}

// 创建全局样式性能优化器
window.__MF_STYLE_PERFORMANCE_OPTIMIZER__ = new StylePerformanceOptimizer();
```

## 9.6 本章小结

本章详细介绍了微前端架构中的样式隔离问题，包括样式冲突的挑战、各种隔离方案、动态样式隔离、主题系统与样式隔离的结合以及样式隔离的最佳实践。我们通过实际代码示例展示了如何在不同场景下实现样式隔离，并提供了样式规范检查和性能优化的方法。

样式隔离是微前端架构中的关键问题，有效的样式隔离方案可以确保各微应用的样式不会相互干扰，提高应用的稳定性和用户体验。在实际项目中，需要根据应用规模、技术栈和性能要求来选择合适的样式隔离策略。

在下一章中，我们将学习微前端性能优化的相关知识，了解如何提高微前端应用的性能。

## 9.7 思考题

1. 微前端样式隔离面临哪些主要挑战？
2. 如何选择合适的样式隔离策略？
3. 在微前端架构中，如何实现主题系统与样式隔离的结合？

## 9.8 示例代码

本章的完整示例代码已经保存在 `frontend/micro-frontend/code/chapter9/style-isolation` 目录中。

### 9.8.1 代码结构

```
style-isolation/
├── src/
│   ├── main-app/
│   │   ├── index.js
│   │   ├── App.js
│   │   └── styles/
│   │       ├── NamespaceProcessor.js
│   │       ├── ShadowDOMAppLoader.js
│   │       └── ThemeManager.js
│   ├── user-app/
│   │   ├── index.js
│   │   ├── App.js
│   │   └── styles/
│   │       ├── UserApp.module.css
│   │       └── components/
│   │           ├── UserProfile.module.css
│   │           └── UserActions.module.css
│   ├── order-app/
│   │   ├── index.js
│   │   ├── App.js
│   │   └── styles/
│   │       ├── OrderApp.module.css
│   │       └── components/
│   │           ├── OrderList.module.css
│   │           └── OrderDetails.module.css
│   ├── shared/
│   │   ├── DynamicCSSInjector.js
│   │   ├── RuntimeStyleTransformer.js
│   │   ├── StyleConventionChecker.js
│   │   └── StylePerformanceOptimizer.js
│   └── index.html
├── package.json
└── webpack.config.js
```

### 9.8.2 运行示例

1. 进入示例代码目录：
```bash
cd frontend/micro-frontend/code/chapter9/style-isolation
```

2. 安装依赖：
```bash
npm install
```

3. 启动开发服务器：
```bash
npm start
```

4. 在浏览器中打开 http://localhost:9009

### 9.8.3 示例功能说明

- 演示了多种样式隔离方案：命名空间隔离、Shadow DOM隔离、CSS-in-JS隔离、CSS Modules隔离
- 实现了动态样式注入和运行时样式转换
- 提供了主题系统与样式隔离的结合方案
- 包含了样式规范检查和性能优化功能
- 展示了样式隔离的最佳实践

### 9.8.4 路由说明

- `/` - 主页面
- `/user` - 用户应用（命名空间隔离）
- `/order` - 订单应用（Shadow DOM隔离）
- `/theme-demo` - 主题切换演示

## 9.9 参考资料

1. CSS Modules文档：https://github.com/css-modules/css-modules
2. Shadow DOM文档：https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM
3. styled-components文档：https://styled-components.com/
4. CSS-in-JS文档：https://cssinjs.org/