# 第十一章：微前端测试策略

## 11.1 微前端测试概述

### 11.1.1 微前端测试挑战

微前端架构在带来灵活性和可维护性的同时，也引入了新的测试挑战：

1. **应用间依赖测试**：微应用之间存在复杂的依赖关系，测试时需要考虑这些依赖
2. **集成测试复杂性**：多个微应用集成后的测试比单体应用更加复杂
3. **环境隔离**：确保测试环境之间相互隔离，避免测试结果相互影响
4. **数据一致性**：跨微应用的数据一致性测试变得困难
5. **版本兼容性**：不同微应用版本之间的兼容性测试
6. **性能测试**：微前端架构下的性能测试需要考虑应用加载、切换等场景
7. **端到端测试**：完整的用户流程可能跨越多个微应用，增加了端到端测试的复杂性

### 11.1.2 测试策略分层

微前端测试应采用分层策略，从单元测试到端到端测试，确保各个层面的质量：

1. **单元测试**：测试单个函数、组件或模块的功能
2. **集成测试**：测试微应用内部组件之间的交互
3. **应用间测试**：测试微应用之间的交互和通信
4. **端到端测试**：测试完整的用户流程
5. **性能测试**：测试系统性能指标
6. **安全测试**：测试系统安全性

### 11.1.3 测试金字塔

在微前端架构中，测试金字塔的形状可能有所不同：

```
        /\
       /  \
      / E2E \     少量端到端测试
     /______\
    /        \
   /Integration\  适量集成测试
  /__________\
 /            \
/  Unit Tests  \  大量单元测试
/______________\
```

微前端架构中，应用间集成测试和端到端测试的比例可能会增加，因为微应用之间的交互是一个重要的测试点。

## 11.2 单元测试策略

### 11.2.1 微应用单元测试

微应用的单元测试主要关注应用内部的功能模块和组件：

1. **组件测试**：测试UI组件的渲染、交互和状态管理
2. **服务测试**：测试业务逻辑和数据处理服务
3. **工具函数测试**：测试通用工具函数的正确性
4. **状态管理测试**：测试状态管理器的行为和状态变化
5. **路由测试**：测试路由配置和导航逻辑

### 11.2.2 框架单元测试

框架单元测试主要关注微前端框架的核心功能：

1. **应用加载器测试**：测试应用加载、卸载和切换逻辑
2. **路由管理测试**：测试路由注册、匹配和导航功能
3. **状态共享测试**：测试跨应用状态共享机制
4. **沙箱隔离测试**：测试沙箱的隔离效果和安全性
5. **通信机制测试**：测试应用间通信的可靠性

### 11.2.3 单元测试工具

常用的单元测试工具包括：

1. **Jest**：功能全面的JavaScript测试框架
2. **Vitest**：基于Vite的快速测试框架
3. **Mocha**：灵活的测试框架
4. **Chai**：断言库，可与多种测试框架配合使用
5. **Sinon**：用于模拟、存根和监视函数行为

### 11.2.4 单元测试示例

```javascript
// 示例：微应用组件单元测试
import { render, screen, fireEvent } from '@testing-library/react';
import { MicroApp } from '../src/MicroApp';

describe('MicroApp Component', () => {
  test('renders correctly with props', () => {
    const props = {
      name: 'test-app',
      url: 'http://localhost:3001',
      container: '#app-container'
    };
    
    render(<MicroApp {...props} />);
    
    expect(screen.getByTestId('micro-app')).toBeInTheDocument();
    expect(screen.getByTestId('app-name')).toHaveTextContent('test-app');
  });

  test('handles load event correctly', () => {
    const props = {
      name: 'test-app',
      url: 'http://localhost:3001',
      container: '#app-container',
      onLoad: jest.fn()
    };
    
    render(<MicroApp {...props} />);
    
    // 模拟加载完成事件
    fireEvent.load(screen.getByTestId('micro-app'));
    
    expect(props.onLoad).toHaveBeenCalledWith('test-app');
  });

  test('handles error event correctly', () => {
    const props = {
      name: 'test-app',
      url: 'http://localhost:3001',
      container: '#app-container',
      onError: jest.fn()
    };
    
    render(<MicroApp {...props} />);
    
    // 模拟错误事件
    fireEvent.error(screen.getByTestId('micro-app'));
    
    expect(props.onError).toHaveBeenCalledWith('test-app', expect.any(Error));
  });
});

// 示例：微前端框架单元测试
import { MicroFrontendFramework } from '../src/MicroFrontendFramework';

describe('MicroFrontendFramework', () => {
  let framework;
  
  beforeEach(() => {
    framework = new MicroFrontendFramework();
  });

  afterEach(() => {
    framework.destroy();
  });

  test('registers micro app correctly', () => {
    const appConfig = {
      name: 'test-app',
      entry: 'http://localhost:3001',
      container: '#app-container'
    };
    
    framework.registerApp(appConfig);
    
    expect(framework.getApp('test-app')).toEqual(appConfig);
  });

  test('loads micro app correctly', async () => {
    const appConfig = {
      name: 'test-app',
      entry: 'http://localhost:3001',
      container: '#app-container'
    };
    
    framework.registerApp(appConfig);
    
    // 模拟加载过程
    const loadPromise = framework.loadApp('test-app');
    
    // 验证应用状态
    expect(framework.getAppStatus('test-app')).toBe('LOADING');
    
    // 模拟加载完成
    await loadPromise;
    
    expect(framework.getAppStatus('test-app')).toBe('LOADED');
  });

  test('unloads micro app correctly', async () => {
    const appConfig = {
      name: 'test-app',
      entry: 'http://localhost:3001',
      container: '#app-container'
    };
    
    framework.registerApp(appConfig);
    await framework.loadApp('test-app');
    
    // 卸载应用
    await framework.unloadApp('test-app');
    
    expect(framework.getAppStatus('test-app')).toBe('UNLOADED');
  });
});
```

## 11.3 集成测试策略

### 11.3.1 微应用内部集成测试

微应用内部集成测试主要关注应用内部组件之间的交互：

1. **组件集成测试**：测试多个组件协同工作的场景
2. **状态管理集成测试**：测试状态管理器与组件的交互
3. **路由集成测试**：测试路由导航与组件渲染的集成
4. **API集成测试**：测试API调用与数据处理流程
5. **事件系统测试**：测试事件发布订阅机制

### 11.3.2 微应用间集成测试

微应用间集成测试主要关注不同微应用之间的交互：

1. **应用间通信测试**：测试应用间数据传递和事件通信
2. **共享状态测试**：测试跨应用状态共享机制
3. **路由导航测试**：测试跨应用路由导航场景
4. **依赖共享测试**：测试共享依赖的正确加载和使用
5. **样式隔离测试**：验证样式隔离机制的有效性

### 11.3.3 集成测试工具

常用的集成测试工具包括：

1. **Testing Library**：专注于用户行为的测试工具
2. **Enzyme**：React组件测试工具，支持浅渲染和完整渲染
3. **Cypress**：端到端测试工具，也可用于集成测试
4. **Playwright**：跨浏览器端到端测试工具
5. **TestCafe**：基于Node.js的端到端测试工具

### 11.3.4 集成测试示例

```javascript
// 示例：微应用内部集成测试
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import { App } from '../src/App';
import { store } from '../src/store';

// 模拟API
jest.mock('../src/api/userApi', () => ({
  getUserInfo: jest.fn(() => Promise.resolve({ id: 1, name: 'Test User' })),
  updateUserProfile: jest.fn(() => Promise.resolve({ success: true }))
}));

describe('App Integration Tests', () => {
  test('user login flow works correctly', async () => {
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    // 验证登录页面显示
    expect(screen.getByText(/登录/i)).toBeInTheDocument();
    
    // 输入用户名和密码
    fireEvent.change(screen.getByLabelText(/用户名/i), { target: { value: 'testuser' } });
    fireEvent.change(screen.getByLabelText(/密码/i), { target: { value: 'password' } });
    
    // 点击登录按钮
    fireEvent.click(screen.getByRole('button', { name: /登录/i }));
    
    // 等待登录完成
    await waitFor(() => {
      expect(screen.getByText(/欢迎, testuser/i)).toBeInTheDocument();
    });
  });

  test('navigation between components works correctly', async () => {
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    // 点击导航链接
    fireEvent.click(screen.getByText(/个人资料/i));
    
    // 验证页面导航
    await waitFor(() => {
      expect(screen.getByText(/编辑个人资料/i)).toBeInTheDocument();
    });
  });
});

// 示例：微应用间集成测试
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { MicroFrontendContainer } from '../src/MicroFrontendContainer';
import { EventBus } from '../src/EventBus';

// 模拟微应用
const mockApp1 = {
  name: 'app1',
  mount: jest.fn(),
  unmount: jest.fn(),
  update: jest.fn()
};

const mockApp2 = {
  name: 'app2',
  mount: jest.fn(),
  unmount: jest.fn(),
  update: jest.fn()
};

describe('MicroApp Integration Tests', () => {
  let container;
  let eventBus;
  
  beforeEach(() => {
    eventBus = new EventBus();
    container = new MicroFrontendContainer({ eventBus });
    
    // 注册微应用
    container.registerApp(mockApp1);
    container.registerApp(mockApp2);
  });
  
  afterEach(() => {
    container.destroy();
  });

  test('apps can communicate through event bus', async () => {
    // 加载应用
    await container.loadApp('app1');
    await container.loadApp('app2');
    
    // 模拟应用1发送事件
    const eventData = { type: 'USER_UPDATED', payload: { id: 1, name: 'Updated User' } };
    eventBus.emit('app1', eventData);
    
    // 验证应用2接收到事件
    await waitFor(() => {
      expect(mockApp2.update).toHaveBeenCalledWith(eventData);
    });
  });

  test('shared state works correctly across apps', async () => {
    // 创建共享状态
    const sharedState = container.createSharedState('user', { id: 1, name: 'Test User' });
    
    // 加载应用
    await container.loadApp('app1');
    await container.loadApp('app2');
    
    // 应用1更新共享状态
    sharedState.update({ name: 'Updated User' });
    
    // 验证应用2接收到状态更新
    await waitFor(() => {
      expect(mockApp2.update).toHaveBeenCalledWith({
        type: 'STATE_CHANGED',
        payload: { key: 'user', value: { id: 1, name: 'Updated User' } }
      });
    });
  });

  test('routing between apps works correctly', async () => {
    // 设置路由
    container.registerRoute('/app1', 'app1');
    container.registerRoute('/app2', 'app2');
    
    // 导航到app1
    await container.navigate('/app1');
    
    // 验证app1被加载
    expect(mockApp1.mount).toHaveBeenCalled();
    expect(mockApp2.mount).not.toHaveBeenCalled();
    
    // 导航到app2
    await container.navigate('/app2');
    
    // 验证app1被卸载，app2被加载
    expect(mockApp1.unmount).toHaveBeenCalled();
    expect(mockApp2.mount).toHaveBeenCalled();
  });
});
```

## 11.4 端到端测试策略

### 11.4.1 微前端端到端测试概述

微前端端到端测试主要关注完整的用户流程，可能跨越多个微应用：

1. **跨应用业务流程测试**：测试跨越多个微应用的完整业务流程
2. **用户导航测试**：测试用户在不同微应用间的导航体验
3. **数据一致性测试**：测试跨应用数据的一致性和同步
4. **性能体验测试**：测试应用加载、切换等场景的性能表现
5. **错误处理测试**：测试错误场景下的系统行为和用户体验

### 11.4.2 端到端测试工具

常用的端到端测试工具包括：

1. **Cypress**：功能强大的端到端测试框架，提供优秀的调试体验
2. **Playwright**：微软开发的跨浏览器端到端测试工具
3. **Selenium**：老牌的浏览器自动化测试工具
4. **TestCafe**：基于Node.js的端到端测试工具，无需WebDriver
5. **Puppeteer**：Google开发的Node.js库，提供高级API来控制Chrome

### 11.4.3 Cypress测试示例

```javascript
// cypress/integration/micro-frontend.spec.js
describe('Micro Frontend E2E Tests', () => {
  beforeEach(() => {
    // 访问主应用
    cy.visit('/');
  });

  it('should load main application correctly', () => {
    // 验证主应用加载
    cy.get('[data-testid="main-app"]').should('be.visible');
    cy.contains('欢迎来到微前端应用').should('be.visible');
  });

  it('should navigate between micro applications', () => {
    // 点击导航到用户管理应用
    cy.get('[data-testid="nav-user-management"]').click();
    
    // 验证URL变化
    cy.url().should('include', '/user-management');
    
    // 验证用户管理应用加载
    cy.get('[data-testid="user-management-app"]').should('be.visible');
    cy.contains('用户管理').should('be.visible');
    
    // 点击导航到产品管理应用
    cy.get('[data-testid="nav-product-management"]').click();
    
    // 验证URL变化
    cy.url().should('include', '/product-management');
    
    // 验证产品管理应用加载
    cy.get('[data-testid="product-management-app"]').should('be.visible');
    cy.contains('产品管理').should('be.visible');
  });

  it('should share data between micro applications', () => {
    // 导航到用户管理应用
    cy.get('[data-testid="nav-user-management"]').click();
    
    // 选择用户
    cy.get('[data-testid="user-list"]').find('[data-testid="user-item"]').first().click();
    
    // 获取选中的用户名
    cy.get('[data-testid="selected-user-name"]').invoke('text').then((userName) => {
      // 导航到订单管理应用
      cy.get('[data-testid="nav-order-management"]').click();
      
      // 验证用户信息已共享
      cy.get('[data-testid="current-user"]').should('contain', userName);
      
      // 创建订单
      cy.get('[data-testid="create-order-btn"]').click();
      
      // 验证订单创建成功，且关联了正确的用户
      cy.get('[data-testid="order-success-message"]').should('be.visible');
      cy.get('[data-testid="order-user"]').should('contain', userName);
    });
  });

  it('should handle errors gracefully', () => {
    // 模拟网络错误
    cy.intercept('GET', '/api/user-management/users', { forceNetworkError: true });
    
    // 导航到用户管理应用
    cy.get('[data-testid="nav-user-management"]').click();
    
    // 验证错误处理
    cy.get('[data-testid="error-message"]').should('be.visible');
    cy.contains('加载用户列表失败').should('be.visible');
    
    // 验证重试按钮
    cy.get('[data-testid="retry-btn"]').should('be.visible');
    
    // 恢复网络并重试
    cy.intercept('GET', '/api/user-management/users', { fixture: 'users.json' });
    cy.get('[data-testid="retry-btn"]').click();
    
    // 验证数据加载成功
    cy.get('[data-testid="user-list"]').should('be.visible');
  });

  it('should maintain performance standards', () => {
    // 监控性能指标
    cy.window().then((win) => {
      const performanceObserver = new win.PerformanceObserver((list) => {
        const entries = list.getEntries();
        const navigationEntry = entries.find(entry => entry.entryType === 'navigation');
        
        if (navigationEntry) {
          // 验证页面加载时间
          expect(navigationEntry.loadEventEnd - navigationEntry.loadEventStart).to.be.lessThan(1000);
        }
      });
      
      performanceObserver.observe({ entryTypes: ['navigation'] });
    });
    
    // 导航到各个应用并验证性能
    cy.get('[data-testid="nav-user-management"]').click();
    cy.get('[data-testid="user-management-app"]').should('be.visible');
    
    cy.get('[data-testid="nav-product-management"]').click();
    cy.get('[data-testid="product-management-app"]').should('be.visible');
    
    cy.get('[data-testid="nav-order-management"]').click();
    cy.get('[data-testid="order-management-app"]').should('be.visible');
  });
});
```

### 11.4.4 Playwright测试示例

```javascript
// tests/e2e/micro-frontend.spec.js
const { test, expect } = require('@playwright/test');

test.describe('Micro Frontend E2E Tests', () => {
  test.beforeEach(async ({ page }) => {
    // 访问主应用
    await page.goto('/');
  });

  test('should load main application correctly', async ({ page }) => {
    // 验证主应用加载
    await expect(page.locator('[data-testid="main-app"]')).toBeVisible();
    await expect(page.locator('text=欢迎来到微前端应用')).toBeVisible();
  });

  test('should navigate between micro applications', async ({ page }) => {
    // 点击导航到用户管理应用
    await page.click('[data-testid="nav-user-management"]');
    
    // 验证URL变化
    await expect(page).toHaveURL(/.*\/user-management/);
    
    // 验证用户管理应用加载
    await expect(page.locator('[data-testid="user-management-app"]')).toBeVisible();
    await expect(page.locator('text=用户管理')).toBeVisible();
    
    // 点击导航到产品管理应用
    await page.click('[data-testid="nav-product-management"]');
    
    // 验证URL变化
    await expect(page).toHaveURL(/.*\/product-management/);
    
    // 验证产品管理应用加载
    await expect(page.locator('[data-testid="product-management-app"]')).toBeVisible();
    await expect(page.locator('text=产品管理')).toBeVisible();
  });

  test('should share data between micro applications', async ({ page }) => {
    // 导航到用户管理应用
    await page.click('[data-testid="nav-user-management"]');
    
    // 选择用户
    await page.locator('[data-testid="user-list"]').locator('[data-testid="user-item"]').first().click();
    
    // 获取选中的用户名
    const userName = await page.locator('[data-testid="selected-user-name"]').textContent();
    
    // 导航到订单管理应用
    await page.click('[data-testid="nav-order-management"]');
    
    // 验证用户信息已共享
    await expect(page.locator('[data-testid="current-user"]')).toContainText(userName);
    
    // 创建订单
    await page.click('[data-testid="create-order-btn"]');
    
    // 验证订单创建成功，且关联了正确的用户
    await expect(page.locator('[data-testid="order-success-message"]')).toBeVisible();
    await expect(page.locator('[data-testid="order-user"]')).toContainText(userName);
  });

  test('should handle errors gracefully', async ({ page }) => {
    // 模拟网络错误
    await page.route('**/api/user-management/users', route => route.abort());
    
    // 导航到用户管理应用
    await page.click('[data-testid="nav-user-management"]');
    
    // 验证错误处理
    await expect(page.locator('[data-testid="error-message"]')).toBeVisible();
    await expect(page.locator('text=加载用户列表失败')).toBeVisible();
    
    // 验证重试按钮
    await expect(page.locator('[data-testid="retry-btn"]')).toBeVisible();
    
    // 恢复网络并重试
    await page.unroute('**/api/user-management/users');
    await page.route('**/api/user-management/users', route => route.fulfill({
      status: 200,
      body: JSON.stringify([{ id: 1, name: 'Test User' }])
    }));
    
    await page.click('[data-testid="retry-btn"]');
    
    // 验证数据加载成功
    await expect(page.locator('[data-testid="user-list"]')).toBeVisible();
  });

  test('should maintain performance standards', async ({ page }) => {
    // 监控性能指标
    await page.evaluate(() => {
      return new Promise(resolve => {
        const performanceObserver = new PerformanceObserver((list) => {
          const entries = list.getEntries();
          const navigationEntry = entries.find(entry => entry.entryType === 'navigation');
          
          if (navigationEntry) {
            // 验证页面加载时间
            const loadTime = navigationEntry.loadEventEnd - navigationEntry.loadEventStart;
            console.log(`Page load time: ${loadTime}ms`);
            resolve(loadTime);
          }
        });
        
        performanceObserver.observe({ entryTypes: ['navigation'] });
      });
    }).then(loadTime => {
      // 验证加载时间小于1秒
      expect(loadTime).toBeLessThan(1000);
    });
    
    // 导航到各个应用并验证性能
    await page.click('[data-testid="nav-user-management"]');
    await expect(page.locator('[data-testid="user-management-app"]')).toBeVisible();
    
    await page.click('[data-testid="nav-product-management"]');
    await expect(page.locator('[data-testid="product-management-app"]')).toBeVisible();
    
    await page.click('[data-testid="nav-order-management"]');
    await expect(page.locator('[data-testid="order-management-app"]')).toBeVisible();
  });
});
```

## 11.5 性能测试策略

### 11.5.1 加载性能测试

```javascript
// 示例：加载性能测试
import { performance } from 'perf_hooks';

describe('Loading Performance Tests', () => {
  test('应该测量微应用加载时间', async () => {
    const startTime = performance.now();
    
    // 加载微应用
    await loadMicroApp('app1');
    
    const endTime = performance.now();
    const loadTime = endTime - startTime;
    
    // 验证加载时间在可接受范围内
    expect(loadTime).toBeLessThan(3000); // 3秒
  });

  test('应该测量多个微应用并发加载时间', async () => {
    const startTime = performance.now();
    
    // 并发加载多个微应用
    await Promise.all([
      loadMicroApp('app1'),
      loadMicroApp('app2'),
      loadMicroApp('app3'),
    ]);
    
    const endTime = performance.now();
    const loadTime = endTime - startTime;
    
    // 验证并发加载时间在可接受范围内
    expect(loadTime).toBeLessThan(5000); // 5秒
  });

  test('应该测量微应用资源大小', async () => {
    // 加载微应用
    await loadMicroApp('app1');
    
    // 获取资源大小
    const resourceSize = await getResourceSize('app1');
    
    // 验证资源大小在合理范围内
    expect(resourceSize).toBeLessThan(1024 * 1024); // 1MB
  });
});
```

### 11.5.2 运行时性能测试

```javascript
// 示例：运行时性能测试
describe('Runtime Performance Tests', () => {
  test('应该测量微应用渲染性能', async () => {
    // 加载微应用
    await loadMicroApp('app1');
    
    // 测量渲染时间
    const renderTime = await measureRenderTime('app1');
    
    // 验证渲染时间在可接受范围内
    expect(renderTime).toBeLessThan(100); // 100ms
  });

  test('应该测量微应用内存使用', async () => {
    // 加载微应用
    await loadMicroApp('app1');
    
    // 测量内存使用
    const memoryUsage = await measureMemoryUsage('app1');
    
    // 验证内存使用在合理范围内
    expect(memoryUsage).toBeLessThan(50 * 1024 * 1024); // 50MB
  });

  test('应该测量微应用CPU使用', async () => {
    // 加载微应用
    await loadMicroApp('app1');
    
    // 执行一些操作
    await performOperations('app1');
    
    // 测量CPU使用
    const cpuUsage = await measureCpuUsage('app1');
    
    // 验证CPU使用在合理范围内
    expect(cpuUsage).toBeLessThan(80); // 80%
  });
});
```

## 11.6 视觉回归测试

### 11.6.1 视觉回归测试策略

```javascript
// 示例：视觉回归测试
import { createImageDiff } from 'image-diff';
import { takeScreenshot } from './utils';

describe('Visual Regression Tests', () => {
  test('应该正确渲染主应用界面', async () => {
    // 加载主应用
    await loadMainApp();
    
    // 截取当前屏幕
    const currentScreenshot = await takeScreenshot();
    
    // 与基准图像比较
    const diff = await createImageDiff({
      actualImage: currentScreenshot,
      expectedImage: 'screenshots/main-app-baseline.png',
    });
    
    // 验证差异在可接受范围内
    expect(diff.percentage).toBeLessThan(0.01); // 1%
  });

  test('应该正确渲染微应用界面', async () => {
    // 加载微应用
    await loadMicroApp('app1');
    
    // 截取当前屏幕
    const currentScreenshot = await takeScreenshot();
    
    // 与基准图像比较
    const diff = await createImageDiff({
      actualImage: currentScreenshot,
      expectedImage: 'screenshots/app1-baseline.png',
    });
    
    // 验证差异在可接受范围内
    expect(diff.percentage).toBeLessThan(0.01); // 1%
  });
});
```

### 11.6.2 响应式设计测试

```javascript
// 示例：响应式设计测试
describe('Responsive Design Tests', () => {
  const viewports = [
    { width: 320, height: 568, name: 'Mobile' },
    { width: 768, height: 1024, name: 'Tablet' },
    { width: 1920, height: 1080, name: 'Desktop' },
  ];

  viewports.forEach(viewport => {
    test(`应该在${viewport.name}视口正确显示`, async () => {
      // 设置视口大小
      await setViewport(viewport.width, viewport.height);
      
      // 加载应用
      await loadMainApp();
      
      // 截取当前屏幕
      const currentScreenshot = await takeScreenshot();
      
      // 与基准图像比较
      const diff = await createImageDiff({
        actualImage: currentScreenshot,
        expectedImage: `screenshots/main-app-${viewport.name.toLowerCase()}-baseline.png`,
      });
      
      // 验证差异在可接受范围内
      expect(diff.percentage).toBeLessThan(0.01); // 1%
    });
  });
});
```

## 11.7 测试自动化与CI/CD集成

### 11.7.1 测试自动化配置

```yaml
# 示例：GitHub Actions测试配置
name: Micro Frontend Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    
    - name: Setup Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '16'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run unit tests
      run: npm run test:unit
      
    - name: Upload coverage reports
      uses: codecov/codecov-action@v1

  integration-tests:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    
    - name: Setup Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '16'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Start test environment
      run: npm run test:start
      
    - name: Run integration tests
      run: npm run test:integration
      
    - name: Stop test environment
      run: npm run test:stop

  e2e-tests:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    
    - name: Setup Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '16'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Start test environment
      run: npm run test:start
      
    - name: Run E2E tests
      run: npm run test:e2e
      
    - name: Stop test environment
      run: npm run test:stop
      
    - name: Upload screenshots
      uses: actions/upload-artifact@v2
      if: failure()
      with:
        name: screenshots
        path: cypress/screenshots
```

### 11.7.2 测试报告生成

```javascript
// 示例：测试报告生成
const { multiple } = require('cypress-multiple-reporters');
const { mochaawesome } = require('cypress-mocha-awesome-reporter');

module.exports = {
  reporter: 'cypress-multiple-reporters',
  reporterOptions: {
    reporterEnabled: 'mochaawesome',
    mochaawesomeReporterOptions: {
      reportDir: 'cypress/results',
      overwrite: false,
      html: false,
      json: true,
    },
  },
  video: true,
  screenshotOnRunFailure: true,
  viewportWidth: 1920,
  viewportHeight: 1080,
};
```

## 11.8 测试最佳实践

### 11.8.1 测试策略选择

1. **测试金字塔原则**
   - 大量单元测试：快速反馈，低成本
   - 适量集成测试：验证组件协作
   - 少量端到端测试：验证关键业务流程

2. **测试优先级**
   - 核心功能优先测试
   - 用户高频使用路径优先测试
   - 跨应用交互优先测试

3. **测试环境管理**
   - 独立的测试环境
   - 一致的测试数据
   - 可重复的测试条件

### 11.8.2 测试数据管理

```javascript
// 示例：测试数据管理
class TestDataManager {
  constructor() {
    this.users = new Map();
    this.products = new Map();
    this.orders = new Map();
  }

  // 创建测试用户
  createUser(userData) {
    const id = `user_${Date.now()}`;
    const user = { id, ...userData };
    this.users.set(id, user);
    return user;
  }

  // 创建测试产品
  createProduct(productData) {
    const id = `product_${Date.now()}`;
    const product = { id, ...productData };
    this.products.set(id, product);
    return product;
  }

  // 创建测试订单
  createOrder(orderData) {
    const id = `order_${Date.now()}`;
    const order = { id, ...orderData };
    this.orders.set(id, order);
    return order;
  }

  // 清理所有测试数据
  cleanup() {
    this.users.clear();
    this.products.clear();
    this.orders.clear();
  }
}

// 导出单例
export const testDataManager = new TestDataManager();
```

### 11.8.3 测试工具选择

1. **单元测试工具**
   - Jest：功能全面，生态丰富
   - Vitest：快速，现代化
   - Mocha：灵活，可定制

2. **集成测试工具**
   - Testing Library：用户行为导向
   - Enzyme：组件内部状态测试
   - React Testing Library：React专用

3. **端到端测试工具**
   - Cypress：功能强大，调试友好
   - Playwright：跨浏览器支持
   - Puppeteer：轻量级，API丰富

4. **性能测试工具**
   - Lighthouse：Web性能审计
   - WebPageTest：在线性能测试
   - GTmetrix：性能分析与建议

## 11.9 总结

微前端测试策略需要综合考虑架构特点和测试挑战，采用多层次、多维度的测试方法：

1. **全面的测试覆盖**：从单元测试到端到端测试，确保各个层面的质量
2. **自动化测试流程**：集成到CI/CD流程中，实现持续测试和反馈
3. **性能与视觉测试**：关注用户体验，确保应用性能和界面一致性
4. **跨团队协作**：建立统一的测试标准和规范，促进团队协作

通过合理的测试策略和工具选择，可以有效保证微前端应用的质量和稳定性，提升开发效率和用户体验。

## 11.10 示例代码

### 11.10.1 代码结构

```
frontend/micro-frontend/code/chapter11/
├── testing-strategy/
│   ├── unit-tests/
│   │   ├── components/
│   │   │   ├── MicroFrontendComponent.test.js
│   │   │   └── MicroApp.test.js
│   │   └── utils/
│   │       └── testDataManager.js
│   ├── integration-tests/
│   │   ├── app-integration.test.js
│   │   └── router-integration.test.js
│   ├── e2e-tests/
│   │   ├── cypress/
│   │   │   ├── integration/
│   │   │   │   ├── micro-app.spec.js
│   │   │   │   └── navigation.spec.js
│   │   │   └── support/
│   │   │       └── commands.js
│   │   └── playwright/
│   │       └── micro-app.spec.js
│   ├── performance-tests/
│   │   ├── loading-performance.test.js
│   │   └── runtime-performance.test.js
│   ├── visual-tests/
│   │   ├── visual-regression.test.js
│   │   └── responsive-design.test.js
│   └── ci-cd/
│       ├── .github/
│       │   └── workflows/
│       │       └── test.yml
│       └── cypress.json
└── README.md
```

### 11.10.2 运行说明

1. 安装依赖：
```bash
npm install
```

2. 运行单元测试：
```bash
npm run test:unit
```

3. 运行集成测试：
```bash
npm run test:integration
```

4. 运行端到端测试：
```bash
npm run test:e2e
```

5. 运行性能测试：
```bash
npm run test:performance
```

6. 运行视觉回归测试：
```bash
npm run test:visual
```

7. 运行所有测试：
```bash
npm run test:all
```

### 11.10.3 功能演示

1. 单元测试演示：
   - 组件渲染测试
   - 生命周期测试
   - 事件处理测试

2. 集成测试演示：
   - 应用间通信测试
   - 路由集成测试
   - 状态共享测试

3. 端到端测试演示：
   - 用户流程测试
   - 跨应用导航测试
   - 数据流测试

4. 性能测试演示：
   - 加载性能测试
   - 运行时性能测试
   - 资源使用测试

5. 视觉回归测试演示：
   - UI一致性测试
   - 响应式设计测试
   - 样式隔离测试