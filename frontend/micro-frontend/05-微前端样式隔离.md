# 第五章：微前端样式隔离

## 5.1 样式隔离概述

### 5.1.1 样式隔离的必要性

在微前端架构中，样式隔离是一个关键挑战。由于多个微应用可能同时运行在同一个页面中，它们的样式可能会相互干扰，导致以下问题：

1. **样式冲突**：不同应用的CSS选择器可能匹配到相同的DOM元素，导致样式覆盖
2. **全局污染**：全局样式可能影响其他应用的外观
3. **样式优先级问题**：不同应用的样式优先级可能不一致，导致显示异常
4. **第三方库冲突**：不同应用可能使用不同版本的UI库，导致样式不一致
5. **主题一致性**：不同应用可能需要保持一致的主题风格

### 5.1.2 样式隔离方案分类

根据实现原理，微前端样式隔离方案可以分为以下几类：

#### 按隔离范围分类
- **完全隔离**：每个微应用的样式完全独立，互不影响
- **部分隔离**：只隔离特定样式，共享通用样式
- **无隔离**：不进行样式隔离，依赖开发规范

#### 按实现时机分类
- **编译时隔离**：在构建阶段处理样式隔离
- **运行时隔离**：在应用运行时动态处理样式隔离
- **混合隔离**：结合编译时和运行时的隔离方案

#### 按技术实现分类
- **CSS作用域**：通过CSS作用域限制样式影响范围
- **Shadow DOM**：使用Web Components的Shadow DOM技术
- **样式命名空间**：通过命名约定避免样式冲突
- **动态加载**：动态加载和卸载样式

## 5.2 CSS作用域隔离

### 5.2.1 CSS Modules原理

CSS Modules是一种CSS模块化方案，通过自动生成唯一的类名来实现样式隔离。其原理是：

1. **唯一类名生成**：为每个CSS类生成唯一的标识符
2. **局部作用域**：样式只应用于对应的组件
3. **依赖管理**：明确样式与组件的依赖关系

```javascript
// CSS Modules示例
// styles.module.css
.container {
  display: flex;
  flex-direction: column;
  padding: 16px;
  background-color: #f5f5f5;
}

.title {
  font-size: 24px;
  font-weight: bold;
  color: #333;
  margin-bottom: 16px;
}

.button {
  padding: 8px 16px;
  background-color: #1890ff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.button:hover {
  background-color: #40a9ff;
}

// 在组件中使用
import React from 'react';
import styles from './styles.module.css';

function MyComponent() {
  return (
    <div className={styles.container}>
      <h1 className={styles.title}>标题</h1>
      <button className={styles.button}>按钮</button>
    </div>
  );
}

export default MyComponent;
```

### 5.2.2 CSS Modules在微前端中的应用

在微前端环境中，可以通过CSS Modules实现样式隔离：

```javascript
// 微前端CSS Modules配置
// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        exclude: /node_modules/,
        use: [
          'style-loader',
          {
            loader: 'css-loader',
            options: {
              modules: {
                localIdentName: '[name]__[local]___[hash:base64:5]',
              },
            },
          },
        ],
      },
      {
        test: /\.css$/,
        include: /node_modules/,
        use: ['style-loader', 'css-loader'],
      },
    ],
  },
};

// 微前端应用基类
import React from 'react';
import { loadMicroApp } from 'qiankun';

class MicroApp extends React.Component {
  containerRef = React.createRef();
  
  componentDidMount() {
    const { name, entry, ...props } = this.props;
    
    // 加载微应用
    this.microApp = loadMicroApp({
      name,
      entry,
      container: this.containerRef.current,
      props,
    });
  }
  
  componentWillUnmount() {
    // 卸载微应用
    if (this.microApp) {
      this.microApp.unmount();
    }
  }
  
  render() {
    return <div ref={this.containerRef} className="micro-app-container" />;
  }
}

export default MicroApp;
```

### 5.2.3 CSS-in-JS方案

CSS-in-JS是一种将CSS直接写在JavaScript代码中的方案，可以实现更灵活的样式隔离：

```javascript
// styled-components示例
import React from 'react';
import styled, { ThemeProvider, createGlobalStyle } from 'styled-components';

// 全局样式
const GlobalStyle = createGlobalStyle`
  body {
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
      'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
      sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
`;

// 主题
const theme = {
  colors: {
    primary: '#1890ff',
    secondary: '#52c41a',
    background: '#f5f5f5',
    text: '#333',
  },
  spacing: {
    small: '8px',
    medium: '16px',
    large: '24px',
  },
};

// 样式组件
const Container = styled.div`
  display: flex;
  flex-direction: column;
  padding: ${props => props.theme.spacing.medium};
  background-color: ${props => props.theme.colors.background};
`;

const Title = styled.h1`
  font-size: 24px;
  font-weight: bold;
  color: ${props => props.theme.colors.text};
  margin-bottom: ${props => props.theme.spacing.medium};
`;

const Button = styled.button`
  padding: ${props => props.theme.spacing.small} ${props => props.theme.spacing.medium};
  background-color: ${props => props.theme.colors.primary};
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  
  &:hover {
    background-color: #40a9ff;
  }
`;

// 微前端应用组件
function MicroApp() {
  return (
    <ThemeProvider theme={theme}>
      <Container>
        <GlobalStyle />
        <Title>微前端应用</Title>
        <Button>按钮</Button>
      </Container>
    </ThemeProvider>
  );
}

export default MicroApp;
```

### 5.2.4 CSS作用域隔离工具

```javascript
// CSS作用域隔离工具
class CSSScope {
  constructor(prefix) {
    this.prefix = prefix;
    this.styleElement = null;
    this.originalCSS = '';
    this.scopedCSS = '';
  }
  
  // 加载CSS并添加作用域
  loadCSS(cssText) {
    this.originalCSS = cssText;
    this.scopedCSS = this.addScope(cssText);
    
    // 创建style元素
    this.styleElement = document.createElement('style');
    this.styleElement.textContent = this.scopedCSS;
    this.styleElement.setAttribute('data-scope', this.prefix);
    
    // 添加到head
    document.head.appendChild(this.styleElement);
  }
  
  // 添加作用域前缀
  addScope(cssText) {
    // 简单的CSS解析，实际应用中可以使用更完善的CSS解析器
    return cssText.replace(/([^\r\n,{}]+)(,(?=[^}]*{)|\s*{)/g, (match, selector, delimiter) => {
      // 跳过@开头的规则
      if (selector.trim().startsWith('@')) {
        return match;
      }
      
      // 跳过:global选择器
      if (selector.includes(':global')) {
        return match;
      }
      
      // 添加作用域前缀
      const scopedSelector = selector
        .split(',')
        .map(s => {
          s = s.trim();
          // 跳过body、html等全局选择器
          if (s === 'body' || s === 'html' || s.startsWith(':')) {
            return s;
          }
          return `.${this.prefix} ${s}`;
        })
        .join(', ');
      
      return scopedSelector + delimiter;
    });
  }
  
  // 卸载CSS
  unloadCSS() {
    if (this.styleElement && this.styleElement.parentNode) {
      this.styleElement.parentNode.removeChild(this.styleElement);
      this.styleElement = null;
    }
  }
  
  // 更新CSS
  updateCSS(cssText) {
    this.unloadCSS();
    this.loadCSS(cssText);
  }
}

// 微前端样式管理器
class MicroFrontendStyleManager {
  constructor() {
    this.scopes = new Map();
  }
  
  // 注册微应用样式
  register(appName, cssText) {
    if (this.scopes.has(appName)) {
      this.scopes.get(appName).updateCSS(cssText);
    } else {
      const scope = new CSSScope(`mf-${appName}`);
      scope.loadCSS(cssText);
      this.scopes.set(appName, scope);
    }
  }
  
  // 卸载微应用样式
  unregister(appName) {
    if (this.scopes.has(appName)) {
      this.scopes.get(appName).unloadCSS();
      this.scopes.delete(appName);
    }
  }
  
  // 清空所有样式
  clear() {
    this.scopes.forEach(scope => {
      scope.unloadCSS();
    });
    this.scopes.clear();
  }
}

// 创建全局样式管理器
const styleManager = new MicroFrontendStyleManager();

// 导出样式管理器
export default styleManager;
```

## 5.3 Shadow DOM隔离

### 5.3.1 Shadow DOM原理

Shadow DOM是Web Components的一部分，它提供了一种封装DOM和样式的方法。其原理是：

1. **DOM封装**：创建一个与主文档隔离的DOM树
2. **样式隔离**：Shadow DOM内的样式不会影响外部，外部样式也不会影响内部
3. **事件重定向**：事件从Shadow DOM内部冒泡到外部时会被重定向

```javascript
// Shadow DOM示例
class ShadowComponent extends HTMLElement {
  constructor() {
    super();
    
    // 创建Shadow DOM
    this.attachShadow({ mode: 'open' });
  }
  
  connectedCallback() {
    // 添加样式
    const style = document.createElement('style');
    style.textContent = `
      :host {
        display: block;
        padding: 16px;
        background-color: #f5f5f5;
        border: 1px solid #ddd;
        border-radius: 4px;
      }
      
      .title {
        font-size: 24px;
        font-weight: bold;
        color: #333;
        margin-bottom: 16px;
      }
      
      .button {
        padding: 8px 16px;
        background-color: #1890ff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      
      .button:hover {
        background-color: #40a9ff;
      }
    `;
    
    // 添加内容
    const container = document.createElement('div');
    container.innerHTML = `
      <h1 class="title">Shadow DOM组件</h1>
      <button class="button">按钮</button>
    `;
    
    // 添加到Shadow DOM
    this.shadowRoot.appendChild(style);
    this.shadowRoot.appendChild(container);
    
    // 添加事件监听
    const button = this.shadowRoot.querySelector('.button');
    button.addEventListener('click', () => {
      alert('按钮被点击');
    });
  }
}

// 注册自定义元素
customElements.define('shadow-component', ShadowComponent);
```

### 5.3.2 微前端中的Shadow DOM应用

在微前端环境中，可以使用Shadow DOM实现完全的样式隔离：

```javascript
// 基于Shadow DOM的微前端容器
class ShadowMicroAppContainer {
  constructor(options = {}) {
    this.options = {
      mode: 'open', // 'open' 或 'closed'
      delegatesFocus: true,
      ...options
    };
    
    this.container = null;
    this.shadowRoot = null;
    this.app = null;
  }
  
  // 创建容器
  createContainer(hostElement) {
    this.container = hostElement;
    
    // 创建Shadow DOM
    this.shadowRoot = this.container.attachShadow({
      mode: this.options.mode,
      delegatesFocus: this.options.delegatesFocus
    });
    
    // 添加基础样式
    this.addBaseStyles();
    
    return this.shadowRoot;
  }
  
  // 添加基础样式
  addBaseStyles() {
    const style = document.createElement('style');
    style.textContent = `
      :host {
        display: block;
        width: 100%;
        height: 100%;
      }
      
      *, *::before, *::after {
        box-sizing: border-box;
      }
      
      body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
          'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
          sans-serif;
      }
    `;
    
    this.shadowRoot.appendChild(style);
  }
  
  // 加载微应用
  async loadApp(appConfig) {
    const { name, entry, container } = appConfig;
    
    // 创建应用容器
    const appContainer = document.createElement('div');
    appContainer.id = `micro-app-${name}`;
    this.shadowRoot.appendChild(appContainer);
    
    // 加载应用HTML
    try {
      const response = await fetch(entry);
      const html = await response.text();
      
      // 创建临时容器解析HTML
      const tempContainer = document.createElement('div');
      tempContainer.innerHTML = html;
      
      // 提取样式
      const styles = tempContainer.querySelectorAll('style, link[rel="stylesheet"]');
      styles.forEach(styleElement => {
        if (styleElement.tagName === 'STYLE') {
          // 直接添加内联样式
          this.shadowRoot.appendChild(styleElement.cloneNode(true));
        } else if (styleElement.tagName === 'LINK') {
          // 加载外部样式
          this.loadExternalStyle(styleElement.href);
        }
      });
      
      // 提取脚本
      const scripts = tempContainer.querySelectorAll('script');
      const scriptContents = [];
      
      scripts.forEach(script => {
        if (script.src) {
          // 外部脚本
          scriptContents.push(`loadScript('${script.src}')`);
        } else {
          // 内联脚本
          scriptContents.push(script.textContent);
        }
      });
      
      // 提取内容
      const content = tempContainer.querySelector('body') || tempContainer;
      appContainer.innerHTML = content.innerHTML;
      
      // 执行脚本
      this.executeScripts(scriptContents);
      
      this.app = {
        name,
        container: appContainer,
        mount: () => {
          appContainer.style.display = 'block';
        },
        unmount: () => {
          appContainer.style.display = 'none';
        }
      };
      
      return this.app;
    } catch (error) {
      console.error(`加载微应用 ${name} 失败:`, error);
      throw error;
    }
  }
  
  // 加载外部样式
  loadExternalStyle(href) {
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = href;
    this.shadowRoot.appendChild(link);
  }
  
  // 执行脚本
  executeScripts(scriptContents) {
    // 创建沙箱环境
    const sandbox = this.createSandbox();
    
    // 在沙箱中执行脚本
    scriptContents.forEach(script => {
      try {
        sandbox.execute(script);
      } catch (error) {
        console.error('执行脚本失败:', error);
      }
    });
  }
  
  // 创建沙箱环境
  createSandbox() {
    // 简单的沙箱实现，实际应用中可能需要更复杂的沙箱
    const sandbox = {
      window: {
        // 暴露必要的全局变量
        document: this.shadowRoot,
        console: window.console,
        setTimeout: window.setTimeout,
        setInterval: window.setInterval,
        clearTimeout: window.clearTimeout,
        clearInterval: window.clearInterval,
        fetch: window.fetch,
        // ... 其他必要的全局变量
      },
      
      execute(code) {
        // 使用Function构造函数创建隔离的执行环境
        const func = new Function(...Object.keys(this.window), code);
        func(...Object.values(this.window));
      }
    };
    
    return sandbox;
  }
  
  // 卸载应用
  unmountApp() {
    if (this.app) {
      this.app.unmount();
      this.app = null;
    }
    
    // 清空Shadow DOM
    if (this.shadowRoot) {
      this.shadowRoot.innerHTML = '';
      this.addBaseStyles();
    }
  }
}

// 微前端Shadow DOM管理器
class ShadowDOMManager {
  constructor() {
    this.containers = new Map();
  }
  
  // 注册微应用
  register(appName, hostElement, appConfig) {
    if (this.containers.has(appName)) {
      throw new Error(`微应用 ${appName} 已存在`);
    }
    
    const container = new ShadowMicroAppContainer();
    container.createContainer(hostElement);
    
    this.containers.set(appName, container);
    
    return container.loadApp({
      name: appName,
      ...appConfig
    });
  }
  
  // 卸载微应用
  unregister(appName) {
    if (this.containers.has(appName)) {
      const container = this.containers.get(appName);
      container.unmountApp();
      this.containers.delete(appName);
    }
  }
  
  // 获取微应用容器
  getContainer(appName) {
    return this.containers.get(appName);
  }
  
  // 清空所有微应用
  clear() {
    this.containers.forEach((container, appName) => {
      container.unmountApp();
    });
    this.containers.clear();
  }
}

// 创建全局Shadow DOM管理器
const shadowDOMManager = new ShadowDOMManager();

export default shadowDOMManager;
```

### 5.3.3 Shadow DOM样式穿透解决方案

虽然Shadow DOM提供了样式隔离，但有时需要从外部控制内部样式或从内部访问外部样式：

```javascript
// Shadow DOM样式穿透工具
class ShadowDOMStyleUtils {
  // 从外部设置Shadow DOM内部样式
  static setInternalStyle(shadowRoot, selector, styles) {
    const styleElement = document.createElement('style');
    let cssText = '';
    
    for (const property in styles) {
      cssText += `${property}: ${styles[property]}; `;
    }
    
    styleElement.textContent = `${selector} { ${cssText} }`;
    shadowRoot.appendChild(styleElement);
    
    return styleElement;
  }
  
  // 从外部获取Shadow DOM内部样式
  static getInternalStyle(shadowRoot, selector, property) {
    const element = shadowRoot.querySelector(selector);
    if (!element) {
      return null;
    }
    
    return getComputedStyle(element, null).getPropertyValue(property);
  }
  
  // 使用CSS变量实现主题穿透
  static setThemeVariables(shadowRoot, theme) {
    const hostElement = shadowRoot.host;
    
    for (const variable in theme) {
      hostElement.style.setProperty(`--${variable}`, theme[variable]);
    }
    
    // 在Shadow DOM内部添加使用CSS变量的样式
    const styleElement = document.createElement('style');
    styleElement.textContent = `
      :host {
        --primary-color: var(--primary-color, #1890ff);
        --secondary-color: var(--secondary-color, #52c41a);
        --background-color: var(--background-color, #f5f5f5);
        --text-color: var(--text-color, #333);
      }
      
      .button {
        background-color: var(--primary-color);
      }
      
      .secondary-button {
        background-color: var(--secondary-color);
      }
      
      .container {
        background-color: var(--background-color);
        color: var(--text-color);
      }
    `;
    
    shadowRoot.appendChild(styleElement);
  }
  
  // 使用::part伪元素实现样式穿透
  static enableStyleParts(shadowRoot) {
    // 在Shadow DOM内部为需要暴露的元素添加part属性
    const elements = shadowRoot.querySelectorAll('[data-part]');
    
    elements.forEach(element => {
      const partName = element.getAttribute('data-part');
      element.setAttribute('part', partName);
    });
    
    // 返回外部可以使用的CSS选择器示例
    return `
      /* 外部可以这样设置样式 */
      shadow-element::part(button) {
        background-color: red;
      }
      
      shadow-element::part(title) {
        color: blue;
      }
    `;
  }
  
  // 使用::theme伪元素实现主题穿透
  static enableThemePseudo(shadowRoot) {
    // 在Shadow DOM内部添加使用::theme的样式
    const styleElement = document.createElement('style');
    styleElement.textContent = `
      .button {
        background-color: ::theme(button-bg, #1890ff);
        color: ::theme(button-color, white);
      }
      
      .title {
        color: ::theme(title-color, #333);
      }
    `;
    
    shadowRoot.appendChild(styleElement);
  }
}

// 使用示例
const shadowElement = document.querySelector('shadow-component');
const shadowRoot = shadowElement.shadowRoot;

// 设置内部样式
ShadowDOMStyleUtils.setInternalStyle(shadowRoot, '.button', {
  'background-color': 'red',
  'color': 'white'
});

// 设置主题变量
ShadowDOMStyleUtils.setThemeVariables(shadowRoot, {
  'primary-color': '#1890ff',
  'secondary-color': '#52c41a',
  'background-color': '#f5f5f5',
  'text-color': '#333'
});
```

## 5.4 样式命名空间隔离

### 5.4.1 命名约定方案

通过制定严格的命名约定，可以避免样式冲突：

```javascript
// 样式命名约定工具
class StyleNamespace {
  constructor(prefix) {
    this.prefix = prefix;
  }
  
  // 生成带命名空间的类名
  className(name) {
    return `${this.prefix}-${name}`;
  }
  
  // 生成带命名空间的ID
  id(name) {
    return `${this.prefix}-${name}`;
  }
  
  // 生成带命名空间的数据属性
  dataAttr(name) {
    return `data-${this.prefix}-${name}`;
  }
  
  // 生成带命名空间的选择器
  selector(name) {
    return `.${this.className(name)}`;
  }
  
  // 生成带命名空间的CSS规则
  cssRule(selector, styles) {
    const namespacedSelector = selector.replace(/(\.[a-zA-Z][a-zA-Z0-9_-]*)/g, (match) => {
      // 跳过已经命名空间的类名
      if (match.startsWith(`.${this.prefix}-`)) {
        return match;
      }
      
      // 跳过全局类名
      if (match.startsWith('.global-')) {
        return match;
      }
      
      // 添加命名空间
      return `.${this.prefix}-${match.substring(1)}`;
    });
    
    return `${namespacedSelector} { ${this.stylesToString(styles)} }`;
  }
  
  // 将样式对象转换为字符串
  stylesToString(styles) {
    return Object.entries(styles)
      .map(([property, value]) => {
        // 转换驼峰命名为连字符命名
        const cssProperty = property.replace(/([A-Z])/g, '-$1').toLowerCase();
        return `${cssProperty}: ${value};`;
      })
      .join(' ');
  }
  
  // 生成CSS文件内容
  generateCSS(cssRules) {
    return cssRules.map(rule => {
      if (typeof rule === 'string') {
        return rule;
      } else if (typeof rule === 'object' && rule.selector && rule.styles) {
        return this.cssRule(rule.selector, rule.styles);
      }
      return '';
    }).join('\n');
  }
}

// 微前端样式命名空间管理器
class MicroFrontendNamespaceManager {
  constructor() {
    this.namespaces = new Map();
  }
  
  // 创建命名空间
  createNamespace(appName) {
    if (this.namespaces.has(appName)) {
      return this.namespaces.get(appName);
    }
    
    const namespace = new StyleNamespace(`mf-${appName}`);
    this.namespaces.set(appName, namespace);
    
    return namespace;
  }
  
  // 获取命名空间
  getNamespace(appName) {
    return this.namespaces.get(appName);
  }
  
  // 删除命名空间
  removeNamespace(appName) {
    this.namespaces.delete(appName);
  }
}

// 创建全局命名空间管理器
const namespaceManager = new MicroFrontendNamespaceManager();

// 使用示例
const appNamespace = namespaceManager.createNamespace('dashboard');

// 生成类名
const containerClass = appNamespace.className('container'); // 'mf-dashboard-container'
const titleClass = appNamespace.className('title'); // 'mf-dashboard-title'

// 生成CSS规则
const buttonRule = appNamespace.cssRule('.button', {
  backgroundColor: '#1890ff',
  color: 'white',
  padding: '8px 16px'
});
// 输出: '.mf-dashboard-button { background-color: #1890ff; color: white; padding: 8px 16px; }'

// 生成CSS文件
const cssContent = appNamespace.generateCSS([
  { selector: '.container', styles: { padding: '16px' } },
  { selector: '.title', styles: { fontSize: '24px', fontWeight: 'bold' } },
  { selector: '.button', styles: { backgroundColor: '#1890ff', color: 'white' } }
]);
```

### 5.4.2 PostCSS命名空间插件

```javascript
// PostCSS命名空间插件
const postcss = require('postcss');

// 命名空间插件
const namespacePlugin = (options = {}) => {
  const {
    prefix = '',
    ignore = [],
    ignoreSelectors = [],
    transformClassName = true,
    transformId = true,
    transformDataAttr = true
  } = options;
  
  return {
    postcssPlugin: 'namespace',
    
    Once(root) {
      root.walkRules(rule => {
        // 检查是否应该忽略此规则
        if (shouldIgnoreRule(rule, ignore, ignoreSelectors)) {
          return;
        }
        
        // 转换选择器
        rule.selector = transformSelector(rule.selector, {
          prefix,
          transformClassName,
          transformId,
          transformDataAttr
        });
      });
      
      // 转换@keyframes
      root.walkAtRules(atRule => {
        if (atRule.name === 'keyframes') {
          if (transformClassName) {
            atRule.params = `${prefix}${atRule.params}`;
          }
        }
      });
    }
  };
};

// 检查是否应该忽略规则
function shouldIgnoreRule(rule, ignore, ignoreSelectors) {
  // 检查选择器是否在忽略列表中
  for (const ignoreSelector of ignoreSelectors) {
    if (rule.selector.includes(ignoreSelector)) {
      return true;
    }
  }
  
  // 检查文件路径是否在忽略列表中
  const source = rule.source && rule.source.input.file;
  if (source) {
    for (const ignorePattern of ignore) {
      if (source.includes(ignorePattern)) {
        return true;
      }
    }
  }
  
  return false;
}

// 转换选择器
function transformSelector(selector, options) {
  const { prefix, transformClassName, transformId, transformDataAttr } = options;
  
  return selector.replace(/([.#\[a-zA-Z][a-zA-Z0-9_-]*)/g, (match) => {
    // 跳过已经命名空间的选择器
    if (match.startsWith(`.${prefix}`) || match.startsWith(`#${prefix}`) || match.startsWith(`[data-${prefix}`)) {
      return match;
    }
    
    // 跳过全局选择器
    if (match.startsWith('.global-') || match.startsWith('#global-') || match.startsWith('[data-global-')) {
      return match;
    }
    
    // 跳过伪类和伪元素
    if (match.startsWith(':')) {
      return match;
    }
    
    // 转换类名
    if (match.startsWith('.') && transformClassName) {
      return `.${prefix}${match.substring(1)}`;
    }
    
    // 转换ID
    if (match.startsWith('#') && transformId) {
      return `#${prefix}${match.substring(1)}`;
    }
    
    // 转换数据属性
    if (match.startsWith('[data-') && transformDataAttr) {
      return match.replace('[data-', `[data-${prefix}`);
    }
    
    return match;
  });
}

// 注册插件
namespacePlugin.postcss = true;

module.exports = namespacePlugin;

// 使用示例
const postcssConfig = {
  plugins: [
    require('autoprefixer'),
    namespacePlugin({
      prefix: 'mf-app-',
      ignoreSelectors: [':global', '.global'],
      transformClassName: true,
      transformId: false,
      transformDataAttr: true
    })
  ]
};

// webpack配置
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          'style-loader',
          {
            loader: 'css-loader',
            options: {
              postcss: true
            }
          },
          {
            loader: 'postcss-loader',
            options: postcssConfig
          }
        ]
      }
    ]
  }
};
```

### 5.4.3 Sass/Less命名空间混入

```scss
// Sass命名空间混入
@mixin micro-frontend-namespace($prefix) {
  // 为类名添加命名空间
  %namespace-class {
    @at-root {
      .#{$prefix}-#{&} {
        @content;
      }
    }
  }
  
  // 为ID添加命名空间
  %namespace-id {
    @at-root {
      ##{$prefix}-#{&} {
        @content;
      }
    }
  }
  
  // 为数据属性添加命名空间
  %namespace-data {
    @at-root {
      [data-#{$prefix}-#{&}] {
        @content;
      }
    }
  }
}

// 使用示例
@include micro-frontend-namespace('dashboard') {
  .container {
    @extend %namespace-class;
    padding: 16px;
    
    .title {
      @extend %namespace-class;
      font-size: 24px;
      font-weight: bold;
    }
    
    .button {
      @extend %namespace-class;
      background-color: #1890ff;
      color: white;
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
    }
  }
  
  #app-header {
    @extend %namespace-id;
    height: 60px;
    background-color: white;
    border-bottom: 1px solid #eee;
  }
  
  [data-widget] {
    @extend %namespace-data;
    margin: 16px;
    padding: 16px;
    background-color: white;
    border-radius: 4px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }
}
```

```less
// Less命名空间混入
.micro-frontend-namespace(@prefix) {
  // 为类名添加命名空间
  .namespace-class() {
    @selector: ~'.@{prefix}@{class-name}';
    @{selector} {
      @content();
    }
  }
  
  // 为ID添加命名空间
  .namespace-id() {
    @selector: ~'#@{prefix}@{id-name}';
    @{selector} {
      @content();
    }
  }
  
  // 为数据属性添加命名空间
  .namespace-data() {
    @selector: ~'[data-@{prefix}@{data-name}]';
    @{selector} {
      @content();
    }
  }
}

// 使用示例
& {
  .micro-frontend-namespace('dashboard');
  
  .container {
    .namespace-class() when (@class-name = 'container') {
      padding: 16px;
      
      .title {
        .namespace-class() when (@class-name = 'title') {
          font-size: 24px;
          font-weight: bold;
        }
      }
      
      .button {
        .namespace-class() when (@class-name = 'button') {
          background-color: #1890ff;
          color: white;
          padding: 8px 16px;
          border: none;
          border-radius: 4px;
        }
      }
    }
  }
  
  #app-header {
    .namespace-id() when (@id-name = 'app-header') {
      height: 60px;
      background-color: white;
      border-bottom: 1px solid #eee;
    }
  }
  
  [data-widget] {
    .namespace-data() when (@data-name = 'widget') {
      margin: 16px;
      padding: 16px;
      background-color: white;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
  }
}
```

## 5.5 动态样式加载与隔离

### 5.5.1 动态样式加载

```javascript
// 动态样式加载器
class DynamicStyleLoader {
  constructor() {
    this.loadedStyles = new Map();
    this.styleElements = new Map();
  }
  
  // 加载CSS文件
  loadCSS(url, options = {}) {
    const { id, prepend = false, crossOrigin = 'anonymous' } = options;
    
    // 检查是否已加载
    if (this.loadedStyles.has(url)) {
      return Promise.resolve(this.loadedStyles.get(url));
    }
    
    return new Promise((resolve, reject) => {
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = url;
      link.crossOrigin = crossOrigin;
      
      if (id) {
        link.id = id;
      }
      
      link.onload = () => {
        this.loadedStyles.set(url, link);
        resolve(link);
      };
      
      link.onerror = () => {
        reject(new Error(`加载CSS文件失败: ${url}`));
      };
      
      // 添加到DOM
      if (prepend) {
        document.head.insertBefore(link, document.head.firstChild);
      } else {
        document.head.appendChild(link);
      }
    });
  }
  
  // 加载CSS文本
  loadCSSText(cssText, options = {}) {
    const { id, prepend = false } = options;
    
    // 检查是否已加载
    if (id && this.styleElements.has(id)) {
      return this.styleElements.get(id);
    }
    
    const style = document.createElement('style');
    style.textContent = cssText;
    
    if (id) {
      style.id = id;
    }
    
    // 添加到DOM
    if (prepend) {
      document.head.insertBefore(style, document.head.firstChild);
    } else {
      document.head.appendChild(style);
    }
    
    if (id) {
      this.styleElements.set(id, style);
    }
    
    return style;
  }
  
  // 卸载CSS
  unloadCSS(urlOrId) {
    // 尝试通过URL卸载
    if (this.loadedStyles.has(urlOrId)) {
      const link = this.loadedStyles.get(urlOrId);
      if (link.parentNode) {
        link.parentNode.removeChild(link);
      }
      this.loadedStyles.delete(urlOrId);
      return true;
    }
    
    // 尝试通过ID卸载
    if (this.styleElements.has(urlOrId)) {
      const style = this.styleElements.get(urlOrId);
      if (style.parentNode) {
        style.parentNode.removeChild(style);
      }
      this.styleElements.delete(urlOrId);
      return true;
    }
    
    return false;
  }
  
  // 清空所有样式
  clear() {
    // 卸载所有链接样式
    this.loadedStyles.forEach((link, url) => {
      if (link.parentNode) {
        link.parentNode.removeChild(link);
      }
    });
    this.loadedStyles.clear();
    
    // 卸载所有内联样式
    this.styleElements.forEach((style, id) => {
      if (style.parentNode) {
        style.parentNode.removeChild(style);
      }
    });
    this.styleElements.clear();
  }
}

// 创建全局样式加载器
const styleLoader = new DynamicStyleLoader();

export default styleLoader;
```

### 5.5.2 样式隔离与动态加载结合

```javascript
// 微前端样式隔离与动态加载管理器
class MicroFrontendStyleManager {
  constructor() {
    this.styleLoader = new DynamicStyleLoader();
    this.appStyles = new Map();
    this.styleScopes = new Map();
  }
  
  // 注册微应用
  registerApp(appName, styleConfig) {
    if (this.appStyles.has(appName)) {
      throw new Error(`微应用 ${appName} 已注册`);
    }
    
    const appStyleInfo = {
      name: appName,
      styles: [],
      scope: null,
      ...styleConfig
    };
    
    this.appStyles.set(appName, appStyleInfo);
    
    return appStyleInfo;
  }
  
  // 加载微应用样式
  async loadAppStyles(appName) {
    const appStyleInfo = this.appStyles.get(appName);
    if (!appStyleInfo) {
      throw new Error(`未找到微应用 ${appName} 的样式配置`);
    }
    
    // 卸载已加载的样式
    this.unloadAppStyles(appName);
    
    const loadedStyles = [];
    
    // 加载CSS文件
    if (appStyleInfo.cssFiles) {
      for (const cssFile of appStyleInfo.cssFiles) {
        try {
          const link = await this.styleLoader.loadCSS(cssFile.url, {
            id: `${appName}-${cssFile.id || 'style'}`,
            prepend: cssFile.prepend
          });
          
          loadedStyles.push({
            type: 'link',
            element: link,
            url: cssFile.url
          });
        } catch (error) {
          console.error(`加载微应用 ${appName} 的CSS文件失败:`, error);
        }
      }
    }
    
    // 加载CSS文本
    if (appStyleInfo.cssTexts) {
      for (const cssText of appStyleInfo.cssTexts) {
        try {
          // 添加命名空间
          const scopedCssText = this.addNamespace(cssText.content, appName);
          
          const style = this.styleLoader.loadCSSText(scopedCssText, {
            id: `${appName}-${cssText.id || 'style'}`,
            prepend: cssText.prepend
          });
          
          loadedStyles.push({
            type: 'style',
            element: style,
            content: cssText.content
          });
        } catch (error) {
          console.error(`加载微应用 ${appName} 的CSS文本失败:`, error);
        }
      }
    }
    
    // 保存已加载的样式
    appStyleInfo.styles = loadedStyles;
    
    return loadedStyles;
  }
  
  // 卸载微应用样式
  unloadAppStyles(appName) {
    const appStyleInfo = this.appStyles.get(appName);
    if (!appStyleInfo) {
      return;
    }
    
    // 卸载所有样式
    appStyleInfo.styles.forEach(style => {
      if (style.type === 'link') {
        this.styleLoader.unloadCSS(style.url);
      } else if (style.type === 'style') {
        const styleId = `${appName}-${style.id || 'style'}`;
        this.styleLoader.unloadCSS(styleId);
      }
    });
    
    // 清空样式列表
    appStyleInfo.styles = [];
  }
  
  // 添加命名空间
  addNamespace(cssText, appName) {
    const prefix = `mf-${appName}`;
    
    // 简单的CSS解析，实际应用中可以使用更完善的CSS解析器
    return cssText.replace(/([^\r\n,{}]+)(,(?=[^}]*{)|\s*{)/g, (match, selector, delimiter) => {
      // 跳过@开头的规则
      if (selector.trim().startsWith('@')) {
        return match;
      }
      
      // 跳过:global选择器
      if (selector.includes(':global')) {
        return match;
      }
      
      // 跳过body、html等全局选择器
      if (selector.trim() === 'body' || selector.trim() === 'html') {
        return match;
      }
      
      // 添加命名空间前缀
      const scopedSelector = selector
        .split(',')
        .map(s => {
          s = s.trim();
          
          // 跳过伪类和伪元素
          if (s.startsWith(':')) {
            return s;
          }
          
          // 跳过已命名空间的选择器
          if (s.startsWith(`.${prefix}`) || s.startsWith(`#${prefix}`)) {
            return s;
          }
          
          // 为类名添加命名空间
          if (s.startsWith('.')) {
            return `.${prefix}${s.substring(1)}`;
          }
          
          // 为ID添加命名空间
          if (s.startsWith('#')) {
            return `#${prefix}${s.substring(1)}`;
          }
          
          // 为属性选择器添加命名空间
          if (s.startsWith('[')) {
            return s.replace('[data-', `[data-${prefix}`);
          }
          
          // 其他情况添加类选择器
          return `.${prefix} ${s}`;
        })
        .join(', ');
      
      return scopedSelector + delimiter;
    });
  }
  
  // 更新微应用样式
  async updateAppStyles(appName, styleConfig) {
    // 重新注册应用
    this.registerApp(appName, styleConfig);
    
    // 重新加载样式
    return this.loadAppStyles(appName);
  }
  
  // 获取微应用样式信息
  getAppStyles(appName) {
    return this.appStyles.get(appName);
  }
  
  // 清空所有微应用样式
  clear() {
    this.appStyles.forEach((appStyleInfo, appName) => {
      this.unloadAppStyles(appName);
    });
    this.appStyles.clear();
  }
}

// 创建全局样式管理器
const microFrontendStyleManager = new MicroFrontendStyleManager();

export default microFrontendStyleManager;
```

### 5.5.3 样式优先级管理

```javascript
// 样式优先级管理器
class StylePriorityManager {
  constructor() {
    this.styleGroups = new Map();
    this.priorityOrder = [];
  }
  
  // 注册样式组
  registerStyleGroup(name, priority = 0) {
    if (this.styleGroups.has(name)) {
      throw new Error(`样式组 ${name} 已存在`);
    }
    
    this.styleGroups.set(name, {
      name,
      priority,
      styles: []
    });
    
    // 更新优先级顺序
    this.updatePriorityOrder();
    
    return this.styleGroups.get(name);
  }
  
  // 添加样式到样式组
  addStyleToGroup(groupName, styleElement) {
    const group = this.styleGroups.get(groupName);
    if (!group) {
      throw new Error(`样式组 ${groupName} 不存在`);
    }
    
    group.styles.push(styleElement);
    
    // 更新样式顺序
    this.updateStyleOrder();
    
    return styleElement;
  }
  
  // 从样式组移除样式
  removeStyleFromGroup(groupName, styleElement) {
    const group = this.styleGroups.get(groupName);
    if (!group) {
      return false;
    }
    
    const index = group.styles.indexOf(styleElement);
    if (index !== -1) {
      group.styles.splice(index, 1);
      
      // 从DOM中移除
      if (styleElement.parentNode) {
        styleElement.parentNode.removeChild(styleElement);
      }
      
      return true;
    }
    
    return false;
  }
  
  // 更新优先级顺序
  updatePriorityOrder() {
    this.priorityOrder = Array.from(this.styleGroups.values())
      .sort((a, b) => a.priority - b.priority)
      .map(group => group.name);
  }
  
  // 更新样式顺序
  updateStyleOrder() {
    // 按优先级顺序重新排列样式
    this.priorityOrder.forEach(groupName => {
      const group = this.styleGroups.get(groupName);
      
      group.styles.forEach(styleElement => {
        // 确保样式在DOM中
        if (!styleElement.parentNode) {
          document.head.appendChild(styleElement);
        }
        
        // 移动到正确的位置
        let insertBefore = null;
        
        // 找到下一个更高优先级的样式组
        const currentIndex = this.priorityOrder.indexOf(groupName);
        for (let i = currentIndex + 1; i < this.priorityOrder.length; i++) {
          const nextGroupName = this.priorityOrder[i];
          const nextGroup = this.styleGroups.get(nextGroupName);
          
          if (nextGroup.styles.length > 0) {
            insertBefore = nextGroup.styles[0];
            break;
          }
        }
        
        // 移动样式
        if (insertBefore) {
          document.head.insertBefore(styleElement, insertBefore);
        } else {
          document.head.appendChild(styleElement);
        }
      });
    });
  }
  
  // 获取样式组
  getStyleGroup(groupName) {
    return this.styleGroups.get(groupName);
  }
  
  // 删除样式组
  removeStyleGroup(groupName) {
    const group = this.styleGroups.get(groupName);
    if (!group) {
      return false;
    }
    
    // 移除所有样式
    group.styles.forEach(styleElement => {
      if (styleElement.parentNode) {
        styleElement.parentNode.removeChild(styleElement);
      }
    });
    
    // 删除样式组
    this.styleGroups.delete(groupName);
    
    // 更新优先级顺序
    this.updatePriorityOrder();
    
    return true;
  }
  
  // 清空所有样式组
  clear() {
    this.styleGroups.forEach((group, groupName) => {
      this.removeStyleGroup(groupName);
    });
    this.styleGroups.clear();
    this.priorityOrder = [];
  }
}

// 创建全局样式优先级管理器
const stylePriorityManager = new StylePriorityManager();

// 初始化默认样式组
stylePriorityManager.registerStyleGroup('reset', -100); // 重置样式
stylePriorityManager.registerStyleGroup('base', -50); // 基础样式
stylePriorityManager.registerStyleGroup('layout', 0); // 布局样式
stylePriorityManager.registerStyleGroup('component', 50); // 组件样式
stylePriorityManager.registerStyleGroup('override', 100); // 覆盖样式

export default stylePriorityManager;
```

## 5.6 微前端样式隔离最佳实践

### 5.6.1 样式隔离方案选择指南

根据不同的场景和需求，选择合适的样式隔离方案：

| 场景 | 推荐方案 | 优点 | 缺点 |
|------|----------|------|------|
| 新项目，技术栈统一 | CSS Modules/CSS-in-JS | 完全隔离，开发体验好 | 需要构建工具支持 |
| 遗留系统改造 | 命名空间/动态加载 | 改造成本低，兼容性好 | 隔离不彻底，依赖规范 |
| 强隔离需求 | Shadow DOM | 完全隔离，样式不泄漏 | 实现复杂，样式穿透困难 |
| 第三方应用集成 | iframe | 完全隔离，安全性高 | 性能开销大，交互复杂 |
| 混合技术栈 | 统一CSS变量+命名空间 | 主题一致，部分隔离 | 维护成本高 |

### 5.6.2 样式隔离实施策略

1. **渐进式隔离**：从关键组件开始，逐步扩展到整个应用
2. **分层隔离**：基础样式共享，组件样式隔离
3. **主题统一**：使用CSS变量实现主题一致性
4. **样式审查**：建立样式规范和代码审查机制
5. **自动化测试**：添加样式回归测试

```javascript
// 微前端样式隔离策略实施工具
class StyleIsolationStrategy {
  constructor(options = {}) {
    this.options = {
      isolationLevel: 'partial', // 'none', 'partial', 'full'
      namespacePrefix: 'mf',
      useShadowDOM: false,
      useCSSModules: false,
      ...options
    };
    
    this.styleManager = new MicroFrontendStyleManager();
    this.namespaceManager = new MicroFrontendNamespaceManager();
    this.priorityManager = new StylePriorityManager();
  }
  
  // 应用样式隔离策略
  applyStrategy(appName, styleConfig) {
    switch (this.options.isolationLevel) {
      case 'none':
        return this.applyNoIsolation(appName, styleConfig);
        
      case 'partial':
        return this.applyPartialIsolation(appName, styleConfig);
        
      case 'full':
        return this.applyFullIsolation(appName, styleConfig);
        
      default:
        throw new Error(`未知的隔离级别: ${this.options.isolationLevel}`);
    }
  }
  
  // 无隔离策略
  async applyNoIsolation(appName, styleConfig) {
    // 直接加载样式，不进行任何隔离处理
    return this.styleManager.loadAppStyles(appName);
  }
  
  // 部分隔离策略
  async applyPartialIsolation(appName, styleConfig) {
    // 创建命名空间
    const namespace = this.namespaceManager.createNamespace(appName);
    
    // 处理样式配置
    const processedStyleConfig = {
      ...styleConfig,
      cssTexts: styleConfig.cssTexts ? styleConfig.cssTexts.map(cssText => ({
        ...cssText,
        content: this.addNamespace(cssText.content, namespace.prefix)
      })) : []
    };
    
    // 注册应用
    this.styleManager.registerApp(appName, processedStyleConfig);
    
    // 加载样式
    const loadedStyles = await this.styleManager.loadAppStyles(appName);
    
    // 添加到样式优先级管理
    const styleGroup = this.priorityManager.registerStyleGroup(appName, 0);
    loadedStyles.forEach(style => {
      this.priorityManager.addStyleToGroup(appName, style.element);
    });
    
    return loadedStyles;
  }
  
  // 完全隔离策略
  async applyFullIsolation(appName, styleConfig) {
    if (this.options.useShadowDOM) {
      return this.applyShadowDOMIsolation(appName, styleConfig);
    } else if (this.options.useCSSModules) {
      return this.applyCSSModulesIsolation(appName, styleConfig);
    } else {
      // 使用命名空间 + 动态加载实现完全隔离
      return this.applyPartialIsolation(appName, styleConfig);
    }
  }
  
  // Shadow DOM隔离
  async applyShadowDOMIsolation(appName, styleConfig) {
    // 创建Shadow DOM容器
    const hostElement = document.createElement('div');
    hostElement.id = `micro-app-${appName}`;
    document.body.appendChild(hostElement);
    
    const container = new ShadowMicroAppContainer();
    const shadowRoot = container.createContainer(hostElement);
    
    // 加载样式到Shadow DOM
    if (styleConfig.cssFiles) {
      for (const cssFile of styleConfig.cssFiles) {
        try {
          const response = await fetch(cssFile.url);
          const cssText = await response.text();
          
          const style = document.createElement('style');
          style.textContent = cssText;
          shadowRoot.appendChild(style);
        } catch (error) {
          console.error(`加载微应用 ${appName} 的CSS文件到Shadow DOM失败:`, error);
        }
      }
    }
    
    if (styleConfig.cssTexts) {
      for (const cssText of styleConfig.cssTexts) {
        const style = document.createElement('style');
        style.textContent = cssText.content;
        shadowRoot.appendChild(style);
      }
    }
    
    return {
      shadowRoot,
      hostElement,
      container
    };
  }
  
  // CSS Modules隔离
  async applyCSSModulesIsolation(appName, styleConfig) {
    // CSS Modules需要在构建时处理，这里只是模拟
    console.warn('CSS Modules需要在构建时处理，这里只是模拟');
    
    // 实际应用中，CSS Modules会在构建时生成唯一的类名
    // 运行时只需要加载处理后的样式
    return this.styleManager.loadAppStyles(appName);
  }
  
  // 添加命名空间
  addNamespace(cssText, prefix) {
    // 简单的CSS解析，实际应用中可以使用更完善的CSS解析器
    return cssText.replace(/([^\r\n,{}]+)(,(?=[^}]*{)|\s*{)/g, (match, selector, delimiter) => {
      // 跳过@开头的规则
      if (selector.trim().startsWith('@')) {
        return match;
      }
      
      // 跳过:global选择器
      if (selector.includes(':global')) {
        return match;
      }
      
      // 跳过body、html等全局选择器
      if (selector.trim() === 'body' || selector.trim() === 'html') {
        return match;
      }
      
      // 添加命名空间前缀
      const scopedSelector = selector
        .split(',')
        .map(s => {
          s = s.trim();
          
          // 跳过伪类和伪元素
          if (s.startsWith(':')) {
            return s;
          }
          
          // 跳过已命名空间的选择器
          if (s.startsWith(`.${prefix}`) || s.startsWith(`#${prefix}`)) {
            return s;
          }
          
          // 为类名添加命名空间
          if (s.startsWith('.')) {
            return `.${prefix}${s.substring(1)}`;
          }
          
          // 为ID添加命名空间
          if (s.startsWith('#')) {
            return `#${prefix}${s.substring(1)}`;
          }
          
          // 为属性选择器添加命名空间
          if (s.startsWith('[')) {
            return s.replace('[data-', `[data-${prefix}`);
          }
          
          // 其他情况添加类选择器
          return `.${prefix} ${s}`;
        })
        .join(', ');
      
      return scopedSelector + delimiter;
    });
  }
  
  // 卸载应用样式
  unloadAppStyles(appName) {
    return this.styleManager.unloadAppStyles(appName);
  }
  
  // 更新应用样式
  async updateAppStyles(appName, styleConfig) {
    return this.styleManager.updateAppStyles(appName, styleConfig);
  }
}

// 创建全局样式隔离策略实例
const styleIsolationStrategy = new StyleIsolationStrategy({
  isolationLevel: 'partial',
  namespacePrefix: 'mf',
  useShadowDOM: false,
  useCSSModules: false
});

export default styleIsolationStrategy;
```

### 5.6.3 样式隔离调试工具

```javascript
// 样式隔离调试工具
class StyleIsolationDebugger {
  constructor() {
    this.isEnabled = false;
    this.debugPanel = null;
    this.styleInfo = new Map();
  }
  
  // 启用调试
  enable() {
    if (this.isEnabled) {
      return;
    }
    
    this.isEnabled = true;
    this.createDebugPanel();
    this.collectStyleInfo();
    this.updateDebugPanel();
    
    console.log('样式隔离调试已启用');
  }
  
  // 禁用调试
  disable() {
    if (!this.isEnabled) {
      return;
    }
    
    this.isEnabled = false;
    
    if (this.debugPanel && this.debugPanel.parentNode) {
      this.debugPanel.parentNode.removeChild(this.debugPanel);
      this.debugPanel = null;
    }
    
    console.log('样式隔离调试已禁用');
  }
  
  // 创建调试面板
  createDebugPanel() {
    // 创建调试面板容器
    this.debugPanel = document.createElement('div');
    this.debugPanel.id = 'style-isolation-debugger';
    this.debugPanel.style.cssText = `
      position: fixed;
      top: 10px;
      left: 10px;
      width: 400px;
      max-height: 600px;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      z-index: 10000;
      font-family: monospace;
      font-size: 12px;
      display: flex;
      flex-direction: column;
    `;
    
    // 创建标题栏
    const header = document.createElement('div');
    header.style.cssText = `
      background: #f5f5f5;
      padding: 8px;
      border-bottom: 1px solid #ccc;
      display: flex;
      justify-content: space-between;
      align-items: center;
    `;
    
    const title = document.createElement('span');
    title.textContent = '样式隔离调试';
    header.appendChild(title);
    
    const closeBtn = document.createElement('button');
    closeBtn.textContent = '×';
    closeBtn.style.cssText = `
      background: none;
      border: none;
      font-size: 16px;
      cursor: pointer;
    `;
    closeBtn.onclick = () => {
      this.debugPanel.style.display = 'none';
    };
    header.appendChild(closeBtn);
    
    // 创建控制区域
    const controls = document.createElement('div');
    controls.style.cssText = `
      padding: 8px;
      border-bottom: 1px solid #ccc;
      display: flex;
      gap: 8px;
    `;
    
    const refreshBtn = document.createElement('button');
    refreshBtn.textContent = '刷新';
    refreshBtn.onclick = () => {
      this.collectStyleInfo();
      this.updateDebugPanel();
    };
    controls.appendChild(refreshBtn);
    
    const highlightBtn = document.createElement('button');
    highlightBtn.textContent = '高亮';
    highlightBtn.onclick = () => {
      this.highlightStyles();
    };
    controls.appendChild(highlightBtn);
    
    const exportBtn = document.createElement('button');
    exportBtn.textContent = '导出';
    exportBtn.onclick = () => {
      this.exportStyleInfo();
    };
    controls.appendChild(exportBtn);
    
    // 创建内容区域
    const content = document.createElement('div');
    content.style.cssText = `
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    `;
    
    // 组装面板
    this.debugPanel.appendChild(header);
    this.debugPanel.appendChild(controls);
    this.debugPanel.appendChild(content);
    
    // 添加到页面
    document.body.appendChild(this.debugPanel);
    
    // 保存内容区域引用
    this.debugContent = content;
  }
  
  // 收集样式信息
  collectStyleInfo() {
    this.styleInfo.clear();
    
    // 收集所有样式表
    const styleSheets = Array.from(document.styleSheets);
    
    styleSheets.forEach((styleSheet, index) => {
      try {
        const rules = Array.from(styleSheet.cssRules || []);
        
        rules.forEach((rule, ruleIndex) => {
          if (rule.type === CSSRule.STYLE_RULE) {
            const selector = rule.selectorText;
            
            // 检查是否是微前端样式
            const isMicroFrontendStyle = selector.includes('mf-') || 
                                        selector.includes('data-mf-') || 
                                        selector.includes('micro-app');
            
            if (isMicroFrontendStyle) {
              // 提取应用名
              let appName = 'unknown';
              const match = selector.match(/mf-([a-zA-Z0-9_-]+)/);
              if (match) {
                appName = match[1];
              }
              
              // 获取样式信息
              const styleInfo = {
                selector,
                appName,
                styleSheet: index,
                ruleIndex,
                cssText: rule.cssText,
                styles: {}
              };
              
              // 获取所有样式属性
              for (let i = 0; i < rule.style.length; i++) {
                const property = rule.style[i];
                const value = rule.style.getPropertyValue(property);
                styleInfo.styles[property] = value;
              }
              
              // 添加到样式信息
              if (!this.styleInfo.has(appName)) {
                this.styleInfo.set(appName, []);
              }
              
              this.styleInfo.get(appName).push(styleInfo);
            }
          }
        });
      } catch (e) {
        console.warn('无法访问样式表:', e);
      }
    });
  }
  
  // 更新调试面板
  updateDebugPanel() {
    if (!this.debugContent) {
      return;
    }
    
    // 清空内容
    this.debugContent.innerHTML = '';
    
    // 添加样式信息
    this.styleInfo.forEach((styles, appName) => {
      const appSection = document.createElement('div');
      appSection.style.cssText = `
        margin-bottom: 16px;
        border: 1px solid #eee;
        border-radius: 4px;
        overflow: hidden;
      `;
      
      // 应用标题
      const appHeader = document.createElement('div');
      appHeader.style.cssText = `
        background: #f5f5f5;
        padding: 8px;
        font-weight: bold;
      `;
      appHeader.textContent = `应用: ${appName} (${styles.length} 个样式)`;
      appSection.appendChild(appHeader);
      
      // 样式列表
      const styleList = document.createElement('div');
      styleList.style.cssText = `
        max-height: 200px;
        overflow-y: auto;
      `;
      
      styles.forEach(style => {
        const styleItem = document.createElement('div');
        styleItem.style.cssText = `
          padding: 8px;
          border-bottom: 1px solid #eee;
        `;
        
        styleItem.innerHTML = `
          <div><strong>选择器:</strong> ${style.selector}</div>
          <div><strong>样式表:</strong> ${style.styleSheet}</div>
          <div><strong>规则索引:</strong> ${style.ruleIndex}</div>
          <details>
            <summary>样式属性</summary>
            <pre>${JSON.stringify(style.styles, null, 2)}</pre>
          </details>
        `;
        
        styleList.appendChild(styleItem);
      });
      
      appSection.appendChild(styleList);
      this.debugContent.appendChild(appSection);
    });
  }
  
  // 高亮样式
  highlightStyles() {
    // 移除之前的高亮
    document.querySelectorAll('.style-isolation-highlight').forEach(el => {
      el.classList.remove('style-isolation-highlight');
    });
    
    // 添加新的高亮
    this.styleInfo.forEach((styles, appName) => {
      styles.forEach(style => {
        try {
          const elements = document.querySelectorAll(style.selector);
          elements.forEach(el => {
            el.classList.add('style-isolation-highlight');
          });
        } catch (e) {
          console.warn('无效的选择器:', style.selector);
        }
      });
    });
    
    // 添加高亮样式
    if (!document.getElementById('style-isolation-highlight-style')) {
      const style = document.createElement('style');
      style.id = 'style-isolation-highlight-style';
      style.textContent = `
        .style-isolation-highlight {
          outline: 2px solid red !important;
          outline-offset: 2px !important;
        }
      `;
      document.head.appendChild(style);
    }
  }
  
  // 导出样式信息
  exportStyleInfo() {
    const data = {};
    
    this.styleInfo.forEach((styles, appName) => {
      data[appName] = styles;
    });
    
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `style-isolation-info-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }
}

// 创建全局样式隔离调试器
const styleIsolationDebugger = new StyleIsolationDebugger();

// 全局暴露调试器
window.__STYLE_ISOLATION_DEBUGGER__ = styleIsolationDebugger;

export default styleIsolationDebugger;
```

## 总结

本章详细介绍了微前端架构中的样式隔离方案，包括：

1. **样式隔离概述**：分析了微前端样式隔离的必要性和方案分类
2. **CSS作用域隔离**：介绍了CSS Modules、CSS-in-JS等作用域隔离方案
3. **Shadow DOM隔离**：实现了基于Shadow DOM的完全样式隔离方案
4. **样式命名空间隔离**：通过命名约定和工具实现样式隔离
5. **动态样式加载与隔离**：实现了动态加载和隔离样式的机制
6. **样式隔离最佳实践**：提供了样式隔离方案选择指南、实施策略和调试工具

通过这些样式隔离方案，微前端应用可以避免样式冲突，保持各自的样式独立性，同时又能共享通用样式和主题。在实际项目中，应根据具体需求选择合适的隔离方案，并结合使用多种技术以达到最佳效果。