# 第十章：微前端性能优化

## 10.1 性能优化概述

在微前端架构中，性能优化是一个关键问题。由于多个微应用共享同一个页面，性能问题可能会更加突出。因此，需要有效的性能优化策略来确保微前端应用的性能和用户体验。

### 10.1.1 性能挑战

1. **资源加载过多**：多个微应用的资源同时加载导致页面加载缓慢
2. **重复依赖**：不同微应用可能使用相同的依赖，导致重复加载
3. **运行时开销**：微前端框架本身带来的运行时开销
4. **内存占用**：多个微应用同时运行导致内存占用过高
5. **渲染性能**：复杂页面结构和样式导致渲染性能下降
6. **网络请求**：过多的网络请求影响页面加载速度

### 10.1.2 性能指标

在微前端架构中，常见的性能指标包括：

1. **首次内容绘制（FCP）**：页面首次绘制内容的时间
2. **最大内容绘制（LCP）**：页面最大内容元素绘制的时间
3. **首次输入延迟（FID）**：用户首次与页面交互的响应时间
4. **累积布局偏移（CLS）**：页面布局稳定性的指标
5. **首次可交互时间（TTI）**：页面完全可交互的时间
6. **资源加载时间**：各类资源（CSS、JS、图片等）的加载时间
7. **内存使用量**：应用运行时的内存占用
8. **CPU使用率**：应用运行时的CPU占用

## 10.2 资源加载优化

### 10.2.1 按需加载

实现微应用的按需加载，减少初始加载资源：

```javascript
// 微应用按需加载器
class LazyAppLoader {
  constructor() {
    this.loadedApps = new Map();
    this.loadingApps = new Map();
    this.appConfigs = new Map();
  }
  
  // 注册应用配置
  registerApp(name, config) {
    this.appConfigs.set(name, {
      entry: config.entry,
      preload: config.preload || false,
      prefetch: config.prefetch || false,
      delay: config.delay || 0,
      ...config
    });
  }
  
  // 加载应用
  loadApp(name, container) {
    // 如果应用已加载，直接显示
    if (this.loadedApps.has(name)) {
      const appData = this.loadedApps.get(name);
      container.appendChild(appData.element);
      return Promise.resolve(appData.app);
    }
    
    // 如果应用正在加载，返回加载Promise
    if (this.loadingApps.has(name)) {
      return this.loadingApps.get(name);
    }
    
    // 获取应用配置
    const config = this.appConfigs.get(name);
    if (!config) {
      return Promise.reject(new Error(`应用 ${name} 未注册`));
    }
    
    // 创建加载Promise
    const loadingPromise = this.doLoadApp(name, config, container);
    this.loadingApps.set(name, loadingPromise);
    
    return loadingPromise;
  }
  
  // 执行应用加载
  doLoadApp(name, config, container) {
    // 延迟加载
    const delayPromise = new Promise(resolve => {
      setTimeout(resolve, config.delay);
    });
    
    return delayPromise
      .then(() => {
        // 加载应用资源
        return this.loadAppResources(name, config);
      })
      .then(resources => {
        // 创建应用实例
        return this.createAppInstance(name, resources, container);
      })
      .then(appData => {
        // 缓存应用数据
        this.loadedApps.set(name, appData);
        
        // 移除加载中的Promise
        this.loadingApps.delete(name);
        
        return appData.app;
      })
      .catch(error => {
        // 移除加载中的Promise
        this.loadingApps.delete(name);
        throw error;
      });
  }
  
  // 加载应用资源
  loadAppResources(name, config) {
    return Promise.all([
      this.loadHTML(config.entry),
      this.loadCSS(config.styles),
      this.loadJS(config.scripts)
    ]).then(([html, css, js]) => {
      return { html, css, js };
    });
  }
  
  // 加载HTML
  loadHTML(entry) {
    return fetch(entry)
      .then(response => response.text());
  }
  
  // 加载CSS
  loadCSS(styleUrls) {
    if (!styleUrls || styleUrls.length === 0) {
      return Promise.resolve([]);
    }
    
    const promises = styleUrls.map(url => {
      return fetch(url)
        .then(response => response.text());
    });
    
    return Promise.all(promises);
  }
  
  // 加载JS
  loadJS(scriptUrls) {
    if (!scriptUrls || scriptUrls.length === 0) {
      return Promise.resolve([]);
    }
    
    const promises = scriptUrls.map(url => {
      return fetch(url)
        .then(response => response.text());
    });
    
    return Promise.all(promises);
  }
  
  // 创建应用实例
  createAppInstance(name, resources, container) {
    // 创建应用容器
    const appElement = document.createElement('div');
    appElement.id = `mf-app-${name}`;
    appElement.innerHTML = resources.html;
    
    // 添加样式
    if (resources.css && resources.css.length > 0) {
      resources.css.forEach(cssText => {
        const style = document.createElement('style');
        style.textContent = cssText;
        appElement.appendChild(style);
      });
    }
    
    // 添加脚本
    if (resources.js && resources.js.length > 0) {
      resources.js.forEach(jsText => {
        const script = document.createElement('script');
        script.textContent = jsText;
        appElement.appendChild(script);
      });
    }
    
    // 将应用元素添加到容器
    container.appendChild(appElement);
    
    // 获取应用实例
    const app = appElement.querySelector('#app');
    
    return Promise.resolve({
      element: appElement,
      app
    });
  }
  
  // 预加载应用
  preloadApp(name) {
    const config = this.appConfigs.get(name);
    if (!config || !config.preload) {
      return Promise.resolve();
    }
    
    // 如果应用已加载或正在加载，不重复预加载
    if (this.loadedApps.has(name) || this.loadingApps.has(name)) {
      return Promise.resolve();
    }
    
    // 创建临时容器
    const tempContainer = document.createElement('div');
    tempContainer.style.display = 'none';
    document.body.appendChild(tempContainer);
    
    // 加载应用
    return this.loadApp(name, tempContainer)
      .then(app => {
        // 隐藏应用
        tempContainer.style.display = 'none';
        
        // 卸载应用（保留资源）
        this.unloadApp(name, false);
        
        console.log(`应用 ${name} 预加载完成`);
      })
      .catch(error => {
        console.error(`应用 ${name} 预加载失败:`, error);
      });
  }
  
  // 预取应用资源
  prefetchApp(name) {
    const config = this.appConfigs.get(name);
    if (!config || !config.prefetch) {
      return Promise.resolve();
    }
    
    // 预取HTML
    if (config.entry) {
      const link = document.createElement('link');
      link.rel = 'prefetch';
      link.href = config.entry;
      document.head.appendChild(link);
    }
    
    // 预取CSS
    if (config.styles) {
      config.styles.forEach(url => {
        const link = document.createElement('link');
        link.rel = 'prefetch';
        link.href = url;
        link.as = 'style';
        document.head.appendChild(link);
      });
    }
    
    // 预取JS
    if (config.scripts) {
      config.scripts.forEach(url => {
        const link = document.createElement('link');
        link.rel = 'prefetch';
        link.href = url;
        link.as = 'script';
        document.head.appendChild(link);
      });
    }
    
    console.log(`应用 ${name} 资源预取完成`);
    return Promise.resolve();
  }
  
  // 卸载应用
  unloadApp(name, removeElement = true) {
    if (this.loadedApps.has(name)) {
      const appData = this.loadedApps.get(name);
      
      // 从DOM中移除
      if (removeElement && appData.element.parentNode) {
        appData.element.parentNode.removeChild(appData.element);
      }
      
      // 从缓存中移除
      this.loadedApps.delete(name);
    }
  }
  
  // 卸载所有应用
  unloadAllApps() {
    this.loadedApps.forEach((appData, name) => {
      this.unloadApp(name);
    });
  }
}

// 创建全局应用加载器
window.__MF_LAZY_APP_LOADER__ = new LazyAppLoader();

// 注册应用
window.__MF_LAZY_APP_LOADER__.registerApp('user-app', {
  entry: '/apps/user-app/index.html',
  styles: [
    '/apps/user-app/styles.css',
    '/apps/user-app/components.css'
  ],
  scripts: [
    '/apps/user-app/app.js'
  ],
  preload: false,
  prefetch: true,
  delay: 0
});

window.__MF_LAZY_APP_LOADER__.registerApp('order-app', {
  entry: '/apps/order-app/index.html',
  styles: [
    '/apps/order-app/styles.css',
    '/apps/order-app/components.css'
  ],
  scripts: [
    '/apps/order-app/app.js'
  ],
  preload: false,
  prefetch: true,
  delay: 100
});

// 路由变化时加载应用
function handleRouteChange(route) {
  const container = document.getElementById('app-container');
  container.innerHTML = '';
  
  switch (route) {
    case '/user':
      window.__MF_LAZY_APP_LOADER__.loadApp('user-app', container)
        .then(() => {
          console.log('用户应用加载成功');
        })
        .catch(error => {
          console.error('用户应用加载失败:', error);
        });
      break;
    case '/order':
      window.__MF_LAZY_APP_LOADER__.loadApp('order-app', container)
        .then(() => {
          console.log('订单应用加载成功');
        })
        .catch(error => {
          console.error('订单应用加载失败:', error);
        });
      break;
    default:
      console.log('未知路由:', route);
  }
}

// 监听路由变化
window.addEventListener('popstate', () => {
  handleRouteChange(window.location.pathname);
});

// 预加载应用
function preloadApps() {
  // 预加载用户应用
  window.__MF_LAZY_APP_LOADER__.preloadApp('user-app');
  
  // 延迟预加载订单应用
  setTimeout(() => {
    window.__MF_LAZY_APP_LOADER__.preloadApp('order-app');
  }, 3000);
}

// 页面空闲时预加载
if ('requestIdleCallback' in window) {
  requestIdleCallback(preloadApps);
} else {
  setTimeout(preloadApps, 1000);
}
```

### 10.2.2 依赖共享

实现微应用间的依赖共享，减少重复加载：

```javascript
// 依赖共享管理器
class DependencySharingManager {
  constructor() {
    this.sharedDependencies = new Map();
    this.loadedDependencies = new Map();
    this.dependencyVersions = new Map();
  }
  
  // 注册共享依赖
  registerDependency(name, config) {
    this.sharedDependencies.set(name, {
      url: config.url,
      version: config.version,
      global: config.global || name,
      type: config.type || 'script',
      ...config
    });
  }
  
  // 加载依赖
  loadDependency(name) {
    // 如果依赖已加载，直接返回
    if (this.loadedDependencies.has(name)) {
      return Promise.resolve(this.loadedDependencies.get(name));
    }
    
    // 获取依赖配置
    const config = this.sharedDependencies.get(name);
    if (!config) {
      return Promise.reject(new Error(`依赖 ${name} 未注册`));
    }
    
    // 加载依赖
    return this.doLoadDependency(name, config);
  }
  
  // 执行依赖加载
  doLoadDependency(name, config) {
    if (config.type === 'script') {
      return this.loadScript(name, config);
    } else if (config.type === 'style') {
      return this.loadStyle(name, config);
    } else {
      return Promise.reject(new Error(`不支持的依赖类型: ${config.type}`));
    }
  }
  
  // 加载脚本依赖
  loadScript(name, config) {
    return new Promise((resolve, reject) => {
      // 检查全局变量是否已存在
      if (window[config.global]) {
        this.loadedDependencies.set(name, window[config.global]);
        resolve(window[config.global]);
        return;
      }
      
      // 创建脚本元素
      const script = document.createElement('script');
      script.src = config.url;
      script.async = true;
      
      script.onload = () => {
        // 检查全局变量
        if (window[config.global]) {
          this.loadedDependencies.set(name, window[config.global]);
          resolve(window[config.global]);
        } else {
          reject(new Error(`依赖 ${name} 加载后未找到全局变量 ${config.global}`));
        }
      };
      
      script.onerror = () => {
        reject(new Error(`依赖 ${name} 加载失败`));
      };
      
      // 添加到head
      document.head.appendChild(script);
    });
  }
  
  // 加载样式依赖
  loadStyle(name, config) {
    return new Promise((resolve, reject) => {
      // 检查样式是否已加载
      const existingLink = document.querySelector(`link[href="${config.url}"]`);
      if (existingLink) {
        this.loadedDependencies.set(name, existingLink);
        resolve(existingLink);
        return;
      }
      
      // 创建链接元素
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = config.url;
      
      link.onload = () => {
        this.loadedDependencies.set(name, link);
        resolve(link);
      };
      
      link.onerror = () => {
        reject(new Error(`依赖 ${name} 加载失败`));
      };
      
      // 添加到head
      document.head.appendChild(link);
    });
  }
  
  // 批量加载依赖
  loadDependencies(names) {
    const promises = names.map(name => this.loadDependency(name));
    return Promise.all(promises);
  }
  
  // 获取依赖
  getDependency(name) {
    return this.loadedDependencies.get(name);
  }
  
  // 检查依赖是否已加载
  isDependencyLoaded(name) {
    return this.loadedDependencies.has(name);
  }
  
  // 卸载依赖
  unloadDependency(name) {
    if (this.loadedDependencies.has(name)) {
      const dependency = this.loadedDependencies.get(name);
      
      // 从DOM中移除
      if (dependency.parentNode) {
        dependency.parentNode.removeChild(dependency);
      }
      
      // 从缓存中移除
      this.loadedDependencies.delete(name);
    }
  }
  
  // 获取依赖信息
  getDependencyInfo(name) {
    const config = this.sharedDependencies.get(name);
    const loaded = this.isDependencyLoaded(name);
    
    return {
      name,
      config,
      loaded,
      version: config ? config.version : null
    };
  }
  
  // 获取所有依赖信息
  getAllDependenciesInfo() {
    const info = [];
    
    this.sharedDependencies.forEach((config, name) => {
      info.push(this.getDependencyInfo(name));
    });
    
    return info;
  }
}

// 创建全局依赖共享管理器
window.__MF_DEPENDENCY_SHARING_MANAGER__ = new DependencySharingManager();

// 注册共享依赖
window.__MF_DEPENDENCY_SHARING_MANAGER__.registerDependency('react', {
  url: 'https://cdn.jsdelivr.net/npm/react@17.0.2/umd/react.production.min.js',
  version: '17.0.2',
  global: 'React',
  type: 'script'
});

window.__MF_DEPENDENCY_SHARING_MANAGER__.registerDependency('react-dom', {
  url: 'https://cdn.jsdelivr.net/npm/react-dom@17.0.2/umd/react-dom.production.min.js',
  version: '17.0.2',
  global: 'ReactDOM',
  type: 'script'
});

window.__MF_DEPENDENCY_SHARING_MANAGER__.registerDependency('vue', {
  url: 'https://cdn.jsdelivr.net/npm/vue@3.2.31/dist/vue.global.prod.js',
  version: '3.2.31',
  global: 'Vue',
  type: 'script'
});

window.__MF_DEPENDENCY_SHARING_MANAGER__.registerDependency('antd', {
  url: 'https://cdn.jsdelivr.net/npm/antd@4.19.5/dist/antd.min.css',
  version: '4.19.5',
  type: 'style'
});

// 微应用依赖加载器
class MicroAppDependencyLoader {
  constructor() {
    this.appDependencies = new Map();
  }
  
  // 注册应用依赖
  registerAppDependencies(appName, dependencies) {
    this.appDependencies.set(appName, dependencies);
  }
  
  // 加载应用依赖
  loadAppDependencies(appName) {
    const dependencies = this.appDependencies.get(appName);
    if (!dependencies) {
      return Promise.resolve([]);
    }
    
    // 过滤已加载的依赖
    const unloadedDependencies = dependencies.filter(dep => {
      return !window.__MF_DEPENDENCY_SHARING_MANAGER__.isDependencyLoaded(dep);
    });
    
    // 加载未加载的依赖
    return window.__MF_DEPENDENCY_SHARING_MANAGER__.loadDependencies(unloadedDependencies);
  }
  
  // 获取应用依赖信息
  getAppDependenciesInfo(appName) {
    const dependencies = this.appDependencies.get(appName) || [];
    
    return dependencies.map(dep => {
      return window.__MF_DEPENDENCY_SHARING_MANAGER__.getDependencyInfo(dep);
    });
  }
}

// 创建全局应用依赖加载器
window.__MF_APP_DEPENDENCY_LOADER__ = new MicroAppDependencyLoader();

// 注册应用依赖
window.__MF_APP_DEPENDENCY_LOADER__.registerAppDependencies('user-app', [
  'react',
  'react-dom',
  'antd'
]);

window.__MF_APP_DEPENDENCY_LOADER__.registerAppDependencies('order-app', [
  'react',
  'react-dom',
  'antd'
]);

// 加载应用前先加载依赖
function loadAppWithDependencies(appName, container) {
  // 加载应用依赖
  return window.__MF_APP_DEPENDENCY_LOADER__.loadAppDependencies(appName)
    .then(() => {
      // 加载应用
      return window.__MF_LAZY_APP_LOADER__.loadApp(appName, container);
    })
    .then(app => {
      console.log(`应用 ${appName} 及其依赖加载成功`);
      return app;
    })
    .catch(error => {
      console.error(`应用 ${appName} 或其依赖加载失败:`, error);
      throw error;
    });
}

// 路由变化时加载应用及其依赖
function handleRouteChangeWithDependencies(route) {
  const container = document.getElementById('app-container');
  container.innerHTML = '';
  
  switch (route) {
    case '/user':
      loadAppWithDependencies('user-app', container);
      break;
    case '/order':
      loadAppWithDependencies('order-app', container);
      break;
    default:
      console.log('未知路由:', route);
  }
}
```

## 10.3 运行时性能优化

### 10.3.1 应用沙箱优化

优化微前端应用沙箱，减少运行时开销：

```javascript
// 优化版应用沙箱
class OptimizedAppSandbox {
  constructor(name, options = {}) {
    this.name = name;
    this.options = options;
    
    // 沙箱状态
    this.active = false;
    this.sandboxWindow = null;
    
    // 性能优化配置
    this.strictIsolation = options.strictIsolation || false;
    this.lazyProxy = options.lazyProxy || false;
    this.proxyCache = new Map();
    
    // 沙箱变量
    this.originalWindow = window;
    this.injectedProperties = new Map();
    this.modifiedProperties = new Map();
    
    // 性能监控
    this.performanceMetrics = {
      proxyAccessCount: 0,
      proxySetCount: 0,
      proxyCacheHitCount: 0
    };
  }
  
  // 激活沙箱
  activate() {
    if (this.active) return;
    
    // 创建沙箱窗口
    this.createSandboxWindow();
    
    // 激活沙箱
    this.active = true;
    
    // 记录激活时间
    this.activateTime = performance.now();
  }
  
  // 创建沙箱窗口
  createSandboxWindow() {
    // 如果启用懒代理，使用优化版代理
    if (this.lazyProxy) {
      this.sandboxWindow = this.createLazyProxyWindow();
    } else {
      this.sandboxWindow = this.createStandardProxyWindow();
    }
  }
  
  // 创建标准代理窗口
  createStandardProxyWindow() {
    const self = this;
    
    return new Proxy(this.originalWindow, {
      get(target, prop) {
        // 性能监控
        self.performanceMetrics.proxyAccessCount++;
        
        // 检查缓存
        if (self.proxyCache.has(prop)) {
          self.performanceMetrics.proxyCacheHitCount++;
          return self.proxyCache.get(prop);
        }
        
        let value;
        
        // 检查修改的属性
        if (self.modifiedProperties.has(prop)) {
          value = self.modifiedProperties.get(prop);
        } 
        // 检查注入的属性
        else if (self.injectedProperties.has(prop)) {
          value = self.injectedProperties.get(prop);
        }
        // 获取原始属性
        else {
          value = target[prop];
        }
        
        // 缓存结果
        self.proxyCache.set(prop, value);
        
        return value;
      },
      
      set(target, prop, value) {
        // 性能监控
        self.performanceMetrics.proxySetCount++;
        
        // 记录修改的属性
        self.modifiedProperties.set(prop, value);
        
        // 清除缓存
        self.proxyCache.delete(prop);
        
        return true;
      },
      
      has(target, prop) {
        return prop in target || 
               self.injectedProperties.has(prop) || 
               self.modifiedProperties.has(prop);
      },
      
      deleteProperty(target, prop) {
        // 删除修改的属性
        if (self.modifiedProperties.has(prop)) {
          self.modifiedProperties.delete(prop);
          self.proxyCache.delete(prop);
          return true;
        }
        
        // 删除注入的属性
        if (self.injectedProperties.has(prop)) {
          self.injectedProperties.delete(prop);
          self.proxyCache.delete(prop);
          return true;
        }
        
        // 删除原始属性
        delete target[prop];
        self.proxyCache.delete(prop);
        
        return true;
      }
    });
  }
  
  // 创建懒代理窗口
  createLazyProxyWindow() {
    const self = this;
    
    return new Proxy(this.originalWindow, {
      get(target, prop) {
        // 性能监控
        self.performanceMetrics.proxyAccessCount++;
        
        // 检查缓存
        if (self.proxyCache.has(prop)) {
          self.performanceMetrics.proxyCacheHitCount++;
          return self.proxyCache.get(prop);
        }
        
        let value;
        
        // 检查修改的属性
        if (self.modifiedProperties.has(prop)) {
          value = self.modifiedProperties.get(prop);
        } 
        // 检查注入的属性
        else if (self.injectedProperties.has(prop)) {
          value = self.injectedProperties.get(prop);
        }
        // 获取原始属性
        else {
          // 懒加载策略：只获取实际访问的属性
          value = target[prop];
          
          // 对于函数属性，绑定原始窗口
          if (typeof value === 'function' && !self.strictIsolation) {
            value = value.bind(target);
          }
        }
        
        // 缓存结果
        self.proxyCache.set(prop, value);
        
        return value;
      },
      
      set(target, prop, value) {
        // 性能监控
        self.performanceMetrics.proxySetCount++;
        
        // 记录修改的属性
        this.modifiedProperties.set(prop, value);
        
        // 清除缓存
        this.proxyCache.delete(prop);
        
        return true;
      },
      
      // 其他代理方法...
      has(target, prop) {
        return prop in target || 
               this.injectedProperties.has(prop) || 
               this.modifiedProperties.has(prop);
      },
      
      deleteProperty(target, prop) {
        if (this.modifiedProperties.has(prop)) {
          this.modifiedProperties.delete(prop);
          this.proxyCache.delete(prop);
          return true;
        }
        
        if (this.injectedProperties.has(prop)) {
          this.injectedProperties.delete(prop);
          this.proxyCache.delete(prop);
          return true;
        }
        
        delete target[prop];
        this.proxyCache.delete(prop);
        
        return true;
      }
    });
  }
  
  // 注入全局变量
  injectGlobal(name, value) {
    this.injectedProperties.set(name, value);
    this.proxyCache.delete(name);
  }
  
  // 移除全局变量
  removeGlobal(name) {
    this.injectedProperties.delete(name);
    this.modifiedProperties.delete(name);
    this.proxyCache.delete(name);
  }
  
  // 获取沙箱窗口
  getSandboxWindow() {
    return this.sandboxWindow;
  }
  
  // 清除代理缓存
  clearProxyCache() {
    this.proxyCache.clear();
  }
  
  // 获取性能指标
  getPerformanceMetrics() {
    const cacheHitRate = this.performanceMetrics.proxyAccessCount > 0 
      ? (this.performanceMetrics.proxyCacheHitCount / this.performanceMetrics.proxyAccessCount * 100).toFixed(2)
      : 0;
      
    return {
      ...this.performanceMetrics,
      cacheHitRate: `${cacheHitRate}%`,
      proxyCacheSize: this.proxyCache.size,
      modifiedPropertiesCount: this.modifiedProperties.size,
      injectedPropertiesCount: this.injectedProperties.size
    };
  }
  
  // 重置性能指标
  resetPerformanceMetrics() {
    this.performanceMetrics = {
      proxyAccessCount: 0,
      proxySetCount: 0,
      proxyCacheHitCount: 0
    };
  }
  
  // 停用沙箱
  deactivate() {
    if (!this.active) return;
    
    // 清理代理缓存
    this.clearProxyCache();
    
    // 停用沙箱
    this.active = false;
    
    // 记录停用时间
    this.deactivateTime = performance.now();
    this.activeDuration = this.deactivateTime - this.activateTime;
  }
  
  // 销毁沙箱
  destroy() {
    // 停用沙箱
    this.deactivate();
    
    // 清理数据
    this.injectedProperties.clear();
    this.modifiedProperties.clear();
    this.proxyCache.clear();
    
    // 重置状态
    this.sandboxWindow = null;
  }
}

// 沙箱管理器
class SandboxManager {
  constructor() {
    this.sandboxes = new Map();
    this.activeSandbox = null;
    this.sandboxPool = [];
    this.maxPoolSize = 5;
  }
  
  // 创建沙箱
  createSandbox(name, options = {}) {
    // 尝试从池中获取沙箱
    let sandbox = this.getSandboxFromPool();
    
    if (!sandbox) {
      // 创建新沙箱
      sandbox = new OptimizedAppSandbox(name, options);
    } else {
      // 重置沙箱
      sandbox.name = name;
      sandbox.options = options;
      sandbox.resetPerformanceMetrics();
    }
    
    this.sandboxes.set(name, sandbox);
    return sandbox;
  }
  
  // 从池中获取沙箱
  getSandboxFromPool() {
    if (this.sandboxPool.length > 0) {
      return this.sandboxPool.pop();
    }
    return null;
  }
  
  // 将沙箱放回池中
  returnSandboxToPool(sandbox) {
    if (this.sandboxPool.length < this.maxPoolSize) {
      // 销毁沙箱
      sandbox.destroy();
      // 重置沙箱
      sandbox.name = '';
      sandbox.options = {};
      // 放入池中
      this.sandboxPool.push(sandbox);
    }
  }
  
  // 激活沙箱
  activateSandbox(name) {
    const sandbox = this.sandboxes.get(name);
    if (!sandbox) {
      throw new Error(`沙箱 ${name} 不存在`);
    }
    
    // 停用当前沙箱
    if (this.activeSandbox && this.activeSandbox !== sandbox) {
      this.activeSandbox.deactivate();
    }
    
    // 激活新沙箱
    sandbox.activate();
    this.activeSandbox = sandbox;
    
    return sandbox;
  }
  
  // 停用沙箱
  deactivateSandbox(name) {
    const sandbox = this.sandboxes.get(name);
    if (!sandbox) {
      return;
    }
    
    sandbox.deactivate();
    
    if (this.activeSandbox === sandbox) {
      this.activeSandbox = null;
    }
  }
  
  // 销毁沙箱
  destroySandbox(name) {
    const sandbox = this.sandboxes.get(name);
    if (!sandbox) {
      return;
    }
    
    // 停用沙箱
    sandbox.deactivate();
    
    // 如果是当前激活的沙箱，清除引用
    if (this.activeSandbox === sandbox) {
      this.activeSandbox = null;
    }
    
    // 放回池中
    this.returnSandboxToPool(sandbox);
    
    // 从映射中移除
    this.sandboxes.delete(name);
  }
  
  // 获取当前激活的沙箱
  getActiveSandbox() {
    return this.activeSandbox;
  }
  
  // 获取所有沙箱的性能指标
  getAllSandboxMetrics() {
    const metrics = {};
    
    this.sandboxes.forEach((sandbox, name) => {
      metrics[name] = sandbox.getPerformanceMetrics();
    });
    
    return metrics;
  }
}

// 创建全局沙箱管理器
window.__MF_SANDBOX_MANAGER__ = new SandboxManager();
```

### 10.3.2 内存管理优化

优化微前端应用的内存使用，防止内存泄漏：

```javascript
// 内存管理器
class MemoryManager {
  constructor() {
    this.memoryStats = {
      used: 0,
      total: 0,
      limit: 0
    };
    
    this.memoryThreshold = 100 * 1024 * 1024; // 100MB
    this.cleanupThreshold = 0.8; // 80%
    this.observers = [];
    
    // 监控内存使用
    this.startMemoryMonitoring();
  }
  
  // 开始内存监控
  startMemoryMonitoring() {
    // 定期检查内存使用
    setInterval(() => {
      this.updateMemoryStats();
      this.checkMemoryThreshold();
    }, 5000);
    
    // 页面卸载时清理
    window.addEventListener('beforeunload', () => {
      this.cleanup();
    });
  }
  
  // 更新内存统计
  updateMemoryStats() {
    if (performance.memory) {
      this.memoryStats.used = performance.memory.usedJSHeapSize;
      this.memoryStats.total = performance.memory.totalJSHeapSize;
      this.memoryStats.limit = performance.memory.jsHeapSizeLimit;
    }
  }
  
  // 检查内存阈值
  checkMemoryThreshold() {
    const usageRatio = this.memoryStats.used / this.memoryStats.limit;
    
    if (usageRatio > this.cleanupThreshold) {
      console.warn(`内存使用率过高: ${(usageRatio * 100).toFixed(2)}%`);
      this.performMemoryCleanup();
    }
  }
  
  // 执行内存清理
  performMemoryCleanup() {
    console.log('执行内存清理...');
    
    // 通知观察者
    this.notifyObservers('memory-cleanup', {
      used: this.memoryStats.used,
      total: this.memoryStats.total,
      limit: this.memoryStats.limit
    });
    
    // 清理未使用的应用
    this.cleanupUnusedApps();
    
    // 强制垃圾回收（如果支持）
    if (window.gc) {
      window.gc();
    }
    
    // 更新内存统计
    setTimeout(() => {
      this.updateMemoryStats();
      console.log('内存清理完成:', this.memoryStats);
    }, 1000);
  }
  
  // 清理未使用的应用
  cleanupUnusedApps() {
    // 获取所有应用容器
    const appContainers = document.querySelectorAll('[data-app]');
    
    appContainers.forEach(container => {
      // 检查容器是否可见
      if (container.offsetParent === null) {
        const appName = container.getAttribute('data-app');
        console.log(`清理未使用的应用: ${appName}`);
        
        // 卸载应用
        if (window.__MF_LAZY_APP_LOADER__) {
          window.__MF_LAZY_APP_LOADER__.unloadApp(appName);
        }
      }
    });
  }
  
  // 添加内存观察者
  addObserver(callback) {
    this.observers.push(callback);
  }
  
  // 移除内存观察者
  removeObserver(callback) {
    this.observers = this.observers.filter(obs => obs !== callback);
  }
  
  // 通知观察者
  notifyObservers(event, data) {
    this.observers.forEach(callback => {
      try {
        callback(event, data);
      } catch (error) {
        console.error('内存观察者回调出错:', error);
      }
    });
  }
  
  // 获取内存统计
  getMemoryStats() {
    this.updateMemoryStats();
    return { ...this.memoryStats };
  }
  
  // 设置内存阈值
  setMemoryThreshold(threshold) {
    this.memoryThreshold = threshold;
  }
  
  // 设置清理阈值
  setCleanupThreshold(threshold) {
    this.cleanupThreshold = threshold;
  }
  
  // 清理
  cleanup() {
    // 清理所有应用
    if (window.__MF_LAZY_APP_LOADER__) {
      window.__MF_LAZY_APP_LOADER__.unloadAllApps();
    }
    
    // 清理沙箱
    if (window.__MF_SANDBOX_MANAGER__) {
      window.__MF_SANDBOX_MANAGER__.sandboxes.forEach((sandbox, name) => {
        window.__MF_SANDBOX_MANAGER__.destroySandbox(name);
      });
    }
    
    // 清理依赖
    if (window.__MF_DEPENDENCY_SHARING_MANAGER__) {
      // 这里可以添加依赖清理逻辑
    }
    
    // 强制垃圾回收（如果支持）
    if (window.gc) {
      window.gc();
    }
  }
}

// 创建全局内存管理器
window.__MF_MEMORY_MANAGER__ = new MemoryManager();

// 应用内存监控器
class AppMemoryMonitor {
  constructor(appName) {
    this.appName = appName;
    this.memorySnapshots = [];
    this.maxSnapshots = 10;
    this.monitoringInterval = null;
  }
  
  // 开始监控
  startMonitoring(interval = 5000) {
    if (this.monitoringInterval) {
      return;
    }
    
    // 立即记录一次
    this.recordSnapshot();
    
    // 定期记录
    this.monitoringInterval = setInterval(() => {
      this.recordSnapshot();
    }, interval);
  }
  
  // 停止监控
  stopMonitoring() {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = null;
    }
  }
  
  // 记录内存快照
  recordSnapshot() {
    if (!performance.memory) {
      return;
    }
    
    const snapshot = {
      timestamp: Date.now(),
      used: performance.memory.usedJSHeapSize,
      total: performance.memory.totalJSHeapSize,
      limit: performance.memory.jsHeapSizeLimit
    };
    
    // 添加快照
    this.memorySnapshots.push(snapshot);
    
    // 限制快照数量
    if (this.memorySnapshots.length > this.maxSnapshots) {
      this.memorySnapshots.shift();
    }
  }
  
  // 获取内存趋势
  getMemoryTrend() {
    if (this.memorySnapshots.length < 2) {
      return null;
    }
    
    const first = this.memorySnapshots[0];
    const last = this.memorySnapshots[this.memorySnapshots.length - 1];
    
    const timeDiff = last.timestamp - first.timestamp;
    const memoryDiff = last.used - first.used;
    
    return {
      timeDiff,
      memoryDiff,
      memoryRate: memoryDiff / timeDiff * 1000, // bytes per second
      snapshots: this.memorySnapshots
    };
  }
  
  // 检查内存泄漏
  checkMemoryLeak() {
    const trend = this.getMemoryTrend();
    
    if (!trend) {
      return { hasLeak: false, reason: '数据不足' };
    }
    
    // 如果内存持续增长，可能存在内存泄漏
    if (trend.memoryRate > 1000) { // 1KB/s
      return {
        hasLeak: true,
        reason: `内存增长速率过快: ${(trend.memoryRate / 1024).toFixed(2)} KB/s`,
        trend
      };
    }
    
    // 检查内存使用是否持续增长
    let increasingCount = 0;
    for (let i = 1; i < this.memorySnapshots.length; i++) {
      if (this.memorySnapshots[i].used > this.memorySnapshots[i - 1].used) {
        increasingCount++;
      }
    }
    
    if (increasingCount >= this.memorySnapshots.length * 0.8) {
      return {
        hasLeak: true,
        reason: `内存使用持续增长: ${increasingCount}/${this.memorySnapshots.length}`,
        trend
      };
    }
    
    return { hasLeak: false, reason: '内存使用正常', trend };
  }
  
  // 清理快照
  clearSnapshots() {
    this.memorySnapshots = [];
  }
}

// 应用内存监控器管理
class AppMemoryMonitorManager {
  constructor() {
    this.monitors = new Map();
  }
  
  // 创建应用监控器
  createMonitor(appName) {
    if (this.monitors.has(appName)) {
      return this.monitors.get(appName);
    }
    
    const monitor = new AppMemoryMonitor(appName);
    this.monitors.set(appName, monitor);
    
    return monitor;
  }
  
  // 获取应用监控器
  getMonitor(appName) {
    return this.monitors.get(appName);
  }
  
  // 移除应用监控器
  removeMonitor(appName) {
    const monitor = this.monitors.get(appName);
    if (monitor) {
      monitor.stopMonitoring();
      this.monitors.delete(appName);
    }
  }
  
  // 获取所有监控器的内存泄漏检测结果
  getAllLeakChecks() {
    const results = {};
    
    this.monitors.forEach((monitor, appName) => {
      results[appName] = monitor.checkMemoryLeak();
    });
    
    return results;
  }
  
  // 清理所有监控器
  clearAll() {
    this.monitors.forEach((monitor, appName) => {
      monitor.stopMonitoring();
    });
    
    this.monitors.clear();
  }
}

// 创建全局应用内存监控器管理
window.__MF_APP_MEMORY_MONITOR_MANAGER__ = new AppMemoryMonitorManager();

// 在应用加载时开始内存监控
function startAppMemoryMonitoring(appName) {
  const monitor = window.__MF_APP_MEMORY_MONITOR_MANAGER__.createMonitor(appName);
  monitor.startMonitoring();
  
  console.log(`开始监控应用 ${appName} 的内存使用`);
}

// 在应用卸载时停止内存监控
function stopAppMemoryMonitoring(appName) {
  const monitor = window.__MF_APP_MEMORY_MONITOR_MANAGER__.getMonitor(appName);
  if (monitor) {
    // 检查内存泄漏
    const leakCheck = monitor.checkMemoryLeak();
    if (leakCheck.hasLeak) {
      console.warn(`应用 ${appName} 可能存在内存泄漏:`, leakCheck.reason);
    }
    
    // 停止监控
    monitor.stopMonitoring();
    
    console.log(`停止监控应用 ${appName} 的内存使用`);
  }
}

// 扩展应用加载器，添加内存监控
const originalLoadApp = window.__MF_LAZY_APP_LOADER__.loadApp;
window.__MF_LAZY_APP_LOADER__.loadApp = function(name, container) {
  // 开始内存监控
  startAppMemoryMonitoring(name);
  
  // 调用原始加载方法
  return originalLoadApp.call(this, name, container)
    .then(app => {
      return app;
    })
    .catch(error => {
      // 加载失败时停止内存监控
      stopAppMemoryMonitoring(name);
      throw error;
    });
};

// 扩展应用卸载方法，添加内存监控
const originalUnloadApp = window.__MF_LAZY_APP_LOADER__.unloadApp;
window.__MF_LAZY_APP_LOADER__.unloadApp = function(name) {
  // 停止内存监控
  stopAppMemoryMonitoring(name);
  
  // 调用原始卸载方法
  return originalUnloadApp.call(this, name);
};
```

## 10.4 渲染性能优化

### 10.4.1 虚拟滚动优化

在微前端应用中实现虚拟滚动，提高长列表渲染性能：

```javascript
// 虚拟滚动组件
class VirtualScroll {
  constructor(container, options = {}) {
    this.container = container;
    this.options = {
      itemHeight: options.itemHeight || 50,
      bufferSize: options.bufferSize || 5,
      renderItem: options.renderItem || this.defaultRenderItem,
      getItemCount: options.getItemCount || this.defaultGetItemCount,
      ...options
    };
    
    // 状态
    this.scrollTop = 0;
    this.containerHeight = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    this.visibleItems = [];
    
    // 性能优化
    this.rafId = null;
    this.lastScrollTime = 0;
    this.scrollThrottle = 16; // ~60fps
    
    // 初始化
    this.init();
  }
  
  // 初始化
  init() {
    // 创建滚动容器
    this.createScrollContainer();
    
    // 创建内容容器
    this.createContentContainer();
    
    // 监听滚动事件
    this.bindEvents();
    
    // 更新布局
    this.updateLayout();
    
    // 渲染可见项
    this.renderVisibleItems();
  }
  
  // 创建滚动容器
  createScrollContainer() {
    this.scrollContainer = document.createElement('div');
    this.scrollContainer.className = 'virtual-scroll-container';
    this.scrollContainer.style.cssText = `
      height: 100%;
      overflow-y: auto;
      position: relative;
    `;
    
    // 替换原始容器内容
    this.container.innerHTML = '';
    this.container.appendChild(this.scrollContainer);
  }
  
  // 创建内容容器
  createContentContainer() {
    this.contentContainer = document.createElement('div');
    this.contentContainer.className = 'virtual-scroll-content';
    this.contentContainer.style.cssText = `
      position: relative;
      width: 100%;
    `;
    
    this.scrollContainer.appendChild(this.contentContainer);
  }
  
  // 绑定事件
  bindEvents() {
    this.scrollContainer.addEventListener('scroll', this.handleScroll.bind(this));
    window.addEventListener('resize', this.handleResize.bind(this));
  }
  
  // 处理滚动事件
  handleScroll() {
    const now = performance.now();
    
    // 节流处理
    if (now - this.lastScrollTime < this.scrollThrottle) {
      return;
    }
    
    this.lastScrollTime = now;
    
    // 取消之前的动画帧
    if (this.rafId) {
      cancelAnimationFrame(this.rafId);
    }
    
    // 使用动画帧更新
    this.rafId = requestAnimationFrame(() => {
      this.updateScrollPosition();
      this.renderVisibleItems();
    });
  }
  
  // 处理窗口大小变化
  handleResize() {
    this.updateLayout();
    this.renderVisibleItems();
  }
  
  // 更新布局
  updateLayout() {
    // 更新容器高度
    this.containerHeight = this.scrollContainer.clientHeight;
    
    // 计算总高度
    const itemCount = this.options.getItemCount();
    const totalHeight = itemCount * this.options.itemHeight;
    
    // 设置内容容器高度
    this.contentContainer.style.height = `${totalHeight}px`;
  }
  
  // 更新滚动位置
  updateScrollPosition() {
    this.scrollTop = this.scrollContainer.scrollTop;
    
    // 计算可见范围
    const startIndex = Math.floor(this.scrollTop / this.options.itemHeight);
    const endIndex = Math.min(
      startIndex + Math.ceil(this.containerHeight / this.options.itemHeight) + this.options.bufferSize,
      this.options.getItemCount() - 1
    );
    
    // 更新索引
    this.startIndex = Math.max(0, startIndex - this.options.bufferSize);
    this.endIndex = endIndex;
  }
  
  // 渲染可见项
  renderVisibleItems() {
    // 清空内容容器
    this.contentContainer.innerHTML = '';
    
    // 渲染可见项
    for (let i = this.startIndex; i <= this.endIndex; i++) {
      const item = this.options.renderItem(i);
      
      // 设置项的位置
      item.style.position = 'absolute';
      item.style.top = `${i * this.options.itemHeight}px`;
      item.style.width = '100%';
      item.style.height = `${this.options.itemHeight}px`;
      
      this.contentContainer.appendChild(item);
    }
  }
  
  // 默认渲染项
  defaultRenderItem(index) {
    const item = document.createElement('div');
    item.className = 'virtual-scroll-item';
    item.textContent = `Item ${index}`;
    return item;
  }
  
  // 默认获取项数量
  defaultGetItemCount() {
    return 1000;
  }
  
  // 滚动到指定项
  scrollToItem(index) {
    const scrollTop = index * this.options.itemHeight;
    this.scrollContainer.scrollTop = scrollTop;
  }
  
  // 滚动到顶部
  scrollToTop() {
    this.scrollContainer.scrollTop = 0;
  }
  
  // 滚动到底部
  scrollToBottom() {
    this.scrollContainer.scrollTop = this.scrollContainer.scrollHeight;
  }
  
  // 刷新
  refresh() {
    this.updateLayout();
    this.renderVisibleItems();
  }
  
  // 销毁
  destroy() {
    // 取消动画帧
    if (this.rafId) {
      cancelAnimationFrame(this.rafId);
    }
    
    // 移除事件监听
    this.scrollContainer.removeEventListener('scroll', this.handleScroll);
    window.removeEventListener('resize', this.handleResize);
    
    // 清空容器
    this.container.innerHTML = '';
  }
}

// 虚拟滚动工厂
class VirtualScrollFactory {
  static create(container, options) {
    return new VirtualScroll(container, options);
  }
}

// 在微前端应用中使用虚拟滚动
function createVirtualListInMicroApp(appName, containerSelector, options) {
  // 等待应用加载完成
  const checkAppLoaded = () => {
    const container = document.querySelector(containerSelector);
    if (container) {
      // 创建虚拟滚动
      const virtualScroll = VirtualScrollFactory.create(container, options);
      
      // 缓存虚拟滚动实例
      if (!window.__MF_VIRTUAL_SCROLLS__) {
        window.__MF_VIRTUAL_SCROLLS__ = {};
      }
      window.__MF_VIRTUAL_SCROLLS__[appName] = virtualScroll;
      
      console.log(`应用 ${appName} 的虚拟滚动创建成功`);
    } else {
      // 应用未加载完成，延迟检查
      setTimeout(checkAppLoaded, 100);
    }
  };
  
  checkAppLoaded();
}

// 用户应用虚拟滚动配置
function setupUserAppVirtualScroll() {
  createVirtualListInMicroApp('user-app', '#user-list-container', {
    itemHeight: 60,
    bufferSize: 3,
    getItemCount: () => {
      // 获取用户列表长度
      return window.__USER_LIST__ ? window.__USER_LIST__.length : 0;
    },
    renderItem: (index) => {
      // 获取用户数据
      const user = window.__USER_LIST__ ? window.__USER_LIST__[index] : null;
      
      // 创建项元素
      const item = document.createElement('div');
      item.className = 'user-item';
      item.style.cssText = `
        display: flex;
        align-items: center;
        padding: 10px;
        border-bottom: 1px solid #eee;
        box-sizing: border-box;
      `;
      
      if (user) {
        item.innerHTML = `
          <img src="${user.avatar}" alt="${user.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
          <div>
            <div style="font-weight: bold;">${user.name}</div>
            <div style="color: #666; font-size: 12px;">${user.email}</div>
          </div>
        `;
      } else {
        item.innerHTML = `
          <div style="padding: 10px;">加载中...</div>
        `;
      }
      
      return item;
    }
  });
}

// 订单应用虚拟滚动配置
function setupOrderAppVirtualScroll() {
  createVirtualListInMicroApp('order-app', '#order-list-container', {
    itemHeight: 80,
    bufferSize: 2,
    getItemCount: () => {
      // 获取订单列表长度
      return window.__ORDER_LIST__ ? window.__ORDER_LIST__.length : 0;
    },
    renderItem: (index) => {
      // 获取订单数据
      const order = window.__ORDER_LIST__ ? window.__ORDER_LIST__[index] : null;
      
      // 创建项元素
      const item = document.createElement('div');
      item.className = 'order-item';
      item.style.cssText = `
        padding: 15px;
        border-bottom: 1px solid #eee;
        box-sizing: border-box;
      `;
      
      if (order) {
        const statusColor = order.status === 'completed' ? '#28a745' : '#ffc107';
        
        item.innerHTML = `
          <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
            <div style="font-weight: bold;">订单 #${order.id}</div>
            <div style="color: ${statusColor};">${order.statusText}</div>
          </div>
          <div style="color: #666; font-size: 14px;">
            <div>商品：${order.product}</div>
            <div>价格：￥${order.price}</div>
            <div>下单时间：${order.time}</div>
          </div>
        `;
      } else {
        item.innerHTML = `
          <div style="padding: 10px;">加载中...</div>
        `;
      }
      
      return item;
    }
  });
}

// 在应用加载后设置虚拟滚动
function setupVirtualScrollForApp(appName) {
  switch (appName) {
    case 'user-app':
      setupUserAppVirtualScroll();
      break;
    case 'order-app':
      setupOrderAppVirtualScroll();
      break;
    default:
      console.log(`应用 ${appName} 没有配置虚拟滚动`);
  }
}

// 扩展应用加载器，添加虚拟滚动设置
const originalLoadAppWithDependencies = window.loadAppWithDependencies;
window.loadAppWithDependencies = function(appName, container) {
  // 调用原始加载方法
  return originalLoadAppWithDependencies.call(this, appName, container)
    .then(app => {
      // 设置虚拟滚动
      setupVirtualScrollForApp(appName);
      
      return app;
    });
};
```

### 10.4.2 懒加载优化

实现微前端应用的懒加载优化，提高初始加载性能：

```javascript
// 懒加载管理器
class LazyLoadManager {
  constructor() {
    this.observers = new Map();
    this.loadedItems = new Set();
    this.loadingItems = new Set();
    this.defaultThreshold = 0.1;
    this.defaultRootMargin = '50px';
  }
  
  // 创建观察者
  createObserver(callback, options = {}) {
    const threshold = options.threshold || this.defaultThreshold;
    const rootMargin = options.rootMargin || this.defaultRootMargin;
    
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const target = entry.target;
          const key = this.getItemKey(target);
          
          // 如果未加载且未在加载中
          if (!this.loadedItems.has(key) && !this.loadingItems.has(key)) {
            this.loadingItems.add(key);
            
            // 执行回调
            callback(target)
              .then(() => {
                // 标记为已加载
                this.loadedItems.add(key);
                this.loadingItems.delete(key);
                
                // 停止观察
                observer.unobserve(target);
              })
              .catch(error => {
                console.error('懒加载失败:', error);
                this.loadingItems.delete(key);
              });
          }
        }
      });
    }, {
      threshold,
      rootMargin
    });
    
    return observer;
  }
  
  // 获取项的键
  getItemKey(target) {
    return target.getAttribute('data-lazy-key') || target.src || target.innerHTML;
  }
  
  // 观察元素
  observe(element, callback, options) {
    // 创建观察者
    const observer = this.createObserver(callback, options);
    
    // 观察元素
    observer.observe(element);
    
    // 缓存观察者
    const key = this.getItemKey(element);
    this.observers.set(key, observer);
    
    return observer;
  }
  
  // 停止观察元素
  unobserve(element) {
    const key = this.getItemKey(element);
    const observer = this.observers.get(key);
    
    if (observer) {
      observer.unobserve(element);
      this.observers.delete(key);
    }
  }
  
  // 检查是否已加载
  isLoaded(key) {
    return this.loadedItems.has(key);
  }
  
  // 检查是否正在加载
  isLoading(key) {
    return this.loadingItems.has(key);
  }
  
  // 清理
  cleanup() {
    this.observers.forEach(observer => {
      observer.disconnect();
    });
    
    this.observers.clear();
    this.loadedItems.clear();
    this.loadingItems.clear();
  }
}

// 创建全局懒加载管理器
window.__MF_LAZY_LOAD_MANAGER__ = new LazyLoadManager();

// 图片懒加载
function lazyLoadImages(container = document) {
  const images = container.querySelectorAll('img[data-lazy-src]');
  
  images.forEach(img => {
    // 设置懒加载键
    if (!img.getAttribute('data-lazy-key')) {
      img.setAttribute('data-lazy-key', img.getAttribute('data-lazy-src'));
    }
    
    // 观察图片
    window.__MF_LAZY_LOAD_MANAGER__.observe(img, (target) => {
      return new Promise((resolve) => {
        // 创建新图片对象预加载
        const newImg = new Image();
        
        newImg.onload = () => {
          // 设置图片源
          target.src = target.getAttribute('data-lazy-src');
          target.removeAttribute('data-lazy-src');
          
          // 添加加载完成类
          target.classList.add('lazy-loaded');
          
          resolve();
        };
        
        newImg.onerror = () => {
          // 加载失败，使用默认图片
          target.src = '/placeholder.jpg';
          target.removeAttribute('data-lazy-src');
          
          // 添加加载失败类
          target.classList.add('lazy-error');
          
          resolve();
        };
        
        // 开始加载
        newImg.src = target.getAttribute('data-lazy-src');
      });
    }, {
      threshold: 0.1,
      rootMargin: '50px'
    });
  });
}

// 组件懒加载
function lazyLoadComponents(container = document) {
  const components = container.querySelectorAll('[data-lazy-component]');
  
  components.forEach(component => {
    // 设置懒加载键
    if (!component.getAttribute('data-lazy-key')) {
      component.setAttribute('data-lazy-key', component.getAttribute('data-lazy-component'));
    }
    
    // 观察组件
    window.__MF_LAZY_LOAD_MANAGER__.observe(component, (target) => {
      return new Promise((resolve) => {
        const componentName = target.getAttribute('data-lazy-component');
        
        // 动态导入组件
        import(`./components/${componentName}.js`)
          .then(module => {
            const ComponentClass = module.default;
            
            // 创建组件实例
            const componentInstance = new ComponentClass();
            
            // 渲染组件
            target.innerHTML = '';
            target.appendChild(componentInstance.render());
            
            // 移除懒加载属性
            target.removeAttribute('data-lazy-component');
            
            // 添加加载完成类
            target.classList.add('lazy-loaded');
            
            resolve();
          })
          .catch(error => {
            console.error(`组件 ${componentName} 加载失败:`, error);
            
            // 显示错误信息
            target.innerHTML = `<div class="lazy-error">组件加载失败</div>`;
            
            resolve();
          });
      });
    }, {
      threshold: 0.1,
      rootMargin: '50px'
    });
  });
}

// 应用懒加载
function lazyLoadApps(container = document) {
  const apps = container.querySelectorAll('[data-lazy-app]');
  
  apps.forEach(app => {
    // 设置懒加载键
    if (!app.getAttribute('data-lazy-key')) {
      app.setAttribute('data-lazy-key', app.getAttribute('data-lazy-app'));
    }
    
    // 观察应用
    window.__MF_LAZY_LOAD_MANAGER__.observe(app, (target) => {
      return new Promise((resolve) => {
        const appName = target.getAttribute('data-lazy-app');
        
        // 加载应用
        loadAppWithDependencies(appName, target)
          .then(() => {
            // 移除懒加载属性
            target.removeAttribute('data-lazy-app');
            
            // 添加加载完成类
            target.classList.add('lazy-loaded');
            
            resolve();
          })
          .catch(error => {
            console.error(`应用 ${appName} 加载失败:`, error);
            
            // 显示错误信息
            target.innerHTML = `<div class="lazy-error">应用加载失败</div>`;
            
            resolve();
          });
      });
    }, {
      threshold: 0.1,
      rootMargin: '100px' // 应用需要更大的预加载区域
    });
  });
}

// 初始化懒加载
function initLazyLoad() {
  // 图片懒加载
  lazyLoadImages();
  
  // 组件懒加载
  lazyLoadComponents();
  
  // 应用懒加载
  lazyLoadApps();
  
  console.log('懒加载初始化完成');
}

// 在DOM变化后重新初始化懒加载
function reinitLazyLoad(container = document) {
  // 图片懒加载
  lazyLoadImages(container);
  
  // 组件懒加载
  lazyLoadComponents(container);
  
  // 应用懒加载
  lazyLoadApps(container);
}

// 使用MutationObserver监听DOM变化
function observeDOMChanges() {
  const observer = new MutationObserver((mutations) => {
    let shouldReinit = false;
    
    mutations.forEach(mutation => {
      // 检查是否有新增节点
      if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
        shouldReinit = true;
      }
    });
    
    if (shouldReinit) {
      // 延迟重新初始化，避免频繁触发
      setTimeout(reinitLazyLoad, 100);
    }
  });
  
  // 观察整个文档
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
  
  return observer;
}

// 页面加载完成后初始化懒加载
document.addEventListener('DOMContentLoaded', () => {
  initLazyLoad();
  observeDOMChanges();
});

// 扩展应用加载器，添加懒加载支持
const originalLoadApp = window.__MF_LAZY_APP_LOADER__.loadApp;
window.__MF_LAZY_APP_LOADER__.loadApp = function(name, container) {
  // 调用原始加载方法
  return originalLoadApp.call(this, name, container)
    .then(app => {
      // 重新初始化懒加载
      reinitLazyLoad(container);
      
      return app;
    });
};
```

## 10.5 性能监控与分析

### 10.5.1 性能监控

实现微前端应用的性能监控，收集性能数据：

```javascript
// 性能监控器
class PerformanceMonitor {
  constructor() {
    this.metrics = {
      navigation: {},
      resources: [],
      paint: {},
      memory: {},
      userTiming: []
    };
    
    this.observers = [];
    this.isMonitoring = false;
    
    // 性能阈值
    this.thresholds = {
      fcp: 2000, // 首次内容绘制 2s
      lcp: 2500, // 最大内容绘制 2.5s
      fid: 100,  // 首次输入延迟 100ms
      cls: 0.1,  // 累积布局偏移 0.1
      tti: 3800  // 首次可交互时间 3.8s
    };
  }
  
  // 开始监控
  startMonitoring() {
    if (this.isMonitoring) return;
    
    this.isMonitoring = true;
    
    // 收集导航计时
    this.collectNavigationTiming();
    
    // 收集资源计时
    this.collectResourceTiming();
    
    // 收集绘制计时
    this.collectPaintTiming();
    
    // 收集内存信息
    this.collectMemoryInfo();
    
    // 收集用户计时
    this.collectUserTiming();
    
    // 监控性能指标
    this.observePerformanceMetrics();
    
    // 监控长任务
    this.observeLongTasks();
    
    console.log('性能监控已启动');
  }
  
  // 停止监控
  stopMonitoring() {
    if (!this.isMonitoring) return;
    
    this.isMonitoring = false;
    
    // 断开所有观察者
    this.observers.forEach(observer => {
      observer.disconnect();
    });
    
    this.observers = [];
    
    console.log('性能监控已停止');
  }
  
  // 收集导航计时
  collectNavigationTiming() {
    if (!performance.getEntriesByType) return;
    
    const navigationEntries = performance.getEntriesByType('navigation');
    
    if (navigationEntries.length > 0) {
      const navigation = navigationEntries[0];
      
      this.metrics.navigation = {
        // DNS查询时间
        dnsLookup: navigation.domainLookupEnd - navigation.domainLookupStart,
        
        // TCP连接时间
        tcpConnection: navigation.connectEnd - navigation.connectStart,
        
        // 请求响应时间
        requestResponse: navigation.responseEnd - navigation.requestStart,
        
        // DOM解析时间
        domParsing: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
        
        // 页面加载时间
        pageLoad: navigation.loadEventEnd - navigation.loadEventStart,
        
        // 首次可交互时间
        timeToInteractive: navigation.domInteractive - navigation.navigationStart,
        
        // 完整加载时间
        loadTime: navigation.loadEventEnd - navigation.navigationStart
      };
    }
  }
  
  // 收集资源计时
  collectResourceTiming() {
    if (!performance.getEntriesByType) return;
    
    const resourceEntries = performance.getEntriesByType('resource');
    
    this.metrics.resources = resourceEntries.map(entry => ({
      name: entry.name,
      type: this.getResourceType(entry.name),
      duration: entry.duration,
      size: entry.transferSize || 0,
      startTime: entry.startTime,
      responseEnd: entry.responseEnd
    }));
  }
  
  // 获取资源类型
  getResourceType(url) {
    if (url.includes('.js')) return 'script';
    if (url.includes('.css')) return 'stylesheet';
    if (url.match(/\.(png|jpg|jpeg|gif|svg|webp)$/)) return 'image';
    if (url.match(/\.(woff|woff2|ttf|eot)$/)) return 'font';
    return 'other';
  }
  
  // 收集绘制计时
  collectPaintTiming() {
    if (!performance.getEntriesByType) return;
    
    const paintEntries = performance.getEntriesByType('paint');
    
    paintEntries.forEach(entry => {
      this.metrics.paint[entry.name] = entry.startTime;
    });
  }
  
  // 收集内存信息
  collectMemoryInfo() {
    if (!performance.memory) return;
    
    this.metrics.memory = {
      used: performance.memory.usedJSHeapSize,
      total: performance.memory.totalJSHeapSize,
      limit: performance.memory.jsHeapSizeLimit
    };
  }
  
  // 收集用户计时
  collectUserTiming() {
    if (!performance.getEntriesByType) return;
    
    const userTimingEntries = performance.getEntriesByType('measure');
    
    this.metrics.userTiming = userTimingEntries.map(entry => ({
      name: entry.name,
      duration: entry.duration,
      startTime: entry.startTime
    }));
  }
  
  // 监控性能指标
  observePerformanceMetrics() {
    // 监控FCP
    this.observeFCP();
    
    // 监控LCP
    this.observeLCP();
    
    // 监控FID
    this.observeFID();
    
    // 监控CLS
    this.observeCLS();
    
    // 监控TTI
    this.observeTTI();
  }
  
  // 监控FCP
  observeFCP() {
    if (!PerformanceObserver) return;
    
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      
      entries.forEach(entry => {
        if (entry.name === 'first-contentful-paint') {
          this.metrics.paint.fcp = entry.startTime;
          
          // 检查阈值
          if (entry.startTime > this.thresholds.fcp) {
            console.warn(`FCP超过阈值: ${entry.startTime.toFixed(2)}ms > ${this.thresholds.fcp}ms`);
          }
        }
      });
    });
    
    observer.observe({ entryTypes: ['paint'] });
    this.observers.push(observer);
  }
  
  // 监控LCP
  observeLCP() {
    if (!PerformanceObserver) return;
    
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      const lastEntry = entries[entries.length - 1];
      
      this.metrics.paint.lcp = lastEntry.startTime;
      
      // 检查阈值
      if (lastEntry.startTime > this.thresholds.lcp) {
        console.warn(`LCP超过阈值: ${lastEntry.startTime.toFixed(2)}ms > ${this.thresholds.lcp}ms`);
      }
    });
    
    observer.observe({ entryTypes: ['largest-contentful-paint'] });
    this.observers.push(observer);
  }
  
  // 监控FID
  observeFID() {
    if (!PerformanceObserver) return;
    
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      
      entries.forEach(entry => {
        if (entry.name === 'first-input') {
          this.metrics.paint.fid = entry.processingStart - entry.startTime;
          
          // 检查阈值
          if (entry.processingStart - entry.startTime > this.thresholds.fid) {
            console.warn(`FID超过阈值: ${(entry.processingStart - entry.startTime).toFixed(2)}ms > ${this.thresholds.fid}ms`);
          }
        }
      });
    });
    
    observer.observe({ entryTypes: ['first-input'] });
    this.observers.push(observer);
  }
  
  // 监控CLS
  observeCLS() {
    if (!PerformanceObserver) return;
    
    let clsValue = 0;
    
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      
      entries.forEach(entry => {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
          this.metrics.paint.cls = clsValue;
          
          // 检查阈值
          if (clsValue > this.thresholds.cls) {
            console.warn(`CLS超过阈值: ${clsValue.toFixed(4)} > ${this.thresholds.cls}`);
          }
        }
      });
    });
    
    observer.observe({ entryTypes: ['layout-shift'] });
    this.observers.push(observer);
  }
  
  // 监控TTI
  observeTTI() {
    // 简化的TTI计算，实际项目中可以使用更精确的库
    setTimeout(() => {
      if (performance.timing) {
        const tti = performance.timing.domInteractive - performance.timing.navigationStart;
        this.metrics.navigation.tti = tti;
        
        // 检查阈值
        if (tti > this.thresholds.tti) {
          console.warn(`TTI超过阈值: ${tti}ms > ${this.thresholds.tti}ms`);
        }
      }
    }, 5000);
  }
  
  // 监控长任务
  observeLongTasks() {
    if (!PerformanceObserver) return;
    
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      
      entries.forEach(entry => {
        if (entry.duration > 50) { // 长任务阈值50ms
          console.warn(`检测到长任务: ${entry.name} - ${entry.duration.toFixed(2)}ms`);
        }
      });
    });
    
    observer.observe({ entryTypes: ['longtask'] });
    this.observers.push(observer);
  }
  
  // 标记用户计时
  mark(name) {
    if (performance.mark) {
      performance.mark(name);
    }
  }
  
  // 测量用户计时
  measure(name, startMark, endMark) {
    if (performance.measure) {
      performance.measure(name, startMark, endMark);
    }
  }
  
  // 获取性能指标
  getMetrics() {
    // 更新内存信息
    this.collectMemoryInfo();
    
    return { ...this.metrics };
  }
  
  // 获取性能评分
  getPerformanceScore() {
    const metrics = this.getMetrics();
    let score = 100;
    
    // FCP评分
    if (metrics.paint.fcp) {
      if (metrics.paint.fcp > this.thresholds.fcp) {
        score -= 20;
      }
    }
    
    // LCP评分
    if (metrics.paint.lcp) {
      if (metrics.paint.lcp > this.thresholds.lcp) {
        score -= 20;
      }
    }
    
    // FID评分
    if (metrics.paint.fid) {
      if (metrics.paint.fid > this.thresholds.fid) {
        score -= 20;
      }
    }
    
    // CLS评分
    if (metrics.paint.cls) {
      if (metrics.paint.cls > this.thresholds.cls) {
        score -= 20;
      }
    }
    
    // TTI评分
    if (metrics.navigation.tti) {
      if (metrics.navigation.tti > this.thresholds.tti) {
        score -= 20;
      }
    }
    
    return Math.max(0, score);
  }
  
  // 设置性能阈值
  setThresholds(thresholds) {
    this.thresholds = { ...this.thresholds, ...thresholds };
  }
}

// 创建全局性能监控器
window.__MF_PERFORMANCE_MONITOR__ = new PerformanceMonitor();

// 微应用性能监控器
class AppPerformanceMonitor {
  constructor(appName) {
    this.appName = appName;
    this.startTime = 0;
    this.loadTime = 0;
    this.metrics = {
      appLoad: 0,
      resourceLoad: {},
      userActions: []
    };
  }
  
  // 开始监控应用加载
  startAppLoadMonitoring() {
    this.startTime = performance.now();
    console.log(`开始监控应用 ${this.appName} 的加载性能`);
  }
  
  // 结束监控应用加载
  endAppLoadMonitoring() {
    this.loadTime = performance.now() - this.startTime;
    this.metrics.appLoad = this.loadTime;
    
    console.log(`应用 ${this.appName} 加载完成，耗时: ${this.loadTime.toFixed(2)}ms`);
    
    // 上报数据
    this.reportMetrics();
  }
  
  // 监控资源加载
  monitorResourceLoad(resourceName) {
    const startTime = performance.now();
    
    return {
      end: () => {
        const loadTime = performance.now() - startTime;
        this.metrics.resourceLoad[resourceName] = loadTime;
        
        console.log(`应用 ${this.appName} 用户操作 ${actionName} 耗时: ${duration.toFixed(2)}ms`);
      }
    };
  }
  
  // 获取性能指标
  getMetrics() {
    return { ...this.metrics };
  }
  
  // 上报指标
  reportMetrics() {
    // 在实际项目中，这里可以发送到监控系统
    console.log(`应用 ${this.appName} 性能指标:`, this.metrics);
  }
}

// 应用性能监控器管理
class AppPerformanceMonitorManager {
  constructor() {
    this.monitors = new Map();
  }
  
  // 创建应用监控器
  createMonitor(appName) {
    if (this.monitors.has(appName)) {
      return this.monitors.get(appName);
    }
    
    const monitor = new AppPerformanceMonitor(appName);
    this.monitors.set(appName, monitor);
    
    return monitor;
  }
  
  // 获取应用监控器
  getMonitor(appName) {
    return this.monitors.get(appName);
  }
  
  // 移除应用监控器
  removeMonitor(appName) {
    this.monitors.delete(appName);
  }
  
  // 获取所有应用的性能指标
  getAllMetrics() {
    const allMetrics = {};
    
    this.monitors.forEach((monitor, appName) => {
      allMetrics[appName] = monitor.getMetrics();
    });
    
    return allMetrics;
  }
}

// 创建全局应用性能监控器管理
window.__MF_APP_PERFORMANCE_MONITOR_MANAGER__ = new AppPerformanceMonitorManager();

// 在应用加载时开始性能监控
function startAppPerformanceMonitoring(appName) {
  const monitor = window.__MF_APP_PERFORMANCE_MONITOR_MANAGER__.createMonitor(appName);
  monitor.startAppLoadMonitoring();
  
  console.log(`开始监控应用 ${appName} 的性能`);
}

// 在应用加载完成时结束性能监控
function endAppPerformanceMonitoring(appName) {
  const monitor = window.__MF_APP_PERFORMANCE_MONITOR_MANAGER__.getMonitor(appName);
  if (monitor) {
    monitor.endAppLoadMonitoring();
  }
}

// 扩展应用加载器，添加性能监控
const originalLoadAppWithDependencies = window.loadAppWithDependencies;
window.loadAppWithDependencies = function(appName, container) {
  // 开始性能监控
  startAppPerformanceMonitoring(appName);
  
  // 调用原始加载方法
  return originalLoadAppWithDependencies.call(this, appName, container)
    .then(app => {
      // 结束性能监控
      endAppPerformanceMonitoring(appName);
      
      return app;
    })
    .catch(error => {
      // 加载失败时也要结束性能监控
      endAppPerformanceMonitoring(appName);
      throw error;
    });
};

// 页面加载完成后启动全局性能监控
document.addEventListener('DOMContentLoaded', () => {
  window.__MF_PERFORMANCE_MONITOR__.startMonitoring();
});

// 页面卸载时停止全局性能监控
window.addEventListener('beforeunload', () => {
  window.__MF_PERFORMANCE_MONITOR__.stopMonitoring();
});
```

## 10.6 性能优化最佳实践

### 10.6.1 性能优化策略

1. **资源优化**
   - 使用CDN加速资源加载
   - 压缩和合并资源文件
   - 使用适当的缓存策略
   - 实现资源的按需加载和预加载

2. **代码优化**
   - 减少不必要的代码执行
   - 使用高效的数据结构和算法
   - 避免内存泄漏
   - 优化渲染性能

3. **网络优化**
   - 减少HTTP请求数量
   - 使用HTTP/2或HTTP/3
   - 实现请求合并和批处理
   - 使用适当的缓存策略

4. **用户体验优化**
   - 实现加载状态指示
   - 提供骨架屏
   - 优化首屏加载时间
   - 实现平滑的页面过渡

### 10.6.2 性能监控建议

1. **关键指标监控**
   - 首次内容绘制（FCP）
   - 最大内容绘制（LCP）
   - 首次输入延迟（FID）
   - 累积布局偏移（CLS）
   - 首次可交互时间（TTI）

2. **自定义指标监控**
   - 应用加载时间
   - 资源加载时间
   - 用户操作响应时间
   - 内存使用情况

3. **性能数据收集**
   - 定期收集性能数据
   - 建立性能基线
   - 设置性能阈值和告警
   - 分析性能趋势

4. **性能分析工具**
   - 使用浏览器开发者工具
   - 使用Lighthouse进行性能审计
   - 使用WebPageTest进行性能测试
   - 使用APM工具进行性能监控

### 10.6.3 性能优化检查清单

- [ ] 是否实现了应用的按需加载？
- [ ] 是否实现了资源的预加载？
- [ ] 是否实现了依赖共享？
- [ ] 是否优化了应用沙箱性能？
- [ ] 是否实现了内存管理？
- [ ] 是否实现了虚拟滚动？
- [ ] 是否实现了懒加载？
- [ ] 是否建立了性能监控？
- [ ] 是否设置了性能阈值？
- [ ] 是否定期分析性能数据？

## 10.7 总结

本章详细介绍了微前端架构中的性能优化策略，包括资源加载优化、运行时性能优化、渲染性能优化和性能监控与分析等方面。通过这些优化策略，可以显著提高微前端应用的性能和用户体验。

在微前端架构中，性能优化是一个持续的过程，需要不断地监控、分析和优化。只有通过全面的性能优化，才能确保微前端应用的高性能和良好的用户体验。

## 10.8 示例代码

本章节的示例代码位于 `frontend/micro-frontend/code/chapter10/performance-optimization` 目录下，包含以下内容：

- `lazy-app-loader.js` - 微应用按需加载器
- `dependency-sharing-manager.js` - 依赖共享管理器
- `optimized-app-sandbox.js` - 优化版应用沙箱
- `memory-manager.js` - 内存管理器
- `virtual-scroll.js` - 虚拟滚动组件
- `lazy-load-manager.js` - 懒加载管理器
- `performance-monitor.js` - 性能监控器

### 运行说明

1. 进入示例代码目录：
   ```bash
   cd frontend/micro-frontend/code/chapter10/performance-optimization
   ```

2. 安装依赖：
   ```bash
   npm install
   ```

3. 启动示例应用：
   ```bash
   npm start
   ```

4. 打开浏览器访问 `http://localhost:3000` 查看性能优化示例。

### 功能演示

示例应用演示了以下性能优化功能：

1. **按需加载** - 点击导航菜单，观察应用的按需加载过程
2. **依赖共享** - 查看网络面板，观察共享依赖的加载情况
3. **虚拟滚动** - 在长列表页面，观察虚拟滚动的效果
4. **懒加载** - 滚动页面，观察图片和组件的懒加载效果
5. **性能监控** - 打开控制台，查看性能监控数据

通过这些示例，可以更好地理解微前端架构中的性能优化策略和实现方法。Name} 资源 ${resourceName} 加载完成，耗时: ${loadTime.toFixed(2)}ms`);
      }
    };
  }
  
  // 监控用户操作
  monitorUserAction(actionName) {
    const startTime = performance.now();
    
    return {
      end: () => {
        const duration = performance.now() - startTime;
        this.metrics.userActions.push({
          name: actionName,
          duration,
          timestamp: Date.now()
        });
        
        console.log(`应用 ${this.app