# 第八章：微前端通信机制

## 8.1 通信机制概述

在微前端架构中，应用间的通信是一个核心且复杂的问题。由于各微应用是独立开发和部署的，它们之间需要有效的通信机制来共享数据、触发行为和保持状态同步。

### 8.1.1 微前端通信的挑战

1. **应用隔离**：微应用运行在独立的上下文中，直接访问受限
2. **数据一致性**：确保跨应用的数据保持一致性
3. **通信延迟**：跨应用通信可能带来额外的延迟
4. **错误处理**：处理通信过程中的错误和异常
5. **安全性**：确保通信过程的安全性，防止恶意攻击
6. **性能影响**：频繁的通信可能影响应用性能

### 8.1.2 通信场景

在微前端架构中，常见的通信场景包括：

1. **用户状态同步**：用户登录/登出状态在所有应用间同步
2. **数据共享**：共享业务数据，如用户信息、配置信息等
3. **事件通知**：一个应用中的操作需要通知其他应用
4. **功能调用**：一个应用需要调用另一个应用的功能
5. **主题切换**：全局主题变化时通知所有应用更新
6. **国际化**：语言切换时通知所有应用更新文本

## 8.2 基于事件的通信机制

### 8.2.1 自定义事件通信

使用浏览器原生自定义事件API实现应用间通信：

```javascript
// 事件总线实现
class EventBus {
  constructor() {
    this.events = {};
  }
  
  // 订阅事件
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(callback);
    
    // 返回取消订阅函数
    return () => {
      this.events[eventName] = this.events[eventName].filter(cb => cb !== callback);
    };
  }
  
  // 发布事件
  emit(eventName, data) {
    if (this.events[eventName]) {
      this.events[eventName].forEach(callback => callback(data));
    }
  }
  
  // 取消订阅
  off(eventName, callback) {
    if (this.events[eventName]) {
      if (callback) {
        this.events[eventName] = this.events[eventName].filter(cb => cb !== callback);
      } else {
        delete this.events[eventName];
      }
    }
  }
  
  // 只订阅一次
  once(eventName, callback) {
    const onceCallback = (data) => {
      callback(data);
      this.off(eventName, onceCallback);
    };
    
    this.on(eventName, onceCallback);
  }
}

// 创建全局事件总线
window.__MF_EVENT_BUS__ = new EventBus();

// 在用户应用中发布用户登录事件
function handleUserLogin(userData) {
  // 更新本地状态
  setUser(userData);
  
  // 发布用户登录事件
  window.__MF_EVENT_BUS__.emit('user:login', userData);
}

// 在订单应用中订阅用户登录事件
class OrderApp {
  constructor() {
    this.init();
  }
  
  init() {
    // 订阅用户登录事件
    this.unsubscribeUserLogin = window.__MF_EVENT_BUS__.on('user:login', (userData) => {
      console.log('订单应用收到用户登录事件:', userData);
      this.updateUserOrders(userData.id);
    });
    
    // 订阅用户登出事件
    this.unsubscribeUserLogout = window.__MF_EVENT_BUS__.on('user:logout', () => {
      console.log('订单应用收到用户登出事件');
      this.clearUserOrders();
    });
  }
  
  updateUserOrders(userId) {
    // 根据用户ID加载订单数据
    fetch(`/api/orders?userId=${userId}`)
      .then(response => response.json())
      .then(orders => {
        this.setState({ orders });
      });
  }
  
  clearUserOrders() {
    this.setState({ orders: [] });
  }
  
  componentWillUnmount() {
    // 取消订阅
    this.unsubscribeUserLogin();
    this.unsubscribeUserLogout();
  }
}
```

### 8.2.2 基于CustomEvent的通信

使用浏览器原生CustomEvent API实现通信：

```javascript
// 发布自定义事件
function publishCustomEvent(eventName, data) {
  const event = new CustomEvent(eventName, {
    detail: data,
    bubbles: true,
    cancelable: true
  });
  
  window.dispatchEvent(event);
}

// 订阅自定义事件
function subscribeCustomEvent(eventName, callback) {
  const eventHandler = (event) => {
    callback(event.detail);
  };
  
  window.addEventListener(eventName, eventHandler);
  
  // 返回取消订阅函数
  return () => {
    window.removeEventListener(eventName, eventHandler);
  };
}

// 在用户应用中使用
function handleUserLogin(userData) {
  // 发布用户登录事件
  publishCustomEvent('user:login', userData);
}

// 在订单应用中使用
class OrderApp {
  constructor() {
    this.unsubscribeEvents = [];
    this.init();
  }
  
  init() {
    // 订阅用户登录事件
    const unsubscribeUserLogin = subscribeCustomEvent('user:login', (userData) => {
      this.handleUserLogin(userData);
    });
    this.unsubscribeEvents.push(unsubscribeUserLogin);
    
    // 订阅用户登出事件
    const unsubscribeUserLogout = subscribeCustomEvent('user:logout', () => {
      this.handleUserLogout();
    });
    this.unsubscribeEvents.push(unsubscribeUserLogout);
  }
  
  handleUserLogin(userData) {
    console.log('订单应用收到用户登录事件:', userData);
    this.loadUserOrders(userData.id);
  }
  
  handleUserLogout() {
    console.log('订单应用收到用户登出事件');
    this.clearUserOrders();
  }
  
  componentWillUnmount() {
    // 取消所有订阅
    this.unsubscribeEvents.forEach(unsubscribe => unsubscribe());
  }
}
```

## 8.3 基于共享状态的通信机制

### 8.3.1 全局状态共享

通过全局状态实现应用间通信：

```javascript
// 全局状态管理器
class GlobalStateManager {
  constructor() {
    this.state = {};
    this.subscribers = {};
  }
  
  // 设置状态
  setState(key, value) {
    const oldValue = this.state[key];
    this.state[key] = value;
    
    // 通知订阅者
    if (this.subscribers[key]) {
      this.subscribers[key].forEach(callback => callback(value, oldValue));
    }
    
    // 发布状态变化事件
    this.publishStateChange(key, value, oldValue);
  }
  
  // 获取状态
  getState(key) {
    return this.state[key];
  }
  
  // 获取所有状态
  getAllState() {
    return { ...this.state };
  }
  
  // 订阅状态变化
  subscribe(key, callback) {
    if (!this.subscribers[key]) {
      this.subscribers[key] = [];
    }
    this.subscribers[key].push(callback);
    
    // 返回取消订阅函数
    return () => {
      this.subscribers[key] = this.subscribers[key].filter(cb => cb !== callback);
    };
  }
  
  // 发布状态变化事件
  publishStateChange(key, value, oldValue) {
    if (window.__MF_EVENT_BUS__) {
      window.__MF_EVENT_BUS__.emit('state:change', { key, value, oldValue });
    }
  }
}

// 创建全局状态管理器
window.__MF_GLOBAL_STATE__ = new GlobalStateManager();

// 在用户应用中更新用户状态
function handleUserLogin(userData) {
  // 更新全局状态
  window.__MF_GLOBAL_STATE__.setState('user', userData);
}

// 在订单应用中订阅用户状态变化
class OrderApp {
  constructor() {
    this.init();
  }
  
  init() {
    // 订阅用户状态变化
    this.unsubscribeUserState = window.__MF_GLOBAL_STATE__.subscribe('user', (user) => {
      if (user) {
        this.loadUserOrders(user.id);
      } else {
        this.clearUserOrders();
      }
    });
    
    // 获取当前用户状态
    const currentUser = window.__MF_GLOBAL_STATE__.getState('user');
    if (currentUser) {
      this.loadUserOrders(currentUser.id);
    }
  }
  
  loadUserOrders(userId) {
    fetch(`/api/orders?userId=${userId}`)
      .then(response => response.json())
      .then(orders => {
        this.setState({ orders });
      });
  }
  
  clearUserOrders() {
    this.setState({ orders: [] });
  }
  
  componentWillUnmount() {
    // 取消订阅
    this.unsubscribeUserState();
  }
}
```

### 8.3.2 基于Redux的共享状态

使用Redux实现跨应用状态共享：

```javascript
// 在主应用中创建Redux store
import { createStore, combineReducers } from 'redux';

// 定义全局状态reducer
const globalReducer = combineReducers({
  user: (state = null, action) => {
    switch (action.type) {
      case 'SET_USER':
        return action.payload;
      case 'CLEAR_USER':
        return null;
      default:
        return state;
    }
  },
  theme: (state = 'light', action) => {
    switch (action.type) {
      case 'SET_THEME':
        return action.payload;
      default:
        return state;
    }
  },
  notifications: (state = [], action) => {
    switch (action.type) {
      case 'ADD_NOTIFICATION':
        return [...state, action.payload];
      case 'REMOVE_NOTIFICATION':
        return state.filter(n => n.id !== action.payload);
      default:
        return state;
    }
  }
});

// 创建store
const store = createStore(globalReducer);

// 将store暴露到全局
window.__MF_STORE__ = store;

// 在用户应用中使用Redux
import { Provider, connect } from 'react-redux';

// 创建用户操作组件
const UserActions = connect(
  state => ({ user: state.user }),
  dispatch => ({
    setUser: (user) => dispatch({ type: 'SET_USER', payload: user }),
    clearUser: () => dispatch({ type: 'CLEAR_USER' })
  })
)(({ user, setUser, clearUser }) => {
  const handleLogin = () => {
    // 模拟登录
    const userData = { id: 123, name: 'John' };
    setUser(userData);
  };
  
  const handleLogout = () => {
    clearUser();
  };
  
  return (
    <div>
      {user ? (
        <div>
          <span>欢迎, {user.name}</span>
          <button onClick={handleLogout}>登出</button>
        </div>
      ) : (
        <button onClick={handleLogin}>登录</button>
      )}
    </div>
  );
});

// 在订单应用中订阅Redux状态
const OrderList = connect(
  state => ({ user: state.user }),
  null
)(({ user }) => {
  const [orders, setOrders] = useState([]);
  
  useEffect(() => {
    if (user) {
      fetch(`/api/orders?userId=${user.id}`)
        .then(response => response.json())
        .then(orders => setOrders(orders));
    } else {
      setOrders([]);
    }
  }, [user]);
  
  return (
    <div>
      <h2>订单列表</h2>
      {user ? (
        <ul>
          {orders.map(order => (
            <li key={order.id}>{order.name}</li>
          ))}
        </ul>
      ) : (
        <p>请先登录</p>
      )}
    </div>
  );
});

// 在微应用根组件中使用Provider
const App = () => (
  <Provider store={window.__MF_STORE__}>
    <div>
      <UserActions />
      <OrderList />
    </div>
  </Provider>
);
```

## 8.4 基于消息传递的通信机制

### 8.4.1 PostMessage通信

使用PostMessage API实现跨iframe通信：

```javascript
// 主应用中的iframe通信管理器
class IframeCommunicationManager {
  constructor() {
    this.iframes = new Map();
    this.messageHandlers = {};
    this.init();
  }
  
  init() {
    // 监听来自iframe的消息
    window.addEventListener('message', this.handleMessage.bind(this));
  }
  
  // 注册iframe
  registerIframe(name, iframe) {
    this.iframes.set(name, iframe);
  }
  
  // 发送消息到iframe
  sendMessage(target, message) {
    const iframe = this.iframes.get(target);
    if (iframe && iframe.contentWindow) {
      iframe.contentWindow.postMessage(message, '*');
    }
  }
  
  // 注册消息处理器
  registerMessageHandler(type, handler) {
    if (!this.messageHandlers[type]) {
      this.messageHandlers[type] = [];
    }
    this.messageHandlers[type].push(handler);
  }
  
  // 处理接收到的消息
  handleMessage(event) {
    const { type, data, source } = event.data;
    
    if (this.messageHandlers[type]) {
      this.messageHandlers[type].forEach(handler => {
        handler(data, source);
      });
    }
  }
}

// 创建全局通信管理器
window.__MF_COMMUNICATION_MANAGER__ = new IframeCommunicationManager();

// 在主应用中注册iframe和消息处理器
function initMainApp() {
  // 注册用户应用iframe
  const userIframe = document.getElementById('user-app-iframe');
  window.__MF_COMMUNICATION_MANAGER__.registerIframe('user-app', userIframe);
  
  // 注册订单应用iframe
  const orderIframe = document.getElementById('order-app-iframe');
  window.__MF_COMMUNICATION_MANAGER__.registerIframe('order-app', orderIframe);
  
  // 注册消息处理器
  window.__MF_COMMUNICATION_MANAGER__.registerMessageHandler('user:login', (data, source) => {
    console.log('主应用收到用户登录消息:', data);
    
    // 转发消息到订单应用
    window.__MF_COMMUNICATION_MANAGER__.sendMessage('order-app', {
      type: 'user:login',
      data
    });
  });
  
  window.__MF_COMMUNICATION_MANAGER__.registerMessageHandler('user:logout', (data, source) => {
    console.log('主应用收到用户登出消息:', data);
    
    // 转发消息到订单应用
    window.__MF_COMMUNICATION_MANAGER__.sendMessage('order-app', {
      type: 'user:logout',
      data
    });
  });
}

// 在用户应用中发送消息
function handleUserLogin(userData) {
  // 发送登录消息到主应用
  window.parent.postMessage({
    type: 'user:login',
    data: userData
  }, '*');
}

// 在订单应用中接收消息
function initOrderApp() {
  // 监听来自主应用的消息
  window.addEventListener('message', (event) => {
    const { type, data } = event.data;
    
    switch (type) {
      case 'user:login':
        console.log('订单应用收到用户登录消息:', data);
        loadUserOrders(data.id);
        break;
      case 'user:logout':
        console.log('订单应用收到用户登出消息');
        clearUserOrders();
        break;
    }
  });
}

function loadUserOrders(userId) {
  fetch(`/api/orders?userId=${userId}`)
    .then(response => response.json())
    .then(orders => {
      renderOrderList(orders);
    });
}

function clearUserOrders() {
  renderOrderList([]);
}
```

### 8.4.2 基于WebSocket的实时通信

使用WebSocket实现实时通信：

```javascript
// WebSocket通信管理器
class WebSocketCommunicationManager {
  constructor(url) {
    this.url = url;
    this.socket = null;
    this.messageHandlers = {};
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.reconnectInterval = 3000;
  }
  
  // 连接WebSocket
  connect() {
    this.socket = new WebSocket(this.url);
    
    this.socket.onopen = () => {
      console.log('WebSocket连接已建立');
      this.reconnectAttempts = 0;
    };
    
    this.socket.onmessage = (event) => {
      const message = JSON.parse(event.data);
      this.handleMessage(message);
    };
    
    this.socket.onclose = () => {
      console.log('WebSocket连接已关闭');
      this.reconnect();
    };
    
    this.socket.onerror = (error) => {
      console.error('WebSocket错误:', error);
    };
  }
  
  // 重连
  reconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      console.log(`尝试重连 (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
      
      setTimeout(() => {
        this.connect();
      }, this.reconnectInterval);
    }
  }
  
  // 发送消息
  sendMessage(type, data, target = 'broadcast') {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      const message = {
        type,
        data,
        target,
        timestamp: Date.now(),
        source: this.getAppId()
      };
      
      this.socket.send(JSON.stringify(message));
    }
  }
  
  // 注册消息处理器
  registerMessageHandler(type, handler) {
    if (!this.messageHandlers[type]) {
      this.messageHandlers[type] = [];
    }
    this.messageHandlers[type].push(handler);
  }
  
  // 处理接收到的消息
  handleMessage(message) {
    const { type, data, source, target } = message;
    
    // 如果消息是指定给当前应用的，或者广播消息
    if (target === this.getAppId() || target === 'broadcast') {
      if (this.messageHandlers[type]) {
        this.messageHandlers[type].forEach(handler => {
          handler(data, source);
        });
      }
    }
  }
  
  // 获取应用ID
  getAppId() {
    return window.__MF_APP_ID__ || 'unknown';
  }
  
  // 断开连接
  disconnect() {
    if (this.socket) {
      this.socket.close();
      this.socket = null;
    }
  }
}

// 创建全局WebSocket通信管理器
window.__MF_WS_COMMUNICATION__ = new WebSocketCommunicationManager('ws://localhost:8080');

// 在用户应用中使用WebSocket
function initUserApp() {
  // 连接WebSocket
  window.__MF_WS_COMMUNICATION__.connect();
  
  // 注册消息处理器
  window.__MF_WS_COMMUNICATION__.registerMessageHandler('user:login', (data, source) => {
    if (source !== window.__MF_APP_ID__) {
      console.log('用户应用收到其他应用的用户登录消息:', data);
      updateUserState(data);
    }
  });
  
  window.__MF_WS_COMMUNICATION__.registerMessageHandler('user:logout', (data, source) => {
    if (source !== window.__MF_APP_ID__) {
      console.log('用户应用收到其他应用的用户登出消息');
      clearUserState();
    }
  });
}

function handleUserLogin(userData) {
  // 更新本地状态
  updateUserState(userData);
  
  // 发送登录消息到其他应用
  window.__MF_WS_COMMUNICATION__.sendMessage('user:login', userData);
}

function handleUserLogout() {
  // 更新本地状态
  clearUserState();
  
  // 发送登出消息到其他应用
  window.__MF_WS_COMMUNICATION__.sendMessage('user:logout');
}
```

## 8.5 基于共享依赖的通信机制

### 8.5.1 Module Federation共享依赖

使用Module Federation实现共享依赖通信：

```javascript
// 主应用webpack配置
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  // ...其他配置
  plugins: [
    new ModuleFederationPlugin({
      name: 'shell',
      remotes: {
        user: 'user@http://localhost:3001/remoteEntry.js',
        order: 'order@http://localhost:3002/remoteEntry.js'
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true },
        './src/shared/EventBus': { singleton: true }
      }
    })
  ]
};

// 共享事件总线
// src/shared/EventBus.js
class EventBus {
  constructor() {
    this.events = {};
  }
  
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(callback);
    
    return () => {
      this.events[eventName] = this.events[eventName].filter(cb => cb !== callback);
    };
  }
  
  emit(eventName, data) {
    if (this.events[eventName]) {
      this.events[eventName].forEach(callback => callback(data));
    }
  }
  
  off(eventName, callback) {
    if (this.events[eventName]) {
      if (callback) {
        this.events[eventName] = this.events[eventName].filter(cb => cb !== callback);
      } else {
        delete this.events[eventName];
      }
    }
  }
}

// 导出单例
export const eventBus = new EventBus();

// 主应用中使用共享事件总线
import { eventBus } from './shared/EventBus';

function handleUserLogin(userData) {
  // 更新本地状态
  setUser(userData);
  
  // 通过共享事件总线发布事件
  eventBus.emit('user:login', userData);
}

// 用户应用webpack配置
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  // ...其他配置
  plugins: [
    new ModuleFederationPlugin({
      name: 'user',
      filename: 'remoteEntry.js',
      exposes: {
        './App': './src/App'
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true },
        './src/shared/EventBus': { singleton: true }
      }
    })
  ]
};

// 用户应用中使用共享事件总线
import { eventBus } from 'shell/src/shared/EventBus';

class UserApp extends React.Component {
  constructor(props) {
    super(props);
    
    // 订阅事件
    this.unsubscribe = eventBus.on('user:login', (userData) => {
      console.log('用户应用收到用户登录事件:', userData);
      this.setState({ user: userData });
    });
  }
  
  componentWillUnmount() {
    // 取消订阅
    this.unsubscribe();
  }
  
  handleLogin = () => {
    const userData = { id: 123, name: 'John' };
    
    // 更新本地状态
    this.setState({ user: userData });
    
    // 通过共享事件总线发布事件
    eventBus.emit('user:login', userData);
  };
  
  render() {
    const { user } = this.state;
    
    return (
      <div>
        {user ? (
          <div>欢迎, {user.name}</div>
        ) : (
          <button onClick={this.handleLogin}>登录</button>
        )}
      </div>
    );
  }
}

// 订单应用webpack配置
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  // ...其他配置
  plugins: [
    new ModuleFederationPlugin({
      name: 'order',
      filename: 'remoteEntry.js',
      exposes: {
        './App': './src/App'
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true },
        './src/shared/EventBus': { singleton: true }
      }
    })
  ]
};

// 订单应用中使用共享事件总线
import { eventBus } from 'shell/src/shared/EventBus';

class OrderApp extends React.Component {
  constructor(props) {
    super(props);
    
    this.state = {
      orders: []
    };
    
    // 订阅事件
    this.unsubscribe = eventBus.on('user:login', (userData) => {
      console.log('订单应用收到用户登录事件:', userData);
      this.loadUserOrders(userData.id);
    });
  }
  
  componentWillUnmount() {
    // 取消订阅
    this.unsubscribe();
  }
  
  loadUserOrders(userId) {
    fetch(`/api/orders?userId=${userId}`)
      .then(response => response.json())
      .then(orders => {
        this.setState({ orders });
      });
  }
  
  render() {
    const { orders } = this.state;
    
    return (
      <div>
        <h2>订单列表</h2>
        <ul>
          {orders.map(order => (
            <li key={order.id}>{order.name}</li>
          ))}
        </ul>
      </div>
    );
  }
}
```

## 8.6 通信安全机制

### 8.6.1 消息验证

实现消息验证机制，确保通信安全：

```javascript
// 消息验证器
class MessageValidator {
  constructor() {
    this.allowedOrigins = ['http://localhost:3000', 'https://example.com'];
    this.messageSignatures = new Map();
    this.secretKey = 'your-secret-key';
  }
  
  // 验证消息来源
  validateOrigin(origin) {
    return this.allowedOrigins.includes(origin);
  }
  
  // 生成消息签名
  generateSignature(message) {
    const messageString = JSON.stringify(message);
    return this.hash(messageString + this.secretKey);
  }
  
  // 验证消息签名
  validateSignature(message, signature) {
    const expectedSignature = this.generateSignature(message);
    return signature === expectedSignature;
  }
  
  // 哈希函数
  hash(str) {
    // 简单的哈希实现，实际应用中应使用更安全的哈希算法
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // 转换为32位整数
    }
    return hash.toString();
  }
  
  // 验证消息格式
  validateMessageFormat(message) {
    return (
      message &&
      typeof message === 'object' &&
      typeof message.type === 'string' &&
      message.timestamp &&
      typeof message.source === 'string'
    );
  }
}

// 创建全局消息验证器
window.__MF_MESSAGE_VALIDATOR__ = new MessageValidator();

// 安全通信管理器
class SecureCommunicationManager {
  constructor() {
    this.messageValidator = window.__MF_MESSAGE_VALIDATOR__;
    this.messageHandlers = {};
    this.init();
  }
  
  init() {
    // 监听消息
    window.addEventListener('message', this.handleMessage.bind(this));
  }
  
  // 处理接收到的消息
  handleMessage(event) {
    // 验证消息来源
    if (!this.messageValidator.validateOrigin(event.origin)) {
      console.warn('拒绝来自未知来源的消息:', event.origin);
      return;
    }
    
    const message = event.data;
    
    // 验证消息格式
    if (!this.messageValidator.validateMessageFormat(message)) {
      console.warn('消息格式无效:', message);
      return;
    }
    
    // 验证消息签名
    if (message.signature && !this.messageValidator.validateSignature(message, message.signature)) {
      console.warn('消息签名无效:', message);
      return;
    }
    
    // 处理消息
    if (this.messageHandlers[message.type]) {
      this.messageHandlers[message.type].forEach(handler => {
        handler(message.data, message.source);
      });
    }
  }
  
  // 发送安全消息
  sendSecureMessage(target, type, data) {
    const message = {
      type,
      data,
      timestamp: Date.now(),
      source: this.getAppId()
    };
    
    // 添加签名
    message.signature = this.messageValidator.generateSignature(message);
    
    // 发送消息
    if (target === 'broadcast') {
      // 广播消息
      window.postMessage(message, '*');
    } else {
      // 发送到特定目标
      const targetWindow = this.getTargetWindow(target);
      if (targetWindow) {
        targetWindow.postMessage(message, '*');
      }
    }
  }
  
  // 注册消息处理器
  registerMessageHandler(type, handler) {
    if (!this.messageHandlers[type]) {
      this.messageHandlers[type] = [];
    }
    this.messageHandlers[type].push(handler);
  }
  
  // 获取目标窗口
  getTargetWindow(target) {
    // 根据目标获取对应的窗口对象
    // 这里需要根据实际实现来获取目标窗口
    return null;
  }
  
  // 获取应用ID
  getAppId() {
    return window.__MF_APP_ID__ || 'unknown';
  }
}

// 创建全局安全通信管理器
window.__MF_SECURE_COMMUNICATION__ = new SecureCommunicationManager();

// 在用户应用中使用安全通信
function initUserApp() {
  // 注册消息处理器
  window.__MF_SECURE_COMMUNICATION__.registerMessageHandler('user:login', (data, source) => {
    if (source !== window.__MF_APP_ID__) {
      console.log('用户应用收到其他应用的用户登录消息:', data);
      updateUserState(data);
    }
  });
  
  window.__MF_SECURE_COMMUNICATION__.registerMessageHandler('user:logout', (data, source) => {
    if (source !== window.__MF_APP_ID__) {
      console.log('用户应用收到其他应用的用户登出消息');
      clearUserState();
    }
  });
}

function handleUserLogin(userData) {
  // 更新本地状态
  updateUserState(userData);
  
  // 发送安全登录消息到其他应用
  window.__MF_SECURE_COMMUNICATION__.sendSecureMessage('broadcast', 'user:login', userData);
}
```

### 8.6.2 权限控制

实现通信权限控制：

```javascript
// 权限管理器
class CommunicationPermissionManager {
  constructor() {
    this.appPermissions = new Map();
    this.typePermissions = new Map();
  }
  
  // 设置应用权限
  setAppPermissions(appId, permissions) {
    this.appPermissions.set(appId, permissions);
  }
  
  // 设置消息类型权限
  setTypePermissions(type, permissions) {
    this.typePermissions.set(type, permissions);
  }
  
  // 检查发送权限
  canSend(appId, type) {
    // 检查应用是否有发送权限
    const appPerms = this.appPermissions.get(appId);
    if (appPerms && !appPerms.canSend) {
      return false;
    }
    
    // 检查消息类型是否有发送权限
    const typePerms = this.typePermissions.get(type);
    if (typePerms && !typePerms.canSend) {
      return false;
    }
    
    return true;
  }
  
  // 检查接收权限
  canReceive(appId, type) {
    // 检查应用是否有接收权限
    const appPerms = this.appPermissions.get(appId);
    if (appPerms && !appPerms.canReceive) {
      return false;
    }
    
    // 检查消息类型是否有接收权限
    const typePerms = this.typePermissions.get(type);
    if (typePerms && !typePerms.canReceive) {
      return false;
    }
    
    return true;
  }
}

// 创建全局权限管理器
window.__MF_COMMUNICATION_PERMISSION__ = new CommunicationPermissionManager();

// 设置应用权限
window.__MF_COMMUNICATION_PERMISSION__.setAppPermissions('user-app', {
  canSend: true,
  canReceive: true
});

window.__MF_COMMUNICATION_PERMISSION__.setAppPermissions('order-app', {
  canSend: true,
  canReceive: true
});

// 设置消息类型权限
window.__MF_COMMUNICATION_PERMISSION__.setTypePermissions('user:login', {
  canSend: true,
  canReceive: true
});

window.__MF_COMMUNICATION_PERMISSION__.setTypePermissions('user:logout', {
  canSend: true,
  canReceive: true
});

window.__MF_COMMUNICATION_PERMISSION__.setTypePermissions('admin:settings', {
  canSend: false, // 普通应用不能发送管理员设置消息
  canReceive: true
});

// 带权限控制的通信管理器
class PermissionControlledCommunicationManager {
  constructor() {
    this.permissionManager = window.__MF_COMMUNICATION_PERMISSION__;
    this.messageHandlers = {};
    this.init();
  }
  
  init() {
    // 监听消息
    window.addEventListener('message', this.handleMessage.bind(this));
  }
  
  // 处理接收到的消息
  handleMessage(event) {
    const message = event.data;
    const { type, source } = message;
    
    // 检查接收权限
    if (!this.permissionManager.canReceive(this.getAppId(), type)) {
      console.warn(`应用 ${this.getAppId()} 没有接收 ${type} 消息的权限`);
      return;
    }
    
    // 处理消息
    if (this.messageHandlers[type]) {
      this.messageHandlers[type].forEach(handler => {
        handler(message.data, source);
      });
    }
  }
  
  // 发送消息
  sendMessage(target, type, data) {
    // 检查发送权限
    if (!this.permissionManager.canSend(this.getAppId(), type)) {
      console.warn(`应用 ${this.getAppId()} 没有发送 ${type} 消息的权限`);
      return;
    }
    
    const message = {
      type,
      data,
      timestamp: Date.now(),
      source: this.getAppId()
    };
    
    // 发送消息
    if (target === 'broadcast') {
      window.postMessage(message, '*');
    } else {
      const targetWindow = this.getTargetWindow(target);
      if (targetWindow) {
        targetWindow.postMessage(message, '*');
      }
    }
  }
  
  // 注册消息处理器
  registerMessageHandler(type, handler) {
    if (!this.messageHandlers[type]) {
      this.messageHandlers[type] = [];
    }
    this.messageHandlers[type].push(handler);
  }
  
  // 获取目标窗口
  getTargetWindow(target) {
    // 根据目标获取对应的窗口对象
    return null;
  }
  
  // 获取应用ID
  getAppId() {
    return window.__MF_APP_ID__ || 'unknown';
  }
}

// 创建全局权限控制通信管理器
window.__MF_PERMISSION_CONTROLLED_COMMUNICATION__ = new PermissionControlledCommunicationManager();
```

## 8.7 通信性能优化

### 8.7.1 消息批处理

实现消息批处理，减少通信频率：

```javascript
// 消息批处理器
class MessageBatcher {
  constructor(options = {}) {
    this.batchSize = options.batchSize || 10;
    this.batchTimeout = options.batchTimeout || 100;
    this.pendingMessages = [];
    this.batchTimer = null;
    this.messageHandler = null;
  }
  
  // 设置消息处理器
  setMessageHandler(handler) {
    this.messageHandler = handler;
  }
  
  // 添加消息到批处理队列
  addMessage(message) {
    this.pendingMessages.push(message);
    
    // 如果达到批处理大小，立即处理
    if (this.pendingMessages.length >= this.batchSize) {
      this.flushMessages();
    } else {
      // 设置定时器，确保消息不会等待太久
      this.scheduleBatchFlush();
    }
  }
  
  // 调度批处理刷新
  scheduleBatchFlush() {
    if (this.batchTimer) {
      return;
    }
    
    this.batchTimer = setTimeout(() => {
      this.flushMessages();
    }, this.batchTimeout);
  }
  
  // 刷新消息批处理
  flushMessages() {
    if (this.pendingMessages.length === 0) {
      return;
    }
    
    // 清除定时器
    if (this.batchTimer) {
      clearTimeout(this.batchTimer);
      this.batchTimer = null;
    }
    
    // 获取待处理消息
    const messages = [...this.pendingMessages];
    this.pendingMessages = [];
    
    // 处理消息批
    if (this.messageHandler) {
      this.messageHandler(messages);
    }
  }
}

// 创建全局消息批处理器
window.__MF_MESSAGE_BATCHER__ = new MessageBatcher({
  batchSize: 10,
  batchTimeout: 50
});

// 设置消息处理器
window.__MF_MESSAGE_BATCHER__.setMessageHandler((messages) => {
  // 合并相同类型的消息
  const mergedMessages = this.mergeMessages(messages);
  
  // 发送合并后的消息
  mergedMessages.forEach(message => {
    window.postMessage(message, '*');
  });
});

// 合并消息
function mergeMessages(messages) {
  const messageMap = new Map();
  
  messages.forEach(message => {
    const { type, data } = message;
    
    if (messageMap.has(type)) {
      // 合并相同类型的消息
      const existingMessage = messageMap.get(type);
      const mergedData = mergeData(existingMessage.data, data);
      messageMap.set(type, {
        ...message,
        data: mergedData
      });
    } else {
      messageMap.set(type, message);
    }
  });
  
  return Array.from(messageMap.values());
}

// 合并数据
function mergeData(existingData, newData) {
  // 简单的合并策略，实际应用中需要根据业务逻辑实现
  return {
    ...existingData,
    ...newData
  };
}

// 在应用中使用消息批处理
function sendBatchMessage(type, data) {
  const message = {
    type,
    data,
    timestamp: Date.now(),
    source: window.__MF_APP_ID__ || 'unknown'
  };
  
  // 添加到批处理队列
  window.__MF_MESSAGE_BATCHER__.addMessage(message);
}

// 使用示例
function handleUserLogin(userData) {
  // 发送批处理消息
  sendBatchMessage('user:login', userData);
}

function handleThemeChange(theme) {
  // 发送批处理消息
  sendBatchMessage('theme:change', { theme });
}
```

### 8.7.2 消息缓存

实现消息缓存，避免重复处理：

```javascript
// 消息缓存管理器
class MessageCacheManager {
  constructor(options = {}) {
    this.maxCacheSize = options.maxCacheSize || 1000;
    this.cacheTimeout = options.cacheTimeout || 60000; // 1分钟
    this.messageCache = new Map();
  }
  
  // 检查消息是否已处理
  hasProcessed(messageId) {
    const cached = this.messageCache.get(messageId);
    
    if (!cached) {
      return false;
    }
    
    // 检查缓存是否过期
    if (Date.now() - cached.timestamp > this.cacheTimeout) {
      this.messageCache.delete(messageId);
      return false;
    }
    
    return true;
  }
  
  // 标记消息已处理
  markAsProcessed(messageId) {
    // 如果缓存已满，删除最旧的条目
    if (this.messageCache.size >= this.maxCacheSize) {
      const oldestKey = this.messageCache.keys().next().value;
      this.messageCache.delete(oldestKey);
    }
    
    this.messageCache.set(messageId, {
      timestamp: Date.now()
    });
  }
  
  // 清理过期缓存
  cleanExpiredCache() {
    const now = Date.now();
    const expiredKeys = [];
    
    this.messageCache.forEach((value, key) => {
      if (now - value.timestamp > this.cacheTimeout) {
        expiredKeys.push(key);
      }
    });
    
    expiredKeys.forEach(key => {
      this.messageCache.delete(key);
    });
  }
  
  // 清空缓存
  clearCache() {
    this.messageCache.clear();
  }
}

// 创建全局消息缓存管理器
window.__MF_MESSAGE_CACHE__ = new MessageCacheManager();

// 定期清理过期缓存
setInterval(() => {
  window.__MF_MESSAGE_CACHE__.cleanExpiredCache();
}, 30000); // 每30秒清理一次

// 带缓存的消息处理器
class CachedMessageHandler {
  constructor() {
    this.messageHandlers = {};
    this.init();
  }
  
  init() {
    // 监听消息
    window.addEventListener('message', this.handleMessage.bind(this));
  }
  
  // 处理接收到的消息
  handleMessage(event) {
    const message = event.data;
    
    // 生成消息ID
    const messageId = this.generateMessageId(message);
    
    // 检查消息是否已处理
    if (window.__MF_MESSAGE_CACHE__.hasProcessed(messageId)) {
      return; // 消息已处理，跳过
    }
    
    // 标记消息已处理
    window.__MF_MESSAGE_CACHE__.markAsProcessed(messageId);
    
    // 处理消息
    const { type, data, source } = message;
    if (this.messageHandlers[type]) {
      this.messageHandlers[type].forEach(handler => {
        handler(data, source);
      });
    }
  }
  
  // 生成消息ID
  generateMessageId(message) {
    // 使用消息内容生成唯一ID
    const { type, data, source, timestamp } = message;
    const content = `${type}:${JSON.stringify(data)}:${source}:${timestamp}`;
    return this.hash(content);
  }
  
  // 哈希函数
  hash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash.toString();
  }
  
  // 注册消息处理器
  registerMessageHandler(type, handler) {
    if (!this.messageHandlers[type]) {
      this.messageHandlers[type] = [];
    }
    this.messageHandlers[type].push(handler);
  }
}

// 创建全局缓存消息处理器
window.__MF_CACHED_MESSAGE_HANDLER__ = new CachedMessageHandler();
```

## 8.8 通信机制最佳实践

### 8.8.1 通信设计原则

1. **最小化通信**：只在必要时进行通信，减少应用间的耦合
2. **明确接口**：定义清晰的通信接口和消息格式
3. **错误处理**：妥善处理通信过程中的错误和异常
4. **安全性**：确保通信过程的安全性，防止恶意攻击
5. **性能考虑**：优化通信性能，避免频繁通信影响应用性能

### 8.8.2 消息格式规范

```javascript
// 标准消息格式
const standardMessageFormat = {
  // 消息类型，必填
  type: 'string',
  
  // 消息数据，必填
  data: 'any',
  
  // 消息来源，必填
  source: 'string',
  
  // 消息目标，可选，默认为broadcast
  target: 'string',
  
  // 时间戳，必填
  timestamp: 'number',
  
  // 消息ID，可选，用于去重
  id: 'string',
  
  // 消息签名，可选，用于验证
  signature: 'string',
  
  // 消息优先级，可选，默认为normal
  priority: 'low|normal|high|critical'
};

// 消息类型命名规范
const messageTypeNamingConventions = {
  // 使用命名空间:动作的格式
  good: [
    'user:login',
    'user:logout',
    'order:create',
    'order:update',
    'notification:show',
    'theme:change'
  ],
  
  // 避免使用通用名称
  bad: [
    'login',
    'update',
    'show',
    'change'
  ]
};
```

### 8.8.3 错误处理策略

```javascript
// 通信错误处理器
class CommunicationErrorHandler {
  constructor() {
    this.errorHandlers = {};
    this.retryQueue = [];
    this.maxRetries = 3;
    this.retryDelay = 1000;
  }
  
  // 注册错误处理器
  registerErrorHandler(errorType, handler) {
    this.errorHandlers[errorType] = handler;
  }
  
  // 处理通信错误
  handleError(error, message, context) {
    const errorType = this.getErrorType(error);
    
    // 记录错误
    console.error(`通信错误 (${errorType}):`, error, message, context);
    
    // 调用错误处理器
    if (this.errorHandlers[errorType]) {
      this.errorHandlers[errorType](error, message, context);
    }
    
    // 根据错误类型决定是否重试
    if (this.shouldRetry(errorType)) {
      this.addToRetryQueue(message, context);
    }
  }
  
  // 获取错误类型
  getErrorType(error) {
    if (error.name === 'NetworkError' || error.message.includes('network')) {
      return 'network';
    } else if (error.name === 'TimeoutError' || error.message.includes('timeout')) {
      return 'timeout';
    } else if (error.name === 'SecurityError' || error.message.includes('security')) {
      return 'security';
    } else {
      return 'unknown';
    }
  }
  
  // 判断是否应该重试
  shouldRetry(errorType) {
    // 网络错误和超时错误可以重试
    return errorType === 'network' || errorType === 'timeout';
  }
  
  // 添加到重试队列
  addToRetryQueue(message, context) {
    this.retryQueue.push({
      message,
      context,
      retries: 0,
      nextRetryTime: Date.now() + this.retryDelay
    });
    
    // 处理重试队列
    this.processRetryQueue();
  }
  
  // 处理重试队列
  processRetryQueue() {
    if (this.retryQueue.length === 0) {
      return;
    }
    
    const now = Date.now();
    const readyToRetry = this.retryQueue.filter(item => item.nextRetryTime <= now);
    
    readyToRetry.forEach(item => {
      if (item.retries < this.maxRetries) {
        // 重试发送消息
        this.retrySendMessage(item.message, item.context, item.retries + 1);
      }
      
      // 从队列中移除
      const index = this.retryQueue.indexOf(item);
      this.retryQueue.splice(index, 1);
    });
    
    // 如果还有待重试的消息，继续处理
    if (this.retryQueue.length > 0) {
      setTimeout(() => this.processRetryQueue(), 1000);
    }
  }
  
  // 重试发送消息
  retrySendMessage(message, context, retryCount) {
    console.log(`重试发送消息 (${retryCount}/${this.maxRetries}):`, message);
    
    try {
      // 发送消息
      context.sendMessage(message);
    } catch (error) {
      // 重试失败，重新加入队列
      this.retryQueue.push({
        message,
        context,
        retries: retryCount,
        nextRetryTime: Date.now() + this.retryDelay * retryCount
      });
    }
  }
}

// 创建全局通信错误处理器
window.__MF_COMMUNICATION_ERROR_HANDLER__ = new CommunicationErrorHandler();

// 注册错误处理器
window.__MF_COMMUNICATION_ERROR_HANDLER__.registerErrorHandler('network', (error, message, context) => {
  // 网络错误处理
  console.log('处理网络错误:', error.message);
});

window.__MF_COMMUNICATION_ERROR_HANDLER__.registerErrorHandler('timeout', (error, message, context) => {
  // 超时错误处理
  console.log('处理超时错误:', error.message);
});

window.__MF_COMMUNICATION_ERROR_HANDLER__.registerErrorHandler('security', (error, message, context) => {
  // 安全错误处理
  console.log('处理安全错误:', error.message);
});
```

## 8.9 本章小结

本章详细介绍了微前端架构中的通信机制问题，包括通信的挑战、各种实现方案、通信安全机制、通信性能优化以及最佳实践。我们通过实际代码示例展示了如何在不同场景下实现应用间通信，并提供了消息格式规范和错误处理策略。

通信机制是微前端架构中的核心问题，有效的通信方案可以显著提高应用间的协作能力和用户体验。在实际项目中，需要根据应用规模、安全要求和性能需求来选择合适的通信机制。

在下一章中，我们将学习微前端样式隔离的相关知识，了解如何在微前端架构中实现有效的样式隔离。

## 8.10 思考题

1. 微前端通信面临哪些主要挑战？
2. 如何确保微前端通信的安全性？
3. 在微前端架构中，如何优化通信性能？

## 8.11 示例代码

本章的完整示例代码已经保存在 `frontend/micro-frontend/code/chapter8/communication-mechanism` 目录中。

### 8.11.1 代码结构

```
communication-mechanism/
├── src/
│   ├── main-app/
│   │   ├── index.js
│   │   ├── App.js
│   │   └── communication/
│   │       ├── EventBus.js
│   │       ├── GlobalStateManager.js
│   │       └── SecureCommunicationManager.js
│   ├── user-app/
│   │   ├── index.js
│   │   ├── App.js
│   │   └── components/
│   │       ├── UserProfile.js
│   │       └── LoginForm.js
│   ├── order-app/
│   │   ├── index.js
│   │   ├── App.js
│   │   └── components/
│   │       ├── OrderList.js
│   │       └── OrderDetails.js
│   ├── shared/
│   │   ├── MessageValidator.js
│   │   ├── CommunicationPermissionManager.js
│   │   ├── MessageBatcher.js
│   │   └── MessageCacheManager.js
│   └── index.html
├── package.json
└── webpack.config.js
```

### 8.11.2 运行示例

1. 进入示例代码目录：
```bash
cd frontend/micro-frontend/code/chapter8/communication-mechanism
```

2. 安装依赖：
```bash
npm install
```

3. 启动开发服务器：
```bash
npm start
```

4. 在浏览器中打开 http://localhost:9008

### 8.11.3 示例功能说明

- 主应用负责通信管理器的初始化和应用注册
- 用户应用展示用户登录/登出功能，并通过事件总线通知其他应用
- 订单应用展示订单列表，并订阅用户状态变化事件
- 演示了基于事件、共享状态、消息传递等多种通信机制
- 实现了消息验证、权限控制、批处理和缓存等高级功能

### 8.11.4 路由说明

- `/` - 主页面
- `/user` - 用户应用
- `/order` - 订单应用

## 8.12 参考资料

1. PostMessage API文档：https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage
2. CustomEvent API文档：https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent
3. WebSocket API文档：https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
4. Module Federation文档：https://module-federation.io/