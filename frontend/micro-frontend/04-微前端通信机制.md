# 第四章：微前端通信机制

## 4.1 微前端通信概述

### 4.1.1 通信挑战

微前端架构中，应用间的通信是一个核心挑战。由于各个微应用可能运行在不同的环境中，甚至使用不同的技术栈，因此需要设计一套有效的通信机制来解决以下问题：

1. **跨域通信限制**：浏览器同源策略限制了不同源之间的直接通信
2. **数据隔离与共享**：如何在保证应用独立性的同时实现必要的数据共享
3. **实时性要求**：某些场景下需要实时同步状态和数据
4. **性能影响**：通信机制不应显著影响应用性能
5. **开发复杂度**：通信方案应简单易用，降低开发复杂度

### 4.1.2 通信分类

微前端通信可以根据不同维度进行分类：

#### 按通信方向分类
- **父应用到子应用**：主应用向微应用传递数据和指令
- **子应用到父应用**：微应用向主应用反馈状态和结果
- **子应用间通信**：不同微应用之间的直接或间接通信

#### 按通信方式分类
- **直接通信**：应用间直接调用API或方法
- **间接通信**：通过中间层（如事件总线、全局状态）进行通信
- **持久化通信**：通过共享存储（如localStorage、IndexedDB）进行通信

#### 按同步性分类
- **同步通信**：请求后立即获得响应
- **异步通信**：请求后通过回调、Promise或事件获得响应

## 4.2 基于事件总线的通信机制

### 4.2.1 事件总线原理

事件总线是一种发布/订阅模式的实现，允许应用间通过事件进行解耦通信。其核心原理是：

1. **事件注册**：应用可以注册感兴趣的事件类型
2. **事件发布**：应用可以发布特定类型的事件
3. **事件分发**：事件总线将事件分发给所有注册的监听器

```javascript
// 简单事件总线实现
class EventBus {
  constructor() {
    this.events = {};
  }
  
  // 订阅事件
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(callback);
    
    // 返回取消订阅函数
    return () => {
      this.events[eventName] = this.events[eventName].filter(cb => cb !== callback);
    };
  }
  
  // 发布事件
  emit(eventName, data) {
    if (this.events[eventName]) {
      this.events[eventName].forEach(callback => {
        callback(data);
      });
    }
  }
  
  // 取消订阅
  off(eventName, callback) {
    if (this.events[eventName]) {
      this.events[eventName] = this.events[eventName].filter(cb => cb !== callback);
    }
  }
  
  // 清空所有事件
  clear() {
    this.events = {};
  }
}

// 创建全局事件总线
const globalEventBus = new EventBus();

// 导出事件总线
export default globalEventBus;
```

### 4.2.2 跨应用事件总线实现

在微前端环境中，需要实现跨应用的事件总线，可以通过以下几种方式：

#### 基于全局变量的实现

```javascript
// 主应用中初始化事件总线
class MicroEventBus {
  constructor() {
    this.eventBus = new EventBus();
    // 将事件总线挂载到全局对象
    window.__MICRO_EVENT_BUS__ = this.eventBus;
  }
  
  getEventBus() {
    return this.eventBus;
  }
}

// 创建并导出微前端事件总线
const microEventBus = new MicroEventBus();
export default microEventBus;
```

#### 基于自定义事件的实现

```javascript
// 基于浏览器CustomEvent API的跨应用事件总线
class CustomEventBus {
  constructor() {
    // 初始化事件监听
    this.init();
  }
  
  init() {
    // 监听来自其他应用的事件
    window.addEventListener('micro-frontend-event', this.handleEvent.bind(this));
  }
  
  handleEvent(event) {
    const { eventName, data, sourceApp } = event.detail;
    
    // 触发内部事件
    this.emit(eventName, data, sourceApp);
  }
  
  // 发布事件
  emit(eventName, data, sourceApp = 'unknown') {
    const customEvent = new CustomEvent('micro-frontend-event', {
      detail: { eventName, data, sourceApp }
    });
    
    window.dispatchEvent(customEvent);
  }
  
  // 订阅事件
  on(eventName, callback) {
    const handler = (event) => {
      const { eventName: receivedEventName, data, sourceApp } = event.detail;
      
      if (receivedEventName === eventName) {
        callback(data, sourceApp);
      }
    };
    
    window.addEventListener('micro-frontend-event', handler);
    
    // 返回取消订阅函数
    return () => {
      window.removeEventListener('micro-frontend-event', handler);
    };
  }
}

// 创建全局事件总线实例
const customEventBus = new CustomEventBus();
export default customEventBus;
```

#### 基于iframe的实现

```javascript
// 基于iframe的跨应用事件总线
class IframeEventBus {
  constructor() {
    this.listeners = {};
    this.targetOrigin = '*'; // 在生产环境中应指定具体域名
    
    // 监听来自iframe的消息
    window.addEventListener('message', this.handleMessage.bind(this));
  }
  
  handleMessage(event) {
    // 验证消息来源
    if (event.origin !== window.location.origin && this.targetOrigin !== '*') {
      return;
    }
    
    const { type, eventName, data, sourceApp } = event.data;
    
    if (type === 'micro-event-bus') {
      this.emit(eventName, data, sourceApp);
    }
  }
  
  // 发布事件
  emit(eventName, data, sourceApp = 'unknown') {
    // 触发本地监听器
    if (this.listeners[eventName]) {
      this.listeners[eventName].forEach(callback => {
        callback(data, sourceApp);
      });
    }
    
    // 向所有iframe发送消息
    const iframes = document.querySelectorAll('iframe');
    iframes.forEach(iframe => {
      if (iframe.contentWindow) {
        iframe.contentWindow.postMessage({
          type: 'micro-event-bus',
          eventName,
          data,
          sourceApp
        }, this.targetOrigin);
      }
    });
  }
  
  // 订阅事件
  on(eventName, callback) {
    if (!this.listeners[eventName]) {
      this.listeners[eventName] = [];
    }
    
    this.listeners[eventName].push(callback);
    
    // 返回取消订阅函数
    return () => {
      this.listeners[eventName] = this.listeners[eventName].filter(cb => cb !== callback);
    };
  }
}

// 创建全局事件总线实例
const iframeEventBus = new IframeEventBus();
export default iframeEventBus;
```

### 4.2.3 事件总线的高级特性

#### 事件命名空间

```javascript
// 带命名空间的事件总线
class NamespacedEventBus extends EventBus {
  constructor(namespace) {
    super();
    this.namespace = namespace;
  }
  
  // 订阅事件
  on(eventName, callback) {
    const namespacedEventName = `${this.namespace}:${eventName}`;
    return super.on(namespacedEventName, callback);
  }
  
  // 发布事件
  emit(eventName, data) {
    const namespacedEventName = `${this.namespace}:${eventName}`;
    return super.emit(namespacedEventName, data);
  }
  
  // 取消订阅
  off(eventName, callback) {
    const namespacedEventName = `${this.namespace}:${eventName}`;
    return super.off(namespacedEventName, callback);
  }
}

// 创建不同命名空间的事件总线
const userEventBus = new NamespacedEventBus('user');
const orderEventBus = new NamespacedEventBus('order');

// 使用示例
userEventBus.on('login', (userData) => {
  console.log('用户登录:', userData);
});

orderEventBus.on('created', (orderData) => {
  console.log('订单创建:', orderData);
});
```

#### 事件中间件

```javascript
// 支持中间件的事件总线
class MiddlewareEventBus extends EventBus {
  constructor() {
    super();
    this.middlewares = [];
  }
  
  // 添加中间件
  use(middleware) {
    this.middlewares.push(middleware);
  }
  
  // 发布事件（带中间件处理）
  emit(eventName, data) {
    // 创建事件上下文
    const context = {
      eventName,
      data,
      cancel: false,
      result: undefined
    };
    
    // 执行中间件
    const runMiddlewares = (index) => {
      if (index >= this.middlewares.length) {
        // 所有中间件执行完毕，触发事件
        if (!context.cancel) {
          super.emit(eventName, context.data);
        }
        return;
      }
      
      const middleware = this.middlewares[index];
      middleware(context, () => runMiddlewares(index + 1));
    };
    
    runMiddlewares(0);
  }
}

// 创建支持中间件的事件总线
const middlewareEventBus = new MiddlewareEventBus();

// 添加日志中间件
middlewareEventBus.use((context, next) => {
  console.log(`事件触发: ${context.eventName}`, context.data);
  next();
});

// 添加权限检查中间件
middlewareEventBus.use((context, next) => {
  if (context.eventName === 'admin-action' && !isAdmin()) {
    console.warn('无权限执行管理员操作');
    context.cancel = true;
    return;
  }
  next();
});

// 添加数据转换中间件
middlewareEventBus.use((context, next) => {
  if (context.eventName === 'user-login') {
    // 标准化用户数据
    context.data = {
      id: context.data.userId,
      name: context.data.userName,
      email: context.data.userEmail
    };
  }
  next();
});
```

## 4.3 基于共享状态的通信机制

### 4.3.1 共享状态设计原则

在微前端架构中设计共享状态时，应遵循以下原则：

1. **最小化共享**：只共享必要的状态，避免过度耦合
2. **明确所有权**：每个状态应有明确的所有者
3. **不可变性**：共享状态应采用不可变数据结构
4. **版本控制**：状态变更应有明确的版本追踪
5. **性能优化**：避免不必要的状态更新和重渲染

### 4.3.2 基于全局对象的共享状态

```javascript
// 简单的全局状态管理
class GlobalState {
  constructor(initialState = {}) {
    this.state = initialState;
    this.listeners = {};
  }
  
  // 获取状态
  getState(key) {
    if (key) {
      return this.state[key];
    }
    return { ...this.state };
  }
  
  // 更新状态
  setState(updates) {
    const prevState = { ...this.state };
    
    // 合并状态
    this.state = { ...this.state, ...updates };
    
    // 通知监听器
    Object.keys(updates).forEach(key => {
      if (this.listeners[key]) {
        this.listeners[key].forEach(listener => {
          listener(this.state[key], prevState[key], key);
        });
      }
    });
  }
  
  // 订阅状态变化
  subscribe(key, listener) {
    if (!this.listeners[key]) {
      this.listeners[key] = [];
    }
    
    this.listeners[key].push(listener);
    
    // 返回取消订阅函数
    return () => {
      this.listeners[key] = this.listeners[key].filter(l => l !== listener);
    };
  }
  
  // 批量更新状态
  batchUpdate(updates) {
    const prevState = { ...this.state };
    
    // 合并状态
    this.state = { ...this.state, ...updates };
    
    // 通知所有相关监听器
    Object.keys(updates).forEach(key => {
      if (this.listeners[key]) {
        this.listeners[key].forEach(listener => {
          listener(this.state[key], prevState[key], key);
        });
      }
    });
  }
}

// 创建全局状态实例
const globalState = new GlobalState({
  user: null,
  theme: 'light',
  language: 'zh-CN'
});

// 将全局状态挂载到window对象
window.__MICRO_GLOBAL_STATE__ = globalState;

export default globalState;
```

### 4.3.3 基于Redux的共享状态

```javascript
// 基于Redux的微前端共享状态
import { createStore, combineReducers, applyMiddleware } from 'redux';

// 用户状态管理
const userReducer = (state = null, action) => {
  switch (action.type) {
    case 'USER_LOGIN':
      return action.payload;
    case 'USER_LOGOUT':
      return null;
    case 'USER_UPDATE':
      return { ...state, ...action.payload };
    default:
      return state;
  }
};

// 主题状态管理
const themeReducer = (state = 'light', action) => {
  switch (action.type) {
    case 'THEME_CHANGE':
      return action.payload;
    default:
      return state;
  }
};

// 通知状态管理
const notificationReducer = (state = [], action) => {
  switch (action.type) {
    case 'NOTIFICATION_ADD':
      return [...state, action.payload];
    case 'NOTIFICATION_REMOVE':
      return state.filter(n => n.id !== action.payload);
    case 'NOTIFICATION_CLEAR':
      return [];
    default:
      return state;
  }
};

// 创建根reducer
const rootReducer = combineReducers({
  user: userReducer,
  theme: themeReducer,
  notification: notificationReducer
});

// 创建中间件，用于记录状态变更来源
const sourceMiddleware = store => next => action => {
  // 添加来源信息到action
  if (!action.meta) {
    action.meta = {};
  }
  action.meta.source = window.__MICRO_APP_NAME__ || 'unknown';
  action.meta.timestamp = Date.now();
  
  return next(action);
};

// 创建store
const store = createStore(
  rootReducer,
  applyMiddleware(sourceMiddleware)
);

// 将store挂载到全局
window.__MICRO_REDUX_STORE__ = store;

export default store;
```

### 4.3.4 基于Vuex的共享状态（Vue环境）

```javascript
// 基于Vuex的微前端共享状态
import { createStore } from 'vuex';

// 创建共享store
const sharedStore = createStore({
  state: {
    user: null,
    theme: 'light',
    language: 'zh-CN',
    notifications: []
  },
  
  mutations: {
    setUser(state, user) {
      state.user = user;
    },
    
    setTheme(state, theme) {
      state.theme = theme;
    },
    
    setLanguage(state, language) {
      state.language = language;
    },
    
    addNotification(state, notification) {
      state.notifications.push({
        ...notification,
        id: Date.now(),
        timestamp: new Date()
      });
    },
    
    removeNotification(state, id) {
      state.notifications = state.notifications.filter(n => n.id !== id);
    }
  },
  
  actions: {
    login({ commit }, userData) {
      commit('setUser', userData);
    },
    
    logout({ commit }) {
      commit('setUser', null);
    },
    
    changeTheme({ commit }, theme) {
      commit('setTheme', theme);
    },
    
    changeLanguage({ commit }, language) {
      commit('setLanguage', language);
    },
    
    addNotification({ commit }, notification) {
      commit('addNotification', notification);
    },
    
    removeNotification({ commit }, id) {
      commit('removeNotification', id);
    }
  },
  
  getters: {
    isLoggedIn: state => !!state.user,
    userName: state => state.user ? state.user.name : '',
    unreadNotifications: state => state.notifications.filter(n => !n.read)
  }
});

// 将store挂载到全局
window.__MICRO_VUEX_STORE__ = sharedStore;

export default sharedStore;
```

## 4.4 基于LocalStorage的通信机制

### 4.4.1 LocalStorage通信原理

LocalStorage是浏览器提供的持久化存储方案，可以用于跨应用通信。其原理是：

1. **写入存储**：一个应用将数据写入LocalStorage
2. **存储事件**：浏览器触发storage事件，通知其他标签页
3. **读取存储**：其他应用监听storage事件并读取数据

### 4.4.2 LocalStorage通信实现

```javascript
// 基于LocalStorage的通信机制
class StorageEventBus {
  constructor(prefix = 'micro-frontend') {
    this.prefix = prefix;
    this.listeners = {};
    
    // 监听storage事件
    window.addEventListener('storage', this.handleStorageEvent.bind(this));
  }
  
  // 处理storage事件
  handleStorageEvent(event) {
    // 只处理我们关心的事件
    if (!event.key || !event.key.startsWith(this.prefix)) {
      return;
    }
    
    // 解析事件名
    const eventName = event.key.replace(`${this.prefix}-`, '');
    
    // 解析数据
    let data;
    try {
      data = JSON.parse(event.newValue || '{}');
    } catch (e) {
      console.error('解析LocalStorage数据失败:', e);
      return;
    }
    
    // 触发事件
    this.emit(eventName, data.data, data.source);
  }
  
  // 发布事件
  emit(eventName, data, source = window.__MICRO_APP_NAME__ || 'unknown') {
    const key = `${this.prefix}-${eventName}`;
    const value = JSON.stringify({
      data,
      source,
      timestamp: Date.now()
    });
    
    try {
      localStorage.setItem(key, value);
      
      // 触发本地监听器
      if (this.listeners[eventName]) {
        this.listeners[eventName].forEach(callback => {
          callback(data, source);
        });
      }
    } catch (e) {
      console.error('写入LocalStorage失败:', e);
    }
  }
  
  // 订阅事件
  on(eventName, callback) {
    if (!this.listeners[eventName]) {
      this.listeners[eventName] = [];
    }
    
    this.listeners[eventName].push(callback);
    
    // 返回取消订阅函数
    return () => {
      this.listeners[eventName] = this.listeners[eventName].filter(cb => cb !== callback);
    };
  }
  
  // 清理过期数据
  cleanup(maxAge = 24 * 60 * 60 * 1000) { // 默认24小时
    const now = Date.now();
    const keysToRemove = [];
    
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      
      if (key && key.startsWith(this.prefix)) {
        try {
          const value = JSON.parse(localStorage.getItem(key) || '{}');
          
          if (now - value.timestamp > maxAge) {
            keysToRemove.push(key);
          }
        } catch (e) {
          // 解析失败，也删除
          keysToRemove.push(key);
        }
      }
    }
    
    keysToRemove.forEach(key => {
      localStorage.removeItem(key);
    });
    
    return keysToRemove.length;
  }
}

// 创建全局存储事件总线
const storageEventBus = new StorageEventBus();

export default storageEventBus;
```

### 4.4.3 IndexedDB通信实现

```javascript
// 基于IndexedDB的通信机制
class IndexedDBEventBus {
  constructor(dbName = 'MicroFrontendDB', version = 1, storeName = 'events') {
    this.dbName = dbName;
    this.version = version;
    this.storeName = storeName;
    this.db = null;
    this.listeners = {};
    
    this.init();
  }
  
  // 初始化数据库
  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => {
        reject(new Error('打开IndexedDB失败'));
      };
      
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // 创建事件存储
        if (!db.objectStoreNames.contains(this.storeName)) {
          const store = db.createObjectStore(this.storeName, { keyPath: 'id' });
          store.createIndex('eventName', 'eventName', { unique: false });
          store.createIndex('timestamp', 'timestamp', { unique: false });
        }
      };
    });
  }
  
  // 发布事件
  async emit(eventName, data, source = window.__MICRO_APP_NAME__ || 'unknown') {
    if (!this.db) {
      await this.init();
    }
    
    const event = {
      id: `${eventName}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      eventName,
      data,
      source,
      timestamp: Date.now()
    };
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.add(event);
      
      request.onsuccess = () => {
        // 触发本地监听器
        if (this.listeners[eventName]) {
          this.listeners[eventName].forEach(callback => {
            callback(data, source);
          });
        }
        
        resolve(event.id);
      };
      
      request.onerror = () => {
        reject(new Error('添加事件到IndexedDB失败'));
      };
    });
  }
  
  // 订阅事件
  on(eventName, callback) {
    if (!this.listeners[eventName]) {
      this.listeners[eventName] = [];
      
      // 启动事件监听
      this.startEventListener(eventName);
    }
    
    this.listeners[eventName].push(callback);
    
    // 返回取消订阅函数
    return () => {
      this.listeners[eventName] = this.listeners[eventName].filter(cb => cb !== callback);
      
      // 如果没有监听器了，停止监听
      if (this.listeners[eventName].length === 0) {
        this.stopEventListener(eventName);
      }
    };
  }
  
  // 启动事件监听
  startEventListener(eventName) {
    const checkInterval = 500; // 检查间隔
    let lastTimestamp = Date.now();
    
    const check = async () => {
      if (!this.listeners[eventName] || this.listeners[eventName].length === 0) {
        return;
      }
      
      try {
        const events = await this.getEventsSince(eventName, lastTimestamp);
        
        if (events.length > 0) {
          lastTimestamp = Math.max(...events.map(e => e.timestamp));
          
          events.forEach(event => {
            if (this.listeners[eventName]) {
              this.listeners[eventName].forEach(callback => {
                callback(event.data, event.source);
              });
            }
          });
        }
      } catch (e) {
        console.error('检查IndexedDB事件失败:', e);
      }
      
      // 继续检查
      if (this.listeners[eventName] && this.listeners[eventName].length > 0) {
        setTimeout(check, checkInterval);
      }
    };
    
    // 开始检查
    setTimeout(check, checkInterval);
  }
  
  // 停止事件监听
  stopEventListener(eventName) {
    // 由于使用定时器检查，停止监听只需要删除监听器数组
    // 下一次检查时会自动停止
  }
  
  // 获取指定时间之后的事件
  async getEventsSince(eventName, timestamp) {
    if (!this.db) {
      await this.init();
    }
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const index = store.index('eventName');
      const request = index.openCursor(IDBKeyRange.only(eventName));
      
      const events = [];
      
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        
        if (cursor) {
          if (cursor.value.timestamp > timestamp) {
            events.push(cursor.value);
          }
          cursor.continue();
        } else {
          resolve(events);
        }
      };
      
      request.onerror = () => {
        reject(new Error('查询IndexedDB事件失败'));
      };
    });
  }
  
  // 清理过期事件
  async cleanup(maxAge = 24 * 60 * 60 * 1000) { // 默认24小时
    if (!this.db) {
      await this.init();
    }
    
    const now = Date.now();
    const cutoffTime = now - maxAge;
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const index = store.index('timestamp');
      const request = index.openCursor(IDBKeyRange.upperBound(cutoffTime));
      
      let deletedCount = 0;
      
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        
        if (cursor) {
          cursor.delete();
          deletedCount++;
          cursor.continue();
        } else {
          resolve(deletedCount);
        }
      };
      
      request.onerror = () => {
        reject(new Error('清理IndexedDB事件失败'));
      };
    });
  }
}

// 创建全局IndexedDB事件总线
const indexedDBEventBus = new IndexedDBEventBus();

export default indexedDBEventBus;
```

## 4.5 基于PostMessage的通信机制

### 4.5.1 PostMessage通信原理

PostMessage是HTML5提供的跨文档通信API，允许不同窗口、iframe之间安全通信。其原理是：

1. **消息发送**：一个窗口使用postMessage发送消息
2. **消息传递**：浏览器将消息传递给目标窗口
3. **消息接收**：目标窗口监听message事件接收消息
4. **安全验证**：接收方可以验证消息来源和内容

### 4.5.2 PostMessage通信实现

```javascript
// 基于PostMessage的通信机制
class PostMessageEventBus {
  constructor(targetOrigin = '*') {
    this.targetOrigin = targetOrigin;
    this.listeners = {};
    this.messageQueue = [];
    this.isReady = false;
    
    // 监听消息
    window.addEventListener('message', this.handleMessage.bind(this));
  }
  
  // 设置就绪状态
  ready() {
    this.isReady = true;
    
    // 处理消息队列
    while (this.messageQueue.length > 0) {
      const { targetWindow, eventName, data, source } = this.messageQueue.shift();
      this.sendMessage(targetWindow, eventName, data, source);
    }
  }
  
  // 处理接收到的消息
  handleMessage(event) {
    // 验证来源
    if (this.targetOrigin !== '*' && event.origin !== this.targetOrigin) {
      return;
    }
    
    // 验证消息格式
    if (!event.data || typeof event.data !== 'object' || !event.data.type) {
      return;
    }
    
    // 只处理我们关心的消息
    if (event.data.type !== 'micro-frontend-event') {
      return;
    }
    
    const { eventName, data, source, target } = event.data;
    
    // 检查是否是发给当前应用的
    if (target && target !== window.__MICRO_APP_NAME__) {
      return;
    }
    
    // 触发事件
    this.emit(eventName, data, source);
  }
  
  // 发送消息
  sendMessage(targetWindow, eventName, data, source) {
    if (!targetWindow) {
      console.warn('目标窗口不存在');
      return;
    }
    
    const message = {
      type: 'micro-frontend-event',
      eventName,
      data,
      source: source || window.__MICRO_APP_NAME__ || 'unknown',
      timestamp: Date.now()
    };
    
    try {
      targetWindow.postMessage(message, this.targetOrigin);
    } catch (e) {
      console.error('发送PostMessage失败:', e);
    }
  }
  
  // 发布事件
  emit(eventName, data, source) {
    // 触发本地监听器
    if (this.listeners[eventName]) {
      this.listeners[eventName].forEach(callback => {
        callback(data, source);
      });
    }
    
    // 发送给父窗口
    if (window.parent && window.parent !== window) {
      if (this.isReady) {
        this.sendMessage(window.parent, eventName, data, source);
      } else {
        // 添加到消息队列
        this.messageQueue.push({
          targetWindow: window.parent,
          eventName,
          data,
          source
        });
      }
    }
    
    // 发送给所有iframe子窗口
    const iframes = document.querySelectorAll('iframe');
    iframes.forEach(iframe => {
      if (iframe.contentWindow) {
        if (this.isReady) {
          this.sendMessage(iframe.contentWindow, eventName, data, source);
        } else {
          // 添加到消息队列
          this.messageQueue.push({
            targetWindow: iframe.contentWindow,
            eventName,
            data,
            source
          });
        }
      }
    });
  }
  
  // 订阅事件
  on(eventName, callback) {
    if (!this.listeners[eventName]) {
      this.listeners[eventName] = [];
    }
    
    this.listeners[eventName].push(callback);
    
    // 返回取消订阅函数
    return () => {
      this.listeners[eventName] = this.listeners[eventName].filter(cb => cb !== callback);
    };
  }
  
  // 发送给特定应用
  sendToApp(appName, eventName, data) {
    // 查找目标iframe
    const iframes = document.querySelectorAll('iframe');
    for (const iframe of iframes) {
      if (iframe.getAttribute('data-app-name') === appName) {
        if (iframe.contentWindow) {
          this.sendMessage(
            iframe.contentWindow,
            eventName,
            data,
            window.__MICRO_APP_NAME__ || 'unknown'
          );
          return true;
        }
      }
    }
    
    // 如果是子应用，发送给父应用
    if (window.parent && window.parent !== window) {
      const message = {
        type: 'micro-frontend-event',
        eventName,
        data,
        target: appName,
        source: window.__MICRO_APP_NAME__ || 'unknown',
        timestamp: Date.now()
      };
      
      try {
        window.parent.postMessage(message, this.targetOrigin);
        return true;
      } catch (e) {
        console.error('发送PostMessage失败:', e);
      }
    }
    
    return false;
  }
}

// 创建全局PostMessage事件总线
const postMessageEventBus = new PostMessageEventBus();

export default postMessageEventBus;
```

## 4.6 微前端通信最佳实践

### 4.6.1 通信方案选择指南

根据不同的场景和需求，选择合适的通信方案：

| 场景 | 推荐方案 | 优点 | 缺点 |
|------|----------|------|------|
| 同一页面内的应用通信 | 事件总线/共享状态 | 实时性好，实现简单 | 内存占用，耦合度较高 |
| 跨标签页应用通信 | LocalStorage/IndexedDB | 持久化，跨标签页共享 | 实时性差，存储容量限制 |
| 跨域应用通信 | PostMessage | 安全，支持跨域 | 实现复杂，需要安全验证 |
| 复杂状态共享 | Redux/Vuex | 状态管理规范，调试方便 | 学习成本高，可能过度设计 |
| 简单数据传递 | 全局变量/自定义事件 | 实现简单，性能好 | 命名冲突，调试困难 |

### 4.6.2 通信安全考虑

在实现微前端通信时，需要考虑以下安全问题：

1. **数据验证**：验证接收到的数据格式和内容
2. **来源验证**：验证消息来源是否可信
3. **权限控制**：根据应用权限限制通信内容
4. **敏感信息**：避免通过通信机制传递敏感信息
5. **XSS防护**：防止恶意脚本通过通信机制注入

```javascript
// 安全通信包装器
class SecureEventBus extends EventBus {
  constructor(options = {}) {
    super();
    this.allowedOrigins = options.allowedOrigins || [];
    this.allowedEvents = options.allowedEvents || [];
    this.maxDataSize = options.maxDataSize || 1024 * 1024; // 1MB
    this.sanitizeData = options.sanitizeData || this.defaultSanitizeData;
  }
  
  // 默认数据清理函数
  defaultSanitizeData(data) {
    // 简单的数据清理，实际应用中应根据需求实现
    if (typeof data === 'string') {
      // 移除可能的脚本标签
      return data.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
    }
    return data;
  }
  
  // 安全发布事件
  emit(eventName, data, options = {}) {
    // 验证事件名
    if (this.allowedEvents.length > 0 && !this.allowedEvents.includes(eventName)) {
      console.warn(`不允许的事件: ${eventName}`);
      return;
    }
    
    // 验证数据大小
    const dataSize = JSON.stringify(data).length;
    if (dataSize > this.maxDataSize) {
      console.warn(`数据大小超过限制: ${dataSize} > ${this.maxDataSize}`);
      return;
    }
    
    // 清理数据
    const sanitizedData = this.sanitizeData(data);
    
    // 调用父类方法
    super.emit(eventName, sanitizedData);
  }
  
  // 安全订阅事件
  on(eventName, callback, options = {}) {
    // 验证事件名
    if (this.allowedEvents.length > 0 && !this.allowedEvents.includes(eventName)) {
      console.warn(`不允许的事件: ${eventName}`);
      return () => {};
    }
    
    // 包装回调函数
    const wrappedCallback = (data) => {
      try {
        // 验证数据
        if (options.validator && !options.validator(data)) {
          console.warn(`事件数据验证失败: ${eventName}`);
          return;
        }
        
        // 调用原始回调
        callback(data);
      } catch (e) {
        console.error(`处理事件时出错: ${eventName}`, e);
      }
    };
    
    // 调用父类方法
    return super.on(eventName, wrappedCallback);
  }
}

// 创建安全事件总线
const secureEventBus = new SecureEventBus({
  allowedOrigins: ['https://app1.example.com', 'https://app2.example.com'],
  allowedEvents: ['user-login', 'user-logout', 'theme-change'],
  maxDataSize: 512 * 1024 // 512KB
});
```

### 4.6.3 性能优化建议

1. **事件节流与防抖**：对频繁触发的事件进行节流或防抖处理
2. **数据压缩**：对大数据进行压缩后再传输
3. **批量更新**：将多个小更新合并为一个大更新
4. **懒加载**：按需加载通信模块
5. **缓存机制**：对频繁访问的数据进行缓存

```javascript
// 性能优化的事件总线
class OptimizedEventBus extends EventBus {
  constructor() {
    super();
    this.throttledEvents = new Map();
    this.debouncedEvents = new Map();
    this.batchedEvents = [];
    this.batchTimer = null;
    this.batchInterval = 16; // 约60fps
  }
  
  // 节流事件
  throttledEmit(eventName, data, delay = 100) {
    if (this.throttledEvents.has(eventName)) {
      return;
    }
    
    this.emit(eventName, data);
    
    this.throttledEvents.set(eventName, true);
    setTimeout(() => {
      this.throttledEvents.delete(eventName);
    }, delay);
  }
  
  // 防抖事件
  debouncedEmit(eventName, data, delay = 100) {
    if (this.debouncedEvents.has(eventName)) {
      clearTimeout(this.debouncedEvents.get(eventName));
    }
    
    const timer = setTimeout(() => {
      this.emit(eventName, data);
      this.debouncedEvents.delete(eventName);
    }, delay);
    
    this.debouncedEvents.set(eventName, timer);
  }
  
  // 批量事件
  batchEmit(eventName, data) {
    this.batchedEvents.push({ eventName, data });
    
    if (!this.batchTimer) {
      this.batchTimer = setTimeout(() => {
        // 按事件名分组
        const eventsByType = {};
        this.batchedEvents.forEach(event => {
          if (!eventsByType[event.eventName]) {
            eventsByType[event.eventName] = [];
          }
          eventsByType[event.eventName].push(event.data);
        });
        
        // 触发批量事件
        Object.keys(eventsByType).forEach(eventName => {
          this.emit(eventName, eventsByType[eventName]);
        });
        
        // 清空批量事件
        this.batchedEvents = [];
        this.batchTimer = null;
      }, this.batchInterval);
    }
  }
  
  // 压缩数据
  compressData(data) {
    try {
      // 简单的数据压缩，实际应用中可以使用更高效的压缩算法
      const jsonString = JSON.stringify(data);
      return btoa(jsonString);
    } catch (e) {
      console.error('数据压缩失败:', e);
      return data;
    }
  }
  
  // 解压数据
  decompressData(compressedData) {
    try {
      const jsonString = atob(compressedData);
      return JSON.parse(jsonString);
    } catch (e) {
      console.error('数据解压失败:', e);
      return compressedData;
    }
  }
  
  // 发送压缩数据
  emitCompressed(eventName, data) {
    const compressedData = this.compressData(data);
    this.emit(eventName, { __compressed: true, data: compressedData });
  }
}

// 创建优化的事件总线
const optimizedEventBus = new OptimizedEventBus();

// 使用示例
optimizedEventBus.throttledEmit('scroll', { scrollTop: window.scrollY }, 50);
optimizedEventBus.debouncedEmit('search', { query: 'example' }, 300);
optimizedEventBus.batchEmit('update', { id: 1, value: 'new' });
optimizedEventBus.emitCompressed('large-data', largeDataObject);
```

## 4.7 实战案例：微前端通信系统实现

### 4.7.1 统一通信接口设计

```javascript
// 统一的微前端通信接口
class MicroFrontendCommunication {
  constructor(options = {}) {
    this.options = {
      // 默认配置
      eventBus: true,
      sharedState: true,
      localStorage: true,
      postMessage: true,
      ...options
    };
    
    // 初始化各种通信方式
    this.init();
  }
  
  // 初始化通信方式
  init() {
    // 事件总线
    if (this.options.eventBus) {
      this.eventBus = new EventBus();
    }
    
    // 共享状态
    if (this.options.sharedState) {
      this.sharedState = new GlobalState();
    }
    
    // LocalStorage通信
    if (this.options.localStorage) {
      this.storageBus = new StorageEventBus();
    }
    
    // PostMessage通信
    if (this.options.postMessage) {
      this.messageBus = new PostMessageEventBus();
    }
  }
  
  // 统一的事件发布接口
  emit(eventName, data, options = {}) {
    const { channel = 'eventBus', target, ...restOptions } = options;
    
    switch (channel) {
      case 'eventBus':
        if (this.eventBus) {
          this.eventBus.emit(eventName, data);
        }
        break;
        
      case 'storage':
        if (this.storageBus) {
          this.storageBus.emit(eventName, data);
        }
        break;
        
      case 'message':
        if (this.messageBus) {
          if (target) {
            this.messageBus.sendToApp(target, eventName, data);
          } else {
            this.messageBus.emit(eventName, data);
          }
        }
        break;
        
      default:
        console.warn(`未知的通信渠道: ${channel}`);
    }
  }
  
  // 统一的事件订阅接口
  on(eventName, callback, options = {}) {
    const { channel = 'eventBus', ...restOptions } = options;
    
    switch (channel) {
      case 'eventBus':
        return this.eventBus ? this.eventBus.on(eventName, callback) : () => {};
        
      case 'storage':
        return this.storageBus ? this.storageBus.on(eventName, callback) : () => {};
        
      case 'message':
        return this.messageBus ? this.messageBus.on(eventName, callback) : () => {};
        
      default:
        console.warn(`未知的通信渠道: ${channel}`);
        return () => {};
    }
  }
  
  // 统一的状态管理接口
  setState(updates) {
    if (this.sharedState) {
      this.sharedState.setState(updates);
    }
  }
  
  getState(key) {
    return this.sharedState ? this.sharedState.getState(key) : undefined;
  }
  
  subscribeState(key, callback) {
    return this.sharedState ? this.sharedState.subscribe(key, callback) : () => {};
  }
}

// 创建全局通信实例
const communication = new MicroFrontendCommunication();

// 挂载到全局
window.__MICRO_COMMUNICATION__ = communication;

export default communication;
```

### 4.7.2 微前端通信系统使用示例

```javascript
// 主应用中的使用
import communication from './communication';

// 监听子应用的用户登录事件
communication.on('user-login', (userData, sourceApp) => {
  console.log(`用户在 ${sourceApp} 中登录:`, userData);
  
  // 更新全局状态
  communication.setState({
    user: userData,
    isLoggedIn: true
  });
  
  // 通知其他子应用
  communication.emit('user-status-changed', {
    status: 'logged-in',
    user: userData
  }, { channel: 'storage' });
});

// 监听子应用的主题变更请求
communication.on('theme-change-request', (theme, sourceApp) => {
  console.log(`${sourceApp} 请求变更主题为:`, theme);
  
  // 更新全局主题
  communication.setState({ theme });
  
  // 通知所有应用主题变更
  communication.emit('theme-changed', theme);
});

// 子应用中的使用
import communication from './communication';

// 用户登录
function login(username, password) {
  // 登录逻辑...
  const userData = { id: 1, name: username, email: `${username}@example.com` };
  
  // 通知主应用
  communication.emit('user-login', userData);
}

// 请求主题变更
function changeTheme(theme) {
  // 请求主应用变更主题
  communication.emit('theme-change-request', theme);
}

// 监听主题变更
communication.on('theme-changed', (theme) => {
  // 应用新主题
  document.body.className = `theme-${theme}`;
});

// 监听用户状态变更
communication.on('user-status-changed', (data) => {
  if (data.status === 'logged-out') {
    // 用户在其他应用中登出，当前应用也需要登出
    logout();
  }
});
```

### 4.7.3 微前端通信调试工具

```javascript
// 微前端通信调试工具
class CommunicationDebugger {
  constructor(communication) {
    this.communication = communication;
    this.eventHistory = [];
    this.maxHistorySize = 100;
    this.isEnabled = false;
    
    // 初始化调试面板
    this.initDebugPanel();
  }
  
  // 启用调试
  enable() {
    if (this.isEnabled) {
      return;
    }
    
    this.isEnabled = true;
    
    // 拦截事件发布
    const originalEmit = this.communication.emit.bind(this.communication);
    this.communication.emit = (eventName, data, options) => {
      // 记录事件
      this.recordEvent('emit', eventName, data, options);
      
      // 调用原始方法
      return originalEmit(eventName, data, options);
    };
    
    // 拦截事件订阅
    const originalOn = this.communication.on.bind(this.communication);
    this.communication.on = (eventName, callback, options) => {
      // 记录订阅
      this.recordEvent('on', eventName, null, options);
      
      // 包装回调
      const wrappedCallback = (data, source) => {
        // 记录事件触发
        this.recordEvent('trigger', eventName, data, { source });
        
        // 调用原始回调
        return callback(data, source);
      };
      
      // 调用原始方法
      return originalOn(eventName, wrappedCallback, options);
    };
    
    console.log('微前端通信调试已启用');
  }
  
  // 禁用调试
  disable() {
    this.isEnabled = false;
    console.log('微前端通信调试已禁用');
  }
  
  // 记录事件
  recordEvent(type, eventName, data, options = {}) {
    if (!this.isEnabled) {
      return;
    }
    
    const event = {
      id: Date.now() + Math.random().toString(36).substr(2, 9),
      timestamp: new Date().toISOString(),
      type,
      eventName,
      data: data ? JSON.parse(JSON.stringify(data)) : null,
      options,
      source: window.__MICRO_APP_NAME__ || 'unknown'
    };
    
    // 添加到历史记录
    this.eventHistory.unshift(event);
    
    // 限制历史记录大小
    if (this.eventHistory.length > this.maxHistorySize) {
      this.eventHistory = this.eventHistory.slice(0, this.maxHistorySize);
    }
    
    // 更新调试面板
    this.updateDebugPanel();
  }
  
  // 初始化调试面板
  initDebugPanel() {
    // 创建调试面板容器
    this.debugPanel = document.createElement('div');
    this.debugPanel.id = 'micro-frontend-debugger';
    this.debugPanel.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      width: 400px;
      max-height: 600px;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      z-index: 10000;
      font-family: monospace;
      font-size: 12px;
      display: none;
      flex-direction: column;
    `;
    
    // 创建标题栏
    const header = document.createElement('div');
    header.style.cssText = `
      background: #f5f5f5;
      padding: 8px;
      border-bottom: 1px solid #ccc;
      display: flex;
      justify-content: space-between;
      align-items: center;
    `;
    
    const title = document.createElement('span');
    title.textContent = '微前端通信调试';
    header.appendChild(title);
    
    const closeBtn = document.createElement('button');
    closeBtn.textContent = '×';
    closeBtn.style.cssText = `
      background: none;
      border: none;
      font-size: 16px;
      cursor: pointer;
    `;
    closeBtn.onclick = () => {
      this.debugPanel.style.display = 'none';
    };
    header.appendChild(closeBtn);
    
    // 创建内容区域
    const content = document.createElement('div');
    content.style.cssText = `
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    `;
    
    // 创建控制区域
    const controls = document.createElement('div');
    controls.style.cssText = `
      padding: 8px;
      border-top: 1px solid #ccc;
      display: flex;
      gap: 8px;
    `;
    
    const clearBtn = document.createElement('button');
    clearBtn.textContent = '清空';
    clearBtn.onclick = () => {
      this.eventHistory = [];
      this.updateDebugPanel();
    };
    controls.appendChild(clearBtn);
    
    const exportBtn = document.createElement('button');
    exportBtn.textContent = '导出';
    exportBtn.onclick = () => {
      const data = JSON.stringify(this.eventHistory, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `micro-frontend-events-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
    };
    controls.appendChild(exportBtn);
    
    // 组装面板
    this.debugPanel.appendChild(header);
    this.debugPanel.appendChild(content);
    this.debugPanel.appendChild(controls);
    
    // 添加到页面
    document.body.appendChild(this.debugPanel);
    
    // 创建切换按钮
    this.toggleBtn = document.createElement('button');
    this.toggleBtn.textContent = '调试';
    this.toggleBtn.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 9999;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      cursor: pointer;
    `;
    this.toggleBtn.onclick = () => {
      this.debugPanel.style.display = 
        this.debugPanel.style.display === 'none' ? 'flex' : 'none';
    };
    
    document.body.appendChild(this.toggleBtn);
    
    // 保存内容区域引用
    this.debugContent = content;
  }
  
  // 更新调试面板
  updateDebugPanel() {
    if (!this.debugContent) {
      return;
    }
    
    // 清空内容
    this.debugContent.innerHTML = '';
    
    // 添加事件列表
    this.eventHistory.forEach(event => {
      const eventEl = document.createElement('div');
      eventEl.style.cssText = `
        margin-bottom: 8px;
        padding: 8px;
        border: 1px solid #eee;
        border-radius: 4px;
      `;
      
      // 事件头部
      const header = document.createElement('div');
      header.style.cssText = `
        display: flex;
        justify-content: space-between;
        margin-bottom: 4px;
        font-weight: bold;
      `;
      
      const type = document.createElement('span');
      type.textContent = event.type;
      type.style.color = this.getTypeColor(event.type);
      header.appendChild(type);
      
      const time = document.createElement('span');
      time.textContent = new Date(event.timestamp).toLocaleTimeString();
      time.style.color = #666;
      header.appendChild(time);
      
      eventEl.appendChild(header);
      
      // 事件详情
      const details = document.createElement('div');
      details.innerHTML = `
        <div><strong>事件:</strong> ${event.eventName}</div>
        <div><strong>来源:</strong> ${event.source}</div>
        ${event.data ? `<div><strong>数据:</strong> <pre>${JSON.stringify(event.data, null, 2)}</pre></div>` : ''}
        ${Object.keys(event.options).length > 0 ? `<div><strong>选项:</strong> <pre>${JSON.stringify(event.options, null, 2)}</pre></div>` : ''}
      `;
      
      eventEl.appendChild(details);
      
      this.debugContent.appendChild(eventEl);
    });
  }
  
  // 获取类型颜色
  getTypeColor(type) {
    switch (type) {
      case 'emit':
        return '#28a745';
      case 'on':
        return '#007bff';
      case 'trigger':
        return '#fd7e14';
      default:
        return '#6c757d';
    }
  }
}

// 创建调试器实例
const debugger = new CommunicationDebugger(communication);

// 全局暴露调试器
window.__MICRO_COMMUNICATION_DEBUGGER__ = debugger;

// 默认启用调试
debugger.enable();

export default debugger;
```

## 总结

本章详细介绍了微前端架构中的通信机制，包括：

1. **微前端通信概述**：分析了微前端通信面临的挑战和分类方式
2. **基于事件总线的通信机制**：实现了多种事件总线方案，包括全局变量、自定义事件和iframe实现
3. **基于共享状态的通信机制**：介绍了全局对象、Redux和Vuex等共享状态方案
4. **基于LocalStorage的通信机制**：实现了LocalStorage和IndexedDB通信方案
5. **基于PostMessage的通信机制**：实现了安全的跨域通信方案
6. **微前端通信最佳实践**：提供了通信方案选择指南、安全考虑和性能优化建议
7. **实战案例**：设计并实现了统一的微前端通信系统和调试工具

通过这些通信机制，微前端应用之间可以实现高效、安全的数据交换和状态同步，为构建复杂的微前端系统提供了坚实的基础。在实际项目中，应根据具体需求选择合适的通信方案，并注意安全性和性能优化。