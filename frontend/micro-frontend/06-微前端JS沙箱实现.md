# 第六章：微前端JS沙箱实现

## 6.1 JS沙箱概述

### 6.1.1 沙箱的必要性

在微前端架构中，JavaScript沙箱是一个关键的安全隔离机制。由于多个微应用可能同时运行在同一个页面中，它们的JavaScript代码可能会相互干扰，导致以下问题：

1. **全局变量污染**：不同应用可能定义相同的全局变量，导致变量覆盖
2. **原型链污染**：修改原型链可能影响其他应用
3. **全局事件监听冲突**：添加全局事件监听器可能影响其他应用
4. **DOM操作冲突**：不同应用可能操作相同的DOM元素
5. **API冲突**：重写或修改全局API可能影响其他应用
6. **安全风险**：恶意代码可能访问或修改其他应用的数据

### 6.1.2 沙箱原理与分类

JavaScript沙箱是一种限制代码执行环境的机制，通过隔离JavaScript执行上下文，防止代码之间的相互干扰。根据实现原理，JavaScript沙箱可以分为以下几类：

#### 按隔离程度分类
- **弱隔离**：只隔离部分全局变量和API，允许共享大部分环境
- **强隔离**：完全隔离JavaScript执行环境，提供独立的上下文
- **混合隔离**：结合弱隔离和强隔离的特点，根据需要进行选择性隔离

#### 按实现技术分类
- **快照沙箱**：通过保存和恢复环境快照实现隔离
- **代理沙箱**：使用ES6 Proxy API拦截和修改操作
- **iframe沙箱**：利用iframe的天然隔离特性
- **Web Worker沙箱**：使用Web Worker创建隔离的执行环境

#### 按作用时机分类
- **编译时沙箱**：在构建阶段处理代码隔离
- **运行时沙箱**：在代码执行时动态实现隔离
- **混合沙箱**：结合编译时和运行时的隔离方案

## 6.2 快照沙箱实现

### 6.2.1 快照沙箱原理

快照沙箱通过在应用加载前保存当前环境状态，在应用卸载后恢复环境状态，从而实现环境隔离。其原理是：

1. **环境快照**：在应用加载前保存当前全局环境状态
2. **应用执行**：在当前环境中执行应用代码
3. **环境恢复**：在应用卸载后恢复之前保存的环境状态

```javascript
// 快照沙箱实现
class SnapshotSandbox {
  constructor(name) {
    this.name = name;
    this.windowSnapshot = {};
    this.modifyPropsMap = {};
    this.active = false;
  }
  
  // 激活沙箱
  active() {
    // 记录当前时间点的window状态
    this.windowSnapshot = {};
    for (const prop in window) {
      this.windowSnapshot[prop] = window[prop];
    }
    
    // 恢复上次修改的属性
    Object.keys(this.modifyPropsMap).forEach(p => {
      window[p] = this.modifyPropsMap[p];
    });
    
    this.active = true;
  }
  
  // 退出沙箱
  inactive() {
    // 记录被修改的属性
    this.modifyPropsMap = {};
    for (const prop in window) {
      if (window[prop] !== this.windowSnapshot[prop]) {
        // 记录被修改的属性
        this.modifyPropsMap[prop] = window[prop];
        // 恢复初始值
        window[prop] = this.windowSnapshot[prop];
      }
    }
    
    this.active = false;
  }
}

// 使用示例
const sandbox = new SnapshotSandbox('app1');

// 激活沙箱
sandbox.active();

// 应用代码可以修改全局变量
window.globalVar = 'app1';
window.document.title = 'App1';

// 退出沙箱
sandbox.inactive();

// 全局变量被恢复
console.log(window.globalVar); // undefined
console.log(window.document.title); // 原始标题
```

### 6.2.2 增强版快照沙箱

基本快照沙箱存在性能问题，需要遍历所有window属性。增强版快照沙箱通过只记录被修改的属性来提高性能：

```javascript
// 增强版快照沙箱
class EnhancedSnapshotSandbox {
  constructor(name) {
    this.name = name;
    this.addedPropsMapInSandbox = {}; // 沙箱期间新增的属性
    this.modifiedPropsOriginalValueMapInSandbox = {}; // 沙箱期间被修改的属性
    this.currentUpdatedPropsValueMap = {}; // 记录沙箱期间最新的值
    this.active = false;
  }
  
  // 激活沙箱
  active() {
    this.currentUpdatedPropsValueMap = {};
    
    // 恢复上次沙箱结束前的状态
    Object.keys(this.addedPropsMapInSandbox).forEach(p => {
      window[p] = this.currentUpdatedPropsValueMap[p];
    });
    
    // 恢复被修改的属性
    Object.keys(this.modifiedPropsOriginalValueMapInSandbox).forEach(p => {
      const value = this.modifiedPropsOriginalValueMapInSandbox[p];
      if (value === undefined) {
        delete window[p];
      } else {
        window[p] = value;
      }
    });
    
    this.active = true;
  }
  
  // 退出沙箱
  inactive() {
    // 记录被修改的属性
    this.modifiedPropsOriginalValueMapInSandbox = {};
    this.addedPropsMapInSandbox = {};
    
    // 遍历window，记录变化
    for (const prop in window) {
      // 如果原始window中没有该属性，说明是新增的
      if (!(prop in this.windowSnapshot)) {
        this.addedPropsMapInSandbox[prop] = window[prop];
      } else if (window[prop] !== this.windowSnapshot[prop]) {
        // 记录被修改的属性及其原始值
        this.modifiedPropsOriginalValueMapInSandbox[prop] = this.windowSnapshot[prop];
        // 记录当前值
        this.currentUpdatedPropsValueMap[prop] = window[prop];
      }
    }
    
    this.active = false;
  }
}

// 微前端沙箱管理器
class SandboxManager {
  constructor() {
    this.sandboxes = new Map();
  }
  
  // 创建沙箱
  createSandbox(name, type = 'snapshot') {
    if (this.sandboxes.has(name)) {
      throw new Error(`沙箱 ${name} 已存在`);
    }
    
    let sandbox;
    
    switch (type) {
      case 'snapshot':
        sandbox = new SnapshotSandbox(name);
        break;
      case 'enhanced-snapshot':
        sandbox = new EnhancedSnapshotSandbox(name);
        break;
      case 'proxy':
        sandbox = new ProxySandbox(name);
        break;
      case 'iframe':
        sandbox = new IframeSandbox(name);
        break;
      default:
        throw new Error(`未知的沙箱类型: ${type}`);
    }
    
    this.sandboxes.set(name, sandbox);
    
    return sandbox;
  }
  
  // 获取沙箱
  getSandbox(name) {
    return this.sandboxes.get(name);
  }
  
  // 删除沙箱
  removeSandbox(name) {
    const sandbox = this.sandboxes.get(name);
    if (sandbox && sandbox.active) {
      sandbox.inactive();
    }
    
    return this.sandboxes.delete(name);
  }
  
  // 清空所有沙箱
  clear() {
    this.sandboxes.forEach((sandbox, name) => {
      if (sandbox.active) {
        sandbox.inactive();
      }
    });
    
    this.sandboxes.clear();
  }
}

// 创建全局沙箱管理器
const sandboxManager = new SandboxManager();

export default sandboxManager;
```

## 6.3 代理沙箱实现

### 6.3.1 代理沙箱原理

代理沙箱使用ES6 Proxy API创建一个代理对象，拦截对全局对象的访问和修改，从而实现环境隔离。其原理是：

1. **创建代理**：使用Proxy API创建window对象的代理
2. **拦截操作**：拦截对代理对象的读取、写入、删除等操作
3. **状态管理**：维护沙箱内部的状态，与外部环境隔离

```javascript
// 代理沙箱实现
class ProxySandbox {
  constructor(name) {
    this.name = name;
    this.sandboxRunning = false;
    this.globalVariableWhiteList = ['window', 'document', 'location', 'top', 'parent', 'self', 'history'];
    
    // 创建沙箱环境
    this.sandbox = this.createProxySandbox();
    
    // 沙箱激活状态
    this.active = false;
  }
  
  // 创建代理沙箱
  createProxySandbox() {
    const self = this;
    const rawWindow = window;
    
    // 创建沙箱的全局对象
    const fakeWindow = Object.create(null);
    
    // 创建代理对象
    const proxy = new Proxy(fakeWindow, {
      get(target, prop) {
        // 优先从沙箱内部获取
        if (prop in target) {
          return target[prop];
        }
        
        // 白名单属性直接从原始window获取
        if (self.globalVariableWhiteList.includes(prop)) {
          return rawWindow[prop];
        }
        
        // 其他属性从原始window获取
        const value = rawWindow[prop];
        
        // 如果是函数，绑定正确的this
        if (typeof value === 'function') {
          return value.bind(rawWindow);
        }
        
        return value;
      },
      
      set(target, prop, value) {
        if (self.sandboxRunning) {
          // 沙箱运行时，设置到沙箱内部
          target[prop] = value;
          
          // 如果是白名单属性，也设置到原始window
          if (self.globalVariableWhiteList.includes(prop)) {
            rawWindow[prop] = value;
          }
          
          return true;
        }
        
        // 沙箱未运行时，直接设置到原始window
        rawWindow[prop] = value;
        return true;
      },
      
      has(target, prop) {
        return prop in target || prop in rawWindow;
      },
      
      deleteProperty(target, prop) {
        if (self.sandboxRunning) {
          // 沙箱运行时，只删除沙箱内部的属性
          delete target[prop];
          return true;
        }
        
        // 沙箱未运行时，直接删除原始window的属性
        delete rawWindow[prop];
        return true;
      }
    });
    
    return proxy;
  }
  
  // 激活沙箱
  active() {
    this.sandboxRunning = true;
    this.active = true;
  }
  
  // 退出沙箱
  inactive() {
    this.sandboxRunning = false;
    this.active = false;
  }
  
  // 执行代码
  execCode(script) {
    if (!this.active) {
      throw new Error('沙箱未激活');
    }
    
    // 使用Function构造函数在沙箱环境中执行代码
    const func = new Function('window', 'document', 'location', 'navigator', 'history', script);
    
    return func(
      this.sandbox,
      this.sandbox.document,
      this.sandbox.location,
      this.sandbox.navigator,
      this.sandbox.history
    );
  }
}

// 使用示例
const sandbox = new ProxySandbox('app1');

// 激活沙箱
sandbox.active();

// 执行代码
sandbox.execCode(`
  window.globalVar = 'app1';
  console.log('全局变量:', window.globalVar);
`);

// 退出沙箱
sandbox.inactive();

// 检查全局变量
console.log(window.globalVar); // undefined
```

### 6.3.2 增强版代理沙箱

增强版代理沙箱支持更细粒度的控制和更完善的隔离：

```javascript
// 增强版代理沙箱
class EnhancedProxySandbox {
  constructor(name, options = {}) {
    this.name = name;
    this.sandboxRunning = false;
    
    // 配置选项
    this.options = {
      // 是否启用严格模式
      strictMode: true,
      // 是否允许访问原始window
      allowRawWindowAccess: false,
      // 全局变量白名单
      globalVariableWhiteList: [
        'window', 'document', 'location', 'top', 'parent', 'self', 
        'history', 'navigator', 'console', 'alert', 'confirm', 'prompt'
      ],
      // 全局函数白名单
      globalFunctionWhiteList: [
        'setTimeout', 'clearTimeout', 'setInterval', 'clearInterval',
        'requestAnimationFrame', 'cancelAnimationFrame',
        'addEventListener', 'removeEventListener'
      ],
      // 自定义白名单
      customWhiteList: [],
      // 自定义黑名单
      customBlackList: [],
      // 属性拦截器
      propertyInterceptors: {},
      // 函数拦截器
      functionInterceptors: {},
      ...options
    };
    
    // 合并白名单
    this.globalVariableWhiteList = [
      ...this.options.globalVariableWhiteList,
      ...this.options.customWhiteList
    ].filter(item => !this.options.customBlackList.includes(item));
    
    // 创建沙箱环境
    this.sandbox = this.createProxySandbox();
    
    // 沙箱激活状态
    this.active = false;
    
    // 记录沙箱内部状态
    this.injectedProps = new Map();
    
    // 记录被修改的原始属性
    this.modifiedOriginalProps = new Map();
  }
  
  // 创建代理沙箱
  createProxySandbox() {
    const self = this;
    const rawWindow = window;
    
    // 创建沙箱的全局对象
    const fakeWindow = Object.create(null);
    
    // 创建代理对象
    const proxy = new Proxy(fakeWindow, {
      get(target, prop) {
        // 优先从沙箱内部获取
        if (target.hasOwnProperty(prop)) {
          const value = target[prop];
          
          // 如果是函数，绑定正确的this
          if (typeof value === 'function') {
            return value.bind(proxy);
          }
          
          return value;
        }
        
        // 检查自定义属性拦截器
        if (self.options.propertyInterceptors[prop] && 
            typeof self.options.propertyInterceptors[prop].get === 'function') {
          return self.options.propertyInterceptors[prop].get(prop, proxy);
        }
        
        // 白名单属性直接从原始window获取
        if (self.globalVariableWhiteList.includes(prop)) {
          const value = rawWindow[prop];
          
          // 如果是函数，应用函数拦截器
          if (typeof value === 'function' && 
              self.options.functionInterceptors[prop] && 
              typeof self.options.functionInterceptors[prop] === 'function') {
            return self.options.functionInterceptors[prop](value, proxy);
          }
          
          // 如果是函数，绑定正确的this
          if (typeof value === 'function') {
            return value.bind(rawWindow);
          }
          
          return value;
        }
        
        // 严格模式下，未定义的属性抛出错误
        if (self.options.strictMode && self.sandboxRunning) {
          throw new ReferenceError(`${prop} is not defined`);
        }
        
        // 其他属性从原始window获取
        const value = rawWindow[prop];
        
        // 如果是函数，绑定正确的this
        if (typeof value === 'function') {
          return value.bind(rawWindow);
        }
        
        return value;
      },
      
      set(target, prop, value) {
        // 检查自定义属性拦截器
        if (self.options.propertyInterceptors[prop] && 
            typeof self.options.propertyInterceptors[prop].set === 'function') {
          return self.options.propertyInterceptors[prop].set(prop, value, proxy);
        }
        
        if (self.sandboxRunning) {
          // 沙箱运行时，设置到沙箱内部
          target[prop] = value;
          
          // 记录注入的属性
          self.injectedProps.set(prop, value);
          
          // 如果是白名单属性，也设置到原始window
          if (self.globalVariableWhiteList.includes(prop)) {
            // 记录原始值
            if (!self.modifiedOriginalProps.has(prop)) {
              self.modifiedOriginalProps.set(prop, rawWindow[prop]);
            }
            
            rawWindow[prop] = value;
          }
          
          return true;
        }
        
        // 沙箱未运行时，直接设置到原始window
        rawWindow[prop] = value;
        return true;
      },
      
      has(target, prop) {
        return target.hasOwnProperty(prop) || rawWindow.hasOwnProperty(prop);
      },
      
      deleteProperty(target, prop) {
        // 检查自定义属性拦截器
        if (self.options.propertyInterceptors[prop] && 
            typeof self.options.propertyInterceptors[prop].delete === 'function') {
          return self.options.propertyInterceptors[prop].delete(prop, proxy);
        }
        
        if (self.sandboxRunning) {
          // 沙箱运行时，只删除沙箱内部的属性
          if (target.hasOwnProperty(prop)) {
            delete target[prop];
            self.injectedProps.delete(prop);
            return true;
          }
          
          // 严格模式下，删除不存在的属性抛出错误
          if (self.options.strictMode) {
            throw new ReferenceError(`Cannot delete property '${prop}'`);
          }
          
          return false;
        }
        
        // 沙箱未运行时，直接删除原始window的属性
        delete rawWindow[prop];
        return true;
      },
      
      ownKeys(target) {
        // 合并沙箱内部和原始window的属性
        return [...new Set([
          ...Object.getOwnPropertyNames(target),
          ...Object.getOwnPropertyNames(rawWindow)
        ])];
      },
      
      getOwnPropertyDescriptor(target, prop) {
        // 优先从沙箱内部获取
        if (target.hasOwnProperty(prop)) {
          return Object.getOwnPropertyDescriptor(target, prop);
        }
        
        // 从原始window获取
        return Object.getOwnPropertyDescriptor(rawWindow, prop);
      }
    });
    
    return proxy;
  }
  
  // 激活沙箱
  active() {
    this.sandboxRunning = true;
    this.active = true;
  }
  
  // 退出沙箱
  inactive() {
    this.sandboxRunning = false;
    this.active = false;
    
    // 恢复被修改的原始属性
    this.modifiedOriginalProps.forEach((originalValue, prop) => {
      if (originalValue === undefined) {
        delete window[prop];
      } else {
        window[prop] = originalValue;
      }
    });
    
    // 清空记录
    this.modifiedOriginalProps.clear();
  }
  
  // 执行代码
  execCode(script) {
    if (!this.active) {
      throw new Error('沙箱未激活');
    }
    
    // 使用Function构造函数在沙箱环境中执行代码
    const func = new Function('window', 'document', 'location', 'navigator', 'history', 'console', script);
    
    return func(
      this.sandbox,
      this.sandbox.document,
      this.sandbox.location,
      this.sandbox.navigator,
      this.sandbox.history,
      this.sandbox.console
    );
  }
  
  // 添加全局变量
  addGlobalVariable(name, value) {
    this.sandbox[name] = value;
    this.injectedProps.set(name, value);
  }
  
  // 移除全局变量
  removeGlobalVariable(name) {
    delete this.sandbox[name];
    this.injectedProps.delete(name);
  }
  
  // 获取沙箱内部变量
  getVariable(name) {
    return this.sandbox[name];
  }
  
  // 获取所有注入的变量
  getInjectedVariables() {
    return new Map(this.injectedProps);
  }
}

// 使用示例
const sandbox = new EnhancedProxySandbox('app1', {
  strictMode: true,
  allowRawWindowAccess: false,
  customWhiteList: ['customGlobalVar'],
  propertyInterceptors: {
    // 拦截document.cookie的访问
    'document.cookie': {
      get: (prop, proxy) => {
        console.log('访问document.cookie被拦截');
        return 'sandboxed-cookie-value';
      },
      set: (prop, value, proxy) => {
        console.log('设置document.cookie被拦截:', value);
        return true;
      }
    }
  },
  functionInterceptors: {
    // 拦截setTimeout调用
    'setTimeout': (originalFn, proxy) => {
      return function(callback, delay) {
        console.log('setTimeout被拦截');
        return originalFn(callback, delay);
      };
    }
  }
});

// 激活沙箱
sandbox.active();

// 执行代码
sandbox.execCode(`
  window.globalVar = 'app1';
  console.log('全局变量:', window.globalVar);
  
  // 访问被拦截的属性
  console.log('Cookie:', document.cookie);
  
  // 调用被拦截的函数
  setTimeout(() => {
    console.log('定时器执行');
  }, 100);
`);

// 退出沙箱
sandbox.inactive();
```

## 6.4 iframe沙箱实现

### 6.4.1 iframe沙箱原理

iframe沙箱利用浏览器提供的iframe天然隔离特性，创建完全独立的JavaScript执行环境。其原理是：

1. **创建iframe**：动态创建一个iframe元素
2. **环境隔离**：利用iframe的独立文档和全局对象
3. **通信机制**：通过postMessage API实现与iframe的通信

```javascript
// iframe沙箱实现
class IframeSandbox {
  constructor(name, options = {}) {
    this.name = name;
    this.options = {
      // iframe样式
      style: {
        position: 'absolute',
        top: '-9999px',
        left: '-9999px',
        width: '1px',
        height: '1px',
        border: 'none',
        visibility: 'hidden'
      },
      // iframe属性
      attributes: {
        sandbox: 'allow-scripts allow-same-origin allow-forms allow-popups'
      },
      // 是否允许访问父窗口
      allowParentAccess: false,
      // 自定义初始化脚本
      initScript: '',
      ...options
    };
    
    this.iframe = null;
    this.iframeWindow = null;
    this.active = false;
    this.messageHandlers = new Map();
    
    // 创建iframe
    this.createIframe();
  }
  
  // 创建iframe
  createIframe() {
    // 创建iframe元素
    this.iframe = document.createElement('iframe');
    
    // 设置属性
    Object.entries(this.options.attributes).forEach(([key, value]) => {
      this.iframe.setAttribute(key, value);
    });
    
    // 设置样式
    Object.entries(this.options.style).forEach(([key, value]) => {
      this.iframe.style[key] = value;
    });
    
    // 添加到页面
    document.body.appendChild(this.iframe);
    
    // 获取iframe窗口对象
    this.iframeWindow = this.iframe.contentWindow;
    
    // 初始化iframe环境
    this.initIframe();
    
    // 设置消息监听
    this.setupMessageListener();
  }
  
  // 初始化iframe环境
  initIframe() {
    const iframeDocument = this.iframe.contentDocument;
    
    // 设置基本HTML结构
    iframeDocument.open();
    iframeDocument.write(`
      <!DOCTYPE html>
      <html>
        <head>
          <meta charset="utf-8">
          <title>${this.name} Sandbox</title>
        </head>
        <body>
          <script>
            // 初始化沙箱环境
            window.__SANDBOX_NAME__ = '${this.name}';
            window.__SANDBOX_PARENT__ = window.parent;
            
            // 重写console，添加沙箱标识
            const originalConsole = window.console;
            window.console = {
              log: function(...args) {
                originalConsole.log('[${this.name}]', ...args);
              },
              error: function(...args) {
                originalConsole.error('[${this.name}]', ...args);
              },
              warn: function(...args) {
                originalConsole.warn('[${this.name}]', ...args);
              },
              info: function(...args) {
                originalConsole.info('[${this.name}]', ...args);
              }
            };
            
            // 执行自定义初始化脚本
            ${this.options.initScript}
          </script>
        </body>
      </html>
    `);
    iframeDocument.close();
  }
  
  // 设置消息监听
  setupMessageListener() {
    window.addEventListener('message', (event) => {
      // 只处理来自当前iframe的消息
      if (event.source !== this.iframeWindow) {
        return;
      }
      
      const { type, data, id } = event.data;
      
      // 处理响应消息
      if (type === 'response' && this.messageHandlers.has(id)) {
        const { resolve, reject } = this.messageHandlers.get(id);
        this.messageHandlers.delete(id);
        
        if (data.error) {
          reject(new Error(data.error));
        } else {
          resolve(data.result);
        }
      }
    });
  }
  
  // 发送消息到iframe
  sendMessage(type, data) {
    return new Promise((resolve, reject) => {
      const id = this.generateMessageId();
      
      // 存储处理器
      this.messageHandlers.set(id, { resolve, reject });
      
      // 发送消息
      this.iframeWindow.postMessage({
        type: 'request',
        id,
        data: {
          type,
          data
        }
      }, '*');
      
      // 设置超时
      setTimeout(() => {
        if (this.messageHandlers.has(id)) {
          this.messageHandlers.delete(id);
          reject(new Error('消息超时'));
        }
      }, 5000);
    });
  }
  
  // 生成消息ID
  generateMessageId() {
    return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  // 激活沙箱
  active() {
    this.active = true;
    
    // 在iframe中设置沙箱激活状态
    this.iframeWindow.postMessage({
      type: 'activate'
    }, '*');
  }
  
  // 退出沙箱
  inactive() {
    this.active = false;
    
    // 在iframe中设置沙箱非激活状态
    this.iframeWindow.postMessage({
      type: 'deactivate'
    }, '*');
  }
  
  // 执行代码
  execCode(script) {
    return this.sendMessage('execCode', { script });
  }
  
  // 销毁沙箱
  destroy() {
    // 移除iframe
    if (this.iframe && this.iframe.parentNode) {
      this.iframe.parentNode.removeChild(this.iframe);
    }
    
    // 清空消息处理器
    this.messageHandlers.clear();
    
    this.iframe = null;
    this.iframeWindow = null;
    this.active = false;
  }
}

// iframe沙箱助手类
class IframeSandboxHelper {
  constructor() {
    this.setupMessageListener();
  }
  
  // 设置消息监听
  setupMessageListener() {
    // 只在iframe中执行
    if (window.parent === window) {
      return;
    }
    
    window.addEventListener('message', (event) => {
      // 只处理来自父窗口的消息
      if (event.source !== window.parent) {
        return;
      }
      
      const { type, id, data } = event.data;
      
      // 处理请求消息
      if (type === 'request') {
        this.handleRequest(id, data);
      } else if (type === 'activate') {
        window.__SANDBOX_ACTIVE__ = true;
      } else if (type === 'deactivate') {
        window.__SANDBOX_ACTIVE__ = false;
      }
    });
  }
  
  // 处理请求
  async handleRequest(id, data) {
    const { type, data: requestData } = data;
    let result;
    let error;
    
    try {
      switch (type) {
        case 'execCode':
          result = this.execCode(requestData.script);
          break;
        default:
          throw new Error(`未知的请求类型: ${type}`);
      }
    } catch (e) {
      error = e.message;
    }
    
    // 发送响应
    window.parent.postMessage({
      type: 'response',
      id,
      data: {
        result,
        error
      }
    }, '*');
  }
  
  // 执行代码
  execCode(script) {
    try {
      // 使用Function构造函数执行代码
      const func = new Function('window', 'document', 'location', 'navigator', 'history', 'console', script);
      
      return func(
        window,
        window.document,
        window.location,
        window.navigator,
        window.history,
        window.console
      );
    } catch (e) {
      throw e;
    }
  }
}

// 在iframe中初始化助手
new IframeSandboxHelper();

export { IframeSandbox, IframeSandboxHelper };
```

### 6.4.2 增强版iframe沙箱

增强版iframe沙箱提供更完善的隔离和通信机制：

```javascript
// 增强版iframe沙箱
class EnhancedIframeSandbox {
  constructor(name, options = {}) {
    this.name = name;
    this.options = {
      // iframe样式
      style: {
        position: 'absolute',
        top: '-9999px',
        left: '-9999px',
        width: '1px',
        height: '1px',
        border: 'none',
        visibility: 'hidden'
      },
      // iframe属性
      attributes: {
        sandbox: 'allow-scripts allow-same-origin allow-forms allow-popups'
      },
      // 是否允许访问父窗口
      allowParentAccess: false,
      // 自定义初始化脚本
      initScript: '',
      // 资源URL前缀
      assetPublicPath: '',
      // 环境变量
      env: {},
      // 全局变量注入
      globalVariables: {},
      // API代理配置
      apiProxy: {},
      ...options
    };
    
    this.iframe = null;
    this.iframeWindow = null;
    this.active = false;
    this.messageHandlers = new Map();
    this.pendingRequests = new Map();
    
    // 创建iframe
    this.createIframe();
  }
  
  // 创建iframe
  createIframe() {
    // 创建iframe元素
    this.iframe = document.createElement('iframe');
    
    // 设置属性
    Object.entries(this.options.attributes).forEach(([key, value]) => {
      this.iframe.setAttribute(key, value);
    });
    
    // 设置样式
    Object.entries(this.options.style).forEach(([key, value]) => {
      this.iframe.style[key] = value;
    });
    
    // 添加到页面
    document.body.appendChild(this.iframe);
    
    // 获取iframe窗口对象
    this.iframeWindow = this.iframe.contentWindow;
    
    // 初始化iframe环境
    this.initIframe();
    
    // 设置消息监听
    this.setupMessageListener();
  }
  
  // 初始化iframe环境
  initIframe() {
    const iframeDocument = this.iframe.contentDocument;
    
    // 准备环境变量
    const envVars = Object.entries(this.options.env)
      .map(([key, value]) => `window.${key} = ${JSON.stringify(value)};`)
      .join('\n');
    
    // 准备全局变量
    const globalVars = Object.entries(this.options.globalVariables)
      .map(([key, value]) => `window.${key} = ${JSON.stringify(value)};`)
      .join('\n');
    
    // 准备API代理
    const apiProxy = this.generateApiProxyCode();
    
    // 设置基本HTML结构
    iframeDocument.open();
    iframeDocument.write(`
      <!DOCTYPE html>
      <html>
        <head>
          <meta charset="utf-8">
          <title>${this.name} Sandbox</title>
          <script>
            // 设置资源公共路径
            if ('${this.options.assetPublicPath}') {
              window.__webpack_public_path__ = '${this.options.assetPublicPath}';
            }
          </script>
        </head>
        <body>
          <script>
            // 初始化沙箱环境
            window.__SANDBOX_NAME__ = '${this.name}';
            window.__SANDBOX_PARENT__ = window.parent;
            window.__SANDBOX_ACTIVE__ = false;
            
            // 设置环境变量
            ${envVars}
            
            // 设置全局变量
            ${globalVars}
            
            // 设置API代理
            ${apiProxy}
            
            // 重写console，添加沙箱标识
            const originalConsole = window.console;
            window.console = {
              log: function(...args) {
                originalConsole.log('[${this.name}]', ...args);
              },
              error: function(...args) {
                originalConsole.error('[${this.name}]', ...args);
              },
              warn: function(...args) {
                originalConsole.warn('[${this.name}]', ...args);
              },
              info: function(...args) {
                originalConsole.info('[${this.name}]', ...args);
              }
            };
            
            // 重写fetch，添加代理
            const originalFetch = window.fetch;
            window.fetch = function(url, options) {
              // 检查是否需要代理
              for (const pattern in window.__API_PROXY__) {
                if (url.startsWith(pattern)) {
                  const proxyUrl = window.__API_PROXY__[pattern];
                  url = url.replace(pattern, proxyUrl);
                  break;
                }
              }
              
              return originalFetch(url, options);
            };
            
            // 执行自定义初始化脚本
            ${this.options.initScript}
          </script>
        </body>
      </html>
    `);
    iframeDocument.close();
  }
  
  // 生成API代理代码
  generateApiProxyCode() {
    const apiProxyConfig = JSON.stringify(this.options.apiProxy);
    return `
      window.__API_PROXY__ = ${apiProxyConfig};
    `;
  }
  
  // 设置消息监听
  setupMessageListener() {
    window.addEventListener('message', (event) => {
      // 只处理来自当前iframe的消息
      if (event.source !== this.iframeWindow) {
        return;
      }
      
      const { type, data, id } = event.data;
      
      // 处理响应消息
      if (type === 'response' && this.messageHandlers.has(id)) {
        const { resolve, reject, timeout } = this.messageHandlers.get(id);
        this.messageHandlers.delete(id);
        
        // 清除超时
        if (timeout) {
          clearTimeout(timeout);
        }
        
        if (data.error) {
          reject(new Error(data.error));
        } else {
          resolve(data.result);
        }
      } else if (type === 'event' && this.pendingRequests.has(data.requestId)) {
        // 处理事件消息
        const { callback } = this.pendingRequests.get(data.requestId);
        if (callback) {
          callback(data.eventData);
        }
      }
    });
  }
  
  // 发送消息到iframe
  sendMessage(type, data, options = {}) {
    return new Promise((resolve, reject) => {
      const id = this.generateMessageId();
      const { timeout = 5000 } = options;
      
      // 存储处理器
      const timeoutId = setTimeout(() => {
        if (this.messageHandlers.has(id)) {
          this.messageHandlers.delete(id);
          reject(new Error('消息超时'));
        }
      }, timeout);
      
      this.messageHandlers.set(id, { resolve, reject, timeout: timeoutId });
      
      // 发送消息
      this.iframeWindow.postMessage({
        type: 'request',
        id,
        data: {
          type,
          data
        }
      }, '*');
    });
  }
  
  // 发送事件到iframe
  sendEvent(eventType, eventData) {
    this.iframeWindow.postMessage({
      type: 'event',
      data: {
        eventType,
        eventData
      }
    }, '*');
  }
  
  // 监听iframe事件
  onEvent(eventType, callback) {
    const requestId = this.generateMessageId();
    
    this.pendingRequests.set(requestId, {
      eventType,
      callback
    });
    
    // 通知iframe开始监听事件
    this.sendMessage('addEventListener', {
      eventType,
      requestId
    });
    
    // 返回取消监听的函数
    return () => {
      this.sendMessage('removeEventListener', {
        eventType,
        requestId
      });
      this.pendingRequests.delete(requestId);
    };
  }
  
  // 生成消息ID
  generateMessageId() {
    return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  // 激活沙箱
  active() {
    this.active = true;
    
    // 在iframe中设置沙箱激活状态
    this.iframeWindow.postMessage({
      type: 'activate'
    }, '*');
  }
  
  // 退出沙箱
  inactive() {
    this.active = false;
    
    // 在iframe中设置沙箱非激活状态
    this.iframeWindow.postMessage({
      type: 'deactivate'
    }, '*');
  }
  
  // 执行代码
  execCode(script) {
    return this.sendMessage('execCode', { script });
  }
  
  // 加载URL
  loadURL(url) {
    return this.sendMessage('loadURL', { url });
  }
  
  // 获取沙箱信息
  getSandboxInfo() {
    return this.sendMessage('getSandboxInfo', {});
  }
  
  // 销毁沙箱
  destroy() {
    // 清空消息处理器
    this.messageHandlers.forEach(({ timeout }) => {
      if (timeout) {
        clearTimeout(timeout);
      }
    });
    this.messageHandlers.clear();
    
    // 清空事件监听
    this.pendingRequests.clear();
    
    // 移除iframe
    if (this.iframe && this.iframe.parentNode) {
      this.iframe.parentNode.removeChild(this.iframe);
    }
    
    this.iframe = null;
    this.iframeWindow = null;
    this.active = false;
  }
}

// 增强版iframe沙箱助手类
class EnhancedIframeSandboxHelper {
  constructor() {
    this.eventListeners = new Map();
    this.setupMessageListener();
  }
  
  // 设置消息监听
  setupMessageListener() {
    // 只在iframe中执行
    if (window.parent === window) {
      return;
    }
    
    window.addEventListener('message', (event) => {
      // 只处理来自父窗口的消息
      if (event.source !== window.parent) {
        return;
      }
      
      const { type, id, data } = event.data;
      
      // 处理请求消息
      if (type === 'request') {
        this.handleRequest(id, data);
      } else if (type === 'activate') {
        window.__SANDBOX_ACTIVE__ = true;
        this.emit('sandbox-activate');
      } else if (type === 'deactivate') {
        window.__SANDBOX_ACTIVE__ = false;
        this.emit('sandbox-deactivate');
      } else if (type === 'event') {
        this.emit(data.eventType, data.eventData);
      }
    });
  }
  
  // 处理请求
  async handleRequest(id, data) {
    const { type, data: requestData } = data;
    let result;
    let error;
    
    try {
      switch (type) {
        case 'execCode':
          result = this.execCode(requestData.script);
          break;
        case 'loadURL':
          result = await this.loadURL(requestData.url);
          break;
        case 'addEventListener':
          this.addEventListener(requestData.eventType, requestId);
          result = true;
          break;
        case 'removeEventListener':
          this.removeEventListener(requestData.eventType, requestId);
          result = true;
          break;
        case 'getSandboxInfo':
          result = this.getSandboxInfo();
          break;
        default:
          throw new Error(`未知的请求类型: ${type}`);
      }
    } catch (e) {
      error = e.message;
    }
    
    // 发送响应
    window.parent.postMessage({
      type: 'response',
      id,
      data: {
        result,
        error
      }
    }, '*');
  }
  
  // 执行代码
  execCode(script) {
    try {
      // 使用Function构造函数执行代码
      const func = new Function('window', 'document', 'location', 'navigator', 'history', 'console', script);
      
      return func(
        window,
        window.document,
        window.location,
        window.navigator,
        window.history,
        window.console
      );
    } catch (e) {
      throw e;
    }
  }
  
  // 加载URL
  async loadURL(url) {
    return new Promise((resolve, reject) => {
      // 创建iframe加载URL
      const iframe = document.createElement('iframe');
      iframe.style.display = 'none';
      document.body.appendChild(iframe);
      
      iframe.onload = () => {
        // 移除iframe
        document.body.removeChild(iframe);
        resolve(true);
      };
      
      iframe.onerror = () => {
        // 移除iframe
        document.body.removeChild(iframe);
        reject(new Error('加载URL失败'));
      };
      
      iframe.src = url;
    });
  }
  
  // 添加事件监听
  addEventListener(eventType, requestId) {
    if (!this.eventListeners.has(eventType)) {
      this.eventListeners.set(eventType, new Set());
    }
    
    this.eventListeners.get(eventType).add(requestId);
  }
  
  // 移除事件监听
  removeEventListener(eventType, requestId) {
    if (this.eventListeners.has(eventType)) {
      this.eventListeners.get(eventType).delete(requestId);
      
      if (this.eventListeners.get(eventType).size === 0) {
        this.eventListeners.delete(eventType);
      }
    }
  }
  
  // 触发事件
  emit(eventType, eventData) {
    if (this.eventListeners.has(eventType)) {
      const requestIds = Array.from(this.eventListeners.get(eventType));
      
      requestIds.forEach(requestId => {
        window.parent.postMessage({
          type: 'event',
          data: {
            requestId,
            eventType,
            eventData
          }
        }, '*');
      });
    }
  }
  
  // 获取沙箱信息
  getSandboxInfo() {
    return {
      name: window.__SANDBOX_NAME__,
      active: window.__SANDBOX_ACTIVE__,
      userAgent: navigator.userAgent,
      url: window.location.href,
      timestamp: Date.now()
    };
  }
}

// 在iframe中初始化助手
new EnhancedIframeSandboxHelper();

export { EnhancedIframeSandbox, EnhancedIframeSandboxHelper };
```

## 6.5 Web Worker沙箱实现

### 6.5.1 Web Worker沙箱原理

Web Worker沙箱利用Web Worker提供的多线程环境，创建完全隔离的JavaScript执行环境。其原理是：

1. **创建Worker**：动态创建一个Web Worker
2. **环境隔离**：利用Worker的独立全局上下文
3. **通信机制**：通过postMessage API实现与Worker的通信

```javascript
// Web Worker沙箱实现
class WorkerSandbox {
  constructor(name, options = {}) {
    this.name = name;
    this.options = {
      // Worker脚本URL
      workerURL: '',
      // Worker脚本内容
      workerScript: '',
      // 是否允许访问父窗口
      allowParentAccess: false,
      // 自定义初始化脚本
      initScript: '',
      // 环境变量
      env: {},
      // 全局变量注入
      globalVariables: {},
      ...options
    };
    
    this.worker = null;
    this.active = false;
    this.messageHandlers = new Map();
    
    // 创建Worker
    this.createWorker();
  }
  
  // 创建Worker
  createWorker() {
    // 准备Worker脚本
    const workerScript = this.generateWorkerScript();
    
    // 创建Blob URL
    const blob = new Blob([workerScript], { type: 'application/javascript' });
    const workerURL = URL.createObjectURL(blob);
    
    // 创建Worker
    this.worker = new Worker(workerURL);
    
    // 设置消息监听
    this.setupMessageListener();
    
    // 释放Blob URL
    URL.revokeObjectURL(workerURL);
  }
  
  // 生成Worker脚本
  generateWorkerScript() {
    // 准备环境变量
    const envVars = Object.entries(this.options.env)
      .map(([key, value]) => `self.${key} = ${JSON.stringify(value)};`)
      .join('\n');
    
    // 准备全局变量
    const globalVars = Object.entries(this.options.globalVariables)
      .map(([key, value]) => `self.${key} = ${JSON.stringify(value)};`)
      .join('\n');
    
    return `
      // 初始化沙箱环境
      self.__SANDBOX_NAME__ = '${this.name}';
      self.__SANDBOX_ACTIVE__ = false;
      
      // 设置环境变量
      ${envVars}
      
      // 设置全局变量
      ${globalVars}
      
      // 模拟浏览器API
      self.console = {
        log: function(...args) {
          self.postMessage({
            type: 'console',
            data: {
              level: 'log',
              args
            }
          });
        },
        error: function(...args) {
          self.postMessage({
            type: 'console',
            data: {
              level: 'error',
              args
            }
          });
        },
        warn: function(...args) {
          self.postMessage({
            type: 'console',
            data: {
              level: 'warn',
              args
            }
          });
        },
        info: function(...args) {
          self.postMessage({
            type: 'console',
            data: {
              level: 'info',
              args
            }
          });
        }
      };
      
      // 模拟定时器
      self.__timers__ = [];
      
      self.setTimeout = function(callback, delay) {
        const id = self.__timers__.length;
        self.__timers__.push({
          id,
          callback,
          delay,
          type: 'timeout'
        });
        
        self.postMessage({
          type: 'setTimeout',
          data: { id, delay }
        });
        
        return id;
      };
      
      self.clearTimeout = function(id) {
        const index = self.__timers__.findIndex(timer => timer.id === id);
        if (index !== -1) {
          self.__timers__.splice(index, 1);
          
          self.postMessage({
            type: 'clearTimeout',
            data: { id }
          });
        }
      };
      
      self.setInterval = function(callback, delay) {
        const id = self.__timers__.length;
        self.__timers__.push({
          id,
          callback,
          delay,
          type: 'interval'
        });
        
        self.postMessage({
          type: 'setInterval',
          data: { id, delay }
        });
        
        return id;
      };
      
      self.clearInterval = function(id) {
        const index = self.__timers__.findIndex(timer => timer.id === id);
        if (index !== -1) {
          self.__timers__.splice(index, 1);
          
          self.postMessage({
            type: 'clearInterval',
            data: { id }
          });
        }
      };
      
      // 处理定时器回调
      self.onmessage = function(event) {
        const { type, data } = event.data;
        
        if (type === 'timer') {
          const { id } = data;
          const timer = self.__timers__.find(t => t.id === id);
          
          if (timer) {
            timer.callback();
            
            // 如果是间隔定时器，继续执行
            if (timer.type === 'interval') {
              self.postMessage({
                type: 'setInterval',
                data: { id, delay: timer.delay }
              });
            } else {
              // 一次性定时器，移除
              const index = self.__timers__.findIndex(t => t.id === id);
              if (index !== -1) {
                self.__timers__.splice(index, 1);
              }
            }
          }
        } else if (type === 'activate') {
          self.__SANDBOX_ACTIVE__ = true;
        } else if (type === 'deactivate') {
          self.__SANDBOX_ACTIVE__ = false;
        } else if (type === 'execCode') {
          try {
            // 使用Function构造函数执行代码
            const func = new Function('self', 'console', 'setTimeout', 'clearTimeout', 'setInterval', 'clearInterval', data.script);
            const result = func(self, self.console, self.setTimeout, self.clearTimeout, self.setInterval, self.clearInterval);
            
            self.postMessage({
              type: 'response',
              data: {
                id: data.id,
                result
              }
            });
          } catch (error) {
            self.postMessage({
              type: 'response',
              data: {
                id: data.id,
                error: error.message
              }
            });
          }
        }
      };
      
      // 执行自定义初始化脚本
      ${this.options.initScript}
    `;
  }
  
  // 设置消息监听
  setupMessageListener() {
    this.worker.addEventListener('message', (event) => {
      const { type, data } = event.data;
      
      switch (type) {
        case 'console':
          this.handleConsoleMessage(data);
          break;
        case 'setTimeout':
          this.handleSetTimeout(data);
          break;
        case 'clearTimeout':
          this.handleClearTimeout(data);
          break;
        case 'setInterval':
          this.handleSetInterval(data);
          break;
        case 'clearInterval':
          this.handleClearInterval(data);
          break;
        case 'response':
          this.handleResponse(data);
          break;
      }
    });
  }
  
  // 处理控制台消息
  handleConsoleMessage(data) {
    const { level, args } = data;
    console[level](`[${this.name}]`, ...args);
  }
  
  // 处理setTimeout
  handleSetTimeout(data) {
    const { id, delay } = data;
    
    setTimeout(() => {
      this.worker.postMessage({
        type: 'timer',
        data: { id }
      });
    }, delay);
  }
  
  // 处理clearTimeout
  handleClearTimeout(data) {
    // 在Worker沙箱中，定时器由主线程管理，这里不需要特殊处理
  }
  
  // 处理setInterval
  handleSetInterval(data) {
    const { id, delay } = data;
    
    const intervalId = setInterval(() => {
      this.worker.postMessage({
        type: 'timer',
        data: { id }
      });
    }, delay);
    
    // 保存intervalId，以便后续清除
    if (!this.intervals) {
      this.intervals = new Map();
    }
    this.intervals.set(id, intervalId);
  }
  
  // 处理clearInterval
  handleClearInterval(data) {
    const { id } = data;
    
    if (this.intervals && this.intervals.has(id)) {
      clearInterval(this.intervals.get(id));
      this.intervals.delete(id);
    }
  }
  
  // 处理响应
  handleResponse(data) {
    const { id, result, error } = data;
    
    if (this.messageHandlers.has(id)) {
      const { resolve, reject } = this.messageHandlers.get(id);
      this.messageHandlers.delete(id);
      
      if (error) {
        reject(new Error(error));
      } else {
        resolve(result);
      }
    }
  }
  
  // 生成消息ID
  generateMessageId() {
    return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  // 激活沙箱
  active() {
    this.active = true;
    
    // 在Worker中设置沙箱激活状态
    this.worker.postMessage({
      type: 'activate'
    });
  }
  
  // 退出沙箱
  inactive() {
    this.active = false;
    
    // 在Worker中设置沙箱非激活状态
    this.worker.postMessage({
      type: 'deactivate'
    });
  }
  
  // 执行代码
  execCode(script) {
    return new Promise((resolve, reject) => {
      const id = this.generateMessageId();
      
      // 存储处理器
      this.messageHandlers.set(id, { resolve, reject });
      
      // 发送消息
      this.worker.postMessage({
        type: 'execCode',
        data: {
          id,
          script
        }
      });
      
      // 设置超时
      setTimeout(() => {
        if (this.messageHandlers.has(id)) {
          this.messageHandlers.delete(id);
          reject(new Error('消息超时'));
        }
      }, 5000);
    });
  }
  
  // 销毁沙箱
  destroy() {
    // 清除所有定时器
    if (this.intervals) {
      this.intervals.forEach(intervalId => {
        clearInterval(intervalId);
      });
      this.intervals.clear();
    }
    
    // 终止Worker
    if (this.worker) {
      this.worker.terminate();
    }
    
    // 清空消息处理器
    this.messageHandlers.clear();
    
    this.worker = null;
    this.active = false;
  }
}

export { WorkerSandbox };
```

## 6.6 沙箱选择与最佳实践

### 6.6.1 沙箱方案对比

| 沙箱方案 | 隔离程度 | 性能影响 | 兼容性 | 实现复杂度 | 适用场景 |
|----------|----------|----------|--------|------------|----------|
| 快照沙箱 | 低 | 低 | 好 | 低 | 简单应用，兼容性要求高 |
| 代理沙箱 | 中 | 中 | 中 | 中 | 大多数场景，平衡性能与隔离 |
| iframe沙箱 | 高 | 高 | 好 | 中 | 强隔离需求，第三方应用 |
| Web Worker沙箱 | 高 | 中 | 差 | 高 | 计算密集型任务，无DOM操作 |

### 6.6.2 沙箱选择指南

根据不同的场景和需求，选择合适的沙箱方案：

1. **兼容性优先**：选择快照沙箱，兼容性最好，但隔离效果有限
2. **性能优先**：选择快照沙箱或代理沙箱，性能影响较小
3. **隔离优先**：选择iframe沙箱或Web Worker沙箱，隔离效果最好
4. **平衡方案**：选择代理沙箱，在性能和隔离之间取得平衡
5. **特殊需求**：根据具体需求选择或组合使用多种沙箱方案

### 6.6.3 沙箱最佳实践

1. **分层隔离**：根据应用的重要性和风险级别，采用不同强度的隔离方案
2. **资源限制**：限制沙箱可使用的资源，防止资源滥用
3. **安全策略**：实施CSP、XSS防护等安全策略
4. **监控告警**：监控沙箱运行状态，及时发现异常
5. **优雅降级**：在不支持某些特性的环境中，提供降级方案

```javascript
// 沙箱最佳实践实现
class SandboxBestPractices {
  constructor() {
    this.sandboxes = new Map();
    this.resourceLimits = new Map();
    this.securityPolicies = new Map();
    this.monitors = new Map();
  }
  
  // 创建沙箱
  createSandbox(name, config) {
    // 根据配置选择沙箱类型
    const sandboxType = this.selectSandboxType(config);
    
    // 创建沙箱
    let sandbox;
    switch (sandboxType) {
      case 'snapshot':
        sandbox = new SnapshotSandbox(name);
        break;
      case 'proxy':
        sandbox = new ProxySandbox(name, config.options);
        break;
      case 'iframe':
        sandbox = new IframeSandbox(name, config.options);
        break;
      case 'worker':
        sandbox = new WorkerSandbox(name, config.options);
        break;
      default:
        throw new Error(`不支持的沙箱类型: ${sandboxType}`);
    }
    
    // 设置资源限制
    this.setResourceLimits(name, config.resourceLimits);
    
    // 设置安全策略
    this.setSecurityPolicies(name, config.securityPolicies);
    
    // 设置监控
    this.setMonitor(name, config.monitor);
    
    // 保存沙箱
    this.sandboxes.set(name, sandbox);
    
    return sandbox;
  }
  
  // 选择沙箱类型
  selectSandboxType(config) {
    const {
      isolationLevel = 'medium',
      performanceRequirement = 'medium',
      compatibilityRequirement = 'medium',
      hasDOMAccess = true,
      isThirdParty = false
    } = config;
    
    // 第三方应用，高隔离需求
    if (isThirdParty || isolationLevel === 'high') {
      return hasDOMAccess ? 'iframe' : 'worker';
    }
    
    // 高性能需求，低隔离需求
    if (performanceRequirement === 'high' && isolationLevel === 'low') {
      return 'snapshot';
    }
    
    // 高兼容性需求
    if (compatibilityRequirement === 'high') {
      return 'snapshot';
    }
    
    // 默认使用代理沙箱
    return 'proxy';
  }
  
  // 设置资源限制
  setResourceLimits(name, limits) {
    if (!limits) {
      return;
    }
    
    this.resourceLimits.set(name, {
      maxMemory: limits.maxMemory || 50 * 1024 * 1024, // 50MB
      maxCpuTime: limits.maxCpuTime || 5000, // 5秒
      maxNetworkRequests: limits.maxNetworkRequests || 10,
      ...limits
    });
  }
  
  // 设置安全策略
  setSecurityPolicies(name, policies) {
    if (!policies) {
      return;
    }
    
    this.securityPolicies.set(name, {
      allowEval: policies.allowEval || false,
      allowInlineScript: policies.allowInlineScript || false,
      allowedDomains: policies.allowedDomains || [],
      customPolicies: policies.customPolicies || {},
      ...policies
    });
  }
  
  // 设置监控
  setMonitor(name, config) {
    if (!config) {
      return;
    }
    
    this.monitors.set(name, {
      enablePerformanceMonitoring: config.enablePerformanceMonitoring || false,
      enableErrorMonitoring: config.enableErrorMonitoring || false,
      enableResourceMonitoring: config.enableResourceMonitoring || false,
      alertThresholds: config.alertThresholds || {},
      ...config
    });
  }
  
  // 激活沙箱
  activeSandbox(name) {
    const sandbox = this.sandboxes.get(name);
    if (!sandbox) {
      throw new Error(`沙箱 ${name} 不存在`);
    }
    
    // 激活沙箱
    sandbox.active();
    
    // 开始监控
    this.startMonitoring(name);
  }
  
  // 退出沙箱
  inactiveSandbox(name) {
    const sandbox = this.sandboxes.get(name);
    if (!sandbox) {
      throw new Error(`沙箱 ${name} 不存在`);
    }
    
    // 停止监控
    this.stopMonitoring(name);
    
    // 退出沙箱
    sandbox.inactive();
  }
  
  // 销毁沙箱
  destroySandbox(name) {
    const sandbox = this.sandboxes.get(name);
    if (!sandbox) {
      throw new Error(`沙箱 ${name} 不存在`);
    }
    
    // 停止监控
    this.stopMonitoring(name);
    
    // 销毁沙箱
    sandbox.destroy();
    
    // 清理资源
    this.resourceLimits.delete(name);
    this.securityPolicies.delete(name);
    this.monitors.delete(name);
    
    // 从列表中移除
    this.sandboxes.delete(name);
  }
  
  // 开始监控
  startMonitoring(name) {
    const monitor = this.monitors.get(name);
    if (!monitor) {
      return;
    }
    
    // 实现监控逻辑
    if (monitor.enablePerformanceMonitoring) {
      this.startPerformanceMonitoring(name);
    }
    
    if (monitor.enableErrorMonitoring) {
      this.startErrorMonitoring(name);
    }
    
    if (monitor.enableResourceMonitoring) {
      this.startResourceMonitoring(name);
    }
  }
  
  // 停止监控
  stopMonitoring(name) {
    // 实现停止监控逻辑
  }
  
  // 开始性能监控
  startPerformanceMonitoring(name) {
    // 实现性能监控逻辑
  }
  
  // 开始错误监控
  startErrorMonitoring(name) {
    // 实现错误监控逻辑
  }
  
  // 开始资源监控
  startResourceMonitoring(name) {
    // 实现资源监控逻辑
  }
  
  // 获取沙箱
  getSandbox(name) {
    return this.sandboxes.get(name);
  }
  
  // 获取所有沙箱
  getAllSandboxes() {
    return Array.from(this.sandboxes.keys());
  }
  
  // 清空所有沙箱
  clear() {
    this.sandboxes.forEach((sandbox, name) => {
      this.destroySandbox(name);
    });
    
    this.sandboxes.clear();
    this.resourceLimits.clear();
    this.securityPolicies.clear();
    this.monitors.clear();
  }
}

// 创建全局沙箱最佳实践实例
const sandboxBestPractices = new SandboxBestPractices();

export default sandboxBestPractices;
```

## 总结

本章详细介绍了微前端架构中的JavaScript沙箱实现方案，包括：

1. **JS沙箱概述**：分析了微前端沙箱的必要性和原理分类
2. **快照沙箱实现**：通过保存和恢复环境快照实现基础隔离
3. **代理沙箱实现**：使用ES6 Proxy API实现更灵活的隔离方案
4. **iframe沙箱实现**：利用iframe的天然隔离特性实现强隔离
5. **Web Worker沙箱实现**：使用Web Worker创建完全隔离的执行环境
6. **沙箱选择与最佳实践**：提供了沙箱方案对比、选择指南和最佳实践

通过这些沙箱方案，微前端应用可以实现JavaScript代码的隔离执行，防止全局变量污染、原型链污染等问题，提高系统的安全性和稳定性。在实际项目中，应根据具体需求选择合适的沙箱方案，并结合使用多种技术以达到最佳效果。