# 第八章：微前端性能优化

## 8.1 微前端性能概述

### 8.1.1 性能挑战

微前端架构虽然带来了许多好处，但也引入了一些独特的性能挑战：

1. **资源加载开销**：多个微应用意味着更多的资源需要加载
2. **重复依赖**：不同应用可能加载相同版本的依赖库
3. **运行时开销**：沙箱隔离、路由管理等机制带来额外开销
4. **应用切换延迟**：微应用之间的切换可能产生延迟
5. **内存占用**：同时加载多个微应用会增加内存使用
6. **网络请求增多**：微应用架构可能导致更多的网络请求

### 8.1.2 性能指标

衡量微前端性能的关键指标：

1. **首次内容绘制(FCP)**：首次绘制任何文本、图像、非空白canvas的时间
2. **最大内容绘制(LCP)**：页面中最大的内容元素绘制完成的时间
3. **首次输入延迟(FID)**：用户首次与页面交互到浏览器响应的时间
4. **累积布局偏移(CLS)**：页面整个生命周期中发生的意外布局偏移
5. **首次可交互时间(TTI)**：页面达到完全可交互状态的时间
6. **应用切换时间**：从一个微应用切换到另一个微应用所需的时间

## 8.2 资源加载优化

### 8.2.1 依赖共享

依赖共享是微前端性能优化的关键策略，可以避免重复加载相同的依赖：

```javascript
// 微前端依赖共享管理器
class MicroFrontendDependencyManager {
  constructor() {
    this.sharedDependencies = new Map();
    this.loadedScripts = new Set();
    this.loadedStyles = new Set();
    this.loadingPromises = new Map();
  }
  
  // 注册共享依赖
  registerSharedDependency(name, config) {
    this.sharedDependencies.set(name, {
      name,
      version: config.version,
      url: config.url,
      type: config.type || 'script',
      global: config.global,
      exports: config.exports || [],
      ...config
    });
  }
  
  // 加载共享依赖
  async loadSharedDependency(name) {
    // 如果已经在加载中，返回现有的Promise
    if (this.loadingPromises.has(name)) {
      return this.loadingPromises.get(name);
    }
    
    // 如果已经加载，直接返回
    if (this.isDependencyLoaded(name)) {
      return this.getDependencyExports(name);
    }
    
    // 创建加载Promise
    const loadingPromise = this._loadDependency(name);
    this.loadingPromises.set(name, loadingPromise);
    
    try {
      const exports = await loadingPromise;
      return exports;
    } finally {
      // 清理加载Promise
      this.loadingPromises.delete(name);
    }
  }
  
  // 实际加载依赖
  async _loadDependency(name) {
    const dependency = this.sharedDependencies.get(name);
    if (!dependency) {
      throw new Error(`Dependency ${name} not found`);
    }
    
    if (dependency.type === 'script') {
      return this._loadScript(dependency);
    } else if (dependency.type === 'style') {
      return this._loadStyle(dependency);
    } else {
      throw new Error(`Unsupported dependency type: ${dependency.type}`);
    }
  }
  
  // 加载脚本
  async _loadScript(dependency) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = dependency.url;
      script.async = true;
      
      script.onload = () => {
        this.loadedScripts.add(dependency.url);
        
        // 获取导出的模块
        const exports = this.getGlobalExports(dependency);
        resolve(exports);
      };
      
      script.onerror = () => {
        reject(new Error(`Failed to load script: ${dependency.url}`));
      };
      
      document.head.appendChild(script);
    });
  }
  
  // 加载样式
  async _loadStyle(dependency) {
    return new Promise((resolve, reject) => {
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = dependency.url;
      
      link.onload = () => {
        this.loadedStyles.add(dependency.url);
        resolve({});
      };
      
      link.onerror = () => {
        reject(new Error(`Failed to load style: ${dependency.url}`));
      };
      
      document.head.appendChild(link);
    });
  }
  
  // 获取全局导出
  getGlobalExports(dependency) {
    const exports = {};
    
    if (dependency.global) {
      const globalObj = window[dependency.global];
      if (globalObj) {
        if (dependency.exports && dependency.exports.length > 0) {
          dependency.exports.forEach(exportName => {
            exports[exportName] = globalObj[exportName];
          });
        } else {
          // 如果没有指定导出，返回整个全局对象
          return globalObj;
        }
      }
    }
    
    return exports;
  }
  
  // 检查依赖是否已加载
  isDependencyLoaded(name) {
    const dependency = this.sharedDependencies.get(name);
    if (!dependency) {
      return false;
    }
    
    if (dependency.type === 'script') {
      return this.loadedScripts.has(dependency.url);
    } else if (dependency.type === 'style') {
      return this.loadedStyles.has(dependency.url);
    }
    
    return false;
  }
  
  // 获取依赖导出
  getDependencyExports(name) {
    const dependency = this.sharedDependencies.get(name);
    if (!dependency || !this.isDependencyLoaded(name)) {
      return null;
    }
    
    return this.getGlobalExports(dependency);
  }
  
  // 预加载依赖
  async preloadDependencies(names) {
    const preloadPromises = names.map(name => {
      return this.loadSharedDependency(name).catch(error => {
        console.warn(`Failed to preload dependency ${name}:`, error);
        return null;
      });
    });
    
    return Promise.allSettled(preloadPromises);
  }
  
  // 卸载依赖
  unloadDependency(name) {
    const dependency = this.sharedDependencies.get(name);
    if (!dependency) {
      return;
    }
    
    if (dependency.type === 'script') {
      // 移除脚本标签
      const scripts = document.querySelectorAll(`script[src="${dependency.url}"]`);
      scripts.forEach(script => script.remove());
      
      // 从已加载集合中移除
      this.loadedScripts.delete(dependency.url);
      
      // 清理全局变量
      if (dependency.global) {
        delete window[dependency.global];
      }
    } else if (dependency.type === 'style') {
      // 移除样式标签
      const links = document.querySelectorAll(`link[href="${dependency.url}"]`);
      links.forEach(link => link.remove());
      
      // 从已加载集合中移除
      this.loadedStyles.delete(dependency.url);
    }
  }
  
  // 获取依赖信息
  getDependencyInfo() {
    const dependencies = [];
    
    this.sharedDependencies.forEach((dep, name) => {
      dependencies.push({
        name,
        version: dep.version,
        url: dep.url,
        type: dep.type,
        loaded: this.isDependencyLoaded(name),
        loading: this.loadingPromises.has(name)
      });
    });
    
    return dependencies;
  }
}

// 使用示例
const dependencyManager = new MicroFrontendDependencyManager();

// 注册共享依赖
dependencyManager.registerSharedDependency('react', {
  version: '17.0.2',
  url: 'https://cdn.jsdelivr.net/npm/react@17.0.2/umd/react.production.min.js',
  type: 'script',
  global: 'React',
  exports: ['useState', 'useEffect', 'Component']
});

dependencyManager.registerSharedDependency('react-dom', {
  version: '17.0.2',
  url: 'https://cdn.jsdelivr.net/npm/react-dom@17.0.2/umd/react-dom.production.min.js',
  type: 'script',
  global: 'ReactDOM',
  exports: ['render', 'hydrate']
});

dependencyManager.registerSharedDependency('antd', {
  version: '4.16.13',
  url: 'https://cdn.jsdelivr.net/npm/antd@4.16.13/dist/antd.min.css',
  type: 'style'
});

// 预加载依赖
dependencyManager.preloadDependencies(['react', 'react-dom', 'antd']);

// 在微应用中使用
async function loadMicroApp(appName) {
  // 加载共享依赖
  await dependencyManager.loadSharedDependency('react');
  await dependencyManager.loadSharedDependency('react-dom');
  await dependencyManager.loadSharedDependency('antd');
  
  // 加载微应用
  const { React, ReactDOM } = dependencyManager.getDependencyExports('react');
  const { render } = dependencyManager.getDependencyExports('react-dom');
  
  // 加载并渲染微应用
  const appModule = await import(`./apps/${appName}/index.js`);
  const App = appModule.default;
  
  const container = document.getElementById(`app-${appName}`);
  render(React.createElement(App), container);
}
```

### 8.2.2 懒加载与预加载

懒加载和预加载是优化微前端资源加载的重要策略：

```javascript
// 微前端懒加载管理器
class MicroFrontendLazyLoader {
  constructor() {
    this.loadedApps = new Map();
    this.loadingApps = new Map();
    this.preloadedApps = new Map();
    this.intersectionObserver = null;
    this.appConfigs = new Map();
  }
  
  // 注册应用配置
  registerApp(name, config) {
    this.appConfigs.set(name, {
      name,
      entry: config.entry,
      preload: config.preload || false,
      preloadDelay: config.preloadDelay || 3000,
      lazy: config.lazy !== false, // 默认启用懒加载
      container: config.container || `app-${name}`,
      ...config
    });
  }
  
  // 加载应用
  async loadApp(name) {
    // 如果已经加载，直接返回
    if (this.loadedApps.has(name)) {
      return this.loadedApps.get(name);
    }
    
    // 如果正在加载，返回现有的Promise
    if (this.loadingApps.has(name)) {
      return this.loadingApps.get(name);
    }
    
    const config = this.appConfigs.get(name);
    if (!config) {
      throw new Error(`App ${name} not found`);
    }
    
    // 创建加载Promise
    const loadingPromise = this._loadApp(config);
    this.loadingApps.set(name, loadingPromise);
    
    try {
      const app = await loadingPromise;
      this.loadedApps.set(name, app);
      return app;
    } finally {
      // 清理加载Promise
      this.loadingApps.delete(name);
    }
  }
  
  // 实际加载应用
  async _loadApp(config) {
    console.log(`Loading app: ${config.name}`);
    const startTime = performance.now();
    
    try {
      // 加载应用资源
      const appModule = await this._loadAppModule(config.entry);
      
      // 创建应用实例
      const app = await this._createAppInstance(appModule, config);
      
      const loadTime = performance.now() - startTime;
      console.log(`App ${config.name} loaded in ${loadTime.toFixed(2)}ms`);
      
      // 触发加载完成事件
      window.dispatchEvent(new CustomEvent('micro-app-loaded', {
        detail: {
          name: config.name,
          loadTime,
          app
        }
      }));
      
      return app;
    } catch (error) {
      console.error(`Failed to load app ${config.name}:`, error);
      
      // 触发加载错误事件
      window.dispatchEvent(new CustomEvent('micro-app-error', {
        detail: {
          name: config.name,
          error
        }
      }));
      
      throw error;
    }
  }
  
  // 加载应用模块
  async _loadAppModule(entry) {
    if (typeof entry === 'string') {
      // 如果是URL，使用动态导入
      if (entry.startsWith('http')) {
        return await import(/* webpackIgnore: true */ entry);
      } else {
        // 如果是模块路径，使用相对导入
        return await import(entry);
      }
    } else if (typeof entry === 'function') {
      // 如果是函数，执行函数获取模块
      return await entry();
    }
    
    throw new Error(`Invalid entry type: ${typeof entry}`);
  }
  
  // 创建应用实例
  async _createAppInstance(appModule, config) {
    let app;
    
    if (typeof appModule === 'function') {
      // 如果导出的是函数，直接调用
      app = await appModule(config.container);
    } else if (appModule && appModule.default) {
      // 如果有默认导出，使用默认导出
      if (typeof appModule.default === 'function') {
        app = await appModule.default(config.container);
      } else {
        app = appModule.default;
      }
    } else {
      // 否则使用整个模块
      app = appModule;
    }
    
    // 如果应用有挂载方法，执行挂载
    if (app && typeof app.mount === 'function') {
      await app.mount(config.container);
    }
    
    return app;
  }
  
  // 卸载应用
  async unloadApp(name) {
    if (!this.loadedApps.has(name)) {
      return;
    }
    
    const app = this.loadedApps.get(name);
    
    try {
      // 如果应用有卸载方法，执行卸载
      if (app && typeof app.unmount === 'function') {
        await app.unmount();
      }
      
      // 从已加载列表中移除
      this.loadedApps.delete(name);
      
      // 触发卸载事件
      window.dispatchEvent(new CustomEvent('micro-app-unmounted', {
        detail: {
          name,
          app
        }
      }));
      
      console.log(`App ${name} unloaded`);
    } catch (error) {
      console.error(`Failed to unload app ${name}:`, error);
    }
  }
  
  // 预加载应用
  async preloadApp(name) {
    if (this.preloadedApps.has(name) || this.loadedApps.has(name)) {
      return;
    }
    
    const config = this.appConfigs.get(name);
    if (!config) {
      throw new Error(`App ${name} not found`);
    }
    
    // 创建预加载Promise
    const preloadPromise = this._preloadApp(config);
    this.preloadedApps.set(name, preloadPromise);
    
    try {
      const app = await preloadPromise;
      console.log(`App ${name} preloaded`);
      return app;
    } catch (error) {
      console.error(`Failed to preload app ${name}:`, error);
      this.preloadedApps.delete(name);
      throw error;
    }
  }
  
  // 实际预加载应用
  async _preloadApp(config) {
    // 加载应用资源但不挂载
    const appModule = await this._loadAppModule(config.entry);
    
    // 创建应用实例但不挂载
    const app = await this._createAppInstance(appModule, { ...config, skipMount: true });
    
    return app;
  }
  
  // 初始化懒加载
  initLazyLoading() {
    // 创建交叉观察器
    this.intersectionObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const appName = entry.target.dataset.app;
          if (appName) {
            this.loadApp(appName);
            // 停止观察已加载的元素
            this.intersectionObserver.unobserve(entry.target);
          }
        }
      });
    }, {
      rootMargin: '100px' // 提前100px开始加载
    });
    
    // 观察所有懒加载容器
    this.observeLazyContainers();
  }
  
  // 观察懒加载容器
  observeLazyContainers() {
    document.querySelectorAll('[data-lazy-app]').forEach(container => {
      const appName = container.dataset.lazyApp;
      const config = this.appConfigs.get(appName);
      
      if (config && config.lazy) {
        container.dataset.app = appName;
        this.intersectionObserver.observe(container);
      }
    });
  }
  
  // 初始化预加载
  initPreloading() {
    // 找出所有需要预加载的应用
    const preloadApps = [];
    
    this.appConfigs.forEach((config, name) => {
      if (config.preload) {
        preloadApps.push(name);
      }
    });
    
    // 延迟预加载，避免影响首屏加载
    setTimeout(() => {
      preloadApps.forEach(appName => {
        this.preloadApp(appName).catch(error => {
          console.warn(`Failed to preload app ${appName}:`, error);
        });
      });
    }, 3000);
  }
  
  // 获取应用状态
  getAppStatus(name) {
    if (this.loadedApps.has(name)) {
      return 'loaded';
    }
    
    if (this.loadingApps.has(name)) {
      return 'loading';
    }
    
    if (this.preloadedApps.has(name)) {
      return 'preloaded';
    }
    
    const config = this.appConfigs.get(name);
    if (config) {
      return 'registered';
    }
    
    return 'unknown';
  }
  
  // 获取所有应用状态
  getAllAppStatus() {
    const status = {};
    
    this.appConfigs.forEach((config, name) => {
      status[name] = this.getAppStatus(name);
    });
    
    return status;
  }
  
  // 清理资源
  destroy() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
    }
    
    // 卸载所有应用
    const appNames = Array.from(this.loadedApps.keys());
    const unloadPromises = appNames.map(name => this.unloadApp(name));
    
    return Promise.allSettled(unloadPromises);
  }
}

// 使用示例
const lazyLoader = new MicroFrontendLazyLoader();

// 注册应用
lazyLoader.registerApp('dashboard', {
  entry: () => import('./apps/dashboard'),
  container: '#dashboard-container',
  lazy: true,
  preload: true,
  preloadDelay: 3000
});

lazyLoader.registerApp('settings', {
  entry: () => import('./apps/settings'),
  container: '#settings-container',
  lazy: true,
  preload: false
});

lazyLoader.registerApp('profile', {
  entry: () => import('./apps/profile'),
  container: '#profile-container',
  lazy: false, // 立即加载
  preload: false
});

// 初始化懒加载和预加载
document.addEventListener('DOMContentLoaded', () => {
  lazyLoader.initLazyLoading();
  lazyLoader.initPreloading();
});

// 手动加载应用
async function showDashboard() {
  await lazyLoader.loadApp('dashboard');
}

// 手动卸载应用
async function hideDashboard() {
  await lazyLoader.unloadApp('dashboard');
}
```

## 8.3 运行时性能优化

### 8.3.1 沙箱性能优化

沙箱是微前端架构的核心组件，但也可能带来性能开销。以下是优化沙箱性能的策略：

```javascript
// 高性能微前端沙箱实现
class HighPerformanceSandbox {
  constructor(name, options = {}) {
    this.name = name;
    this.options = {
      strict: false, // 是否启用严格模式
      secure: true,  // 是否启用安全模式
      performance: true, // 是否启用性能优化
      ...options
    };
    
    this.sandbox = null;
    this.proxy = null;
    this.globalProps = new Map();
    this.modifiedProps = new Set();
    this.timers = new Set();
    this.listeners = new Map();
    this.performanceMetrics = {
      propAccessCount: 0,
      propSetCount: 0,
      functionCallCount: 0,
      executionTime: 0
    };
  }
  
  // 创建沙箱
  createSandbox() {
    if (this.sandbox) {
      return this.sandbox;
    }
    
    const startTime = performance.now();
    
    // 创建沙箱上下文
    this.sandbox = this._createSandboxContext();
    
    // 创建代理
    this.proxy = this._createProxy(this.sandbox);
    
    const endTime = performance.now();
    this.performanceMetrics.creationTime = endTime - startTime;
    
    return this.proxy;
  }
  
  // 创建沙箱上下文
  _createSandboxContext() {
    const sandbox = {};
    
    // 复制全局对象的安全属性
    this._copySafeGlobalProps(sandbox);
    
    // 添加沙箱特定的全局对象
    this._addSandboxGlobals(sandbox);
    
    return sandbox;
  }
  
  // 复制安全的全局属性
  _copySafeGlobalProps(target) {
    // 安全的全局对象列表
    const safeGlobals = [
      // 基本对象和函数
      'Object', 'Function', 'Array', 'String', 'Number', 'Boolean', 'Date', 'RegExp', 'Error', 'JSON',
      'Math', 'parseInt', 'parseFloat', 'isNaN', 'isFinite', 'decodeURI', 'decodeURIComponent',
      'encodeURI', 'encodeURIComponent', 'escape', 'unescape',
      
      // ES6+ 新增对象
      'Map', 'Set', 'WeakMap', 'WeakSet', 'Proxy', 'Reflect', 'Promise', 'Symbol',
      'ArrayBuffer', 'DataView', 'Int8Array', 'Uint8Array', 'Uint8ClampedArray',
      'Int16Array', 'Uint16Array', 'Int32Array', 'Uint32Array', 'Float32Array', 'Float64Array',
      
      // 控制台API
      'console',
      
      // 定时器函数
      'setTimeout', 'setInterval', 'clearTimeout', 'clearInterval',
      
      // 其他安全API
      'addEventListener', 'removeEventListener', 'dispatchEvent'
    ];
    
    safeGlobals.forEach(prop => {
      if (window[prop] !== undefined) {
        if (typeof window[prop] === 'function') {
          // 对于函数，创建包装函数
          target[prop] = this._wrapFunction(window[prop], prop);
        } else {
          // 对于对象，创建浅拷贝
          target[prop] = this._shallowCopy(window[prop]);
        }
        
        // 记录全局属性
        this.globalProps.set(prop, window[prop]);
      }
    });
  }
  
  // 添加沙箱特定的全局对象
  _addSandboxGlobals(target) {
    // 添加沙箱信息
    target.__SANDBOX_NAME__ = this.name;
    target.__SANDBOX_OPTIONS__ = this.options;
    
    // 添加沙箱API
    target.__SANDBEX_API__ = {
      getName: () => this.name,
      getOptions: () => this.options,
      getPerformanceMetrics: () => this.performanceMetrics,
      reset: () => this.reset(),
      destroy: () => this.destroy()
    };
  }
  
  // 包装函数
  _wrapFunction(fn, name) {
    const self = this;
    
    return function(...args) {
      const startTime = performance.now();
      self.performanceMetrics.functionCallCount++;
      
      try {
        // 对于特殊函数，进行特殊处理
        if (name === 'setTimeout' || name === 'setInterval') {
          return self._wrapTimer(fn.apply(this, args), args);
        } else if (name === 'addEventListener') {
          return self._wrapEventListener(fn.apply(this, args), args);
        }
        
        return fn.apply(this, args);
      } finally {
        const endTime = performance.now();
        self.performanceMetrics.executionTime += endTime - startTime;
      }
    };
  }
  
  // 包装定时器
  _wrapTimer(timerId, args) {
    this.timers.add(timerId);
    return timerId;
  }
  
  // 包装事件监听器
  _wrapEventListener(result, args) {
    if (args.length >= 3) {
      const [target, type, listener, options] = args;
      
      if (!this.listeners.has(target)) {
        this.listeners.set(target, new Map());
      }
      
      const targetListeners = this.listeners.get(target);
      
      if (!targetListeners.has(type)) {
        targetListeners.set(type, new Set());
      }
      
      targetListeners.get(type).add(listener);
    }
    
    return result;
  }
  
  // 浅拷贝对象
  _shallowCopy(obj) {
    if (obj === null || typeof obj !== 'object') {
      return obj;
    }
    
    // 对于基本类型，直接返回
    if (obj instanceof String || obj instanceof Number || obj instanceof Boolean) {
      return obj;
    }
    
    // 对于数组，创建新数组
    if (Array.isArray(obj)) {
      return obj.slice();
    }
    
    // 对于其他对象，创建新对象
    const result = {};
    Object.keys(obj).forEach(key => {
      result[key] = obj[key];
    });
    
    return result;
  }
  
  // 创建代理
  _createProxy(target) {
    const self = this;
    
    const handler = {
      get(target, prop) {
        self.performanceMetrics.propAccessCount++;
        
        // 如果是沙箱API，直接返回
        if (prop === '__SANDBEX_API__') {
          return target[prop];
        }
        
        // 如果是__proto__或constructor，返回安全的值
        if (prop === '__proto__' || prop === 'constructor') {
          return undefined;
        }
        
        // 如果属性存在于目标对象，直接返回
        if (prop in target) {
          return target[prop];
        }
        
        // 如果属性存在于原始window对象，返回包装后的值
        if (window[prop] !== undefined) {
          // 如果是函数，返回包装函数
          if (typeof window[prop] === 'function') {
            return self._wrapFunction(window[prop], prop);
          }
          
          // 如果是对象，返回代理对象
          if (typeof window[prop] === 'object' && window[prop] !== null) {
            return self._createObjectProxy(window[prop], prop);
          }
          
          return window[prop];
        }
        
        return undefined;
      },
      
      set(target, prop, value) {
        self.performanceMetrics.propSetCount++;
        
        // 如果是沙箱API，禁止修改
        if (prop === '__SANDBEX_API__') {
          return false;
        }
        
        // 如果是__proto__或constructor，禁止修改
        if (prop === '__proto__' || prop === 'constructor') {
          return false;
        }
        
        // 记录修改的属性
        self.modifiedProps.add(prop);
        
        // 在安全模式下，检查属性是否可写
        if (self.options.secure && prop in window) {
          const descriptor = Object.getOwnPropertyDescriptor(window, prop);
          if (descriptor && !descriptor.writable) {
            return false;
          }
        }
        
        target[prop] = value;
        return true;
      },
      
      has(target, prop) {
        return prop in target || prop in window;
      },
      
      deleteProperty(target, prop) {
        // 如果是沙箱API，禁止删除
        if (prop === '__SANDBEX_API__') {
          return false;
        }
        
        // 如果是__proto__或constructor，禁止删除
        if (prop === '__proto__' || prop === 'constructor') {
          return false;
        }
        
        // 从目标对象中删除
        if (prop in target) {
          delete target[prop];
          self.modifiedProps.delete(prop);
          return true;
        }
        
        // 在安全模式下，检查是否可以删除
        if (self.options.secure && prop in window) {
          const descriptor = Object.getOwnPropertyDescriptor(window, prop);
          if (descriptor && !descriptor.configurable) {
            return false;
          }
        }
        
        return true;
      },
      
      ownKeys(target) {
        // 合并目标对象和window对象的键
        const targetKeys = Object.getOwnPropertyNames(target);
        const windowKeys = Object.getOwnPropertyNames(window);
        
        // 去重
        return [...new Set([...targetKeys, ...windowKeys])];
      },
      
      getOwnPropertyDescriptor(target, prop) {
        // 优先从目标对象获取属性描述符
        let descriptor = Object.getOwnPropertyDescriptor(target, prop);
        
        // 如果目标对象没有，从window对象获取
        if (!descriptor) {
          descriptor = Object.getOwnPropertyDescriptor(window, prop);
          
          // 如果是window对象的属性，修改描述符
          if (descriptor) {
            descriptor = { ...descriptor };
            descriptor.configurable = true; // 使其可配置
          }
        }
        
        return descriptor;
      }
    };
    
    return new Proxy(target, handler);
  }
  
  // 创建对象代理
  _createObjectProxy(obj, name) {
    const self = this;
    
    return new Proxy(obj, {
      get(target, prop) {
        if (typeof target[prop] === 'function') {
          return self._wrapFunction(target[prop].bind(target), `${name}.${prop}`);
        }
        
        return target[prop];
      }
    });
  }
  
  // 重置沙箱
  reset() {
    // 清理修改的属性
    this.modifiedProps.forEach(prop => {
      delete this.sandbox[prop];
    });
    this.modifiedProps.clear();
    
    // 清理定时器
    this.timers.forEach(timerId => {
      clearTimeout(timerId);
      clearInterval(timerId);
    });
    this.timers.clear();
    
    // 清理事件监听器
    this.listeners.forEach((typeMap, target) => {
      typeMap.forEach((listeners, type) => {
        listeners.forEach(listener => {
          target.removeEventListener(type, listener);
        });
      });
    });
    this.listeners.clear();
    
    // 重置性能指标
    this.performanceMetrics = {
      propAccessCount: 0,
      propSetCount: 0,
      functionCallCount: 0,
      executionTime: 0,
      creationTime: this.performanceMetrics.creationTime
    };
  }
  
  // 销毁沙箱
  destroy() {
    this.reset();
    this.sandbox = null;
    this.proxy = null;
  }
  
  // 获取性能指标
  getPerformanceMetrics() {
    return {
      ...this.performanceMetrics,
      modifiedPropsCount: this.modifiedProps.size,
      timersCount: this.timers.size,
      listenersCount: Array.from(this.listeners.values())
        .reduce((sum, typeMap) => sum + Array.from(typeMap.values())
          .reduce((typeSum, listeners) => typeSum + listeners.size, 0), 0)
    };
  }
}

// 使用示例
const sandbox = new HighPerformanceSandbox('app1', {
  strict: false,
  secure: true,
  performance: true
});

// 创建沙箱
const appSandbox = sandbox.createSandbox();

// 在沙箱中执行代码
function executeInSandbox(code) {
  try {
    const func = new Function('sandbox', `
      with (sandbox) {
        ${code}
      }
    `);
    
    return func(appSandbox);
  } catch (error) {
    console.error('Sandbox execution error:', error);
  }
}

// 执行代码
executeInSandbox(`
  // 可以访问全局对象
  console.log('Hello from sandbox!');
  
  // 可以使用定时器
  const timer = setTimeout(() => {
    console.log('Timer executed');
  }, 1000);
  
  // 可以添加事件监听器
  document.addEventListener('click', () => {
    console.log('Document clicked');
  });
  
  // 修改变量
  var myVar = 'sandbox variable';
`);

// 获取性能指标
const metrics = sandbox.getPerformanceMetrics();
console.log('Sandbox performance metrics:', metrics);

// 重置沙箱
sandbox.reset();

// 销毁沙箱
sandbox.destroy();
```

## 8.4 渲染性能优化

### 8.4.1 虚拟列表优化

对于大型数据列表，虚拟列表是提高渲染性能的有效方法：

```javascript
// 微前端虚拟列表组件
class MicroFrontendVirtualList {
  constructor(container, options = {}) {
    this.container = typeof container === 'string' ? document.querySelector(container) : container;
    
    this.options = {
      itemHeight: 50,        // 每项高度
      bufferSize: 5,         // 缓冲区大小
      threshold: 200,        // 滚动阈值
      renderItem: null,      // 渲染项函数
      data: [],              // 数据
      ...options
    };
    
    this.state = {
      scrollTop: 0,
      containerHeight: 0,
      startIndex: 0,
      endIndex: 0,
      visibleItems: [],
      isScrolling: false,
      scrollTimer: null
    };
    
    this.init();
  }
  
  // 初始化
  init() {
    // 创建容器结构
    this.createContainer();
    
    // 计算初始状态
    this.updateState();
    
    // 渲染初始项
    this.renderItems();
    
    // 绑定事件
    this.bindEvents();
  }
  
  // 创建容器结构
  createContainer() {
    // 创建虚拟列表容器
    this.virtualList = document.createElement('div');
    this.virtualList.className = 'virtual-list';
    this.virtualList.style.cssText = `
      height: 100%;
      overflow-y: auto;
      position: relative;
    `;
    
    // 创建内容容器
    this.content = document.createElement('div');
    this.content.className = 'virtual-list-content';
    this.content.style.cssText = `
      position: relative;
      height: ${this.options.data.length * this.options.itemHeight}px;
    `;
    
    // 创建可见项容器
    this.visibleContainer = document.createElement('div');
    this.visibleContainer.className = 'virtual-list-visible';
    this.visibleContainer.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
    `;
    
    // 组装结构
    this.content.appendChild(this.visibleContainer);
    this.virtualList.appendChild(this.content);
    
    // 替换原容器内容
    this.container.innerHTML = '';
    this.container.appendChild(this.virtualList);
  }
  
  // 更新状态
  updateState() {
    const { scrollTop } = this.state;
    const { itemHeight, bufferSize, data } = this.options;
    
    // 计算容器高度
    this.state.containerHeight = this.virtualList.clientHeight;
    
    // 计算可见项范围
    const visibleCount = Math.ceil(this.state.containerHeight / itemHeight);
    const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - bufferSize);
    const endIndex = Math.min(data.length - 1, startIndex + visibleCount + bufferSize * 2);
    
    this.state.startIndex = startIndex;
    this.state.endIndex = endIndex;
    
    // 计算可见项
    this.state.visibleItems = [];
    for (let i = startIndex; i <= endIndex; i++) {
      this.state.visibleItems.push({
        index: i,
        data: data[i],
        top: i * itemHeight
      });
    }
  }
  
  // 渲染项
  renderItems() {
    const { renderItem } = this.options;
    const { visibleItems } = this.state;
    
    // 清空可见项容器
    this.visibleContainer.innerHTML = '';
    
    // 渲染可见项
    visibleItems.forEach(item => {
      const itemElement = document.createElement('div');
      itemElement.className = 'virtual-list-item';
      itemElement.style.cssText = `
        position: absolute;
        top: ${item.top}px;
        left: 0;
        right: 0;
        height: ${this.options.itemHeight}px;
        box-sizing: border-box;
      `;
      
      // 如果有渲染函数，使用渲染函数
      if (renderItem) {
        const renderedContent = renderItem(item.data, item.index);
        if (typeof renderedContent === 'string') {
          itemElement.innerHTML = renderedContent;
        } else if (renderedContent instanceof HTMLElement) {
          itemElement.appendChild(renderedContent);
        }
      } else {
        // 默认渲染
        itemElement.textContent = item.data;
      }
      
      this.visibleContainer.appendChild(itemElement);
    });
  }
  
  // 绑定事件
  bindEvents() {
    // 监听滚动事件
    this.virtualList.addEventListener('scroll', this.handleScroll.bind(this));
    
    // 监听窗口大小变化
    window.addEventListener('resize', this.handleResize.bind(this));
  }
  
  // 处理滚动事件
  handleScroll() {
    const scrollTop = this.virtualList.scrollTop;
    
    // 如果滚动距离小于阈值，不更新
    if (Math.abs(scrollTop - this.state.scrollTop) < this.options.threshold) {
      return;
    }
    
    // 更新滚动位置
    this.state.scrollTop = scrollTop;
    
    // 标记为滚动中
    this.state.isScrolling = true;
    
    // 清除之前的定时器
    if (this.state.scrollTimer) {
      clearTimeout(this.state.scrollTimer);
    }
    
    // 设置新的定时器
    this.state.scrollTimer = setTimeout(() => {
      this.state.isScrolling = false;
    }, 150);
    
    // 更新状态并渲染
    this.updateState();
    this.renderItems();
  }
  
  // 处理窗口大小变化
  handleResize() {
    this.updateState();
    this.renderItems();
  }
  
  // 更新数据
  updateData(newData) {
    this.options.data = newData;
    this.updateState();
    this.renderItems();
  }
  
  // 滚动到指定项
  scrollToItem(index) {
    if (index < 0 || index >= this.options.data.length) {
      return;
    }
    
    const scrollTop = index * this.options.itemHeight;
    this.virtualList.scrollTop = scrollTop;
  }
  
  // 获取当前可见项
  getVisibleItems() {
    return this.state.visibleItems.map(item => ({
      index: item.index,
      data: item.data
    }));
  }
  
  // 销毁虚拟列表
  destroy() {
    // 清除定时器
    if (this.state.scrollTimer) {
      clearTimeout(this.state.scrollTimer);
    }
    
    // 移除事件监听
    this.virtualList.removeEventListener('scroll', this.handleScroll);
    window.removeEventListener('resize', this.handleResize);
    
    // 清空容器
    this.container.innerHTML = '';
  }
}

// 使用示例
const data = Array.from({ length: 10000 }, (_, i) => `Item ${i + 1}`);

// 创建虚拟列表
const virtualList = new MicroFrontendVirtualList('#list-container', {
  itemHeight: 50,
  bufferSize: 5,
  data: data,
  renderItem: (data, index) => {
    const item = document.createElement('div');
    item.className = 'list-item';
    item.innerHTML = `
      <div class="item-index">${index + 1}</div>
      <div class="item-content">${data}</div>
      <div class="item-actions">
        <button class="btn-edit">编辑</button>
        <button class="btn-delete">删除</button>
      </div>
    `;
    
    // 添加事件处理
    item.querySelector('.btn-edit').addEventListener('click', () => {
      console.log(`Edit item ${index + 1}`);
    });
    
    item.querySelector('.btn-delete').addEventListener('click', () => {
      console.log(`Delete item ${index + 1}`);
    });
    
    return item;
  }
});

// 添加样式
const style = document.createElement('style');
style.textContent = `
  .virtual-list {
    border: 1px solid #ddd;
    border-radius: 4px;
  }
  
  .virtual-list-item {
    padding: 10px;
    border-bottom: 1px solid #eee;
    display: flex;
    align-items: center;
  }
  
  .virtual-list-item:hover {
    background-color: #f5f5f5;
  }
  
  .item-index {
    width: 50px;
    font-weight: bold;
  }
  
  .item-content {
    flex: 1;
  }
  
  .item-actions {
    display: flex;
    gap: 8px;
  }
  
  .btn-edit, .btn-delete {
    padding: 4px 8px;
    border: none;
    border-radius: 3px;
    cursor: pointer;
  }
  
  .btn-edit {
    background-color: #4CAF50;
    color: white;
  }
  
  .btn-delete {
    background-color: #f44336;
    color: white;
  }
`;
document.head.appendChild(style);
```

## 8.5 性能监控与分析

### 8.5.1 性能数据收集

```javascript
// 微前端性能数据收集器
class MicroFrontendPerformanceCollector {
  constructor() {
    this.metrics = {
      navigation: {},
      resources: [],
      userTiming: [],
      vitals: {},
      custom: new Map()
    };
    
    this.observers = {
      navigation: null,
      resource: null,
      userTiming: null,
      vitals: null
    };
    
    this.init();
  }
  
  // 初始化性能收集器
  init() {
    // 收集导航性能
    this.collectNavigationMetrics();
    
    // 收集资源性能
    this.collectResourceMetrics();
    
    // 收集用户计时
    this.collectUserTimingMetrics();
    
    // 收集Web Vitals
    this.collectWebVitals();
    
    // 监听自定义性能指标
    this.setupCustomMetrics();
  }
  
  // 收集导航性能
  collectNavigationMetrics() {
    if ('PerformanceObserver' in window) {
      this.observers.navigation = new PerformanceObserver(list => {
        for (const entry of list.getEntries()) {
          if (entry.entryType === 'navigation') {
            this.metrics.navigation = {
              type: entry.type,
              redirectCount: entry.redirectCount,
              transferSize: entry.transferSize,
              encodedBodySize: entry.encodedBodySize,
              decodedBodySize: entry.decodedBodySize,
              unloadEventStart: entry.unloadEventStart,
              unloadEventEnd: entry.unloadEventEnd,
              redirectStart: entry.redirectStart,
              redirectEnd: entry.redirectEnd,
              fetchStart: entry.fetchStart,
              domainLookupStart: entry.domainLookupStart,
              domainLookupEnd: entry.domainLookupEnd,
              connectStart: entry.connectStart,
              connectEnd: entry.connectEnd,
              secureConnectionStart: entry.secureConnectionStart,
              requestStart: entry.requestStart,
              responseStart: entry.responseStart,
              responseEnd: entry.responseEnd,
              domLoading: entry.domLoading,
              domInteractive: entry.domInteractive,
              domContentLoadedEventStart: entry.domContentLoadedEventStart,
              domContentLoadedEventEnd: entry.domContentLoadedEventEnd,
              domComplete: entry.domComplete,
              loadEventStart: entry.loadEventStart,
              loadEventEnd: entry.loadEventEnd,
              
              // 计算的时间指标
              dnsTime: entry.domainLookupEnd - entry.domainLookupStart,
              tcpTime: entry.connectEnd - entry.connectStart,
              sslTime: entry.secureConnectionStart > 0 ? entry.connectEnd - entry.secureConnectionStart : 0,
              ttfb: entry.responseStart - entry.requestStart,
              responseTime: entry.responseEnd - entry.responseStart,
              domParseTime: entry.domContentLoadedEventStart - entry.responseEnd,
              domReadyTime: entry.domContentLoadedEventEnd - entry.domContentLoadedEventStart,
              loadTime: entry.loadEventEnd - entry.loadEventStart,
              totalTime: entry.loadEventEnd - entry.navigationStart
            };
          }
        }
      });
      
      this.observers.navigation.observe({ entryTypes: ['navigation'] });
    } else if (performance.timing) {
      // 降级处理
      const timing = performance.timing;
      this.metrics.navigation = {
        dnsTime: timing.domainLookupEnd - timing.domainLookupStart,
        tcpTime: timing.connectEnd - timing.connectStart,
        sslTime: timing.secureConnectionStart > 0 ? timing.connectEnd - timing.secureConnectionStart : 0,
        ttfb: timing.responseStart - timing.requestStart,
        responseTime: timing.responseEnd - timing.responseStart,
        domParseTime: timing.domContentLoadedEventStart - timing.responseEnd,
        domReadyTime: timing.domContentLoadedEventEnd - timing.domContentLoadedEventStart,
        loadTime: timing.loadEventEnd - timing.loadEventStart,
        totalTime: timing.loadEventEnd - timing.navigationStart
      };
    }
  }
  
  // 收集资源性能
  collectResourceMetrics() {
    if ('PerformanceObserver' in window) {
      this.observers.resource = new PerformanceObserver(list => {
        for (const entry of list.getEntries()) {
          if (entry.entryType === 'resource') {
            this.metrics.resources.push({
              name: entry.name,
              type: this.getResourceType(entry.name),
              startTime: entry.startTime,
              duration: entry.duration,
              initiatorType: entry.initiatorType,
              transferSize: entry.transferSize,
              encodedBodySize: entry.encodedBodySize,
              decodedBodySize: entry.decodedBodySize,
              nextHopProtocol: entry.nextHopProtocol,
              responseStatus: entry.responseStatus
            });
          }
        }
      });
      
      this.observers.resource.observe({ entryTypes: ['resource'] });
    }
  }
  
  // 收集用户计时
  collectUserTimingMetrics() {
    if ('PerformanceObserver' in window) {
      this.observers.userTiming = new PerformanceObserver(list => {
        for (const entry of list.getEntries()) {
          if (entry.entryType === 'mark' || entry.entryType === 'measure') {
            this.metrics.userTiming.push({
              name: entry.name,
              entryType: entry.entryType,
              startTime: entry.startTime,
              duration: entry.duration
            });
          }
        }
      });
      
      this.observers.userTiming.observe({ entryTypes: ['mark', 'measure'] });
    }
  }
  
  // 收集Web Vitals
  collectWebVitals() {
    // 收集LCP (Largest Contentful Paint)
    this.collectLCP();
    
    // 收集FID (First Input Delay)
    this.collectFID();
    
    // 收集CLS (Cumulative Layout Shift)
    this.collectCLS();
    
    // 收集FCP (First Contentful Paint)
    this.collectFCP();
    
    // 收集TTI (Time to Interactive)
    this.collectTTI();
  }
  
  // 收集LCP
  collectLCP() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver(list => {
        const entries = list.getEntries();
        const lastEntry = entries[entries.length - 1];
        
        this.metrics.vitals.lcp = {
          value: lastEntry.startTime,
          element: lastEntry.element ? lastEntry.element.tagName : '',
          url: lastEntry.url || '',
          timestamp: Date.now()
        };
      });
      
      observer.observe({ entryTypes: ['largest-contentful-paint'] });
    }
  }
  
  // 收集FID
  collectFID() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver(list => {
        for (const entry of list.getEntries()) {
          if (entry.entryType === 'first-input') {
            this.metrics.vitals.fid = {
              value: entry.processingStart - entry.startTime,
              eventType: entry.name,
              timestamp: Date.now()
            };
            
            // 只需要第一次输入
            observer.disconnect();
            break;
          }
        }
      });
      
      observer.observe({ entryTypes: ['first-input'] });
    }
  }
  
  // 收集CLS
  collectCLS() {
    if ('PerformanceObserver' in window) {
      let clsValue = 0;
      
      const observer = new PerformanceObserver(list => {
        for (const entry of list.getEntries()) {
          if (!entry.hadRecentInput) {
            clsValue += entry.value;
            this.metrics.vitals.cls = {
              value: clsValue,
              timestamp: Date.now()
            };
          }
        }
      });
      
      observer.observe({ entryTypes: ['layout-shift'] });
    }
  }
  
  // 收集FCP
  collectFCP() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver(list => {
        for (const entry of list.getEntries()) {
          if (entry.name === 'first-contentful-paint') {
            this.metrics.vitals.fcp = {
              value: entry.startTime,
              timestamp: Date.now()
            };
            
            observer.disconnect();
            break;
          }
        }
      });
      
      observer.observe({ entryTypes: ['paint'] });
    }
  }
  
  // 收集TTI
  collectTTI() {
    // 使用tti-polyfill库
    if (typeof ttiPolyfill !== 'undefined') {
      ttiPolyfill.getFirstConsistentlyInteractive().then(value => {
        this.metrics.vitals.tti = {
          value,
          timestamp: Date.now()
        };
      });
    }
  }
  
  // 设置自定义指标
  setupCustomMetrics() {
    // 监听微前端事件
    window.addEventListener('micro-app-loaded', event => {
      this.recordCustomMetric('app-load-time', {
        appName: event.detail.name,
        value: event.detail.loadTime
      });
    });
    
    window.addEventListener('micro-app-mounted', event => {
      this.recordCustomMetric('app-mount-time', {
        appName: event.detail.name,
        value: event.detail.mountTime
      });
    });
    
    window.addEventListener('micro-app-route-change', event => {
      this.recordCustomMetric('route-change-time', {
        appName: event.detail.name,
        from: event.detail.from,
        to: event.detail.to,
        value: event.detail.duration
      });
    });
  }
  
  // 记录自定义指标
  recordCustomMetric(name, data) {
    if (!this.metrics.custom.has(name)) {
      this.metrics.custom.set(name, []);
    }
    
    this.metrics.custom.get(name).push({
      ...data,
      timestamp: Date.now()
    });
  }
  
  // 获取资源类型
  getResourceType(url) {
    if (/\.js$/.test(url)) return 'script';
    if (/\.css$/.test(url)) return 'stylesheet';
    if (/\.(png|jpg|jpeg|gif|svg|webp)$/.test(url)) return 'image';
    if (/\.woff2?$/.test(url)) return 'font';
    return 'other';
  }
  
  // 获取性能报告
  getPerformanceReport() {
    return {
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      url: window.location.href,
      navigation: this.metrics.navigation,
      resources: this.metrics.resources,
      userTiming: this.metrics.userTiming,
      vitals: this.metrics.vitals,
      custom: Object.fromEntries(this.metrics.custom)
    };
  }
  
  // 发送性能数据
  sendMetrics(endpoint) {
    const report = this.getPerformanceReport();
    
    fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(report)
    }).catch(error => {
      console.error('Failed to send performance metrics:', error);
    });
  }
  
  // 清理资源
  destroy() {
    Object.values(this.observers).forEach(observer => {
      if (observer) {
        observer.disconnect();
      }
    });
  }
}

// 使用示例
const performanceCollector = new MicroFrontendPerformanceCollector();

// 定期发送性能数据
setInterval(() => {
  performanceCollector.sendMetrics('/api/performance');
}, 30000);

// 记录自定义指标
performanceCollector.recordCustomMetric('custom-operation', {
  operation: 'data-processing',
  value: 150,
  unit: 'ms'
});
```

## 总结

本章详细介绍了微前端性能优化的各种策略和技术，包括：

1. **微前端性能概述**：分析了微前端架构面临的性能挑战和关键性能指标
2. **资源加载优化**：介绍了依赖共享、懒加载和预加载等优化策略
3. **运行时性能优化**：详细讲解了沙箱性能优化的实现方法
4. **渲染性能优化**：提供了虚拟列表等优化渲染性能的技术
5. **性能监控与分析**：介绍了性能数据收集和分析的方法

通过这些优化策略，微前端应用可以实现更快的加载速度、更流畅的用户交互和更好的整体性能。在实际项目中，应根据应用特点和性能瓶颈选择合适的优化策略，并通过性能监控持续优化应用性能。
    this.intervalIds = new Set();
    
    this.init();
  }
  
  // 初始化沙箱
  init() {
    switch (this.options.sandboxType) {
      case 'proxy':
        this.initProxySandbox();
        break;
      case 'snapshot':
        this.initSnapshotSandbox();
        break;
      case 'iframe':
        this.initIframeSandbox();
        break;
      default:
        this.initProxySandbox();
    }
  }
  
  // 初始化代理沙箱
  initProxySandbox() {
    const self = this;
    const rawWindow = window;
    
    // 创建沙箱全局对象
    const sandboxWindow = Object.create(rawWindow);
    
    // 创建代理对象
    const proxy = new Proxy(sandboxWindow, {
      get(target, prop) {
        // 性能优化：直接访问原生属性
        if (self.options.enablePerformanceOptimization && self.isSafeProperty(prop)) {
          return rawWindow[prop];
        }
        
        return target[prop];
      },
      
      set(target, prop, value) {
        // 记录修改的属性
        if (target[prop] !== value) {
          self.modifiedProps.add(prop);
        }
        
        // 性能优化：直接设置原生属性
        if (self.options.enablePerformanceOptimization && self.isSafeProperty(prop)) {
          rawWindow[prop] = value;
          return true;
        }
        
        target[prop] = value;
        return true;
      },
      
      has(target, prop) {
        return prop in target || prop in rawWindow;
      },
      
      deleteProperty(target, prop) {
        if (prop in target) {
          self.modifiedProps.add(prop);
          delete target[prop];
          return true;
        }
        return false;
      }
    });
    
    this.sandbox = proxy;
  }
  
  // 判断是否为安全属性（可以直接访问的属性）
  isSafeProperty(prop) {
    // 排除可能影响全局状态的属性
    const unsafeProps = [
      'document', 'window', 'self', 'parent', 'top', 'frames',
      'location', 'history', 'navigator', 'localStorage', 'sessionStorage',
      'indexedDB', 'webkitStorageInfo', 'globalStorage', 'sessionStorage'
    ];
    
    // 排除函数（避免函数调用带来的性能问题）
    if (typeof window[prop] === 'function') {
      return false;
    }
    
    // 排除不安全属性
    if (unsafeProps.includes(prop)) {
      return false;
    }
    
    // 排除以下划线开头的属性（通常是内部属性）
    if (prop.startsWith('_')) {
      return false;
    }
    
    return true;
  }
  
  // 初始化快照沙箱
  initSnapshotSandbox() {
    this.sandbox = window;
  }
  
  // 初始化iframe沙箱
  initIframeSandbox() {
    const iframe = document.createElement('iframe');
    iframe.style.display = 'none';
    document.body.appendChild(iframe);
    
    this.iframe = iframe;
    this.sandbox = iframe.contentWindow;
  }
  
  // 激活沙箱
  activate() {
    if (this.active) {
      return;
    }
    
    switch (this.options.sandboxType) {
      case 'snapshot':
        this.activateSnapshotSandbox();
        break;
      case 'iframe':
        this.activateIframeSandbox();
        break;
    }
    
    this.active = true;
    this.patchTimers();
    this.patchEventListeners();
  }
  
  // 激活快照沙箱
  activateSnapshotSandbox() {
    // 保存当前全局状态
    this.windowSnapshot = {};
    for (const prop in window) {
      this.windowSnapshot[prop] = window[prop];
    }
  }
  
  // 激活iframe沙箱
  activateIframeSandbox() {
    // 设置iframe沙箱的全局变量
    this.sandbox.parent = window;
    this.sandbox.top = window;
  }
  
  // 停用沙箱
  deactivate() {
    if (!this.active) {
      return;
    }
    
    this.restoreTimers();
    this.restoreEventListeners();
    
    switch (this.options.sandboxType) {
      case 'snapshot':
        this.deactivateSnapshotSandbox();
        break;
      case 'iframe':
        this.deactivateIframeSandbox();
        break;
    }
    
    this.active = false;
  }
  
  // 停用快照沙箱
  deactivateSnapshotSandbox() {
    // 恢复全局状态
    for (const prop in this.windowSnapshot) {
      window[prop] = this.windowSnapshot[prop];
    }
  }
  
  // 停用iframe沙箱
  deactivateIframeSandbox() {
    // 清理iframe
    if (this.iframe && this.iframe.parentNode) {
      this.iframe.parentNode.removeChild(this.iframe);
    }
  }
  
  // 修复定时器
  patchTimers() {
    const self = this;
    
    // 保存原始方法
    const originalSetTimeout = this.sandbox.setTimeout;
    const originalClearTimeout = this.sandbox.clearTimeout;
    const originalSetInterval = this.sandbox.setInterval;
    const originalClearInterval = this.sandbox.clearInterval;
    
    // 重写setTimeout
    this.sandbox.setTimeout = function(callback, delay, ...args) {
      const id = originalSetTimeout.call(this, callback, delay, ...args);
      self.timerIds.add(id);
      return id;
    };
    
    // 重写clearTimeout
    this.sandbox.clearTimeout = function(id) {
      self.timerIds.delete(id);
      return originalClearTimeout.call(this, id);
    };
    
    // 重写setInterval
    this.sandbox.setInterval = function(callback, delay, ...args) {
      const id = originalSetInterval.call(this, callback, delay, ...args);
      self.intervalIds.add(id);
      return id;
    };
    
    // 重写clearInterval
    this.sandbox.clearInterval = function(id) {
      self.intervalIds.delete(id);
      return originalClearInterval.call(this, id);
    };
  }
  
  // 恢复定时器
  restoreTimers() {
    // 清理所有定时器
    this.timerIds.forEach(id => {
      this.sandbox.clearTimeout(id);
    });
    
    this.intervalIds.forEach(id => {
      this.sandbox.clearInterval(id);
    });
    
    this.timerIds.clear();
    this.intervalIds.clear();
  }
  
  // 修复事件监听器
  patchEventListeners() {
    const self = this;
    
    // 保存原始方法
    const originalAddEventListener = this.sandbox.addEventListener;
    const originalRemoveEventListener = this.sandbox.removeEventListener;
    
    // 重写addEventListener
    this.sandbox.addEventListener = function(type, listener, options) {
      const id = `${type}_${Date.now()}_${Math.random()}`;
      self.eventListeners.set(id, { type, listener, options });
      return originalAddEventListener.call(this, type, listener, options);
    };
    
    // 重写removeEventListener
    this.sandbox.removeEventListener = function(type, listener, options) {
      // 查找并移除事件监听器
      for (const [id, event] of self.eventListeners.entries()) {
        if (event.type === type && event.listener === listener) {
          self.eventListeners.delete(id);
          break;
        }
      }
      
      return originalRemoveEventListener.call(this, type, listener, options);
    };
  }
  
  // 恢复事件监听器
  restoreEventListeners() {
    // 移除所有事件监听器
    this.eventListeners.forEach(({ type, listener, options }) => {
      this.sandbox.removeEventListener(type, listener, options);
    });
    
    this.eventListeners.clear();
  }
  
  // 获取沙箱全局对象
  getGlobalObject() {
    return this.sandbox;
  }
  
  // 执行代码
  execScript(code) {
    try {
      // 使用Function构造函数执行代码，避免eval的安全问题
      const execFunction = new Function('window', code);
      return execFunction(this.sandbox);
    } catch (error) {
      console.error(`执行代码失败: ${error.message}`);
      throw error;
    }
  }
  
  // 销毁沙箱
  destroy() {
    this.deactivate();
    
    if (this.iframe && this.iframe.parentNode) {
      this.iframe.parentNode.removeChild(this.iframe);
    }
    
    this.sandbox = null;
    this.globalProps.clear();
    this.modifiedProps.clear();
    this.timerIds.clear();
    this.eventListeners.clear();
    this.intervalIds.clear();
  }
}

// 创建高性能沙箱工厂
class SandboxFactory {
  static createSandbox(name, options = {}) {
    return new HighPerformanceSandbox(name, options);
  }
}

// 导出沙箱工厂
export default SandboxFactory;
```

### 8.3.2 通信机制优化

微前端应用间的通信是性能瓶颈之一，需要优化：

```javascript
// 高性能通信管理器
class HighPerformanceCommunicationManager {
  constructor() {
    this.eventBus = new Map();
    this.messageQueue = [];
    this.isProcessingQueue = false;
    this.batchSize = 10; // 批处理大小
    this.batchTimeout = 16; // 批处理超时时间（毫秒）
    this.batchTimer = null;
    this.messageHandlers = new Map();
    this.responseHandlers = new Map();
    this.messageId = 0;
  }
  
  // 订阅事件
  on(eventType, handler, options = {}) {
    if (!this.eventBus.has(eventType)) {
      this.eventBus.set(eventType, []);
    }
    
    const listener = {
      handler,
      once: options.once || false,
      priority: options.priority || 0,
      app: options.app || 'unknown'
    };
    
    this.eventBus.get(eventType).push(listener);
    
    // 按优先级排序
    this.eventBus.get(eventType).sort((a, b) => b.priority - a.priority);
    
    // 返回取消订阅函数
    return () => {
      this.off(eventType, handler);
    };
  }
  
  // 取消订阅
  off(eventType, handler) {
    if (!this.eventBus.has(eventType)) {
      return;
    }
    
    const listeners = this.eventBus.get(eventType);
    const index = listeners.findIndex(listener => listener.handler === handler);
    
    if (index !== -1) {
      listeners.splice(index, 1);
    }
    
    // 如果没有监听器了，删除事件类型
    if (listeners.length === 0) {
      this.eventBus.delete(eventType);
    }
  }
  
  // 发布事件（批处理）
  emit(eventType, data, options = {}) {
    const message = {
      id: this.messageId++,
      type: eventType,
      data,
      timestamp: Date.now(),
      source: options.source || 'unknown',
      target: options.target || null,
      priority: options.priority || 'normal'
    };
    
    // 高优先级消息立即处理
    if (message.priority === 'high') {
      this.processMessage(message);
      return;
    }
    
    // 添加到消息队列
    this.messageQueue.push(message);
    
    // 如果队列处理未启动，启动批处理
    if (!this.isProcessingQueue) {
      this.startBatchProcessing();
    }
  }
  
  // 启动批处理
  startBatchProcessing() {
    if (this.isProcessingQueue) {
      return;
    }
    
    this.isProcessingQueue = true;
    
    // 设置批处理定时器
    this.batchTimer = setTimeout(() => {
      this.processBatch();
    }, this.batchTimeout);
  }
  
  // 处理消息批次
  processBatch() {
    if (this.messageQueue.length === 0) {
      this.isProcessingQueue = false;
      return;
    }
    
    // 取出一批消息
    const batch = this.messageQueue.splice(0, this.batchSize);
    
    // 按优先级排序
    batch.sort((a, b) => {
      const priorityOrder = { high: 3, normal: 2, low: 1 };
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
    
    // 处理批次中的消息
    batch.forEach(message => {
      this.processMessage(message);
    });
    
    // 如果还有消息，继续处理
    if (this.messageQueue.length > 0) {
      this.batchTimer = setTimeout(() => {
        this.processBatch();
      }, this.batchTimeout);
    } else {
      this.isProcessingQueue = false;
    }
  }
  
  // 处理单个消息
  processMessage(message) {
    const listeners = this.eventBus.get(message.type);
    
    if (!listeners || listeners.length === 0) {
      return;
    }
    
    // 复制监听器数组，避免在处理过程中数组被修改
    const listenersToProcess = [...listeners];
    
    // 处理消息
    for (const listener of listenersToProcess) {
      try {
        listener.handler(message.data, message);
        
        // 如果是一次性监听器，移除它
        if (listener.once) {
          this.off(message.type, listener.handler);
        }
      } catch (error) {
        console.error(`处理事件 ${message.type} 时出错:`, error);
      }
    }
  }
  
  // 发送请求并等待响应
  async request(eventType, data, options = {}) {
    return new Promise((resolve, reject) => {
      const messageId = this.messageId++;
      
      // 设置响应超时
      const timeout = options.timeout || 5000;
      const timeoutId = setTimeout(() => {
        this.responseHandlers.delete(messageId);
        reject(new Error(`请求 ${eventType} 超时`));
      }, timeout);
      
      // 注册响应处理器
      this.responseHandlers.set(messageId, {
        resolve,
        reject,
        timeoutId
      });
      
      // 发送请求消息
      this.emit(eventType, data, {
        ...options,
        requestId: messageId,
        isRequest: true
      });
    });
  }
  
  // 响应请求
  response(requestId, data, isError = false) {
    const handler = this.responseHandlers.get(requestId);
    
    if (!handler) {
      return;
    }
    
    // 清除超时
    clearTimeout(handler.timeoutId);
    
    // 移除响应处理器
    this.responseHandlers.delete(requestId);
    
    // 处理响应
    if (isError) {
      handler.reject(data);
    } else {
      handler.resolve(data);
    }
  }
  
  // 创建命名空间
  namespace(name) {
    return {
      on: (eventType, handler, options) => {
        return this.on(`${name}:${eventType}`, handler, {
          ...options,
          namespace: name
        });
      },
      
      off: (eventType, handler) => {
        return this.off(`${name}:${eventType}`, handler);
      },
      
      emit: (eventType, data, options) => {
        return this.emit(`${name}:${eventType}`, data, {
          ...options,
          namespace: name
        });
      },
      
      request: (eventType, data, options) => {
        return this.request(`${name}:${eventType}`, data, {
          ...options,
          namespace: name
        });
      },
      
      response: (requestId, data, isError) => {
        return this.response(requestId, data, isError);
      }
    };
  }
  
  // 清理
  clear() {
    this.eventBus.clear();
    this.messageQueue = [];
    this.messageHandlers.clear();
    this.responseHandlers.forEach(handler => {
      clearTimeout(handler.timeoutId);
    });
    this.responseHandlers.clear();
    
    if (this.batchTimer) {
      clearTimeout(this.batchTimer);
      this.batchTimer = null;
    }
    
    this.isProcessingQueue = false;
  }
}

// 创建全局通信管理器
const communicationManager = new HighPerformanceCommunicationManager();

// 导出通信管理器
export default communicationManager;
```

## 8.4 缓存策略

### 8.4.1 资源缓存

资源缓存是提高微前端性能的重要手段：

```javascript
// 微前端资源缓存管理器
class MicroFrontendCacheManager {
  constructor() {
    this.cache = new Map();
    this.cacheConfig = {
      maxAge: 24 * 60 * 60 * 1000, // 24小时
      maxSize: 100, // 最大缓存条目数
      storageQuota: 50 * 1024 * 1024, // 50MB存储配额
      ...this.loadCacheConfig()
    };
    
    this.cacheStats = {
      hits: 0,
      misses: 0,
      evictions: 0,
      size: 0
    };
    
    this.initCache();
  }
  
  // 初始化缓存
  initCache() {
    // 从localStorage加载缓存
    this.loadFromStorage();
    
    // 定期清理过期缓存
    setInterval(() => {
      this.cleanExpiredCache();
    }, 60 * 60 * 1000); // 每小时清理一次
  }
  
  // 加载缓存配置
  loadCacheConfig() {
    try {
      const config = localStorage.getItem('mf-cache-config');
      return config ? JSON.parse(config) : {};
    } catch (error) {
      console.error('加载缓存配置失败:', error);
      return {};
    }
  }
  
  // 保存缓存配置
  saveCacheConfig() {
    try {
      localStorage.setItem('mf-cache-config', JSON.stringify(this.cacheConfig));
    } catch (error) {
      console.error('保存缓存配置失败:', error);
    }
  }
  
  // 从localStorage加载缓存
  loadFromStorage() {
    try {
      const cacheData = localStorage.getItem('mf-cache-data');
      if (cacheData) {
        const data = JSON.parse(cacheData);
        
        // 恢复缓存
        for (const [key, entry] of Object.entries(data)) {
          this.cache.set(key, entry);
        }
        
        this.updateCacheStats();
      }
    } catch (error) {
      console.error('从存储加载缓存失败:', error);
    }
  }
  
  // 保存到localStorage
  saveToStorage() {
    try {
      const data = {};
      
      // 只保存非过期的缓存
      for (const [key, entry] of this.cache.entries()) {
        if (!this.isExpired(entry)) {
          data[key] = entry;
        }
      }
      
      localStorage.setItem('mf-cache-data', JSON.stringify(data));
    } catch (error) {
      console.error('保存缓存到存储失败:', error);
    }
  }
  
  // 获取缓存
  get(key) {
    const entry = this.cache.get(key);
    
    if (!entry) {
      this.cacheStats.misses++;
      return null;
    }
    
    // 检查是否过期
    if (this.isExpired(entry)) {
      this.cache.delete(key);
      this.cacheStats.misses++;
      return null;
    }
    
    // 更新访问时间
    entry.lastAccessed = Date.now();
    this.cacheStats.hits++;
    
    return entry.data;
  }
  
  // 设置缓存
  set(key, data, options = {}) {
    const ttl = options.ttl || this.cacheConfig.maxAge;
    const priority = options.priority || 'normal';
    
    const entry = {
      data,
      created: Date.now(),
      lastAccessed: Date.now(),
      ttl,
      priority,
      size: this.calculateSize(data)
    };
    
    // 检查是否需要腾出空间
    this.ensureSpace(entry.size);
    
    // 设置缓存
    this.cache.set(key, entry);
    this.updateCacheStats();
    
    // 异步保存到存储
    this.scheduleSaveToStorage();
  }
  
  // 删除缓存
  delete(key) {
    const deleted = this.cache.delete(key);
    if (deleted) {
      this.updateCacheStats();
      this.scheduleSaveToStorage();
    }
    return deleted;
  }
  
  // 检查缓存是否存在
  has(key) {
    const entry = this.cache.get(key);
    return entry && !this.isExpired(entry);
  }
  
  // 清空缓存
  clear() {
    this.cache.clear();
    this.updateCacheStats();
    this.saveToStorage();
  }
  
  // 检查是否过期
  isExpired(entry) {
    return Date.now() - entry.created > entry.ttl;
  }
  
  // 计算数据大小
  calculateSize(data) {
    try {
      return JSON.stringify(data).length;
    } catch (error) {
      return 0;
    }
  }
  
  // 确保有足够空间
  ensureSpace(requiredSize) {
    // 检查缓存大小限制
    while (this.cache.size >= this.cacheConfig.maxSize) {
      this.evictLeastRecentlyUsed();
    }
    
    // 检查存储配额
    const currentSize = this.getCurrentCacheSize();
    if (currentSize + requiredSize > this.cacheConfig.storageQuota) {
      this.evictBySize(requiredSize);
    }
  }
  
  // 淘汰最近最少使用的缓存
  evictLeastRecentlyUsed() {
    let lruKey = null;
    let lruTime = Date.now();
    
    for (const [key, entry] of this.cache.entries()) {
      if (entry.lastAccessed < lruTime) {
        lruTime = entry.lastAccessed;
        lruKey = key;
      }
    }
    
    if (lruKey) {
      this.cache.delete(lruKey);
      this.cacheStats.evictions++;
    }
  }
  
  // 按大小淘汰缓存
  evictBySize(requiredSize) {
    // 按优先级和访问时间排序
    const entries = Array.from(this.cache.entries()).sort((a, b) => {
      // 先按优先级排序
      const priorityOrder = { low: 1, normal: 2, high: 3 };
      const priorityDiff = priorityOrder[a[1].priority] - priorityOrder[b[1].priority];
      
      if (priorityDiff !== 0) {
        return priorityDiff;
      }
      
      // 再按访问时间排序
      return a[1].lastAccessed - b[1].lastAccessed;
    });
    
    let freedSize = 0;
    
    for (const [key, entry] of entries) {
      this.cache.delete(key);
      freedSize += entry.size;
      this.cacheStats.evictions++;
      
      if (freedSize >= requiredSize) {
        break;
      }
    }
  }
  
  // 清理过期缓存
  cleanExpiredCache() {
    const expiredKeys = [];
    
    for (const [key, entry] of this.cache.entries()) {
      if (this.isExpired(entry)) {
        expiredKeys.push(key);
      }
    }
    
    for (const key of expiredKeys) {
      this.cache.delete(key);
      this.cacheStats.evictions++;
    }
    
    if (expiredKeys.length > 0) {
      this.updateCacheStats();
      this.saveToStorage();
    }
  }
  
  // 获取当前缓存大小
  getCurrentCacheSize() {
    let size = 0;
    
    for (const entry of this.cache.values()) {
      size += entry.size;
    }
    
    return size;
  }
  
  // 更新缓存统计
  updateCacheStats() {
    this.cacheStats.size = this.cache.size;
    this.cacheStats.currentSize = this.getCurrentCacheSize();
  }
  
  // 计划保存到存储
  scheduleSaveToStorage() {
    // 防抖保存，避免频繁IO
    if (this.saveTimer) {
      clearTimeout(this.saveTimer);
    }
    
    this.saveTimer = setTimeout(() => {
      this.saveToStorage();
      this.saveTimer = null;
    }, 1000);
  }
  
  // 获取缓存统计
  getStats() {
    this.updateCacheStats();
    return { ...this.cacheStats };
  }
  
  // 获取缓存配置
  getConfig() {
    return { ...this.cacheConfig };
  }
  
  // 更新缓存配置
  updateConfig(newConfig) {
    this.cacheConfig = {
      ...this.cacheConfig,
      ...newConfig
    };
    
    this.saveCacheConfig();
    
    // 如果配置变化导致缓存超出限制，立即清理
    this.ensureSpace(0);
  }
}

// 创建全局缓存管理器
const cacheManager = new MicroFrontendCacheManager();

// 导出缓存管理器
export default cacheManager;
```

### 8.4.2 应用状态缓存

应用状态缓存可以避免重复初始化和加载：

```javascript
// 微前端状态缓存管理器
class MicroAppStateCache {
  constructor() {
    this.stateCache = new Map();
    this.cacheConfig = {
      maxAge: 30 * 60 * 1000, // 30分钟
      maxSize: 50, // 最大缓存状态数
      compressionEnabled: true,
      ...this.loadCacheConfig()
    };
    
    this.compressionWorker = null;
    this.initCompressionWorker();
  }
  
  // 初始化压缩Worker
  initCompressionWorker() {
    if (this.cacheConfig.compressionEnabled && window.Worker) {
      // 创建压缩Worker代码
      const workerCode = `
        self.onmessage = function(e) {
          const { id, action, data } = e.data;
          
          if (action === 'compress') {
            try {
              const compressed = JSON.stringify(data);
              self.postMessage({ id, result: compressed });
            } catch (error) {
              self.postMessage({ id, error: error.message });
            }
          } else if (action === 'decompress') {
            try {
              const decompressed = JSON.parse(data);
              self.postMessage({ id, result: decompressed });
            } catch (error) {
              self.postMessage({ id, error: error.message });
            }
          }
        };
      `;
      
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      this.compressionWorker = new Worker(URL.createObjectURL(blob));
    }
  }
  
  // 加载缓存配置
  loadCacheConfig() {
    try {
      const config = sessionStorage.getItem('mf-state-cache-config');
      return config ? JSON.parse(config) : {};
    } catch (error) {
      console.error('加载状态缓存配置失败:', error);
      return {};
    }
  }
  
  // 保存缓存配置
  saveCacheConfig() {
    try {
      sessionStorage.setItem('mf-state-cache-config', JSON.stringify(this.cacheConfig));
    } catch (error) {
      console.error('保存状态缓存配置失败:', error);
    }
  }
  
  // 缓存应用状态
  async cacheAppState(appName, state, options = {}) {
    const ttl = options.ttl || this.cacheConfig.maxAge;
    const version = options.version || '1.0.0';
    
    const stateEntry = {
      appName,
      state,
      version,
      created: Date.now(),
      lastAccessed: Date.now(),
      ttl
    };
    
    // 如果启用压缩，压缩状态数据
    if (this.cacheConfig.compressionEnabled && this.compressionWorker) {
      try {
        const compressedState = await this.compressState(state);
        stateEntry.state = compressedState;
        stateEntry.compressed = true;
      } catch (error) {
        console.error('压缩状态失败:', error);
      }
    }
    
    // 检查缓存大小
    this.ensureCacheSize();
    
    // 设置缓存
    this.stateCache.set(appName, stateEntry);
    
    // 保存到sessionStorage
    this.saveToSessionStorage();
    
    return true;
  }
  
  // 获取缓存的应用状态
  async getCachedAppState(appName, version = null) {
    const stateEntry = this.stateCache.get(appName);
    
    if (!stateEntry) {
      return null;
    }
    
    // 检查是否过期
    if (this.isExpired(stateEntry)) {
      this.stateCache.delete(appName);
      this.saveToSessionStorage();
      return null;
    }
    
    // 检查版本兼容性
    if (version && !this.isVersionCompatible(stateEntry.version, version)) {
      console.warn(`应用 ${appName} 的缓存状态版本不兼容: 缓存版本 ${stateEntry.version}, 请求版本 ${version}`);
      return null;
    }
    
    // 更新访问时间
    stateEntry.lastAccessed = Date.now();
    
    // 如果状态被压缩，解压缩
    let state = stateEntry.state;
    if (stateEntry.compressed) {
      try {
        state = await this.decompressState(state);
      } catch (error) {
        console.error('解压缩状态失败:', error);
        return null;
      }
    }
    
    return state;
  }
  
  // 压缩状态
  compressState(state) {
    return new Promise((resolve, reject) => {
      const id = Date.now().toString();
      
      const handleMessage = (e) => {
        if (e.data.id === id) {
          this.compressionWorker.removeEventListener('message', handleMessage);
          
          if (e.data.error) {
            reject(new Error(e.data.error));
          } else {
            resolve(e.data.result);
          }
        }
      };
      
      this.compressionWorker.addEventListener('message', handleMessage);
      this.compressionWorker.postMessage({ id, action: 'compress', data: state });
    });
  }
  
  // 解压缩状态
  decompressState(compressedState) {
    return new Promise((resolve, reject) => {
      const id = Date.now().toString();
      
      const handleMessage = (e) => {
        if (e.data.id === id) {
          this.compressionWorker.removeEventListener('message', handleMessage);
          
          if (e.data.error) {
            reject(new Error(e.data.error));
          } else {
            resolve(e.data.result);
          }
        }
      };
      
      this.compressionWorker.addEventListener('message', handleMessage);
      this.compressionWorker.postMessage({ id, action: 'decompress', data: compressedState });
    });
  }
  
  // 检查是否过期
  isExpired(stateEntry) {
    return Date.now() - stateEntry.created > stateEntry.ttl;
  }
  
  // 检查版本兼容性
  isVersionCompatible(cachedVersion, requestedVersion) {
    // 简单的版本兼容性检查，实际项目中可能需要更复杂的逻辑
    return cachedVersion === requestedVersion;
  }
  
  // 确保缓存大小在限制内
  ensureCacheSize() {
    while (this.stateCache.size >= this.cacheConfig.maxSize) {
      this.evictLeastRecentlyUsed();
    }
  }
  
  // 淘汰最近最少使用的状态
  evictLeastRecentlyUsed() {
    let lruKey = null;
    let lruTime = Date.now();
    
    for (const [key, entry] of this.stateCache.entries()) {
      if (entry.lastAccessed < lruTime) {
        lruTime = entry.lastAccessed;
        lruKey = key;
      }
    }
    
    if (lruKey) {
      this.stateCache.delete(lruKey);
    }
  }
  
  // 保存到sessionStorage
  saveToSessionStorage() {
    try {
      const data = {};
      
      // 只保存非过期的状态
      for (const [key, entry] of this.stateCache.entries()) {
        if (!this.isExpired(entry)) {
          data[key] = entry;
        }
      }
      
      sessionStorage.setItem('mf-state-cache', JSON.stringify(data));
    } catch (error) {
      console.error('保存状态缓存到sessionStorage失败:', error);
    }
  }
  
  // 从sessionStorage加载
  loadFromSessionStorage() {
    try {
      const data = sessionStorage.getItem('mf-state-cache');
      if (data) {
        const stateData = JSON.parse(data);
        
        for (const [key, entry] of Object.entries(stateData)) {
          // 只加载未过期的状态
          if (!this.isExpired(entry)) {
            this.stateCache.set(key, entry);
          }
        }
      }
    } catch (error) {
      console.error('从sessionStorage加载状态缓存失败:', error);
    }
  }
  
  // 清除应用状态缓存
  clearAppStateCache(appName = null) {
    if (appName) {
      this.stateCache.delete(appName);
    } else {
      this.stateCache.clear();
    }
    
    this.saveToSessionStorage();
  }
  
  // 获取缓存统计
  getStats() {
    return {
      size: this.stateCache.size,
      maxSize: this.cacheConfig.maxSize,
      compressionEnabled: this.cacheConfig.compressionEnabled
    };
  }
  
  // 更新缓存配置
  updateConfig(newConfig) {
    this.cacheConfig = {
      ...this.cacheConfig,
      ...newConfig
    };
    
    this.saveCacheConfig();
    
    // 如果配置变化导致缓存超出限制，立即清理
    this.ensureCacheSize();
  }
  
  // 销毁
  destroy() {
    if (this.compressionWorker) {
      this.compressionWorker.terminate();
      this.compressionWorker = null;
    }
    
    this.stateCache.clear();
  }
}

// 创建全局状态缓存管理器
const appStateCache = new MicroAppStateCache();

// 导出状态缓存管理器
export default appStateCache;
```

## 总结

本章详细介绍了微前端性能优化的各种策略和实现方法，包括：

1. **资源加载优化**：通过依赖共享、懒加载和代码分割减少初始加载时间
2. **运行时性能优化**：优化沙箱实现和通信机制，减少运行时开销
3. **缓存策略**：实现资源缓存和应用状态缓存，提高响应速度

通过这些优化策略，微前端应用可以在保持架构优势的同时，提供接近单体应用的用户体验。在实际项目中，应根据具体场景选择合适的优化策略，并持续监控和调整以达到最佳性能。