# 第十三章：微前端监控与调试

## 13.1 微前端监控概述

### 13.1.1 监控挑战

微前端架构带来的监控挑战主要包括：

1. **分布式系统复杂性**
   - 多个应用独立运行
   - 跨应用调用追踪
   - 分布式事务监控

2. **数据聚合与分析**
   - 多源数据收集
   - 指标标准化
   - 关联分析困难

3. **故障定位难度**
   - 故障边界模糊
   - 依赖关系复杂
   - 根因分析困难

4. **性能监控复杂性**
   - 跨应用性能影响
   - 资源竞争问题
   - 用户体验一致性

### 13.1.2 监控目标

微前端监控的主要目标包括：

1. **可用性监控**
   - 应用健康状态
   - 服务可用性
   - 故障快速发现

2. **性能监控**
   - 加载性能
   - 运行时性能
   - 用户体验指标

3. **业务监控**
   - 用户行为分析
   - 业务流程监控
   - 转化率分析

4. **错误监控**
   - JavaScript错误
   - API请求错误
   - 资源加载错误

## 13.2 性能监控

### 13.2.1 关键性能指标

```javascript
// 示例：性能指标收集
class PerformanceMetrics {
  constructor() {
    this.metrics = {
      navigation: {},
      resources: [],
      paint: {},
      layoutShift: [],
      firstInputDelay: null,
      largestContentfulPaint: null,
      customMetrics: new Map(),
    };
    
    this.observers = new Map();
    this.isCollecting = false;
  }

  // 开始收集性能指标
  startCollecting() {
    if (this.isCollecting) return;
    
    this.isCollecting = true;
    
    // 收集导航指标
    this.collectNavigationMetrics();
    
    // 收集资源加载指标
    this.collectResourceMetrics();
    
    // 收集绘制指标
    this.collectPaintMetrics();
    
    // 观察布局偏移
    this.observeLayoutShift();
    
    // 观察首次输入延迟
    this.observeFirstInputDelay();
    
    // 观察最大内容绘制
    this.observeLargestContentfulPaint();
    
    console.log('Performance metrics collection started');
  }

  // 停止收集性能指标
  stopCollecting() {
    if (!this.isCollecting) return;
    
    this.isCollecting = false;
    
    // 断开所有观察者
    for (const [name, observer] of this.observers) {
      observer.disconnect();
      this.observers.delete(name);
    }
    
    console.log('Performance metrics collection stopped');
  }

  // 收集导航指标
  collectNavigationMetrics() {
    if (!performance.timing) return;
    
    const timing = performance.timing;
    const navigation = performance.navigation;
    
    this.metrics.navigation = {
      // 页面加载时间
      loadTime: timing.loadEventEnd - timing.navigationStart,
      
      // DOM解析时间
      domParseTime: timing.domContentLoadedEventEnd - timing.responseEnd,
      
      // 资源加载时间
      resourceLoadTime: timing.loadEventEnd - timing.domContentLoadedEventEnd,
      
      // 首字节时间
      ttfb: timing.responseStart - timing.navigationStart,
      
      // DNS查询时间
      dnsTime: timing.domainLookupEnd - timing.domainLookupStart,
      
      // TCP连接时间
      tcpTime: timing.connectEnd - timing.connectStart,
      
      // SSL握手时间
      sslTime: timing.secureConnectionStart > 0 
        ? timing.connectEnd - timing.secureConnectionStart 
        : 0,
      
      // 导航类型
      type: navigation.type,
      redirectCount: navigation.redirectCount,
    };
  }

  // 收集资源加载指标
  collectResourceMetrics() {
    if (!performance.getEntriesByType) return;
    
    const resources = performance.getEntriesByType('resource');
    
    this.metrics.resources = resources.map(resource => ({
      name: resource.name,
      type: this.getResourceType(resource.name),
      duration: resource.duration,
      size: resource.transferSize || 0,
      startTime: resource.startTime,
      
      // 请求各阶段时间
      redirectTime: resource.redirectEnd - resource.redirectStart,
      dnsTime: resource.domainLookupEnd - resource.domainLookupStart,
      tcpTime: resource.connectEnd - resource.connectStart,
      sslTime: resource.secureConnectionStart > 0 
        ? resource.connectEnd - resource.secureConnectionStart 
        : 0,
      ttfb: resource.responseStart - resource.requestStart,
      downloadTime: resource.responseEnd - resource.responseStart,
    }));
  }

  // 收集绘制指标
  collectPaintMetrics() {
    if (!performance.getEntriesByType) return;
    
    const paints = performance.getEntriesByType('paint');
    
    this.metrics.paint = {};
    paints.forEach(paint => {
      this.metrics.paint[paint.name] = paint.startTime;
    });
  }

  // 观察布局偏移
  observeLayoutShift() {
    if (!window.PerformanceObserver) return;
    
    try {
      const observer = new PerformanceObserver(list => {
        for (const entry of list.getEntries()) {
          if (!entry.hadRecentInput) {
            this.metrics.layoutShift.push({
              value: entry.value,
              time: entry.startTime,
            });
          }
        }
      });
      
      observer.observe({ type: 'layout-shift', buffered: true });
      this.observers.set('layout-shift', observer);
    } catch (error) {
      console.error('Failed to observe layout shift:', error);
    }
  }

  // 观察首次输入延迟
  observeFirstInputDelay() {
    if (!window.PerformanceObserver) return;
    
    try {
      const observer = new PerformanceObserver(list => {
        for (const entry of list.getEntries()) {
          this.metrics.firstInputDelay = {
            value: entry.processingStart - entry.startTime,
            time: entry.startTime,
          };
        }
      });
      
      observer.observe({ type: 'first-input', buffered: true });
      this.observers.set('first-input', observer);
    } catch (error) {
      console.error('Failed to observe first input delay:', error);
    }
  }

  // 观察最大内容绘制
  observeLargestContentfulPaint() {
    if (!window.PerformanceObserver) return;
    
    try {
      const observer = new PerformanceObserver(list => {
        const entries = list.getEntries();
        const lastEntry = entries[entries.length - 1];
        
        this.metrics.largestContentfulPaint = {
          value: lastEntry.startTime,
          element: lastEntry.element ? lastEntry.element.tagName : 'unknown',
          url: lastEntry.url || '',
          time: lastEntry.startTime,
        };
      });
      
      observer.observe({ type: 'largest-contentful-paint', buffered: true });
      this.observers.set('largest-contentful-paint', observer);
    } catch (error) {
      console.error('Failed to observe largest contentful paint:', error);
    }
  }

  // 添加自定义指标
  addCustomMetric(name, value, tags = {}) {
    this.metrics.customMetrics.set(name, {
      value,
      tags,
      timestamp: Date.now(),
    });
  }

  // 计算Web Vitals
  getWebVitals() {
    const vitals = {};
    
    // LCP (Largest Contentful Paint)
    if (this.metrics.largestContentfulPaint) {
      vitals.lcp = this.metrics.largestContentfulPaint.value;
    }
    
    // FID (First Input Delay)
    if (this.metrics.firstInputDelay) {
      vitals.fid = this.metrics.firstInputDelay.value;
    }
    
    // CLS (Cumulative Layout Shift)
    if (this.metrics.layoutShift.length > 0) {
      vitals.cls = this.metrics.layoutShift.reduce((sum, shift) => sum + shift.value, 0);
    }
    
    // FCP (First Contentful Paint)
    if (this.metrics.paint['first-contentful-paint']) {
      vitals.fcp = this.metrics.paint['first-contentful-paint'];
    }
    
    // TTFB (Time to First Byte)
    if (this.metrics.navigation.ttfb) {
      vitals.ttfb = this.metrics.navigation.ttfb;
    }
    
    return vitals;
  }

  // 获取资源类型
  getResourceType(url) {
    const extension = url.split('.').pop().split('?')[0].toLowerCase();
    
    const typeMap = {
      'js': 'script',
      'css': 'stylesheet',
      'png': 'image',
      'jpg': 'image',
      'jpeg': 'image',
      'gif': 'image',
      'svg': 'image',
      'webp': 'image',
      'woff': 'font',
      'woff2': 'font',
      'ttf': 'font',
      'eot': 'font',
    };
    
    return typeMap[extension] || 'other';
  }

  // 获取所有指标
  getAllMetrics() {
    return {
      ...this.metrics,
      customMetrics: Array.from(this.metrics.customMetrics.entries()).map(([name, data]) => ({
        name,
        ...data,
      })),
      webVitals: this.getWebVitals(),
    };
  }

  // 发送指标到监控系统
  async sendMetrics(endpoint) {
    const metrics = this.getAllMetrics();
    
    try {
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          url: window.location.href,
          userAgent: navigator.userAgent,
          timestamp: Date.now(),
          metrics,
        }),
      });
      
      if (!response.ok) {
        throw new Error(`Failed to send metrics: ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      console.error('Error sending metrics:', error);
      throw error;
    }
  }
}

// 导出单例
export const performanceMetrics = new PerformanceMetrics();
```

### 13.2.2 跨应用性能追踪

```javascript
// 示例：跨应用性能追踪
class CrossAppPerformanceTracker {
  constructor() {
    this.appMetrics = new Map(); // appName -> metrics
    this.transactionMap = new Map(); // transactionId -> transaction
    this.activeTransactions = new Map(); // appName -> Set(transactionId)
    this.observers = new Map();
  }

  // 注册应用
  registerApp(appName, config = {}) {
    if (this.appMetrics.has(appName)) {
      return this.appMetrics.get(appName);
    }
    
    const appConfig = {
      name: appName,
      endpoints: config.endpoints || [],
      criticalResources: config.criticalResources || [],
      performanceThresholds: config.performanceThresholds || {},
      ...config,
    };
    
    this.appMetrics.set(appName, {
      config: appConfig,
      metrics: {
        loadTime: [],
        renderTime: [],
        apiCalls: [],
        resourceLoadTime: [],
        userInteractions: [],
        errors: [],
      },
      isActive: false,
      startTime: null,
    });
    
    console.log(`App registered for performance tracking: ${appName}`);
    return appConfig;
  }

  // 开始应用追踪
  startAppTracking(appName) {
    const appInfo = this.appMetrics.get(appName);
    if (!appInfo) {
      throw new Error(`App ${appName} not registered`);
    }
    
    if (appInfo.isActive) {
      return;
    }
    
    appInfo.isActive = true;
    appInfo.startTime = performance.now();
    
    // 开始收集应用特定指标
    this.startAppMetricsCollection(appName);
    
    // 开始跨应用追踪
    this.startCrossAppTracking(appName);
    
    console.log(`Started tracking for app: ${appName}`);
  }

  // 停止应用追踪
  stopAppTracking(appName) {
    const appInfo = this.appMetrics.get(appName);
    if (!appInfo || !appInfo.isActive) {
      return;
    }
    
    appInfo.isActive = false;
    
    // 停止收集指标
    this.stopAppMetricsCollection(appName);
    
    // 计算总加载时间
    const loadTime = performance.now() - appInfo.startTime;
    appInfo.metrics.loadTime.push({
      value: loadTime,
      timestamp: Date.now(),
    });
    
    console.log(`Stopped tracking for app: ${appName}, total load time: ${loadTime}ms`);
  }

  // 开始应用指标收集
  startAppMetricsCollection(appName) {
    const appInfo = this.appMetrics.get(appName);
    
    // 观察资源加载
    if (window.PerformanceObserver) {
      try {
        const resourceObserver = new PerformanceObserver(list => {
          for (const entry of list.getEntries()) {
            // 只记录应用相关的资源
            if (this.isAppResource(appName, entry.name)) {
              appInfo.metrics.resourceLoadTime.push({
                name: entry.name,
                duration: entry.duration,
                size: entry.transferSize || 0,
                timestamp: Date.now(),
              });
            }
          }
        });
        
        resourceObserver.observe({ type: 'resource', buffered: true });
        this.observers.set(`${appName}-resource`, resourceObserver);
      } catch (error) {
        console.error(`Failed to observe resources for ${appName}:`, error);
      }
    }
    
    // 拦截API调用
    this.interceptApiCalls(appName);
    
    // 监听用户交互
    this.trackUserInteractions(appName);
  }

  // 停止应用指标收集
  stopAppMetricsCollection(appName) {
    const observer = this.observers.get(`${appName}-resource`);
    if (observer) {
      observer.disconnect();
      this.observers.delete(`${appName}-resource`);
    }
    
    // 恢复原始API调用
    this.restoreApiCalls(appName);
    
    // 停止用户交互追踪
    this.stopUserInteractionTracking(appName);
  }

  // 开始跨应用追踪
  startCrossAppTracking(appName) {
    // 监听应用间通信
    this.trackAppCommunication(appName);
    
    // 监听路由变化
    this.trackRouteChanges(appName);
  }

  // 拦截API调用
  interceptApiCalls(appName) {
    const appInfo = this.appMetrics.get(appName);
    const originalFetch = window.fetch;
    
    appInfo.originalFetch = originalFetch;
    
    window.fetch = async (...args) => {
      const startTime = performance.now();
      const url = args[0];
      
      try {
        const response = await originalFetch(...args);
        const endTime = performance.now();
        
        // 记录成功的API调用
        appInfo.metrics.apiCalls.push({
          url: typeof url === 'string' ? url : url.url,
          method: args[1]?.method || 'GET',
          status: response.status,
          duration: endTime - startTime,
          timestamp: Date.now(),
        });
        
        return response;
      } catch (error) {
        const endTime = performance.now();
        
        // 记录失败的API调用
        appInfo.metrics.apiCalls.push({
          url: typeof url === 'string' ? url : url.url,
          method: args[1]?.method || 'GET',
          status: 0,
          duration: endTime - startTime,
          error: error.message,
          timestamp: Date.now(),
        });
        
        throw error;
      }
    };
  }

  // 恢复API调用
  restoreApiCalls(appName) {
    const appInfo = this.appMetrics.get(appName);
    if (appInfo.originalFetch) {
      window.fetch = appInfo.originalFetch;
      delete appInfo.originalFetch;
    }
  }

  // 追踪用户交互
  trackUserInteractions(appName) {
    const appInfo = this.appMetrics.get(appName);
    const interactionHandler = (event) => {
      const startTime = performance.now();
      
      // 使用requestAnimationFrame来测量交互后的响应时间
      requestAnimationFrame(() => {
        const endTime = performance.now();
        
        appInfo.metrics.userInteractions.push({
          type: event.type,
          target: event.target.tagName,
          duration: endTime - startTime,
          timestamp: Date.now(),
        });
      });
    };
    
    appInfo.interactionHandler = interactionHandler;
    
    // 监听常见交互事件
    ['click', 'touchstart', 'keydown'].forEach(eventType => {
      document.addEventListener(eventType, interactionHandler, { passive: true });
    });
  }

  // 停止用户交互追踪
  stopUserInteractionTracking(appName) {
    const appInfo = this.appMetrics.get(appName);
    
    if (appInfo.interactionHandler) {
      ['click', 'touchstart', 'keydown'].forEach(eventType => {
        document.removeEventListener(eventType, appInfo.interactionHandler);
      });
      
      delete appInfo.interactionHandler;
    }
  }

  // 追踪应用间通信
  trackAppCommunication(appName) {
    // 监听自定义事件（应用间通信）
    const communicationHandler = (event) => {
      if (event.detail && event.detail.source && event.detail.target) {
        const sourceApp = event.detail.source;
        const targetApp = event.detail.target;
        
        // 记录通信事件
        this.recordCommunication({
          source: sourceApp,
          target: targetApp,
          type: event.type,
          data: event.detail.data,
          timestamp: Date.now(),
        });
      }
    };
    
    document.addEventListener('micro-app-communication', communicationHandler);
    this.observers.set(`${appName}-communication`, {
      disconnect: () => {
        document.removeEventListener('micro-app-communication', communicationHandler);
      }
    });
  }

  // 追踪路由变化
  trackRouteChanges(appName) {
    const routeChangeHandler = (event) => {
      if (event.detail && event.detail.app === appName) {
        const startTime = performance.now();
        
        // 记录路由变化
        this.recordRouteChange({
          app: appName,
          from: event.detail.from,
          to: event.detail.to,
          timestamp: Date.now(),
        });
        
        // 监听路由变化完成
        const routeCompleteHandler = () => {
          const endTime = performance.now();
          
          // 记录路由变化时间
          this.recordRouteChangeComplete({
            app: appName,
            from: event.detail.from,
            to: event.detail.to,
            duration: endTime - startTime,
            timestamp: Date.now(),
          });
          
          document.removeEventListener('micro-app-route-complete', routeCompleteHandler);
        };
        
        document.addEventListener('micro-app-route-complete', routeCompleteHandler);
      }
    };
    
    document.addEventListener('micro-app-route-change', routeChangeHandler);
    this.observers.set(`${appName}-route`, {
      disconnect: () => {
        document.removeEventListener('micro-app-route-change', routeChangeHandler);
      }
    });
  }

  // 开始事务追踪
  startTransaction(transactionId, appName, operation) {
    const transaction = {
      id: transactionId,
      appName,
      operation,
      startTime: performance.now(),
      endTime: null,
      duration: null,
      status: 'active',
      steps: [],
    };
    
    this.transactionMap.set(transactionId, transaction);
    
    if (!this.activeTransactions.has(appName)) {
      this.activeTransactions.set(appName, new Set());
    }
    
    this.activeTransactions.get(appName).add(transactionId);
    
    return transaction;
  }

  // 完成事务步骤
  completeTransactionStep(transactionId, stepName, stepData = {}) {
    const transaction = this.transactionMap.get(transactionId);
    if (!transaction) {
      return;
    }
    
    transaction.steps.push({
      name: stepName,
      timestamp: Date.now(),
      ...stepData,
    });
  }

  // 完成事务
  completeTransaction(transactionId, status = 'success') {
    const transaction = this.transactionMap.get(transactionId);
    if (!transaction) {
      return;
    }
    
    transaction.endTime = performance.now();
    transaction.duration = transaction.endTime - transaction.startTime;
    transaction.status = status;
    
    // 从活动事务中移除
    if (this.activeTransactions.has(transaction.appName)) {
      this.activeTransactions.get(transaction.appName).delete(transactionId);
    }
    
    return transaction;
  }

  // 记录通信事件
  recordCommunication(data) {
    // 这里可以发送到监控系统
    console.log('App communication:', data);
  }

  // 记录路由变化
  recordRouteChange(data) {
    // 这里可以发送到监控系统
    console.log('Route change:', data);
  }

  // 记录路由变化完成
  recordRouteChangeComplete(data) {
    // 这里可以发送到监控系统
    console.log('Route change complete:', data);
  }

  // 判断资源是否属于应用
  isAppResource(appName, resourceUrl) {
    const appInfo = this.appMetrics.get(appName);
    if (!appInfo) return false;
    
    // 检查是否在应用的端点列表中
    const endpoints = appInfo.config.endpoints;
    if (endpoints.some(endpoint => resourceUrl.includes(endpoint))) {
      return true;
    }
    
    // 检查是否是关键资源
    const criticalResources = appInfo.config.criticalResources;
    if (criticalResources.some(resource => resourceUrl.includes(resource))) {
      return true;
    }
    
    return false;
  }

  // 获取应用指标
  getAppMetrics(appName) {
    const appInfo = this.appMetrics.get(appName);
    if (!appInfo) return null;
    
    return {
      config: appInfo.config,
      metrics: appInfo.metrics,
      isActive: appInfo.isActive,
      startTime: appInfo.startTime,
    };
  }

  // 获取所有应用指标
  getAllAppMetrics() {
    const result = {};
    
    for (const [appName, appInfo] of this.appMetrics) {
      result[appName] = {
        config: appInfo.config,
        metrics: appInfo.metrics,
        isActive: appInfo.isActive,
        startTime: appInfo.startTime,
      };
    }
    
    return result;
  }

  // 获取事务信息
  getTransaction(transactionId) {
    return this.transactionMap.get(transactionId);
  }

  // 获取应用的活动事务
  getActiveTransactions(appName) {
    if (!this.activeTransactions.has(appName)) {
      return [];
    }
    
    const transactionIds = this.activeTransactions.get(appName);
    return Array.from(transactionIds).map(id => this.transactionMap.get(id));
  }

  // 获取所有活动事务
  getAllActiveTransactions() {
    const result = {};
    
    for (const [appName, transactionIds] of this.activeTransactions) {
      result[appName] = Array.from(transactionIds).map(id => this.transactionMap.get(id));
    }
    
    return result;
  }
}

// 导出单例
export const crossAppPerformanceTracker = new CrossAppPerformanceTracker();
```

## 13.3 错误监控

### 13.3.1 错误捕获与分类

```javascript
// 示例：错误监控与分类
class ErrorMonitor {
  constructor() {
    this.errorTypes = {
      JAVASCRIPT: 'javascript',
      NETWORK: 'network',
      RESOURCE: 'resource',
      PROMISE: 'promise',
      CUSTOM: 'custom',
    };
    
    this.errorSeverity = {
      LOW: 'low',
      MEDIUM: 'medium',
      HIGH: 'high',
      CRITICAL: 'critical',
    };
    
    this.errors = [];
    this.errorCounts = new Map();
    this.errorSubscribers = new Map();
    this.isMonitoring = false;
    this.errorFilters = [];
  }

  // 开始错误监控
  startMonitoring() {
    if (this.isMonitoring) return;
    
    this.isMonitoring = true;
    
    // 监听JavaScript错误
    window.addEventListener('error', this.handleJavaScriptError.bind(this));
    
    // 监听未捕获的Promise拒绝
    window.addEventListener('unhandledrejection', this.handlePromiseRejection.bind(this));
    
    // 拦截网络请求
    this.interceptNetworkRequests();
    
    // 监听资源加载错误
    this.monitorResourceErrors();
    
    console.log('Error monitoring started');
  }

  // 停止错误监控
  stopMonitoring() {
    if (!this.isMonitoring) return;
    
    this.isMonitoring = false;
    
    // 移除事件监听器
    window.removeEventListener('error', this.handleJavaScriptError.bind(this));
    window.removeEventListener('unhandledrejection', this.handlePromiseRejection.bind(this));
    
    // 恢复网络请求
    this.restoreNetworkRequests();
    
    // 停止资源错误监控
    this.stopResourceErrorMonitoring();
    
    console.log('Error monitoring stopped');
  }

  // 处理JavaScript错误
  handleJavaScriptError(event) {
    const error = {
      type: this.errorTypes.JAVASCRIPT,
      message: event.message,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
      stack: event.error ? event.error.stack : null,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      url: window.location.href,
    };
    
    // 确定错误严重程度
    error.severity = this.determineErrorSeverity(error);
    
    // 应用错误过滤器
    if (!this.shouldReportError(error)) {
      return;
    }
    
    // 记录错误
    this.recordError(error);
  }

  // 处理Promise拒绝
  handlePromiseRejection(event) {
    const error = {
      type: this.errorTypes.PROMISE,
      message: event.reason ? (event.reason.message || String(event.reason)) : 'Unknown promise rejection',
      stack: event.reason && event.reason.stack ? event.reason.stack : null,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      url: window.location.href,
    };
    
    // 确定错误严重程度
    error.severity = this.determineErrorSeverity(error);
    
    // 应用错误过滤器
    if (!this.shouldReportError(error)) {
      return;
    }
    
    // 记录错误
    this.recordError(error);
    
    // 防止默认控制台输出
    event.preventDefault();
  }

  // 拦截网络请求
  interceptNetworkRequests() {
    const originalFetch = window.fetch;
    
    this.originalFetch = originalFetch;
    
    window.fetch = async (...args) => {
      const startTime = performance.now();
      const url = args[0];
      
      try {
        const response = await originalFetch(...args);
        
        // 检查HTTP错误状态码
        if (!response.ok) {
          const error = {
            type: this.errorTypes.NETWORK,
            message: `HTTP error: ${response.status} ${response.statusText}`,
            url: typeof url === 'string' ? url : url.url,
            method: args[1]?.method || 'GET',
            status: response.status,
            statusText: response.statusText,
            duration: performance.now() - startTime,
            timestamp: Date.now(),
            userAgent: navigator.userAgent,
            pageUrl: window.location.href,
          };
          
          // 确定错误严重程度
          error.severity = this.determineNetworkErrorSeverity(response.status);
          
          // 应用错误过滤器
          if (this.shouldReportError(error)) {
            this.recordError(error);
          }
        }
        
        return response;
      } catch (error) {
        const networkError = {
          type: this.errorTypes.NETWORK,
          message: error.message,
          url: typeof url === 'string' ? url : url.url,
          method: args[1]?.method || 'GET',
          duration: performance.now() - startTime,
          timestamp: Date.now(),
          userAgent: navigator.userAgent,
          pageUrl: window.location.href,
        };
        
        // 确定错误严重程度
        networkError.severity = this.errorSeverity.HIGH;
        
        // 应用错误过滤器
        if (this.shouldReportError(networkError)) {
          this.recordError(networkError);
        }
        
        throw error;
      }
    };
  }

  // 恢复网络请求
  restoreNetworkRequests() {
    if (this.originalFetch) {
      window.fetch = this.originalFetch;
      delete this.originalFetch;
    }
  }

  // 监控资源加载错误
  monitorResourceErrors() {
    const resourceErrorHandler = (event) => {
      const error = {
        type: this.errorTypes.RESOURCE,
        message: `Resource loading error: ${event.target.src || event.target.href}`,
        element: event.target.tagName,
        source: event.target.src || event.target.href,
        timestamp: Date.now(),
        userAgent: navigator.userAgent,
        pageUrl: window.location.href,
      };
      
      // 确定错误严重程度
      error.severity = this.determineResourceErrorSeverity(event.target.tagName);
      
      // 应用错误过滤器
      if (this.shouldReportError(error)) {
        this.recordError(error);
      }
    };
    
    this.resourceErrorHandler = resourceErrorHandler;
    
    // 监听资源加载错误
    window.addEventListener('error', resourceErrorHandler, true);
  }

  // 停止资源错误监控
  stopResourceErrorMonitoring() {
    if (this.resourceErrorHandler) {
      window.removeEventListener('error', this.resourceErrorHandler, true);
      delete this.resourceErrorHandler;
    }
  }

  // 记录自定义错误
  recordCustomError(message, severity = this.errorSeverity.MEDIUM, context = {}) {
    const error = {
      type: this.errorTypes.CUSTOM,
      message,
      severity,
      context,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      url: window.location.href,
    };
    
    // 应用错误过滤器
    if (this.shouldReportError(error)) {
      this.recordError(error);
    }
    
    return error;
  }

  // 记录错误
  recordError(error) {
    // 添加唯一ID
    error.id = this.generateErrorId(error);
    
    // 添加到错误列表
    this.errors.push(error);
    
    // 限制错误列表大小
    if (this.errors.length > 1000) {
      this.errors.splice(0, this.errors.length - 1000);
    }
    
    // 更新错误计数
    const errorKey = this.getErrorKey(error);
    this.errorCounts.set(errorKey, (this.errorCounts.get(errorKey) || 0) + 1);
    
    // 通知订阅者
    this.notifySubscribers(error);
    
    // 发送到监控系统
    this.sendErrorToMonitoring(error);
  }

  // 确定错误严重程度
  determineErrorSeverity(error) {
    // 根据错误消息和类型确定严重程度
    if (error.type === this.errorTypes.JAVASCRIPT) {
      // JavaScript错误通常是高严重性
      return this.errorSeverity.HIGH;
    } else if (error.type === this.errorTypes.PROMISE) {
      // Promise拒绝根据消息确定严重性
      if (error.message.includes('Network') || error.message.includes('fetch')) {
        return this.errorSeverity.HIGH;
      }
      return this.errorSeverity.MEDIUM;
    }
    
    return this.errorSeverity.MEDIUM;
  }

  // 确定网络错误严重程度
  determineNetworkErrorSeverity(status) {
    if (status >= 500) {
      return this.errorSeverity.HIGH;
    } else if (status >= 400) {
      return this.errorSeverity.MEDIUM;
    }
    
    return this.errorSeverity.LOW;
  }

  // 确定资源错误严重程度
  determineResourceErrorSeverity(tagName) {
    if (tagName === 'SCRIPT') {
      return this.errorSeverity.HIGH;
    } else if (tagName === 'LINK' || tagName === 'IMG') {
      return this.errorSeverity.MEDIUM;
    }
    
    return this.errorSeverity.LOW;
  }

  // 应用错误过滤器
  shouldReportError(error) {
    for (const filter of this.errorFilters) {
      if (!filter(error)) {
        return false;
      }
    }
    
    return true;
  }

  // 添加错误过滤器
  addErrorFilter(filter) {
    this.errorFilters.push(filter);
  }

  // 移除错误过滤器
  removeErrorFilter(filter) {
    const index = this.errorFilters.indexOf(filter);
    if (index > -1) {
      this.errorFilters.splice(index, 1);
    }
  }

  // 订阅错误通知
  subscribe(callback) {
    const id = `subscriber-${Date.now()}`;
    this.errorSubscribers.set(id, callback);
    
    // 返回取消订阅函数
    return () => {
      this.errorSubscribers.delete(id);
    };
  }

  // 通知订阅者
  notifySubscribers(error) {
    for (const [id, callback] of this.errorSubscribers) {
      try {
        callback(error);
      } catch (e) {
        console.error(`Error in subscriber ${id}:`, e);
      }
    }
  }

  // 发送错误到监控系统
  async sendErrorToMonitoring(error) {
    try {
      // 这里应该发送到实际的监控系统
      console.log('Sending error to monitoring system:', error);
      
      // 示例：发送到监控API
      // const response = await fetch('/api/errors', {
      //   method: 'POST',
      //   headers: {
      //     'Content-Type': 'application/json',
      //   },
      //   body: JSON.stringify(error),
      // });
      
      // if (!response.ok) {
      //   throw new Error(`Failed to send error: ${response.status}`);
      // }
    } catch (e) {
      console.error('Failed to send error to monitoring system:', e);
    }
  }

  // 生成错误ID
  generateErrorId(error) {
    // 基于错误类型、消息和位置生成唯一ID
    const key = `${error.type}:${error.message}:${error.filename || ''}:${error.lineno || 0}:${error.colno || 0}`;
    return this.hashString(key);
  }

  // 获取错误键
  getErrorKey(error) {
    // 用于错误计数的键
    if (error.type === this.errorTypes.JAVASCRIPT) {
      return `${error.type}:${error.message}:${error.filename || ''}:${error.lineno || 0}`;
    } else if (error.type === this.errorTypes.NETWORK) {
      return `${error.type}:${error.url}:${error.status || 0}`;
    } else if (error.type === this.errorTypes.RESOURCE) {
      return `${error.type}:${error.element}:${error.source || ''}`;
    } else {
      return `${error.type}:${error.message}`;
    }
  }

  // 哈希字符串
  hashString(str) {
    let hash = 0;
    if (str.length === 0) return hash.toString();
    
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // 转换为32位整数
    }
    
    return Math.abs(hash).toString();
  }

  // 获取错误列表
  getErrors(options = {}) {
    let errors = [...this.errors];
    
    // 应用过滤器
    if (options.type) {
      errors = errors.filter(error => error.type === options.type);
    }
    
    if (options.severity) {
      errors = errors.filter(error => error.severity === options.severity);
    }
    
    if (options.since) {
      errors = errors.filter(error => error.timestamp >= options.since);
    }
    
    if (options.limit) {
      errors = errors.slice(-options.limit);
    }
    
    // 按时间戳降序排序
    errors.sort((a, b) => b.timestamp - a.timestamp);
    
    return errors;
  }

  // 获取错误统计
  getErrorStats() {
    const stats = {
      total: this.errors.length,
      byType: {},
      bySeverity: {},
      topErrors: [],
    };
    
    // 按类型统计
    for (const error of this.errors) {
      stats.byType[error.type] = (stats.byType[error.type] || 0) + 1;
    }
    
    // 按严重程度统计
    for (const error of this.errors) {
      stats.bySeverity[error.severity] = (stats.bySeverity[error.severity] || 0) + 1;
    }
    
    // 获取最常见的错误
    const errorCounts = Array.from(this.errorCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10);
    
    stats.topErrors = errorCounts.map(([key, count]) => {
      const [type, ...rest] = key.split(':');
      const message = rest.join(':');
      
      return {
        type,
        message,
        count,
      };
    });
    
    return stats;
  }

  // 清除错误记录
  clearErrors() {
    this.errors = [];
    this.errorCounts.clear();
  }
}

// 导出单例
export const errorMonitor = new ErrorMonitor();
```

## 13.4 用户行为监控

### 13.4.1 用户交互追踪

```javascript
// 示例：用户交互追踪
class UserInteractionTracker {
  constructor() {
    this.interactions = [];
    this.sessionId = this.generateSessionId();
    this.userId = null;
    this.isTracking = false;
    this.observers = new Map();
    this.heatmapData = new Map(); // elementId -> { clicks, hovers, scrolls }
    this.conversionEvents = new Map(); // eventName -> count
  }

  // 开始追踪
  startTracking(userId = null) {
    if (this.isTracking) return;
    
    this.isTracking = true;
    this.userId = userId;
    
    // 追踪页面加载
    this.trackPageLoad();
    
    // 追踪点击事件
    this.trackClicks();
    
    // 追踪表单提交
    this.trackFormSubmissions();
    
    // 追踪滚动事件
    this.trackScrolling();
    
    // 追踪鼠标移动（用于热图）
    this.trackMouseMovement();
    
    // 追踪页面可见性变化
    this.trackPageVisibility();
    
    // 追踪页面卸载
    this.trackPageUnload();
    
    console.log('User interaction tracking started');
  }

  // 停止追踪
  stopTracking() {
    if (!this.isTracking) return;
    
    this.isTracking = false;
    
    // 断开所有观察者
    for (const [name, observer] of this.observers) {
      if (observer.disconnect) {
        observer.disconnect();
      } else if (typeof observer === 'function') {
        document.removeEventListener(name, observer);
      }
    }
    
    this.observers.clear();
    
    console.log('User interaction tracking stopped');
  }

  // 追踪页面加载
  trackPageLoad() {
    const pageLoad = {
      type: 'page-load',
      url: window.location.href,
      referrer: document.referrer,
      userAgent: navigator.userAgent,
      timestamp: Date.now(),
      sessionId: this.sessionId,
      userId: this.userId,
    };
    
    // 添加性能指标
    if (performance.timing) {
      const timing = performance.timing;
      pageLoad.loadTime = timing.loadEventEnd - timing.navigationStart;
      pageLoad.domReadyTime = timing.domContentLoadedEventEnd - timing.navigationStart;
    }
    
    this.recordInteraction(pageLoad);
  }

  // 追踪点击事件
  trackClicks() {
    const clickHandler = (event) => {
      const target = event.target;
      const elementPath = this.getElementPath(target);
      
      const click = {
        type: 'click',
        element: {
          tagName: target.tagName,
          id: target.id,
          className: target.className,
          text: target.textContent ? target.textContent.substring(0, 50) : '',
          path: elementPath,
        },
        position: {
          x: event.clientX,
          y: event.clientY,
        },
        timestamp: Date.now(),
        sessionId: this.sessionId,
        userId: this.userId,
        url: window.location.href,
      };
      
      this.recordInteraction(click);
      
      // 更新热图数据
      this.updateHeatmapData(target, 'click', event.clientX, event.clientY);
    };
    
    document.addEventListener('click', clickHandler, true);
    this.observers.set('click', clickHandler);
  }

  // 追踪表单提交
  trackFormSubmissions() {
    const submitHandler = (event) => {
      const form = event.target;
      const formData = new FormData(form);
      const formFields = [];
      
      // 收集表单字段信息（不包含敏感数据）
      for (const [name, value] of formData.entries()) {
        // 跳过敏感字段
        if (this.isSensitiveField(name)) {
          continue;
        }
        
        formFields.push({
          name,
          type: form.elements[name]?.type || 'text',
          value: typeof value === 'string' ? value.substring(0, 100) : value,
        });
      }
      
      const submission = {
        type: 'form-submit',
        form: {
          id: form.id,
          className: form.className,
          action: form.action,
          method: form.method,
          fields: formFields,
        },
        timestamp: Date.now(),
        sessionId: this.sessionId,
        userId: this.userId,
        url: window.location.href,
      };
      
      this.recordInteraction(submission);
    };
    
    document.addEventListener('submit', submitHandler, true);
    this.observers.set('submit', submitHandler);
  }

  // 追踪滚动事件
  trackScrolling() {
    let scrollTimeout;
    
    const scrollHandler = () => {
      // 使用防抖来避免过多的事件
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        const scroll = {
          type: 'scroll',
          position: {
            x: window.scrollX,
            y: window.scrollY,
          },
          viewport: {
            width: window.innerWidth,
            height: window.innerHeight,
          },
          document: {
            width: document.documentElement.scrollWidth,
            height: document.documentElement.scrollHeight,
          },
          scrollPercent: Math.round(
            (window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100
          ),
          timestamp: Date.now(),
          sessionId: this.sessionId,
          userId: this.userId,
          url: window.location.href,
        };
        
        this.recordInteraction(scroll);
      }, 100);
    };
    
    window.addEventListener('scroll', scrollHandler, { passive: true });
    this.observers.set('scroll', scrollHandler);
  }

  // 追踪鼠标移动（用于热图）
  trackMouseMovement() {
    let mouseTimeout;
    let lastPosition = null;
    
    const mouseMoveHandler = (event) => {
      // 使用防抖来避免过多的事件
      clearTimeout(mouseTimeout);
      mouseTimeout = setTimeout(() => {
        // 只记录移动距离超过一定阈值的位置
        if (lastPosition) {
          const distance = Math.sqrt(
            Math.pow(event.clientX - lastPosition.x, 2) + 
            Math.pow(event.clientY - lastPosition.y, 2)
          );
          
          if (distance < 50) { // 移动距离小于50像素则不记录
            return;
          }
        }
        
        lastPosition = { x: event.clientX, y: event.clientY };
        
        // 更新热图数据
        const target = document.elementFromPoint(event.clientX, event.clientY);
        if (target) {
          this.updateHeatmapData(target, 'hover', event.clientX, event.clientY);
        }
      }, 100);
    };
    
    document.addEventListener('mousemove', mouseMoveHandler, { passive: true });
    this.observers.set('mousemove', mouseMoveHandler);
  }

  // 追踪页面可见性变化
  trackPageVisibility() {
    const visibilityHandler = () => {
      const visibility = {
        type: 'visibility-change',
        isVisible: !document.hidden,
        timestamp: Date.now(),
        sessionId: this.sessionId,
        userId: this.userId,
        url: window.location.href,
      };
      
      this.recordInteraction(visibility);
    };
    
    document.addEventListener('visibilitychange', visibilityHandler);
    this.observers.set('visibilitychange', visibilityHandler);
  }

  // 追踪页面卸载
  trackPageUnload() {
    const unloadHandler = () => {
      const unload = {
        type: 'page-unload',
        timestamp: Date.now(),
        sessionId: this.sessionId,
        userId: this.userId,
        url: window.location.href,
      };
      
      // 使用sendBeacon来确保数据发送
      this.sendDataUsingBeacon(unload);
    };
    
    window.addEventListener('beforeunload', unloadHandler);
    this.observers.set('beforeunload', unloadHandler);
  }

  // 追踪自定义事件
  trackCustomEvent(eventName, properties = {}) {
    const customEvent = {
      type: 'custom-event',
      eventName,
      properties,
      timestamp: Date.now(),
      sessionId: this.sessionId,
      userId: this.userId,
      url: window.location.href,
    };
    
    this.recordInteraction(customEvent);
    
    // 更新转化事件计数
    this.conversionEvents.set(eventName, (this.conversionEvents.get(eventName) || 0) + 1);
  }

  // 记录交互
  recordInteraction(interaction) {
    this.interactions.push(interaction);
    
    // 限制交互记录数量
    if (this.interactions.length > 1000) {
      this.interactions.splice(0, this.interactions.length - 1000);
    }
    
    // 发送到监控系统
    this.sendInteractionToMonitoring(interaction);
  }

  // 更新热图数据
  updateHeatmapData(element, action, x, y) {
    const elementId = this.getElementId(element);
    
    if (!this.heatmapData.has(elementId)) {
      this.heatmapData.set(elementId, {
        element: {
          tagName: element.tagName,
          id: element.id,
          className: element.className,
          selector: this.getElementSelector(element),
        },
        clicks: [],
        hovers: [],
        scrolls: [],
      });
    }
    
    const data = this.heatmapData.get(elementId);
    
    if (action === 'click') {
      data.clicks.push({ x, y, timestamp: Date.now() });
    } else if (action === 'hover') {
      data.hovers.push({ x, y, timestamp: Date.now() });
    } else if (action === 'scroll') {
      data.scrolls.push({ x, y, timestamp: Date.now() });
    }
  }

  // 获取元素ID
  getElementId(element) {
    if (element.id) {
      return `#${element.id}`;
    }
    
    if (element.className) {
      return `.${element.className.split(' ').join('.')}`;
    }
    
    return element.tagName.toLowerCase();
  }

  // 获取元素选择器
  getElementSelector(element) {
    if (element.id) {
      return `#${element.id}`;
    }
    
    let selector = element.tagName.toLowerCase();
    
    if (element.className) {
      selector += `.${element.className.split(' ').join('.')}`;
    }
    
    return selector;
  }

  // 获取元素路径
  getElementPath(element) {
    const path = [];
    let current = element;
    
    while (current && current !== document.body) {
      let selector = current.tagName.toLowerCase();
      
      if (current.id) {
        selector += `#${current.id}`;
      } else if (current.className) {
        selector += `.${current.className.split(' ').join('.')}`;
      }
      
      path.unshift(selector);
      current = current.parentElement;
    }
    
    return path.join(' > ');
  }

  // 判断是否为敏感字段
  isSensitiveField(fieldName) {
    const sensitivePatterns = [
      /password/i,
      /passwd/i,
      /secret/i,
      /token/i,
      /key/i,
      /credit/i,
      /card/i,
      /ssn/i,
      /social/i,
    ];
    
    return sensitivePatterns.some(pattern => pattern.test(fieldName));
  }

  // 生成会话ID
  generateSessionId() {
    return 'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  }

  // 发送交互数据到监控系统
  async sendInteractionToMonitoring(interaction) {
    try {
      // 这里应该发送到实际的监控系统
      console.log('Sending interaction to monitoring system:', interaction);
      
      // 示例：发送到监控API
      // const response = await fetch('/api/interactions', {
      //   method: 'POST',
      //   headers: {
      //     'Content-Type': 'application/json',
      //   },
      //   body: JSON.stringify(interaction),
      // });
      
      // if (!response.ok) {
      //   throw new Error(`Failed to send interaction: ${response.status}`);
      // }
    } catch (e) {
      console.error('Failed to send interaction to monitoring system:', e);
    }
  }

  // 使用sendBeacon发送数据
  sendDataUsingBeacon(data) {
    if (navigator.sendBeacon) {
      navigator.sendBeacon('/api/interactions', JSON.stringify(data));
    } else {
      // 回退到常规fetch
      this.sendInteractionToMonitoring(data);
    }
  }

  // 获取交互记录
  getInteractions(options = {}) {
    let interactions = [...this.interactions];
    
    // 应用过滤器
    if (options.type) {
      interactions = interactions.filter(interaction => interaction.type === options.type);
    }
    
    if (options.since) {
      interactions = interactions.filter(interaction => interaction.timestamp >= options.since);
    }
    
    if (options.limit) {
      interactions = interactions.slice(-options.limit);
    }
    
    // 按时间戳排序
    interactions.sort((a, b) => a.timestamp - b.timestamp);
    
    return interactions;
  }

  // 获取热图数据
  getHeatmapData() {
    return Array.from(this.heatmapData.values());
  }

  // 获取转化事件数据
  getConversionEvents() {
    return Array.from(this.conversionEvents.entries()).map(([eventName, count]) => ({
      eventName,
      count,
    }));
  }

  // 获取会话统计
  getSessionStats() {
    if (this.interactions.length === 0) {
      return null;
    }
    
    const firstInteraction = this.interactions[0];
    const lastInteraction = this.interactions[this.interactions.length - 1];
    
    const sessionDuration = lastInteraction.timestamp - firstInteraction.timestamp;
    
    // 按类型统计交互
    const interactionsByType = {};
    for (const interaction of this.interactions) {
      interactionsByType[interaction.type] = (interactionsByType[interaction.type] || 0) + 1;
    }
    
    // 计算页面滚动深度
    const scrollInteractions = this.interactions.filter(i => i.type === 'scroll');
    const maxScrollPercent = scrollInteractions.length > 0
      ? Math.max(...scrollInteractions.map(i => i.scrollPercent || 0))
      : 0;
    
    return {
      sessionId: this.sessionId,
      userId: this.userId,
      startTime: firstInteraction.timestamp,
      endTime: lastInteraction.timestamp,
      duration: sessionDuration,
      totalInteractions: this.interactions.length,
      interactionsByType,
      maxScrollPercent,
      conversionEvents: this.getConversionEvents(),
    };
  }

  // 清除交互记录
  clearInteractions() {
    this.interactions = [];
    this.heatmapData.clear();
    this.conversionEvents.clear();
  }
}

// 导出单例
export const userInteractionTracker = new UserInteractionTracker();
```

## 13.5 调试工具与技巧

### 13.5.1 微前端调试工具

```javascript
// 示例：微前端调试工具
class MicroFrontendDebugger {
  constructor() {
    this.apps = new Map(); // appName -> appInfo
    this.eventLog = [];
    this.performanceData = new Map(); // appName -> performanceData
    this.errorLog = [];
    this.isDebugMode = false;
    this.debugPanel = null;
    this.eventListeners = new Map();
  }

  // 启用调试模式
  enableDebugMode() {
    if (this.isDebugMode) return;
    
    this.isDebugMode = true;
    
    // 创建调试面板
    this.createDebugPanel();
    
    // 监听微前端事件
    this.setupEventListeners();
    
    // 拦截全局错误
    this.interceptErrors();
    
    // 监听性能指标
    this.monitorPerformance();
    
    console.log('Micro frontend debug mode enabled');
  }

  // 禁用调试模式
  disableDebugMode() {
    if (!this.isDebugMode) return;
    
    this.isDebugMode = false;
    
    // 移除调试面板
    if (this.debugPanel && this.debugPanel.parentNode) {
      this.debugPanel.parentNode.removeChild(this.debugPanel);
      this.debugPanel = null;
    }
    
    // 移除事件监听器
    this.removeEventListeners();
    
    // 恢复错误处理
    this.restoreErrorHandling();
    
    // 停止性能监控
    this.stopPerformanceMonitoring();
    
    console.log('Micro frontend debug mode disabled');
  }

  // 注册应用
  registerApp(appName, appInfo) {
    this.apps.set(appName, {
      name: appName,
      ...appInfo,
      status: 'registered',
      registeredAt: new Date(),
      events: [],
      errors: [],
      performance: {},
    });
    
    // 更新调试面板
    this.updateDebugPanel();
    
    console.log(`App registered for debugging: ${appName}`);
  }

  // 记录事件
  logEvent(type, data) {
    const event = {
      type,
      data,
      timestamp: Date.now(),
    };
    
    this.eventLog.push(event);
    
    // 限制事件日志大小
    if (this.eventLog.length > 1000) {
      this.eventLog.splice(0, this.eventLog.length - 1000);
    }
    
    // 更新调试面板
    this.updateEventsTab();
  }

  // 记录错误
  logError(error) {
    this.errorLog.push(error);
    
    // 限制错误日志大小
    if (this.errorLog.length > 500) {
      this.errorLog.splice(0, this.errorLog.length - 500);
    }
    
    // 更新调试面板
    this.updateErrorsTab();
  }

  // 记录性能数据
  logPerformance(appName, data) {
    if (!this.performanceData.has(appName)) {
      this.performanceData.set(appName, {});
    }
    
    const appPerf = this.performanceData.get(appName);
    Object.assign(appPerf, data);
    
    // 更新调试面板
    this.updatePerformanceTab();
  }

  // 加载应用
  async loadApp(appName) {
    // 这里应该调用实际的加载逻辑
    console.log(`Loading app: ${appName}`);
    
    // 模拟加载过程
    this.logEvent('app-load-start', { appName });
    
    try {
      // 模拟加载延迟
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      this.logEvent('app-load-success', { appName });
      
      // 更新应用状态
      if (this.apps.has(appName)) {
        const appInfo = this.apps.get(appName);
        appInfo.status = 'loaded';
        appInfo.loadedAt = new Date();
        this.updateAppsTab();
      }
    } catch (error) {
      this.logEvent('app-load-error', { appName, error: error.message });
      
      this.logError({
        type: 'app-load-error',
        appName,
        message: error.message,
        timestamp: Date.now(),
      });
    }
  }

  // 卸载应用
  async unloadApp(appName) {
    // 这里应该调用实际的卸载逻辑
    console.log(`Unloading app: ${appName}`);
    
    this.logEvent('app-unload-start', { appName });
    
    try {
      // 模拟卸载延迟
      await new Promise(resolve => setTimeout(resolve, 500));
      
      this.logEvent('app-unload-success', { appName });
      
      // 更新应用状态
      if (this.apps.has(appName)) {
        const appInfo = this.apps.get(appName);
        appInfo.status = 'registered';
        appInfo.unloadedAt = new Date();
        this.updateAppsTab();
      }
    } catch (error) {
      this.logEvent('app-unload-error', { appName, error: error.message });
      
      this.logError({
        type: 'app-unload-error',
        appName,
        message: error.message,
        timestamp: Date.now(),
      });
    }
  }

  // 重新加载应用
  async reloadApp(appName) {
    await this.unloadApp(appName);
    await this.loadApp(appName);
  }

  // 停止性能监控
  stopPerformanceMonitoring() {
    if (this.memoryInterval) {
      clearInterval(this.memoryInterval);
      this.memoryInterval = null;
    }
  }
}

// 导出单例
export const microFrontendDebugger = new MicroFrontendDebugger();
```

## 13.6 监控最佳实践

### 13.6.1 监控策略

1. **分层监控**
   - 基础设施层监控
   - 应用层监控
   - 业务层监控
   - 用户体验监控

2. **监控指标选择**
   - 关键性能指标(KPI)
   - 核心业务指标
   - 技术指标
   - 用户体验指标

3. **监控告警策略**
   - 分级告警机制
   - 告警收敛规则
   - 告警通知渠道
   - 告警响应流程

4. **监控数据管理**
   - 数据采集策略
   - 数据存储方案
   - 数据分析工具
   - 数据可视化

### 13.6.2 调试技巧

1. **应用隔离调试**
   - 独立环境调试
   - 模拟数据调试
   - 边界条件测试
   - 错误注入测试

2. **跨应用调试**
   - 通信链路追踪
   - 状态同步调试
   - 依赖关系分析
   - 性能瓶颈定位

3. **性能调试**
   - 性能分析工具
   - 资源加载分析
   - 运行时性能分析
   - 内存泄漏检测

4. **错误调试**
   - 错误堆栈分析
   - 错误复现方法
   - 错误边界测试
   - 错误恢复机制

## 13.7 总结

微前端监控与调试是确保微前端架构稳定运行的关键环节。本章介绍了：

1. **性能监控**：通过关键指标收集和跨应用性能追踪，全面了解系统性能状况。

2. **错误监控**：实现错误捕获、分类和分析，快速定位和解决问题。

3. **用户行为监控**：追踪用户交互，分析用户行为，优化用户体验。

4. **调试工具与技巧**：提供专门的调试工具和实用的调试技巧，提高开发效率。

通过合理的监控策略和调试方法，可以确保微前端系统的高可用性和高性能，为用户提供优质的使用体验。

## 13.8 示例代码

### 13.8.1 文件结构

```
micro-frontend-monitoring/
├── performance/
│   ├── PerformanceMetrics.js      # 性能指标收集
│   ├── CrossAppPerformanceTracker.js  # 跨应用性能追踪
│   └── WebVitalsCollector.js     # Web Vitals收集
├── error/
│   ├── ErrorMonitor.js            # 错误监控
│   ├── ErrorAnalyzer.js           # 错误分析
│   └── ErrorReporter.js           # 错误报告
├── user/
│   ├── UserInteractionTracker.js  # 用户交互追踪
│   ├── HeatmapGenerator.js        # 热图生成
│   └── ConversionTracker.js       # 转化追踪
├── debug/
│   ├── MicroFrontendDebugger.js   # 微前端调试工具
│   ├── DevToolsExtension.js       # 开发者工具扩展
│   └── ConsoleHelpers.js          # 控制台辅助工具
└── integration/
    ├── MonitoringDashboard.js     # 监控仪表板
    ├── AlertManager.js            # 告警管理
    └── DataCollector.js           # 数据收集器
```

### 13.8.2 运行说明

1. **安装依赖**
   ```bash
   npm install
   ```

2. **启动监控服务**
   ```bash
   npm run monitor
   ```

3. **集成到微前端应用**
   ```javascript
   import { performanceMetrics, errorMonitor, userInteractionTracker } from './monitoring';
   
   // 启动性能监控
   performanceMetrics.startCollecting();
   
   // 启动错误监控
   errorMonitor.startMonitoring();
   
   // 启动用户行为追踪
   userInteractionTracker.startTracking();
   ```

4. **启用调试模式**
   ```javascript
   import { microFrontendDebugger } from './debug';
   
   // 启用调试模式
   microFrontendDebugger.enableDebugMode();
   
   // 注册应用
   microFrontendDebugger.registerApp('app1', {
     entry: '//localhost:8081',
     container: '#app1-container',
   });
   ```

### 13.8.3 功能演示

1. **性能监控演示**
   - 实时性能指标展示
   - Web Vitals指标分析
   - 跨应用性能对比

2. **错误监控演示**
   - 错误实时捕获
   - 错误分类统计
   - 错误趋势分析

3. **用户行为监控演示**
   - 用户交互热图
   - 转化漏斗分析
   - 用户路径追踪

4. **调试工具演示**
   - 应用状态监控
   - 事件日志查看
   - 性能数据分析

通过本章的学习，读者应该能够构建完整的微前端监控与调试体系，确保微前端应用的稳定性和高性能。