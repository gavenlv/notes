<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第9章：Promise与异步编程 - 演示</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        header {
            background-color: #4a6bdf;
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        header h1 {
            margin-bottom: 10px;
        }
        
        .tabs {
            display: flex;
            background-color: #f1f1f1;
            border-bottom: 1px solid #ddd;
            overflow-x: auto;
        }
        
        .tab {
            padding: 15px 20px;
            cursor: pointer;
            background-color: #f1f1f1;
            border: none;
            outline: none;
            transition: background-color 0.3s;
            white-space: nowrap;
            font-size: 16px;
        }
        
        .tab:hover {
            background-color: #ddd;
        }
        
        .tab.active {
            background-color: #4a6bdf;
            color: white;
        }
        
        .tab-content {
            display: none;
            padding: 20px;
            min-height: 500px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .demo-section {
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 8px;
            background-color: #f9f9f9;
            border-left: 4px solid #4a6bdf;
        }
        
        .demo-section h3 {
            margin-bottom: 15px;
            color: #4a6bdf;
        }
        
        .demo-section p {
            margin-bottom: 15px;
        }
        
        button {
            background-color: #4a6bdf;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
            margin-bottom: 10px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #3a5bd9;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .output {
            margin-top: 15px;
            padding: 15px;
            background-color: #f1f1f1;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .code-block {
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
            font-family: monospace;
            overflow-x: auto;
        }
        
        .interactive-section {
            margin-top: 20px;
            padding: 20px;
            background-color: #e9f5ff;
            border-radius: 8px;
        }
        
        .interactive-section h4 {
            margin-bottom: 15px;
            color: #2c5aa0;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .exercise-result {
            margin-top: 15px;
            padding: 15px;
            background-color: #f1f1f1;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0,0,0,.3);
            border-radius: 50%;
            border-top-color: #4a6bdf;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .status.success {
            background-color: #d4edda;
            color: #155724;
        }
        
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        .status.info {
            background-color: #d1ecf1;
            color: #0c5460;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .card {
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .card h4 {
            margin-bottom: 15px;
            color: #4a6bdf;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #f1f1f1;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .progress {
            height: 100%;
            background-color: #4a6bdf;
            width: 0%;
            transition: width 0.3s;
        }
        
        .comparison {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .comparison-column {
            flex: 1;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
        }
        
        .comparison-column h4 {
            margin-bottom: 10px;
            color: #4a6bdf;
        }
        
        .comparison-column pre {
            background-color: #f1f1f1;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>第9章：Promise与异步编程</h1>
            <p>交互式演示与实践练习</p>
        </header>
        
        <div class="tabs">
            <button class="tab active" onclick="openTab(event, 'basics')">Promise基础</button>
            <button class="tab" onclick="openTab(event, 'advanced')">Promise进阶</button>
            <button class="tab" onclick="openTab(event, 'async-await')">Async/Await</button>
            <button class="tab" onclick="openTab(event, 'applications')">实际应用</button>
            <button class="tab" onclick="openTab(event, 'exercises')">实践练习</button>
        </div>
        
        <!-- Promise基础 -->
        <div id="basics" class="tab-content active">
            <div class="demo-section">
                <h3>Promise状态与创建</h3>
                <p>Promise有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p>
                <button onclick="createPromise()">创建Promise</button>
                <div id="promise-output" class="output"></div>
            </div>
            
            <div class="demo-section">
                <h3>Promise链式调用</h3>
                <p>通过then方法可以实现Promise的链式调用，使异步代码更加清晰。</p>
                <button onclick="promiseChaining()">执行链式调用</button>
                <div id="chaining-output" class="output"></div>
            </div>
            
            <div class="demo-section">
                <h3>错误处理</h3>
                <p>使用catch方法捕获Promise中的错误。</p>
                <button onclick="promiseErrorHandling()">测试错误处理</button>
                <div id="error-output" class="output"></div>
            </div>
            
            <div class="demo-section">
                <h3>finally方法</h3>
                <p>finally方法无论Promise最终状态如何都会执行。</p>
                <button onclick="promiseFinally()">测试finally</button>
                <div id="finally-output" class="output"></div>
            </div>
        </div>
        
        <!-- Promise进阶 -->
        <div id="advanced" class="tab-content">
            <div class="demo-section">
                <h3>Promise.all</h3>
                <p>Promise.all用于并行处理多个Promise，当所有Promise都完成时返回结果。</p>
                <button onclick="promiseAllDemo()">执行Promise.all</button>
                <div id="promise-all-output" class="output"></div>
            </div>
            
            <div class="demo-section">
                <h3>Promise.race</h3>
                <p>Promise.race返回最先完成或失败的Promise的结果。</p>
                <button onclick="promiseRaceDemo()">执行Promise.race</button>
                <div id="promise-race-output" class="output"></div>
            </div>
            
            <div class="demo-section">
                <h3>Promise.allSettled</h3>
                <p>Promise.allSettled等待所有Promise完成，无论成功或失败。</p>
                <button onclick="promiseAllSettledDemo()">执行Promise.allSettled</button>
                <div id="promise-allsettled-output" class="output"></div>
            </div>
            
            <div class="comparison">
                <div class="comparison-column">
                    <h4>串行执行</h4>
                    <pre>await task1();
await task2();
await task3();</pre>
                    <button onclick="serialExecution()">执行串行任务</button>
                    <div id="serial-output" class="output"></div>
                </div>
                
                <div class="comparison-column">
                    <h4>并行执行</h4>
                    <pre>await Promise.all([
  task1(),
  task2(),
  task3()
]);</pre>
                    <button onclick="parallelExecution()">执行并行任务</button>
                    <div id="parallel-output" class="output"></div>
                </div>
            </div>
        </div>
        
        <!-- Async/Await -->
        <div id="async-await" class="tab-content">
            <div class="demo-section">
                <h3>Async函数基础</h3>
                <p>async函数是ES2017引入的，它是Generator函数的语法糖，使得异步操作更加方便。</p>
                <button onclick="asyncFunctionBasics()">运行async函数</button>
                <div id="async-basics-output" class="output"></div>
            </div>
            
            <div class="demo-section">
                <h3>Await表达式</h3>
                <p>await操作符用于等待一个Promise对象，它只能在async函数内部使用。</p>
                <button onclick="awaitExpression()">测试await</button>
                <div id="await-output" class="output"></div>
            </div>
            
            <div class="demo-section">
                <h3>Async/Await错误处理</h3>
                <p>使用try/catch块处理async/await中的错误。</p>
                <button onclick="asyncErrorHandling()">测试错误处理</button>
                <div id="async-error-output" class="output"></div>
            </div>
            
            <div class="demo-section">
                <h3>串行vs并行处理</h3>
                <p>比较串行和并行处理异步任务的性能差异。</p>
                <button onclick="compareSerialVsParallel()">比较执行方式</button>
                <div id="comparison-output" class="output"></div>
            </div>
        </div>
        
        <!-- 实际应用 -->
        <div id="applications" class="tab-content">
            <div class="demo-section">
                <h3>API请求处理</h3>
                <p>使用Promise和async/await处理API请求。</p>
                <button onclick="fetchUserData()">获取用户数据</button>
                <div id="api-output" class="output"></div>
            </div>
            
            <div class="demo-section">
                <h3>超时处理</h3>
                <p>为Promise添加超时机制，防止长时间等待。</p>
                <button onclick="timeoutHandling()">测试超时处理</button>
                <div id="timeout-output" class="output"></div>
            </div>
            
            <div class="demo-section">
                <h3>重试机制</h3>
                <p>实现Promise的重试机制，提高操作的可靠性。</p>
                <button onclick="retryMechanism()">测试重试机制</button>
                <div id="retry-output" class="output"></div>
            </div>
            
            <div class="demo-section">
                <h3>并发限制</h3>
                <p>限制同时运行的Promise数量，避免资源耗尽。</p>
                <button onclick="concurrencyLimit()">测试并发限制</button>
                <div id="concurrency-output" class="output"></div>
            </div>
        </div>
        
        <!-- 实践练习 -->
        <div id="exercises" class="tab-content">
            <div class="interactive-section">
                <h4>练习1：Promise队列</h4>
                <p>实现一个Promise队列，按顺序执行异步任务。</p>
                <button onclick="promiseQueueExercise()">运行Promise队列</button>
                <div id="queue-exercise-output" class="output"></div>
            </div>
            
            <div class="interactive-section">
                <h4>练习2：Promise缓存</h4>
                <p>实现一个Promise缓存，避免重复请求相同的数据。</p>
                <button onclick="promiseCacheExercise()">测试Promise缓存</button>
                <div id="cache-exercise-output" class="output"></div>
            </div>
            
            <div class="interactive-section">
                <h4>练习3：图片加载器</h4>
                <p>实现一个图片加载器，支持并行加载、错误处理和进度显示。</p>
                <div>
                    <label for="image-urls">图片URL（每行一个）：</label>
                    <textarea id="image-urls" rows="4" placeholder="https://picsum.photos/seed/img1/200/200.jpg
https://picsum.photos/seed/img2/200/200.jpg
https://picsum.photos/seed/img3/200/200.jpg">https://picsum.photos/seed/img1/200/200.jpg
https://picsum.photos/seed/img2/200/200.jpg
https://picsum.photos/seed/img3/200/200.jpg</textarea>
                    <button onclick="loadImages()">加载图片</button>
                    <div id="image-loading-output" class="output"></div>
                    <div id="image-container" class="grid"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 工具函数
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function randomSuccess(successRate = 0.7) {
            return Math.random() < successRate;
        }
        
        function logToOutput(outputId, message, type = 'info') {
            const output = document.getElementById(outputId);
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : '';
            
            output.innerHTML += `<span class="${className}">[${timestamp}] ${message}</span>\n`;
            output.scrollTop = output.scrollHeight;
        }
        
        function clearOutput(outputId) {
            document.getElementById(outputId).innerHTML = '';
        }
        
        // Tab切换功能
        function openTab(evt, tabName) {
            const tabContents = document.getElementsByClassName('tab-content');
            for (let i = 0; i < tabContents.length; i++) {
                tabContents[i].classList.remove('active');
            }
            
            const tabs = document.getElementsByClassName('tab');
            for (let i = 0; i < tabs.length; i++) {
                tabs[i].classList.remove('active');
            }
            
            document.getElementById(tabName).classList.add('active');
            evt.currentTarget.classList.add('active');
        }
        
        // Promise基础示例
        function createPromise() {
            clearOutput('promise-output');
            logToOutput('promise-output', '创建一个Promise...');
            
            const myPromise = new Promise((resolve, reject) => {
                setTimeout(() => {
                    if (randomSuccess()) {
                        resolve('Promise成功完成！');
                    } else {
                        reject(new Error('Promise执行失败！'));
                    }
                }, 1000);
            });
            
            logToOutput('promise-output', 'Promise已创建，等待结果...');
            
            myPromise
                .then(result => {
                    logToOutput('promise-output', `成功: ${result}`, 'success');
                })
                .catch(error => {
                    logToOutput('promise-output', `失败: ${error.message}`, 'error');
                });
        }
        
        function promiseChaining() {
            clearOutput('chaining-output');
            logToOutput('chaining-output', '开始Promise链式调用...');
            
            Promise.resolve(1)
                .then(value => {
                    logToOutput('chaining-output', `第一步: ${value}`);
                    return value + 1;
                })
                .then(value => {
                    logToOutput('chaining-output', `第二步: ${value}`);
                    return value * 2;
                })
                .then(value => {
                    logToOutput('chaining-output', `最终结果: ${value}`, 'success');
                });
        }
        
        function promiseErrorHandling() {
            clearOutput('error-output');
            logToOutput('error-output', '测试Promise错误处理...');
            
            Promise.reject(new Error('这是一个测试错误'))
                .then(result => {
                    logToOutput('error-output', `这不会执行: ${result}`);
                })
                .catch(error => {
                    logToOutput('error-output', `捕获错误: ${error.message}`, 'error');
                })
                .then(() => {
                    logToOutput('error-output', '错误处理后继续执行');
                });
        }
        
        function promiseFinally() {
            clearOutput('finally-output');
            logToOutput('finally-output', '测试Promise.finally方法...');
            
            const success = randomSuccess();
            
            if (success) {
                logToOutput('finally-output', '模拟成功的Promise');
                Promise.resolve('操作成功')
                    .then(result => {
                        logToOutput('finally-output', `成功: ${result}`, 'success');
                    })
                    .catch(error => {
                        logToOutput('finally-output', `失败: ${error.message}`, 'error');
                    })
                    .finally(() => {
                        logToOutput('finally-output', 'finally块执行（成功情况）');
                    });
            } else {
                logToOutput('finally-output', '模拟失败的Promise');
                Promise.reject(new Error('操作失败'))
                    .then(result => {
                        logToOutput('finally-output', `这不会执行: ${result}`);
                    })
                    .catch(error => {
                        logToOutput('finally-output', `失败: ${error.message}`, 'error');
                    })
                    .finally(() => {
                        logToOutput('finally-output', 'finally块执行（失败情况）');
                    });
            }
        }
        
        // Promise进阶示例
        function promiseAllDemo() {
            clearOutput('promise-all-output');
            logToOutput('promise-all-output', '开始Promise.all演示...');
            
            const promise1 = Promise.resolve(3);
            const promise2 = new Promise(resolve => setTimeout(() => resolve('foo'), 1000));
            const promise3 = Promise.resolve(42);
            
            logToOutput('promise-all-output', '创建了3个Promise，等待所有完成...');
            
            Promise.all([promise1, promise2, promise3])
                .then(values => {
                    logToOutput('promise-all-output', `所有Promise完成，结果: ${JSON.stringify(values)}`, 'success');
                })
                .catch(error => {
                    logToOutput('promise-all-output', `至少有一个Promise失败: ${error.message}`, 'error');
                });
        }
        
        function promiseRaceDemo() {
            clearOutput('promise-race-output');
            logToOutput('promise-race-output', '开始Promise.race演示...');
            
            const promise1 = new Promise(resolve => setTimeout(() => resolve('one'), 500));
            const promise2 = new Promise(resolve => setTimeout(() => resolve('two'), 100));
            const promise3 = new Promise(resolve => setTimeout(() => resolve('three'), 300));
            
            logToOutput('promise-race-output', '创建了3个Promise，等待最快的完成...');
            
            Promise.race([promise1, promise2, promise3])
                .then(value => {
                    logToOutput('promise-race-output', `最快的Promise完成，结果: ${value}`, 'success');
                })
                .catch(error => {
                    logToOutput('promise-race-output', `最快的Promise失败: ${error.message}`, 'error');
                });
        }
        
        function promiseAllSettledDemo() {
            clearOutput('promise-allsettled-output');
            logToOutput('promise-allsettled-output', '开始Promise.allSettled演示...');
            
            const promise1 = Promise.resolve(3);
            const promise2 = new Promise((resolve, reject) => 
                setTimeout(() => reject(new Error("失败")), 1000)
            );
            const promise3 = Promise.resolve(42);
            
            logToOutput('promise-allsettled-output', '创建了3个Promise（其中1个会失败），等待所有完成...');
            
            Promise.allSettled([promise1, promise2, promise3])
                .then(results => {
                    logToOutput('promise-allsettled-output', '所有Promise已完成，结果:', 'success');
                    results.forEach((result, i) => {
                        if (result.status === 'fulfilled') {
                            logToOutput('promise-allsettled-output', `Promise ${i}: 成功 - ${result.value}`);
                        } else {
                            logToOutput('promise-allsettled-output', `Promise ${i}: 失败 - ${result.reason.message}`, 'error');
                        }
                    });
                });
        }
        
        async function serialExecution() {
            clearOutput('serial-output');
            logToOutput('serial-output', '开始串行执行...');
            
            console.time('串行执行');
            
            const task1 = () => delay(1000).then(() => '任务1完成');
            const task2 = () => delay(1000).then(() => '任务2完成');
            const task3 = () => delay(1000).then(() => '任务3完成');
            
            const result1 = await task1();
            logToOutput('serial-output', result1);
            
            const result2 = await task2();
            logToOutput('serial-output', result2);
            
            const result3 = await task3();
            logToOutput('serial-output', result3);
            
            console.timeEnd('串行执行');
            logToOutput('serial-output', '串行执行完成', 'success');
        }
        
        async function parallelExecution() {
            clearOutput('parallel-output');
            logToOutput('parallel-output', '开始并行执行...');
            
            console.time('并行执行');
            
            const task1 = delay(1000).then(() => '任务1完成');
            const task2 = delay(1000).then(() => '任务2完成');
            const task3 = delay(1000).then(() => '任务3完成');
            
            const results = await Promise.all([task1, task2, task3]);
            
            results.forEach(result => {
                logToOutput('parallel-output', result);
            });
            
            console.timeEnd('并行执行');
            logToOutput('parallel-output', '并行执行完成', 'success');
        }
        
        // Async/Await示例
        async function asyncFunctionBasics() {
            clearOutput('async-basics-output');
            logToOutput('async-basics-output', '测试async函数基础...');
            
            async function fetchData() {
                return '数据';
            }
            
            const data = await fetchData();
            logToOutput('async-basics-output', `async函数返回: ${data}`, 'success');
            
            // 等同于
            fetchData().then(data => {
                logToOutput('async-basics-output', `Promise.then返回: ${data}`);
            });
        }
        
        async function awaitExpression() {
            clearOutput('await-output');
            logToOutput('await-output', '测试await表达式...');
            
            logToOutput('await-output', '开始...');
            await delay(1000);
            logToOutput('await-output', '1秒后...');
            
            const result = await Promise.resolve('结果');
            logToOutput('await-output', `Promise结果: ${result}`);
            
            try {
                const errorResult = await Promise.reject(new Error('错误'));
            } catch (error) {
                logToOutput('await-output', `捕获错误: ${error.message}`, 'error');
            }
        }
        
        async function asyncErrorHandling() {
            clearOutput('async-error-output');
            logToOutput('async-error-output', '测试async/await错误处理...');
            
            try {
                const success = randomSuccess();
                
                if (success) {
                    const data = await Promise.resolve('成功获取数据');
                    logToOutput('async-error-output', `成功: ${data}`, 'success');
                } else {
                    const data = await Promise.reject(new Error('获取数据失败'));
                    logToOutput('async-error-output', `这不会执行: ${data}`);
                }
            } catch (error) {
                logToOutput('async-error-output', `捕获错误: ${error.message}`, 'error');
            } finally {
                logToOutput('async-error-output', '清理工作');
            }
        }
        
        async function compareSerialVsParallel() {
            clearOutput('comparison-output');
            logToOutput('comparison-output', '比较串行vs并行处理...');
            
            // 串行处理
            logToOutput('comparison-output', '串行处理:');
            console.time('串行处理');
            
            const serialStart = Date.now();
            await delay(1000);
            await delay(1000);
            await delay(1000);
            const serialTime = Date.now() - serialStart;
            
            console.timeEnd('串行处理');
            logToOutput('comparison-output', `串行处理耗时: ${serialTime}ms`);
            
            // 并行处理
            logToOutput('comparison-output', '并行处理:');
            console.time('并行处理');
            
            const parallelStart = Date.now();
            await Promise.all([
                delay(1000),
                delay(1000),
                delay(1000)
            ]);
            const parallelTime = Date.now() - parallelStart;
            
            console.timeEnd('并行处理');
            logToOutput('comparison-output', `并行处理耗时: ${parallelTime}ms`);
            
            logToOutput('comparison-output', `性能提升: ${((serialTime - parallelTime) / serialTime * 100).toFixed(1)}%`, 'success');
        }
        
        // 实际应用示例
        async function fetchUserData() {
            clearOutput('api-output');
            logToOutput('api-output', '模拟API请求...');
            
            // 模拟API请求
            function fetchUser(id) {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        if (id === 1) {
                            resolve({ id, name: '张三', email: 'zhangsan@example.com' });
                        } else {
                            reject(new Error('用户不存在'));
                        }
                    }, 1000);
                });
            }
            
            function getUserPosts(userId) {
                return new Promise(resolve => {
                    setTimeout(() => {
                        resolve([
                            { id: 1, title: '文章1', userId },
                            { id: 2, title: '文章2', userId }
                        ]);
                    }, 800);
                });
            }
            
            try {
                logToOutput('api-output', '获取用户信息...');
                const user = await fetchUser(1);
                logToOutput('api-output', `用户: ${user.name} (${user.email})`, 'success');
                
                logToOutput('api-output', '获取用户文章...');
                const posts = await getUserPosts(user.id);
                logToOutput('api-output', `文章数量: ${posts.length}`, 'success');
                
                posts.forEach(post => {
                    logToOutput('api-output', `- ${post.title}`);
                });
                
                logToOutput('api-output', '所有数据获取完成', 'success');
            } catch (error) {
                logToOutput('api-output', `错误: ${error.message}`, 'error');
            }
        }
        
        async function timeoutHandling() {
            clearOutput('timeout-output');
            logToOutput('timeout-output', '测试超时处理...');
            
            // Promise超时处理
            function withTimeout(promise, timeoutMs) {
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('操作超时')), timeoutMs);
                });
                
                return Promise.race([promise, timeoutPromise]);
            }
            
            // 测试会超时的操作
            try {
                logToOutput('timeout-output', '开始一个2秒的操作，设置1秒超时...');
                const result = await withTimeout(delay(2000), 1000);
                logToOutput('timeout-output', `结果: ${result}`, 'success');
            } catch (error) {
                logToOutput('timeout-output', `捕获错误: ${error.message}`, 'error');
            }
            
            // 测试不会超时的操作
            try {
                logToOutput('timeout-output', '开始一个500毫秒的操作，设置1秒超时...');
                const result = await withTimeout(delay(500), 1000);
                logToOutput('timeout-output', `结果: ${result}`, 'success');
            } catch (error) {
                logToOutput('timeout-output', `捕获错误: ${error.message}`, 'error');
            }
        }
        
        async function retryMechanism() {
            clearOutput('retry-output');
            logToOutput('retry-output', '测试重试机制...');
            
            let attemptCount = 0;
            
            function unreliableOperation() {
                attemptCount++;
                logToOutput('retry-output', `尝试第 ${attemptCount} 次`);
                
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        if (attemptCount >= 3) {
                            resolve('成功！');
                        } else {
                            reject(new Error('操作失败'));
                        }
                    }, 500);
                });
            }
            
            // Promise重试机制
            function retry(fn, maxAttempts = 3, delayMs = 1000) {
                return new Promise((resolve, reject) => {
                    let attempt = 1;
                    
                    function attemptOperation() {
                        fn()
                            .then(resolve)
                            .catch(error => {
                                if (attempt < maxAttempts) {
                                    attempt++;
                                    logToOutput('retry-output', `尝试失败，${delayMs}ms后重试 (${attempt}/${maxAttempts})`);
                                    setTimeout(attemptOperation, delayMs);
                                } else {
                                    reject(new Error(`操作失败，已尝试${maxAttempts}次: ${error.message}`));
                                }
                            });
                    }
                    
                    attemptOperation();
                });
            }
            
            try {
                const result = await retry(unreliableOperation, 5, 500);
                logToOutput('retry-output', `最终结果: ${result}`, 'success');
            } catch (error) {
                logToOutput('retry-output', `最终失败: ${error.message}`, 'error');
            }
        }
        
        async function concurrencyLimit() {
            clearOutput('concurrency-output');
            logToOutput('concurrency-output', '测试并发限制...');
            
            // 并发限制器
            class ConcurrencyLimiter {
                constructor(maxConcurrency) {
                    this.maxConcurrency = maxConcurrency;
                    this.running = 0;
                    this.queue = [];
                }
                
                async add(promiseCreator) {
                    return new Promise((resolve, reject) => {
                        this.queue.push({
                            promiseCreator,
                            resolve,
                            reject
                        });
                        
                        this.process();
                    });
                }
                
                async process() {
                    if (this.running >= this.maxConcurrency || this.queue.length === 0) {
                        return;
                    }
                    
                    this.running++;
                    const { promiseCreator, resolve, reject } = this.queue.shift();
                    
                    try {
                        const result = await promiseCreator();
                        resolve(result);
                    } catch (error) {
                        reject(error);
                    } finally {
                        this.running--;
                        this.process();
                    }
                }
            }
            
            const limiter = new ConcurrencyLimiter(3);
            
            // 创建10个任务，但只有3个会同时运行
            for (let i = 1; i <= 10; i++) {
                limiter.add(() => {
                    logToOutput('concurrency-output', `任务${i}开始`);
                    return delay(Math.random() * 2000 + 1000).then(() => {
                        logToOutput('concurrency-output', `任务${i}完成`);
                        return `任务${i}的结果`;
                    });
                }).then(result => {
                    logToOutput('concurrency-output', result, 'success');
                });
            }
        }
        
        // 实践练习
        async function promiseQueueExercise() {
            clearOutput('queue-exercise-output');
            logToOutput('queue-exercise-output', 'Promise队列练习...');
            
            // Promise队列实现
            class PromiseQueue {
                constructor() {
                    this.queue = [];
                    this.running = false;
                }
                
                add(promiseCreator) {
                    return new Promise((resolve, reject) => {
                        this.queue.push({
                            promiseCreator,
                            resolve,
                            reject
                        });
                        
                        if (!this.running) {
                            this.processQueue();
                        }
                    });
                }
                
                async processQueue() {
                    this.running = true;
                    
                    while (this.queue.length > 0) {
                        const { promiseCreator, resolve, reject } = this.queue.shift();
                        
                        try {
                            const result = await promiseCreator();
                            resolve(result);
                        } catch (error) {
                            reject(error);
                        }
                    }
                    
                    this.running = false;
                }
            }
            
            const queue = new PromiseQueue();
            
            queue.add(() => delay(1000).then(() => '任务1完成'))
                .then(result => logToOutput('queue-exercise-output', result, 'success'));
            
            queue.add(() => delay(500).then(() => '任务2完成'))
                .then(result => logToOutput('queue-exercise-output', result, 'success'));
            
            queue.add(() => delay(800).then(() => '任务3完成'))
                .then(result => logToOutput('queue-exercise-output', result, 'success'));
        }
        
        async function promiseCacheExercise() {
            clearOutput('cache-exercise-output');
            logToOutput('cache-exercise-output', 'Promise缓存练习...');
            
            // Promise缓存实现
            class PromiseCache {
                constructor() {
                    this.cache = new Map();
                }
                
                get(key, promiseCreator) {
                    if (this.cache.has(key)) {
                        logToOutput('cache-exercise-output', `从缓存获取: ${key}`);
                        return this.cache.get(key);
                    }
                    
                    logToOutput('cache-exercise-output', `创建新Promise: ${key}`);
                    const promise = promiseCreator();
                    this.cache.set(key, promise);
                    return promise;
                }
            }
            
            const cache = new PromiseCache();
            
            function fetchUserData(userId) {
                return cache.get(`user-${userId}`, () => {
                    return new Promise(resolve => {
                        setTimeout(() => {
                            resolve({ id: userId, name: `用户${userId}` });
                        }, 500);
                    });
                });
            }
            
            // 第一次调用会发起请求
            fetchUserData(1).then(user => {
                logToOutput('cache-exercise-output', `获取用户: ${JSON.stringify(user)}`, 'success');
            });
            
            // 第二次调用会使用缓存
            setTimeout(() => {
                fetchUserData(1).then(user => {
                    logToOutput('cache-exercise-output', `获取用户: ${JSON.stringify(user)}`, 'success');
                });
            }, 100);
            
            // 获取不同用户
            fetchUserData(2).then(user => {
                logToOutput('cache-exercise-output', `获取用户: ${JSON.stringify(user)}`, 'success');
            });
        }
        
        async function loadImages() {
            const output = document.getElementById('image-loading-output');
            const container = document.getElementById('image-container');
            const urlsTextarea = document.getElementById('image-urls');
            
            clearOutput('image-loading-output');
            container.innerHTML = '';
            
            const urls = urlsTextarea.value.trim().split('\n').filter(url => url.trim());
            
            if (urls.length === 0) {
                logToOutput('image-loading-output', '请输入至少一个图片URL', 'error');
                return;
            }
            
            logToOutput('image-loading-output', `开始加载 ${urls.length} 张图片...`);
            
            // 创建进度条
            const progressBar = document.createElement('div');
            progressBar.className = 'progress-bar';
            const progress = document.createElement('div');
            progress.className = 'progress';
            progressBar.appendChild(progress);
            container.appendChild(progressBar);
            
            let loadedCount = 0;
            let errorCount = 0;
            
            // 图片加载函数
            function loadImage(url) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    
                    img.onload = () => {
                        loadedCount++;
                        updateProgress();
                        resolve({ url, img });
                    };
                    
                    img.onerror = () => {
                        errorCount++;
                        updateProgress();
                        reject(new Error(`加载失败: ${url}`));
                    };
                    
                    img.src = url;
                });
            }
            
            // 更新进度
            function updateProgress() {
                const total = urls.length;
                const percent = ((loadedCount + errorCount) / total * 100).toFixed(0);
                progress.style.width = `${percent}%`;
                
                logToOutput('image-loading-output', 
                    `进度: ${loadedCount + errorCount}/${total} (成功: ${loadedCount}, 失败: ${errorCount})`);
            }
            
            // 并行加载所有图片
            try {
                const results = await Promise.allSettled(
                    urls.map(url => loadImage(url))
                );
                
                // 显示成功加载的图片
                results.forEach((result, index) => {
                    if (result.status === 'fulfilled') {
                        const { url, img } = result.value;
                        
                        const card = document.createElement('div');
                        card.className = 'card';
                        
                        const title = document.createElement('h4');
                        title.textContent = `图片 ${index + 1}`;
                        
                        const imageContainer = document.createElement('div');
                        imageContainer.appendChild(img);
                        
                        const urlText = document.createElement('p');
                        urlText.textContent = url;
                        urlText.style.fontSize = '12px';
                        urlText.style.wordBreak = 'break-all';
                        
                        card.appendChild(title);
                        card.appendChild(imageContainer);
                        card.appendChild(urlText);
                        
                        container.appendChild(card);
                    }
                });
                
                // 移除进度条
                progressBar.remove();
                
                logToOutput('image-loading-output', 
                    `图片加载完成 (成功: ${loadedCount}, 失败: ${errorCount})`, 'success');
            } catch (error) {
                logToOutput('image-loading-output', `加载过程中发生错误: ${error.message}`, 'error');
            }
        }
        
        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', function() {
            logToOutput('promise-output', '页面加载完成，可以开始演示Promise与异步编程');
        });
    </script>
</body>
</html>