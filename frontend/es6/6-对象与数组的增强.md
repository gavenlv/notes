# 第6章：对象与数组的增强

ES6对JavaScript中的对象和数组进行了大幅增强，引入了许多便利的语法和功能，使代码更加简洁、易读和高效。本章将详细介绍这些增强特性。

## 6.1 对象字面量增强

### 6.1.1 属性简写

当对象属性名与变量名相同时，可以简写：

```javascript
// ES5
var name = 'Alice';
var age = 25;
var person = {
  name: name,
  age: age
};

// ES6
const name = 'Alice';
const age = 25;
const person = {
  name,  // 属性名与变量名相同，可简写
  age
};

console.log(person); // { name: 'Alice', age: 25 }
```

### 6.1.2 方法简写

对象方法的定义可以更加简洁：

```javascript
// ES5
var calculator = {
  add: function(a, b) {
    return a + b;
  },
  subtract: function(a, b) {
    return a - b;
  }
};

// ES6
const calculator = {
  add(a, b) {
    return a + b;
  },
  subtract(a, b) {
    return a - b;
  }
};

console.log(calculator.add(5, 3)); // 8
console.log(calculator.subtract(5, 3)); // 2
```

### 6.1.3 计算属性名

ES6允许使用表达式作为对象的属性名：

```javascript
// ES5
var prop = 'name';
var person = {};
person[prop] = 'Alice';

// ES6
const prop = 'name';
const prefix = 'user';
const person = {
  [prop]: 'Alice',
  [`${prefix}Id`]: 123,
  ['full' + 'Name']: 'Alice Smith'
};

console.log(person); // { name: 'Alice', userId: 123, fullName: 'Alice Smith' }
```

## 6.2 数组新增方法

### 6.2.1 Array.from()

`Array.from()`方法可以将类数组对象或可迭代对象转换为真正的数组：

```javascript
// 从类数组对象创建数组
const arrayLike = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3
};
const arr1 = Array.from(arrayLike);
console.log(arr1); // ['a', 'b', 'c']

// 从字符串创建数组
const str = 'hello';
const arr2 = Array.from(str);
console.log(arr2); // ['h', 'e', 'l', 'l', 'o']

// 使用映射函数
const arr3 = Array.from([1, 2, 3], x => x * 2);
console.log(arr3); // [2, 4, 6]

// 从Set创建数组
const set = new Set([1, 2, 3, 2, 1]);
const arr4 = Array.from(set);
console.log(arr4); // [1, 2, 3]
```

### 6.2.2 Array.of()

`Array.of()`方法创建一个具有可变数量参数的新数组实例：

```javascript
// Array构造函数的问题
const arr1 = new Array(3); // 创建一个长度为3的空数组
console.log(arr1); // [empty × 3]

const arr2 = new Array(1, 2, 3); // 创建包含1, 2, 3的数组
console.log(arr2); // [1, 2, 3]

// Array.of解决了这个问题
const arr3 = Array.of(3); // 创建包含3的数组
console.log(arr3); // [3]

const arr4 = Array.of(1, 2, 3); // 创建包含1, 2, 3的数组
console.log(arr4); // [1, 2, 3]
```

### 6.2.3 find() 和 findIndex()

`find()`方法返回数组中满足提供的测试函数的第一个元素的值，否则返回`undefined`。

`findIndex()`方法返回数组中满足提供的测试函数的第一个元素的索引，否则返回-1。

```javascript
const numbers = [5, 12, 8, 130, 44];

// find示例
const found = numbers.find(element => element > 10);
console.log(found); // 12

// findIndex示例
const foundIndex = numbers.findIndex(element => element > 10);
console.log(foundIndex); // 1

// 查找对象
const users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
  { id: 3, name: 'Charlie' }
];

const user = users.find(u => u.id === 2);
console.log(user); // { id: 2, name: 'Bob' }

const userIndex = users.findIndex(u => u.id === 2);
console.log(userIndex); // 1
```

### 6.2.4 fill()

`fill()`方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素：

```javascript
const arr1 = [1, 2, 3, 4];
arr1.fill(0);
console.log(arr1); // [0, 0, 0, 0]

const arr2 = [1, 2, 3, 4];
arr2.fill(0, 1, 3); // 从索引1开始，到索引3（不包括3）结束
console.log(arr2); // [1, 0, 0, 4]

// 创建指定长度并填充的数组
const arr3 = Array(5).fill(0);
console.log(arr3); // [0, 0, 0, 0, 0]

// 填充对象
const arr4 = Array(3).fill({});
arr4[0].name = 'Alice';
console.log(arr4); // [{ name: 'Alice' }, { name: 'Alice' }, { name: 'Alice' }]
// 注意：填充的是同一个对象的引用

// 解决方案：使用map
const arr5 = Array(3).fill().map(() => ({}));
arr5[0].name = 'Alice';
console.log(arr5); // [{ name: 'Alice' }, {}, {}]
```

### 6.2.5 copyWithin()

`copyWithin()`方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改数组的大小：

```javascript
const arr1 = [1, 2, 3, 4, 5];
arr1.copyWithin(0, 3); // 从索引3开始复制，到索引0开始粘贴
console.log(arr1); // [4, 5, 3, 4, 5]

const arr2 = [1, 2, 3, 4, 5];
arr2.copyWithin(1, 3, 5); // 从索引3开始到索引5（不包括5）结束复制，到索引1开始粘贴
console.log(arr2); // [1, 4, 5, 4, 5]

const arr3 = [1, 2, 3, 4, 5];
arr3.copyWithin(-2, 0); // 从索引0开始复制，到倒数第二个位置开始粘贴
console.log(arr3); // [1, 2, 3, 1, 2]
```

### 6.2.6 entries(), keys(), values()

这些方法返回数组的迭代器对象：

```javascript
const arr = ['a', 'b', 'c'];

// entries() 返回键值对迭代器
const entries = arr.entries();
for (const [index, value] of entries) {
  console.log(index, value);
}
// 0 'a'
// 1 'b'
// 2 'c'

// keys() 返回键迭代器
const keys = arr.keys();
for (const key of keys) {
  console.log(key);
}
// 0
// 1
// 2

// values() 返回值迭代器
const values = arr.values();
for (const value of values) {
  console.log(value);
}
// 'a'
// 'b'
// 'c'
```

### 6.2.7 includes()

`includes()`方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回`true`，否则返回`false`：

```javascript
const arr = [1, 2, 3, NaN];

console.log(arr.includes(2)); // true
console.log(arr.includes(4)); // false

// 与indexOf的区别：includes能正确识别NaN
console.log(arr.includes(NaN)); // true
console.log(arr.indexOf(NaN)); // -1

// 可指定起始位置
console.log(arr.includes(2, 1)); // true
console.log(arr.includes(2, 2)); // false
```

## 6.3 对象新增方法

### 6.3.1 Object.assign()

`Object.assign()`方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，它将返回目标对象：

```javascript
// 基本用法
const target = { a: 1, b: 2 };
const source = { b: 3, c: 4 };

const returnedTarget = Object.assign(target, source);

console.log(target); // { a: 1, b: 3, c: 4 }
console.log(returnedTarget); // { a: 1, b: 3, c: 4 }

// 多个源对象
const obj1 = { a: 1 };
const obj2 = { b: 2 };
const obj3 = { c: 3 };

const obj = Object.assign(obj1, obj2, obj3);
console.log(obj); // { a: 1, b: 2, c: 3 }
console.log(obj1); // { a: 1, b: 2, c: 3 } - 目标对象也会被改变

// 浅拷贝
const original = { a: 1, b: { c: 2 } };
const copy = Object.assign({}, original);
console.log(copy); // { a: 1, b: { c: 2 } }

copy.b.c = 3;
console.log(original.b.c); // 3 - 原始对象也被改变，因为是浅拷贝

// 合并具有相同属性的对象
const o1 = { a: 1, b: 1, c: 1 };
const o2 = { b: 2, c: 2 };
const o3 = { c: 3 };

const obj = Object.assign({}, o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 } - 后面的属性会覆盖前面的
```

### 6.3.2 Object.is()

`Object.is()`方法判断两个值是否是相同的值：

```javascript
// 与===的区别
console.log(Object.is(25, 25)); // true
console.log(Object.is('foo', 'foo')); // true
console.log(Object.is('foo', 'bar')); // false
console.log(Object.is(null, null)); // true

console.log(Object.is(0, -0)); // false
console.log(0 === -0); // true

console.log(Object.is(NaN, NaN)); // true
console.log(NaN === NaN); // false

console.log(Object.is(-0, 0)); // false
console.log(Object.is(0, 0)); // true
```

### 6.3.3 Object.getOwnPropertyDescriptors()

`Object.getOwnPropertyDescriptors()`方法用来获取一个对象的所有自身属性的描述符：

```javascript
const obj = {
  a: 1,
  get b() { return 2; },
  set c(value) { this.a = value; }
};

const descriptors = Object.getOwnPropertyDescriptors(obj);
console.log(descriptors);
/*
{
  a: {
    value: 1,
    writable: true,
    enumerable: true,
    configurable: true
  },
  b: {
    get: [Function: get b],
    set: undefined,
    enumerable: true,
    configurable: true
  },
  c: {
    get: undefined,
    set: [Function: set c],
    enumerable: true,
    configurable: true
  }
}
*/
```

### 6.3.4 Object.setPrototypeOf() 和 Object.getPrototypeOf()

`Object.setPrototypeOf()`方法设置一个指定的对象的原型（即内部`[[Prototype]]`属性）到另一个对象或`null`。

`Object.getPrototypeOf()`方法返回指定对象的原型（内部`[[Prototype]]`属性的值）：

```javascript
const obj = {};
const prototypeObj = { a: 1 };

// 设置原型
Object.setPrototypeOf(obj, prototypeObj);
console.log(obj.a); // 1

// 获取原型
const proto = Object.getPrototypeOf(obj);
console.log(proto === prototypeObj); // true

// 与__proto__的区别
const obj2 = {};
obj2.__proto__ = prototypeObj;
console.log(obj2.a); // 1

// __proto__是浏览器实现，不是标准，推荐使用Object.setPrototypeOf和Object.getPrototypeOf
```

### 6.3.5 Object.keys(), Object.values(), Object.entries()

这些方法用于获取对象的键、值和键值对：

```javascript
const obj = {
  a: 1,
  b: 2,
  c: 3
};

// Object.keys() - 获取键数组
const keys = Object.keys(obj);
console.log(keys); // ['a', 'b', 'c']

// Object.values() - 获取值数组
const values = Object.values(obj);
console.log(values); // [1, 2, 3]

// Object.entries() - 获取键值对数组
const entries = Object.entries(obj);
console.log(entries); // [['a', 1], ['b', 2], ['c', 3]]

// 遍历对象
for (const [key, value] of Object.entries(obj)) {
  console.log(`${key}: ${value}`);
}
// a: 1
// b: 2
// c: 3
```

## 6.4 迭代器与for...of循环

### 6.4.1 迭代器协议

迭代器是一种特殊对象，它具有一个`next()`方法，每次调用返回一个结果对象，包含两个属性：

- `value`: 当前位置的值
- `done`: 布尔值，表示是否遍历完成

```javascript
// 创建一个简单的迭代器
function createIterator(array) {
  let index = 0;
  
  return {
    next() {
      if (index < array.length) {
        return { value: array[index++], done: false };
      } else {
        return { done: true };
      }
    }
  };
}

const iterator = createIterator(['a', 'b', 'c']);
console.log(iterator.next()); // { value: 'a', done: false }
console.log(iterator.next()); // { value: 'b', done: false }
console.log(iterator.next()); // { value: 'c', done: false }
console.log(iterator.next()); // { done: true }
```

### 6.4.2 可迭代协议

可迭代对象是实现了`Symbol.iterator`方法的对象，这个方法返回一个迭代器对象：

```javascript
// 创建一个可迭代对象
const myIterable = {
  data: ['a', 'b', 'c'],
  [Symbol.iterator]() {
    let index = 0;
    const data = this.data;
    
    return {
      next() {
        if (index < data.length) {
          return { value: data[index++], done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
};

// 使用for...of遍历
for (const item of myIterable) {
  console.log(item);
}
// 'a'
// 'b'
// 'c'

// 使用扩展运算符
console.log([...myIterable]); // ['a', 'b', 'c']

// 使用解构赋值
const [first, second] = myIterable;
console.log(first, second); // 'a' 'b'
```

### 6.4.3 for...of循环

`for...of`循环用于遍历可迭代对象：

```javascript
// 遍历数组
const arr = ['a', 'b', 'c'];
for (const item of arr) {
  console.log(item);
}
// 'a'
// 'b'
// 'c'

// 遍历字符串
const str = 'hello';
for (const char of str) {
  console.log(char);
}
// 'h'
// 'e'
// 'l'
// 'l'
// 'o'

// 遍历Map
const map = new Map([
  ['a', 1],
  ['b', 2],
  ['c', 3]
]);

for (const [key, value] of map) {
  console.log(`${key}: ${value}`);
}
// 'a: 1'
// 'b: 2'
// 'c: 3'

// 遍历Set
const set = new Set(['a', 'b', 'c']);
for (const item of set) {
  console.log(item);
}
// 'a'
// 'b'
// 'c'

// 遍历NodeList
const divs = document.querySelectorAll('div');
for (const div of divs) {
  console.log(div);
}
```

### 6.4.4 内置迭代器

JavaScript提供了几种内置的迭代器：

```javascript
// entries() 返回键值对迭代器
const arr = ['a', 'b', 'c'];
for (const [index, value] of arr.entries()) {
  console.log(index, value);
}
// 0 'a'
// 1 'b'
// 2 'c'

// keys() 返回键迭代器
for (const key of arr.keys()) {
  console.log(key);
}
// 0
// 1
// 2

// values() 返回值迭代器
for (const value of arr.values()) {
  console.log(value);
}
// 'a'
// 'b'
// 'c'
```

## 6.5 实际应用场景

### 6.5.1 对象属性简写和方法简写

```javascript
// API请求示例
function fetchUserData(userId) {
  return fetch(`/api/users/${userId}`)
    .then(response => response.json())
    .then(data => {
      // 使用属性简写
      return {
        id: data.id,
        name: data.name,
        email: data.email
      };
    });
}

// 使用方法简写
const userService = {
  baseUrl: '/api/users',
  
  // 方法简写
  async getUser(id) {
    const response = await fetch(`${this.baseUrl}/${id}`);
    return response.json();
  },
  
  async createUser(userData) {
    const response = await fetch(this.baseUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(userData)
    });
    return response.json();
  },
  
  async updateUser(id, userData) {
    const response = await fetch(`${this.baseUrl}/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(userData)
    });
    return response.json();
  }
};
```

### 6.5.2 数组方法的应用

```javascript
// 数据处理示例
const users = [
  { id: 1, name: 'Alice', age: 25, active: true },
  { id: 2, name: 'Bob', age: 30, active: false },
  { id: 3, name: 'Charlie', age: 35, active: true },
  { id: 4, name: 'David', age: 28, active: true }
];

// 使用find查找特定用户
const activeUser = users.find(user => user.id === 3);
console.log(activeUser); // { id: 3, name: 'Charlie', age: 35, active: true }

// 使用findIndex查找特定用户的索引
const bobIndex = users.findIndex(user => user.name === 'Bob');
console.log(bobIndex); // 1

// 使用includes检查是否存在特定用户
const userIds = users.map(user => user.id);
console.log(userIds.includes(3)); // true

// 使用entries获取索引和值
for (const [index, user] of users.entries()) {
  console.log(`${index}: ${user.name}`);
}

// 使用Array.from处理类数组对象
function getArguments() {
  return Array.from(arguments).map(arg => arg.toUpperCase());
}
console.log(getArguments('a', 'b', 'c')); // ['A', 'B', 'C']

// 使用fill创建数组并初始化
const matrix = Array(5).fill(null).map(() => Array(5).fill(0));
console.log(matrix);
/*
[
  [0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0]
]
*/
```

### 6.5.3 对象方法的应用

```javascript
// 配置合并示例
const defaultConfig = {
  apiUrl: 'https://api.example.com',
  timeout: 5000,
  retries: 3,
  headers: {
    'Content-Type': 'application/json'
  }
};

const userConfig = {
  timeout: 10000,
  headers: {
    'Authorization': 'Bearer token123'
  }
};

// 使用Object.assign合并配置
const config = Object.assign({}, defaultConfig, userConfig);
console.log(config);
/*
{
  apiUrl: 'https://api.example.com',
  timeout: 10000,
  retries: 3,
  headers: {
    'Authorization': 'Bearer token123'
  }
}
*/

// 使用展开运算符合并配置（ES2018+）
const config2 = { ...defaultConfig, ...userConfig };
console.log(config2);

// 使用Object.keys遍历对象属性
for (const key of Object.keys(config)) {
  console.log(`${key}: ${config[key]}`);
}

// 使用Object.entries遍历对象键值对
for (const [key, value] of Object.entries(config)) {
  console.log(`${key}:`, value);
}

// 使用Object.values获取对象值数组
const configValues = Object.values(config);
console.log(configValues);
```

### 6.5.4 迭代器的应用

```javascript
// 自定义迭代器示例：斐波那契数列
class Fibonacci {
  constructor(limit) {
    this.limit = limit;
  }
  
  [Symbol.iterator]() {
    let a = 0, b = 1, count = 0;
    
    return {
      next: () => {
        if (count++ < this.limit) {
          const value = a;
          [a, b] = [b, a + b];
          return { value, done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
}

const fib = new Fibonacci(10);
for (const num of fib) {
  console.log(num);
}
// 0, 1, 1, 2, 3, 5, 8, 13, 21, 34

// 自定义可迭代对象：范围
class Range {
  constructor(start, end, step = 1) {
    this.start = start;
    this.end = end;
    this.step = step;
  }
  
  [Symbol.iterator]() {
    let current = this.start;
    
    return {
      next: () => {
        if (current <= this.end) {
          const value = current;
          current += this.step;
          return { value, done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
}

const range = new Range(1, 5);
console.log([...range]); // [1, 2, 3, 4, 5]

// 使用for...of遍历DOM集合
const divs = document.querySelectorAll('div');
for (const div of divs) {
  console.log(div.textContent);
}
```

## 6.6 实践练习

### 练习1：对象字面量增强

创建一个函数`createPerson(name, age, job)`，使用对象字面量增强特性（属性简写、方法简写、计算属性名）返回一个包含以下内容的对象：

- `name`和`age`属性使用属性简写
- `job`属性
- `introduce`方法使用方法简写，返回介绍字符串
- `id`属性使用计算属性名，值为`person_${name}_${age}`

```javascript
// 你的代码
```

### 练习2：数组方法应用

给定一个包含学生对象的数组，每个学生对象包含`id`、`name`、`score`和`active`属性，使用数组方法完成以下任务：

1. 找到第一个活跃且分数大于80的学生
2. 找到分数最高的学生的索引
3. 检查是否存在id为5的学生
4. 创建一个包含所有活跃学生分数的数组
5. 创建一个5x5的矩阵，初始值为0

```javascript
const students = [
  { id: 1, name: 'Alice', score: 85, active: true },
  { id: 2, name: 'Bob', score: 92, active: false },
  { id: 3, name: 'Charlie', score: 78, active: true },
  { id: 4, name: 'David', score: 95, active: true },
  { id: 5, name: 'Eve', score: 88, active: false }
];

// 你的代码
```

### 练习3：对象方法应用

创建一个函数`mergeConfigs(...configs)`，使用对象方法合并多个配置对象，要求：

1. 使用`Object.assign`合并所有配置
2. 确保不修改原始配置对象
3. 返回合并后的配置
4. 使用`Object.keys`、`Object.values`和`Object.entries`分别输出合并后配置的键、值和键值对

```javascript
// 你的代码
```

### 练习4：自定义迭代器

创建一个可迭代对象`PrimeNumbers`，实现以下功能：

1. 可以迭代指定范围内的所有质数
2. 使用`for...of`循环遍历质数
3. 可以使用扩展运算符转换为数组
4. 可以使用解构赋值获取前几个质数

```javascript
// 你的代码
```

## 6.7 最佳实践

### 6.7.1 对象创建与操作

1. **优先使用对象字面量**：除非需要使用构造函数或原型链，否则优先使用对象字面量创建对象。

2. **合理使用属性简写**：当属性名与变量名相同时，使用属性简写使代码更简洁。

3. **谨慎使用`Object.assign`**：注意`Object.assign`是浅拷贝，对于嵌套对象需要特别小心。

4. **使用展开运算符替代`Object.assign`**：在支持ES2018+的环境中，优先使用对象展开运算符`...`替代`Object.assign`。

```javascript
// 不推荐
const merged = Object.assign({}, obj1, obj2);

// 推荐
const merged = { ...obj1, ...obj2 };
```

### 6.7.2 数组操作

1. **使用`Array.from`替代`Array.prototype.slice.call`**：将类数组对象转换为数组时，使用`Array.from`更简洁。

```javascript
// 不推荐
const args = Array.prototype.slice.call(arguments);

// 推荐
const args = Array.from(arguments);
```

2. **使用`Array.of`替代`new Array`**：创建数组时，`Array.of`的行为更一致。

3. **优先使用`includes`替代`indexOf`**：检查数组是否包含某个元素时，`includes`更直观，且能正确处理`NaN`。

```javascript
// 不推荐
if (arr.indexOf(item) !== -1) { /* ... */ }

// 推荐
if (arr.includes(item)) { /* ... */ }
```

4. **使用`find`和`findIndex`替代手动循环**：查找数组元素时，使用`find`和`findIndex`更简洁。

### 6.7.3 迭代器与遍历

1. **优先使用`for...of`遍历**：遍历数组、字符串、Map、Set等可迭代对象时，优先使用`for...of`。

2. **合理使用解构赋值**：遍历对象或数组时，使用解构赋值使代码更简洁。

```javascript
// 遍历对象
for (const [key, value] of Object.entries(obj)) {
  console.log(`${key}: ${value}`);
}

// 遍历数组
for (const [index, value] of arr.entries()) {
  console.log(`${index}: ${value}`);
}
```

3. **自定义可迭代对象**：当需要自定义遍历逻辑时，实现`Symbol.iterator`方法使对象可迭代。

## 6.8 常见问题与解决方案

### 问题1：`Object.assign`修改了原始对象

**问题描述**：使用`Object.assign`时，不小心修改了原始对象。

**解决方案**：确保第一个参数是一个空对象，这样就不会修改任何原始对象。

```javascript
// 错误做法
const merged = Object.assign(original, updates); // original被修改

// 正确做法
const merged = Object.assign({}, original, updates); // original保持不变
```

### 问题2：`Array.from`与`Array.of`混淆

**问题描述**：混淆了`Array.from`和`Array.of`的用途。

**解决方案**：
- `Array.from`用于将类数组对象或可迭代对象转换为数组。
- `Array.of`用于创建一个包含所有参数的新数组。

```javascript
// Array.from - 从类数组对象创建数组
const arrayLike = { 0: 'a', 1: 'b', length: 2 };
const arr1 = Array.from(arrayLike); // ['a', 'b']

// Array.of - 创建包含参数的数组
const arr2 = Array.of('a', 'b'); // ['a', 'b']
```

### 问题3：`includes`与`indexOf`的选择

**问题描述**：不确定何时使用`includes`，何时使用`indexOf`。

**解决方案**：
- 只需要检查元素是否存在时，使用`includes`更直观。
- 需要知道元素位置时，使用`indexOf`。

```javascript
// 检查是否存在
if (arr.includes(item)) { /* ... */ }

// 获取位置
const index = arr.indexOf(item);
if (index !== -1) { /* ... */ }
```

### 问题4：迭代器的实现复杂

**问题描述**：实现自定义迭代器时感到困惑。

**解决方案**：理解迭代器协议和可迭代协议的区别：
- 迭代器是一个有`next()`方法的对象。
- 可迭代对象是一个有`[Symbol.iterator]`方法的对象，该方法返回一个迭代器。

```javascript
// 可迭代对象
const myIterable = {
  data: [1, 2, 3],
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.data.length) {
          return { value: this.data[index++], done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
};

// 使用for...of遍历
for (const item of myIterable) {
  console.log(item);
}
```

## 总结

ES6对对象和数组的增强极大地提升了JavaScript的表达能力和开发效率。通过本章的学习，我们了解了：

1. 对象字面量的增强特性：属性简写、方法简写和计算属性名。
2. 数组新增方法：`Array.from`、`Array.of`、`find`、`findIndex`、`fill`、`copyWithin`、`entries`、`keys`、`values`、`includes`等。
3. 对象新增方法：`Object.assign`、`Object.is`、`Object.getOwnPropertyDescriptors`、`Object.setPrototypeOf`、`Object.getPrototypeOf`、`Object.keys`、`Object.values`、`Object.entries`等。
4. 迭代器协议和可迭代协议，以及`for...of`循环的使用。
5. 这些特性在实际开发中的应用场景和最佳实践。

掌握这些特性将帮助你编写更加简洁、高效和可维护的JavaScript代码。在下一章中，我们将学习ES6中的类与继承，这将使JavaScript的面向对象编程更加直观和强大。