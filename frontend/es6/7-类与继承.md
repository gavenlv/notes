# 第7章：类与继承

ES6引入了基于原型的面向对象编程的语法糖，使JavaScript的面向对象编程更加直观和易于理解。本章将详细介绍ES6中类的语法、继承机制以及相关的面向对象编程概念。

## 7.1 类的语法与特性

### 7.1.1 类的基本语法

在ES6之前，JavaScript使用构造函数和原型链来实现面向对象编程。ES6引入了`class`关键字，提供了更简洁、更直观的语法来创建对象和处理继承。

```javascript
// ES5构造函数方式
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.sayHello = function() {
  return `Hello, my name is ${this.name} and I'm ${this.age} years old.`;
};

// ES6类方式
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHello() {
    return `Hello, my name is ${this.name} and I'm ${this.age} years old.`;
  }
}

// 使用类创建实例
const alice = new Person('Alice', 30);
console.log(alice.sayHello()); // "Hello, my name is Alice and I'm 30 years old."
```

### 7.1.2 类声明与类表达式

类可以通过两种方式定义：类声明和类表达式。

```javascript
// 类声明
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}

// 类表达式（匿名）
const Person = class {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
};

// 类表达式（命名）
const Person = class PersonClass {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  
  getClassName() {
    return PersonClass.name;
  }
};

const person = new Person('Bob', 25);
console.log(person.getClassName()); // "PersonClass"
```

### 7.1.3 类的特性

类具有以下几个重要特性：

1. **类不会被提升**：与函数声明不同，类声明不会被提升，必须先声明后使用。

```javascript
// 错误：类不会被提升
const person = new Person('Alice', 30); // ReferenceError

class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}
```

2. **类中的所有代码自动运行在严格模式下**：类中的代码默认运行在严格模式下，无需显式声明。

3. **类的方法是不可枚举的**：类中定义的方法默认不可枚举。

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
  
  sayHello() {
    return `Hello, I'm ${this.name}`;
  }
}

const person = new Person('Alice');
for (const key in person) {
  console.log(key); // 只会输出 "name"，不会输出 "sayHello"
}

console.log(Object.keys(person)); // ["name"]
console.log(Object.getOwnPropertyNames(person.__proto__)); // ["constructor", "sayHello"]
```

4. **类的方法没有[[Construct]]内部方法**：类的方法不能使用`new`关键字调用。

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
  
  sayHello() {
    return `Hello, I'm ${this.name}`;
  }
}

const person = new Person('Alice');
person.sayHello(); // 正确

// new person.sayHello(); // TypeError: person.sayHello is not a constructor
```

## 7.2 继承与super关键字

### 7.2.1 基本继承语法

ES6使用`extends`关键字实现类的继承，使子类可以继承父类的属性和方法。

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    return `${this.name} makes a noise.`;
  }
}

class Dog extends Animal {
  speak() {
    return `${this.name} barks.`;
  }
}

const dog = new Dog('Rex');
console.log(dog.speak()); // "Rex barks."
```

### 7.2.2 super关键字

`super`关键字用于调用父类的构造函数和方法。

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    return `${this.name} makes a noise.`;
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name); // 调用父类的构造函数
    this.breed = breed;
  }
  
  speak() {
    // 调用父类的speak方法
    return `${super.speak()} It's a ${this.breed}.`;
  }
  
  fetch() {
    return `${this.name} is fetching.`;
  }
}

const dog = new Dog('Rex', 'Golden Retriever');
console.log(dog.speak()); // "Rex makes a noise. It's a Golden Retriever."
console.log(dog.fetch()); // "Rex is fetching."
```

### 7.2.3 继承中的方法覆盖

子类可以覆盖父类的方法，也可以使用`super`关键字在覆盖的方法中调用父类的实现。

```javascript
class Vehicle {
  constructor(speed) {
    this.speed = speed;
  }
  
  accelerate(amount) {
    this.speed += amount;
    return `Speed increased to ${this.speed} km/h.`;
  }
  
  brake(amount) {
    this.speed = Math.max(0, this.speed - amount);
    return `Speed decreased to ${this.speed} km/h.`;
  }
}

class Car extends Vehicle {
  constructor(speed, fuel) {
    super(speed);
    this.fuel = fuel;
  }
  
  accelerate(amount) {
    // 检查燃料是否足够
    if (this.fuel <= 0) {
      return "Cannot accelerate: no fuel!";
    }
    
    // 调用父类的accelerate方法
    const result = super.accelerate(amount);
    
    // 消耗燃料
    this.fuel -= amount * 0.1;
    
    return `${result} Fuel remaining: ${this.fuel.toFixed(1)}L.`;
  }
  
  refuel(amount) {
    this.fuel += amount;
    return `Refueled. Fuel now: ${this.fuel}L.`;
  }
}

const car = new Car(0, 50);
console.log(car.accelerate(20)); // "Speed increased to 20 km/h. Fuel remaining: 48.0L."
console.log(car.accelerate(30)); // "Speed increased to 50 km/h. Fuel remaining: 45.0L."
console.log(car.brake(10)); // "Speed decreased to 40 km/h."
console.log(car.refuel(20)); // "Refueled. Fuel now: 65.0L."
```

### 7.2.4 继承中的静态方法和属性

子类可以继承父类的静态方法和属性，也可以覆盖它们。

```javascript
class Shape {
  static count = 0;
  
  constructor() {
    Shape.count++;
  }
  
  static getCount() {
    return `Total shapes created: ${Shape.count}`;
  }
  
  area() {
    throw new Error('Must implement area method');
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }
  
  area() {
    return Math.PI * this.radius ** 2;
  }
  
  static getCircleCount() {
    // 调用父类的静态方法
    return `${super.getCount()} (including circles)`;
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }
  
  area() {
    return this.width * this.height;
  }
}

const circle = new Circle(5);
const rectangle = new Rectangle(4, 6);

console.log(Shape.getCount()); // "Total shapes created: 2"
console.log(Circle.getCircleCount()); // "Total shapes created: 2 (including circles)"
console.log(circle.area()); // 78.53981633974483
console.log(rectangle.area()); // 24
```

## 7.3 静态方法与属性

### 7.3.1 静态方法

静态方法是定义在类本身上的方法，而不是类的实例上。它们使用`static`关键字定义。

```javascript
class MathUtils {
  static add(a, b) {
    return a + b;
  }
  
  static multiply(a, b) {
    return a * b;
  }
  
  // 静态方法可以调用其他静态方法
  static power(base, exponent) {
    let result = 1;
    for (let i = 0; i < exponent; i++) {
      result = this.multiply(result, base);
    }
    return result;
  }
  
  // 静态方法不能访问实例属性或方法
  static getPi() {
    // return this.radius; // 错误：静态方法不能访问实例属性
    return Math.PI;
  }
}

// 调用静态方法
console.log(MathUtils.add(5, 3)); // 8
console.log(MathUtils.multiply(4, 6)); // 24
console.log(MathUtils.power(2, 3)); // 8
console.log(MathUtils.getPi()); // 3.141592653589793

const math = new MathUtils();
// math.add(5, 3); // 错误：实例不能调用静态方法
```

### 7.3.2 静态属性

ES6引入了静态属性的定义方式，使用`static`关键字定义。

```javascript
class Counter {
  static count = 0;
  
  constructor() {
    Counter.count++;
  }
  
  static getCount() {
    return Counter.count;
  }
  
  static reset() {
    Counter.count = 0;
  }
}

const counter1 = new Counter();
const counter2 = new Counter();
const counter3 = new Counter();

console.log(Counter.getCount()); // 3
console.log(Counter.count); // 3

Counter.reset();
console.log(Counter.getCount()); // 0
```

### 7.3.3 静态块

ES2022引入了静态初始化块（static block），用于在类定义时执行静态初始化代码。

```javascript
class DatabaseConnection {
  static connectionPool = [];
  static maxConnections = 5;
  
  static {
    // 静态初始化块
    console.log('Initializing database connection pool...');
    
    // 初始化连接池
    for (let i = 0; i < this.maxConnections; i++) {
      this.connectionPool.push({
        id: i,
        active: false,
        created: new Date()
      });
    }
    
    console.log(`Database connection pool initialized with ${this.connectionPool.length} connections.`);
  }
  
  static getConnection() {
    const connection = this.connectionPool.find(conn => !conn.active);
    
    if (connection) {
      connection.active = true;
      return connection;
    }
    
    throw new Error('No available connections in the pool');
  }
  
  static releaseConnection(connectionId) {
    const connection = this.connectionPool.find(conn => conn.id === connectionId);
    
    if (connection) {
      connection.active = false;
      return true;
    }
    
    return false;
  }
}

// 输出: "Initializing database connection pool..."
// 输出: "Database connection pool initialized with 5 connections."

const conn1 = DatabaseConnection.getConnection();
console.log(`Connection ${conn1.id} acquired`);

DatabaseConnection.releaseConnection(conn1.id);
console.log(`Connection ${conn1.id} released`);
```

## 7.4 私有字段与方法

### 7.4.1 私有字段

ES2022引入了私有字段（private fields）的概念，使用`#`前缀定义私有字段，只能在类的内部访问。

```javascript
class BankAccount {
  #balance = 0; // 私有字段
  #transactions = []; // 私有字段
  
  constructor(initialBalance) {
    if (initialBalance > 0) {
      this.#balance = initialBalance;
    }
  }
  
  deposit(amount) {
    if (amount <= 0) {
      throw new Error('Deposit amount must be positive');
    }
    
    this.#balance += amount;
    this.#transactions.push({
      type: 'deposit',
      amount,
      timestamp: new Date()
    });
    
    return this.#balance;
  }
  
  withdraw(amount) {
    if (amount <= 0) {
      throw new Error('Withdrawal amount must be positive');
    }
    
    if (amount > this.#balance) {
      throw new Error('Insufficient funds');
    }
    
    this.#balance -= amount;
    this.#transactions.push({
      type: 'withdrawal',
      amount,
      timestamp: new Date()
    });
    
    return this.#balance;
  }
  
  getBalance() {
    return this.#balance;
  }
  
  getTransactionHistory() {
    // 返回交易历史的副本，防止外部修改
    return [...this.#transactions];
  }
}

const account = new BankAccount(100);
account.deposit(50);
account.withdraw(30);

console.log(account.getBalance()); // 120
console.log(account.getTransactionHistory()); // 交易历史数组

// account.#balance; // 语法错误：私有字段只能在类内部访问
// account.#transactions; // 语法错误：私有字段只能在类内部访问
```

### 7.4.2 私有方法

私有方法使用`#`前缀定义，只能在类的内部调用。

```javascript
class DataProcessor {
  #data = [];
  #errors = [];
  
  constructor(data) {
    this.#data = data;
  }
  
  process() {
    try {
      this.#validate();
      this.#transform();
      this.#save();
      return { success: true, data: this.#data };
    } catch (error) {
      this.#errors.push(error);
      return { success: false, errors: this.#errors };
    }
  }
  
  // 私有方法：验证数据
  #validate() {
    if (!Array.isArray(this.#data)) {
      throw new Error('Data must be an array');
    }
    
    if (this.#data.length === 0) {
      throw new Error('Data array cannot be empty');
    }
  }
  
  // 私有方法：转换数据
  #transform() {
    this.#data = this.#data.map(item => {
      if (typeof item === 'string') {
        return item.trim().toLowerCase();
      }
      return item;
    });
  }
  
  // 私有方法：保存数据
  #save() {
    // 模拟保存操作
    console.log('Data saved successfully');
  }
}

const processor = new DataProcessor(['  Item 1  ', 'ITEM 2', 'Item 3']);
const result = processor.process();

console.log(result); // { success: true, data: ['item 1', 'item 2', 'item 3'] }

// processor.#validate(); // 语法错误：私有方法只能在类内部调用
```

### 7.4.3 私有字段的继承

私有字段不会被继承，子类无法访问父类的私有字段。

```javascript
class Parent {
  #privateField = 'parent private';
  publicField = 'parent public';
  
  getPrivateField() {
    return this.#privateField;
  }
}

class Child extends Parent {
  #privateField = 'child private';
  publicField = 'child public';
  
  getChildPrivateField() {
    return this.#privateField;
  }
  
  // 尝试访问父类的私有字段
  // getParentPrivateField() {
  //   return this.#privateField; // 错误：无法访问父类的私有字段
  // }
}

const child = new Child();
console.log(child.getChildPrivateField()); // "child private"
console.log(child.getPrivateField()); // "parent private"
console.log(child.publicField); // "child public"
```

## 7.5 实际应用场景

### 7.5.1 组件系统

类在构建组件系统中非常有用，可以创建可重用的UI组件。

```javascript
class Component {
  constructor(element, options = {}) {
    this.element = element;
    this.options = { ...this.defaultOptions, ...options };
    this.state = {};
    this.init();
  }
  
  get defaultOptions() {
    return {
      className: 'component',
      visible: true
    };
  }
  
  init() {
    this.element.classList.add(this.options.className);
    this.render();
    this.bindEvents();
  }
  
  render() {
    // 默认渲染逻辑
    this.element.style.display = this.options.visible ? 'block' : 'none';
  }
  
  bindEvents() {
    // 默认事件绑定
  }
  
  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.render();
  }
  
  show() {
    this.options.visible = true;
    this.render();
  }
  
  hide() {
    this.options.visible = false;
    this.render();
  }
  
  destroy() {
    this.element.remove();
  }
}

class Button extends Component {
  get defaultOptions() {
    return {
      ...super.defaultOptions,
      className: 'btn',
      text: 'Button',
      onClick: null
    };
  }
  
  render() {
    super.render();
    this.element.textContent = this.options.text;
  }
  
  bindEvents() {
    if (this.options.onClick) {
      this.element.addEventListener('click', this.options.onClick);
    }
  }
  
  setText(text) {
    this.options.text = text;
    this.render();
  }
}

class Modal extends Component {
  constructor(element, options = {}) {
    super(element, options);
    this.overlay = document.createElement('div');
    this.overlay.className = 'modal-overlay';
    document.body.appendChild(this.overlay);
  }
  
  get defaultOptions() {
    return {
      ...super.defaultOptions,
      className: 'modal',
      closeOnOverlay: true,
      showCloseButton: true
    };
  }
  
  render() {
    super.render();
    
    // 添加关闭按钮
    if (this.options.showCloseButton && !this.closeButton) {
      this.closeButton = document.createElement('button');
      this.closeButton.className = 'modal-close';
      this.closeButton.textContent = '×';
      this.element.appendChild(this.closeButton);
      
      this.closeButton.addEventListener('click', () => this.hide());
    }
    
    // 更新覆盖层显示状态
    this.overlay.style.display = this.options.visible ? 'block' : 'none';
  }
  
  bindEvents() {
    if (this.options.closeOnOverlay) {
      this.overlay.addEventListener('click', () => this.hide());
    }
  }
  
  hide() {
    this.options.visible = false;
    this.render();
  }
  
  destroy() {
    super.destroy();
    this.overlay.remove();
  }
}

// 使用示例
const buttonElement = document.createElement('button');
document.body.appendChild(buttonElement);

const button = new Button(buttonElement, {
  text: 'Click me',
  onClick: () => {
    modal.show();
  }
});

const modalElement = document.createElement('div');
document.body.appendChild(modalElement);

const modal = new Modal(modalElement, {
  showCloseButton: true,
  closeOnOverlay: true
});
```

### 7.5.2 数据模型

类可以用于创建数据模型，封装数据操作和业务逻辑。

```javascript
class UserModel {
  #id;
  #name;
  #email;
  #createdAt;
  #updatedAt;
  
  constructor({ id, name, email }) {
    this.#id = id || this.#generateId();
    this.#name = name;
    this.#email = email;
    this.#createdAt = new Date();
    this.#updatedAt = new Date();
  }
  
  // 私有方法：生成ID
  #generateId() {
    return Math.random().toString(36).substr(2, 9);
  }
  
  // 私有方法：验证邮箱
  #validateEmail(email) {
    const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return re.test(email);
  }
  
  // 公共方法：获取用户信息
  getInfo() {
    return {
      id: this.#id,
      name: this.#name,
      email: this.#email,
      createdAt: this.#createdAt,
      updatedAt: this.#updatedAt
    };
  }
  
  // 公共方法：更新用户名
  updateName(newName) {
    if (!newName || newName.trim() === '') {
      throw new Error('Name cannot be empty');
    }
    
    this.#name = newName.trim();
    this.#updatedAt = new Date();
    return this.getInfo();
  }
  
  // 公共方法：更新邮箱
  updateEmail(newEmail) {
    if (!this.#validateEmail(newEmail)) {
      throw new Error('Invalid email format');
    }
    
    this.#email = newEmail;
    this.#updatedAt = new Date();
    return this.getInfo();
  }
  
  // 静态方法：从API响应创建用户实例
  static fromApiResponse(data) {
    return new UserModel({
      id: data.id,
      name: data.name,
      email: data.email
    });
  }
  
  // 静态方法：验证用户数据
  static validateUserData(data) {
    const errors = [];
    
    if (!data.name || data.name.trim() === '') {
      errors.push('Name is required');
    }
    
    if (!data.email) {
      errors.push('Email is required');
    } else {
      const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!re.test(data.email)) {
        errors.push('Invalid email format');
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

// 使用示例
const user = new UserModel({
  name: 'John Doe',
  email: 'john@example.com'
});

console.log(user.getInfo());
// 更新用户信息
user.updateName('Jane Doe');
user.updateEmail('jane@example.com');
console.log(user.getInfo());

// 从API响应创建用户
const apiResponse = {
  id: 'user123',
  name: 'API User',
  email: 'api@example.com'
};

const apiUser = UserModel.fromApiResponse(apiResponse);
console.log(apiUser.getInfo());

// 验证用户数据
const userData = {
  name: '',
  email: 'invalid-email'
};

const validation = UserModel.validateUserData(userData);
console.log(validation.isValid); // false
console.log(validation.errors); // ["Name is required", "Invalid email format"]
```

## 7.6 实践练习

### 练习1：创建一个简单的游戏角色类

创建一个`Character`类，包含以下功能：
- 属性：name（名字）、health（生命值）、attack（攻击力）
- 方法：attack(target)（攻击目标）、takeDamage(amount)（受到伤害）、isAlive()（是否存活）
- 静态属性：charactersCount（角色总数）
- 私有字段：#id（唯一标识符）

然后创建一个继承自`Character`的`Warrior`（战士）类，增加以下功能：
- 额外属性：armor（护甲值）
- 重写takeDamage方法，考虑护甲值减少伤害
- 新增方法：rage()（狂暴，临时增加攻击力）

### 练习2：实现一个简单的表单验证器类

创建一个`FormValidator`类，用于验证表单数据：
- 构造函数接收表单元素和验证规则
- 方法：validate()（验证表单）、showErrors()（显示错误）、clearErrors()（清除错误）
- 私有方法：#validateField(field, rules)（验证单个字段）
- 私有字段：#errors（存储错误信息）

然后创建一个继承自`FormValidator`的`LoginFormValidator`类，专门用于登录表单验证：
- 添加特定的验证规则（邮箱格式、密码长度等）
- 重写showErrors方法，提供更友好的错误提示

### 练习3：实现一个简单的数据缓存类

创建一个`Cache`类，用于缓存数据：
- 私有字段：#data（存储缓存数据）、#maxSize（最大缓存大小）、#ttl（生存时间）
- 方法：set(key, value, ttl)（设置缓存）、get(key)（获取缓存）、delete(key)（删除缓存）、clear()（清空缓存）
- 私有方法：#isExpired(key)（检查缓存是否过期）、#evictOldest()（淘汰最旧的缓存）
- 静态方法：createLRUCache(maxSize)（创建LRU缓存）

然后创建一个继承自`Cache`的`AsyncCache`类，支持异步数据加载：
- 新增方法：getAsync(key, loader)（异步获取数据，如果缓存不存在则使用loader函数加载）
- 重写get方法，支持Promise类型的值

## 7.7 最佳实践

### 7.7.1 类设计原则

1. **单一职责原则**：每个类应该只有一个引起变化的原因。

```javascript
// 好的设计：每个类有明确的职责
class User {
  constructor(id, name, email) {
    this.id = id;
    this.name = name;
    this.email = email;
  }
  
  updateProfile(newData) {
    // 更新用户信息的逻辑
  }
}

class UserRepository {
  save(user) {
    // 保存用户到数据库的逻辑
  }
  
  findById(id) {
    // 从数据库查找用户的逻辑
  }
}

class UserValidator {
  validate(user) {
    // 验证用户数据的逻辑
  }
}

// 不好的设计：一个类承担了太多职责
class User {
  constructor(id, name, email) {
    this.id = id;
    this.name = name;
    this.email = email;
  }
  
  updateProfile(newData) {
    // 更新用户信息的逻辑
  }
  
  save() {
    // 保存用户到数据库的逻辑
  }
  
  findById(id) {
    // 从数据库查找用户的逻辑
  }
  
  validate() {
    // 验证用户数据的逻辑
  }
}
```

2. **开闭原则**：对扩展开放，对修改关闭。

```javascript
// 好的设计：使用继承和组合扩展功能
class Shape {
  area() {
    throw new Error('Must implement area method');
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }
  
  area() {
    return Math.PI * this.radius ** 2;
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }
  
  area() {
    return this.width * this.height;
  }
}

// 不好的设计：修改现有类来添加新功能
class Shape {
  constructor(type) {
    this.type = type;
  }
  
  area() {
    if (this.type === 'circle') {
      return Math.PI * this.radius ** 2;
    } else if (this.type === 'rectangle') {
      return this.width * this.height;
    }
    // 每次添加新形状都需要修改这个类
  }
}
```

3. **里氏替换原则**：子类应该能够替换父类而不影响程序的正确性。

```javascript
// 好的设计：子类可以完全替代父类
class Bird {
  fly() {
    return "Flying in the sky";
  }
}

class Sparrow extends Bird {
  fly() {
    return "Sparrow flying in the sky";
  }
}

// 不好的设计：子类不能完全替代父类
class Bird {
  fly() {
    return "Flying in the sky";
  }
}

class Penguin extends Bird {
  fly() {
    throw new Error("Penguins can't fly");
  }
}
```

### 7.7.2 使用私有字段封装内部状态

```javascript
// 好的设计：使用私有字段封装内部状态
class Counter {
  #count = 0;
  
  increment() {
    this.#count++;
    return this.#count;
  }
  
  decrement() {
    this.#count--;
    return this.#count;
  }
  
  getCount() {
    return this.#count;
  }
}

// 不好的设计：暴露内部状态
class Counter {
  count = 0;
  
  increment() {
    this.count++;
    return this.count;
  }
  
  decrement() {
    this.count--;
    return this.count;
  }
}

const counter = new Counter();
counter.count = 100; // 可以直接修改内部状态，破坏封装性
```

### 7.7.3 使用组合而非继承

```javascript
// 好的设计：使用组合实现功能
class Logger {
  log(message) {
    console.log(`[LOG] ${message}`);
  }
}

class Database {
  save(data) {
    console.log(`Saving data: ${JSON.stringify(data)}`);
  }
}

class UserService {
  constructor() {
    this.logger = new Logger();
    this.database = new Database();
  }
  
  createUser(userData) {
    this.logger.log('Creating new user');
    this.database.save(userData);
  }
}

// 不好的设计：过度使用继承
class BaseService {
  log(message) {
    console.log(`[LOG] ${message}`);
  }
  
  save(data) {
    console.log(`Saving data: ${JSON.stringify(data)}`);
  }
}

class UserService extends BaseService {
  createUser(userData) {
    this.log('Creating new user');
    this.save(userData);
  }
}

class ProductService extends BaseService {
  createProduct(productData) {
    this.log('Creating new product');
    this.save(productData);
  }
}
```

## 7.8 常见问题与解决方案

### 7.8.1 类与构造函数的区别

**问题**：ES6的类与ES5的构造函数有什么区别？

**解决方案**：
1. 类不会被提升，而函数声明会被提升
2. 类中的所有代码自动运行在严格模式下
3. 类的方法是不可枚举的
4. 类的方法没有[[Construct]]内部方法，不能使用`new`关键字调用
5. 类必须使用`new`关键字调用，而构造函数可以不使用`new`调用

```javascript
// 类不会被提升
// const person = new Person(); // ReferenceError

class Person {
  constructor(name) {
    this.name = name;
  }
}

// 函数声明会被提升
const person = new Person('Alice'); // 正常工作

function Person(name) {
  this.name = name;
}
```

### 7.8.2 如何实现多重继承

**问题**：JavaScript的类只支持单继承，如何实现多重继承？

**解决方案**：使用混入（Mixin）模式或组合模式。

```javascript
// 使用混入模式实现多重继承
const CanFly = {
  fly() {
    return `${this.name} is flying`;
  }
};

const CanSwim = {
  swim() {
    return `${this.name} is swimming`;
  }
};

function mix(...mixins) {
  return function(target) {
    Object.assign(target.prototype, ...mixins);
    return target;
  };
}

@mix(CanFly, CanSwim)
class Duck {
  constructor(name) {
    this.name = name;
  }
}

const duck = new Duck('Donald');
console.log(duck.fly()); // "Donald is flying"
console.log(duck.swim()); // "Donald is swimming"

// 使用组合模式实现多重继承
class FlyBehavior {
  fly() {
    return `${this.name} is flying`;
  }
}

class SwimBehavior {
  swim() {
    return `${this.name} is swimming`;
  }
}

class Duck {
  constructor(name) {
    this.name = name;
    this.flyBehavior = new FlyBehavior();
    this.swimBehavior = new SwimBehavior();
  }
  
  fly() {
    return this.flyBehavior.fly.call(this);
  }
  
  swim() {
    return this.swimBehavior.swim.call(this);
  }
}

const duck = new Duck('Donald');
console.log(duck.fly()); // "Donald is flying"
console.log(duck.swim()); // "Donald is swimming"
```

### 7.8.3 如何实现抽象类

**问题**：JavaScript没有内置的抽象类，如何实现抽象类？

**解决方案**：使用构造函数检查或使用new.target。

```javascript
// 使用构造函数检查实现抽象类
class Shape {
  constructor() {
    if (new.target === Shape) {
      throw new Error('Cannot instantiate abstract class');
    }
  }
  
  area() {
    throw new Error('Must implement area method');
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }
  
  area() {
    return Math.PI * this.radius ** 2;
  }
}

// const shape = new Shape(); // 错误：不能实例化抽象类
const circle = new Circle(5);
console.log(circle.area()); // 78.53981633974483

// 使用抽象方法标记
class Shape {
  constructor() {
    if (new.target === Shape) {
      throw new Error('Cannot instantiate abstract class');
    }
    
    // 检查是否实现了所有抽象方法
    const abstractMethods = ['area', 'perimeter'];
    for (const method of abstractMethods) {
      if (typeof this[method] !== 'function') {
        throw new Error(`Must implement ${method} method`);
      }
    }
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }
  
  area() {
    return Math.PI * this.radius ** 2;
  }
  
  // 忘记实现perimeter方法
}

// const circle = new Circle(5); // 错误：必须实现perimeter方法
```

### 7.8.4 如何实现私有方法的继承

**问题**：私有方法不能被子类访问，如何在子类中调用父类的私有方法？

**解决方案**：使用受保护的（protected）方法模式，通过命名约定或使用getter方法。

```javascript
// 使用命名约定实现受保护方法
class Parent {
  constructor() {
    this._protectedMethod = this._protectedMethod.bind(this);
  }
  
  // 使用下划线前缀表示受保护的方法
  _protectedMethod() {
    return 'Protected method from parent';
  }
  
  publicMethod() {
    return this._protectedMethod();
  }
}

class Child extends Parent {
  childMethod() {
    return this._protectedMethod(); // 可以访问受保护的方法
  }
}

const child = new Child();
console.log(child.childMethod()); // "Protected method from parent"

// 使用getter方法实现受保护方法
class Parent {
  constructor() {
    this._protectedMethod = this._protectedMethod.bind(this);
  }
  
  _protectedMethod() {
    return 'Protected method from parent';
  }
  
  get protectedMethod() {
    return this._protectedMethod.bind(this);
  }
  
  publicMethod() {
    return this.protectedMethod();
  }
}

class Child extends Parent {
  childMethod() {
    return this.protectedMethod; // 通过getter访问受保护的方法
  }
}

const child = new Child();
console.log(child.childMethod()); // "Protected method from parent"
```

## 总结

ES6的类语法为JavaScript提供了更直观、更易读的面向对象编程方式。通过类，我们可以更清晰地组织代码，实现继承和封装。私有字段和方法的引入进一步增强了封装性，使我们可以更好地控制类的内部状态。

在实际开发中，合理使用类可以大大提高代码的可维护性和可扩展性。但也要注意，类并不是解决所有问题的银弹，有时候简单的函数或对象字面量可能更合适。选择合适的编程范式和设计模式，才能写出高质量的JavaScript代码。