# 第3章：箭头函数与函数增强

## 3.1 箭头函数语法与特性

### 3.1.1 传统函数与箭头函数的对比

在ES6之前，JavaScript中定义函数主要有两种方式：函数声明和函数表达式。ES6引入了箭头函数，它提供了一种更简洁的函数书写方式。

```javascript
// 传统函数声明
function add(a, b) {
  return a + b;
}

// 函数表达式
const multiply = function(a, b) {
  return a * b;
};

// ES6箭头函数
const subtract = (a, b) => {
  return a - b;
};

// 简化形式（当函数体只有一条返回语句时）
const divide = (a, b) => a / b;
```

### 3.1.2 箭头函数的语法规则

箭头函数有几种不同的语法形式：

```javascript
// 1. 基本语法
const greet = (name) => {
  return `Hello, ${name}!`;
};

// 2. 单参数时可省略括号
const sayHello = name => `Hello, ${name}!`;

// 3. 无参数时必须使用括号
const getRandom = () => Math.random();

// 4. 多参数时必须使用括号
const add = (a, b) => a + b;

// 5. 函数体有多条语句时必须使用大括号
const calculate = (a, b) => {
  const sum = a + b;
  const difference = a - b;
  return { sum, difference };
};

// 6. 返回对象字面量时需要用括号包裹
const createUser = (name, age) => ({ name, age });
```

### 3.1.3 箭头函数的特点

1. **更简洁的语法**：减少了代码量，提高了可读性
2. **没有自己的this**：不绑定自己的this，会捕获其所在上下文的this值
3. **不能作为构造函数**：不能使用new关键字调用
4. **没有arguments对象**：可以通过剩余参数获取所有参数
5. **没有prototype属性**：不能用作构造函数，因此没有prototype

```javascript
// 箭头函数没有自己的this
const person = {
  name: 'Alice',
  age: 30,
  
  // 传统函数中的this指向调用者
  sayNameTraditional: function() {
    console.log(this.name); // 'Alice'
    setTimeout(function() {
      console.log(this.name); // undefined (在浏览器中可能是window.name)
    }, 100);
  },
  
  // 箭头函数中的this继承自外层作用域
  sayNameArrow: function() {
    console.log(this.name); // 'Alice'
    setTimeout(() => {
      console.log(this.name); // 'Alice' (继承自外层作用域)
    }, 100);
  }
};

person.sayNameTraditional();
person.sayNameArrow();
```

## 3.2 this绑定规则变化

### 3.2.1 传统函数中的this

在传统函数中，this的值取决于函数的调用方式：

1. **作为对象方法调用**：this指向该对象
2. **作为普通函数调用**：在非严格模式下指向全局对象（window），严格模式下为undefined
3. **使用call/apply/bind调用**：this指向指定的对象
4. **作为构造函数调用**：this指向新创建的对象

```javascript
// 1. 作为对象方法调用
const obj = {
  name: 'Object',
  getName: function() {
    return this.name;
  }
};
console.log(obj.getName()); // 'Object'

// 2. 作为普通函数调用
function getName() {
  return this.name;
}
const name = 'Global';
console.log(getName()); // 'Global' (非严格模式)

// 3. 使用call/apply/bind
const anotherObj = { name: 'Another' };
console.log(getName.call(anotherObj)); // 'Another'
const boundGetName = getName.bind(anotherObj);
console.log(boundGetName()); // 'Another'

// 4. 作为构造函数调用
function Person(name) {
  this.name = name;
}
const person = new Person('John');
console.log(person.name); // 'John'
```

### 3.2.2 箭头函数中的this

箭头函数没有自己的this，它会捕获其定义时所在上下文的this值，并且这个值在整个函数生命周期内保持不变。

```javascript
// 箭头函数捕获定义时的this
const obj = {
  name: 'Object',
  
  // 箭头函数作为对象方法
  getName: () => {
    return this.name; // this不是obj，而是外层作用域的this
  },
  
  // 混合使用
  init: function() {
    // 这里的this指向obj
    console.log(this.name); // 'Object'
    
    // 箭头函数继承了外层的this
    const arrowFunc = () => {
      console.log(this.name); // 'Object'
    };
    arrowFunc();
    
    // 传统函数有自己的this
    const regularFunc = function() {
      console.log(this.name); // undefined (非严格模式下可能是window.name)
    };
    regularFunc();
  }
};

console.log(obj.getName()); // undefined (在浏览器中可能是window.name)
obj.init();
```

### 3.2.3 实际应用场景

箭头函数特别适合解决回调函数中的this问题：

```javascript
// 传统方法解决回调中的this问题
const timer = {
  seconds: 0,
  
  start: function() {
    var self = this; // 保存this引用
    
    setInterval(function() {
      self.seconds++;
      console.log(self.seconds);
    }, 1000);
  },
  
  // 使用bind方法
  startWithBind: function() {
    setInterval(function() {
      this.seconds++;
      console.log(this.seconds);
    }.bind(this), 1000);
  }
};

// 使用箭头函数的简洁解决方案
const modernTimer = {
  seconds: 0,
  
  start: function() {
    setInterval(() => {
      this.seconds++; // this继承自外层作用域
      console.log(this.seconds);
    }, 1000);
  }
};

modernTimer.start();
```

## 3.3 默认参数

### 3.3.1 传统默认参数处理方式

在ES6之前，处理函数默认参数通常使用逻辑或运算符：

```javascript
// 传统默认参数处理
function greet(name) {
  name = name || 'Guest';
  console.log('Hello, ' + name + '!');
}

// 更精确的检查
function greetStrict(name) {
  if (typeof name === 'undefined') {
    name = 'Guest';
  }
  console.log('Hello, ' + name + '!');
}

// 问题：当传入有效但可转换为false的值时
greet(); // 'Hello, Guest!'
greet(undefined); // 'Hello, Guest!'
greet(null); // 'Hello, Guest!' (可能不是期望的结果)
greet(0); // 'Hello, Guest!' (不是期望的结果)
greet(''); // 'Hello, Guest!' (不是期望的结果)
```

### 3.3.2 ES6默认参数语法

ES6引入了更直观的默认参数语法：

```javascript
// ES6默认参数
function greet(name = 'Guest') {
  console.log(`Hello, ${name}!`);
}

greet(); // 'Hello, Guest!'
greet(undefined); // 'Hello, Guest!'
greet(null); // 'Hello, null!' (null是有效值)
greet(0); // 'Hello, 0!'
greet(''); // 'Hello, !'

// 多个默认参数
function createPerson(name = 'Anonymous', age = 0, isActive = true) {
  return { name, age, isActive };
}

console.log(createPerson()); // { name: 'Anonymous', age: 0, isActive: true }
console.log(createPerson('Alice')); // { name: 'Alice', age: 0, isActive: true }
console.log(createPerson('Bob', 30)); // { name: 'Bob', age: 30, isActive: true }
console.log(createPerson('Charlie', 40, false)); // { name: 'Charlie', age: 40, isActive: false }
```

### 3.3.3 默认参数的高级用法

默认参数可以使用表达式，甚至可以使用前面定义的参数：

```javascript
// 使用表达式作为默认值
function getRandomNumber(max = Math.random() * 100) {
  return Math.floor(max);
}

console.log(getRandomNumber()); // 随机数
console.log(getRandomNumber(50)); // 0-50之间的随机数

// 使用前面定义的参数作为后面参数的默认值
function createRectangle(width = 10, height = width) {
  return { width, height, area: width * height };
}

console.log(createRectangle()); // { width: 10, height: 10, area: 100 }
console.log(createRectangle(5)); // { width: 5, height: 5, area: 25 }
console.log(createRectangle(5, 8)); // { width: 5, height: 8, area: 40 }

// 使用函数作为默认值
function getValue() {
  console.log('getValue called');
  return 10;
}

function add(a = getValue(), b = 20) {
  return a + b;
}

console.log(add()); // 输出 'getValue called' 然后输出 30
console.log(add(5)); // 25 (getValue不会被调用)
console.log(add(5, 15)); // 20 (getValue不会被调用)
```

## 3.4 剩余参数与扩展运算符

### 3.4.1 剩余参数（Rest Parameters）

剩余参数语法允许我们将一个不定数量的参数表示为一个数组。

```javascript
// 基本语法
function sum(...numbers) {
  return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3)); // 6
console.log(sum(1, 2, 3, 4, 5)); // 15
console.log(sum()); // 0

// 与普通参数混合使用
function greet(greeting, ...names) {
  names.forEach(name => {
    console.log(`${greeting}, ${name}!`);
  });
}

greet('Hello', 'Alice', 'Bob', 'Charlie');
// 输出:
// Hello, Alice!
// Hello, Bob!
// Hello, Charlie!

// 剩余参数必须是最后一个参数
// 错误示例
// function invalid(...rest, last) {} // 语法错误

// 箭头函数中的剩余参数
const multiply = (...numbers) => numbers.reduce((product, num) => product * num, 1);
console.log(multiply(2, 3, 4)); // 24
```

### 3.4.2 扩展运算符（Spread Operator）

扩展运算符是剩余参数的逆操作，它允许将一个数组或类数组对象"展开"成独立的参数。

```javascript
// 函数调用中的扩展运算符
const numbers = [1, 2, 3];
console.log(Math.max(...numbers)); // 3
console.log(Math.min(...numbers)); // 1

// 数组合并
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2];
console.log(combined); // [1, 2, 3, 4, 5, 6]

// 在数组中间插入元素
const parts = ['shoulders', 'knees'];
const body = ['head', ...parts, 'and', 'toes'];
console.log(body); // ['head', 'shoulders', 'knees', 'and', 'toes']

// 对象扩展运算符（ES2018）
const person = { name: 'Alice', age: 30 };
const employee = { ...person, position: 'Developer' };
console.log(employee); // { name: 'Alice', age: 30, position: 'Developer' }

// 覆盖属性
const updatedPerson = { ...person, age: 31 };
console.log(updatedPerson); // { name: 'Alice', age: 31 }
```

### 3.4.3 实际应用场景

```javascript
// 1. 函数参数处理
function log(level, message, ...data) {
  console.log(`[${level}] ${message}`, ...data);
}

log('INFO', 'User logged in', { id: 123, name: 'Alice' });

// 2. 数组操作
// 复制数组
const original = [1, 2, 3];
const copy = [...original];

// 添加元素
const withNewElement = [...original, 4];
console.log(withNewElement); // [1, 2, 3, 4]

// 在开头添加元素
const withElementAtStart = [0, ...original];
console.log(withElementAtStart); // [0, 1, 2, 3]

// 3. 对象操作
// 浅拷贝对象
const user = { name: 'Bob', age: 25 };
const userCopy = { ...user };

// 合并对象
const defaults = { theme: 'light', fontSize: 16 };
const userSettings = { theme: 'dark' };
const finalSettings = { ...defaults, ...userSettings };
console.log(finalSettings); // { theme: 'dark', fontSize: 16 }

// 4. 解构与剩余参数
const [first, second, ...rest] = [1, 2, 3, 4, 5];
console.log(first); // 1
console.log(second); // 2
console.log(rest); // [3, 4, 5]

const { name, ...otherProps } = { name: 'Alice', age: 30, city: 'New York' };
console.log(name); // 'Alice'
console.log(otherProps); // { age: 30, city: 'New York' }
```

## 3.5 函数增强的其他特性

### 3.5.1 函数参数的尾逗号

ES6允许在函数参数列表的末尾添加尾逗号，这在版本控制系统中特别有用：

```javascript
// 传统方式
function createUser(name, age, email) {
  return { name, age, email };
}

// 使用尾逗号
function createUserWithComma(
  name,
  age,
  email,  // 添加这个逗号使得在版本控制中添加新参数时差异更清晰
) {
  return { name, age, email };
}

// 调用时也可以使用尾逗号
createUserWithComma(
  'Alice',
  30,
  'alice@example.com',  // 添加这个逗号使得添加新参数时差异更清晰
);
```

### 3.5.2 函数的name属性

ES6为所有函数添加了name属性，可以获取函数的名称：

```javascript
// 函数声明
function myFunction() {}
console.log(myFunction.name); // 'myFunction'

// 函数表达式
const myFunc = function() {};
console.log(myFunc.name); // 'myFunc'

// 箭头函数
const arrowFunc = () => {};
console.log(arrowFunc.name); // 'arrowFunc'

// 对象方法
const obj = {
  myMethod() {},
  anotherMethod: function() {}
};
console.log(obj.myMethod.name); // 'myMethod'
console.log(obj.anotherMethod.name); // 'anotherMethod'

// 构造函数
function Person() {}
const p = new Person();
console.log(p.constructor.name); // 'Person'

// 匿名函数的推断名称
const obj2 = {
  'some-prop': function() {}
};
console.log(obj2['some-prop'].name); // 'some-prop'
```

## 3.6 实践练习

### 3.6.1 练习1：使用箭头函数重构代码

将以下传统函数转换为箭头函数：

```javascript
// 原始代码
function doubleNumbers(numbers) {
  return numbers.map(function(num) {
    return num * 2;
  });
}

function filterEvenNumbers(numbers) {
  return numbers.filter(function(num) {
    return num % 2 === 0;
  });
}

function sumNumbers(numbers) {
  return numbers.reduce(function(sum, num) {
    return sum + num;
  }, 0);
}
```

### 3.6.2 练习2：使用默认参数和剩余参数

创建一个函数，可以接受任意数量的数字参数，并返回它们的平均值。如果没有提供参数，则返回0。

### 3.6.3 练习3：解决this绑定问题

以下代码中的setTimeout回调函数无法访问正确的this值。请使用箭头函数修复这个问题：

```javascript
const counter = {
  count: 0,
  start: function() {
    setInterval(function() {
      this.count++;
      console.log(this.count);
    }, 1000);
  }
};

counter.start();
```

## 3.7 最佳实践

### 3.7.1 何时使用箭头函数

**适合使用箭头函数的场景：**

1. **回调函数**：特别是需要保留外层this的回调
2. **数组方法**：map、filter、reduce等
3. **简短的单行函数**：提高代码可读性

```javascript
// 好的实践
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(num => num * 2);
const evens = numbers.filter(num => num % 2 === 0);

// 事件处理器
document.getElementById('button').addEventListener('click', () => {
  // this指向外层作用域
  this.doSomething();
});
```

**不适合使用箭头函数的场景：**

1. **对象方法**：需要使用this引用对象本身
2. **构造函数**：箭头函数不能用作构造函数
3. **需要使用arguments对象的函数**
4. **需要动态this的函数**：如事件处理器中的this需要指向触发元素

```javascript
// 不好的实践
const person = {
  name: 'Alice',
  // 不推荐：箭头函数作为对象方法
  getName: () => this.name, // this不指向person
  
  // 推荐：传统函数作为对象方法
  getNameTraditional: function() {
    return this.name;
  }
};
```

### 3.7.2 默认参数的最佳实践

1. **避免使用可变表达式作为默认值**：除非确实需要每次调用都重新计算
2. **将常用参数放在前面**：带有默认值的参数应该放在参数列表的末尾
3. **考虑使用对象参数**：当函数有多个可选参数时

```javascript
// 好的实践
function createUser(options = {}) {
  const {
    name = 'Anonymous',
    age = 0,
    email = null,
    isActive = true
  } = options;
  
  return { name, age, email, isActive };
}

// 使用
const user1 = createUser();
const user2 = createUser({ name: 'Alice', age: 30 });
const user3 = createUser({ name: 'Bob', email: 'bob@example.com' });
```

### 3.7.3 剩余参数与扩展运算符的最佳实践

1. **避免在函数参数中混合使用剩余参数和arguments对象**
2. **使用扩展运算符替代Array.from或slice方法**
3. **在对象操作中使用扩展运算符进行浅拷贝**

```javascript
// 好的实践
function logMessages(level, ...messages) {
  console.log(`[${level}]`, ...messages);
}

// 数组复制
const original = [1, 2, 3];
const copy = [...original]; // 比original.slice()更简洁

// 对象合并
const defaultConfig = { theme: 'light', lang: 'en' };
const userConfig = { theme: 'dark' };
const finalConfig = { ...defaultConfig, ...userConfig };
```

## 3.8 常见问题与解决方案

### 3.8.1 箭头函数中的this问题

**问题**：误用箭头函数导致this指向错误

```javascript
const button = document.getElementById('myButton');
button.addEventListener('click', () => {
  // 这里的this指向外层作用域，而不是button元素
  this.classList.add('active'); // 可能会出错
});
```

**解决方案**：在需要this指向DOM元素时使用传统函数：

```javascript
button.addEventListener('click', function() {
  // 这里的this指向button元素
  this.classList.add('active');
});
```

### 3.8.2 默认参数与undefined

**问题**：默认参数只对undefined生效，不适用于null

```javascript
function greet(name = 'Guest') {
  console.log(`Hello, ${name}!`);
}

greet(null); // 输出 "Hello, null!" 而不是 "Hello, Guest!"
```

**解决方案**：显式检查null值：

```javascript
function greet(name) {
  name = (name === undefined || name === null) ? 'Guest' : name;
  console.log(`Hello, ${name}!`);
}
```

### 3.8.3 剩余参数与函数重载

**问题**：剩余参数使得实现函数重载变得复杂

```javascript
function createPerson(name, ...rest) {
  // 如何区分rest是age还是options对象？
}
```

**解决方案**：使用参数类型检查或对象参数：

```javascript
function createPerson(name, options = {}) {
  const { age = 0, email = null, isActive = true } = options;
  return { name, age, email, isActive };
}

// 使用
const person1 = createPerson('Alice', { age: 30 });
const person2 = createPerson('Bob', { email: 'bob@example.com', isActive: false });
```

## 3.9 总结

ES6引入的箭头函数和函数增强特性极大地改善了JavaScript函数的书写体验和功能：

1. **箭头函数**提供了更简洁的语法，解决了回调函数中的this绑定问题
2. **默认参数**使函数参数处理更加直观和灵活
3. **剩余参数**和**扩展运算符**简化了可变参数和数组/对象操作
4. **函数name属性**提供了更好的调试和反射能力

这些特性不仅提高了代码的可读性和简洁性，还解决了一些长期存在的JavaScript编程难题。合理使用这些特性可以编写出更加现代、简洁和可维护的JavaScript代码。