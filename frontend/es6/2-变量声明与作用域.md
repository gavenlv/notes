# 第2章：变量声明与作用域

## 目录
- [JavaScript变量声明的历史](#javascript变量声明的历史)
- [let关键字详解](#let关键字详解)
- [const关键字详解](-const关键字详解)
- [块级作用域](#块级作用域)
- [暂时性死区](#暂时性死区)
- [变量提升与TDZ](#变量提升与tdz)
- [实践练习](#实践练习)
- [最佳实践](#最佳实践)
- [常见问题与解决方案](#常见问题与解决方案)

## JavaScript变量声明的历史

在ES6之前，JavaScript只有一种声明变量的方式：`var`。`var`存在一些问题，这些问题在ES6中通过引入`let`和`const`得到了解决。

### var的问题

1. **函数作用域**：`var`声明的变量只有函数作用域，没有块级作用域。
2. **变量提升**：`var`声明的变量会被提升到函数或全局作用域的顶部。
3. **重复声明**：同一作用域内可以多次声明同一个变量。
4. **全局对象属性**：在全局作用域中使用`var`声明的变量会成为全局对象的属性。

这些特性导致了许多意想不到的行为和难以调试的bug。

### ES6的解决方案

ES6引入了`let`和`const`，解决了`var`的大部分问题：
- 引入了块级作用域
- 消除了变量提升
- 禁止重复声明
- 不会创建全局对象属性

## let关键字详解

`let`是ES6中新增的变量声明关键字，用于声明块级作用域的变量。

### 基本语法

```javascript
let variableName = initialValue;
```

### let的特性

1. **块级作用域**：`let`声明的变量只在所在的代码块内有效。

```javascript
{
  let x = 10;
  console.log(x); // 10
}

console.log(x); // ReferenceError: x is not defined
```

2. **不存在变量提升**：`let`声明的变量不会提升到代码块顶部。

```javascript
console.log(x); // ReferenceError: Cannot access 'x' before initialization
let x = 10;
```

3. **暂时性死区**：从代码块开始到`let`声明之间的区域称为暂时性死区（TDZ），在此区域内访问变量会导致错误。

```javascript
{
  // TDZ开始
  console.log(typeof x); // ReferenceError
  let x = 10; // TDZ结束
  console.log(x); // 10
}
```

4. **不允许重复声明**：同一作用域内不能重复声明同一个变量。

```javascript
let x = 10;
let x = 20; // SyntaxError: Identifier 'x' has already been declared
```

5. **不会成为全局对象的属性**：在全局作用域中使用`let`声明的变量不会成为`window`对象的属性。

```javascript
let globalVar = 'I am global';
console.log(window.globalVar); // undefined
```

### let的使用场景

1. **循环中的计数器**：`let`解决了`var`在循环中的经典问题。

```javascript
// 使用var的问题
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100); // 输出: 3, 3, 3
}

// 使用let的解决方案
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100); // 输出: 0, 1, 2
}
```

2. **条件块中的变量**：在条件语句中声明只在特定条件下使用的变量。

```javascript
if (condition) {
  let result = calculateResult();
  console.log(result);
}
// result在这里不可访问
```

## const关键字详解

`const`用于声明常量，一旦声明，其值就不能再改变。

### 基本语法

```javascript
const CONSTANT_NAME = initialValue;
```

### const的特性

1. **必须初始化**：声明`const`变量时必须立即初始化。

```javascript
const x; // SyntaxError: Missing initializer in const declaration
```

2. **值不可变**：`const`声明的变量不能重新赋值。

```javascript
const x = 10;
x = 20; // TypeError: Assignment to constant variable.
```

3. **块级作用域**：与`let`相同，`const`也具有块级作用域。

```javascript
{
  const x = 10;
  console.log(x); // 10
}

console.log(x); // ReferenceError: x is not defined
```

4. **暂时性死区**：与`let`相同，`const`也存在暂时性死区。

```javascript
console.log(x); // ReferenceError: Cannot access 'x' before initialization
const x = 10;
```

5. **不允许重复声明**：与`let`相同，同一作用域内不能重复声明同一个变量。

```javascript
const x = 10;
const x = 20; // SyntaxError: Identifier 'x' has already been declared
```

### const与对象/数组

对于对象和数组，`const`保证的是变量引用不变，而不是内容不变。

```javascript
const person = { name: 'Alice', age: 30 };
person.age = 31; // 这是允许的，修改的是对象的内容
console.log(person.age); // 31

person = { name: 'Bob', age: 25 }; // TypeError: Assignment to constant variable.
```

```javascript
const numbers = [1, 2, 3];
numbers.push(4); // 这是允许的，修改的是数组的内容
console.log(numbers); // [1, 2, 3, 4]

numbers = [4, 5, 6]; // TypeError: Assignment to constant variable.
```

### const的使用场景

1. **声明不会改变的变量**：如配置项、常量值等。

```javascript
const API_URL = 'https://api.example.com';
const MAX_RETRY_COUNT = 3;
```

2. **声明函数引用**：确保函数引用不会被意外改变。

```javascript
const calculateTotal = (items) => {
  return items.reduce((sum, item) => sum + item.price, 0);
};
```

3. **导入模块**：在模块系统中，通常使用`const`导入模块。

```javascript
const express = require('express');
const { Component } = React;
```

## 块级作用域

块级作用域是ES6引入的重要概念，它由一对花括号`{}`界定。

### 什么是块级作用域

块级作用域是指变量只在当前代码块内有效，代码块可以是一对花括号内的任何代码，如：

1. **函数体**
2. **条件语句**
3. **循环语句**
4. **任何使用花括号包裹的代码块**

### 块级作用域示例

```javascript
// 函数块
function test() {
  let x = 10; // 函数作用域
  console.log(x); // 10
}

// 条件块
if (true) {
  let y = 20; // 块级作用域
  console.log(y); // 20
}

// 循环块
for (let i = 0; i < 3; i++) {
  let z = i * 2; // 块级作用域
  console.log(z); // 0, 2, 4
}

// 独立块
{
  let a = 30; // 块级作用域
  console.log(a); // 30
}
```

### 块级作用域的优势

1. **避免变量污染**：防止变量泄露到外部作用域。

```javascript
// 使用var的问题
var items = [];
for (var i = 0; i < 3; i++) {
  items[i] = function() {
    console.log(i);
  };
}
items[0](); // 3，而不是预期的0

// 使用let的解决方案
var items = [];
for (let i = 0; i < 3; i++) {
  items[i] = function() {
    console.log(i);
  };
}
items[0](); // 0，符合预期
```

2. **提高代码可读性**：变量的作用范围更加明确。

3. **减少命名冲突**：不同块中的同名变量不会互相干扰。

```javascript
function processData(data) {
  // 第一个块
  {
    let result = data.filter(item => item.active);
    console.log('Active items:', result);
  }
  
  // 第二个块
  {
    let result = data.map(item => item.name);
    console.log('Item names:', result);
  }
  // 两个result变量互不影响
}
```

## 暂时性死区

暂时性死区（Temporal Dead Zone，TDZ）是ES6中的一个重要概念，指的是从代码块开始到变量声明之间的区域。

### TDZ的工作原理

在TDZ区域内，变量虽然已经存在，但尚未被初始化，因此不能被访问。

```javascript
{
  // TDZ开始
  console.log(myVar); // ReferenceError: Cannot access 'myVar' before initialization
  // TDZ结束
  let myVar = 10;
  console.log(myVar); // 10
}
```

### TDZ与typeof

即使在TDZ内，`typeof`操作符也会抛出错误，这与`var`不同：

```javascript
console.log(typeof notDeclared); // "undefined"，变量未声明

{
  console.log(typeof myLet); // ReferenceError，变量在TDZ内
  let myLet = 10;
}
```

### TDZ的实际影响

1. **参数默认值**：函数参数的默认值表达式也处于TDZ中。

```javascript
function test(x = y, y = 10) {
  return x + y;
}

test(); // ReferenceError: Cannot access 'y' before initialization
// 因为x的默认值使用了y，而此时y还未初始化

function test2(x = 10, y = x) {
  return x + y;
}

test2(); // 20，正常工作
```

2. **解构赋值**：解构赋值中也存在TDZ。

```javascript
let { x = y, y = 10 } = {}; // ReferenceError: Cannot access 'y' before initialization
```

## 变量提升与TDZ

### var的变量提升

使用`var`声明的变量会被提升到函数或全局作用域的顶部，但赋值不会提升。

```javascript
function test() {
  console.log(x); // undefined，而不是ReferenceError
  var x = 10;
  console.log(x); // 10
}

// 实际解释为：
function test() {
  var x; // 变量声明提升
  console.log(x); // undefined
  x = 10; // 赋值保持原位
  console.log(x); // 10
}
```

### let/const与变量提升

虽然`let`和`const`不会被提升，但实际上它们在代码块开始时就被创建了，只是处于不可访问的TDZ中，直到声明语句被执行。

```javascript
{
  // 变量x已经被创建，但处于TDZ中
  console.log(typeof x); // ReferenceError
  let x = 10; // 声明语句执行，TDZ结束
}
```

### 函数声明与变量声明

函数声明会被完全提升，包括函数体：

```javascript
test(); // "Hello, world!"，可以正常调用

function test() {
  console.log("Hello, world!");
}
```

但函数表达式（使用`var`、`let`或`const`）遵循相应的提升规则：

```javascript
testExpression(); // TypeError: testExpression is not a function

var testExpression = function() {
  console.log("Hello from expression!");
};

// 实际解释为：
var testExpression; // 变量声明提升，值为undefined
testExpression(); // TypeError，undefined不是函数
testExpression = function() {
  console.log("Hello from expression!");
};
```

## 实践练习

### 练习1：let与var的区别

创建一个函数，使用`var`和`let`声明变量，观察它们在循环中的行为差异。

```javascript
function testVar() {
  for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log('var:', i), 100);
  }
}

function testLet() {
  for (let i = 0; i < 3; i++) {
    setTimeout(() => console.log('let:', i), 100);
  }
}

testVar();  // 输出: var: 3, var: 3, var: 3
testLet();  // 输出: let: 0, let: 1, let: 2
```

### 练习2：const与对象操作

创建一个对象，使用`const`声明，然后尝试修改对象的属性和重新赋值整个对象。

```javascript
const person = {
  name: 'Alice',
  age: 30
};

// 修改对象属性 - 允许
person.age = 31;
console.log(person.age); // 31

// 添加新属性 - 允许
person.email = 'alice@example.com';
console.log(person.email); // alice@example.com

// 重新赋值整个对象 - 不允许
try {
  person = { name: 'Bob', age: 25 };
} catch (error) {
  console.log(error.message); // Assignment to constant variable.
}
```

### 练习3：块级作用域与TDZ

创建一个包含多个嵌套块的函数，测试变量在不同块级作用域中的可见性。

```javascript
function testScope() {
  let outer = 'outer';
  
  {
    console.log(outer); // 'outer'
    // console.log(inner); // ReferenceError: inner is not defined
    
    let inner = 'inner';
    console.log(inner); // 'inner'
    
    {
      console.log(outer); // 'outer'
      console.log(inner); // 'inner'
      
      let deepest = 'deepest';
      console.log(deepest); // 'deepest'
    }
    
    // console.log(deepest); // ReferenceError: deepest is not defined
  }
  
  // console.log(inner); // ReferenceError: inner is not defined
  // console.log(deepest); // ReferenceError: deepest is not defined
}

testScope();
```

### 练习4：暂时性死区

创建一个函数，展示TDZ在不同场景下的行为。

```javascript
function testTDZ() {
  // 1. 基本TDZ
  try {
    console.log(x);
    let x = 10;
  } catch (error) {
    console.log('Error:', error.message);
  }
  
  // 2. 函数参数中的TDZ
  try {
    function testParams(x = y, y = 10) {
      return x + y;
    }
    testParams();
  } catch (error) {
    console.log('Params Error:', error.message);
  }
  
  // 3. 正确的参数默认值
  function correctParams(x = 10, y = x) {
    return x + y;
  }
  console.log('Correct params result:', correctParams());
}

testTDZ();
```

## 最佳实践

### 1. 优先使用const，其次使用let

- 默认使用`const`声明变量，除非需要重新赋值
- 只有在明确需要变量值改变时才使用`let`
- 避免使用`var`，除非有特殊需求（如需要在旧环境中运行）

```javascript
// 好的做法
const API_URL = 'https://api.example.com';
let currentPage = 1;

// 不推荐的做法
var apiUrl = 'https://api.example.com';
var currentPage = 1;
```

### 2. 在最小作用域内声明变量

- 在尽可能小的作用域内声明变量
- 避免在函数或全局作用域中声明不必要的变量

```javascript
// 好的做法
function processItems(items) {
  const results = [];
  
  for (const item of items) {
    if (item.active) {
      const processed = processItem(item);
      results.push(processed);
    }
  }
  
  return results;
}

// 不推荐的做法
let results; // 过早声明
let processed; // 过早声明

function processItems(items) {
  results = [];
  
  for (let i = 0; i < items.length; i++) {
    if (items[i].active) {
      processed = processItem(items[i]);
      results.push(processed);
    }
  }
  
  return results;
}
```

### 3. 避免在块内声明函数

虽然现代JavaScript支持在块内声明函数，但这可能导致不同环境下的行为不一致。

```javascript
// 不推荐的做法
if (condition) {
  function test() {
    console.log('Inside block');
  }
}

// 推荐的做法
let test;
if (condition) {
  test = function() {
    console.log('Inside block');
  };
}
```

### 4. 使用解构赋值减少变量声明

解构赋值可以一次性声明多个变量，使代码更简洁。

```javascript
// 好的做法
const { name, age, email } = user;

// 不推荐的做法
const name = user.name;
const age = user.age;
const email = user.email;
```

### 5. 常量命名规范

- 使用全大写字母和下划线命名全局常量
- 使用驼峰命名法命名局部常量

```javascript
// 全局常量
const API_BASE_URL = 'https://api.example.com';
const MAX_RETRY_COUNT = 3;

// 局部常量
const baseUrl = 'https://api.example.com';
const maxRetryCount = 3;
```

## 常见问题与解决方案

### 1. 在循环中使用异步操作

**问题**：在循环中使用异步操作时，`var`声明的变量会导致意外的结果。

**解决方案**：使用`let`声明循环变量，或使用闭包捕获当前值。

```javascript
// 问题代码
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100); // 输出: 3, 3, 3
}

// 解决方案1：使用let
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100); // 输出: 0, 1, 2
}

// 解决方案2：使用闭包
for (var i = 0; i < 3; i++) {
  (function(index) {
    setTimeout(() => console.log(index), 100); // 输出: 0, 1, 2
  })(i);
}
```

### 2. 对象属性的修改与const

**问题**：误以为`const`声明的对象内容不可变。

**解决方案**：理解`const`保证的是引用不变，不是内容不变。如需不可变对象，使用`Object.freeze()`。

```javascript
const person = { name: 'Alice', age: 30 };

// 修改属性 - 允许
person.age = 31;

// 如需不可变对象
const frozenPerson = Object.freeze({ name: 'Alice', age: 30 });
frozenPerson.age = 31; // 非严格模式下静默失败，严格模式下抛出TypeError
```

### 3. 全局变量污染

**问题**：在全局作用域中使用`var`创建的变量会成为全局对象的属性，可能导致命名冲突。

**解决方案**：使用`let`或`const`，或者使用模块系统避免全局变量。

```javascript
// 问题代码
var globalVar = 'I am global';
console.log(window.globalVar); // 'I am global'

// 解决方案
let globalLet = 'I am also global but not a property';
console.log(window.globalLet); // undefined

// 更好的解决方案：使用模块
// module.js
export const moduleVar = 'I am module-scoped';
```

### 4. 变量提升导致的意外行为

**问题**：`var`的变量提升可能导致意外的undefined值。

**解决方案**：始终在使用前声明变量，或者使用`let`/`const`避免变量提升。

```javascript
// 问题代码
function test() {
  console.log(x); // undefined
  if (false) {
    var x = 10;
  }
}

// 解决方案1：提前声明
function test() {
  var x;
  console.log(x); // undefined，但更明确
  if (false) {
    x = 10;
  }
}

// 解决方案2：使用let
function test() {
  if (false) {
    let x = 10;
  }
  console.log(x); // ReferenceError，更明确地指出问题
}
```

### 5. TDZ相关的错误

**问题**：在TDZ内访问变量导致ReferenceError。

**解决方案**：确保在使用变量前声明它，理解TDZ的范围。

```javascript
// 问题代码
function test() {
  console.log(x); // ReferenceError
  let x = 10;
}

// 解决方案：在使用前声明
function test() {
  let x = 10;
  console.log(x); // 10
}
```

## 总结

本章深入探讨了ES6中变量声明与作用域的重要概念，包括：

1. **JavaScript变量声明的历史**：了解了`var`的问题和ES6引入`let`/`const`的背景。
2. **let关键字**：掌握了`let`的特性、使用场景和注意事项。
3. **const关键字**：理解了`const`的工作原理，特别是与对象/数组的关系。
4. **块级作用域**：学习了块级作用域的概念和优势。
5. **暂时性死区**：深入理解了TDZ的工作原理和实际影响。
6. **变量提升与TDZ**：对比了`var`的变量提升和`let`/`const`的TDZ行为。
7. **实践练习**：通过实际代码加深了对概念的理解。
8. **最佳实践**：掌握了变量声明的最佳实践方法。
9. **常见问题与解决方案**：了解了常见陷阱和相应的解决方法。

掌握变量声明与作用域是理解JavaScript工作原理的基础，也是编写高质量代码的关键。在下一章中，我们将学习ES6中另一个重要特性：箭头函数与函数增强。

## 下一步

在下一章中，我们将深入探讨ES6中的函数特性，包括箭头函数的语法和行为、函数参数的默认值、剩余参数和展开运算符等。这些特性不仅使函数定义更加简洁，也解决了JavaScript中一些长期存在的函数相关的问题。