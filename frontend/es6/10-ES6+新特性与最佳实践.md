# 第10章：ES6+新特性与最佳实践

## 概述

ES6（ECMAScript 2015）是JavaScript发展史上的一个重要里程碑，但JavaScript的演进并未停止。自ES6发布以来，ECMAScript规范每年都会发布新版本，引入了许多有用的新特性。本章将介绍ES6之后的重要特性，并分享JavaScript开发的最佳实践。

## 10.1 ES2016-ES2022新特性

### 10.1.1 ES2016 (ECMAScript 7)

ES2016是一个小版本更新，主要引入了两个新特性：

#### Array.prototype.includes()

`includes()`方法用于判断数组是否包含指定的值，返回布尔值。

```javascript
// 旧方法：使用indexOf
const fruits = ['apple', 'banana', 'orange'];
console.log(fruits.indexOf('banana') !== -1); // true

// 新方法：使用includes
console.log(fruits.includes('banana')); // true
console.log(fruits.includes('grape')); // false

// includes还可以处理NaN
console.log([NaN].includes(NaN)); // true
console.log([NaN].indexOf(NaN)); // -1
```

#### 指数运算符 (**)

指数运算符是Math.pow()的简写形式。

```javascript
// 旧方法
console.log(Math.pow(2, 3)); // 8

// 新方法
console.log(2 ** 3); // 8

// 与赋值运算符结合
let x = 2;
x **= 3;
console.log(x); // 8
```

### 10.1.2 ES2017 (ECMAScript 8)

ES2017主要引入了异步编程的重要改进：

#### async/await

async/await是基于Promise的语法糖，使异步代码更易读和维护。

```javascript
// 使用Promise链
function fetchUserData(userId) {
    return fetch(`/api/users/${userId}`)
        .then(response => response.json())
        .then(user => {
            return fetch(`/api/posts/${user.id}`)
                .then(response => response.json())
                .then(posts => ({ user, posts }));
        });
}

// 使用async/await
async function fetchUserDataAsync(userId) {
    const userResponse = await fetch(`/api/users/${userId}`);
    const user = await userResponse.json();
    
    const postsResponse = await fetch(`/api/posts/${user.id}`);
    const posts = await postsResponse.json();
    
    return { user, posts };
}
```

#### Object.values()

`Object.values()`方法返回一个给定对象自身的所有可枚举属性值的数组。

```javascript
const person = {
    name: '张三',
    age: 30,
    job: '工程师'
};

console.log(Object.values(person)); // ['张三', 30, '工程师']
```

#### Object.entries()

`Object.entries()`方法返回一个给定对象自身可枚举属性的键值对数组。

```javascript
const person = {
    name: '张三',
    age: 30,
    job: '工程师'
};

console.log(Object.entries(person));
// [['name', '张三'], ['age', 30], ['job', '工程师']]

// 常用于遍历对象
Object.entries(person).forEach(([key, value]) => {
    console.log(`${key}: ${value}`);
});
```

#### String.prototype.padStart() 和 String.prototype.padEnd()

这两个方法用于在字符串的开头或结尾填充字符，以达到指定长度。

```javascript
// padStart
console.log('7'.padStart(2, '0')); // '07'
console.log('hello'.padStart(10, '*')); // '*****hello'

// padEnd
console.log('7'.padEnd(2, '0')); // '70'
console.log('hello'.padEnd(10, '*')); // 'hello*****'

// 实际应用：格式化数字
const formatNumber = (num) => num.toString().padStart(5, '0');
console.log(formatNumber(42)); // '00042'
```

#### Object.getOwnPropertyDescriptors()

`Object.getOwnPropertyDescriptors()`方法用来获取一个对象的所有自身属性的描述符。

```javascript
const obj = {
    name: '张三',
    get age() { return 30; }
};

console.log(Object.getOwnPropertyDescriptors(obj));
/*
{
  name: {
    value: '张三',
    writable: true,
    enumerable: true,
    configurable: true
  },
  age: {
    get: [Function: get age],
    set: undefined,
    enumerable: true,
    configurable: true
  }
}
*/
```

#### 函数参数列表和调用中的尾随逗号

ES2017允许在函数参数列表和调用中使用尾随逗号。

```javascript
// 函数定义
function sum(a, b, c,) {
    return a + b + c;
}

// 函数调用
console.log(sum(1, 2, 3,)); // 6

// 在长参数列表中特别有用
const config = {
    host: 'localhost',
    port: 3000,
    timeout: 5000, // 尾随逗号使添加新属性更容易
};
```

### 10.1.3 ES2018 (ECMAScript 9)

ES2018引入了一些重要的异步和对象处理特性：

#### 异步迭代

异步迭代允许迭代异步数据源，如从API获取的数据流。

```javascript
// 异步迭代器示例
const asyncIterable = {
    [Symbol.asyncIterator]() {
        let i = 0;
        return {
            next() {
                return new Promise(resolve => {
                    setTimeout(() => {
                        resolve({
                            value: i++,
                            done: i > 3
                        });
                    }, 1000);
                });
            }
        };
    }
};

// 使用for-await-of循环
(async function() {
    for await (const num of asyncIterable) {
        console.log(num); // 0, 1, 2, 3 (每秒输出一个)
    }
})();
```

#### Promise.prototype.finally()

`finally()`方法在Promise结束时（无论成功还是失败）都会执行指定的回调函数。

```javascript
fetch('/api/data')
    .then(response => response.json())
    .catch(error => console.error('Error:', error))
    .finally(() => {
        // 无论成功或失败，都会执行
        console.log('请求完成');
        hideLoadingIndicator();
    });
```

#### 对象休息/展开属性

ES2018将展开和休息运算符引入对象字面量。

```javascript
// 对象展开
const obj1 = { a: 1, b: 2 };
const obj2 = { ...obj1, c: 3 };
console.log(obj2); // { a: 1, b: 2, c: 3 }

// 对象休息属性
const { a, ...rest } = obj2;
console.log(a); // 1
console.log(rest); // { b: 2, c: 3 }
```

#### 正则表达式改进

ES2018为正则表达式添加了几个新特性：

```javascript
// 后行断言
const regex = /(?<=\$)\d+/;
console.log(regex.exec('价格: $100')[0]); // '100'

// Unicode属性转义
const unicodeRegex = /\p{Script=Greek}/u;
console.log(unicodeRegex.test('α')); // true
console.log(unicodeRegex.test('a')); // false

// 点(.)匹配行终止符
const dotAllRegex = /./s;
console.log(dotAllRegex.test('hello\nworld')); // true
```

### 10.1.4 ES2019 (ECMAScript 10)

ES2019引入了一些有用的数组和方法改进：

#### Array.prototype.flat() 和 Array.prototype.flatMap()

`flat()`方法将嵌套数组"展平"为指定深度的数组，`flatMap()`方法先映射后展平。

```javascript
// flat
const nestedArray = [1, [2, 3], [4, [5]]];
console.log(nestedArray.flat()); // [1, 2, 3, 4, [5]]
console.log(nestedArray.flat(2)); // [1, 2, 3, 4, 5]

// flatMap
const sentences = [
    '这是一个句子',
    '这是另一个句子',
    '还有第三个句子'
];
const words = sentences.flatMap(sentence => sentence.split(' '));
console.log(words); // ['这是一个', '句子', '这是', '另一个', '句子', '还有', '第三个', '句子']
```

#### Object.fromEntries()

`Object.fromEntries()`方法将键值对列表转换为对象。

```javascript
const entries = [
    ['name', '张三'],
    ['age', 30],
    ['job', '工程师']
];

const obj = Object.fromEntries(entries);
console.log(obj); // { name: '张三', age: 30, job: '工程师' }

// 实际应用：转换URL参数
const urlParams = new URLSearchParams('name=张三&age=30');
const paramsObj = Object.fromEntries(urlParams);
console.log(paramsObj); // { name: '张三', age: '30' }
```

#### String.prototype.trimStart() 和 String.prototype.trimEnd()

这两个方法分别从字符串的开始和结束位置移除空白字符。

```javascript
const str = '  hello world  ';
console.log(str.trimStart()); // 'hello world  '
console.log(str.trimEnd()); // '  hello world'
console.log(str.trim()); // 'hello world'
```

#### 可选的catch绑定

ES2019允许在catch块中省略错误参数。

```javascript
// 旧语法
try {
    // 可能出错的代码
} catch (error) {
    console.log('发生错误');
}

// 新语法
try {
    // 可能出错的代码
} catch {
    console.log('发生错误');
}
```

#### Function.prototype.toString() 修订

`toString()`方法现在返回函数的源代码，包括注释和空格。

```javascript
function example() {
    // 这是一个示例函数
    return 'Hello, world!';
}

console.log(example.toString());
/*
function example() {
    // 这是一个示例函数
    return 'Hello, world!';
}
*/
```

### 10.1.5 ES2020 (ECMAScript 11)

ES2020引入了一些重要特性，特别是空值处理和模块系统改进：

#### 可选链操作符 (?.)

可选链操作符允许读取深层嵌套对象属性，而不必显式验证链中的每个引用是否有效。

```javascript
const user = {
    name: '张三',
    address: {
        city: '北京'
    }
};

// 旧方法
const city = user && user.address && user.address.city;
console.log(city); // '北京'

// 新方法
const city2 = user?.address?.city;
console.log(city2); // '北京'

// 如果属性不存在，返回undefined
const zipCode = user?.address?.zipCode;
console.log(zipCode); // undefined
```

#### 空值合并运算符 (??)

空值合并运算符当左侧操作数为null或undefined时，返回右侧操作数，否则返回左侧操作数。

```javascript
// 旧方法：使用||运算符
const port = settings.port || 3000; // 如果settings.port是0，会错误地使用3000

// 新方法：使用??运算符
const port2 = settings.port ?? 3000; // 只有当settings.port是null或undefined时才使用3000

// 示例
const nullValue = null;
const emptyText = '';
const zero = 0;

console.log(nullValue ?? '默认值'); // '默认值'
console.log(emptyText ?? '默认值'); // '' (空字符串不是null或undefined)
console.log(zero ?? '默认值'); // 0 (0不是null或undefined)
```

#### globalThis

`globalThis`提供了一个标准方式来获取全局`this`值，无论代码在什么环境中运行。

```javascript
// 在不同环境中获取全局对象的方式不同
// 浏览器: window 或 self
// Node.js: global
// Web Worker: self

// ES2020提供了统一的方式
console.log(typeof globalThis); // 'object'
```

#### BigInt

BigInt是一种新的基本类型，用于表示任意精度的整数，可以安全地操作大整数。

```javascript
// 创建BigInt
const bigIntValue = 9007199254740991n; // 在数字后加n
const bigIntValue2 = BigInt('9007199254740991'); // 使用BigInt函数

// 运算
console.log(9007199254740991n + 1n); // 9007199254740992n

// 不能与普通数字混合运算
// console.log(9007199254740991n + 1); // TypeError

// 比较
console.log(1n === 1); // false (类型不同)
console.log(1n == 1); // true (值相等)
```

#### String.prototype.matchAll()

`matchAll()`方法返回一个包含所有匹配正则表达式结果的迭代器。

```javascript
const regex = /t(e)(st(\d?))/g;
const str = 'test1test2';

const matches = str.matchAll(regex);

for (const match of matches) {
    console.log(match);
}
/*
[
  'test1',
  'e',
  'st1',
  '1',
  index: 0,
  input: 'test1test2',
  groups: undefined
]
[
  'test2',
  'e',
  'st2',
  '2',
  index: 5,
  input: 'test1test2',
  groups: undefined
]
*/
```

#### 动态import()

动态`import()`允许按需加载模块，返回一个Promise。

```javascript
// 静态导入（在模块顶层）
// import { module } from './module.js';

// 动态导入（可以在任何地方使用）
button.addEventListener('click', async () => {
    const module = await import('./module.js');
    module.doSomething();
});

// 条件导入
if (condition) {
    const module = await import('./module.js');
    module.doSomething();
}
```

#### import.meta

`import.meta`对象包含模块的元信息，如模块的URL。

```javascript
// 在模块中
console.log(import.meta.url); // 模块的URL
```

### 10.1.6 ES2021 (ECMAScript 12)

ES2021引入了一些实用的字符串和Promise方法：

#### String.prototype.replaceAll()

`replaceAll()`方法替换字符串中所有匹配的子字符串。

```javascript
// 旧方法：使用全局正则表达式
const message = 'apple, banana, apple, orange';
const newMessage = message.replace(/apple/g, 'grape');
console.log(newMessage); // 'grape, banana, grape, orange'

// 新方法：使用replaceAll
const newMessage2 = message.replaceAll('apple', 'grape');
console.log(newMessage2); // 'grape, banana, grape, orange'
```

#### Promise.any()

`Promise.any()`接收Promise数组，返回第一个成功的Promise，如果所有Promise都失败，则返回一个失败的Promise。

```javascript
const promise1 = Promise.reject('失败1');
const promise2 = Promise.reject('失败2');
const promise3 = Promise.resolve('成功');

Promise.any([promise1, promise2, promise3])
    .then(result => console.log(result)) // '成功'
    .catch(error => console.log(error)); // 不会执行

// 所有Promise都失败的情况
Promise.any([promise1, promise2])
    .then(result => console.log(result))
    .catch(error => console.log(error)); // AggregateError: All promises were rejected
```

#### 逻辑赋值运算符

ES2021引入了三个新的逻辑赋值运算符：`||=`、`&&=` 和 `??=`。

```javascript
// ||= (逻辑或赋值)
let x = 0;
x ||= 5; // 等同于 x = x || 5
console.log(x); // 5

// &&= (逻辑与赋值)
let y = 5;
y &&= 0; // 等同于 y = y && 0
console.log(y); // 0

// ??= (空值合并赋值)
let z = null;
z ??= 10; // 等同于 z = z ?? 10
console.log(z); // 10
```

#### 数字分隔符

数字分隔符使用下划线(_)来使大数字更易读。

```javascript
const billion = 1_000_000_000;
const bytes = 0b1111_1111;
const hex = 0xFF_FF_FF_FF;

console.log(billion); // 1000000000
console.log(bytes); // 255
console.log(hex); // 4294967295
```

### 10.1.7 ES2022 (ECMAScript 13)

ES2022引入了一些重要的类和数组方法改进：

#### 类字段

ES2022允许在类中直接定义字段，包括私有字段。

```javascript
class Person {
    // 公共字段
    name = '未知';
    age = 0;
    
    // 私有字段（以#开头）
    #id = Math.random().toString(36).substr(2, 9);
    #secret = '这是一个秘密';
    
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    // 私有方法
    #getSecret() {
        return this.#secret;
    }
    
    // 公共方法可以访问私有字段和方法
    getInfo() {
        return `${this.name} (ID: ${this.#id}): ${this.#getSecret()}`;
    }
}

const person = new Person('张三', 30);
console.log(person.getInfo()); // '张三 (ID: abc123): 这是一个秘密'

// 无法从外部访问私有字段
// console.log(person.#id); // SyntaxError
// console.log(person.#getSecret()); // SyntaxError
```

#### 私有方法与访问器

类也可以有私有方法和访问器。

```javascript
class Counter {
    #count = 0;
    
    // 私有方法
    #increment() {
        this.#count++;
    }
    
    // 私有getter
    get #value() {
        return this.#count;
    }
    
    // 公共方法
    incrementAndLog() {
        this.#increment();
        console.log(`当前计数: ${this.#value}`);
    }
}

const counter = new Counter();
counter.incrementAndLog(); // '当前计数: 1'
counter.incrementAndLog(); // '当前计数: 2'
```

#### 类的静态初始化块

静态初始化块在类创建时执行，用于初始化静态字段。

```javascript
class MyClass {
    static staticProperty1;
    static staticProperty2;
    
    // 静态初始化块
    static {
        try {
            const data = JSON.parse('{"value": 42}');
            this.staticProperty1 = data.value;
            this.staticProperty2 = '初始化成功';
        } catch (e) {
            this.staticProperty1 = 0;
            this.staticProperty2 = '初始化失败';
        }
    }
}

console.log(MyClass.staticProperty1); // 42
console.log(MyClass.staticProperty2); // '初始化成功'
```

#### Array.prototype.at()

`at()`方法使用整数索引访问数组元素，支持负索引从末尾开始计数。

```javascript
const arr = ['a', 'b', 'c', 'd', 'e'];

console.log(arr.at(0)); // 'a'
console.log(arr.at(2)); // 'c'
console.log(arr.at(-1)); // 'e' (最后一个元素)
console.log(arr.at(-2)); // 'd' (倒数第二个元素)

// 等同于
console.log(arr[arr.length - 1]); // 'e'
```

#### Object.hasOwn()

`Object.hasOwn()`方法是`Object.hasOwnProperty()`的更安全替代。

```javascript
const obj = { name: '张三' };
const objWithNullProto = Object.create(null);
objWithNullProto.name = '李四';

// 使用hasOwnProperty
console.log(obj.hasOwnProperty('name')); // true
// console.log(objWithNullProto.hasOwnProperty('name')); // TypeError

// 使用Object.hasOwn
console.log(Object.hasOwn(obj, 'name')); // true
console.log(Object.hasOwn(objWithNullProto, 'name')); // true
```

#### Error对象的cause属性

Error对象现在可以包含一个cause属性，用于指示错误的根本原因。

```javascript
try {
    try {
        // 一些可能失败的操作
        JSON.parse('invalid json');
    } catch (error) {
        throw new Error('处理数据失败', { cause: error });
    }
} catch (error) {
    console.log(error.message); // '处理数据失败'
    console.log(error.cause.message); // 'Unexpected token i in JSON at position 0'
}
```

## 10.2 性能优化技巧

### 10.2.1 避免不必要的重新渲染

在React等框架中，使用适当的优化技术避免不必要的组件重新渲染。

```javascript
// 使用React.memo避免不必要的重新渲染
const ExpensiveComponent = React.memo(function ExpensiveComponent({ data }) {
    // 复杂的计算或渲染
    return <div>{/* 渲染内容 */}</div>;
});

// 使用useMemo缓存计算结果
function MyComponent({ items }) {
    const expensiveValue = useMemo(() => {
        return items.reduce((sum, item) => sum + item.value, 0);
    }, [items]);
    
    return <div>{expensiveValue}</div>;
}

// 使用useCallback缓存函数
function MyComponent({ onClick }) {
    const handleClick = useCallback(() => {
        onClick('some data');
    }, [onClick]);
    
    return <button onClick={handleClick}>点击</button>;
}
```

### 10.2.2 优化循环和数组操作

使用适当的方法处理数组和循环，提高性能。

```javascript
// 使用for循环而不是forEach处理大数组
const largeArray = new Array(1000000).fill(0);

// 慢
largeArray.forEach(item => {
    // 处理每个项目
});

// 快
for (let i = 0; i < largeArray.length; i++) {
    // 处理每个项目
}

// 使用Map和Set进行快速查找
const array = [1, 2, 3, 4, 5];
const set = new Set(array);

// 慢
const exists1 = array.includes(3);

// 快
const exists2 = set.has(3);
```

### 10.2.3 防抖和节流

使用防抖和节流技术优化频繁触发的事件。

```javascript
// 防抖：延迟执行，在指定时间内没有新触发才执行
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

// 节流：固定时间间隔执行
function throttle(func, interval) {
    let lastTime = 0;
    return function(...args) {
        const now = Date.now();
        if (now - lastTime >= interval) {
            func.apply(this, args);
            lastTime = now;
        }
    };
}

// 使用示例
const debouncedSearch = debounce(searchAPI, 300);
const throttledScroll = throttle(updatePosition, 100);

input.addEventListener('input', debouncedSearch);
window.addEventListener('scroll', throttledScroll);
```

### 10.2.4 懒加载和代码分割

使用懒加载和代码分割减少初始加载时间。

```javascript
// 动态导入实现懒加载
button.addEventListener('click', async () => {
    const module = await import('./heavy-module.js');
    module.doSomething();
});

// React中的懒加载
const LazyComponent = React.lazy(() => import('./LazyComponent'));

function App() {
    return (
        <div>
            <Suspense fallback={<div>加载中...</div>}>
                <LazyComponent />
            </Suspense>
        </div>
    );
}
```

## 10.3 代码风格与最佳实践

### 10.3.1 使用现代JavaScript特性

充分利用现代JavaScript特性，编写更简洁、可读的代码。

```javascript
// 使用解构赋值
function processUser(user) {
    // 旧方法
    const name = user.name;
    const age = user.age;
    const email = user.email;
    
    // 新方法
    const { name, age, email } = user;
}

// 使用展开运算符
function updateUser(user, updates) {
    // 旧方法
    const newUser = Object.assign({}, user);
    Object.keys(updates).forEach(key => {
        newUser[key] = updates[key];
    });
    
    // 新方法
    return { ...user, ...updates };
}

// 使用模板字符串
function greet(name, age) {
    // 旧方法
    return 'Hello, ' + name + '! You are ' + age + ' years old.';
    
    // 新方法
    return `Hello, ${name}! You are ${age} years old.`;
}
```

### 10.3.2 函数式编程原则

采用函数式编程原则，编写更可预测、可测试的代码。

```javascript
// 避免副作用
const add = (a, b) => a + b; // 纯函数

// 使用高阶函数
const numbers = [1, 2, 3, 4, 5];

// 避免for循环
const doubled = [];
for (let i = 0; i < numbers.length; i++) {
    doubled.push(numbers[i] * 2);
}

// 使用map
const doubled2 = numbers.map(n => n * 2);

// 使用函数组合
const compose = (f, g) => x => f(g(x));
const addOne = x => x + 1;
const double = x => x * 2;
const addOneThenDouble = compose(double, addOne);
console.log(addOneThenDouble(3)); // 8
```

### 10.3.3 错误处理

实现健壮的错误处理机制。

```javascript
// 使用try/catch处理同步错误
try {
    const data = JSON.parse(jsonString);
    processData(data);
} catch (error) {
    console.error('解析JSON失败:', error);
    // 提供回退方案
    useDefaultData();
}

// 使用Promise.catch处理异步错误
fetch('/api/data')
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP错误: ${response.status}`);
        }
        return response.json();
    })
    .catch(error => {
        console.error('获取数据失败:', error);
        // 提供用户友好的错误信息
        showErrorMessage('无法加载数据，请稍后再试');
    });

// 使用async/await简化错误处理
async function fetchData() {
    try {
        const response = await fetch('/api/data');
        if (!response.ok) {
            throw new Error(`HTTP错误: ${response.status}`);
        }
        return await response.json();
    } catch (error) {
        console.error('获取数据失败:', error);
        // 提供回退数据
        return getDefaultData();
    }
}
```

### 10.3.4 代码组织与模块化

合理组织代码结构，使用模块化提高可维护性。

```javascript
// 模块导出
// api.js
export const fetchUsers = async () => {
    const response = await fetch('/api/users');
    return response.json();
};

export const createUser = async (userData) => {
    const response = await fetch('/api/users', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(userData)
    });
    return response.json();
};

// 模块导入
// userService.js
import { fetchUsers, createUser } from './api.js';

class UserService {
    async getUsers() {
        try {
            return await fetchUsers();
        } catch (error) {
            console.error('获取用户失败:', error);
            return [];
        }
    }
    
    async addUser(userData) {
        try {
            return await createUser(userData);
        } catch (error) {
            console.error('创建用户失败:', error);
            throw error;
        }
    }
}

export default new UserService();
```

## 10.4 实战项目案例

### 10.4.1 现代化待办事项应用

使用现代JavaScript特性构建一个功能完整的待办事项应用。

```javascript
// todo.js
class TodoApp {
    constructor() {
        this.todos = JSON.parse(localStorage.getItem('todos')) || [];
        this.filter = 'all'; // all, active, completed
        this.init();
    }
    
    init() {
        this.bindEvents();
        this.render();
    }
    
    bindEvents() {
        document.querySelector('#add-todo-form').addEventListener('submit', this.handleAddTodo.bind(this));
        document.querySelector('#filter-buttons').addEventListener('click', this.handleFilterChange.bind(this));
    }
    
    async handleAddTodo(event) {
        event.preventDefault();
        const input = document.querySelector('#todo-input');
        const text = input.value.trim();
        
        if (!text) return;
        
        const todo = {
            id: Date.now().toString(),
            text,
            completed: false,
            createdAt: new Date().toISOString()
        };
        
        // 模拟API调用
        await this.simulateApiCall(() => {
            this.todos = [...this.todos, todo];
            this.saveTodos();
            this.render();
        });
        
        input.value = '';
    }
    
    async handleToggleTodo(id) {
        await this.simulateApiCall(() => {
            this.todos = this.todos.map(todo =>
                todo.id === id ? { ...todo, completed: !todo.completed } : todo
            );
            this.saveTodos();
            this.render();
        });
    }
    
    async handleDeleteTodo(id) {
        await this.simulateApiCall(() => {
            this.todos = this.todos.filter(todo => todo.id !== id);
            this.saveTodos();
            this.render();
        });
    }
    
    handleFilterChange(event) {
        if (event.target.tagName !== 'BUTTON') return;
        
        this.filter = event.target.dataset.filter;
        this.updateFilterButtons();
        this.render();
    }
    
    getFilteredTodos() {
        switch (this.filter) {
            case 'active':
                return this.todos.filter(todo => !todo.completed);
            case 'completed':
                return this.todos.filter(todo => todo.completed);
            default:
                return this.todos;
        }
    }
    
    render() {
        const todoList = document.querySelector('#todo-list');
        const filteredTodos = this.getFilteredTodos();
        
        todoList.innerHTML = '';
        
        if (filteredTodos.length === 0) {
            todoList.innerHTML = '<li class="empty-message">没有待办事项</li>';
            return;
        }
        
        filteredTodos.forEach(todo => {
            const todoItem = document.createElement('li');
            todoItem.className = `todo-item ${todo.completed ? 'completed' : ''}`;
            todoItem.innerHTML = `
                <div class="todo-content">
                    <input type="checkbox" ${todo.completed ? 'checked' : ''} data-id="${todo.id}" class="toggle-todo">
                    <span class="todo-text">${todo.text}</span>
                </div>
                <button class="delete-todo" data-id="${todo.id}">删除</button>
            `;
            
            todoItem.querySelector('.toggle-todo').addEventListener('change', () => {
                this.handleToggleTodo(todo.id);
            });
            
            todoItem.querySelector('.delete-todo').addEventListener('click', () => {
                this.handleDeleteTodo(todo.id);
            });
            
            todoList.appendChild(todoItem);
        });
        
        this.updateStats();
    }
    
    updateStats() {
        const total = this.todos.length;
        const completed = this.todos.filter(todo => todo.completed).length;
        const active = total - completed;
        
        document.querySelector('#todo-stats').textContent = 
            `总计: ${total} | 待完成: ${active} | 已完成: ${completed}`;
    }
    
    updateFilterButtons() {
        document.querySelectorAll('#filter-buttons button').forEach(button => {
            button.classList.toggle('active', button.dataset.filter === this.filter);
        });
    }
    
    saveTodos() {
        localStorage.setItem('todos', JSON.stringify(this.todos));
    }
    
    simulateApiCall(callback) {
        // 模拟API延迟
        return new Promise(resolve => {
            setTimeout(() => {
                callback();
                resolve();
            }, 300);
        });
    }
}

// 初始化应用
document.addEventListener('DOMContentLoaded', () => {
    new TodoApp();
});
```

### 10.4.2 数据可视化仪表板

使用现代JavaScript创建一个交互式数据可视化仪表板。

```javascript
// dashboard.js
class DataDashboard {
    constructor() {
        this.data = [];
        this.charts = {};
        this.filters = {
            dateRange: '7d',
            category: 'all'
        };
        this.init();
    }
    
    async init() {
        await this.loadData();
        this.setupEventListeners();
        this.renderCharts();
        this.renderStats();
    }
    
    async loadData() {
        try {
            // 使用动态导入加载图表库
            const { Chart } = await import('https://cdn.jsdelivr.net/npm/chart.js');
            this.Chart = Chart;
            
            // 模拟API调用
            this.data = await this.fetchData();
        } catch (error) {
            console.error('加载数据失败:', error);
            this.showErrorMessage('无法加载数据，请刷新页面重试');
        }
    }
    
    async fetchData() {
        // 模拟API延迟
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // 生成模拟数据
        const days = parseInt(this.filters.dateRange);
        const data = [];
        
        for (let i = days - 1; i >= 0; i--) {
            const date = new Date();
            date.setDate(date.getDate() - i);
            
            data.push({
                date: date.toISOString().split('T')[0],
                sales: Math.floor(Math.random() * 10000) + 5000,
                visitors: Math.floor(Math.random() * 1000) + 500,
                conversion: Math.random() * 0.1 + 0.02,
                category: Math.random() > 0.5 ? 'A' : 'B'
            });
        }
        
        return data;
    }
    
    setupEventListeners() {
        // 日期范围选择器
        document.querySelectorAll('[data-date-range]').forEach(button => {
            button.addEventListener('click', (event) => {
                this.filters.dateRange = event.target.dataset.dateRange;
                this.updateActiveButton(event.target, '[data-date-range]');
                this.refreshDashboard();
            });
        });
        
        // 类别选择器
        document.querySelectorAll('[data-category]').forEach(button => {
            button.addEventListener('click', (event) => {
                this.filters.category = event.target.dataset.category;
                this.updateActiveButton(event.target, '[data-category]');
                this.refreshDashboard();
            });
        });
        
        // 导出按钮
        document.querySelector('#export-data').addEventListener('click', () => {
            this.exportData();
        });
    }
    
    updateActiveButton(activeButton, selector) {
        document.querySelectorAll(selector).forEach(button => {
            button.classList.toggle('active', button === activeButton);
        });
    }
    
    async refreshDashboard() {
        this.showLoading();
        
        try {
            this.data = await this.fetchData();
            this.updateCharts();
            this.renderStats();
        } catch (error) {
            console.error('刷新数据失败:', error);
            this.showErrorMessage('刷新数据失败');
        } finally {
            this.hideLoading();
        }
    }
    
    renderCharts() {
        this.renderSalesChart();
        this.renderVisitorsChart();
        this.renderConversionChart();
    }
    
    renderSalesChart() {
        const ctx = document.querySelector('#sales-chart').getContext('2d');
        
        if (this.charts.sales) {
            this.charts.sales.destroy();
        }
        
        this.charts.sales = new this.Chart(ctx, {
            type: 'line',
            data: {
                labels: this.data.map(item => item.date),
                datasets: [{
                    label: '销售额',
                    data: this.data.map(item => item.sales),
                    borderColor: 'rgb(75, 192, 192)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            callback: value => `¥${value.toLocaleString()}`
                        }
                    }
                }
            }
        });
    }
    
    renderVisitorsChart() {
        const ctx = document.querySelector('#visitors-chart').getContext('2d');
        
        if (this.charts.visitors) {
            this.charts.visitors.destroy();
        }
        
        this.charts.visitors = new this.Chart(ctx, {
            type: 'bar',
            data: {
                labels: this.data.map(item => item.date),
                datasets: [{
                    label: '访客数',
                    data: this.data.map(item => item.visitors),
                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true
                    }
                }
            }
        });
    }
    
    renderConversionChart() {
        const ctx = document.querySelector('#conversion-chart').getContext('2d');
        
        if (this.charts.conversion) {
            this.charts.conversion.destroy();
        }
        
        this.charts.conversion = new this.Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: ['转化', '未转化'],
                datasets: [{
                    data: [
                        this.data.reduce((sum, item) => sum + item.conversion * item.visitors, 0),
                        this.data.reduce((sum, item) => sum + (1 - item.conversion) * item.visitors, 0)
                    ],
                    backgroundColor: [
                        'rgba(255, 99, 132, 0.2)',
                        'rgba(201, 203, 207, 0.2)'
                    ],
                    borderColor: [
                        'rgba(255, 99, 132, 1)',
                        'rgba(201, 203, 207, 1)'
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        position: 'bottom'
                    }
                }
            }
        });
    }
    
    updateCharts() {
        this.renderSalesChart();
        this.renderVisitorsChart();
        this.renderConversionChart();
    }
    
    renderStats() {
        const totalSales = this.data.reduce((sum, item) => sum + item.sales, 0);
        const totalVisitors = this.data.reduce((sum, item) => sum + item.visitors, 0);
        const avgConversion = this.data.reduce((sum, item) => sum + item.conversion, 0) / this.data.length;
        
        document.querySelector('#total-sales').textContent = `¥${totalSales.toLocaleString()}`;
        document.querySelector('#total-visitors').textContent = totalVisitors.toLocaleString();
        document.querySelector('#avg-conversion').textContent = `${(avgConversion * 100).toFixed(2)}%`;
    }
    
    exportData() {
        // 创建CSV内容
        const headers = ['日期', '销售额', '访客数', '转化率'];
        const rows = this.data.map(item => [
            item.date,
            item.sales,
            item.visitors,
            (item.conversion * 100).toFixed(2) + '%'
        ]);
        
        let csvContent = headers.join(',') + '\n';
        rows.forEach(row => {
            csvContent += row.join(',') + '\n';
        });
        
        // 创建下载链接
        const blob = new Blob([csvContent], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `dashboard-data-${new Date().toISOString().split('T')[0]}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
    
    showLoading() {
        document.querySelector('.loading-overlay').classList.add('visible');
    }
    
    hideLoading() {
        document.querySelector('.loading-overlay').classList.remove('visible');
    }
    
    showErrorMessage(message) {
        const errorElement = document.querySelector('.error-message');
        errorElement.textContent = message;
        errorElement.classList.add('visible');
        
        setTimeout(() => {
            errorElement.classList.remove('visible');
        }, 5000);
    }
}

// 初始化仪表板
document.addEventListener('DOMContentLoaded', () => {
    new DataDashboard();
});
```

## 10.5 常见问题与解决方案

### 10.5.1 异步操作问题

#### 问题：回调地狱

```javascript
// 回调地狱
getData(function(a) {
    getMoreData(a, function(b) {
        getMoreData(b, function(c) {
            getMoreData(c, function(d) {
                console.log(d);
            });
        });
    });
});
```

#### 解决方案：使用Promise或async/await

```javascript
// 使用Promise
getData()
    .then(a => getMoreData(a))
    .then(b => getMoreData(b))
    .then(c => getMoreData(c))
    .then(d => console.log(d))
    .catch(error => console.error(error));

// 使用async/await
async function fetchData() {
    try {
        const a = await getData();
        const b = await getMoreData(a);
        const c = await getMoreData(b);
        const d = await getMoreData(c);
        console.log(d);
    } catch (error) {
        console.error(error);
    }
}
```

### 10.5.2 this绑定问题

#### 问题：this指向不明确

```javascript
const obj = {
    name: '张三',
    greet: function() {
        console.log(`Hello, ${this.name}`);
        
        setTimeout(function() {
            console.log(`Goodbye, ${this.name}`); // this指向全局对象或undefined
        }, 1000);
    }
};

obj.greet();
```

#### 解决方案：使用箭头函数或bind方法

```javascript
const obj = {
    name: '张三',
    greet: function() {
        console.log(`Hello, ${this.name}`);
        
        // 使用箭头函数
        setTimeout(() => {
            console.log(`Goodbye, ${this.name}`); // this继承自外层作用域
        }, 1000);
        
        // 或使用bind方法
        setTimeout(function() {
            console.log(`Goodbye, ${this.name}`);
        }.bind(this), 2000);
    }
};

obj.greet();
```

### 10.5.3 内存泄漏问题

#### 问题：未清理的事件监听器和定时器

```javascript
// 可能导致内存泄漏的代码
class Component {
    constructor() {
        this.data = new Array(1000000).fill(0);
        
        // 添加事件监听器
        window.addEventListener('resize', this.handleResize);
        
        // 设置定时器
        this.timer = setInterval(() => {
            this.updateData();
        }, 1000);
    }
    
    handleResize() {
        // 处理窗口大小变化
    }
    
    updateData() {
        // 更新数据
    }
}
```

#### 解决方案：提供清理方法

```javascript
class Component {
    constructor() {
        this.data = new Array(1000000).fill(0);
        
        // 绑定方法并保存引用
        this.handleResize = this.handleResize.bind(this);
        this.updateData = this.updateData.bind(this);
        
        // 添加事件监听器
        window.addEventListener('resize', this.handleResize);
        
        // 设置定时器
        this.timer = setInterval(this.updateData, 1000);
    }
    
    handleResize() {
        // 处理窗口大小变化
    }
    
    updateData() {
        // 更新数据
    }
    
    // 提供清理方法
    destroy() {
        // 移除事件监听器
        window.removeEventListener('resize', this.handleResize);
        
        // 清除定时器
        clearInterval(this.timer);
        
        // 清空数据
        this.data = null;
    }
}

// 使用示例
const component = new Component();
// 组件不再需要时
component.destroy();
```

### 10.5.4 性能问题

#### 问题：频繁的DOM操作

```javascript
// 低效的DOM操作
function addItems(count) {
    for (let i = 0; i < count; i++) {
        const item = document.createElement('div');
        item.textContent = `Item ${i}`;
        document.body.appendChild(item); // 每次都触发重排和重绘
    }
}
```

#### 解决方案：批量操作DOM

```javascript
// 高效的DOM操作
function addItems(count) {
    // 创建文档片段
    const fragment = document.createDocumentFragment();
    
    for (let i = 0; i < count; i++) {
        const item = document.createElement('div');
        item.textContent = `Item ${i}`;
        fragment.appendChild(item);
    }
    
    // 一次性添加到DOM
    document.body.appendChild(fragment);
}

// 或者使用innerHTML
function addItems(count) {
    let html = '';
    for (let i = 0; i < count; i++) {
        html += `<div>Item ${i}</div>`;
    }
    document.body.innerHTML += html;
}
```

## 10.6 总结与展望

### 10.6.1 本章回顾

本章介绍了ES6之后的重要JavaScript新特性，包括：

- ES2016-ES2022的主要新特性
- 性能优化技巧
- 代码风格与最佳实践
- 实战项目案例
- 常见问题与解决方案

这些新特性和最佳实践可以帮助开发者编写更现代、高效、可维护的JavaScript代码。

### 10.6.2 JavaScript的未来发展

JavaScript生态系统仍在快速发展，未来可能出现的趋势包括：

- 更多的语言特性，如管道操作符、模式匹配等
- 更好的类型检查和工具支持
- WebAssembly与JavaScript的更深度集成
- 更强大的并发和并行处理能力
- 更好的性能和内存管理

### 10.6.3 持续学习建议

要跟上JavaScript的发展，建议：

1. 定期阅读ECMAScript提案和规范
2. 关注主流JavaScript框架和库的更新
3. 参与开源项目和社区讨论
4. 尝试新特性并提供反馈
5. 保持代码质量和最佳实践

JavaScript是一门不断演进的语言，保持学习和实践是成为优秀JavaScript开发者的关键。

---

**下一章预告：** 本课程到此结束，希望您已经掌握了ES6及后续版本的重要特性，能够编写现代、高效的JavaScript代码。继续实践和探索，您将成为JavaScript专家！