# 第2章：函数式编程基础

## 学习目标

本章将深入讲解Scala的函数式编程特性，包括：
- 纯函数和副作用
- 不可变数据
- 高阶函数
- 函数组合
- 柯里化和偏应用函数
- 递归和尾递归优化
- 模式匹配的高级用法

## 环境要求

- Scala 2.13.x 或 3.x
- sbt 1.8.x
- 基本的Scala语法知识（完成第1章）

## 章节内容

### 2.1 函数式编程核心概念

#### 纯函数 (Pure Functions)
- 相同的输入总是产生相同的输出
- 没有副作用（不修改外部状态）
- 引用透明性

#### 不可变性 (Immutability)
- val vs var 的区别
- 不可变集合的优势
- 函数式数据转换

#### 一等公民函数 (First-class Functions)
- 函数可以作为参数传递
- 函数可以作为返回值
- 函数可以赋值给变量

### 2.2 高阶函数详解

#### 集合操作的高阶函数
- map: 转换每个元素
- filter: 过滤元素
- reduce/fold: 聚合操作
- flatMap: 扁平化映射

#### 自定义高阶函数
- 接受函数作为参数的函数
- 返回函数的函数
- 函数组合器

### 2.3 函数组合和柯里化

#### 函数组合 (Function Composition)
- compose 方法
- andThen 方法
- 管道式编程

#### 柯里化 (Currying)
- 多参数函数的柯里化
- 部分应用函数
- 柯里化的实际应用

### 2.4 递归和模式匹配

#### 递归函数
- 基本递归
- 尾递归优化
- @tailrec 注解

#### 模式匹配高级特性
- 类型模式匹配
- 守卫条件
- 提取器模式
- 密封类和模式匹配

### 2.5 函数式编程实践

#### Option类型
- 处理可能缺失的值
- 避免空指针异常
- Option的组合操作

#### Either类型
- 处理成功/失败场景
- 错误处理函数式风格
- Either的转换操作

#### 惰性求值
- lazy val
- Stream和LazyList
- 惰性计算的性能优势

## 实践练习

### 练习1：纯函数实现
实现一个纯函数版本的字符串处理工具，包含以下功能：
- 字符串反转
- 单词统计
- 字符频率统计

### 练习2：高阶函数应用
使用高阶函数实现以下功能：
- 列表元素的平方和
- 过滤并转换数据
- 自定义排序函数

### 练习3：函数组合器
创建通用的函数组合器，支持：
- 函数管道
- 条件组合
- 错误处理组合

### 练习4：递归算法
使用递归实现：
- 二叉树遍历
- 快速排序
- 目录结构遍历

## 代码示例结构

本章代码示例包含以下文件：

```
code/src/main/scala/chapter2/
├── PureFunctions.scala          # 纯函数示例
├── HigherOrderFunctions.scala   # 高阶函数示例
├── FunctionComposition.scala    # 函数组合示例
├── Currying.scala              # 柯里化示例
├── Recursion.scala             # 递归示例
├── PatternMatchingAdvanced.scala # 高级模式匹配
└── FunctionalCollections.scala  # 函数式集合操作
```

## 学习建议

1. **理解概念**：先理解函数式编程的核心思想，再学习具体语法
2. **动手实践**：每个概念都要通过代码示例来验证
3. **循序渐进**：从简单的高阶函数开始，逐步学习复杂的概念
4. **思考应用**：思考如何在日常编程中应用函数式编程思想

## 扩展阅读

- 《Scala函数式编程》
- Scala官方文档中的函数式编程部分
- Functional Programming in Scala 在线课程

## 下一章预告

第3章将介绍Scala的面向对象编程特性，包括类、对象、特质、继承等概念，以及如何将函数式编程和面向对象编程结合起来。

---

**注意**：本章的所有代码示例都可以在`code`目录中找到，并且都是可运行的完整示例。建议按照章节顺序学习，并动手运行每个示例来加深理解。