# 第6章：SQL连接与子查询

## 6.1 连接查询概述

### 什么是连接查询？

连接查询（JOIN）是从多个表中检索数据的SQL操作，通过关联表之间的列来组合结果。连接是关系型数据库的核心概念之一，允许我们从相关联的表中获取有意义的数据。

### 为什么需要连接查询？

在关系型数据库中，数据通常被分散到多个表中，以减少数据冗余和提高数据一致性。例如，员工信息可能在一个表中，部门信息在另一个表中。为了获取员工及其部门信息，我们需要使用连接查询。

### 连接查询的基本语法

```sql
SELECT column1, column2, ...
FROM table1
JOIN_TYPE table2 ON table1.column = table2.column
[JOIN_TYPE table3 ON table2.column = table3.column]
WHERE condition
ORDER BY column;
```

## 6.2 内连接（INNER JOIN）

### 什么是内连接？

内连接（INNER JOIN）只返回两个表中匹配的行，即两个表中连接列的值相等的行。如果某行在一个表中有值但在另一个表中没有匹配值，则该行不会出现在结果中。

### 基本语法

```sql
SELECT column1, column2, ...
FROM table1
INNER JOIN table2 ON table1.column = table2.column;
```

### 使用USING简化连接条件

如果两个表中的连接列具有相同的名称，可以使用USING关键字简化连接条件：

```sql
SELECT column1, column2, ...
FROM table1
INNER JOIN table2 USING (common_column);
```

### 使用自然连接

自然连接（NATURAL JOIN）会自动匹配两个表中所有名称相同的列：

```sql
SELECT column1, column2, ...
FROM table1
NATURAL JOIN table2;
```

### 内连接示例

```sql
-- 查询员工及其部门信息
SELECT e.name, e.position, d.name AS department
FROM employees e
INNER JOIN departments d ON e.department_id = d.id;

-- 使用WHERE实现相同效果
SELECT e.name, e.position, d.name AS department
FROM employees e, departments d
WHERE e.department_id = d.id;

-- 使用USING简化连接条件（假设两个表都有department_id列）
SELECT e.name, e.position, d.name AS department
FROM employees e
INNER JOIN departments d USING (department_id);

-- 查询员工参与的项目信息
SELECT 
    e.name AS employee_name,
    p.name AS project_name,
    ep.role,
    ep.hours_worked
FROM employees e
INNER JOIN employee_projects ep ON e.id = ep.employee_id
INNER JOIN projects p ON ep.project_id = p.id;
```

### 实验验证

让我们使用内连接进行一些查询：

```sql
-- 创建示例数据库
CREATE DATABASE IF NOT EXISTS company_demo CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE company_demo;

-- 创建部门表
CREATE TABLE departments (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    manager_id INT,
    location VARCHAR(100),
    budget DECIMAL(12, 2)
);

-- 创建员工表
CREATE TABLE employees (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    age INT,
    gender VARCHAR(10),
    department_id INT,
    position VARCHAR(50),
    salary DECIMAL(10, 2),
    hire_date DATE,
    email VARCHAR(100),
    phone VARCHAR(20),
    is_active BOOLEAN DEFAULT TRUE,
    manager_id INT,
    FOREIGN KEY (department_id) REFERENCES departments(id),
    FOREIGN KEY (manager_id) REFERENCES employees(id)
);

-- 创建项目表
CREATE TABLE projects (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    start_date DATE,
    end_date DATE,
    budget DECIMAL(12, 2)
);

-- 创建员工项目关联表
CREATE TABLE employee_projects (
    employee_id INT,
    project_id INT,
    role VARCHAR(50),
    hours_worked INT DEFAULT 0,
    PRIMARY KEY (employee_id, project_id),
    FOREIGN KEY (employee_id) REFERENCES employees(id),
    FOREIGN KEY (project_id) REFERENCES projects(id)
);

-- 插入部门数据
INSERT INTO departments (name, location, budget) VALUES
('技术部', '北京', 1000000.00),
('市场部', '上海', 800000.00),
('人事部', '广州', 500000.00),
('财务部', '深圳', 600000.00),
('研发部', '杭州', 1200000.00);

-- 插入员工数据
INSERT INTO employees (name, age, gender, department_id, position, salary, hire_date, email, phone) VALUES
('张三', 30, '男', 1, '高级工程师', 15000.00, '2020-01-15', 'zhangsan@example.com', '13800138001'),
('李四', 28, '女', 1, '工程师', 12000.00, '2020-03-20', 'lisi@example.com', '13800138002'),
('王五', 35, '男', 1, '工程师', 13000.00, '2019-06-10', 'wangwu@example.com', '13800138003'),
('赵六', 25, '女', 1, '初级工程师', 8000.00, '2021-02-28', 'zhaoliu@example.com', '13800138004'),
('钱七', 32, '男', 2, '市场经理', 18000.00, '2019-11-05', 'qianqi@example.com', '13800138005'),
('孙八', 27, '女', 2, '市场专员', 9000.00, '2020-07-12', 'sunba@example.com', '13800138006'),
('周九', 40, '男', 2, '市场专员', 8500.00, '2020-05-20', 'zhoujiu@example.com', '13800138007'),
('吴十', 29, '女', 3, '人事经理', 16000.00, '2018-09-15', 'wushi@example.com', '13800138008'),
('郑十一', 26, '男', 3, '人事专员', 7000.00, '2021-01-10', 'zhengshiyi@example.com', '13800138009'),
('陈十二', 33, '女', 4, '财务经理', 20000.00, '2019-03-15', 'chenshier@example.com', '13800138010'),
('林十三', 28, '男', 4, '会计', 10000.00, '2020-06-20', 'linshisan@example.com', '13800138011'),
('黄十四', 36, '男', 5, '研发经理', 25000.00, '2018-05-10', 'huangshisi@example.com', '13800138012'),
('刘十五', 31, '女', 5, '高级研究员', 18000.00, '2019-08-15', 'liushiwu@example.com', '13800138013'),
('徐十六', 29, '男', 5, '研究员', 14000.00, '2020-02-20', 'xushiliu@example.com', '13800138014');

-- 插入项目数据
INSERT INTO projects (name, start_date, end_date, budget) VALUES
('项目A', '2023-01-01', '2023-12-31', 500000.00),
('项目B', '2023-03-01', '2023-08-31', 200000.00),
('项目C', '2023-04-01', '2023-09-30', 150000.00),
('项目D', '2023-02-15', '2023-11-30', 300000.00),
('项目E', '2023-05-01', '2023-10-31', 250000.00);

-- 插入员工项目关联数据
INSERT INTO employee_projects (employee_id, project_id, role, hours_worked) VALUES
(1, 1, '项目经理', 320),
(2, 1, '开发工程师', 400),
(3, 2, '项目经理', 200),
(4, 2, '市场专员', 300),
(5, 3, '项目经理', 150),
(6, 3, '人事专员', 200),
(7, 4, '项目经理', 250),
(8, 4, '人事专员', 180),
(9, 5, '项目经理', 220),
(10, 5, '财务专员', 160),
(11, 1, '财务专员', 120),
(12, 2, '会计', 140),
(13, 3, '研发主管', 280),
(14, 4, '高级研究员', 350),
(15, 5, '研究员', 300);

-- 内连接：查询员工及其部门信息
SELECT 
    e.name AS '员工姓名',
    e.position AS '职位',
    d.name AS '部门名称',
    d.location AS '部门位置'
FROM employees e
INNER JOIN departments d ON e.department_id = d.id
ORDER BY d.name, e.name;

-- 内连接：查询员工参与的项目信息
SELECT 
    e.name AS '员工姓名',
    p.name AS '项目名称',
    ep.role AS '角色',
    ep.hours_worked AS '工作小时数'
FROM employees e
INNER JOIN employee_projects ep ON e.id = ep.employee_id
INNER JOIN projects p ON ep.project_id = p.id
ORDER BY e.name, p.name;
```

## 6.3 外连接（OUTER JOIN）

### 什么是外连接？

外连接（OUTER JOIN）返回两个表中的所有行，即使在另一个表中没有匹配的行。外连接分为左外连接（LEFT OUTER JOIN）、右外连接（RIGHT OUTER JOIN）和全外连接（FULL OUTER JOIN）。

### 左外连接（LEFT JOIN）

左外连接返回左表的所有行，以及右表中匹配的行。如果右表中没有匹配的行，则结果中右表的列将显示为NULL。

#### 基本语法

```sql
SELECT column1, column2, ...
FROM table1
LEFT JOIN table2 ON table1.column = table2.column;
```

#### 左外连接示例

```sql
-- 查询所有员工及其部门信息（即使没有部门）
SELECT e.name, e.position, d.name AS department
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id;

-- 查询没有部门的员工
SELECT e.name, e.position
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id
WHERE d.id IS NULL;

-- 查询所有部门及其员工数量（包括没有员工的部门）
SELECT 
    d.name AS department,
    COUNT(e.id) AS employee_count
FROM departments d
LEFT JOIN employees e ON d.id = e.department_id
GROUP BY d.id, d.name
ORDER BY employee_count DESC;
```

### 右外连接（RIGHT JOIN）

右外连接返回右表的所有行，以及左表中匹配的行。如果左表中没有匹配的行，则结果中左表的列将显示为NULL。

#### 基本语法

```sql
SELECT column1, column2, ...
FROM table1
RIGHT JOIN table2 ON table1.column = table2.column;
```

#### 右外连接示例

```sql
-- 查询所有部门及其员工信息（即使没有员工）
SELECT e.name, e.position, d.name AS department
FROM employees e
RIGHT JOIN departments d ON e.department_id = d.id;

-- 查询没有员工的部门
SELECT d.name, d.location
FROM employees e
RIGHT JOIN departments d ON e.department_id = d.id
WHERE e.id IS NULL;
```

### 全外连接（FULL OUTER JOIN）

全外连接返回两个表中的所有行，无论是否匹配。如果某行在一个表中有值但在另一个表中没有匹配值，则结果中另一个表的列将显示为NULL。

**注意**：MySQL不支持FULL OUTER JOIN，但可以通过UNION来模拟：

```sql
-- MySQL不支持FULL OUTER JOIN，可以使用UNION模拟
SELECT e.name, e.position, d.name AS department
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id
UNION
SELECT e.name, e.position, d.name AS department
FROM employees e
RIGHT JOIN departments d ON e.department_id = d.id
WHERE e.id IS NULL;
```

### 实验验证

让我们使用外连接进行一些查询：

```sql
-- 左连接：查询所有员工及其部门信息（即使没有部门）
SELECT 
    e.name AS '员工姓名',
    e.position AS '职位',
    d.name AS '部门名称'
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id;

-- 查询没有员工的部门
SELECT 
    d.name AS '部门名称',
    d.location AS '部门位置'
FROM departments d
LEFT JOIN employees e ON d.id = e.department_id
WHERE e.id IS NULL;

-- 右连接：查询所有部门及其员工信息（即使没有员工）
SELECT 
    e.name AS '员工姓名',
    e.position AS '职位',
    d.name AS '部门名称'
FROM employees e
RIGHT JOIN departments d ON e.department_id = d.id;

-- 使用UNION模拟全外连接
SELECT 
    e.name AS '员工姓名',
    e.position AS '职位',
    d.name AS '部门名称'
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id
UNION
SELECT 
    e.name AS '员工姓名',
    e.position AS '职位',
    d.name AS '部门名称'
FROM employees e
RIGHT JOIN departments d ON e.department_id = d.id
WHERE e.id IS NULL;
```

## 6.4 自连接（SELF JOIN）

### 什么是自连接？

自连接是指表与自身进行连接，通常用于处理层次结构数据或比较同一表中的行。自连接需要为表使用不同的别名，以区分同一个表的两个实例。

### 基本语法

```sql
SELECT column1, column2, ...
FROM table1 t1
JOIN table1 t2 ON t1.column = t2.column;
```

### 自连接的应用场景

1. **查找层次结构数据**：如员工与经理的关系
2. **查找重复数据**：如查找相同姓名或邮箱的员工
3. **比较同一表中的行**：如查找薪资高于其他员工的员工

### 自连接示例

```sql
-- 为员工表添加manager_id列（如果不存在）
ALTER TABLE employees ADD COLUMN manager_id INT;
ALTER TABLE employees ADD FOREIGN KEY (manager_id) REFERENCES employees(id);

-- 更新一些员工的manager_id
UPDATE employees SET manager_id = 1 WHERE id IN (2, 3);
UPDATE employees SET manager_id = 5 WHERE id IN (6, 7);
UPDATE employees SET manager_id = 8 WHERE id IN (9);
UPDATE employees SET manager_id = 10 WHERE id IN (11, 12);
UPDATE employees SET manager_id = 13 WHERE id IN (14, 15);

-- 查询员工及其经理信息
SELECT 
    e.name AS employee_name,
    e.position AS employee_position,
    m.name AS manager_name,
    m.position AS manager_position
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id
ORDER BY e.name;

-- 查询同一部门中薪资高于其他员工的员工
SELECT 
    e1.name AS employee_name,
    e1.salary AS employee_salary,
    e2.name AS compared_employee,
    e2.salary AS compared_salary
FROM employees e1
JOIN employees e2 ON e1.department_id = e2.department_id AND e1.salary > e2.salary
ORDER BY e1.name, e2.name;

-- 查找相同职位的员工
SELECT 
    e1.name AS employee1,
    e1.position AS position,
    e2.name AS employee2,
    e2.position AS position
FROM employees e1
JOIN employees e2 ON e1.position = e2.position AND e1.id < e2.id
ORDER BY e1.position, e1.name;
```

### 实验验证

让我们使用自连接进行一些查询：

```sql
-- 自连接：查询员工及其经理信息
SELECT 
    e.name AS '员工姓名',
    e.position AS '员工职位',
    m.name AS '经理姓名',
    m.position AS '经理职位'
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id
ORDER BY e.name;

-- 查询同一部门中薪资高于其他员工的员工
SELECT 
    e1.name AS '员工姓名',
    e1.salary AS '员工薪资',
    e2.name AS '比较员工',
    e2.salary AS '比较员工薪资'
FROM employees e1
JOIN employees e2 ON e1.department_id = e2.department_id AND e1.salary > e2.salary
ORDER BY e1.name, e2.name;

-- 查找相同职位的员工
SELECT 
    e1.name AS '员工1',
    e1.position AS '职位',
    e2.name AS '员工2',
    e2.position AS '职位'
FROM employees e1
JOIN employees e2 ON e1.position = e2.position AND e1.id < e2.id
ORDER BY e1.position, e1.name;
```

## 6.5 交叉连接（CROSS JOIN）

### 什么是交叉连接？

交叉连接（CROSS JOIN）返回两个表的笛卡尔积，即第一个表中的每一行与第二个表中的每一行组合。如果第一个表有m行，第二个表有n行，则结果将有m×n行。

### 基本语法

```sql
SELECT column1, column2, ...
FROM table1
CROSS JOIN table2;

-- 或者使用旧的语法
SELECT column1, column2, ...
FROM table1, table2;
```

### 交叉连接的应用场景

1. **生成所有可能的组合**：如产品与颜色的所有组合
2. **生成测试数据**：如生成所有可能的用户-权限组合
3. **创建矩阵或网格**：如创建时间-地点的矩阵

### 交叉连接示例

```sql
-- 创建颜色表
CREATE TABLE colors (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(20) NOT NULL
);

INSERT INTO colors (name) VALUES ('红色'), ('蓝色'), ('绿色'), ('黄色');

-- 创建产品表
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL
);

INSERT INTO products (name) VALUES ('T恤'), ('裤子'), ('帽子'), ('鞋子');

-- 交叉连接：生成产品与颜色的所有组合
SELECT 
    p.name AS product,
    c.name AS color,
    CONCAT(p.name, '-', c.name) AS product_color
FROM products p
CROSS JOIN colors c
ORDER BY p.name, c.name;

-- 使用交叉连接生成测试数据
SELECT 
    e.name AS employee,
    d.name AS department
FROM employees e
CROSS JOIN departments d
ORDER BY e.name, d.name;
```

### 实验验证

让我们使用交叉连接进行一些查询：

```sql
-- 创建颜色表
CREATE TABLE colors (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(20) NOT NULL
);

INSERT INTO colors (name) VALUES ('红色'), ('蓝色'), ('绿色'), ('黄色');

-- 创建产品表
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL
);

INSERT INTO products (name) VALUES ('T恤'), ('裤子'), ('帽子'), ('鞋子');

-- 交叉连接：生成产品与颜色的所有组合
SELECT 
    p.name AS '产品',
    c.name AS '颜色',
    CONCAT(p.name, '-', c.name) AS '产品-颜色组合'
FROM products p
CROSS JOIN colors c
ORDER BY p.name, c.name;
```

## 6.6 子查询概述

### 什么是子查询？

子查询是嵌套在另一个查询中的查询，也称为内部查询或内部选择。子查询可以返回单个值、一列值、一行值或一个表，并可以在SELECT、FROM、WHERE、HAVING等子句中使用。

### 子查询的类型

| 类型 | 描述 | 返回值 |
|------|------|--------|
| 标量子查询 | 返回单个值的子查询 | 单个值 |
| 列表子查询 | 返回一列值的子查询 | 一列值 |
| 行子查询 | 返回一行值的子查询 | 一行值 |
| 表子查询 | 返回一个表的子查询 | 多行多列 |

### 子查询 vs 连接查询

| 特性 | 子查询 | 连接查询 |
|------|--------|----------|
| 可读性 | 复杂查询可能更难读 | 通常更直观 |
| 性能 | 可能较低（取决于优化器） | 通常更高 |
| 灵活性 | 更灵活，可用于多种场景 | 主要用于表连接 |
| 嵌套 | 可以多层嵌套 | 不支持嵌套 |

## 6.7 标量子查询

### 什么是标量子查询？

标量子查询返回单个值，可以用于任何期望单个值的上下文中，如SELECT、WHERE、HAVING等子句中。

### 标量子查询在SELECT子句中使用

```sql
-- 查询每个员工的薪资与平均薪资的差距
SELECT 
    name, 
    salary,
    (SELECT AVG(salary) FROM employees) AS avg_salary,
    salary - (SELECT AVG(salary) FROM employees) AS difference
FROM employees;
```

### 标量子查询在WHERE子句中使用

```sql
-- 查询薪资高于平均薪资的员工
SELECT name, position, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);

-- 查询薪资最高的员工
SELECT name, position, salary
FROM employees
WHERE salary = (SELECT MAX(salary) FROM employees);
```

### 标量子查询在HAVING子句中使用

```sql
-- 查询平均薪资高于公司平均薪资的部门
SELECT 
    d.name AS department,
    AVG(e.salary) AS avg_salary
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.id, d.name
HAVING AVG(e.salary) > (SELECT AVG(salary) FROM employees);
```

### 实验验证

让我们使用标量子查询进行一些查询：

```sql
-- 标量子查询在SELECT子句中使用
SELECT 
    name, 
    salary,
    (SELECT AVG(salary) FROM employees) AS '平均薪资',
    salary - (SELECT AVG(salary) FROM employees) AS '与平均薪资的差距'
FROM employees;

-- 标量子查询在WHERE子句中使用
SELECT name, position, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);

-- 查询薪资最高的员工
SELECT name, position, salary
FROM employees
WHERE salary = (SELECT MAX(salary) FROM employees);

-- 标量子查询在HAVING子句中使用
SELECT 
    d.name AS '部门',
    AVG(e.salary) AS '平均薪资'
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.id, d.name
HAVING AVG(e.salary) > (SELECT AVG(salary) FROM employees);
```

## 6.8 列表子查询

### 什么是列表子查询？

列表子查询返回一列值，通常与IN、ANY、ALL、SOME等运算符一起使用。

### 使用IN运算符

```sql
-- 查询技术部（部门ID=1）的员工
SELECT name, position, department_id
FROM employees
WHERE department_id IN (SELECT id FROM departments WHERE name = '技术部');

-- 查询参与项目的员工
SELECT name, position
FROM employees
WHERE id IN (SELECT DISTINCT employee_id FROM employee_projects);
```

### 使用ANY/SOME运算符

```sql
-- 查询薪资大于任何市场部员工薪资的技术部员工
SELECT name, position, salary
FROM employees
WHERE department_id = 1 AND salary > ANY (
    SELECT salary FROM employees WHERE department_id = 2
);

-- SOME是ANY的同义词
SELECT name, position, salary
FROM employees
WHERE department_id = 1 AND salary > SOME (
    SELECT salary FROM employees WHERE department_id = 2
);
```

### 使用ALL运算符

```sql
-- 查询薪资大于所有市场部员工薪资的技术部员工
SELECT name, position, salary
FROM employees
WHERE department_id = 1 AND salary > ALL (
    SELECT salary FROM employees WHERE department_id = 2
);

-- 查询薪资不小于任何员工薪资的员工（即薪资最高的员工）
SELECT name, position, salary
FROM employees
WHERE salary >= ALL (SELECT salary FROM employees);
```

### 实验验证

让我们使用列表子查询进行一些查询：

```sql
-- 使用IN运算符查询技术部的员工
SELECT name, position, department_id
FROM employees
WHERE department_id IN (SELECT id FROM departments WHERE name = '技术部');

-- 查询参与项目的员工
SELECT name, position
FROM employees
WHERE id IN (SELECT DISTINCT employee_id FROM employee_projects);

-- 使用ANY运算符查询薪资大于任何市场部员工薪资的技术部员工
SELECT name, position, salary
FROM employees
WHERE department_id = 1 AND salary > ANY (
    SELECT salary FROM employees WHERE department_id = 2
);

-- 使用ALL运算符查询薪资大于所有市场部员工薪资的技术部员工
SELECT name, position, salary
FROM employees
WHERE department_id = 1 AND salary > ALL (
    SELECT salary FROM employees WHERE department_id = 2
);
```

## 6.9 行子查询

### 什么是行子查询？

行子查询返回一行值，通常与行构造器一起使用，用于比较多个列的值。

### 行子查询示例

```sql
-- 查询与张三职位和薪资相同的员工
SELECT name, position, salary
FROM employees
WHERE (position, salary) = (
    SELECT position, salary FROM employees WHERE name = '张三'
);

-- 查询与李四部门和职位相同的员工
SELECT name, department_id, position
FROM employees
WHERE (department_id, position) = (
    SELECT department_id, position FROM employees WHERE name = '李四'
);

-- 使用行子查询进行范围比较
SELECT name, position, salary
FROM employees
WHERE (salary, age) > (
    SELECT salary, age FROM employees WHERE name = '赵六'
);
```

### 实验验证

让我们使用行子查询进行一些查询：

```sql
-- 查询与张三职位和薪资相同的员工
SELECT name, position, salary
FROM employees
WHERE (position, salary) = (
    SELECT position, salary FROM employees WHERE name = '张三'
);

-- 查询与李四部门和职位相同的员工
SELECT name, department_id, position
FROM employees
WHERE (department_id, position) = (
    SELECT department_id, position FROM employees WHERE name = '李四'
);

-- 使用行子查询进行范围比较
SELECT name, position, salary, age
FROM employees
WHERE (salary, age) > (
    SELECT salary, age FROM employees WHERE name = '赵六'
);
```

## 6.10 表子查询

### 什么是表子查询？

表子查询返回多行多列，通常用于FROM子句中，作为派生表使用。

### 表子查询在FROM子句中使用

```sql
-- 查询各部门的平均薪资
SELECT department_name, avg_salary
FROM (
    SELECT 
        d.name AS department_name,
        AVG(e.salary) AS avg_salary
    FROM employees e
    JOIN departments d ON e.department_id = d.id
    GROUP BY d.name
) AS dept_avg
WHERE avg_salary > 10000;

-- 查询薪资高于其部门平均薪资的员工
SELECT e.name, e.salary, e.department_id, d.avg_salary
FROM employees e
JOIN (
    SELECT department_id, AVG(salary) AS avg_salary
    FROM employees
    GROUP BY department_id
) AS d ON e.department_id = d.department_id
WHERE e.salary > d.avg_salary;
```

### 表子查询与JOIN结合使用

```sql
-- 查询各部门中薪资最高的员工
SELECT e.name, e.salary, e.department_id, d.name AS department
FROM employees e
JOIN departments d ON e.department_id = d.id
JOIN (
    SELECT department_id, MAX(salary) AS max_salary
    FROM employees
    GROUP BY department_id
) AS max_sal ON e.department_id = max_sal.department_id AND e.salary = max_sal.max_salary;
```

### 实验验证

让我们使用表子查询进行一些查询：

```sql
-- 表子查询在FROM子句中使用
SELECT department_name, avg_salary
FROM (
    SELECT 
        d.name AS department_name,
        AVG(e.salary) AS avg_salary
    FROM employees e
    JOIN departments d ON e.department_id = d.id
    GROUP BY d.name
) AS dept_avg
WHERE avg_salary > 10000;

-- 查询薪资高于其部门平均薪资的员工
SELECT e.name, e.salary, e.department_id, d.avg_salary
FROM employees e
JOIN (
    SELECT department_id, AVG(salary) AS avg_salary
    FROM employees
    GROUP BY department_id
) AS d ON e.department_id = d.department_id
WHERE e.salary > d.avg_salary;

-- 查询各部门中薪资最高的员工
SELECT e.name, e.salary, e.department_id, d.name AS department
FROM employees e
JOIN departments d ON e.department_id = d.id
JOIN (
    SELECT department_id, MAX(salary) AS max_salary
    FROM employees
    GROUP BY department_id
) AS max_sal ON e.department_id = max_sal.department_id AND e.salary = max_sal.max_salary;
```

## 6.11 相关子查询

### 什么是相关子查询？

相关子查询是指子查询依赖于外部查询的值，即子查询的执行依赖于外部查询的当前行。相关子查询对于外部查询的每一行都会执行一次。

### 相关子查询示例

```sql
-- 查询薪资高于其所在部门平均薪资的员工
SELECT name, salary, department_id
FROM employees e1
WHERE salary > (
    SELECT AVG(salary)
    FROM employees e2
    WHERE e2.department_id = e1.department_id
);

-- 查询每个部门中薪资最高的员工
SELECT name, salary, department_id
FROM employees e1
WHERE salary = (
    SELECT MAX(salary)
    FROM employees e2
    WHERE e2.department_id = e1.department_id
);

-- 查询每个项目中工作小时数最多的员工
SELECT e.name, p.name AS project, ep.hours_worked
FROM employees e
JOIN employee_projects ep ON e.id = ep.employee_id
JOIN projects p ON ep.project_id = p.id
WHERE ep.hours_worked = (
    SELECT MAX(hours_worked)
    FROM employee_projects ep2
    WHERE ep2.project_id = ep.project_id
);
```

### 相关子查询 vs 非相关子查询

| 特性 | 相关子查询 | 非相关子查询 |
|------|------------|--------------|
| 执行方式 | 对外部查询的每一行执行一次 | 只执行一次 |
| 性能 | 通常较低 | 通常较高 |
| 依赖性 | 依赖于外部查询的值 | 不依赖于外部查询的值 |
| 适用场景 | 需要基于当前行进行比较的场景 | 可以独立执行的查询 |

### 实验验证

让我们使用相关子查询进行一些查询：

```sql
-- 查询薪资高于其所在部门平均薪资的员工
SELECT 
    e1.name, 
    e1.salary, 
    e1.department_id,
    (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department_id = e1.department_id) AS dept_avg_salary
FROM employees e1
WHERE e1.salary > (
    SELECT AVG(e2.salary)
    FROM employees e2
    WHERE e2.department_id = e1.department_id
);

-- 查询每个部门中薪资最高的员工
SELECT name, salary, department_id
FROM employees e1
WHERE salary = (
    SELECT MAX(e2.salary)
    FROM employees e2
    WHERE e2.department_id = e1.department_id
);

-- 查询每个项目中工作小时数最多的员工
SELECT e.name, p.name AS project, ep.hours_worked
FROM employees e
JOIN employee_projects ep ON e.id = ep.employee_id
JOIN projects p ON ep.project_id = p.id
WHERE ep.hours_worked = (
    SELECT MAX(ep2.hours_worked)
    FROM employee_projects ep2
    WHERE ep2.project_id = ep.project_id
);
```

## 6.12 EXISTS和NOT EXISTS

### 什么是EXISTS？

EXISTS用于检查子查询是否返回任何行。如果子查询返回至少一行，则EXISTS返回TRUE；否则返回FALSE。NOT EXISTS则相反，如果子查询不返回任何行，则返回TRUE。

### EXISTS示例

```sql
-- 查询有员工的部门
SELECT name, location
FROM departments d
WHERE EXISTS (
    SELECT 1 FROM employees e WHERE e.department_id = d.id
);

-- 查询有项目的员工
SELECT name, position
FROM employees e
WHERE EXISTS (
    SELECT 1 FROM employee_projects ep WHERE ep.employee_id = e.id
);

-- 查询参与多个项目的员工
SELECT name, position
FROM employees e
WHERE EXISTS (
    SELECT project_id FROM employee_projects ep WHERE ep.employee_id = e.id
) AND (
    SELECT COUNT(DISTINCT project_id) FROM employee_projects ep WHERE ep.employee_id = e.id
) > 1;
```

### NOT EXISTS示例

```sql
-- 查询没有员工的部门
SELECT name, location
FROM departments d
WHERE NOT EXISTS (
    SELECT 1 FROM employees e WHERE e.department_id = d.id
);

-- 查询没有参与项目的员工
SELECT name, position
FROM employees e
WHERE NOT EXISTS (
    SELECT 1 FROM employee_projects ep WHERE ep.employee_id = e.id
);

-- 查询没有下属的员工（即不是经理的员工）
SELECT name, position
FROM employees e1
WHERE NOT EXISTS (
    SELECT 1 FROM employees e2 WHERE e2.manager_id = e1.id
);
```

### EXISTS vs IN

EXISTS和IN在某些情况下可以互换使用，但它们的工作方式不同：

```sql
-- 使用IN
SELECT name, position
FROM employees
WHERE department_id IN (SELECT id FROM departments WHERE location = '北京');

-- 使用EXISTS
SELECT e.name, e.position
FROM employees e
WHERE EXISTS (
    SELECT 1 FROM departments d WHERE d.id = e.department_id AND d.location = '北京'
);
```

### 实验验证

让我们使用EXISTS和NOT EXISTS进行一些查询：

```sql
-- EXISTS查询有员工的部门
SELECT name, location
FROM departments d
WHERE EXISTS (
    SELECT 1 FROM employees e WHERE e.department_id = d.id
);

-- NOT EXISTS查询没有员工的部门
SELECT name, location
FROM departments d
WHERE NOT EXISTS (
    SELECT 1 FROM employees e WHERE e.department_id = d.id
);

-- EXISTS查询有项目的员工
SELECT name, position
FROM employees e
WHERE EXISTS (
    SELECT 1 FROM employee_projects ep WHERE ep.employee_id = e.id
);

-- NOT EXISTS查询没有参与项目的员工
SELECT name, position
FROM employees e
WHERE NOT EXISTS (
    SELECT 1 FROM employee_projects ep WHERE ep.employee_id = e.id
);

-- EXISTS vs IN比较
-- 使用IN
SELECT name, position
FROM employees
WHERE department_id IN (SELECT id FROM departments WHERE location = '北京');

-- 使用EXISTS
SELECT e.name, e.position
FROM employees e
WHERE EXISTS (
    SELECT 1 FROM departments d WHERE d.id = e.department_id AND d.location = '北京'
);
```

## 6.13 本章小结

本章介绍了SQL的连接与子查询，包括：

1. **内连接（INNER JOIN）**：只返回两个表中匹配的行
2. **外连接（OUTER JOIN）**：返回一个表的所有行和另一个表中的匹配行
3. **自连接（SELF JOIN）**：表与自身连接，用于处理层次结构数据
4. **交叉连接（CROSS JOIN）**：返回两个表的笛卡尔积
5. **子查询**：嵌套在另一个查询中的查询，包括标量子查询、列表子查询、行子查询和表子查询
6. **相关子查询**：依赖于外部查询的子查询
7. **EXISTS和NOT EXISTS**：检查子查询是否返回任何行

通过本章的学习，您应该能够：

- 使用各种连接查询从多个表中检索数据
- 使用自连接处理层次结构数据
- 使用各种类型的子查询实现复杂的查询逻辑
- 理解相关子查询和非相关子查询的区别
- 使用EXISTS和NOT EXISTS检查子查询是否返回行

## 6.14 思考题

1. 内连接和外连接有什么区别？在什么情况下应该使用外连接？
2. 自连接适用于哪些场景？如何使用自连接查询层次结构数据？
3. 相关子查询和非相关子查询有什么区别？它们的执行过程有何不同？
4. EXISTS和IN有什么区别？在什么情况下使用EXISTS更合适？
5. 子查询和连接查询有什么区别？在什么情况下应该使用子查询，什么情况下应该使用连接查询？

## 6.15 下章预告

在第7章中，我们将学习SQL的聚合与分组，包括：

- 聚合函数详解
- GROUP BY子句的使用
- HAVING子句的应用
- 高级分组技巧
- 聚合函数与连接查询的结合

---

*继续学习，掌握SQL聚合与分组的技巧！*