# 第8章：SQL高级特性

## 8.1 视图（Views）

### 8.1.1 视图的概念

视图（View）是基于SQL查询结果的虚拟表，它本身不存储数据，而是存储一个查询语句。当查询视图时，数据库会执行视图定义的查询语句并返回结果。

视图的主要优点：
- **简化复杂查询**：将复杂的SQL查询封装为简单的视图
- **数据安全**：限制用户只能看到特定列或行
- **逻辑数据独立性**：改变基础表结构不影响使用视图的应用程序
- **数据一致性**：确保多个应用程序使用相同的数据逻辑

### 8.1.2 创建视图

创建视图的基本语法：

```sql
CREATE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
```

示例：创建一个显示员工基本信息的视图

```sql
CREATE VIEW employee_basic_info AS
SELECT 
    id, 
    name, 
    position, 
    department_id,
    salary
FROM employees;
```

### 8.1.3 使用视图

使用视图就像使用普通表一样：

```sql
-- 查询视图
SELECT * FROM employee_basic_info;

-- 对视图进行条件查询
SELECT * FROM employee_basic_info WHERE salary > 10000;

-- 对视图进行排序
SELECT * FROM employee_basic_info ORDER BY salary DESC;
```

### 8.1.4 修改和删除视图

修改视图：

```sql
-- 使用CREATE OR REPLACE VIEW修改视图
CREATE OR REPLACE VIEW employee_basic_info AS
SELECT 
    id, 
    name, 
    position, 
    d.name AS department_name,
    salary
FROM employees e
JOIN departments d ON e.department_id = d.id;
```

删除视图：

```sql
DROP VIEW view_name;
```

### 8.1.5 视图的限制

- 视图不能包含ORDER BY子句（除非使用了TOP等限制子句）
- 视图不能包含参数
- 某些视图不支持INSERT、UPDATE、DELETE操作
- 视图不能引用临时表或表变量

## 8.2 存储过程（Stored Procedures）

### 8.2.1 存储过程的概念

存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集合，经编译后存储在数据库中，可以通过名称调用并传递参数。

存储过程的优点：
- **提高性能**：预编译，减少网络传输
- **减少网络流量**：只需传递参数和调用命令
- **增强安全性**：可以限制用户直接操作表
- **代码复用**：一次编写，多次调用
- **事务管理**：可以在存储过程中处理事务

### 8.2.2 创建存储过程

创建存储过程的基本语法：

```sql
CREATE PROCEDURE procedure_name
    [参数列表]
AS
BEGIN
    -- SQL语句
END;
```

示例：创建一个根据部门ID查询员工信息的存储过程

```sql
CREATE PROCEDURE GetEmployeesByDepartment
    @DeptId INT
AS
BEGIN
    SELECT 
        e.id,
        e.name,
        e.position,
        e.salary,
        d.name AS department
    FROM employees e
    JOIN departments d ON e.department_id = d.id
    WHERE e.department_id = @DeptId;
END;
```

### 8.2.3 调用存储过程

调用存储过程：

```sql
-- 不带参数的存储过程
EXEC procedure_name;

-- 带参数的存储过程
EXEC GetEmployeesByDepartment @DeptId = 1;
```

### 8.2.4 带输出参数的存储过程

```sql
CREATE PROCEDURE GetEmployeeCountByDepartment
    @DeptId INT,
    @EmployeeCount INT OUTPUT
AS
BEGIN
    SELECT @EmployeeCount = COUNT(*)
    FROM employees
    WHERE department_id = @DeptId;
END;
```

调用带输出参数的存储过程：

```sql
DECLARE @Count INT;
EXEC GetEmployeeCountByDepartment @DeptId = 1, @EmployeeCount = @Count OUTPUT;
PRINT '员工数量: ' + CAST(@Count AS VARCHAR);
```

### 8.2.5 修改和删除存储过程

修改存储过程：

```sql
ALTER PROCEDURE procedure_name
    [参数列表]
AS
BEGIN
    -- 新的SQL语句
END;
```

删除存储过程：

```sql
DROP PROCEDURE procedure_name;
```

## 8.3 函数（Functions）

### 8.3.1 函数的概念

函数（Function）是接受输入参数、执行操作并返回结果的SQL代码块。与存储过程不同，函数必须返回一个值。

函数的类型：
- **标量函数**：返回单个值
- **表值函数**：返回表

### 8.3.2 创建标量函数

创建标量函数的基本语法：

```sql
CREATE FUNCTION function_name
    [参数列表]
RETURNS return_data_type
AS
BEGIN
    -- 函数体
    RETURN return_value;
END;
```

示例：创建一个计算员工年薪的函数

```sql
CREATE FUNCTION CalculateAnnualSalary
    (@Salary DECIMAL(10, 2), @Bonus DECIMAL(10, 2) = 0)
RETURNS DECIMAL(12, 2)
AS
BEGIN
    DECLARE @AnnualSalary DECIMAL(12, 2);
    SET @AnnualSalary = (@Salary * 12) + @Bonus;
    RETURN @AnnualSalary;
END;
```

使用标量函数：

```sql
SELECT 
    name,
    salary,
    dbo.CalculateAnnualSalary(salary, 5000) AS annual_salary
FROM employees;
```

### 8.3.3 创建表值函数

创建内联表值函数：

```sql
CREATE FUNCTION GetEmployeesByDepartment
    (@DeptId INT)
RETURNS TABLE
AS
RETURN
(
    SELECT 
        e.id,
        e.name,
        e.position,
        e.salary,
        d.name AS department
    FROM employees e
    JOIN departments d ON e.department_id = d.id
    WHERE e.department_id = @DeptId
);
```

使用表值函数：

```sql
SELECT * FROM dbo.GetEmployeesByDepartment(1);
```

创建多语句表值函数：

```sql
CREATE FUNCTION GetDepartmentStats
    (@DeptId INT)
RETURNS @DeptStats TABLE
(
    department_name VARCHAR(50),
    employee_count INT,
    avg_salary DECIMAL(10, 2),
    min_salary DECIMAL(10, 2),
    max_salary DECIMAL(10, 2)
)
AS
BEGIN
    INSERT INTO @DeptStats
    SELECT 
        d.name,
        COUNT(e.id),
        AVG(e.salary),
        MIN(e.salary),
        MAX(e.salary)
    FROM departments d
    LEFT JOIN employees e ON d.id = e.department_id
    WHERE d.id = @DeptId
    GROUP BY d.name;
    
    RETURN;
END;
```

### 8.3.4 修改和删除函数

修改函数：

```sql
ALTER FUNCTION function_name
    [参数列表]
RETURNS return_data_type
AS
BEGIN
    -- 新的函数体
    RETURN return_value;
END;
```

删除函数：

```sql
DROP FUNCTION function_name;
```

## 8.4 触发器（Triggers）

### 8.4.1 触发器的概念

触发器（Trigger）是一种特殊类型的存储过程，它在特定表上发生特定事件（如INSERT、UPDATE或DELETE）时自动执行。

触发器的类型：
- **AFTER触发器**：在操作执行后触发
- **INSTEAD OF触发器**：代替操作执行
- **BEFORE触发器**：在操作执行前触发（某些数据库支持）

触发器的优点：
- **数据完整性**：自动执行业务规则
- **审计跟踪**：记录数据变更
- **级联操作**：自动执行相关操作

### 8.4.2 创建触发器

创建AFTER触发器的基本语法：

```sql
CREATE TRIGGER trigger_name
ON table_name
AFTER [INSERT, UPDATE, DELETE]
AS
BEGIN
    -- 触发器代码
END;
```

示例：创建一个记录员工薪资变更的触发器

```sql
-- 创建薪资变更记录表
CREATE TABLE salary_history (
    id INT IDENTITY(1,1) PRIMARY KEY,
    employee_id INT,
    old_salary DECIMAL(10, 2),
    new_salary DECIMAL(10, 2),
    change_date DATETIME DEFAULT GETDATE(),
    changed_by VARCHAR(50)
);

-- 创建触发器
CREATE TRIGGER tr_SalaryChange
ON employees
AFTER UPDATE
AS
BEGIN
    -- 检查是否更新了薪资
    IF UPDATE(salary)
    BEGIN
        INSERT INTO salary_history (employee_id, old_salary, new_salary)
        SELECT 
            i.id,
            d.salary AS old_salary,
            i.salary AS new_salary
        FROM inserted i
        JOIN deleted d ON i.id = d.id
        WHERE i.salary <> d.salary;
    END
END;
```

### 8.4.3 INSTEAD OF触发器

INSTEAD OF触发器用于替代原始操作执行，常用于不可更新的视图。

```sql
CREATE VIEW employee_department_view AS
SELECT 
    e.id,
    e.name,
    e.position,
    d.name AS department
FROM employees e
JOIN departments d ON e.department_id = d.id;

-- 创建INSTEAD OF INSERT触发器
CREATE TRIGGER tr_InsteadOfInsertEmployeeDepartment
ON employee_department_view
INSTEAD OF INSERT
AS
BEGIN
    -- 检查部门是否存在
    DECLARE @DeptId INT;
    SELECT @DeptId = id FROM departments WHERE name = (SELECT department FROM inserted);
    
    IF @DeptId IS NOT NULL
    BEGIN
        INSERT INTO employees (name, position, department_id)
        SELECT name, position, @DeptId FROM inserted;
    END
    ELSE
    BEGIN
        RAISERROR('指定的部门不存在', 16, 1);
    END
END;
```

### 8.4.4 修改和删除触发器

修改触发器：

```sql
ALTER TRIGGER trigger_name
ON table_name
AFTER [INSERT, UPDATE, DELETE]
AS
BEGIN
    -- 新的触发器代码
END;
```

删除触发器：

```sql
DROP TRIGGER trigger_name;
```

## 8.5 事务处理（Transactions）

### 8.5.1 事务的概念

事务（Transaction）是一组SQL操作的集合，这些操作要么全部成功执行，要么全部不执行，保证数据库的一致性。

事务的ACID特性：
- **原子性（Atomicity）**：事务中的所有操作要么全部完成，要么全部不完成
- **一致性（Consistency）**：事务开始前和结束后，数据库的完整性约束没有被破坏
- **隔离性（Isolation）**：多个并发事务之间互不干扰
- **持久性（Durability）**：事务一旦提交，其结果就是永久性的

### 8.5.2 事务控制语句

事务控制的基本语句：

```sql
-- 开始事务
BEGIN TRANSACTION;

-- 提交事务
COMMIT TRANSACTION;

-- 回滚事务
ROLLBACK TRANSACTION;
```

示例：银行转账事务

```sql
BEGIN TRANSACTION;

-- 从账户A扣款
UPDATE accounts SET balance = balance - 1000 WHERE id = 1;

-- 向账户B加款
UPDATE accounts SET balance = balance + 1000 WHERE id = 2;

-- 检查操作是否成功
IF @@ERROR = 0
BEGIN
    -- 提交事务
    COMMIT TRANSACTION;
    PRINT '转账成功';
END
ELSE
BEGIN
    -- 回滚事务
    ROLLBACK TRANSACTION;
    PRINT '转账失败，已回滚';
END
```

### 8.5.3 事务隔离级别

事务隔离级别决定了事务之间的可见性：

```sql
-- 设置事务隔离级别
SET TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SNAPSHOT | SERIALIZABLE];
```

不同隔离级别的特点：
- **READ UNCOMMITTED**：可以读取未提交的数据（脏读）
- **READ COMMITTED**：只能读取已提交的数据（大多数数据库的默认级别）
- **REPEATABLE READ**：确保在事务内多次读取同一数据的结果一致
- **SNAPSHOT**：基于快照的隔离，读取事务开始时的数据版本
- **SERIALIZABLE**：最高隔离级别，完全隔离，性能最低

### 8.5.4 嵌套事务

```sql
-- 外部事务
BEGIN TRANSACTION OuterTran;

-- 执行一些操作
INSERT INTO departments (name) VALUES ('新部门');

-- 内部事务
BEGIN TRANSACTION InnerTran;
SAVE TRANSACTION SavePoint;

-- 尝试插入员工
INSERT INTO employees (name, department_id) VALUES ('新员工', 99); -- 假设部门99不存在

-- 检查是否成功
IF @@ERROR <> 0
BEGIN
    -- 回滚到保存点
    ROLLBACK TRANSACTION SavePoint;
    PRINT '插入员工失败，已回滚';
END
ELSE
BEGIN
    -- 提交内部事务
    COMMIT TRANSACTION InnerTran;
END

-- 提交外部事务
COMMIT TRANSACTION OuterTran;
```

## 8.6 游标（Cursors）

### 8.6.1 游标的概念

游标（Cursor）是一种数据库对象，用于逐行处理查询结果集，而不是一次性处理整个结果集。

游标的使用场景：
- 需要逐行处理数据
- 需要基于当前行的值执行不同的操作
- 需要更新或删除特定行

### 8.6.2 使用游标

使用游标的基本步骤：

```sql
-- 1. 声明游标
DECLARE cursor_name CURSOR FOR
SELECT column1, column2, ...
FROM table_name
WHERE condition;

-- 2. 打开游标
OPEN cursor_name;

-- 3. 获取第一行
FETCH NEXT FROM cursor_name INTO @variable1, @variable2, ...;

-- 4. 检查是否成功获取数据
WHILE @@FETCH_STATUS = 0
BEGIN
    -- 处理当前行
    
    -- 获取下一行
    FETCH NEXT FROM cursor_name INTO @variable1, @variable2, ...;
END

-- 5. 关闭游标
CLOSE cursor_name;

-- 6. 释放游标
DEALLOCATE cursor_name;
```

示例：使用游标更新员工薪资

```sql
-- 声明变量
DECLARE @EmployeeId INT;
DECLARE @Salary DECIMAL(10, 2);
DECLARE @NewSalary DECIMAL(10, 2);

-- 声明游标
DECLARE employee_cursor CURSOR FOR
SELECT id, salary FROM employees WHERE salary < 10000;

-- 打开游标
OPEN employee_cursor;

-- 获取第一行
FETCH NEXT FROM employee_cursor INTO @EmployeeId, @Salary;

-- 循环处理
WHILE @@FETCH_STATUS = 0
BEGIN
    -- 计算新薪资（增加10%）
    SET @NewSalary = @Salary * 1.1;
    
    -- 更新员工薪资
    UPDATE employees 
    SET salary = @NewSalary 
    WHERE id = @EmployeeId;
    
    PRINT '员工ID: ' + CAST(@EmployeeId AS VARCHAR) + 
          ', 原薪资: ' + CAST(@Salary AS VARCHAR) + 
          ', 新薪资: ' + CAST(@NewSalary AS VARCHAR);
    
    -- 获取下一行
    FETCH NEXT FROM employee_cursor INTO @EmployeeId, @Salary;
END

-- 关闭游标
CLOSE employee_cursor;

-- 释放游标
DEALLOCATE employee_cursor;
```

### 8.6.3 游标类型

```sql
-- 只进游标（默认）
DECLARE cursor_name CURSOR FOR SELECT ...;

-- 静态游标
DECLARE cursor_name STATIC CURSOR FOR SELECT ...;

-- 动态游标
DECLARE cursor_name DYNAMIC CURSOR FOR SELECT ...;

-- 键集游标
DECLARE cursor_name KEYSET CURSOR FOR SELECT ...;
```

不同游标类型的特点：
- **只进游标**：只能向前移动，性能最好
- **静态游标**：创建结果集的静态副本，不反映其他用户对数据的更改
- **动态游标**：反映所有数据更改，性能较差
- **键集游标**：键集固定，但数据值可以更改

## 8.7 窗口函数（Window Functions）

### 8.7.1 窗口函数的概念

窗口函数（Window Functions）是一种特殊的函数，它可以对结果集中的行集（称为"窗口"）执行计算，同时保留原始行的详细信息。

窗口函数的语法：

```sql
function_name([expression]) OVER (
    [PARTITION BY expression]
    [ORDER BY expression]
    [ROWS or RANGE clause]
)
```

### 8.7.2 排名函数

排名函数用于为结果集中的行分配排名：

```sql
-- ROW_NUMBER(): 为每行分配唯一的连续整数
SELECT 
    name,
    salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) AS salary_rank
FROM employees;

-- RANK(): 为相同值的行分配相同的排名，跳过后续排名
SELECT 
    name,
    salary,
    RANK() OVER (ORDER BY salary DESC) AS salary_rank
FROM employees;

-- DENSE_RANK(): 为相同值的行分配相同的排名，不跳过后续排名
SELECT 
    name,
    salary,
    DENSE_RANK() OVER (ORDER BY salary DESC) AS salary_rank
FROM employees;

-- NTILE(): 将结果集划分为指定数量的组
SELECT 
    name,
    salary,
    NTILE(4) OVER (ORDER BY salary DESC) AS salary_quartile
FROM employees;
```

### 8.7.3 聚合函数

聚合函数也可以作为窗口函数使用：

```sql
-- 计算每个部门的员工薪资总和
SELECT 
    e.name,
    e.salary,
    d.name AS department,
    SUM(e.salary) OVER (PARTITION BY d.id) AS dept_total_salary
FROM employees e
JOIN departments d ON e.department_id = d.id;

-- 计算累计薪资
SELECT 
    name,
    salary,
    SUM(salary) OVER (ORDER BY salary DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_salary
FROM employees;

-- 计算移动平均
SELECT 
    name,
    salary,
    AVG(salary) OVER (ORDER BY id ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS moving_avg
FROM employees;
```

### 8.7.4 分析函数

分析函数提供更高级的分析功能：

```sql
-- LAG(): 访问前一行
SELECT 
    name,
    salary,
    LAG(salary, 1, 0) OVER (ORDER BY salary DESC) AS prev_salary,
    salary - LAG(salary, 1, 0) OVER (ORDER BY salary DESC) AS salary_diff
FROM employees;

-- LEAD(): 访问后一行
SELECT 
    name,
    salary,
    LEAD(salary, 1, 0) OVER (ORDER BY salary DESC) AS next_salary
FROM employees;

-- FIRST_VALUE(): 访问窗口中的第一行
SELECT 
    name,
    salary,
    FIRST_VALUE(salary) OVER (ORDER BY salary DESC) AS highest_salary
FROM employees;

-- LAST_VALUE(): 访问窗口中的最后一行
SELECT 
    name,
    salary,
    LAST_VALUE(salary) OVER (ORDER BY salary DESC) AS lowest_salary
FROM employees;
```

## 8.8 公用表表达式（CTE）

### 8.8.1 公用表表达式的概念

公用表表达式（Common Table Expression，CTE）是一个临时的结果集，它在单个SELECT、INSERT、UPDATE或DELETE语句的执行范围内存在。

CTE的优点：
- **提高可读性**：将复杂查询分解为逻辑步骤
- **递归查询**：支持递归查询层次结构数据
- **代码复用**：在同一查询中多次引用CTE

### 8.8.2 基本CTE语法

```sql
WITH cte_name (column1, column2, ...) AS
(
    -- CTE查询
    SELECT column1, column2, ...
    FROM table_name
    WHERE condition
)
-- 主查询
SELECT *
FROM cte_name
WHERE condition;
```

示例：使用CTE查询各部门薪资最高的员工

```sql
WITH DeptMaxSalary AS (
    SELECT 
        department_id,
        MAX(salary) AS max_salary
    FROM employees
    GROUP BY department_id
)
SELECT 
    e.name,
    e.position,
    e.salary,
    d.name AS department
FROM employees e
JOIN departments d ON e.department_id = d.id
JOIN DeptMaxSalary dms ON e.department_id = dms.department_id AND e.salary = dms.max_salary;
```

### 8.8.3 多个CTE

```sql
WITH DeptAvgSalary AS (
    SELECT 
        department_id,
        AVG(salary) AS avg_salary
    FROM employees
    GROUP BY department_id
),
HighSalaryDepts AS (
    SELECT 
        department_id,
        avg_salary
    FROM DeptAvgSalary
    WHERE avg_salary > 10000
)
SELECT 
    d.name AS department,
    das.avg_salary,
    COUNT(e.id) AS employee_count
FROM departments d
JOIN DeptAvgSalary das ON d.id = das.department_id
JOIN employees e ON d.id = e.department_id
WHERE d.id IN (SELECT department_id FROM HighSalaryDepts)
GROUP BY d.id, d.name, das.avg_salary;
```

### 8.8.4 递归CTE

递归CTE用于查询层次结构数据：

```sql
WITH RECURSIVE EmployeeHierarchy AS (
    -- 锚点查询：获取顶级员工（没有经理的员工）
    SELECT 
        id,
        name,
        position,
        manager_id,
        0 AS level
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- 递归查询：获取下属员工
    SELECT 
        e.id,
        e.name,
        e.position,
        e.manager_id,
        eh.level + 1
    FROM employees e
    JOIN EmployeeHierarchy eh ON e.manager_id = eh.id
)
SELECT 
    REPLICATE('  ', level) + name AS employee_name,
    position,
    level
FROM EmployeeHierarchy
ORDER BY level, name;
```

## 8.9 JSON数据处理

### 8.9.1 JSON数据类型

现代数据库支持JSON数据类型，用于存储和查询JSON格式的数据：

```sql
-- 创建包含JSON列的表
CREATE TABLE employee_details (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    details JSON
);

-- 插入JSON数据
INSERT INTO employee_details (id, name, details) VALUES
(1, '张三', '{"age": 30, "skills": ["Java", "Python", "SQL"], "address": {"city": "北京", "district": "朝阳区"}}'),
(2, '李四', '{"age": 28, "skills": ["JavaScript", "React", "Node.js"], "address": {"city": "上海", "district": "浦东新区"}}');
```

### 8.9.2 查询JSON数据

```sql
-- 提取JSON属性
SELECT 
    name,
    JSON_EXTRACT(details, '$.age') AS age,
    JSON_EXTRACT(details, '$.skills') AS skills,
    JSON_EXTRACT(details, '$.address.city') AS city
FROM employee_details;

-- 使用简化语法（MySQL）
SELECT 
    name,
    details->'$.age' AS age,
    details->'$.skills' AS skills,
    details->'$.address.city' AS city
FROM employee_details;

-- 提取无引号的值（MySQL）
SELECT 
    name,
    details->>'$.age' AS age,
    details->>'$.address.city' AS city
FROM employee_details;
```

### 8.9.3 修改JSON数据

```sql
-- 更新JSON属性
UPDATE employee_details
SET details = JSON_SET(details, '$.age', 31)
WHERE id = 1;

-- 添加JSON属性
UPDATE employee_details
SET details = JSON_INSERT(details, '$.email', 'zhangsan@example.com')
WHERE id = 1;

-- 删除JSON属性
UPDATE employee_details
SET details = JSON_REMOVE(details, '$.email')
WHERE id = 1;

-- 合并JSON对象
UPDATE employee_details
SET details = JSON_MERGE(details, '{"department": "技术部", "experience": 5}')
WHERE id = 1;
```

### 8.9.4 JSON函数

```sql
-- 检查JSON路径是否存在
SELECT 
    name,
    JSON_CONTAINS_PATH(details, 'one', '$.skills') AS has_skills
FROM employee_details;

-- 搜索JSON值
SELECT 
    name,
    details
FROM employee_details
WHERE JSON_CONTAINS(details, '"Java"', '$.skills');

-- 获取JSON键
SELECT 
    name,
    JSON_KEYS(details) AS keys
FROM employee_details;

-- 获取JSON数组长度
SELECT 
    name,
    JSON_LENGTH(details, '$.skills') AS skill_count
FROM employee_details;
```

## 8.10 小结

本章介绍了SQL的高级特性，包括：

1. **视图（Views）**：基于SQL查询结果的虚拟表，用于简化复杂查询和提高数据安全性。

2. **存储过程（Stored Procedures）**：预编译的SQL语句集合，用于提高性能和代码复用。

3. **函数（Functions）**：接受输入参数并返回结果的SQL代码块，包括标量函数和表值函数。

4. **触发器（Triggers）**：在特定表上发生特定事件时自动执行的特殊存储过程。

5. **事务处理（Transactions）**：保证数据库操作的原子性、一致性、隔离性和持久性。

6. **游标（Cursors）**：用于逐行处理查询结果集的数据库对象。

7. **窗口函数（Window Functions）**：对结果集中的行集执行计算，同时保留原始行的详细信息。

8. **公用表表达式（CTE）**：临时结果集，用于提高查询可读性和支持递归查询。

9. **JSON数据处理**：存储和查询JSON格式数据的功能。

这些高级特性使SQL不仅是一种查询语言，而是一种完整的数据库编程语言，能够处理复杂的业务逻辑和数据操作需求。

## 8.11 思考题

1. 视图和表有什么区别？在什么情况下应该使用视图？

2. 存储过程和函数有什么区别？在什么情况下应该使用存储过程，什么情况下应该使用函数？

3. 触发器有哪些类型？INSTEAD OF触发器通常用于什么场景？

4. 事务的隔离级别有哪些？不同隔离级别有什么影响？

5. 游标有哪些类型？为什么在大多数情况下应该避免使用游标？

6. 窗口函数和聚合函数有什么区别？窗口函数适用于什么场景？

7. 递归CTE的执行过程是怎样的？递归CTE适用于什么类型的数据？

8. 如何在SQL中存储和查询JSON数据？JSON数据类型有哪些优缺点？

## 8.12 下章预告

下一章将介绍SQL性能优化，包括索引、查询优化、执行计划分析等内容，帮助您编写高效的SQL查询。