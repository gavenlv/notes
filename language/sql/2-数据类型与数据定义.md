# 第2章：SQL数据类型与数据定义

## 2.1 SQL数据类型

### 什么是数据类型？

数据类型是数据的一种属性，它定义了数据可以存储什么样的值以及可以对这些值执行什么样的操作。在SQL中，选择合适的数据类型对于数据库的性能和数据的完整性至关重要。

### 常见数据类型分类

SQL数据类型主要分为以下几类：

1. **数值类型**：用于存储数字
2. **字符串类型**：用于存储文本
3. **日期时间类型**：用于存储日期和时间
4. **布尔类型**：用于存储真/假值
5. **二进制类型**：用于存储二进制数据

### 数值类型

#### 整数类型

整数类型用于存储没有小数部分的数字。

| 类型 | 存储空间 | 范围（有符号） | 范围（无符号） | 适用场景 |
|------|----------|----------------|----------------|----------|
| TINYINT | 1字节 | -128到127 | 0到255 | 小范围计数 |
| SMALLINT | 2字节 | -32768到32767 | 0到65535 | 中等范围计数 |
| MEDIUMINT | 3字节 | -8388608到8388607 | 0到16777215 | 较大范围计数 |
| INT或INTEGER | 4字节 | -2147483648到2147483647 | 0到4294967295 | 通用整数 |
| BIGINT | 8字节 | -9223372036854775808到9223372036854775807 | 0到18446744073709551615 | 大范围计数 |

**示例**：
```sql
-- 创建一个包含不同整数类型的表
CREATE TABLE numeric_examples (
    tiny_col TINYINT,
    small_col SMALLINT,
    medium_col MEDIUMINT,
    int_col INT,
    big_col BIGINT
);

-- 插入数据
INSERT INTO numeric_examples VALUES (10, 1000, 100000, 1000000, 1000000000);
```

#### 浮点类型

浮点类型用于存储有小数部分的数字。

| 类型 | 存储空间 | 范围 | 精度 | 适用场景 |
|------|----------|------|------|----------|
| FLOAT | 4字节 | 约±3.4e38 | 约7位小数 | 单精度浮点数 |
| DOUBLE | 8字节 | 约±1.8e308 | 约15位小数 | 双精度浮点数 |
| DECIMAL(M,D) | 变长 | 取决于M和D | 精确到D位小数 | 精确小数 |

**示例**：
```sql
-- 创建一个包含浮点类型的表
CREATE TABLE float_examples (
    float_col FLOAT,
    double_col DOUBLE,
    decimal_col DECIMAL(10, 2)  -- 总共10位，其中2位小数
);

-- 插入数据
INSERT INTO float_examples VALUES (3.14159, 2.718281828, 12345.67);
```

**DECIMAL vs FLOAT/DOUBLE**：
- DECIMAL存储精确的小数值，适用于财务计算
- FLOAT和DOUBLE存储近似值，适用于科学计算

### 字符串类型

#### 定长字符串

| 类型 | 最大长度 | 特点 | 适用场景 |
|------|----------|------|----------|
| CHAR(M) | M字节 | 定长，不足时用空格填充 | 固定长度的数据，如身份证号、邮编 |

**示例**：
```sql
-- 创建一个包含CHAR类型的表
CREATE TABLE char_examples (
    id CHAR(10),  -- 固定10个字符
    country_code CHAR(2)  -- 固定2个字符，如'CN', 'US'
);

-- 插入数据
INSERT INTO char_examples VALUES ('1234567890', 'CN');
```

#### 变长字符串

| 类型 | 最大长度 | 特点 | 适用场景 |
|------|----------|------|----------|
| VARCHAR(M) | M字节 | 变长，只占用实际长度+1字节 | 变长文本，如姓名、地址 |
| TINYTEXT | 255字节 | 变长 | 短文本 |
| TEXT | 65535字节 | 变长 | 中等长度文本 |
| MEDIUMTEXT | 16,777,215字节 | 变长 | 长文本 |
| LONGTEXT | 4,294,967,295字节 | 变长 | 超长文本 |

**示例**：
```sql
-- 创建一个包含VARCHAR和TEXT类型的表
CREATE TABLE varchar_examples (
    name VARCHAR(50),  -- 最多50个字符
    description TEXT   -- 最多65535个字符
);

-- 插入数据
INSERT INTO varchar_examples VALUES ('张三', '这是一个员工描述');
```

#### CHAR vs VARCHAR

- **CHAR**：固定长度，存储效率高，适合长度固定的数据
- **VARCHAR**：可变长度，节省空间，适合长度不固定的数据

**示例对比**：
```sql
-- CHAR(10)存储'ABC'：实际占用10字节（'ABC' + 7个空格）
-- VARCHAR(10)存储'ABC'：实际占用4字节（'ABC' + 1字节长度信息）
```

### 日期时间类型

| 类型 | 格式 | 范围 | 适用场景 |
|------|------|------|----------|
| DATE | 'YYYY-MM-DD' | '1000-01-01'到'9999-12-31' | 存储日期 |
| TIME | 'HH:MM:SS' | '-838:59:59'到'838:59:59' | 存储时间 |
| DATETIME | 'YYYY-MM-DD HH:MM:SS' | '1000-01-01 00:00:00'到'9999-12-31 23:59:59' | 存储日期和时间 |
| TIMESTAMP | 'YYYY-MM-DD HH:MM:SS' | '1970-01-01 00:00:01'UTC到'2038-01-19 03:14:07'UTC | 时间戳 |
| YEAR | YYYY | 1901到2155 | 存储年份 |

**示例**：
```sql
-- 创建一个包含日期时间类型的表
CREATE TABLE datetime_examples (
    date_col DATE,
    time_col TIME,
    datetime_col DATETIME,
    timestamp_col TIMESTAMP,
    year_col YEAR
);

-- 插入数据
INSERT INTO datetime_examples VALUES 
('2023-05-15', '14:30:00', '2023-05-15 14:30:00', '2023-05-15 14:30:00', 2023);
```

#### DATETIME vs TIMESTAMP

- **DATETIME**：固定值，不随时区变化
- **TIMESTAMP**：以UTC存储，查询时转换为当前时区，自动更新

**示例**：
```sql
-- 创建一个包含TIMESTAMP的表，设置自动更新
CREATE TABLE timestamp_example (
    id INT PRIMARY KEY,
    content VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 插入数据
INSERT INTO timestamp_example (id, content) VALUES (1, '初始内容');

-- 更新数据
UPDATE timestamp_example SET content = '更新内容' WHERE id = 1;

-- 查询数据，可以看到updated_at自动更新
SELECT * FROM timestamp_example;
```

### 布尔类型

在MySQL中，布尔类型实际上是TINYINT(1)的别名：

| 类型 | 值 | 存储 |
|------|----|----- |
| BOOLEAN或BOOL | TRUE/FALSE | 1/0 |

**示例**：
```sql
-- 创建一个包含布尔类型的表
CREATE TABLE boolean_examples (
    id INT PRIMARY KEY,
    is_active BOOLEAN,
    has_permission BOOL
);

-- 插入数据
INSERT INTO boolean_examples VALUES (1, TRUE, FALSE);
INSERT INTO boolean_examples VALUES (2, 1, 0);  -- 也可以用1/0

-- 查询数据
SELECT * FROM boolean_examples WHERE is_active = TRUE;
```

### 二进制类型

| 类型 | 最大长度 | 适用场景 |
|------|----------|----------|
| BINARY(M) | M字节 | 固定长度二进制数据 |
| VARBINARY(M) | M字节 | 可变长度二进制数据 |
| TINYBLOB | 255字节 | 小型二进制对象 |
| BLOB | 65535字节 | 中型二进制对象 |
| MEDIUMBLOB | 16,777,215字节 | 大型二进制对象 |
| LONGBLOB | 4,294,967,295字节 | 超大型二进制对象 |

**示例**：
```sql
-- 创建一个包含二进制类型的表
CREATE TABLE binary_examples (
    id INT PRIMARY KEY,
    image BLOB,
    file_data VARBINARY(1000)
);

-- 插入数据（实际应用中通常通过编程语言插入二进制数据）
INSERT INTO binary_examples (id, image) VALUES (1, 0x48656C6C6F);  -- 'Hello'的十六进制表示
```

## 2.2 创建数据库和表

### 创建数据库

使用`CREATE DATABASE`语句创建数据库：

```sql
CREATE DATABASE database_name;
```

**示例**：
```sql
-- 创建一个名为company的数据库
CREATE DATABASE company;

-- 如果数据库不存在则创建
CREATE DATABASE IF NOT EXISTS company;

-- 创建数据库并指定字符集
CREATE DATABASE company CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
```

### 选择数据库

使用`USE`语句选择要操作的数据库：

```sql
USE database_name;
```

**示例**：
```sql
-- 使用company数据库
USE company;
```

### 创建表

使用`CREATE TABLE`语句创建表：

```sql
CREATE TABLE table_name (
    column1 data_type [constraints],
    column2 data_type [constraints],
    ...
    [table_constraints]
);
```

**示例**：
```sql
-- 创建一个员工表
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    age INT,
    gender VARCHAR(10),
    department VARCHAR(50),
    position VARCHAR(50),
    salary DECIMAL(10, 2),
    hire_date DATE,
    email VARCHAR(100) UNIQUE,
    phone VARCHAR(20)
);
```

### 实验验证

让我们创建一个完整的数据库结构：

**步骤1**：创建数据库
```sql
CREATE DATABASE IF NOT EXISTS company_demo CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE company_demo;
```

**步骤2**：创建部门表
```sql
CREATE TABLE departments (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    manager_id INT,
    location VARCHAR(100),
    budget DECIMAL(12, 2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**步骤3**：创建员工表
```sql
CREATE TABLE employees (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    age INT CHECK (age >= 18 AND age <= 65),
    gender ENUM('男', '女', '其他'),
    department_id INT,
    position VARCHAR(50),
    salary DECIMAL(10, 2) CHECK (salary >= 0),
    hire_date DATE NOT NULL,
    email VARCHAR(100) UNIQUE,
    phone VARCHAR(20),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (department_id) REFERENCES departments(id)
);
```

**步骤4**：创建项目表
```sql
CREATE TABLE projects (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    start_date DATE,
    end_date DATE,
    budget DECIMAL(12, 2),
    status ENUM('计划中', '进行中', '已完成', '已取消') DEFAULT '计划中',
    manager_id INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (manager_id) REFERENCES employees(id)
);
```

**步骤5**：创建员工项目关联表
```sql
CREATE TABLE employee_projects (
    employee_id INT,
    project_id INT,
    role VARCHAR(50),
    hours_worked INT DEFAULT 0,
    start_date DATE,
    end_date DATE,
    PRIMARY KEY (employee_id, project_id),
    FOREIGN KEY (employee_id) REFERENCES employees(id),
    FOREIGN KEY (project_id) REFERENCES projects(id)
);
```

## 2.3 修改表结构

### 添加列

使用`ALTER TABLE ... ADD COLUMN`语句添加列：

```sql
ALTER TABLE table_name ADD COLUMN column_name data_type [constraints];
```

**示例**：
```sql
-- 为employees表添加一个middle_name列
ALTER TABLE employees ADD COLUMN middle_name VARCHAR(50);

-- 为employees表添加一个birth_date列，并指定位置
ALTER TABLE employees ADD COLUMN birth_date DATE AFTER age;

-- 为employees表添加一个notes列，并放在最后
ALTER TABLE employees ADD COLUMN notes TEXT;
```

### 修改列

使用`ALTER TABLE ... MODIFY COLUMN`语句修改列：

```sql
ALTER TABLE table_name MODIFY COLUMN column_name new_data_type [new_constraints];
```

**示例**：
```sql
-- 修改name列的长度
ALTER TABLE employees MODIFY COLUMN name VARCHAR(100) NOT NULL;

-- 修改salary列的精度
ALTER TABLE employees MODIFY COLUMN salary DECIMAL(12, 2);

-- 修改phone列的默认值
ALTER TABLE employees MODIFY COLUMN phone VARCHAR(20) DEFAULT '无';
```

### 重命名列

使用`ALTER TABLE ... CHANGE COLUMN`语句重命名列：

```sql
ALTER TABLE table_name CHANGE COLUMN old_name new_name data_type [constraints];
```

**示例**：
```sql
-- 将name列重命名为full_name
ALTER TABLE employees CHANGE COLUMN name full_name VARCHAR(50) NOT NULL;

-- 将age列重命名为employee_age，并修改数据类型
ALTER TABLE employees CHANGE COLUMN age employee_age SMALLINT;
```

### 删除列

使用`ALTER TABLE ... DROP COLUMN`语句删除列：

```sql
ALTER TABLE table_name DROP COLUMN column_name;
```

**示例**：
```sql
-- 删除middle_name列
ALTER TABLE employees DROP COLUMN middle_name;

-- 删除notes列
ALTER TABLE employees DROP COLUMN notes;
```

### 重命名表

使用`RENAME TABLE`语句重命名表：

```sql
RENAME TABLE old_name TO new_name;
```

**示例**：
```sql
-- 将employees表重命名为staff
RENAME TABLE employees TO staff;

-- 或者使用ALTER TABLE
ALTER TABLE staff RENAME TO employees;
```

## 2.4 约束与索引

### 什么是约束？

约束是应用于表中数据的规则，用于限制可以插入到表中的数据类型，确保数据的准确性和可靠性。

### 常见约束类型

#### 主键约束（PRIMARY KEY）

主键约束唯一标识表中的每一行记录，主键列不能包含NULL值，且值必须唯一。

**示例**：
```sql
-- 创建表时定义主键
CREATE TABLE departments (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL
);

-- 或者定义复合主键
CREATE TABLE employee_projects (
    employee_id INT,
    project_id INT,
    PRIMARY KEY (employee_id, project_id)
);

-- 为已存在的表添加主键
ALTER TABLE employees ADD PRIMARY KEY (id);
```

#### 外键约束（FOREIGN KEY）

外键约束用于建立两个表之间的链接，确保一个表中的数据匹配另一个表中的值。

**示例**：
```sql
-- 创建表时定义外键
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    department_id INT,
    FOREIGN KEY (department_id) REFERENCES departments(id)
);

-- 为已存在的表添加外键
ALTER TABLE employees ADD CONSTRAINT fk_department 
FOREIGN KEY (department_id) REFERENCES departments(id);

-- 指定外键约束的更新和删除行为
ALTER TABLE employees ADD CONSTRAINT fk_department 
FOREIGN KEY (department_id) REFERENCES departments(id)
ON DELETE SET NULL  -- 当部门被删除时，将员工的department_id设为NULL
ON UPDATE CASCADE;  -- 当部门的id更新时，同时更新员工的department_id
```

外键约束的参考行为：
- `CASCADE`：级联操作，当父表记录被删除/更新时，子表中的相关记录也被删除/更新
- `SET NULL`：设置为NULL，当父表记录被删除/更新时，子表中的外键列被设置为NULL
- `RESTRICT`：限制操作，如果子表中有相关记录，则不允许删除/更新父表记录
- `NO ACTION`：无动作，与RESTRICT相同

#### 唯一约束（UNIQUE）

唯一约束确保列中的所有值都是唯一的，但允许NULL值（可以有多个NULL）。

**示例**：
```sql
-- 创建表时定义唯一约束
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    phone VARCHAR(20)
);

-- 创建表后添加唯一约束
ALTER TABLE employees ADD CONSTRAINT uc_email UNIQUE (email);

-- 创建复合唯一约束
ALTER TABLE employees ADD CONSTRAINT uc_name_phone UNIQUE (name, phone);
```

#### 非空约束（NOT NULL）

非空约束确保列不能有NULL值。

**示例**：
```sql
-- 创建表时定义非空约束
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    age INT NOT NULL
);

-- 修改现有列添加非空约束
ALTER TABLE employees MODIFY COLUMN age INT NOT NULL;
```

#### 检查约束（CHECK）

检查约束确保列中的值满足特定条件。

**示例**：
```sql
-- 创建表时定义检查约束
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    age INT CHECK (age >= 18),
    salary DECIMAL(10, 2) CHECK (salary >= 0)
);

-- 创建表后添加检查约束
ALTER TABLE employees ADD CONSTRAINT chk_age CHECK (age >= 18 AND age <= 65);
ALTER TABLE employees ADD CONSTRAINT chk_salary CHECK (salary > 0);
```

#### 默认约束（DEFAULT）

默认约束为列提供默认值。

**示例**：
```sql
-- 创建表时定义默认值
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    hire_date DATE DEFAULT CURRENT_DATE
);

-- 修改现有列添加默认值
ALTER TABLE employees MODIFY COLUMN is_active BOOLEAN DEFAULT TRUE;
```

### 什么是索引？

索引是数据库表中一个或多个列值的副本，按照特定顺序排序，用于加速数据检索。索引类似于书的目录，可以帮助数据库快速定位数据，而不必扫描整个表。

### 索引类型

#### 主键索引

主键自动创建唯一索引，用于快速查找记录。

#### 唯一索引

唯一索引确保索引列中的所有值都是唯一的。

```sql
-- 创建唯一索引
CREATE UNIQUE INDEX idx_email ON employees(email);
```

#### 普通索引

普通索引不要求唯一性，可以包含重复值。

```sql
-- 创建普通索引
CREATE INDEX idx_name ON employees(name);

-- 创建复合索引
CREATE INDEX idx_department_salary ON employees(department_id, salary);
```

#### 全文索引

全文索引用于全文搜索，只能在CHAR、VARCHAR和TEXT列上创建。

```sql
-- 创建全文索引
CREATE FULLTEXT INDEX idx_description ON projects(description);
```

### 创建索引

```sql
-- 创建索引
CREATE INDEX index_name ON table_name(column1, column2, ...);

-- 创建唯一索引
CREATE UNIQUE INDEX index_name ON table_name(column1, column2, ...);

-- 创建全文索引
CREATE FULLTEXT INDEX index_name ON table_name(column);
```

### 删除索引

```sql
-- 删除索引
DROP INDEX index_name ON table_name;
```

### 查看索引

```sql
-- 查看表的索引
SHOW INDEX FROM table_name;

-- 在MySQL中查看索引信息
SHOW INDEX FROM employees;
```

### 索引使用建议

1. **为经常查询的列创建索引**：如WHERE子句中经常使用的列
2. **为经常连接的列创建索引**：如外键列
3. **为经常排序的列创建索引**：如ORDER BY子句中使用的列
4. **避免过多索引**：索引会占用存储空间，并降低写入性能
5. **选择高选择性列**：选择性高的列（即不同值多的列）更适合创建索引
6. **考虑复合索引**：多个列经常一起查询时，创建复合索引

## 2.5 本章小结

本章介绍了SQL的数据类型和数据定义语言（DDL），包括：

1. **SQL数据类型**：数值类型、字符串类型、日期时间类型、布尔类型和二进制类型
2. **创建数据库和表**：使用CREATE DATABASE和CREATE TABLE语句
3. **修改表结构**：使用ALTER TABLE语句添加、修改、删除列
4. **约束与索引**：主键、外键、唯一、非空、检查和默认约束，以及各种索引类型

通过本章的学习，您应该能够：

- 理解并选择适当的数据类型
- 创建数据库和表
- 修改表结构
- 使用约束确保数据完整性
- 创建和管理索引以提高查询性能

## 2.6 思考题

1. CHAR和VARCHAR有什么区别？在什么情况下应该使用哪种类型？
2. DECIMAL和FLOAT/DOUBLE有什么区别？在什么情况下应该使用DECIMAL？
3. DATETIME和TIMESTAMP有什么区别？在什么情况下应该使用哪种类型？
4. 什么是外键约束？它如何确保数据的完整性？
5. 什么是索引？为什么索引可以提高查询性能？过多索引会有什么问题？

## 2.7 下章预告

在第3章中，我们将学习SQL的基本查询，包括：

- SELECT语句的详细用法
- WHERE子句的条件过滤
- ORDER BY子句的排序功能
- LIMIT子句的结果限制
- 基本的数据处理和转换

---

*继续学习，掌握SQL查询的更多技巧！*