# 第4章：SQL高级查询

## 4.1 GROUP BY子句与聚合函数

### 什么是GROUP BY子句？

GROUP BY子句用于将具有相同值的行组合成汇总行，通常与聚合函数一起使用，对每个组进行计算。

### 什么是聚合函数？

聚合函数对一组值执行计算，并返回单个值。常见的聚合函数包括：

| 函数 | 描述 |
|------|------|
| COUNT() | 计数，返回行数 |
| SUM() | 求和，返回值的总和 |
| AVG() | 平均值，返回值的平均值 |
| MAX() | 最大值，返回值的最大值 |
| MIN() | 最小值，返回值的最小值 |

### 基本语法

```sql
SELECT column1, column2, ..., aggregate_function(column)
FROM table_name
WHERE condition
GROUP BY column1, column2, ...
ORDER BY column1, column2, ...;
```

### 单列分组

按单个列进行分组：

```sql
-- 按部门分组，计算每个部门的员工数量
SELECT department_id, COUNT(*) AS '员工数量'
FROM employees
GROUP BY department_id;

-- 按职位分组，计算每个职位的平均薪资
SELECT position, AVG(salary) AS '平均薪资'
FROM employees
GROUP BY position;
```

### 多列分组

按多个列进行分组：

```sql
-- 按部门和职位分组，计算每个部门和职位的员工数量和平均薪资
SELECT department_id, position, COUNT(*) AS '员工数量', AVG(salary) AS '平均薪资'
FROM employees
GROUP BY department_id, position
ORDER BY department_id, AVG(salary) DESC;
```

### 聚合函数详解

#### COUNT函数

COUNT函数用于计算行数：

```sql
-- 计算所有员工数量
SELECT COUNT(*) AS '总员工数' FROM employees;

-- 计算有电话的员工数量（排除NULL值）
SELECT COUNT(phone) AS '有电话的员工数' FROM employees;

-- 计算不同职位的数量
SELECT COUNT(DISTINCT position) AS '不同职位数量' FROM employees;
```

#### SUM函数

SUM函数用于计算总和：

```sql
-- 计算所有员工的薪资总和
SELECT SUM(salary) AS '薪资总和' FROM employees;

-- 按部门计算薪资总和
SELECT department_id, SUM(salary) AS '部门薪资总和'
FROM employees
GROUP BY department_id;
```

#### AVG函数

AVG函数用于计算平均值：

```sql
-- 计算所有员工的平均薪资
SELECT AVG(salary) AS '平均薪资' FROM employees;

-- 按职位计算平均薪资
SELECT position, AVG(salary) AS '平均薪资'
FROM employees
GROUP BY position;
```

#### MAX和MIN函数

MAX和MIN函数用于计算最大值和最小值：

```sql
-- 计算最高和最低薪资
SELECT MAX(salary) AS '最高薪资', MIN(salary) AS '最低薪资' FROM employees;

-- 按部门计算最高和最低薪资
SELECT department_id, MAX(salary) AS '最高薪资', MIN(salary) AS '最低薪资'
FROM employees
GROUP BY department_id;
```

### 实验验证

让我们使用GROUP BY和聚合函数进行一些查询：

```sql
-- 创建示例数据库
CREATE DATABASE IF NOT EXISTS company_demo CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE company_demo;

-- 创建部门表
CREATE TABLE departments (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    manager_id INT,
    location VARCHAR(100),
    budget DECIMAL(12, 2)
);

-- 创建员工表
CREATE TABLE employees (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    age INT,
    gender VARCHAR(10),
    department_id INT,
    position VARCHAR(50),
    salary DECIMAL(10, 2),
    hire_date DATE,
    email VARCHAR(100),
    phone VARCHAR(20),
    is_active BOOLEAN DEFAULT TRUE,
    FOREIGN KEY (department_id) REFERENCES departments(id)
);

-- 插入部门数据
INSERT INTO departments (name, location, budget) VALUES
('技术部', '北京', 1000000.00),
('市场部', '上海', 800000.00),
('人事部', '广州', 500000.00),
('财务部', '深圳', 600000.00);

-- 插入员工数据
INSERT INTO employees (name, age, gender, department_id, position, salary, hire_date, email, phone) VALUES
('张三', 30, '男', 1, '高级工程师', 15000.00, '2020-01-15', 'zhangsan@example.com', '13800138001'),
('李四', 28, '女', 1, '工程师', 12000.00, '2020-03-20', 'lisi@example.com', '13800138002'),
('王五', 35, '男', 1, '工程师', 13000.00, '2019-06-10', 'wangwu@example.com', '13800138003'),
('赵六', 25, '女', 1, '初级工程师', 8000.00, '2021-02-28', 'zhaoliu@example.com', '13800138004'),
('钱七', 32, '男', 2, '市场经理', 18000.00, '2019-11-05', 'qianqi@example.com', '13800138005'),
('孙八', 27, '女', 2, '市场专员', 9000.00, '2020-07-12', 'sunba@example.com', '13800138006'),
('周九', 40, '男', 2, '市场专员', 8500.00, '2020-05-20', 'zhoujiu@example.com', '13800138007'),
('吴十', 29, '女', 3, '人事经理', 16000.00, '2018-09-15', 'wushi@example.com', '13800138008'),
('郑十一', 26, '男', 3, '人事专员', 7000.00, '2021-01-10', 'zhengshiyi@example.com', '13800138009'),
('陈十二', 33, '女', 4, '财务经理', 20000.00, '2019-03-15', 'chenshier@example.com', '13800138010'),
('林十三', 28, '男', 4, '会计', 10000.00, '2020-06-20', 'linshisan@example.com', '13800138011');

-- 按部门分组，计算每个部门的员工数量、平均薪资、最高薪资和最低薪资
SELECT 
    d.name AS '部门名称',
    COUNT(e.id) AS '员工数量',
    AVG(e.salary) AS '平均薪资',
    MAX(e.salary) AS '最高薪资',
    MIN(e.salary) AS '最低薪资',
    SUM(e.salary) AS '薪资总和'
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY e.department_id, d.name
ORDER BY COUNT(e.id) DESC;

-- 按职位分组，计算每个职位的员工数量和平均薪资
SELECT 
    position AS '职位',
    COUNT(*) AS '员工数量',
    AVG(salary) AS '平均薪资',
    MAX(salary) AS '最高薪资',
    MIN(salary) AS '最低薪资'
FROM employees
GROUP BY position
ORDER BY AVG(salary) DESC;
```

## 4.2 HAVING子句

### 什么是HAVING子句？

HAVING子句用于过滤GROUP BY子句返回的组，类似于WHERE子句过滤行。HAVING子句通常与聚合函数一起使用，而WHERE子句不能与聚合函数一起使用。

### 基本语法

```sql
SELECT column1, column2, ..., aggregate_function(column)
FROM table_name
WHERE condition
GROUP BY column1, column2, ...
HAVING group_condition
ORDER BY column1, column2, ...;
```

### WHERE vs HAVING

WHERE和HAVING的主要区别：

| 特性 | WHERE | HAVING |
|------|-------|--------|
| 作用对象 | 行 | 组 |
| 使用时机 | GROUP BY之前 | GROUP BY之后 |
| 聚合函数 | 不能使用 | 可以使用 |
| 执行顺序 | 先执行 | 后执行 |

### HAVING子句示例

```sql
-- 查询员工数量大于2的部门
SELECT department_id, COUNT(*) AS '员工数量'
FROM employees
GROUP BY department_id
HAVING COUNT(*) > 2;

-- 查询平均薪资大于12000的职位
SELECT position, AVG(salary) AS '平均薪资'
FROM employees
GROUP BY position
HAVING AVG(salary) > 12000;

-- 查询薪资总和大于50000的部门
SELECT department_id, SUM(salary) AS '薪资总和'
FROM employees
GROUP BY department_id
HAVING SUM(salary) > 50000;

-- 复合条件：查询员工数量大于2且平均薪资大于10000的部门
SELECT department_id, COUNT(*) AS '员工数量', AVG(salary) AS '平均薪资'
FROM employees
GROUP BY department_id
HAVING COUNT(*) > 2 AND AVG(salary) > 10000;
```

### WHERE和HAVING结合使用

```sql
-- 先过滤年龄大于25的员工，再按部门分组，最后筛选平均薪资大于10000的部门
SELECT department_id, COUNT(*) AS '员工数量', AVG(salary) AS '平均薪资'
FROM employees
WHERE age > 25
GROUP BY department_id
HAVING AVG(salary) > 10000;
```

### 实验验证

让我们使用HAVING子句进行一些查询：

```sql
-- 查询员工数量大于2的部门
SELECT 
    d.name AS '部门名称',
    COUNT(e.id) AS '员工数量'
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY e.department_id, d.name
HAVING COUNT(e.id) > 2;

-- 查询平均薪资大于12000的职位
SELECT 
    position AS '职位',
    COUNT(*) AS '员工数量',
    AVG(salary) AS '平均薪资'
FROM employees
GROUP BY position
HAVING AVG(salary) > 12000;

-- 查询薪资总和大于50000的部门
SELECT 
    d.name AS '部门名称',
    SUM(e.salary) AS '薪资总和'
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY e.department_id, d.name
HAVING SUM(e.salary) > 50000;

-- 复合条件：查询员工数量大于2且平均薪资大于10000的部门
SELECT 
    d.name AS '部门名称',
    COUNT(e.id) AS '员工数量',
    AVG(e.salary) AS '平均薪资'
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY e.department_id, d.name
HAVING COUNT(e.id) > 2 AND AVG(e.salary) > 10000;
```

## 4.3 连接查询（JOIN）

### 什么是连接查询？

连接查询用于从多个表中检索数据，通过关联表之间的列来组合结果。连接是关系型数据库的核心概念之一。

### 连接类型

| 连接类型 | 描述 |
|----------|------|
| INNER JOIN | 内连接，只返回两个表中匹配的行 |
| LEFT JOIN | 左连接，返回左表的所有行，以及右表中匹配的行 |
| RIGHT JOIN | 右连接，返回右表的所有行，以及左表中匹配的行 |
| FULL OUTER JOIN | 全外连接，返回两个表中的所有行（MySQL不支持） |
| CROSS JOIN | 交叉连接，返回两个表的笛卡尔积 |
| SELF JOIN | 自连接，表与自身连接 |

### 内连接（INNER JOIN）

内连接只返回两个表中匹配的行：

```sql
SELECT column1, column2, ...
FROM table1
INNER JOIN table2 ON table1.column = table2.column;
```

**示例**：
```sql
-- 查询员工及其部门信息
SELECT e.name, e.position, d.name AS department
FROM employees e
INNER JOIN departments d ON e.department_id = d.id;

-- 使用WHERE实现相同效果
SELECT e.name, e.position, d.name AS department
FROM employees e, departments d
WHERE e.department_id = d.id;
```

### 左连接（LEFT JOIN）

左连接返回左表的所有行，以及右表中匹配的行：

```sql
SELECT column1, column2, ...
FROM table1
LEFT JOIN table2 ON table1.column = table2.column;
```

**示例**：
```sql
-- 查询所有员工及其部门信息（即使没有部门）
SELECT e.name, e.position, d.name AS department
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id;

-- 查询没有员工的部门
SELECT d.name AS department
FROM departments d
LEFT JOIN employees e ON d.id = e.department_id
WHERE e.id IS NULL;
```

### 右连接（RIGHT JOIN）

右连接返回右表的所有行，以及左表中匹配的行：

```sql
SELECT column1, column2, ...
FROM table1
RIGHT JOIN table2 ON table1.column = table2.column;
```

**示例**：
```sql
-- 查询所有部门及其员工信息（即使没有员工）
SELECT e.name, e.position, d.name AS department
FROM employees e
RIGHT JOIN departments d ON e.department_id = d.id;
```

### 多表连接

可以连接多个表：

```sql
SELECT column1, column2, ...
FROM table1
JOIN table2 ON table1.column = table2.column
JOIN table3 ON table2.column = table3.column;
```

**示例**：
```sql
-- 假设我们有项目表和员工项目关联表
CREATE TABLE projects (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    start_date DATE,
    end_date DATE,
    budget DECIMAL(12, 2)
);

CREATE TABLE employee_projects (
    employee_id INT,
    project_id INT,
    role VARCHAR(50),
    hours_worked INT DEFAULT 0,
    PRIMARY KEY (employee_id, project_id),
    FOREIGN KEY (employee_id) REFERENCES employees(id),
    FOREIGN KEY (project_id) REFERENCES projects(id)
);

-- 插入示例数据
INSERT INTO projects (name, start_date, end_date, budget) VALUES
('项目A', '2023-01-01', '2023-12-31', 500000.00),
('项目B', '2023-03-01', '2023-08-31', 200000.00),
('项目C', '2023-04-01', '2023-09-30', 150000.00);

INSERT INTO employee_projects (employee_id, project_id, role, hours_worked) VALUES
(1, 1, '项目经理', 320),
(2, 1, '开发工程师', 400),
(3, 2, '项目经理', 200),
(4, 2, '市场专员', 300),
(5, 3, '项目经理', 150),
(6, 3, '人事专员', 200);

-- 查询员工参与的项目信息
SELECT 
    e.name AS employee_name,
    p.name AS project_name,
    ep.role,
    ep.hours_worked
FROM employees e
JOIN employee_projects ep ON e.id = ep.employee_id
JOIN projects p ON ep.project_id = p.id
ORDER BY e.name, p.name;
```

### 自连接（SELF JOIN）

自连接是表与自身的连接，通常用于处理层次结构数据：

```sql
SELECT column1, column2, ...
FROM table1 t1
JOIN table1 t2 ON t1.column = t2.column;
```

**示例**：
```sql
-- 为员工表添加manager_id列
ALTER TABLE employees ADD COLUMN manager_id INT;
ALTER TABLE employees ADD FOREIGN KEY (manager_id) REFERENCES employees(id);

-- 更新一些员工的manager_id
UPDATE employees SET manager_id = 1 WHERE id IN (2, 3);
UPDATE employees SET manager_id = 5 WHERE id IN (6, 7);
UPDATE employees SET manager_id = 10 WHERE id IN (11, 12);

-- 查询员工及其经理信息
SELECT 
    e.name AS employee_name,
    e.position AS employee_position,
    m.name AS manager_name,
    m.position AS manager_position
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id
ORDER BY e.name;
```

### 实验验证

让我们使用连接查询进行一些查询：

```sql
-- 内连接：查询员工及其部门信息
SELECT 
    e.name AS '员工姓名',
    e.position AS '职位',
    d.name AS '部门名称',
    d.location AS '部门位置'
FROM employees e
INNER JOIN departments d ON e.department_id = d.id
ORDER BY d.name, e.name;

-- 左连接：查询所有员工及其部门信息（即使没有部门）
SELECT 
    e.name AS '员工姓名',
    e.position AS '职位',
    d.name AS '部门名称'
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id;

-- 查询没有员工的部门
SELECT 
    d.name AS '部门名称',
    d.location AS '部门位置'
FROM departments d
LEFT JOIN employees e ON d.id = e.department_id
WHERE e.id IS NULL;

-- 多表连接：查询员工参与的项目信息
SELECT 
    e.name AS '员工姓名',
    p.name AS '项目名称',
    ep.role AS '角色',
    ep.hours_worked AS '工作小时数'
FROM employees e
JOIN employee_projects ep ON e.id = ep.employee_id
JOIN projects p ON ep.project_id = p.id
ORDER BY e.name, p.name;

-- 自连接：查询员工及其经理信息
SELECT 
    e.name AS '员工姓名',
    e.position AS '员工职位',
    m.name AS '经理姓名',
    m.position AS '经理职位'
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id
ORDER BY e.name;
```

## 4.4 子查询

### 什么是子查询？

子查询是嵌套在另一个查询中的查询，也称为内部查询或内部选择。子查询可以返回单个值、一列值、一行值或一个表。

### 子查询类型

| 类型 | 描述 | 返回值 |
|------|------|--------|
| 标量子查询 | 返回单个值的子查询 | 单个值 |
| 列表子查询 | 返回一列值的子查询 | 一列值 |
| 行子查询 | 返回一行值的子查询 | 一行值 |
| 表子查询 | 返回一个表的子查询 | 多行多列 |

### 标量子查询

标量子查询返回单个值，可以用于WHERE、SELECT、HAVING等子句中：

```sql
-- 查询薪资高于平均薪资的员工
SELECT name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);

-- 查询每个员工的薪资与平均薪资的差距
SELECT 
    name, 
    salary,
    salary - (SELECT AVG(salary) FROM employees) AS '与平均薪资的差距'
FROM employees;
```

### 列表子查询

列表子查询返回一列值，通常与IN、ANY、ALL等运算符一起使用：

```sql
-- 查询技术部（部门ID=1）的员工
SELECT name, position, department_id
FROM employees
WHERE department_id IN (SELECT id FROM departments WHERE name = '技术部');

-- 使用ANY：查询薪资大于任何市场部员工薪资的技术部员工
SELECT name, position, salary
FROM employees
WHERE department_id = 1 AND salary > ANY (
    SELECT salary FROM employees WHERE department_id = 2
);

-- 使用ALL：查询薪资大于所有市场部员工薪资的技术部员工
SELECT name, position, salary
FROM employees
WHERE department_id = 1 AND salary > ALL (
    SELECT salary FROM employees WHERE department_id = 2
);
```

### 行子查询

行子查询返回一行值，通常与行构造器一起使用：

```sql
-- 查询与张三职位和薪资相同的员工
SELECT name, position, salary
FROM employees
WHERE (position, salary) = (
    SELECT position, salary FROM employees WHERE name = '张三'
);
```

### 表子查询

表子查询返回多行多列，通常用于FROM子句中：

```sql
-- 查询各部门的平均薪资
SELECT department_name, avg_salary
FROM (
    SELECT 
        d.name AS department_name,
        AVG(e.salary) AS avg_salary
    FROM employees e
    JOIN departments d ON e.department_id = d.id
    GROUP BY d.name
) AS dept_avg
WHERE avg_salary > 10000;
```

### 相关子查询

相关子查询是指子查询依赖于外部查询的值：

```sql
-- 查询薪资高于其所在部门平均薪资的员工
SELECT name, salary, department_id
FROM employees e1
WHERE salary > (
    SELECT AVG(salary)
    FROM employees e2
    WHERE e2.department_id = e1.department_id
);
```

### EXISTS和NOT EXISTS

EXISTS用于检查子查询是否返回任何行：

```sql
-- 查询有员工的部门
SELECT name, location
FROM departments d
WHERE EXISTS (
    SELECT 1 FROM employees e WHERE e.department_id = d.id
);

-- 查询没有员工的部门
SELECT name, location
FROM departments d
WHERE NOT EXISTS (
    SELECT 1 FROM employees e WHERE e.department_id = d.id
);
```

### 实验验证

让我们使用子查询进行一些查询：

```sql
-- 标量子查询：查询薪资高于平均薪资的员工
SELECT 
    name, 
    position, 
    salary,
    (SELECT AVG(salary) FROM employees) AS '平均薪资'
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);

-- 列表子查询：查询技术部（部门ID=1）的员工
SELECT name, position, department_id
FROM employees
WHERE department_id IN (SELECT id FROM departments WHERE name = '技术部');

-- 相关子查询：查询薪资高于其所在部门平均薪资的员工
SELECT 
    e1.name, 
    e1.salary, 
    e1.department_id,
    (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department_id = e1.department_id) AS '部门平均薪资'
FROM employees e1
WHERE e1.salary > (
    SELECT AVG(e2.salary)
    FROM employees e2
    WHERE e2.department_id = e1.department_id
);

-- 表子查询：查询各部门的平均薪资
SELECT department_name, avg_salary
FROM (
    SELECT 
        d.name AS department_name,
        AVG(e.salary) AS avg_salary
    FROM employees e
    JOIN departments d ON e.department_id = d.id
    GROUP BY d.name
) AS dept_avg
WHERE avg_salary > 10000;

-- EXISTS：查询有员工的部门
SELECT name, location
FROM departments d
WHERE EXISTS (
    SELECT 1 FROM employees e WHERE e.department_id = d.id
);
```

## 4.5 集合运算

### 什么是集合运算？

集合运算用于合并多个查询结果集，常见的集合运算包括UNION、INTERSECT和EXCEPT。

### UNION运算符

UNION运算符用于合并两个或多个SELECT语句的结果集，并去除重复行：

```sql
SELECT column1, column2, ... FROM table1
UNION
SELECT column1, column2, ... FROM table2;
```

**示例**：
```sql
-- 查询所有员工和经理的姓名
SELECT name, position FROM employees WHERE position LIKE '%经理%'
UNION
SELECT name, position FROM employees WHERE position LIKE '%工程师%';

-- 查询所有员工和部门的名称
SELECT name AS '名称', '员工' AS '类型' FROM employees
UNION
SELECT name AS '名称', '部门' AS '类型' FROM departments;
```

### UNION ALL运算符

UNION ALL运算符用于合并两个或多个SELECT语句的结果集，但不去除重复行：

```sql
SELECT column1, column2, ... FROM table1
UNION ALL
SELECT column1, column2, ... FROM table2;
```

**示例**：
```sql
-- 查询所有员工和经理的姓名（包括重复）
SELECT name, position FROM employees WHERE position LIKE '%经理%'
UNION ALL
SELECT name, position FROM employees WHERE position LIKE '%工程师%';
```

### INTERSECT运算符

INTERSECT运算符返回两个查询结果集的交集（MySQL不支持，可以使用INNER JOIN替代）：

```sql
-- MySQL不支持INTERSECT，可以使用INNER JOIN替代
SELECT name FROM employees WHERE position LIKE '%经理%'
INTERSECT
SELECT name FROM employees WHERE salary > 15000;

-- 使用INNER JOIN替代
SELECT DISTINCT e1.name
FROM employees e1
JOIN employees e2 ON e1.name = e2.name
WHERE e1.position LIKE '%经理%' AND e2.salary > 15000;
```

### EXCEPT运算符

EXCEPT运算符返回第一个查询结果集中不在第二个查询结果集中的行（MySQL不支持，可以使用LEFT JOIN替代）：

```sql
-- MySQL不支持EXCEPT，可以使用LEFT JOIN替代
SELECT name FROM employees WHERE position LIKE '%经理%'
EXCEPT
SELECT name FROM employees WHERE salary > 15000;

-- 使用LEFT JOIN替代
SELECT e1.name
FROM employees e1
LEFT JOIN employees e2 ON e1.name = e2.name AND e2.salary > 15000
WHERE e1.position LIKE '%经理%' AND e2.name IS NULL;
```

### 实验验证

让我们使用集合运算进行一些查询：

```sql
-- UNION：查询所有经理和工程师的姓名
SELECT name, position FROM employees WHERE position LIKE '%经理%'
UNION
SELECT name, position FROM employees WHERE position LIKE '%工程师%';

-- UNION ALL：查询所有经理和工程师的姓名（包括重复）
SELECT name, position FROM employees WHERE position LIKE '%经理%'
UNION ALL
SELECT name, position FROM employees WHERE position LIKE '%工程师%';

-- 查询所有员工和部门的名称
SELECT name AS '名称', '员工' AS '类型' FROM employees
UNION
SELECT name AS '名称', '部门' AS '类型' FROM departments;

-- 使用INNER JOIN模拟INTERSECT：查询既是经理又是高薪的员工
SELECT DISTINCT e1.name, e1.position, e1.salary
FROM employees e1
JOIN employees e2 ON e1.name = e2.name
WHERE e1.position LIKE '%经理%' AND e2.salary > 15000;

-- 使用LEFT JOIN模拟EXCEPT：查询是经理但不是高薪的员工
SELECT e1.name, e1.position, e1.salary
FROM employees e1
LEFT JOIN employees e2 ON e1.name = e2.name AND e2.salary > 15000
WHERE e1.position LIKE '%经理%' AND e2.name IS NULL;
```

## 4.6 本章小结

本章介绍了SQL的高级查询，包括：

1. **GROUP BY子句与聚合函数**：按组计算统计数据
2. **HAVING子句**：过滤分组结果
3. **连接查询（JOIN）**：从多个表中检索数据
4. **子查询**：嵌套查询实现复杂逻辑
5. **集合运算**：合并多个查询结果

通过本章的学习，您应该能够：

- 使用GROUP BY和聚合函数进行数据汇总
- 使用HAVING子句过滤分组结果
- 使用各种连接查询从多个表中检索数据
- 使用子查询实现复杂的查询逻辑
- 使用集合运算合并多个查询结果

## 4.7 思考题

1. WHERE和HAVING有什么区别？在什么情况下使用HAVING？
2. INNER JOIN和LEFT JOIN有什么区别？在什么情况下使用LEFT JOIN？
3. 相关子查询和非相关子查询有什么区别？相关子查询的执行过程是怎样的？
4. UNION和UNION ALL有什么区别？在什么情况下使用UNION ALL？
5. 子查询和连接查询有什么区别？在什么情况下应该使用子查询，什么情况下应该使用连接查询？

## 4.8 下章预告

在第5章中，我们将学习SQL的数据操作，包括：

- INSERT语句：插入数据
- UPDATE语句：更新数据
- DELETE语句：删除数据
- 事务处理：确保数据一致性

---

*继续学习，掌握SQL数据操作的技巧！*