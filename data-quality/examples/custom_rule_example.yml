# 自定义规则示例
# 展示如何创建各种类型的数据质量规则

# 1. 完整性检查 - 订单表完整性
- rule_type: "completeness"
  version: "1.0"
  description: "订单表数据完整性检查"
  scenarios: ["regression", "monitoring", "all"]
  
  rule:
    name: "orders_data_completeness"
    description: "检查订单表关键字段的完整性"
    category: "completeness"
    priority: "high"
    enabled: true
    
    target:
      database: "ecommerce"
      table: "orders"
      partition_key: "order_date"
      
    columns:
      - name: "order_id"
        data_type: "String"
        nullable: false
        required: true
        
      - name: "customer_id"
        data_type: "UInt32"
        nullable: false
        required: true
        
      - name: "order_amount"
        data_type: "Decimal64(2)"
        nullable: false
        required: true
        
      - name: "order_status"
        data_type: "String"
        nullable: false
        required: true
        
    checks:
      null_check:
        enabled: true
        severity: "critical"
        description: "检查关键字段空值"
        
      empty_string_check:
        enabled: true
        severity: "high"
        description: "检查字符串字段空值"
        
      duplicate_check:
        enabled: true
        key_columns: ["order_id"]
        severity: "critical"
        description: "检查订单ID重复"
    
    thresholds:
      null_percentage: 0
      empty_percentage: 0
      duplicate_percentage: 0
    
    template: |
      -- 订单表完整性检查
      WITH completeness_metrics AS (
        SELECT
          COUNT(*) as total_orders,
          
          -- 空值检查
          COUNT(CASE WHEN order_id IS NULL OR order_id = '' THEN 1 END) as null_order_ids,
          COUNT(CASE WHEN customer_id IS NULL THEN 1 END) as null_customer_ids,
          COUNT(CASE WHEN order_amount IS NULL THEN 1 END) as null_amounts,
          COUNT(CASE WHEN order_status IS NULL OR order_status = '' THEN 1 END) as null_status,
          
          -- 重复检查
          COUNT(*) - COUNT(DISTINCT order_id) as duplicate_order_ids,
          
          -- 数据量检查
          COUNT(*) as row_count
        FROM ecommerce.orders
        WHERE order_date >= today() - 30
      )
      SELECT
        total_orders,
        null_order_ids,
        null_customer_ids,
        null_amounts,
        null_status,
        duplicate_order_ids,
        row_count,
        
        -- 计算百分比
        round(null_order_ids / total_orders * 100, 2) as null_order_id_pct,
        round(null_customer_ids / total_orders * 100, 2) as null_customer_id_pct,
        round(duplicate_order_ids / total_orders * 100, 2) as duplicate_pct,
        
        CASE 
          WHEN total_orders = 0 THEN 'FAIL'
          WHEN null_order_ids > 0 OR null_customer_ids > 0 OR null_amounts > 0 OR null_status > 0 THEN 'FAIL'
          WHEN duplicate_order_ids > 0 THEN 'FAIL'
          ELSE 'PASS'
        END as check_result
      FROM completeness_metrics

# 2. 准确性检查 - 产品价格合理性
- rule_type: "accuracy"
  version: "1.0"
  description: "产品价格数据准确性检查"
  scenarios: ["regression", "monitoring", "all"]
  
  rule:
    name: "product_price_accuracy"
    description: "检查产品价格的合理性和格式"
    category: "accuracy"
    priority: "high"
    enabled: true
    
    target:
      database: "ecommerce"
      table: "products"
      
    columns:
      - name: "price"
        data_type: "Decimal64(2)"
        validation_rules:
          - type: "range"
            min_value: "0.01"
            max_value: "99999.99"
          - type: "format"
            pattern: "^\\d+\\.\\d{2}$"
            
      - name: "category_id"
        data_type: "UInt16"
        validation_rules:
          - type: "enum"
            allowed_values: [1, 2, 3, 4, 5, 10, 20, 30]
            
      - name: "stock_quantity"
        data_type: "Int32"
        validation_rules:
          - type: "range"
            min_value: "0"
            max_value: "100000"
    
    business_rules:
      - name: "luxury_product_price"
        description: "奢侈品类产品价格应大于1000元"
        condition: "(category_id = 10 AND price >= 1000) OR category_id != 10"
        
      - name: "discount_price_logic"
        description: "折扣价格不能大于原价"
        condition: "discount_price IS NULL OR discount_price <= price"
    
    template: |
      -- 产品价格准确性检查
      WITH accuracy_metrics AS (
        SELECT
          COUNT(*) as total_products,
          
          -- 价格范围检查
          COUNT(CASE WHEN price <= 0 OR price > 99999.99 THEN 1 END) as invalid_price_range,
          COUNT(CASE WHEN price IS NULL THEN 1 END) as null_prices,
          
          -- 类别有效性检查
          COUNT(CASE WHEN category_id NOT IN (1,2,3,4,5,10,20,30) THEN 1 END) as invalid_categories,
          
          -- 库存合理性检查
          COUNT(CASE WHEN stock_quantity < 0 OR stock_quantity > 100000 THEN 1 END) as invalid_stock,
          
          -- 业务规则检查
          COUNT(CASE WHEN category_id = 10 AND price < 1000 THEN 1 END) as luxury_price_violations,
          COUNT(CASE WHEN discount_price IS NOT NULL AND discount_price > price THEN 1 END) as discount_logic_violations,
          
          -- 统计信息
          round(AVG(price), 2) as avg_price,
          round(MIN(price), 2) as min_price,
          round(MAX(price), 2) as max_price
        FROM ecommerce.products
        WHERE updated_date >= today() - 7
      )
      SELECT
        total_products,
        invalid_price_range,
        null_prices,
        invalid_categories,
        invalid_stock,
        luxury_price_violations,
        discount_logic_violations,
        avg_price,
        min_price,
        max_price,
        
        CASE 
          WHEN total_products = 0 THEN 'FAIL'
          WHEN invalid_price_range > 0 OR null_prices > 0 THEN 'FAIL'
          WHEN invalid_categories > 0 OR invalid_stock > 0 THEN 'FAIL'
          WHEN luxury_price_violations > 0 OR discount_logic_violations > 0 THEN 'FAIL'
          ELSE 'PASS'
        END as check_result
      FROM accuracy_metrics

# 3. 一致性检查 - 订单金额与明细一致性
- rule_type: "consistency"
  version: "1.0"
  description: "订单总金额与明细金额一致性检查"
  scenarios: ["regression", "consistency_check", "all"]
  
  rule:
    name: "order_amount_consistency"
    description: "检查订单表总金额与订单明细表金额的一致性"
    category: "consistency"
    priority: "critical"
    enabled: true
    
    target:
      database: "ecommerce"
      table: "orders"
      
    related_tables:
      - database: "ecommerce"
        table: "order_items"
        relationship: "aggregation"
        key_columns: ["order_id"]
        reference_columns: ["order_id"]
        aggregation_column: "item_total"
        
    checks:
      aggregation_consistency:
        enabled: true
        tolerance: 0.01  # 允许1分钱的差异
        severity: "critical"
        description: "订单总金额与明细汇总一致性"
        
      referential_integrity:
        enabled: true
        severity: "high"
        description: "订单明细表的订单ID必须在订单表中存在"
    
    template: |
      -- 订单金额一致性检查
      WITH consistency_metrics AS (
        SELECT
          COUNT(*) as total_orders,
          
          -- 金额一致性检查
          COUNT(CASE 
            WHEN ABS(o.order_amount - COALESCE(oi.calculated_total, 0)) > 0.01 
            THEN 1 
          END) as amount_inconsistencies,
          
          -- 引用完整性检查
          COUNT(CASE 
            WHEN o.order_id NOT IN (
              SELECT DISTINCT order_id 
              FROM ecommerce.order_items 
              WHERE order_id IS NOT NULL
            ) 
            THEN 1 
          END) as orders_without_items,
          
          -- 孤儿明细检查
          (SELECT COUNT(DISTINCT order_id) 
           FROM ecommerce.order_items oi2 
           WHERE oi2.order_id NOT IN (
             SELECT order_id 
             FROM ecommerce.orders 
             WHERE order_id IS NOT NULL
           )
          ) as orphan_items,
          
          -- 统计信息
          round(AVG(ABS(o.order_amount - COALESCE(oi.calculated_total, 0))), 4) as avg_amount_diff,
          round(MAX(ABS(o.order_amount - COALESCE(oi.calculated_total, 0))), 2) as max_amount_diff
        FROM ecommerce.orders o
        LEFT JOIN (
          SELECT 
            order_id,
            SUM(quantity * unit_price) as calculated_total
          FROM ecommerce.order_items
          GROUP BY order_id
        ) oi ON o.order_id = oi.order_id
        WHERE o.order_date >= today() - 30
      )
      SELECT
        total_orders,
        amount_inconsistencies,
        orders_without_items,
        orphan_items,
        avg_amount_diff,
        max_amount_diff,
        
        -- 计算不一致比例
        round(amount_inconsistencies / total_orders * 100, 2) as inconsistency_rate,
        
        CASE 
          WHEN total_orders = 0 THEN 'FAIL'
          WHEN amount_inconsistencies > 0 THEN 'FAIL'
          WHEN orders_without_items > 0 THEN 'FAIL'
          WHEN orphan_items > 0 THEN 'FAIL'
          ELSE 'PASS'
        END as check_result
      FROM consistency_metrics

# 4. 时效性检查 - 数据更新及时性
- rule_type: "timeliness"
  version: "1.0"
  description: "数据更新时效性检查"
  scenarios: ["monitoring", "timeliness_check", "all"]
  
  rule:
    name: "data_freshness_check"
    description: "检查关键表的数据更新时效性"
    category: "timeliness"
    priority: "medium"
    enabled: true
    
    target:
      database: "ecommerce"
      table: "orders"
      
    time_columns:
      - name: "created_time"
        data_type: "DateTime"
        freshness_threshold: "2 hours"
        
      - name: "updated_time"
        data_type: "DateTime"
        freshness_threshold: "1 hour"
    
    checks:
      freshness_check:
        enabled: true
        max_delay: "2 hours"
        severity: "medium"
        description: "检查数据更新是否及时"
        
      latency_check:
        enabled: true
        max_latency: "30 minutes"
        severity: "low"
        description: "检查数据处理延迟"
    
    template: |
      -- 数据时效性检查
      WITH timeliness_metrics AS (
        SELECT
          COUNT(*) as total_records,
          
          -- 新鲜度检查
          COUNT(CASE 
            WHEN created_time < now() - INTERVAL 2 HOUR 
            THEN 1 
          END) as stale_records,
          
          -- 最新记录时间
          MAX(created_time) as latest_record_time,
          MIN(created_time) as earliest_record_time,
          
          -- 数据延迟计算
          round(dateDiff('minute', MAX(created_time), now())) as minutes_since_latest,
          
          -- 今日数据量
          COUNT(CASE 
            WHEN toDate(created_time) = today() 
            THEN 1 
          END) as today_records,
          
          -- 昨日数据量（用于对比）
          COUNT(CASE 
            WHEN toDate(created_time) = today() - 1 
            THEN 1 
          END) as yesterday_records
        FROM ecommerce.orders
        WHERE created_time >= today() - 7
      )
      SELECT
        total_records,
        stale_records,
        latest_record_time,
        earliest_record_time,
        minutes_since_latest,
        today_records,
        yesterday_records,
        
        -- 计算数据新鲜度比例
        round((total_records - stale_records) / total_records * 100, 2) as freshness_rate,
        
        -- 数据量变化比例
        CASE 
          WHEN yesterday_records > 0 
          THEN round((today_records - yesterday_records) / yesterday_records * 100, 2)
          ELSE NULL
        END as daily_change_rate,
        
        CASE 
          WHEN total_records = 0 THEN 'FAIL'
          WHEN minutes_since_latest > 120 THEN 'FAIL'  -- 超过2小时无新数据
          WHEN stale_records / total_records > 0.1 THEN 'FAIL'  -- 超过10%的数据不新鲜
          ELSE 'PASS'
        END as check_result
      FROM timeliness_metrics

