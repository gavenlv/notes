### 🔍 考察核心要点

以下表格汇总了Docker和Kubernetes的核心考察维度及关键点，你可以根据招聘岗位的级别（初/中/高级）调整考察的深度和侧重点。

| 能力维度          | Docker 关键考察点                                                                                                | Kubernetes (K8s) 关键考察点                                                                                     | 适用岗位级别   |
| :---------------- | :--------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------- | :--------- |
| **核心概念理解**    | 镜像、容器、仓库、Dockerfile、数据卷、网络模式                                                                 | Pod、Deployment、Service、Namespace、ConfigMap/Secret、滚动更新与回滚                                     | 初级及以上     |
| **常用命令与操作**  | `docker run`、`docker build`、`docker ps`、`docker logs`、`docker exec`                                      | `kubectl get`、`kubectl describe`、`kubectl apply`、`kubectl logs`、`kubectl exec`                               | 初级及以上     |
| **镜像构建与优化**  | 编写高效的Dockerfile、多阶段构建、减少镜像层数、使用小型基础镜像                                                             | 管理镜像仓库（如Harbor）、思考镜像拉取策略（`imagePullPolicy`）                                                                       | 中级及以上     |
| **网络与存储**     | 容器网络模式（bridge/host/none）、端口映射、数据卷挂载（volumes）                                                        | K8s网络模型（CNI）、Service类型（ClusterIP/NodePort/LoadBalancer）、Ingress、PersistentVolume (PV) & PersistentVolumeClaim (PVC) | 中级及以上     |
| **编排与部署**     | Docker Compose 多容器编排                                                                                    | 理解Deployment, StatefulSet, DaemonSet控制器、Pod生命周期、健康检查（liveness/readiness probes）              | 中级及以上     |
| **故障排查与调试**  | 查看容器日志、进入容器调试、分析容器进程                                                                                 | 查看Pod描述和事件、查看容器日志、进入Pod调试、分析资源状态（如`kubectl describe`）                                      | 中级及以上     |
| **安全与最佳实践**  | 非root用户运行容器、镜像漏洞扫描、安全运行实践                                                                             | RBAC授权、SecurityContext配置、网络策略（NetworkPolicy）、Secret管理                                           | 高级         |
| **集群管理与原理**  | -                                                                                                              | 核心组件功能（API Server, etcd, Scheduler, Controller Manager, Kubelet, Kube-proxy）、高可用性、etcd运维             | 高级、架构师    |

### 💡 面试问题示例

#### **Docker 相关问题**

1.  **基础概念**：镜像（Image）和容器（Container）有什么区别？
2.  **操作命令**：如何查看 Docker 容器的日志？如何进入一个运行中的容器进行调试？
3.  **Dockerfile**：如何编写一个高效的 Dockerfile？有哪些最佳实践？
4.  **故障排查**：如果一个容器不断重启，你如何排查问题？

#### **Kubernetes 相关问题**

1.  **核心概念**：Pod 是什么？为什么 K8s 不直接管理容器而是引入 Pod 的概念？
2.  **核心概念**：Deployment 和 StatefulSet 有什么区别？分别用在什么场景？
3.  **操作命令**：如何将一个 Deployment 扩展到 3 个副本？如何滚动更新一个应用？
4.  **故障排查**：如何排查一个 Pod 无法正常启动的问题？
5.  **原理理解**：简述一下 K8s 中创建一个 Pod 的完整流程。

### ⚡ 快速考察技巧

1.  **电话筛查 (5-10分钟)**：询问2-3个核心概念题，例如“Docker镜像和容器的区别”或“Pod是什么”，观察回答的流畅度和准确性。
2.  **实战编码测试 (45-60分钟)**：
    *   **初级**：提供一个简单的应用（如Python Flask）和需求，要求编写Dockerfile将其容器化，并推送到镜像仓库。
    *   **中高级**：除了容器化应用，还要求编写Kubernetes的Deployment和Service的YAML配置文件，或要求对现有的有瑕疵的Dockerfile和YAML文件进行优化和调试。可以提供在线K8s实验环境或要求其在本地Minikube环境中操作。
3.  **深度探讨 (现场/视频面试)**：
    *   **场景题**：设计一个具体的故障场景（如“某个服务部署后无法访问”），要求应聘者口述排查思路和命令。
    *   **设计题**：要求设计一个简单应用的容器化及在K8s上的部署方案，并说明如何考虑网络、存储、高可用等因素。

### 🤝 考察团队协作与工程实践

除了纯技术能力，还可以了解其在团队中的实践经验：
*   **CI/CD集成**：是否有将Docker和K8s与CI/CD工具（如Jenkins、GitLab CI）集成的经验？流程是怎样的？
*   **配置管理**：如何管理不同环境（开发、测试、生产）的配置？是否使用过Helm、Kustomize等工具？
*   **监控与日志**：如何监控K8s集群和容器的健康状况？如何收集和查看容器日志？

### 📌 总结

快速考察应聘者的Docker和Kubernetes能力，关键在于**理论结合实践**：

*   **初级开发者**：重点考察**基本概念和常用命令**的掌握程度，能完成简单的容器化和部署任务。
*   **中级开发者/运维**：重点考察**复杂场景的应用能力**、**故障排查技巧**以及**对网络、存储等核心概念的理解**。
*   **高级工程师/架构师**：重点考察**系统设计能力**、**原理深入理解**、**集群管理经验**以及**安全与最佳实践的落地**。

### ⚙️ 一、Docker 基础概念

1.  **什么是 Docker？为什么使用它？**
    Docker 是一个开源的容器化平台，允许开发者将应用及其依赖打包到一个轻量级、可移植的容器中。它保证了应用在不同环境中运行的一致性。使用 Docker 可以简化部署、提升开发效率、更好地利用系统资源，并非常适合微服务架构和 DevOps 流程。

2.  **Docker 容器与传统虚拟机（VM）有何区别？**
    两者的主要区别在于虚拟化层次和资源使用方式：
    | 特性 | Docker 容器 | 传统虚拟机 (VM) |
    | :--- | :--- | :--- |
    | **虚拟化级别** | 操作系统级别 | 硬件级别 |
    | **隔离性** | 进程级别隔离（通过 Namespace、Cgroups） | 完整的操作系统级别隔离 |
    | **启动速度** | 秒级 | 分钟级 |
    | **性能损耗** | 低，接近原生 | 高 |
    | **磁盘占用** | 小（共享镜像层） | 大（每个VM包含完整OS） |
    | **本质** | 宿主操作系统上的一个进程 | 虚拟机监视器上的完整操作系统 |

3.  **什么是 Docker 镜像和容器？**
    *   **镜像（Image）**：是一个**只读的模板**，包含了运行应用程序所需的代码、运行时环境、库、环境变量和配置文件。它采用分层存储结构，每一层都是只读的。
    *   **容器（Container）**：是镜像的一个**可运行的实例**。容器在镜像的只读层之上增加了一个可写层，使得应用程序可以运行。容器是轻量级、可移植的。

### 📝 二、Dockerfile 与镜像构建

1.  **Dockerfile 中的 COPY 和 ADD 指令有什么区别？**
    *   `COPY`：**仅用于**将本地文件或目录复制到镜像中。行为简单明确，是首选。
    *   `ADD`：除了复制本地文件外，还支持：
        *   从 URL 下载文件并复制到镜像中。
        *   自动解压本地压缩文件（如 tar、zip）到镜像指定目录。
    *   **建议**：除非需要 `ADD` 的额外功能，否则应优先使用 `COPY`，因为它的行为更可预测。

2.  **Dockerfile 中 CMD 和 ENTRYPOINT 有什么区别？**
    *   `CMD`：为容器提供**默认的执行命令**及其参数。一个 Dockerfile 中只能有一条 `CMD` 指令。这些参数可以被 `docker run` 后面接的命令行参数覆盖。
    *   `ENTRYPOINT`：配置容器启动时运行的**核心命令**，不容易被 `docker run` 覆盖。通常用于让容器像一个可执行程序一样运行。
    *   **联合使用**：`ENTRYPOINT` 设定主要命令，`CMD` 设定其默认参数。运行容器时，命令行参数会附加在 `ENTRYPOINT` 之后，并覆盖 `CMD` 的内容。

3.  **什么是多阶段构建？有什么好处？**
    **多阶段构建**允许在一个 Dockerfile 中使用多个 `FROM` 指令，每个 `FROM` 开始一个新的构建阶段。你可以选择性地将前一阶段的构建结果复制到后续阶段。
    *   **好处**：
        *   **大幅减小最终镜像体积**：因为最终镜像只包含运行所需的 artifacts（如编译好的二进制文件、依赖包），而不包含编译环境（如编译器、构建工具）。
        *   **提升安全性**：减少了攻击面。

### ⚡ 三、容器操作与生命周期管理

1.  **Docker 容器有哪些常见的生命周期操作命令？**
    常用的命令包括：
    *   `docker create`：创建容器但不启动。
    *   `docker start`：启动已停止的容器。
    *   `docker stop`：停止运行中的容器。
    *   `docker restart`：重启容器。
    *   `docker rm`：删除已停止的容器。
    *   `docker run`：创建并启动一个新容器（等价于 `docker create` + `docker start`）。
    *   `docker exec -it <container> /bin/bash`：进入一个正在运行的容器内部执行命令。
    *   `docker logs <container>`：查看容器的日志输出。

2.  **如何实现 Docker 容器的数据持久化？**
    容器默认的文件系统是临时的，容器删除后数据会丢失。实现数据持久化的主要方式有：
    *   **数据卷（Volume）**：由 Docker 管理，存储在宿主机特定目录（如 `/var/lib/docker/volumes/`），与容器的生命周期解耦。是**推荐的方式**。
        *   命令：`docker volume create`、`docker run -v volume_name:/path/in/container`
    *   **绑定挂载（Bind Mount）**：将宿主机的任意目录或文件直接挂载到容器中。更灵活，但依赖宿主机目录结构。
        *   命令：`docker run -v /host/path:/path/in/container`

### 🌐 四、Docker 网络与通信

1.  **Docker 有哪些网络模式？**
    Docker 主要提供以下网络模式：
    *   **bridge（桥接）**：**默认模式**。每个容器分配独立的网络命名空间，并通过一个虚拟网桥（docker0）与宿主机通信。容器之间可以通过 IP 地址通信，在同一网桥上的容器可以通过容器名通信。
    *   **host（主机）**：容器共享宿主机的网络命名空间，直接使用宿主机的 IP 和端口。性能最好，但隔离性最差。
    *   **none（无网络）**：容器没有网络接口，只有回环地址（lo）。
    *   **container（容器）**：新容器与一个已存在的容器共享网络命名空间，网络配置完全相同。

2.  **如何实现跨主机容器通信？**
    默认的 `bridge` 网络无法直接跨主机通信。实现跨主机通信的方案有：
    *   **Overlay 网络（覆盖网络）**：通过 VXLAN 等隧道技术，在物理网络之上创建一个虚拟网络，使不同主机上的容器就像在同一个局域网中一样。Docker Swarm 和 Kubernetes 默认使用 Overlay 网络实现跨主机通信。
    *   第三方网络插件：如 Calico、Flannel 等，通常与 Kubernetes 集成，提供更强大的网络策略和性能。

### ☸️ 五、Kubernetes 核心概念

1.  **Kubernetes 的核心组件有哪些？简述其功能。**
    一个 Kubernetes 集群由 Master（控制平面）和 Node（工作节点）组成。
    *   **Master 组件**：
        *   **API Server**：集群的**唯一入口**，所有资源操作的请求都要经过它，是其他组件通信的中枢。
        *   **etcd**：分布式的**键值数据库**，保存了整个集群的状态等所有持久化数据。
        *   **Scheduler**：负责**调度 Pod** 到合适的 Node 上运行。
        *   **Controller Manager**：运行着各种**控制器**，负责维护集群的状态（如副本数、节点状态）。
    *   **Node 组件**：
        *   **Kubelet**：负责与 Master 通信，管理本节点上 Pod 的**生命周期**（创建、销毁）。
        *   **kube-proxy**：负责维护节点上的**网络规则**，实现 Service 的负载均衡和网络代理。
        *   **容器运行时**（如 Containerd）：负责真正**运行容器**。

2.  **什么是 Pod？为什么它是 Kubernetes 的最小部署单元？**
    *   **Pod** 是 Kubernetes 中**创建和管理的最小、最简单的计算单元**。一个 Pod 包含一个或多个**紧密关联的容器**（通常是一个），这些容器共享网络命名空间、IP 地址、端口空间和存储卷（Volume）。它们总是被共同调度和部署在同一个节点上。
    *   **为什么是最小单元**：Kubernetes 无法直接操作容器，而是通过 Pod 来对容器进行抽象和包装。Pod 提供了一个共享的环境，使得其内部的容器可以高效通信（通过 localhost）和共享数据，从而将它们视为一个整体服务单元来管理。

3.  **Kubernetes 的 Service 有哪些类型？**
    Service 定义了访问一组 Pod 的抽象方式。其主要类型有：
    *   **ClusterIP**：**默认类型**。为 Service 分配一个集群内部的虚拟 IP，只能在集群内部访问。
    *   **NodePort**：在每个 Node 的 IP 上开放一个静态端口（NodePort），并将请求转发给 Service。可以通过 `<NodeIP>:<NodePort>` 从集群外部访问。
    *   **LoadBalancer**：通常由云服务商提供。在 NodePort 的基础上，创建一个外部负载均衡器，并将流量引导到 Service。
    *   **ExternalName**：将 Service 映射到一个外部域名（如 `my.database.example.com`），用于访问集群外部的服务。

### 🔧 六、Kubernetes 进阶特性

1.  **什么是滚动更新（Rolling Update）和回滚（Rollback）？**
    这是 Deployment 控制器管理 Pod 更新的策略。
    *   **滚动更新**：当更新 Deployment 的 Pod 模板（如镜像版本）时，Kubernetes 会**逐步创建新版本的 Pod**，同时**逐步终止旧版本的 Pod**。此过程无需停服，能保证服务在更新期间始终可用。
    *   **回滚**：如果更新后的应用出现问题，可以**将 Deployment 回退到之前的修订版本**。Kubernetes 会再次执行滚动更新，将 Pod 恢复到旧版配置。

2.  **如何保障应用的高可用性？**
    *   **多副本（Replicas）**：通过 Deployment 等控制器设置 `replicas > 1`，Kubernetes 会确保始终有指定数量的 Pod 实例在运行，即使有节点故障，也会在其它节点上重建 Pod。
    *   **就绪探针（Readiness Probe）**：告诉 Kubernetes 何时可以将流量发送到 Pod。只有当就绪检查通过后，Pod 才会成为 Service 的端点（Endpoint）。这确保了只有准备好服务的 Pod 才会接收流量。
    *   **存活探针（Liveness Probe）**：告诉 Kubernetes 何时需要**重启容器**。如果存活检查失败，Kubernetes 会杀死该容器并根据策略重启它。这可以解决应用程序运行但无法正常服务的问题。

3.  **如何管理敏感配置信息（如密码）？**
    *   使用 **Secret** 对象。Secret 用于存储敏感数据，例如密码、OAuth 令牌和 ssh 密钥。Secret 的数据是经过 Base64 编码的（**注意：并非加密**），可以通过环境变量或挂载为卷的方式传递给 Pod。
    *   普通配置可以使用 **ConfigMap**。

### 💡 面试小贴士

*   **理解原理**：面试官不仅想知道“是什么”，更想知道“为什么”，比如为什么用 Pod 而不是直接管理容器。
*   **结合经验**：尽量将答案与你过去的项目经验相结合，例如“我们在上一个项目中使用多阶段构建，将镜像体积减少了 70%”。
*   **主动思考**：对于一些开放性问题（例如如何设计一个系统），可以先澄清需求，再阐述你的思路，展现解决问题的逻辑。
*   **诚实守信**：如果遇到不会的问题，可以坦诚说明，并尝试基于已有知识进行推理，展现学习能力和解决问题的思路。
