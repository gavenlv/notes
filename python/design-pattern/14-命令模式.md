# 第14章 命令模式 (Command Pattern)

## 1. 什么是命令模式？

命令模式是一种行为型设计模式，它将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

### 1.1 核心概念

- **命令 (Command)**: 声明执行操作的接口
- **具体命令 (ConcreteCommand)**: 将一个接收者对象绑定于一个动作，调用接收者相应的操作
- **客户端 (Client)**: 创建一个具体命令对象并设定它的接收者
- **调用者 (Invoker)**: 要求该命令执行这个请求
- **接收者 (Receiver)**: 知道如何实施与执行一个请求相关的操作

### 1.2 现实世界类比

想象一个餐厅的点餐系统：
- 顾客是客户端，点餐单是命令对象
- 服务员是调用者，接收点餐单并传递给厨房
- 厨师是接收者，根据点餐单准备食物
- 点餐单可以排队、取消、重做，还可以记录日志

## 2. 命令模式的结构

```python
Command
    ↳ ConcreteCommand
Invoker
Receiver
Client
```

### 2.1 参与者角色

1. **Command (命令)**: 声明执行操作的接口
2. **ConcreteCommand (具体命令)**: 将一个接收者对象绑定于一个动作，调用接收者相应的操作
3. **Client (客户端)**: 创建一个具体命令对象并设定它的接收者
4. **Invoker (调用者)**: 要求该命令执行这个请求
5. **Receiver (接收者)**: 知道如何实施与执行一个请求相关的操作

## 3. 命令模式的实现

### 3.1 基础实现示例

让我们通过一个文本编辑器的例子来理解命令模式：

```python
from abc import ABC, abstractmethod
from datetime import datetime

# 接收者 - 文档类
class Document:
    def __init__(self, name):
        self.name = name
        self.content = ""
        self.cursor_position = 0
    
    def insert_text(self, text, position=None):
        if position is None:
            position = self.cursor_position
        
        self.content = self.content[:position] + text + self.content[position:]
        self.cursor_position = position + len(text)
        print(f"在位置 {position} 插入文本: '{text}'")
    
    def delete_text(self, start, length):
        deleted_text = self.content[start:start+length]
        self.content = self.content[:start] + self.content[start+length:]
        
        if self.cursor_position > start:
            self.cursor_position = max(start, self.cursor_position - length)
        
        print(f"从位置 {start} 删除 {length} 个字符: '{deleted_text}'")
        return deleted_text
    
    def set_cursor(self, position):
        self.cursor_position = max(0, min(position, len(self.content)))
        print(f"设置光标位置: {self.cursor_position}")
    
    def get_content(self):
        return self.content
    
    def display(self):
        print(f"文档 '{self.name}' 内容: '{self.content}'")
        print(f"光标位置: {self.cursor_position}")

# 命令接口
class Command(ABC):
    @abstractmethod
    def execute(self):
        pass
    
    @abstractmethod
    def undo(self):
        pass

# 具体命令 - 插入文本
class InsertCommand(Command):
    def __init__(self, document, text, position=None):
        self.document = document
        self.text = text
        self.position = position
        self.executed = False
    
    def execute(self):
        if not self.executed:
            self.original_position = self.document.cursor_position
            self.document.insert_text(self.text, self.position)
            self.executed = True
    
    def undo(self):
        if self.executed:
            # 删除刚才插入的文本
            delete_start = self.position if self.position is not None else self.original_position
            self.document.delete_text(delete_start, len(self.text))
            self.document.set_cursor(self.original_position)
            self.executed = False

# 具体命令 - 删除文本
class DeleteCommand(Command):
    def __init__(self, document, start, length):
        self.document = document
        self.start = start
        self.length = length
        self.deleted_text = ""
        self.executed = False
    
    def execute(self):
        if not self.executed:
            self.original_position = self.document.cursor_position
            self.deleted_text = self.document.delete_text(self.start, self.length)
            self.executed = True
    
    def undo(self):
        if self.executed:
            # 重新插入被删除的文本
            self.document.insert_text(self.deleted_text, self.start)
            self.document.set_cursor(self.original_position)
            self.executed = False

# 具体命令 - 设置光标
class SetCursorCommand(Command):
    def __init__(self, document, position):
        self.document = document
        self.position = position
        self.original_position = 0
        self.executed = False
    
    def execute(self):
        if not self.executed:
            self.original_position = self.document.cursor_position
            self.document.set_cursor(self.position)
            self.executed = True
    
    def undo(self):
        if self.executed:
            self.document.set_cursor(self.original_position)
            self.executed = False

# 调用者 - 命令管理器
class CommandManager:
    def __init__(self):
        self.history = []
        self.redo_stack = []
    
    def execute_command(self, command):
        command.execute()
        self.history.append(command)
        self.redo_stack.clear()  # 执行新命令后清空重做栈
    
    def undo(self):
        if self.history:
            command = self.history.pop()
            command.undo()
            self.redo_stack.append(command)
            print("撤销操作")
        else:
            print("没有可撤销的操作")
    
    def redo(self):
        if self.redo_stack:
            command = self.redo_stack.pop()
            command.execute()
            self.history.append(command)
            print("重做操作")
        else:
            print("没有可重做的操作")
    
    def get_history_size(self):
        return len(self.history)
    
    def clear_history(self):
        self.history.clear()
        self.redo_stack.clear()
        print("历史记录已清除")
```

### 3.2 使用示例

```python
# 创建文档和命令管理器
doc = Document("测试文档")
cmd_manager = CommandManager()

print("=== 文本编辑器命令模式演示 ===")

# 执行一系列命令
print("\n1. 插入文本")
cmd1 = InsertCommand(doc, "Hello")
cmd_manager.execute_command(cmd1)

doc.display()

print("\n2. 插入更多文本")
cmd2 = InsertCommand(doc, " World!")
cmd_manager.execute_command(cmd2)

doc.display()

print("\n3. 设置光标位置")
cmd3 = SetCursorCommand(doc, 5)
cmd_manager.execute_command(cmd3)

doc.display()

print("\n4. 在光标位置插入文本")
cmd4 = InsertCommand(doc, " Beautiful")
cmd_manager.execute_command(cmd4)

doc.display()

print("\n5. 删除部分文本")
cmd5 = DeleteCommand(doc, 0, 6)  # 删除 "Hello "
cmd_manager.execute_command(cmd5)

doc.display()

print(f"\n历史记录大小: {cmd_manager.get_history_size()}")

# 测试撤销和重做功能
print("\n=== 测试撤销功能 ===")
cmd_manager.undo()  # 撤销删除
doc.display()

cmd_manager.undo()  # 撤销插入 " Beautiful"
doc.display()

cmd_manager.undo()  # 撤销设置光标
doc.display()

print("\n=== 测试重做功能 ===")
cmd_manager.redo()  # 重做设置光标
doc.display()

cmd_manager.redo()  # 重做插入 " Beautiful"
doc.display()

cmd_manager.redo()  # 重做删除
doc.display()
```

## 4. 命令模式的优势

### 4.1 优点

1. **解耦调用者和接收者**: 命令模式将调用操作的对象与知道如何实现该操作的对象解耦
2. **支持撤销和重做**: 可以很容易地实现命令的撤销和重做功能
3. **支持命令队列**: 可以将命令放入队列中，延迟执行或批量执行
4. **支持日志记录**: 可以记录命令的执行历史
5. **易于扩展**: 增加新的命令很容易，无需修改现有代码

### 4.2 缺点

1. **增加复杂性**: 可能会引入过多的具体命令类
2. **性能开销**: 每个命令都是一个对象，可能增加内存开销
3. **设计过度**: 对于简单的操作，使用命令模式可能过度设计

## 5. 实际应用场景

### 5.1 智能家居控制系统

```python
from abc import ABC, abstractmethod

# 接收者 - 各种家电设备
class Light:
    def __init__(self, location):
        self.location = location
        self.is_on = False
    
    def turn_on(self):
        self.is_on = True
        print(f"{self.location} 灯已打开")
    
    def turn_off(self):
        self.is_on = False
        print(f"{self.location} 灯已关闭")

class Thermostat:
    def __init__(self):
        self.temperature = 22  # 默认温度
    
    def set_temperature(self, temp):
        self.temperature = temp
        print(f"温度设置为 {temp}°C")
    
    def get_temperature(self):
        return self.temperature

class TV:
    def __init__(self):
        self.is_on = False
        self.channel = 1
        self.volume = 50
    
    def turn_on(self):
        self.is_on = True
        print("电视已打开")
    
    def turn_off(self):
        self.is_on = False
        print("电视已关闭")
    
    def set_channel(self, channel):
        self.channel = channel
        print(f"频道设置为 {channel}")
    
    def set_volume(self, volume):
        self.volume = volume
        print(f"音量设置为 {volume}")

# 命令接口
class HomeCommand(ABC):
    @abstractmethod
    def execute(self):
        pass
    
    @abstractmethod
    def undo(self):
        pass

# 具体命令
class LightOnCommand(HomeCommand):
    def __init__(self, light):
        self.light = light
        self.previous_state = None
    
    def execute(self):
        self.previous_state = self.light.is_on
        self.light.turn_on()
    
    def undo(self):
        if self.previous_state is False:
            self.light.turn_off()

class LightOffCommand(HomeCommand):
    def __init__(self, light):
        self.light = light
        self.previous_state = None
    
    def execute(self):
        self.previous_state = self.light.is_on
        self.light.turn_off()
    
    def undo(self):
        if self.previous_state is True:
            self.light.turn_on()

class ThermostatCommand(HomeCommand):
    def __init__(self, thermostat, temperature):
        self.thermostat = thermostat
        self.temperature = temperature
        self.previous_temp = None
    
    def execute(self):
        self.previous_temp = self.thermostat.get_temperature()
        self.thermostat.set_temperature(self.temperature)
    
    def undo(self):
        if self.previous_temp is not None:
            self.thermostat.set_temperature(self.previous_temp)

# 宏命令 - 组合多个命令
class MacroCommand(HomeCommand):
    def __init__(self, commands):
        self.commands = commands
    
    def execute(self):
        for command in self.commands:
            command.execute()
    
    def undo(self):
        # 按相反顺序撤销
        for command in reversed(self.commands):
            command.undo()

# 调用者 - 遥控器
class RemoteControl:
    def __init__(self):
        self.on_commands = {}
        self.off_commands = {}
        self.undo_command = None
    
    def set_command(self, slot, on_command, off_command):
        self.on_commands[slot] = on_command
        self.off_commands[slot] = off_command
    
    def press_on_button(self, slot):
        if slot in self.on_commands:
            command = self.on_commands[slot]
            command.execute()
            self.undo_command = command
    
    def press_off_button(self, slot):
        if slot in self.off_commands:
            command = self.off_commands[slot]
            command.execute()
            self.undo_command = command
    
    def press_undo_button(self):
        if self.undo_command is not None:
            self.undo_command.undo()
            self.undo_command = None

# 使用智能家居系统
living_room_light = Light("客厅")
bedroom_light = Light("卧室")
thermostat = Thermostat()
tv = TV()

# 创建命令
living_light_on = LightOnCommand(living_room_light)
living_light_off = LightOffCommand(living_room_light)
bedroom_light_on = LightOnCommand(bedroom_light)
bedroom_light_off = LightOffCommand(bedroom_light)
warm_temp = ThermostatCommand(thermostat, 25)

# 创建宏命令 - "回家模式"
go_home_commands = [living_light_on, bedroom_light_on, warm_temp]
go_home_macro = MacroCommand(go_home_commands)

# 创建宏命令 - "睡觉模式"
sleep_commands = [living_light_off, bedroom_light_off, ThermostatCommand(thermostat, 20)]
sleep_macro = MacroCommand(sleep_commands)

# 设置遥控器
remote = RemoteControl()
remote.set_command(0, living_light_on, living_light_off)
remote.set_command(1, bedroom_light_on, bedroom_light_off)
remote.set_command(2, go_home_macro, sleep_macro)

print("=== 智能家居控制系统 ===")

# 测试遥控器
print("\n1. 打开客厅灯:")
remote.press_on_button(0)

print("\n2. 打开卧室灯:")
remote.press_on_button(1)

print("\n3. 撤销操作:")
remote.press_undo_button()

print("\n4. 执行回家模式:")
remote.press_on_button(2)

print("\n5. 执行睡觉模式:")
remote.press_off_button(2)
```

### 5.2 交易系统

```python
from abc import ABC, abstractmethod

# 接收者 - 银行账户
class BankAccount:
    def __init__(self, owner, initial_balance=0):
        self.owner = owner
        self.balance = initial_balance
        print(f"创建账户: {owner}, 初始余额: {initial_balance}")
    
    def deposit(self, amount):
        self.balance += amount
        print(f"存款 {amount}, 当前余额: {self.balance}")
    
    def withdraw(self, amount):
        if amount <= self.balance:
            self.balance -= amount
            print(f"取款 {amount}, 当前余额: {self.balance}")
            return True
        else:
            print(f"取款失败: 余额不足，当前余额: {self.balance}")
            return False
    
    def get_balance(self):
        return self.balance

# 交易命令接口
class Transaction(ABC):
    @abstractmethod
    def execute(self):
        pass
    
    @abstractmethod
    def undo(self):
        pass

# 具体交易命令
class DepositTransaction(Transaction):
    def __init__(self, account, amount):
        self.account = account
        self.amount = amount
        self.executed = False
    
    def execute(self):
        self.account.deposit(self.amount)
        self.executed = True
    
    def undo(self):
        if self.executed:
            self.account.withdraw(self.amount)
            self.executed = False

class WithdrawTransaction(Transaction):
    def __init__(self, account, amount):
        self.account = account
        self.amount = amount
        self.executed = False
        self.successful = False
    
    def execute(self):
        self.successful = self.account.withdraw(self.amount)
        self.executed = True
        return self.successful
    
    def undo(self):
        if self.executed and self.successful:
            self.account.deposit(self.amount)
            self.executed = False

# 交易管理器
class TransactionManager:
    def __init__(self):
        self.transactions = []
        self.current_index = -1
    
    def execute_transaction(self, transaction):
        # 清除当前索引之后的所有交易（重做历史）
        if self.current_index < len(self.transactions) - 1:
            self.transactions = self.transactions[:self.current_index + 1]
        
        success = transaction.execute()
        if success is not False:  # 允许返回None或True
            self.transactions.append(transaction)
            self.current_index = len(self.transactions) - 1
        return success
    
    def can_undo(self):
        return self.current_index >= 0
    
    def can_redo(self):
        return self.current_index < len(self.transactions) - 1
    
    def undo(self):
        if self.can_undo():
            transaction = self.transactions[self.current_index]
            transaction.undo()
            self.current_index -= 1
            print("撤销交易")
        else:
            print("没有可撤销的交易")
    
    def redo(self):
        if self.can_redo():
            self.current_index += 1
            transaction = self.transactions[self.current_index]
            transaction.execute()
            print("重做交易")
        else:
            print("没有可重做的交易")
    
    def get_transaction_history(self):
        return self.transactions[:self.current_index + 1]

# 使用交易系统
account = BankAccount("张三", 1000)
tx_manager = TransactionManager()

print("\n=== 银行交易系统 ===")

# 执行一系列交易
print("\n1. 存款500:")
tx1 = DepositTransaction(account, 500)
tx_manager.execute_transaction(tx1)

print("\n2. 取款200:")
tx2 = WithdrawTransaction(account, 200)
tx_manager.execute_transaction(tx2)

print("\n3. 取款2000（会失败）:")
tx3 = WithdrawTransaction(account, 2000)
tx_manager.execute_transaction(tx3)

print("\n4. 存款1000:")
tx4 = DepositTransaction(account, 1000)
tx_manager.execute_transaction(tx4)

print(f"\n当前余额: {account.get_balance()}")

# 测试撤销和重做
print("\n=== 测试撤销功能 ===")
tx_manager.undo()  # 撤销存款1000
print(f"余额: {account.get_balance()}")

tx_manager.undo()  # 撤销取款200
print(f"余额: {account.get_balance()}")

print("\n=== 测试重做功能 ===")
tx_manager.redo()  # 重做取款200
print(f"余额: {account.get_balance()}")

tx_manager.redo()  # 重做存款1000
print(f"余额: {account.get_balance()}")
```

## 6. 命令模式的变体

### 6.1 简单命令模式

对于不需要撤销功能的简单场景：

```python
from abc import ABC, abstractmethod

class SimpleCommand(ABC):
    @abstractmethod
    def execute(self):
        pass

class PrintCommand(SimpleCommand):
    def __init__(self, message):
        self.message = message
    
    def execute(self):
        print(self.message)

class CalculatorCommand(SimpleCommand):
    def __init__(self, a, b, operation):
        self.a = a
        self.b = b
        self.operation = operation
    
    def execute(self):
        if self.operation == "add":
            result = self.a + self.b
        elif self.operation == "subtract":
            result = self.a - self.b
        elif self.operation == "multiply":
            result = self.a * self.b
        elif self.operation == "divide":
            result = self.a / self.b if self.b != 0 else "错误: 除零"
        else:
            result = "未知操作"
        
        print(f"{self.a} {self.operation} {self.b} = {result}")

# 命令执行器
class CommandExecutor:
    def __init__(self):
        self.commands = []
    
    def add_command(self, command):
        self.commands.append(command)
    
    def execute_all(self):
        for command in self.commands:
            command.execute()

# 使用简单命令模式
executor = CommandExecutor()
executor.add_command(PrintCommand("开始执行命令"))
executor.add_command(CalculatorCommand(10, 5, "add"))
executor.add_command(CalculatorCommand(10, 5, "subtract"))
executor.add_command(CalculatorCommand(10, 5, "multiply"))
executor.add_command(CalculatorCommand(10, 5, "divide"))
executor.add_command(PrintCommand("命令执行完成"))

executor.execute_all()
```

## 7. 命令模式与相关模式的比较

### 7.1 命令模式 vs 策略模式

- **命令模式**: 封装操作和参数，支持撤销、队列等功能
- **策略模式**: 封装算法，客户端选择不同的策略

### 7.2 命令模式 vs 备忘录模式

- **命令模式**: 封装操作，支持撤销
- **备忘录模式**: 保存对象状态，用于恢复

### 7.3 命令模式 vs 责任链模式

- **命令模式**: 封装请求，支持排队、撤销
- **责任链模式**: 多个处理器依次处理请求

## 8. 最佳实践

### 8.1 何时使用命令模式

1. **需要撤销操作**: 需要支持操作的撤销和重做时
2. **需要命令队列**: 需要将操作排队、延迟执行或记录日志时
3. **需要参数化对象**: 需要用不同的请求参数化对象时
4. **需要支持事务**: 需要支持事务性操作时

### 8.2 实现建议

1. **保持命令简单**: 每个命令应该只执行一个明确的操作
2. **考虑性能**: 对于频繁执行的简单操作，命令模式可能带来性能开销
3. **支持复合命令**: 考虑实现宏命令来组合多个命令
4. **处理异常**: 妥善处理命令执行过程中的异常
5. **考虑内存使用**: 大量命令对象可能占用较多内存

## 9. 总结

命令模式是一种强大的行为型模式，它通过将请求封装为对象，实现了请求发送者和接收者的解耦。这种模式特别适用于以下情况：

- 需要支持操作的撤销和重做
- 需要将操作排队或记录操作日志
- 需要用不同的请求参数化对象
- 需要支持事务性操作

通过合理使用命令模式，我们可以创建灵活、可扩展的系统，同时支持高级功能如撤销、重做、事务等。