# 第17章：中介者模式 (Mediator Pattern)

## 概念解析

### 什么是中介者模式？
中介者模式用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

### 模式结构
- **Mediator（中介者）**：定义各个同事对象交互的接口
- **ConcreteMediator（具体中介者）**：实现中介者接口，协调各个同事对象
- **Colleague（同事）**：定义同事类的接口，维护一个指向中介者对象的引用
- **ConcreteColleague（具体同事）**：实现同事类接口，每个同事类都知道它的中介者对象

## 应用场景
- 一组对象以定义良好但是复杂的方式进行通信
- 想定制一个分布在多个类中的行为，而又不想生成太多的子类
- 对象间的引用关系复杂，难以理解

## 代码示例

```python
from abc import ABC, abstractmethod
from typing import List, Dict

# 中介者接口
class Mediator(ABC):
    @abstractmethod
    def send_message(self, message: str, sender: 'Colleague'):
        pass

# 同事类接口
class Colleague(ABC):
    def __init__(self, mediator: Mediator, name: str):
        self.mediator = mediator
        self.name = name
    
    @abstractmethod
    def send(self, message: str):
        pass
    
    @abstractmethod
    def receive(self, message: str, sender: str):
        pass

# 具体同事类 - 用户
class User(Colleague):
    def send(self, message: str):
        print(f"{self.name} 发送消息: {message}")
        self.mediator.send_message(message, self)
    
    def receive(self, message: str, sender: str):
        print(f"{self.name} 收到来自 {sender} 的消息: {message}")

# 具体同事类 - 聊天机器人
class ChatBot(Colleague):
    def __init__(self, mediator: Mediator, name: str):
        super().__init__(mediator, name)
        self.responses = {
            "你好": "你好！我是聊天机器人，有什么可以帮你的？",
            "时间": "当前时间是模拟时间",
            "帮助": "我可以回答一些简单问题，试试问'你好'或'时间'"
        }
    
    def send(self, message: str):
        # 聊天机器人不主动发送消息
        pass
    
    def receive(self, message: str, sender: str):
        response = self.responses.get(message, "抱歉，我不理解这个问题")
        print(f"{self.name} 回复 {sender}: {response}")
        # 机器人自动回复
        self.mediator.send_message(response, self)

# 具体中介者 - 聊天室
class ChatRoom(Mediator):
    def __init__(self):
        self.users: Dict[str, Colleague] = {}
    
    def add_user(self, user: Colleague):
        self.users[user.name] = user
    
    def send_message(self, message: str, sender: Colleague):
        for name, user in self.users.items():
            if user != sender:  # 不发送给自己
                user.receive(message, sender.name)

# 客户端代码
def main():
    # 创建中介者（聊天室）
    chat_room = ChatRoom()
    
    # 创建同事对象（用户和机器人）
    alice = User(chat_room, "Alice")
    bob = User(chat_room, "Bob")
    chatbot = ChatBot(chat_room, "ChatBot")
    
    # 将用户添加到聊天室
    chat_room.add_user(alice)
    chat_room.add_user(bob)
    chat_room.add_user(chatbot)
    
    # 用户间通信
    print("=== 用户间通信 ===")
    alice.send("大家好，我是Alice！")
    bob.send("你好Alice，我是Bob！")
    
    print("\n=== 与机器人交互 ===")
    alice.send("你好")
    bob.send("时间")
    alice.send("这是什么？")

if __name__ == "__main__":
    main()
```

## 实际应用案例：飞机交通控制系统

```python
# 飞机交通控制系统中介者模式实现
class AirTrafficControl(Mediator):
    def __init__(self):
        self.aircrafts: Dict[str, 'Aircraft'] = {}
        self.runways: List['Runway'] = []
    
    def register_aircraft(self, aircraft: 'Aircraft'):
        self.aircrafts[aircraft.flight_number] = aircraft
    
    def register_runway(self, runway: 'Runway'):
        self.runways.append(runway)
    
    def request_landing(self, aircraft: 'Aircraft') -> bool:
        """处理飞机着陆请求"""
        print(f"ATC: 收到 {aircraft.flight_number} 的着陆请求")
        
        # 检查跑道可用性
        available_runway = None
        for runway in self.runways:
            if not runway.is_occupied:
                available_runway = runway
                break
        
        if available_runway:
            available_runway.occupy()
            print(f"ATC: 批准 {aircraft.flight_number} 在跑道 {available_runway.number} 着陆")
            return True
        else:
            print(f"ATC: 拒绝 {aircraft.flight_number} 的着陆请求，所有跑道繁忙")
            return False
    
    def notify_landing_complete(self, aircraft: 'Aircraft', runway: 'Runway'):
        """通知着陆完成"""
        runway.vacate()
        print(f"ATC: {aircraft.flight_number} 已在跑道 {runway.number} 完成着陆")

class Aircraft(Colleague):
    def __init__(self, mediator: Mediator, flight_number: str):
        super().__init__(mediator, flight_number)
        self.flight_number = flight_number
        self.current_runway = None
    
    def request_landing(self):
        """请求着陆"""
        print(f"{self.flight_number}: 请求着陆")
        return self.mediator.request_landing(self)
    
    def land(self, runway):
        """执行着陆"""
        self.current_runway = runway
        print(f"{self.flight_number}: 正在跑道 {runway.number} 着陆")
        # 模拟着陆过程
        print(f"{self.flight_number}: 着陆完成")
        self.mediator.notify_landing_complete(self, runway)
    
    def send(self, message: str):
        pass
    
    def receive(self, message: str, sender: str):
        pass

class Runway:
    def __init__(self, number: int):
        self.number = number
        self.is_occupied = False
    
    def occupy(self):
        self.is_occupied = True
    
    def vacate(self):
        self.is_occupied = False

# 使用示例
def air_traffic_example():
    # 创建交通控制中心
    atc = AirTrafficControl()
    
    # 创建跑道
    runway1 = Runway(1)
    runway2 = Runway(2)
    atc.register_runway(runway1)
    atc.register_runway(runway2)
    
    # 创建飞机
    flight1 = Aircraft(atc, "CA123")
    flight2 = Aircraft(atc, "UA456")
    flight3 = Aircraft(atc, "DL789")
    
    atc.register_aircraft(flight1)
    atc.register_aircraft(flight2)
    atc.register_aircraft(flight3)
    
    # 模拟着陆请求
    print("=== 飞机着陆模拟 ===")
    
    if flight1.request_landing():
        flight1.land(runway1)
    
    if flight2.request_landing():
        flight2.land(runway2)
    
    # 第三个飞机请求着陆（此时跑道已满）
    if flight3.request_landing():
        flight3.land(runway1)  # 这个不会执行
    else:
        print(f"{flight3.flight_number}: 等待可用跑道")

if __name__ == "__main__":
    air_traffic_example()
```

## GUI应用案例：对话框组件交互

```python
# GUI对话框中的中介者模式
class DialogMediator(Mediator):
    def __init__(self):
        self.components: Dict[str, 'Component'] = {}
    
    def register_component(self, name: str, component: 'Component'):
        self.components[name] = component
    
    def send_message(self, message: str, sender: 'Component'):
        """处理组件间的交互"""
        if sender.name == "username_input" and message == "text_changed":
            # 用户名输入框内容变化时，检查并更新状态
            username = self.components["username_input"].get_text()
            if len(username) < 3:
                self.components["username_error"].set_text("用户名至少3个字符")
                self.components["submit_button"].set_enabled(False)
            else:
                self.components["username_error"].set_text("")
                self._check_submit_availability()
        
        elif sender.name == "password_input" and message == "text_changed":
            # 密码输入框内容变化时，检查并更新状态
            password = self.components["password_input"].get_text()
            if len(password) < 6:
                self.components["password_error"].set_text("密码至少6个字符")
                self.components["submit_button"].set_enabled(False)
            else:
                self.components["password_error"].set_text("")
                self._check_submit_availability()
    
    def _check_submit_availability(self):
        """检查是否可以提交"""
        username = self.components["username_input"].get_text()
        password = self.components["password_input"].get_text()
        
        if len(username) >= 3 and len(password) >= 6:
            self.components["submit_button"].set_enabled(True)
        else:
            self.components["submit_button"].set_enabled(False)

class Component(Colleague):
    def __init__(self, mediator: Mediator, name: str):
        super().__init__(mediator, name)
        self.name = name
    
    def send(self, message: str):
        self.mediator.send_message(message, self)
    
    def receive(self, message: str, sender: str):
        pass

class InputField(Component):
    def __init__(self, mediator: Mediator, name: str):
        super().__init__(mediator, name)
        self.text = ""
    
    def set_text(self, text: str):
        self.text = text
        self.send("text_changed")
    
    def get_text(self) -> str:
        return self.text

class Label(Component):
    def __init__(self, mediator: Mediator, name: str):
        super().__init__(mediator, name)
        self.text = ""
    
    def set_text(self, text: str):
        self.text = text
        print(f"{self.name}: {text}")

class Button(Component):
    def __init__(self, mediator: Mediator, name: str):
        super().__init__(mediator, name)
        self.enabled = False
    
    def set_enabled(self, enabled: bool):
        self.enabled = enabled
        status = "启用" if enabled else "禁用"
        print(f"{self.name}: {status}")
    
    def click(self):
        if self.enabled:
            print(f"{self.name}: 按钮被点击")

# 使用示例
def dialog_example():
    mediator = DialogMediator()
    
    # 创建对话框组件
    username_input = InputField(mediator, "username_input")
    password_input = InputField(mediator, "password_input")
    username_error = Label(mediator, "username_error")
    password_error = Label(mediator, "password_error")
    submit_button = Button(mediator, "submit_button")
    
    # 注册组件到中介者
    mediator.register_component("username_input", username_input)
    mediator.register_component("password_input", password_input)
    mediator.register_component("username_error", username_error)
    mediator.register_component("password_error", password_error)
    mediator.register_component("submit_button", submit_button)
    
    # 模拟用户输入
    print("=== 对话框交互模拟 ===")
    username_input.set_text("ab")  # 用户名太短
    password_input.set_text("12345")  # 密码太短
    
    username_input.set_text("abc")  # 用户名符合要求
    password_input.set_text("123456")  # 密码符合要求
    
    submit_button.click()  # 可以提交了

if __name__ == "__main__":
    dialog_example()
```

## 最佳实践

### 优点
- 减少了对象间的耦合
- 将控制逻辑集中化
- 简化了对象间的交互
- 提高了系统的可维护性

### 缺点
- 中介者可能变得过于复杂
- 如果设计不当，中介者可能成为上帝对象

### 适用场景
- 对象间存在复杂的引用关系
- 想通过一个中间类来封装多个类中的行为
- 想在多个类间共享行为，而又不想生成太多子类

### 注意事项
- 避免中介者变得过于庞大
- 合理划分中介者的职责
- 考虑使用事件驱动架构作为替代方案

## 扩展应用

中介者模式还可以应用于：
- 消息队列系统
- 事件总线
- 微服务架构中的API网关
- 工作流引擎
- 游戏中的事件系统