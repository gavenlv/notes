# 第15章：解释器模式 (Interpreter Pattern)

## 概念解析

### 什么是解释器模式？
解释器模式定义了一种语言的文法，并且建立一个解释器来解释该语言中的句子。它属于行为型模式，主要用于构建一个简单的语言解释器。

### 模式结构
- **AbstractExpression（抽象表达式）**：声明一个抽象的解释操作
- **TerminalExpression（终结符表达式）**：实现与文法中的终结符相关联的解释操作
- **NonterminalExpression（非终结符表达式）**：为文法中的规则提供解释操作的实现
- **Context（上下文）**：包含解释器之外的一些全局信息
- **Client（客户端）**：构建表示该文法定义的语言中一个特定句子的抽象语法树

## 应用场景
- 当有一个语言需要解释执行，并且可将该语言中的句子表示为一个抽象语法树时
- 一些重复出现的问题可以用一种简单的语言来表达
- 一个简单语法需要解释的场景

## 代码示例

```python
from abc import ABC, abstractmethod
from typing import Dict

# 抽象表达式类
class Expression(ABC):
    @abstractmethod
    def interpret(self, context: Dict[str, int]) -> int:
        pass

# 终结符表达式 - 数字
class Number(Expression):
    def __init__(self, value: int):
        self.value = value
    
    def interpret(self, context: Dict[str, int]) -> int:
        return self.value

# 终结符表达式 - 变量
class Variable(Expression):
    def __init__(self, name: str):
        self.name = name
    
    def interpret(self, context: Dict[str, int]) -> int:
        return context.get(self.name, 0)

# 非终结符表达式 - 加法
class Add(Expression):
    def __init__(self, left: Expression, right: Expression):
        self.left = left
        self.right = right
    
    def interpret(self, context: Dict[str, int]) -> int:
        return self.left.interpret(context) + self.right.interpret(context)

# 非终结符表达式 - 减法
class Subtract(Expression):
    def __init__(self, left: Expression, right: Expression):
        self.left = left
        self.right = right
    
    def interpret(self, context: Dict[str, int]) -> int:
        return self.left.interpret(context) - self.right.interpret(context)

# 非终结符表达式 - 乘法
class Multiply(Expression):
    def __init__(self, left: Expression, right: Expression):
        self.left = left
        self.right = right
    
    def interpret(self, context: Dict[str, int]) -> int:
        return self.left.interpret(context) * self.right.interpret(context)

# 非终结符表达式 - 除法
class Divide(Expression):
    def __init__(self, left: Expression, right: Expression):
        self.left = left
        self.right = right
    
    def interpret(self, context: Dict[str, int]) -> int:
        right_value = self.right.interpret(context)
        if right_value == 0:
            raise ValueError("Division by zero")
        return self.left.interpret(context) // right_value

# 表达式解析器
class ExpressionParser:
    def parse(self, expression: str) -> Expression:
        tokens = expression.split()
        return self._parse_expression(tokens)
    
    def _parse_expression(self, tokens: list) -> Expression:
        if len(tokens) == 1:
            token = tokens[0]
            if token.isdigit():
                return Number(int(token))
            else:
                return Variable(token)
        
        # 处理括号表达式
        if tokens[0] == '(' and tokens[-1] == ')':
            return self._parse_expression(tokens[1:-1])
        
        # 寻找操作符（考虑优先级）
        operator_positions = []
        bracket_count = 0
        
        for i, token in enumerate(tokens):
            if token == '(':
                bracket_count += 1
            elif token == ')':
                bracket_count -= 1
            elif bracket_count == 0 and token in ['+', '-', '*', '/']:
                operator_positions.append((i, token))
        
        # 按优先级处理
        for operator in ['+', '-', '*', '/']:
            for pos, op in operator_positions:
                if op == operator:
                    left = self._parse_expression(tokens[:pos])
                    right = self._parse_expression(tokens[pos+1:])
                    
                    if operator == '+':
                        return Add(left, right)
                    elif operator == '-':
                        return Subtract(left, right)
                    elif operator == '*':
                        return Multiply(left, right)
                    elif operator == '/':
                        return Divide(left, right)
        
        raise ValueError("Invalid expression")

# 客户端代码
def main():
    # 创建上下文（变量值）
    context = {'x': 10, 'y': 5, 'z': 2}
    
    # 测试简单表达式
    parser = ExpressionParser()
    
    # 测试数字表达式
    expr1 = parser.parse("10")
    print(f"10 = {expr1.interpret(context)}")
    
    # 测试变量表达式
    expr2 = parser.parse("x")
    print(f"x = {expr2.interpret(context)}")
    
    # 测试加法
    expr3 = parser.parse("x + y")
    print(f"x + y = {expr3.interpret(context)}")
    
    # 测试复杂表达式
    expr4 = parser.parse("(x + y) * z")
    print(f"(x + y) * z = {expr4.interpret(context)}")
    
    # 测试嵌套表达式
    expr5 = parser.parse("((x + y) * z) / (y - 1)")
    print(f"((x + y) * z) / (y - 1) = {expr5.interpret(context)}")
    
    # 测试带括号的表达式
    expr6 = parser.parse("(x * (y + z)) - 5")
    print(f"(x * (y + z)) - 5 = {expr6.interpret(context)}")

if __name__ == "__main__":
    main()
```

## 实际应用案例：SQL查询条件解释器

```python
# SQL条件解释器实现
class SQLCondition(ABC):
    @abstractmethod
    def interpret(self, record: Dict) -> bool:
        pass

class EqualCondition(SQLCondition):
    def __init__(self, field: str, value: any):
        self.field = field
        self.value = value
    
    def interpret(self, record: Dict) -> bool:
        return record.get(self.field) == self.value

class GreaterThanCondition(SQLCondition):
    def __init__(self, field: str, value: any):
        self.field = field
        self.value = value
    
    def interpret(self, record: Dict) -> bool:
        return record.get(self.field) > self.value

class AndCondition(SQLCondition):
    def __init__(self, left: SQLCondition, right: SQLCondition):
        self.left = left
        self.right = right
    
    def interpret(self, record: Dict) -> bool:
        return self.left.interpret(record) and self.right.interpret(record)

class OrCondition(SQLCondition):
    def __init__(self, left: SQLCondition, right: SQLCondition):
        self.left = left
        self.right = right
    
    def interpret(self, record: Dict) -> bool:
        return self.left.interpret(record) or self.right.interpret(record)

class SQLQuery:
    def __init__(self, condition: SQLCondition):
        self.condition = condition
    
    def execute(self, records: List[Dict]) -> List[Dict]:
        return [record for record in records if self.condition.interpret(record)]

# 使用示例
def sql_example():
    # 模拟数据
    records = [
        {'id': 1, 'name': 'Alice', 'age': 25, 'salary': 50000},
        {'id': 2, 'name': 'Bob', 'age': 30, 'salary': 60000},
        {'id': 3, 'name': 'Charlie', 'age': 35, 'salary': 70000},
        {'id': 4, 'name': 'David', 'age': 28, 'salary': 55000},
    ]
    
    # 构建查询条件：age > 25 AND salary > 55000
    condition = AndCondition(
        GreaterThanCondition('age', 25),
        GreaterThanCondition('salary', 55000)
    )
    
    query = SQLQuery(condition)
    results = query.execute(records)
    
    print("查询结果：")
    for record in results:
        print(record)

if __name__ == "__main__":
    sql_example()
```

## 最佳实践

### 优点
- 易于改变和扩展文法
- 实现文法比较容易
- 易于实现简单语言

### 缺点
- 对于复杂文法难以维护
- 执行效率较低
- 增加了类的数量

### 适用场景
- 简单的语法需要解释的场景
- 效率不是关键问题的场景
- 需要动态执行简单脚本的场景

### 注意事项
- 避免用于复杂的文法解释
- 考虑使用现成的解析器工具（如PLY、ANTLR）
- 对于性能要求高的场景，考虑其他方案

## 扩展应用

解释器模式还可以应用于：
- 正则表达式引擎
- 模板引擎
- 规则引擎
- 配置语言解释器
- 领域特定语言（DSL）