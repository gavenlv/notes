# 工厂方法模式

## 章节概述

本章将详细介绍工厂方法模式(Factory Method Pattern)，这是创建型设计模式中最常用的模式之一。通过本章的学习，你将理解工厂方法模式的原理、实现方式、应用场景以及优缺点，并掌握在Python中实现工厂方法模式的各种方法。

## 工厂方法模式的概念

### 定义

工厂方法模式定义了一个创建对象的接口，但让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

### 为什么需要工厂方法模式

1. **解耦**: 将对象的创建和使用分离，降低系统的耦合度
2. **扩展性**: 增加新产品时，只需添加具体的产品类和对应的工厂类
3. **封装性**: 隐藏了产品类的实现细节，对调用者透明
4. **灵活性**: 符合开闭原则，对扩展开放，对修改关闭

### 生活中的例子

- 汽车工厂生产不同品牌的汽车
- 面包店制作不同类型的面包
- 服装厂生产不同款式的服装

## 工厂方法模式的结构

工厂方法模式包含以下角色：

1. **抽象产品(Product)**: 定义产品的接口
2. **具体产品(ConcreteProduct)**: 实现抽象产品接口的具体产品类
3. **抽象工厂(Creator)**: 声明工厂方法，返回一个产品对象
4. **具体工厂(ConcreteCreator)**: 实现工厂方法，返回具体产品实例

### 类图结构

```
+----------------+       +-----------------+
|    Product     |<------| ConcreteProduct |
+----------------+       +-----------------+
| +operation()   |       | +operation()    |
+----------------+       +-----------------+
        ^                        ^
        |                        |
+----------------+       +-----------------+
|    Creator     |<------| ConcreteCreator |
+----------------+       +-----------------+
| +factoryMethod()|      | +factoryMethod()|
+----------------+       +-----------------+
```

## 工厂方法模式的实现

### 1. 基本实现

```python
from abc import ABC, abstractmethod

# 抽象产品
class Product(ABC):
    @abstractmethod
    def operation(self):
        pass

# 具体产品A
class ConcreteProductA(Product):
    def operation(self):
        return "具体产品A的操作"

# 具体产品B
class ConcreteProductB(Product):
    def operation(self):
        return "具体产品B的操作"

# 抽象工厂
class Creator(ABC):
    @abstractmethod
    def factory_method(self):
        pass
    
    def some_operation(self):
        product = self.factory_method()
        return f"工厂操作: {product.operation()}"

# 具体工厂A
class ConcreteCreatorA(Creator):
    def factory_method(self):
        return ConcreteProductA()

# 具体工厂B
class ConcreteCreatorB(Creator):
    def factory_method(self):
        return ConcreteProductB()

# 客户端代码
def client_code(creator):
    print(creator.some_operation())

# 测试
creator_a = ConcreteCreatorA()
client_code(creator_a)  # 输出: 工厂操作: 具体产品A的操作

creator_b = ConcreteCreatorB()
client_code(creator_b)  # 输出: 工厂操作: 具体产品B的操作
```

### 2. 简单的工厂方法实现

```python
# 动物产品
class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "汪汪汪"

class Cat(Animal):
    def speak(self):
        return "喵喵喵"

# 动物工厂
class AnimalFactory:
    @staticmethod
    def create_animal(animal_type):
        if animal_type == "dog":
            return Dog()
        elif animal_type == "cat":
            return Cat()
        else:
            raise ValueError(f"未知的动物类型: {animal_type}")

# 测试
factory = AnimalFactory()
dog = factory.create_animal("dog")
cat = factory.create_animal("cat")

print(dog.speak())  # 输出: 汪汪汪
print(cat.speak())  # 输出: 喵喵喵
```

### 3. 使用注册表的工厂方法

```python
class ProductRegistry:
    _registry = {}
    
    @classmethod
    def register(cls, product_type, product_class):
        cls._registry[product_type] = product_class
    
    @classmethod
    def create(cls, product_type, *args, **kwargs):
        if product_type not in cls._registry:
            raise ValueError(f"未注册的产品类型: {product_type}")
        return cls._registry[product_type](*args, **kwargs)

# 产品类
class ProductA:
    def __init__(self, name):
        self.name = name
    
    def __str__(self):
        return f"产品A: {self.name}"

class ProductB:
    def __init__(self, name):
        self.name = name
    
    def __str__(self):
        return f"产品B: {self.name}"

# 注册产品
ProductRegistry.register("A", ProductA)
ProductRegistry.register("B", ProductB)

# 使用注册表创建产品
product_a = ProductRegistry.create("A", "产品A实例")
product_b = ProductRegistry.create("B", "产品B实例")

print(product_a)  # 输出: 产品A: 产品A实例
print(product_b)  # 输出: 产品B: 产品B实例
```

## 工厂方法模式的应用场景

### 1. 日志记录器工厂

```python
from abc import ABC, abstractmethod
import datetime

# 抽象日志记录器
class Logger(ABC):
    @abstractmethod
    def log(self, message):
        pass

# 控制台日志记录器
class ConsoleLogger(Logger):
    def log(self, message):
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{timestamp}] CONSOLE: {message}")

# 文件日志记录器
class FileLogger(Logger):
    def __init__(self, filename):
        self.filename = filename
    
    def log(self, message):
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        with open(self.filename, 'a', encoding='utf-8') as f:
            f.write(f"[{timestamp}] FILE: {message}\n")

# 数据库日志记录器
class DatabaseLogger(Logger):
    def __init__(self, db_connection):
        self.db_connection = db_connection
    
    def log(self, message):
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        # 实际应用中会执行数据库插入操作
        print(f"[{timestamp}] DATABASE: {message} (保存到数据库 {self.db_connection})")

# 抽象日志工厂
class LoggerFactory(ABC):
    @abstractmethod
    def create_logger(self):
        pass

# 具体控制台日志工厂
class ConsoleLoggerFactory(LoggerFactory):
    def create_logger(self):
        return ConsoleLogger()

# 具体文件日志工厂
class FileLoggerFactory(LoggerFactory):
    def __init__(self, filename):
        self.filename = filename
    
    def create_logger(self):
        return FileLogger(self.filename)

# 具体数据库日志工厂
class DatabaseLoggerFactory(LoggerFactory):
    def __init__(self, db_connection):
        self.db_connection = db_connection
    
    def create_logger(self):
        return DatabaseLogger(self.db_connection)

# 客户端代码
def client_code(logger_factory):
    logger = logger_factory.create_logger()
    logger.log("这是一条测试日志消息")

# 测试
print("控制台日志:")
console_factory = ConsoleLoggerFactory()
client_code(console_factory)

print("\n文件日志:")
file_factory = FileLoggerFactory("app.log")
client_code(file_factory)

print("\n数据库日志:")
db_factory = DatabaseLoggerFactory("localhost:3306")
client_code(db_factory)

# 清理文件
import os
if os.path.exists("app.log"):
    os.remove("app.log")
```

### 2. 支付处理工厂

```python
from abc import ABC, abstractmethod

# 抽象支付处理器
class PaymentProcessor(ABC):
    @abstractmethod
    def process_payment(self, amount):
        pass

# 信用卡支付处理器
class CreditCardProcessor(PaymentProcessor):
    def __init__(self, card_number, cvv):
        self.card_number = card_number
        self.cvv = cvv
    
    def process_payment(self, amount):
        print(f"使用信用卡 {self.card_number} 支付 ¥{amount:.2f}")
        return {"status": "success", "transaction_id": f"CC_{hash(self.card_number)}"}

# 支付宝支付处理器
class AlipayProcessor(PaymentProcessor):
    def __init__(self, account_id):
        self.account_id = account_id
    
    def process_payment(self, amount):
        print(f"使用支付宝账号 {self.account_id} 支付 ¥{amount:.2f}")
        return {"status": "success", "transaction_id": f"ALI_{hash(self.account_id)}"}

# 微信支付处理器
class WeChatPayProcessor(PaymentProcessor):
    def __init__(self, openid):
        self.openid = openid
    
    def process_payment(self, amount):
        print(f"使用微信账号 {self.openid} 支付 ¥{amount:.2f}")
        return {"status": "success", "transaction_id": f"WX_{hash(self.openid)}"}

# 支付工厂
class PaymentProcessorFactory:
    @staticmethod
    def create_processor(payment_type, **kwargs):
        if payment_type == "credit_card":
            return CreditCardProcessor(kwargs.get("card_number"), kwargs.get("cvv"))
        elif payment_type == "alipay":
            return AlipayProcessor(kwargs.get("account_id"))
        elif payment_type == "wechat":
            return WeChatPayProcessor(kwargs.get("openid"))
        else:
            raise ValueError(f"不支持的支付方式: {payment_type}")

# 测试
payment_configs = [
    {"type": "credit_card", "card_number": "1234-5678-9012-3456", "cvv": "123"},
    {"type": "alipay", "account_id": "user@example.com"},
    {"type": "wechat", "openid": "ox123456789"}
]

for config in payment_configs:
    payment_type = config["type"]
    params = {k: v for k, v in config.items() if k != "type"}
    
    processor = PaymentProcessorFactory.create_processor(payment_type, **params)
    result = processor.process_payment(100.00)
    print(f"支付结果: {result}")
```

### 3. 数据库连接工厂

```python
from abc import ABC, abstractmethod
import sqlite3
import json

# 抽象数据库连接
class DatabaseConnection(ABC):
    @abstractmethod
    def connect(self):
        pass
    
    @abstractmethod
    def execute_query(self, query):
        pass
    
    @abstractmethod
    def close(self):
        pass

# SQLite连接
class SQLiteConnection(DatabaseConnection):
    def __init__(self, db_path):
        self.db_path = db_path
        self.connection = None
    
    def connect(self):
        self.connection = sqlite3.connect(self.db_path)
        print(f"已连接到SQLite数据库: {self.db_path}")
    
    def execute_query(self, query):
        if self.connection:
            cursor = self.connection.cursor()
            result = cursor.execute(query).fetchall()
            return result
        return None
    
    def close(self):
        if self.connection:
            self.connection.close()
            print(f"已关闭SQLite数据库连接: {self.db_path}")

# 模拟MySQL连接
class MySQLConnection(DatabaseConnection):
    def __init__(self, host, port, database, username, password):
        self.host = host
        self.port = port
        self.database = database
        self.username = username
        self.password = password
        self.connection = None
    
    def connect(self):
        # 实际应用中会使用真实的MySQL连接
        self.connection = f"模拟连接到MySQL: {self.username}@{self.host}:{self.port}/{self.database}"
        print(self.connection)
    
    def execute_query(self, query):
        if self.connection:
            # 模拟查询结果
            return [("模拟", "MySQL", "查询", "结果")]
        return None
    
    def close(self):
        if self.connection:
            self.connection = None
            print(f"已关闭MySQL数据库连接: {self.database}")

# 数据库连接工厂
class DatabaseConnectionFactory:
    @staticmethod
    def create_connection(db_type, **kwargs):
        if db_type == "sqlite":
            return SQLiteConnection(kwargs.get("db_path"))
        elif db_type == "mysql":
            return MySQLConnection(
                kwargs.get("host"),
                kwargs.get("port"),
                kwargs.get("database"),
                kwargs.get("username"),
                kwargs.get("password")
            )
        else:
            raise ValueError(f"不支持的数据库类型: {db_type}")

# 测试
db_configs = [
    {"type": "sqlite", "db_path": ":memory:"},
    {"type": "mysql", "host": "localhost", "port": 3306, "database": "test", "username": "root", "password": "123456"}
]

for config in db_configs:
    db_type = config["type"]
    params = {k: v for k, v in config.items() if k != "type"}
    
    db = DatabaseConnectionFactory.create_connection(db_type, **params)
    db.connect()
    result = db.execute_query("SELECT * FROM users")
    print(f"查询结果: {result}")
    db.close()
```

## 工厂方法模式的变体

### 1. 参数化工厂方法

```python
class ShapeFactory:
    @staticmethod
    def create_shape(shape_type, *args):
        if shape_type == "circle":
            return Circle(*args)
        elif shape_type == "rectangle":
            return Rectangle(*args)
        elif shape_type == "triangle":
            return Triangle(*args)
        else:
            raise ValueError(f"不支持的形状类型: {shape_type}")

class Shape:
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14 * self.radius ** 2
    
    def __str__(self):
        return f"圆形(半径={self.radius})"

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def __str__(self):
        return f"矩形(宽={self.width}, 高={self.height})"

class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height
    
    def area(self):
        return 0.5 * self.base * self.height
    
    def __str__(self):
        return f"三角形(底={self.base}, 高={self.height})"

# 测试
shapes = [
    ShapeFactory.create_shape("circle", 5),
    ShapeFactory.create_shape("rectangle", 4, 6),
    ShapeFactory.create_shape("triangle", 3, 4)
]

for shape in shapes:
    print(f"{shape}的面积: {shape.area()}")
```

### 2. 使用类注册的工厂

```python
class ServiceFactory:
    _services = {}
    
    @classmethod
    def register(cls, service_name, service_class):
        cls._services[service_name] = service_class
    
    @classmethod
    def create(cls, service_name, *args, **kwargs):
        if service_name not in cls._services:
            raise ValueError(f"未注册的服务: {service_name}")
        return cls._services[service_name](*args, **kwargs)
    
    @classmethod
    def list_services(cls):
        return list(cls._services.keys())

# 定义服务类
class UserService:
    def __init__(self, db_connection):
        self.db_connection = db_connection
    
    def get_user(self, user_id):
        return f"从数据库{self.db_connection}获取用户{user_id}"

class NotificationService:
    def __init__(self, email_provider):
        self.email_provider = email_provider
    
    def send_notification(self, user, message):
        return f"通过{self.email_provider}向用户{user}发送通知: {message}"

class CacheService:
    def __init__(self, cache_type):
        self.cache_type = cache_type
    
    def cache_data(self, key, value):
        return f"将数据{key}:{value}缓存到{self.cache_type}"

# 注册服务
ServiceFactory.register("user", UserService)
ServiceFactory.register("notification", NotificationService)
ServiceFactory.register("cache", CacheService)

# 使用工厂创建服务
user_service = ServiceFactory.create("user", "localhost:3306")
notification_service = ServiceFactory.create("notification", "Gmail")
cache_service = ServiceFactory.create("cache", "Redis")

# 测试服务
print(user_service.get_user("123"))
print(notification_service.send_notification("张三", "欢迎注册"))
print(cache_service.cache_data("session:123", "user_data"))

print(f"已注册的服务: {ServiceFactory.list_services()}")
```

## 工厂方法模式的优缺点

### 优点

1. **解耦**: 将对象的创建和使用分离，降低了系统的耦合度
2. **扩展性**: 符合开闭原则，增加新产品时只需添加相应的产品类和工厂类
3. **封装性**: 隐藏了产品类的实现细节，对调用者透明
4. **灵活性**: 客户端只需要知道具体工厂的名称，无需知道产品创建的细节
5. **代码复用**: 可以在多个地方使用相同的工厂方法创建对象

### 缺点

1. **类数量增加**: 每增加一个产品，就需要增加一个具体产品类和对应的具体工厂类
2. **复杂度增加**: 系统的复杂度在一定程度上增加了
3. **抽象层**: 引入了抽象层，增加了理解难度

## 工厂方法模式与其他模式的关系

### 1. 与抽象工厂模式

工厂方法模式是抽象工厂模式的简化版本。工厂方法模式只生产一种产品，而抽象工厂模式可以生产多种产品。

### 2. 与单例模式

工厂方法可以返回单例实例。

### 3. 与原型模式

工厂方法可以使用原型模式创建对象，尤其是在创建对象的成本较高时。

### 4. 与策略模式

工厂方法可以用来创建策略对象。

## 最佳实践

### 1. 合理选择工厂方法

不是所有需要创建对象的地方都需要使用工厂方法。当对象的创建逻辑比较复杂，或者需要根据条件创建不同对象时，才考虑使用工厂方法。

### 2. 保持工厂方法的简单性

工厂方法的职责应该是创建对象，不应该包含过多的业务逻辑。

### 3. 考虑使用依赖注入

在某些情况下，使用依赖注入可能是比工厂方法更好的选择。

### 4. 考虑使用配置文件

可以使用配置文件来指定要创建的产品类型，使系统更加灵活。

## Python中的特殊考虑

### 1. 动态语言的特性

Python的动态特性使得工厂方法的实现更加灵活，但也更容易出错。

### 2. 使用反射

可以使用反射来动态加载类和创建对象，使工厂更加灵活。

```python
def create_class_by_name(class_name, module_name, *args, **kwargs):
    module = __import__(module_name)
    class_ = getattr(module, class_name)
    return class_(*args, **kwargs)

# 示例使用
# circle = create_class_by_name("Circle", "shapes", 5)
```

### 3. 使用`__dict__`

可以使用字典来存储和获取类，实现简单的注册表功能。

## 总结

工厂方法模式是创建型设计模式中最常用的模式之一。它定义了一个创建对象的接口，但让子类决定实例化哪一个类。这种模式使一个类的实例化延迟到其子类。

工厂方法模式的主要优点是：
- 将对象的创建和使用分离，降低系统的耦合度
- 符合开闭原则，对扩展开放，对修改关闭
- 隐藏了产品类的实现细节，对调用者透明

在Python中，我们可以利用动态语言的特性，使工厂方法的实现更加灵活。在实际应用中，应该根据具体需求选择合适的实现方式。

在下一章中，我们将学习建造者模式，它是另一个创建型设计模式，适用于创建复杂对象。