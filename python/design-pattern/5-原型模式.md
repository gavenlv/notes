# 原型模式

## 章节概述

本章将详细介绍原型模式(Prototype Pattern)，这是一种创建型设计模式，通过复制现有对象来创建新对象。通过本章的学习，你将理解原型模式的原理、实现方式、应用场景以及优缺点，并掌握在Python中实现原型模式的各种方法。

## 原型模式的概念

### 定义

原型模式使用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象。

### 为什么需要原型模式

1. **性能优化**: 当创建对象的成本较高时，通过复制可以提高性能
2. **简化创建**: 避免复杂的初始化过程，直接复制已有对象
3. **动态创建**: 可以在运行时动态创建和修改对象
4. **隐藏细节**: 客户端不需要知道对象创建的细节

### 生活中的例子

- 克隆技术：通过克隆已有生物创建新个体
- 文档复制：复制已有文档作为新文档的基础
- 模板复制：基于模板创建新的文档或项目

## 原型模式的结构

原型模式包含以下角色：

1. **抽象原型(Prototype)**: 声明克隆方法的接口
2. **具体原型(ConcretePrototype)**: 实现克隆方法，返回自己的一个副本
3. **客户端(Client)**: 通过请求原型克隆自己来创建新对象

### 类图结构

```
+----------------+       +-----------------+
|   Client       |------>|   Prototype     |
+----------------+       +-----------------+
| -prototype     |       | +clone()        |
+----------------+       +-----------------+
                                 ^
                                 |
                         +-----------------+
                         | ConcretePrototype|
                         +-----------------+
                         | +clone()        |
                         +-----------------+
```

## 原型模式的实现

### 1. 基本实现

```python
from abc import ABC, abstractmethod

# 抽象原型
class Prototype(ABC):
    @abstractmethod
    def clone(self):
        pass

# 具体原型
class ConcretePrototype(Prototype):
    def __init__(self, field):
        self.field = field
    
    def clone(self):
        # 创建新对象并复制字段
        return ConcretePrototype(self.field)
    
    def __str__(self):
        return f"ConcretePrototype(field={self.field})"

# 客户端代码
prototype = ConcretePrototype("初始值")
clone = prototype.clone()

print(f"原对象: {prototype}")
print(f"克隆对象: {clone}")
print(f"原对象ID: {id(prototype)}")
print(f"克隆对象ID: {id(clone)}")
print(f"是同一个对象: {prototype is clone}")
```

### 2. 浅拷贝实现

```python
import copy

# 可变对象的类
class Person:
    def __init__(self, name, address):
        self.name = name
        self.address = address  # address是一个可变对象
    
    def __str__(self):
        return f"Person(name={self.name}, address={self.address})"

# 实现原型接口
class PersonPrototype:
    def __init__(self, person):
        self.person = person
    
    def clone_shallow(self):
        # 浅拷贝：只复制对象本身，不复制引用的对象
        return copy.copy(self.person)
    
    def clone_deep(self):
        # 深拷贝：复制对象及其引用的所有对象
        return copy.deepcopy(self.person)

# 测试浅拷贝和深拷贝
address = {"city": "北京", "street": "朝阳区"}
person = Person("张三", address)
prototype = PersonPrototype(person)

# 浅拷贝
shallow_clone = prototype.clone_shallow()
print("\n浅拷贝测试:")
print(f"原对象: {person}")
print(f"克隆对象: {shallow_clone}")
print(f"是同一个对象: {person is shallow_clone}")
print(f"地址是同一个对象: {person.address is shallow_clone.address}")

# 修改原对象的地址
person.address["city"] = "上海"
print(f"修改原对象地址后，克隆对象的地址: {shallow_clone.address}")

# 深拷贝
deep_clone = prototype.clone_deep()
print("\n深拷贝测试:")
print(f"原对象: {person}")
print(f"克隆对象: {deep_clone}")
print(f"是同一个对象: {person is deep_clone}")
print(f"地址是同一个对象: {person.address is deep_clone.address}")

# 修改原对象的地址
person.address["city"] = "广州"
print(f"修改原对象地址后，克隆对象的地址: {deep_clone.address}")
```

### 3. 使用注册表的实现

```python
class PrototypeRegistry:
    _registry = {}
    
    @classmethod
    def register(cls, key, prototype):
        cls._registry[key] = prototype
    
    @classmethod
    def unregister(cls, key):
        if key in cls._registry:
            del cls._registry[key]
    
    @classmethod
    def clone(cls, key, **kwargs):
        if key not in cls._registry:
            raise ValueError(f"未注册的原型: {key}")
        
        prototype = cls._registry[key]
        clone = copy.deepcopy(prototype)
        
        # 更新克隆对象的属性
        for attr, value in kwargs.items():
            if hasattr(clone, attr):
                setattr(clone, attr, value)
        
        return clone
    
    @classmethod
    def list_prototypes(cls):
        return list(cls._registry.keys())

# 定义可克隆的类
class Shape:
    def __init__(self, x=0, y=0, color="black"):
        self.x = x
        self.y = y
        self.color = color
    
    def clone(self):
        return copy.deepcopy(self)
    
    def __str__(self):
        return f"{self.__class__.__name__}(x={self.x}, y={self.y}, color={self.color})"

class Circle(Shape):
    def __init__(self, x=0, y=0, color="black", radius=1):
        super().__init__(x, y, color)
        self.radius = radius
    
    def __str__(self):
        return f"Circle(x={self.x}, y={self.y}, color={self.color}, radius={self.radius})"

class Rectangle(Shape):
    def __init__(self, x=0, y=0, color="black", width=1, height=1):
        super().__init__(x, y, color)
        self.width = width
        self.height = height
    
    def __str__(self):
        return f"Rectangle(x={self.x}, y={self.y}, color={self.color}, width={self.width}, height={self.height})"

# 注册原型
PrototypeRegistry.register("circle", Circle(x=10, y=20, color="red", radius=5))
PrototypeRegistry.register("rectangle", Rectangle(x=5, y=15, color="blue", width=10, height=8))

# 使用注册表创建对象
print("\n使用注册表克隆原型:")
circle1 = PrototypeRegistry.clone("circle")
circle2 = PrototypeRegistry.clone("circle", color="green", radius=10)
rectangle1 = PrototypeRegistry.clone("rectangle")
rectangle2 = PrototypeRegistry.clone("rectangle", x=20, y=30, width=15)

print(f"圆形1: {circle1}")
print(f"圆形2: {circle2}")
print(f"矩形1: {rectangle1}")
print(f"矩形2: {rectangle2}")

print(f"已注册的原型: {PrototypeRegistry.list_prototypes()}")
```

## 原型模式的应用场景

### 1. 游戏对象克隆

```python
# 游戏中的角色类
class GameCharacter:
    def __init__(self, name, health, attack, defense, skills):
        self.name = name
        self.health = health
        self.attack = attack
        self.defense = defense
        self.skills = skills
    
    def clone(self):
        return copy.deepcopy(self)
    
    def __str__(self):
        skills_str = ", ".join(self.skills)
        return f"{self.name}(生命值={self.health}, 攻击力={self.attack}, 防御力={self.defense}, 技能=[{skills_str}])"

# 角色原型工厂
class CharacterFactory:
    _prototypes = {}
    
    @classmethod
    def register(cls, name, character):
        cls._prototypes[name] = character
    
    @classmethod
    def create(cls, name, new_name=None):
        if name not in cls._prototypes:
            raise ValueError(f"未注册的角色原型: {name}")
        
        character = cls._prototypes[name].clone()
        if new_name:
            character.name = new_name
        return character

# 注册角色原型
warrior = GameCharacter("战士", 100, 20, 15, ["重击", "防御"])
mage = GameCharacter("法师", 60, 30, 5, ["火球术", "冰冻术", "魔法盾"])
archer = GameCharacter("弓箭手", 80, 25, 10, ["精准射击", "多重箭"])

CharacterFactory.register("warrior", warrior)
CharacterFactory.register("mage", mage)
CharacterFactory.register("archer", archer)

# 创建游戏角色
print("\n游戏角色克隆:")
warrior1 = CharacterFactory.create("warrior", "勇敢的战士")
warrior2 = CharacterFactory.create("warrior", "强大的战士")
mage1 = CharacterFactory.create("mage", "智慧的法师")
archer1 = CharacterFactory.create("archer", "敏捷的弓箭手")

print(warrior1)
print(warrior2)
print(mage1)
print(archer1)

# 修改克隆对象不会影响原对象
warrior1.health = 80  # 受伤了
print(f"修改后，{warrior1}")
print(f"原型{warrior}")
```

### 2. 文档模板系统

```python
# 文档类
class Document:
    def __init__(self, title, content, author, tags):
        self.title = title
        self.content = content
        self.author = author
        self.tags = tags
    
    def clone(self):
        return copy.deepcopy(self)
    
    def __str__(self):
        tags_str = ", ".join(self.tags)
        return f"文档: {self.title}\n作者: {self.author}\n标签: [{tags_str}]\n内容: {self.content}"

# 文档模板工厂
class DocumentTemplateFactory:
    _templates = {}
    
    @classmethod
    def register(cls, name, template):
        cls._templates[name] = template
    
    @classmethod
    def create(cls, name, **kwargs):
        if name not in cls._templates:
            raise ValueError(f"未注册的文档模板: {name}")
        
        document = cls._templates[name].clone()
        
        # 更新文档属性
        for attr, value in kwargs.items():
            if hasattr(document, attr):
                setattr(document, attr, value)
        
        return document

# 注册文档模板
report_template = Document(
    "报告",
    "这是一份报告。第一部分：...\n第二部分：...\n结论：...",
    "系统",
    ["报告", "正式"]
)

memo_template = Document(
    "备忘录",
    "这是一份备忘录。\n主题：...\n内容：...",
    "系统",
    ["备忘录", "内部"]
)

meeting_template = Document(
    "会议记录",
    "会议时间：\n参会人员：\n会议议程：\n1. ...\n2. ...\n会议结论：",
    "系统",
    ["会议", "记录"]
)

DocumentTemplateFactory.register("report", report_template)
DocumentTemplateFactory.register("memo", memo_template)
DocumentTemplateFactory.register("meeting", meeting_template)

# 创建文档
print("\n文档模板系统:")
weekly_report = DocumentTemplateFactory.create(
    "report", 
    title="周报", 
    content="本周工作总结：...\n下周工作计划：...",
    author="张三"
)

project_memo = DocumentTemplateFactory.create(
    "memo",
    title="项目备忘录",
    content="项目进度：...\n存在问题：...",
    author="李四"
)

team_meeting = DocumentTemplateFactory.create(
    "meeting",
    title="团队会议记录",
    content="会议时间：2023-10-15\n参会人员：张三, 李四, 王五\n会议议程：\n1. 项目进度汇报\n2. 问题讨论\n3. 下一步计划",
    author="王五"
)

print(weekly_report)
print("\n" + "="*50 + "\n")
print(project_memo)
print("\n" + "="*50 + "\n")
print(team_meeting)
```

### 3. 图形编辑器

```python
# 图形基类
class Graphic:
    def __init__(self, x=0, y=0, color="black"):
        self.x = x
        self.y = y
        self.color = color
    
    def clone(self):
        return copy.deepcopy(self)
    
    def move(self, dx, dy):
        self.x += dx
        self.y += dy
    
    def __str__(self):
        return f"{self.__class__.__name__}(x={self.x}, y={self.y}, color={self.color})"

# 具体图形类
class Line(Graphic):
    def __init__(self, x1=0, y1=0, x2=10, y2=10, color="black"):
        super().__init__(x1, y1, color)
        self.x2 = x2
        self.y2 = y2
    
    def move(self, dx, dy):
        super().move(dx, dy)
        self.x2 += dx
        self.y2 += dy
    
    def __str__(self):
        return f"Line(({self.x}, {self.y}) to ({self.x2}, {self.y2}), color={self.color})"

class Circle(Graphic):
    def __init__(self, x=0, y=0, radius=10, color="black"):
        super().__init__(x, y, color)
        self.radius = radius
    
    def __str__(self):
        return f"Circle(center=({self.x}, {self.y}), radius={self.radius}, color={self.color})"

class Rectangle(Graphic):
    def __init__(self, x=0, y=0, width=20, height=10, color="black"):
        super().__init__(x, y, color)
        self.width = width
        self.height = height
    
    def move(self, dx, dy):
        super().move(dx, dy)
    
    def __str__(self):
        return f"Rectangle(top-left=({self.x}, {self.y}), width={self.width}, height={self.height}, color={self.color})"

# 图形编辑器
class GraphicEditor:
    def __init__(self):
        self.graphics = []
        self.clipboard = None
    
    def add_graphic(self, graphic):
        self.graphics.append(graphic)
    
    def remove_graphic(self, index):
        if 0 <= index < len(self.graphics):
            return self.graphics.pop(index)
        return None
    
    def copy_graphic(self, index):
        if 0 <= index < len(self.graphics):
            self.clipboard = self.graphics[index].clone()
    
    def paste_graphic(self):
        if self.clipboard:
            # 创建一个偏移的副本，避免完全重叠
            new_graphic = self.clipboard.clone()
            new_graphic.move(10, 10)
            self.add_graphic(new_graphic)
            return new_graphic
        return None
    
    def list_graphics(self):
        for i, graphic in enumerate(self.graphics):
            print(f"{i}: {graphic}")

# 使用图形编辑器
print("\n图形编辑器:")
editor = GraphicEditor()

# 添加图形
editor.add_graphic(Line(0, 0, 20, 20, "red"))
editor.add_graphic(Circle(50, 50, 15, "blue"))
editor.add_graphic(Rectangle(100, 0, 30, 20, "green"))

print("初始图形:")
editor.list_graphics()

# 复制第一个图形
print("\n复制第一个图形:")
editor.copy_graphic(0)
editor.paste_graphic()

print("复制后的图形:")
editor.list_graphics()

# 复制第二个图形并多次粘贴
print("\n复制第二个图形并多次粘贴:")
editor.copy_graphic(1)
editor.paste_graphic()
editor.paste_graphic()

print("最终图形:")
editor.list_graphics()
```

## 原型模式的优缺点

### 优点

1. **性能优化**: 通过复制已有对象创建新对象，比直接创建更高效
2. **简化创建**: 避免复杂的初始化过程
3. **动态创建**: 可以在运行时动态添加和删除原型
4. **隐藏细节**: 客户端不需要知道对象创建的细节
5. **减少子类**: 可以通过克隆对象来避免创建多个子类

### 缺点

1. **深拷贝复杂性**: 实现深拷贝可能比较复杂，特别是对于包含循环引用的对象
2. **类设计要求**: 需要类实现克隆方法，可能违反开闭原则
3. **对象状态管理**: 需要管理对象的状态，确保复制后的对象状态正确

## 原型模式与其他模式的关系

### 1. 与工厂方法模式

原型模式可以与工厂方法模式结合使用，工厂方法可以通过克隆原型来创建对象。

### 2. 与单例模式

如果单例类实现了原型接口，需要谨慎处理克隆操作，避免破坏单例特性。

### 3. 与组合模式

组合模式中的复杂对象结构可以使用原型模式进行复制。

## 最佳实践

### 1. 合理使用深拷贝

根据需要选择使用浅拷贝还是深拷贝。对于包含可变引用的对象，通常需要使用深拷贝。

### 2. 实现原型注册表

使用原型注册表可以管理和访问多个原型对象，提高系统的灵活性。

### 3. 考虑性能影响

虽然原型模式可以提高性能，但对于简单对象，直接创建可能更高效。

### 4. 处理循环引用

在实现深拷贝时，需要处理循环引用的情况，避免无限递归。

## Python中的特殊考虑

### 1. 使用copy模块

Python的`copy`模块提供了`copy()`（浅拷贝）和`deepcopy()`（深拷贝）函数，可以方便地实现原型模式。

### 2. 使用`__dict__`

可以使用`__dict__`来复制对象的状态：

```python
def clone(self):
    clone = self.__class__()
    clone.__dict__ = copy.deepcopy(self.__dict__)
    return clone
```

### 3. 使用`__reduce__`

对于复杂的对象，可以自定义`__reduce__`方法来控制序列化和反序列化过程，从而实现更灵活的克隆。

## 总结

原型模式是一种创建型设计模式，它使用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象。

原型模式的主要优点是：
- 通过复制已有对象创建新对象，提高性能
- 简化对象的创建过程，避免复杂的初始化
- 可以在运行时动态创建和修改对象
- 隐藏了对象创建的细节

在Python中，我们可以利用`copy`模块方便地实现浅拷贝和深拷贝。需要注意的是，对于包含可变引用的对象，应该使用深拷贝来确保复制的完整性。

原型模式特别适用于以下场景：
- 创建对象的成本较高
- 需要创建多个相似的对象
- 对象的初始化过程复杂

在下一章中，我们将学习适配器模式，这是结构型设计模式的第一个成员。