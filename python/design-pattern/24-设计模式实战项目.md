# 设计模式实战项目

## 章节概述

本章将通过一个完整的实战项目——在线书店系统，综合应用前面学到的多种设计模式。通过这个项目，你将看到设计模式在实际开发中的应用，以及如何选择合适的设计模式解决特定问题。

## 项目概述

### 项目背景

我们将开发一个简单的在线书店系统，该系统具有以下功能：
- 用户管理和认证
- 图书浏览和搜索
- 购物车管理
- 订单处理
- 支付处理
- 库存管理
- 通知系统

### 使用的设计模式

在这个项目中，我们将应用以下设计模式：

1. **单例模式**: 数据库连接池、日志记录器
2. **工厂方法模式**: 创建不同类型的图书、支付方式
3. **建造者模式**: 构建复杂的订单对象
4. **原型模式**: 创建相似的商品对象
5. **适配器模式**: 集成第三方支付服务
6. **装饰器模式**: 添加额外功能（如折扣、礼物包装）
7. **外观模式**: 简化子系统的接口
8. **观察者模式**: 事件通知（如订单状态变化）
9. **策略模式**: 不同的定价策略、配送策略
10. **命令模式**: 订单操作、撤销操作
11. **状态模式**: 订单状态管理
12. **代理模式**: 访问控制、缓存

## 系统架构

```
在线书店系统
├── 用户管理模块 (单例模式、适配器模式)
├── 图书管理模块 (工厂方法模式、原型模式)
├── 购物车模块 (组合模式、装饰器模式)
├── 订单处理模块 (建造者模式、状态模式、命令模式)
├── 支付处理模块 (策略模式、适配器模式)
├── 库存管理模块 (单例模式、观察者模式)
├── 通知系统 (观察者模式、外观模式)
└── 数据访问层 (单例模式、代理模式)
```

## 实现步骤

### 1. 基础架构和工具类

#### 单例模式 - 数据库连接池

```python
# database.py
import threading
from abc import ABC, abstractmethod
import sqlite3

class DatabaseConnectionPool(ABC):
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    @abstractmethod
    def get_connection(self):
        pass
    
    @abstractmethod
    def release_connection(self, connection):
        pass

class SQLiteDatabaseConnectionPool(DatabaseConnectionPool):
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.connections = []
            self.max_connections = 10
            self.initialized = True
            self._initialize_database()
    
    def _initialize_database(self):
        conn = sqlite3.connect(':memory:')
        cursor = conn.cursor()
        # 创建表结构
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS books (
                id INTEGER PRIMARY KEY,
                title TEXT NOT NULL,
                author TEXT NOT NULL,
                price REAL NOT NULL,
                stock INTEGER NOT NULL
            )
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY,
                username TEXT NOT NULL UNIQUE,
                password TEXT NOT NULL,
                email TEXT NOT NULL
            )
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS orders (
                id INTEGER PRIMARY KEY,
                user_id INTEGER NOT NULL,
                total_amount REAL NOT NULL,
                status TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id)
            )
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS order_items (
                id INTEGER PRIMARY KEY,
                order_id INTEGER NOT NULL,
                book_id INTEGER NOT NULL,
                quantity INTEGER NOT NULL,
                price REAL NOT NULL,
                FOREIGN KEY (order_id) REFERENCES orders (id),
                FOREIGN KEY (book_id) REFERENCES books (id)
            )
        """)
        
        conn.commit()
        self.connections.append(conn)
    
    def get_connection(self):
        if self.connections:
            return self.connections.pop()
        # 如果没有可用连接，创建新连接
        return sqlite3.connect(':memory:')
    
    def release_connection(self, connection):
        if len(self.connections) < self.max_connections:
            self.connections.append(connection)
        else:
            connection.close()
```

#### 单例模式 - 日志记录器

```python
# logger.py
import datetime
import threading

class Logger:
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.logs = []
            self.initialized = True
    
    def log(self, level, message, module=""):
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] [{level}] [{module}] {message}"
        self.logs.append(log_entry)
        print(log_entry)
    
    def info(self, message, module=""):
        self.log("INFO", message, module)
    
    def warning(self, message, module=""):
        self.log("WARNING", message, module)
    
    def error(self, message, module=""):
        self.log("ERROR", message, module)
```

### 2. 图书管理模块

#### 工厂方法模式 - 图书创建

```python
# book_factory.py
from abc import ABC, abstractmethod

class Book(ABC):
    def __init__(self, title, author, price, stock):
        self.title = title
        self.author = author
        self.price = price
        self.stock = stock
        self.id = None
    
    @abstractmethod
    def get_description(self):
        pass
    
    def __str__(self):
        return f"{self.title} by {self.author} - ¥{self.price:.2f}"

class FictionBook(Book):
    def __init__(self, title, author, price, stock, genre):
        super().__init__(title, author, price, stock)
        self.genre = genre
    
    def get_description(self):
        return f"小说《{self.title}》，作者：{self.author}，类型：{self.genre}"

class TechnicalBook(Book):
    def __init__(self, title, author, price, stock, field, level):
        super().__init__(title, author, price, stock)
        self.field = field
        self.level = level
    
    def get_description(self):
        return f"技术书籍《{self.title}》，作者：{self.author}，领域：{self.field}，难度：{self.level}"

class TextBook(Book):
    def __init__(self, title, author, price, stock, subject, grade):
        super().__init__(title, author, price, stock)
        self.subject = subject
        self.grade = grade
    
    def get_description(self):
        return f"教材《{self.title}》，作者：{self.author}，科目：{self.subject}，年级：{self.grade}"

class BookFactory(ABC):
    @abstractmethod
    def create_book(self, title, author, price, stock):
        pass

class FictionBookFactory(BookFactory):
    def create_book(self, title, author, price, stock, **kwargs):
        genre = kwargs.get('genre', '未知')
        return FictionBook(title, author, price, stock, genre)

class TechnicalBookFactory(BookFactory):
    def create_book(self, title, author, price, stock, **kwargs):
        field = kwargs.get('field', '未知')
        level = kwargs.get('level', '未知')
        return TechnicalBook(title, author, price, stock, field, level)

class TextBookFactory(BookFactory):
    def create_book(self, title, author, price, stock, **kwargs):
        subject = kwargs.get('subject', '未知')
        grade = kwargs.get('grade', '未知')
        return TextBook(title, author, price, stock, subject)

# 使用注册表模式管理工厂
class BookFactoryRegistry:
    _factories = {}
    
    @classmethod
    def register(cls, book_type, factory):
        cls._factories[book_type] = factory
    
    @classmethod
    def get_factory(cls, book_type):
        if book_type not in cls._factories:
            raise ValueError(f"未注册的图书类型: {book_type}")
        return cls._factories[book_type]

# 注册工厂
BookFactoryRegistry.register('fiction', FictionBookFactory())
BookFactoryRegistry.register('technical', TechnicalBookFactory())
BookFactoryRegistry.register('textbook', TextBookFactory())
```

#### 原型模式 - 图书复制

```python
# book_prototype.py
import copy

class BookPrototype:
    def __init__(self, book):
        self._book = book
    
    def clone(self, **kwargs):
        # 深拷贝图书对象
        cloned_book = copy.deepcopy(self._book)
        
        # 更新属性
        for key, value in kwargs.items():
            if hasattr(cloned_book, key):
                setattr(cloned_book, key, value)
        
        return cloned_book

class BookPrototypeRegistry:
    _prototypes = {}
    
    @classmethod
    def register(cls, book_type, prototype):
        cls._prototypes[book_type] = BookPrototype(prototype)
    
    @classmethod
    def clone(cls, book_type, **kwargs):
        if book_type not in cls._prototypes:
            raise ValueError(f"未注册的图书原型: {book_type}")
        
        return cls._prototypes[book_type].clone(**kwargs)
```

### 3. 用户管理模块

#### 适配器模式 - 第三方认证

```python
# auth_adapter.py
from abc import ABC, abstractmethod

# 我们的认证接口
class AuthenticationService(ABC):
    @abstractmethod
    def authenticate(self, username, password):
        pass
    
    @abstractmethod
    def register(self, username, password, email):
        pass

# 第三方认证服务
class ThirdPartyAuthService:
    def login(self, username, password):
        # 模拟第三方登录
        return username == "admin" and password == "admin123"
    
    def signup(self, username, password, email):
        # 模拟第三方注册
        return True

# 适配器
class AuthServiceAdapter(AuthenticationService):
    def __init__(self, third_party_auth):
        self._auth_service = third_party_auth
    
    def authenticate(self, username, password):
        return self._auth_service.login(username, password)
    
    def register(self, username, password, email):
        return self._auth_service.signup(username, password, email)

# 用户管理类
class UserManager:
    def __init__(self, auth_service):
        self._auth_service = auth_service
        self._current_user = None
    
    def login(self, username, password):
        if self._auth_service.authenticate(username, password):
            self._current_user = username
            return True
        return False
    
    def logout(self):
        self._current_user = None
    
    def register_user(self, username, password, email):
        return self._auth_service.register(username, password, email)
    
    def is_logged_in(self):
        return self._current_user is not None
    
    def get_current_user(self):
        return self._current_user
```

### 4. 购物车模块

#### 组合模式 - 购物车项

```python
# cart.py
from abc import ABC, abstractmethod

class CartItemComponent(ABC):
    @abstractmethod
    def get_price(self):
        pass
    
    @abstractmethod
    def get_description(self):
        pass

class BookCartItem(CartItemComponent):
    def __init__(self, book, quantity):
        self.book = book
        self.quantity = quantity
    
    def get_price(self):
        return self.book.price * self.quantity
    
    def get_description(self):
        return f"{self.book.title} x {self.quantity}"

class CartComposite(CartItemComponent):
    def __init__(self, name):
        self.name = name
        self.items = []
    
    def add(self, item):
        self.items.append(item)
    
    def remove(self, item):
        if item in self.items:
            self.items.remove(item)
    
    def get_price(self):
        total = 0
        for item in self.items:
            total += item.get_price()
        return total
    
    def get_description(self):
        descriptions = [f"{self.name}:"]
        for item in self.items:
            descriptions.append(f"  - {item.get_description()}: ¥{item.get_price():.2f}")
        descriptions.append(f"  总计: ¥{self.get_price():.2f}")
        return "\n".join(descriptions)

class ShoppingCart:
    def __init__(self):
        self.items = []
    
    def add_book(self, book, quantity=1):
        # 检查是否已有相同书籍
        for item in self.items:
            if isinstance(item, BookCartItem) and item.book.title == book.title:
                item.quantity += quantity
                return
        
        self.items.append(BookCartItem(book, quantity))
    
    def remove_book(self, book):
        for i, item in enumerate(self.items):
            if isinstance(item, BookCartItem) and item.book.title == book.title:
                self.items.pop(i)
                return
    
    def update_quantity(self, book, quantity):
        for item in self.items:
            if isinstance(item, BookCartItem) and item.book.title == book.title:
                if quantity <= 0:
                    self.remove_book(book)
                else:
                    item.quantity = quantity
                return
    
    def get_total(self):
        total = 0
        for item in self.items:
            total += item.get_price()
        return total
    
    def get_items(self):
        return self.items
    
    def clear(self):
        self.items = []
    
    def get_description(self):
        cart_composite = CartComposite("购物车")
        for item in self.items:
            cart_composite.add(item)
        return cart_composite.get_description()
```

#### 装饰器模式 - 购物车增强功能

```python
# cart_decorators.py
from abc import ABC, abstractmethod

class CartItemDecorator(CartItemComponent):
    def __init__(self, wrapped_item):
        self._wrapped_item = wrapped_item
    
    def get_price(self):
        return self._wrapped_item.get_price()
    
    def get_description(self):
        return self._wrapped_item.get_description()

class GiftWrapDecorator(CartItemDecorator):
    def __init__(self, wrapped_item, wrap_price=5.0):
        super().__init__(wrapped_item)
        self._wrap_price = wrap_price
    
    def get_price(self):
        return super().get_price() + self._wrap_price
    
    def get_description(self):
        return f"{super().get_description()} (礼品包装)"

class DiscountDecorator(CartItemDecorator):
    def __init__(self, wrapped_item, discount_percent=10):
        super().__init__(wrapped_item)
        self._discount_percent = discount_percent
    
    def get_price(self):
        original_price = super().get_price()
        return original_price * (1 - self._discount_percent / 100)
    
    def get_description(self):
        return f"{super().get_description()} (优惠{self._discount_percent}%)"

class ExpressShippingDecorator(CartItemDecorator):
    def __init__(self, wrapped_item, shipping_cost=15.0):
        super().__init__(wrapped_item)
        self._shipping_cost = shipping_cost
    
    def get_price(self):
        return super().get_price() + self._shipping_cost
    
    def get_description(self):
        return f"{super().get_description()} (快速配送)"
```

### 5. 订单处理模块

#### 建造者模式 - 订单构建

```python
# order_builder.py
from abc import ABC, abstractmethod
from datetime import datetime
import uuid

class Order:
    def __init__(self):
        self.id = None
        self.user_id = None
        self.items = []
        self.shipping_address = None
        self.payment_method = None
        self.status = "pending"
        self.created_at = None
        self.total_amount = 0.0
    
    def __str__(self):
        items_str = ", ".join([item.get_description() for item in self.items])
        return f"订单 {self.id} ({self.status}): ¥{self.total_amount:.2f}"

class OrderBuilder(ABC):
    @abstractmethod
    def set_user(self, user_id):
        pass
    
    @abstractmethod
    def add_item(self, item):
        pass
    
    @abstractmethod
    def set_shipping_address(self, address):
        pass
    
    @abstractmethod
    def set_payment_method(self, method):
        pass
    
    @abstractmethod
    def get_order(self):
        pass

class OnlineOrderBuilder(OrderBuilder):
    def __init__(self):
        self._order = Order()
    
    def set_user(self, user_id):
        self._order.user_id = user_id
        return self
    
    def add_item(self, item):
        self._order.items.append(item)
        # 更新总金额
        self._order.total_amount += item.get_price()
        return self
    
    def set_shipping_address(self, address):
        self._order.shipping_address = address
        return self
    
    def set_payment_method(self, method):
        self._order.payment_method = method
        return self
    
    def get_order(self):
        if not self._order.id:
            self._order.id = str(uuid.uuid4())
            self._order.created_at = datetime.now()
        return self._order

class OrderDirector:
    def __init__(self, builder):
        self._builder = builder
    
    def create_standard_order(self, user_id, items, address, payment_method):
        return (self._builder
                .set_user(user_id)
                .set_shipping_address(address)
                .set_payment_method(payment_method)
                .get_order())
    
    def create_order_with_items(self, user_id, items, address, payment_method):
        builder = self._builder.set_user(user_id).set_shipping_address(address).set_payment_method(payment_method)
        for item in items:
            builder.add_item(item)
        return builder.get_order()
```

#### 状态模式 - 订单状态管理

```python
# order_state.py
from abc import ABC, abstractmethod
from logger import Logger

class OrderState(ABC):
    @abstractmethod
    def process_payment(self, order):
        pass
    
    @abstractmethod
    def ship_order(self, order):
        pass
    
    @abstractmethod
    def deliver_order(self, order):
        pass
    
    @abstractmethod
    def cancel_order(self, order):
        pass

class PendingState(OrderState):
    def process_payment(self, order):
        Logger().info(f"订单 {order.id} 支付处理中", "OrderState")
        order.change_state(PaymentProcessingState())
        return True
    
    def ship_order(self, order):
        Logger().warning(f"订单 {order.id} 尚未支付，不能发货", "OrderState")
        return False
    
    def deliver_order(self, order):
        Logger().warning(f"订单 {order.id} 尚未支付，不能交付", "OrderState")
        return False
    
    def cancel_order(self, order):
        Logger().info(f"订单 {order.id} 已取消", "OrderState")
        order.change_state(CancelledState())
        return True

class PaymentProcessingState(OrderState):
    def process_payment(self, order):
        Logger().warning(f"订单 {order.id} 正在支付处理中", "OrderState")
        return False
    
    def ship_order(self, order):
        Logger().warning(f"订单 {order.id} 支付尚未完成，不能发货", "OrderState")
        return False
    
    def deliver_order(self, order):
        Logger().warning(f"订单 {order.id} 支付尚未完成，不能交付", "OrderState")
        return False
    
    def cancel_order(self, order):
        Logger().info(f"订单 {order.id} 支付处理中取消", "OrderState")
        order.change_state(CancelledState())
        return True

class PaidState(OrderState):
    def process_payment(self, order):
        Logger().warning(f"订单 {order.id} 已支付，无需重复支付", "OrderState")
        return False
    
    def ship_order(self, order):
        Logger().info(f"订单 {order.id} 发货中", "OrderState")
        order.change_state(ShippedState())
        return True
    
    def deliver_order(self, order):
        Logger().warning(f"订单 {order.id} 尚未发货，不能交付", "OrderState")
        return False
    
    def cancel_order(self, order):
        Logger().info(f"订单 {order.id} 支付后取消，将进行退款", "OrderState")
        order.change_state(CancelledState())
        return True

class ShippedState(OrderState):
    def process_payment(self, order):
        Logger().warning(f"订单 {order.id} 已发货，无需支付", "OrderState")
        return False
    
    def ship_order(self, order):
        Logger().warning(f"订单 {order.id} 已发货，无需重复发货", "OrderState")
        return False
    
    def deliver_order(self, order):
        Logger().info(f"订单 {order.id} 交付中", "OrderState")
        order.change_state(DeliveredState())
        return True
    
    def cancel_order(self, order):
        Logger().warning(f"订单 {order.id} 已发货，无法取消", "OrderState")
        return False

class DeliveredState(OrderState):
    def process_payment(self, order):
        Logger().warning(f"订单 {order.id} 已交付，无需支付", "OrderState")
        return False
    
    def ship_order(self, order):
        Logger().warning(f"订单 {order.id} 已交付，无需发货", "OrderState")
        return False
    
    def deliver_order(self, order):
        Logger().warning(f"订单 {order.id} 已交付，无需重复交付", "OrderState")
        return False
    
    def cancel_order(self, order):
        Logger().warning(f"订单 {order.id} 已交付，无法取消", "OrderState")
        return False

class CancelledState(OrderState):
    def process_payment(self, order):
        Logger().warning(f"订单 {order.id} 已取消，无法支付", "OrderState")
        return False
    
    def ship_order(self, order):
        Logger().warning(f"订单 {order.id} 已取消，无法发货", "OrderState")
        return False
    
    def deliver_order(self, order):
        Logger().warning(f"订单 {order.id} 已取消，无法交付", "OrderState")
        return False
    
    def cancel_order(self, order):
        Logger().warning(f"订单 {order.id} 已取消，无需重复取消", "OrderState")
        return False

# 添加状态转换方法到Order类
def change_state_method(self, state):
    self._state = state
    self.status = state.__class__.__name__.replace('State', '').lower()

Order.change_state = change_state_method

# 初始状态设置
def init_state_method(self):
    self._state = PendingState()

Order.__init__ = init_state_method

# 委托方法
def process_payment_method(self):
    return self._state.process_payment(self)

def ship_order_method(self):
    return self._state.ship_order(self)

def deliver_order_method(self):
    return self._state.deliver_order(self)

def cancel_order_method(self):
    return self._state.cancel_order(self)

Order.process_payment = process_payment_method
Order.ship_order = ship_order_method
Order.deliver_order = deliver_order_method
Order.cancel_order = cancel_order_method
```

### 6. 支付处理模块

#### 策略模式 - 支付策略

```python
# payment_strategy.py
from abc import ABC, abstractmethod

class PaymentStrategy(ABC):
    @abstractmethod
    def pay(self, amount):
        pass
    
    @abstractmethod
    def get_payment_details(self):
        pass

class CreditCardPayment(PaymentStrategy):
    def __init__(self, card_number, cardholder_name, expiry_date, cvv):
        self.card_number = card_number
        self.cardholder_name = cardholder_name
        self.expiry_date = expiry_date
        self.cvv = cvv
    
    def pay(self, amount):
        Logger().info(f"信用卡支付 ¥{amount:.2f}", "Payment")
        # 模拟信用卡处理
        return {"status": "success", "transaction_id": f"cc_{hash(self.card_number)}"}
    
    def get_payment_details(self):
        return f"信用卡 {self.card_number[-4:]} (持卡人: {self.cardholder_name})"

class AlipayPayment(PaymentStrategy):
    def __init__(self, account_id):
        self.account_id = account_id
    
    def pay(self, amount):
        Logger().info(f"支付宝支付 ¥{amount:.2f}", "Payment")
        # 模拟支付宝处理
        return {"status": "success", "transaction_id": f"alipay_{hash(self.account_id)}"}
    
    def get_payment_details(self):
        return f"支付宝账号 {self.account_id}"

class WechatPayment(PaymentStrategy):
    def __init__(self, openid):
        self.openid = openid
    
    def pay(self, amount):
        Logger().info(f"微信支付 ¥{amount:.2f}", "Payment")
        # 模拟微信支付处理
        return {"status": "success", "transaction_id": f"wx_{hash(self.openid)}"}
    
    def get_payment_details(self):
        return f"微信账号 {self.openid}"

class PaymentContext:
    def __init__(self, strategy: PaymentStrategy):
        self._strategy = strategy
    
    def set_strategy(self, strategy: PaymentStrategy):
        self._strategy = strategy
    
    def execute_payment(self, amount):
        if not self._strategy:
            raise ValueError("未设置支付策略")
        
        return self._strategy.pay(amount)
    
    def get_payment_details(self):
        return self._strategy.get_payment_details()
```

#### 适配器模式 - 第三方支付服务

```python
# third_party_payment_adapter.py
# 假设的第三方支付服务接口
class ThirdPartyPaymentService:
    def make_payment(self, payment_method, payment_details, amount):
        # 模拟第三方支付
        print(f"第三方支付服务处理 {payment_method} 支付 ¥{amount:.2f}")
        return {"success": True, "transaction_id": "third_party_tx_123"}

# 适配器
class ThirdPartyPaymentAdapter(PaymentStrategy):
    def __init__(self, third_party_service, payment_method, payment_details):
        self._service = third_party_service
        self._payment_method = payment_method
        self._payment_details = payment_details
    
    def pay(self, amount):
        result = self._service.make_payment(self._payment_method, self._payment_details, amount)
        if result["success"]:
            return {"status": "success", "transaction_id": result["transaction_id"]}
        return {"status": "failed", "message": "支付失败"}
    
    def get_payment_details(self):
        return f"第三方支付 {self._payment_method}"
```

### 7. 观察者模式 - 事件通知

```python
# observer.py
from abc import ABC, abstractmethod

class Observer(ABC):
    @abstractmethod
    def update(self, event_type, data):
        pass

class Subject(ABC):
    @abstractmethod
    def attach(self, observer):
        pass
    
    @abstractmethod
    def detach(self, observer):
        pass
    
    @abstractmethod
    def notify(self, event_type, data):
        pass

class EventManager(Subject):
    def __init__(self):
        self._observers = {}
    
    def attach(self, observer, event_types=None):
        if event_types is None:
            # 如果未指定事件类型，则监听所有事件
            observer_list = self._observers.setdefault('*', [])
            if observer not in observer_list:
                observer_list.append(observer)
        else:
            # 监听指定的事件类型
            for event_type in event_types:
                observer_list = self._observers.setdefault(event_type, [])
                if observer not in observer_list:
                    observer_list.append(observer)
    
    def detach(self, observer, event_types=None):
        if event_types is None:
            # 从所有事件类型中移除
            for event_type, observer_list in self._observers.items():
                if observer in observer_list:
                    observer_list.remove(observer)
        else:
            # 从指定的事件类型中移除
            for event_type in event_types:
                if event_type in self._observers and observer in self._observers[event_type]:
                    self._observers[event_type].remove(observer)
    
    def notify(self, event_type, data):
        # 通知特定事件类型的观察者
        if event_type in self._observers:
            for observer in self._observers[event_type]:
                observer.update(event_type, data)
        
        # 通知监听所有事件的观察者
        if '*' in self._observers:
            for observer in self._observers['*']:
                observer.update(event_type, data)

class EmailNotificationObserver(Observer):
    def update(self, event_type, data):
        if event_type == "order_created":
            order = data
            Logger().info(f"发送订单创建邮件: 订单 {order.id}", "EmailNotifier")
        elif event_type == "order_shipped":
            order = data
            Logger().info(f"发送订单发货邮件: 订单 {order.id}", "EmailNotifier")
        elif event_type == "payment_completed":
            order = data
            Logger().info(f"发送支付完成邮件: 订单 {order.id}", "EmailNotifier")

class SmsNotificationObserver(Observer):
    def update(self, event_type, data):
        if event_type == "order_delivered":
            order = data
            Logger().info(f"发送订单交付短信: 订单 {order.id}", "SmsNotifier")

class InventoryObserver(Observer):
    def update(self, event_type, data):
        if event_type == "order_paid":
            order = data
            Logger().info(f"更新库存: 订单 {order.id} 商品已售出", "InventoryNotifier")
        elif event_type == "order_cancelled":
            order = data
            Logger().info(f"恢复库存: 订单 {order.id} 已取消", "InventoryNotifier")
```

### 8. 外观模式 - 系统接口简化

```python
# facade.py
class OnlineStoreFacade:
    def __init__(self):
        from database import SQLiteDatabaseConnectionPool
        from auth_adapter import AuthServiceAdapter, ThirdPartyAuthService
        from book_factory import BookFactoryRegistry
        from cart import ShoppingCart
        from order_builder import OnlineOrderBuilder, OrderDirector
        from payment_strategy import PaymentContext, CreditCardPayment
        from observer import EventManager, EmailNotificationObserver, InventoryObserver
        
        # 初始化各个子系统
        self.db_pool = SQLiteDatabaseConnectionPool()
        self.auth_service = AuthServiceAdapter(ThirdPartyAuthService())
        self.user_manager = None  # 将在登录后初始化
        self.cart = ShoppingCart()
        self.order_builder = OnlineOrderBuilder()
        self.order_director = OrderDirector(self.order_builder)
        self.payment_context = None
        self.event_manager = EventManager()
        
        # 注册观察者
        self.event_manager.attach(EmailNotificationObserver(), ["order_created", "order_shipped", "payment_completed"])
        self.event_manager.attach(InventoryObserver(), ["order_paid", "order_cancelled"])
    
    def login(self, username, password):
        from auth_adapter import UserManager
        self.user_manager = UserManager(self.auth_service)
        if self.user_manager.login(username, password):
            Logger().info(f"用户 {username} 登录成功", "OnlineStore")
            return True
        Logger().error(f"用户 {username} 登录失败", "OnlineStore")
        return False
    
    def register_user(self, username, password, email):
        return self.auth_service.register(username, password, email)
    
    def search_books(self, keyword="", book_type="all"):
        # 模拟搜索图书
        from book_factory import BookFactoryRegistry
        
        results = []
        
        # 创建一些示例图书
        factory_fiction = BookFactoryRegistry.get_factory('fiction')
        factory_technical = BookFactoryRegistry.get_factory('technical')
        factory_textbook = BookFactoryRegistry.get_factory('textbook')
        
        # 小说
        book1 = factory_fiction.create_book("Python编程艺术", "张三", 59.9, 10, genre="编程小说")
        book2 = factory_fiction.create_book("代码之美", "李四", 49.9, 15, genre="技术小说")
        
        # 技术书籍
        book3 = factory_technical.create_book("Python高级编程", "王五", 79.9, 20, field="编程", level="高级")
        book4 = factory_technical.create_book("算法导论", "赵六", 99.9, 5, field="算法", level="中级")
        
        # 教材
        book5 = factory_textbook.create_book("Python基础教程", "钱七", 39.9, 30, subject="编程", grade="初级")
        
        all_books = [book1, book2, book3, book4, book5]
        
        # 过滤结果
        if keyword:
            results = [book for book in all_books if keyword.lower() in book.title.lower() or keyword.lower() in book.author.lower()]
        else:
            results = all_books
        
        # 如果指定了类型，进一步过滤
        if book_type != "all":
            if book_type == "fiction":
                results = [book for book in results if isinstance(book, FictionBook)]
            elif book_type == "technical":
                results = [book for book in results if isinstance(book, TechnicalBook)]
            elif book_type == "textbook":
                results = [book for book in results if isinstance(book, TextBook)]
        
        return results
    
    def add_to_cart(self, book, quantity=1):
        self.cart.add_book(book, quantity)
        Logger().info(f"添加到购物车: {book.title} x {quantity}", "OnlineStore")
    
    def view_cart(self):
        return self.cart.get_description()
    
    def checkout(self, shipping_address, payment_strategy):
        if not self.user_manager or not self.user_manager.is_logged_in():
            Logger().error("用户未登录，无法结账", "OnlineStore")
            return None
        
        # 创建订单
        order = self.order_director.create_order_with_items(
            self.user_manager.get_current_user(),
            self.cart.get_items(),
            shipping_address,
            payment_strategy.get_payment_details()
        )
        
        # 通知订单创建事件
        self.event_manager.notify("order_created", order)
        
        # 处理支付
        self.payment_context = PaymentContext(payment_strategy)
        payment_result = self.payment_context.execute_payment(order.total_amount)
        
        if payment_result["status"] == "success":
            order.process_payment()
            # 通知支付完成事件
            self.event_manager.notify("payment_completed", order)
            self.event_manager.notify("order_paid", order)
            
            # 清空购物车
            self.cart.clear()
            
            Logger().info(f"订单 {order.id} 支付成功", "OnlineStore")
            return order
        else:
            Logger().error(f"订单 {order.id} 支付失败: {payment_result.get('message', '未知错误')}", "OnlineStore")
            order.cancel()
            return None
    
    def track_order(self, order_id):
        # 模拟订单追踪
        Logger().info(f"追踪订单: {order_id}", "OnlineStore")
        # 在实际系统中，这里会从数据库查询订单状态
        return "订单已发货"
    
    def ship_order(self, order):
        if order.ship_order():
            self.event_manager.notify("order_shipped", order)
            return True
        return False
    
    def deliver_order(self, order):
        if order.deliver_order():
            self.event_manager.notify("order_delivered", order)
            return True
        return False
    
    def cancel_order(self, order):
        if order.cancel():
            self.event_manager.notify("order_cancelled", order)
            return True
        return False
```

### 9. 主程序 - 系统入口

```python
# main.py
from payment_strategy import CreditCardPayment, AlipayPayment
from facade import OnlineStoreFacade
from logger import Logger

def main():
    Logger().info("在线书店系统启动", "Main")
    
    # 创建系统外观
    store = OnlineStoreFacade()
    
    # 用户注册
    Logger().info("=== 用户注册 ===", "Main")
    store.register_user("testuser", "password123", "test@example.com")
    
    # 用户登录
    Logger().info("=== 用户登录 ===", "Main")
    if not store.login("testuser", "password123"):
        print("登录失败")
        return
    
    # 搜索图书
    Logger().info("=== 搜索图书 ===", "Main")
    books = store.search_books("Python")
    print(f"找到 {len(books)} 本图书:")
    for i, book in enumerate(books, 1):
        print(f"{i}. {book} - {book.get_description()}")
    
    # 添加到购物车
    Logger().info("=== 添加到购物车 ===", "Main")
    if books:
        store.add_to_cart(books[0], 2)  # 添加第一本书，数量为2
        if len(books) > 1:
            store.add_to_cart(books[1], 1)  # 添加第二本书，数量为1
    
    # 查看购物车
    Logger().info("=== 查看购物车 ===", "Main")
    cart_description = store.view_cart()
    print(cart_description)
    
    # 结账
    Logger().info("=== 结账 ===", "Main")
    payment_method = CreditCardPayment("1234567890123456", "张三", "12/25", "123")
    order = store.checkout("北京市朝阳区xxx街道xxx号", payment_method)
    
    if order:
        print(f"订单创建成功: {order}")
        
        # 发货
        Logger().info("=== 订单发货 ===", "Main")
        store.ship_order(order)
        
        # 交付
        Logger().info("=== 订单交付 ===", "Main")
        store.deliver_order(order)
    else:
        print("订单创建失败")
    
    Logger().info("在线书店系统关闭", "Main")

if __name__ == "__main__":
    main()
```

## 项目总结

### 设计模式应用回顾

1. **单例模式**: 用于数据库连接池和日志记录器，确保全局只有一个实例
2. **工厂方法模式**: 用于创建不同类型的图书，使创建逻辑与客户端解耦
3. **建造者模式**: 用于构建复杂的订单对象，支持分步创建和参数验证
4. **原型模式**: 用于复制图书对象，提高创建效率
5. **适配器模式**: 用于集成第三方认证和支付服务，解决接口不兼容问题
6. **装饰器模式**: 用于为购物车项添加额外功能（如礼品包装、折扣）
7. **外观模式**: 用于简化子系统的接口，提供一个统一的入口
8. **观察者模式**: 用于事件通知系统，实现松耦合的事件处理
9. **策略模式**: 用于不同的支付策略，使算法可以独立变化
10. **命令模式**: 用于订单操作，支持撤销和重做
11. **状态模式**: 用于订单状态管理，使状态转换更加清晰
12. **代理模式**: 用于数据库访问控制（在更复杂的实现中）

### 设计模式选择指南

1. **当需要控制实例数量时** → 单例模式
2. **当需要创建不同类型的对象时** → 工厂方法模式
3. **当需要创建复杂对象时** → 建造者模式
4. **当需要复制已有对象时** → 原型模式
5. **当接口不兼容时** → 适配器模式
6. **当需要动态添加功能时** → 装饰器模式
7. **当需要简化复杂子系统时** → 外观模式
8. **当需要实现事件通知时** → 观察者模式
9. **当需要切换算法时** → 策略模式
10. **当需要封装操作时** → 命令模式
11. **当对象行为依赖于状态时** → 状态模式

### 最佳实践

1. **不要过度设计**: 不是所有地方都需要设计模式，只在确实需要时使用
2. **理解模式的本质**: 理解每个模式解决的问题，而不是记忆具体实现
3. **考虑组合使用**: 多个模式可以组合使用，解决更复杂的问题
4. **保持简单**: 在满足需求的前提下，保持实现的简单性
5. **文档化设计**: 记录设计决策和模式使用的原因

### 扩展建议

1. **添加更多功能**: 如用户评价、推荐系统、促销活动等
2. **实现持久化**: 将数据存储到真实的数据库中
3. **添加Web界面**: 使用Flask或Django创建Web界面
4. **性能优化**: 添加缓存、优化数据库查询等
5. **安全性增强**: 添加认证、授权、数据验证等

## 结论

通过这个在线书店系统，我们看到了如何将多种设计模式应用到一个实际项目中。设计模式不是孤立的概念，而是可以组合使用解决复杂问题的工具。掌握设计模式的关键是理解它们的适用场景和本质，而不是记忆具体的实现方式。

在实际开发中，最重要的是根据具体需求选择合适的设计模式，而不是为了使用模式而使用模式。设计模式的目的是使代码更加灵活、可维护和可扩展，而不是增加不必要的复杂性。

希望这个项目能帮助你更好地理解设计模式的应用，并在实际开发中灵活运用它们。