# 第23章：访问者模式 (Visitor Pattern)

## 概念解析

### 什么是访问者模式？
访问者模式表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

### 模式结构
- **Visitor（访问者）**：为该对象结构中ConcreteElement的每一个类声明一个Visit操作
- **ConcreteVisitor（具体访问者）**：实现每个由Visitor声明的操作
- **Element（元素）**：定义一个Accept操作，它以一个访问者为参数
- **ConcreteElement（具体元素）**：实现Accept操作
- **ObjectStructure（对象结构）**：能枚举它的元素，可以提供一个高层的接口以允许访问者访问它的元素

## 应用场景
- 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作
- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作污染这些对象的类
- 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作

## 代码示例

```python
from abc import ABC, abstractmethod
from typing import List

# 访问者接口
class Visitor(ABC):
    @abstractmethod
    def visit_book(self, book: 'Book'):
        pass
    
    @abstractmethod
    def visit_magazine(self, magazine: 'Magazine'):
        pass
    
    @abstractmethod
    def visit_research_paper(self, paper: 'ResearchPaper'):
        pass

# 元素接口
class LibraryItem(ABC):
    @abstractmethod
    def accept(self, visitor: Visitor):
        pass

# 具体元素 - 书籍
class Book(LibraryItem):
    def __init__(self, title: str, author: str, isbn: str, pages: int, price: float):
        self.title = title
        self.author = author
        self.isbn = isbn
        self.pages = pages
        self.price = price
    
    def accept(self, visitor: Visitor):
        visitor.visit_book(self)

# 具体元素 - 杂志
class Magazine(LibraryItem):
    def __init__(self, title: str, issue: int, publisher: str, pages: int, price: float):
        self.title = title
        self.issue = issue
        self.publisher = publisher
        self.pages = pages
        self.price = price
    
    def accept(self, visitor: Visitor):
        visitor.visit_magazine(self)

# 具体元素 - 研究论文
class ResearchPaper(LibraryItem):
    def __init__(self, title: str, authors: List[str], journal: str, pages: int, citations: int):
        self.title = title
        self.authors = authors
        self.journal = journal
        self.pages = pages
        self.citations = citations
    
    def accept(self, visitor: Visitor):
        visitor.visit_research_paper(self)

# 具体访问者 - 价格计算器
class PriceCalculator(Visitor):
    def __init__(self):
        self.total_price = 0
    
    def visit_book(self, book: Book):
        # 书籍价格计算逻辑
        price = book.price
        print(f"书籍 '{book.title}' 价格: ${price}")
        self.total_price += price
    
    def visit_magazine(self, magazine: Magazine):
        # 杂志价格计算逻辑
        price = magazine.price
        # 杂志可能有折扣
        if magazine.issue > 10:  # 过刊折扣
            price *= 0.7
        print(f"杂志 '{magazine.title}' 第{magazine.issue}期价格: ${price:.2f}")
        self.total_price += price
    
    def visit_research_paper(self, paper: ResearchPaper):
        # 研究论文通常是免费的
        print(f"研究论文 '{paper.title}' 免费")
        # 研究论文不计入总价

# 具体访问者 - 页数统计器
class PageCounter(Visitor):
    def __init__(self):
        self.total_pages = 0
    
    def visit_book(self, book: Book):
        self.total_pages += book.pages
        print(f"书籍 '{book.title}' 页数: {book.pages}")
    
    def visit_magazine(self, magazine: Magazine):
        self.total_pages += magazine.pages
        print(f"杂志 '{magazine.title}' 页数: {magazine.pages}")
    
    def visit_research_paper(self, paper: ResearchPaper):
        self.total_pages += paper.pages
        print(f"研究论文 '{paper.title}' 页数: {paper.pages}")

# 具体访问者 - 引用分析器
class CitationAnalyzer(Visitor):
    def __init__(self):
        self.total_citations = 0
        self.high_citation_items = []
    
    def visit_book(self, book: Book):
        # 书籍通常没有引用计数
        print(f"书籍 '{book.title}' 没有引用数据")
    
    def visit_magazine(self, magazine: Magazine):
        # 杂志通常没有引用计数
        print(f"杂志 '{magazine.title}' 没有引用数据")
    
    def visit_research_paper(self, paper: ResearchPaper):
        self.total_citations += paper.citations
        print(f"研究论文 '{paper.title}' 引用次数: {paper.citations}")
        
        if paper.citations > 100:
            self.high_citation_items.append(paper.title)

# 对象结构 - 图书馆
class Library:
    def __init__(self):
        self.items: List[LibraryItem] = []
    
    def add_item(self, item: LibraryItem):
        self.items.append(item)
    
    def accept_visitor(self, visitor: Visitor):
        """接受访问者访问所有元素"""
        for item in self.items:
            item.accept(visitor)

# 客户端代码
def main():
    # 创建图书馆
    library = Library()
    
    # 添加各种图书馆项目
    library.add_item(Book("Python编程", "张三", "978-7-121-12345-6", 300, 59.99))
    library.add_item(Book("设计模式", "李四", "978-7-121-12346-3", 400, 79.99))
    library.add_item(Magazine("计算机世界", 25, "计算机出版社", 80, 15.99))
    library.add_item(Magazine("科技前沿", 5, "科技出版社", 60, 12.99))
    library.add_item(ResearchPaper("深度学习综述", ["王五", "赵六"], "AI期刊", 25, 150))
    library.add_item(ResearchPaper("神经网络优化", ["钱七"], "机器学习期刊", 18, 85))
    
    print("=== 访问者模式演示 ===\n")
    
    # 使用价格计算器访问
    print("1. 价格计算:")
    price_calculator = PriceCalculator()
    library.accept_visitor(price_calculator)
    print(f"总价格: ${price_calculator.total_price:.2f}\n")
    
    # 使用页数统计器访问
    print("2. 页数统计:")
    page_counter = PageCounter()
    library.accept_visitor(page_counter)
    print(f"总页数: {page_counter.total_pages}\n")
    
    # 使用引用分析器访问
    print("3. 引用分析:")
    citation_analyzer = CitationAnalyzer()
    library.accept_visitor(citation_analyzer)
    print(f"总引用次数: {citation_analyzer.total_citations}")
    print(f"高引用论文: {citation_analyzer.high_citation_items}")

if __name__ == "__main__":
    main()
```

## 实际应用案例：编译器抽象语法树访问

```python
# 编译器AST访问者模式实现
class ASTVisitor(ABC):
    @abstractmethod
    def visit_number(self, node: 'NumberNode'):
        pass
    
    @abstractmethod
    def visit_variable(self, node: 'VariableNode'):
        pass
    
    @abstractmethod
    def visit_binary_operation(self, node: 'BinaryOperationNode'):
        pass
    
    @abstractmethod
    def visit_assignment(self, node: 'AssignmentNode'):
        pass

class ASTNode(ABC):
    @abstractmethod
    def accept(self, visitor: ASTVisitor):
        pass

class NumberNode(ASTNode):
    def __init__(self, value: int):
        self.value = value
    
    def accept(self, visitor: ASTVisitor):
        visitor.visit_number(self)

class VariableNode(ASTNode):
    def __init__(self, name: str):
        self.name = name
    
    def accept(self, visitor: ASTVisitor):
        visitor.visit_variable(self)

class BinaryOperationNode(ASTNode):
    def __init__(self, left: ASTNode, operator: str, right: ASTNode):
        self.left = left
        self.operator = operator
        self.right = right
    
    def accept(self, visitor: ASTVisitor):
        visitor.visit_binary_operation(self)

class AssignmentNode(ASTNode):
    def __init__(self, variable: str, expression: ASTNode):
        self.variable = variable
        self.expression = expression
    
    def accept(self, visitor: ASTVisitor):
        visitor.visit_assignment(self)

# 具体访问者 - 解释器
class Interpreter(ASTVisitor):
    def __init__(self):
        self.variables = {}
    
    def visit_number(self, node: NumberNode):
        return node.value
    
    def visit_variable(self, node: VariableNode):
        if node.name in self.variables:
            return self.variables[node.name]
        else:
            raise NameError(f"变量未定义: {node.name}")
    
    def visit_binary_operation(self, node: BinaryOperationNode):
        left_value = node.left.accept(self)
        right_value = node.right.accept(self)
        
        if node.operator == '+':
            return left_value + right_value
        elif node.operator == '-':
            return left_value - right_value
        elif node.operator == '*':
            return left_value * right_value
        elif node.operator == '/':
            if right_value == 0:
                raise ZeroDivisionError("除零错误")
            return left_value / right_value
        else:
            raise ValueError(f"未知操作符: {node.operator}")
    
    def visit_assignment(self, node: AssignmentNode):
        value = node.expression.accept(self)
        self.variables[node.variable] = value
        return value
    
    def interpret(self, node: ASTNode):
        return node.accept(self)

# 具体访问者 - 代码生成器
class CodeGenerator(ASTVisitor):
    def __init__(self):
        self.code = []
    
    def visit_number(self, node: NumberNode):
        self.code.append(f"PUSH {node.value}")
    
    def visit_variable(self, node: VariableNode):
        self.code.append(f"LOAD {node.name}")
    
    def visit_binary_operation(self, node: BinaryOperationNode):
        node.left.accept(self)
        node.right.accept(self)
        
        op_map = {'+': 'ADD', '-': 'SUB', '*': 'MUL', '/': 'DIV'}
        self.code.append(op_map[node.operator])
    
    def visit_assignment(self, node: AssignmentNode):
        node.expression.accept(self)
        self.code.append(f"STORE {node.variable}")
    
    def generate_code(self, node: ASTNode) -> List[str]:
        self.code = []
        node.accept(self)
        return self.code

# 使用示例
def compiler_example():
    print("=== 编译器AST访问者模式演示 ===\n")
    
    # 构建AST: x = 10 + 5 * 2
    expression = BinaryOperationNode(
        NumberNode(10),
        '+',
        BinaryOperationNode(NumberNode(5), '*', NumberNode(2))
    )
    assignment = AssignmentNode('x', expression)
    
    # 使用解释器访问
    print("1. 解释器执行:")
    interpreter = Interpreter()
    result = interpreter.interpret(assignment)
    print(f"执行结果: x = {result}")
    print(f"变量表: {interpreter.variables}")
    
    # 使用代码生成器访问
    print("\n2. 代码生成:")
    code_generator = CodeGenerator()
    assembly_code = code_generator.generate_code(assignment)
    print("生成的汇编代码:")
    for instruction in assembly_code:
        print(f"  {instruction}")

if __name__ == "__main__":
    compiler_example()
```

## 实际应用案例：文件系统访问器

```python
# 文件系统访问者模式实现
import os
from abc import ABC, abstractmethod
from typing import List

class FileSystemVisitor(ABC):
    @abstractmethod
    def visit_file(self, file_path: str, size: int):
        pass
    
    @abstractmethod
    def visit_directory(self, dir_path: str, file_count: int, total_size: int):
        pass

class FileSystemItem(ABC):
    @abstractmethod
    def accept(self, visitor: FileSystemVisitor):
        pass

class FileItem(FileSystemItem):
    def __init__(self, path: str):
        self.path = path
        self.size = os.path.getsize(path)
    
    def accept(self, visitor: FileSystemVisitor):
        visitor.visit_file(self.path, self.size)

class DirectoryItem(FileSystemItem):
    def __init__(self, path: str):
        self.path = path
        self.children: List[FileSystemItem] = []
        self._populate_children()
    
    def _populate_children(self):
        """填充子项目"""
        try:
            for item_name in os.listdir(self.path):
                item_path = os.path.join(self.path, item_name)
                
                if os.path.isfile(item_path):
                    self.children.append(FileItem(item_path))
                elif os.path.isdir(item_path):
                    self.children.append(DirectoryItem(item_path))
        except PermissionError:
            print(f"无法访问目录: {self.path}")
    
    def accept(self, visitor: FileSystemVisitor):
        # 先访问子项目
        total_size = 0
        file_count = 0
        
        for child in self.children:
            child.accept(visitor)
            if isinstance(child, FileItem):
                total_size += child.size
                file_count += 1
            elif isinstance(child, DirectoryItem):
                # 对于目录，我们需要递归计算
                stats = self._get_directory_stats(child)
                total_size += stats['total_size']
                file_count += stats['file_count']
        
        # 然后访问当前目录
        visitor.visit_directory(self.path, file_count, total_size)
    
    def _get_directory_stats(self, directory: 'DirectoryItem') -> dict:
        """获取目录统计信息"""
        total_size = 0
        file_count = 0
        
        for child in directory.children:
            if isinstance(child, FileItem):
                total_size += child.size
                file_count += 1
            elif isinstance(child, DirectoryItem):
                stats = self._get_directory_stats(child)
                total_size += stats['total_size']
                file_count += stats['file_count']
        
        return {'total_size': total_size, 'file_count': file_count}

# 具体访问者 - 大小统计器
class SizeCalculator(FileSystemVisitor):
    def __init__(self):
        self.total_size = 0
        self.largest_file = ("", 0)
    
    def visit_file(self, file_path: str, size: int):
        self.total_size += size
        
        if size > self.largest_file[1]:
            self.largest_file = (file_path, size)
    
    def visit_directory(self, dir_path: str, file_count: int, total_size: int):
        # 目录访问主要用于统计，这里不需要额外操作
        pass

# 具体访问者 - 文件类型分析器
class FileTypeAnalyzer(FileSystemVisitor):
    def __init__(self):
        self.file_types = {}
    
    def visit_file(self, file_path: str, size: int):
        # 获取文件扩展名
        _, ext = os.path.splitext(file_path)
        file_type = ext.lower() if ext else "无扩展名"
        
        if file_type not in self.file_types:
            self.file_types[file_type] = {'count': 0, 'total_size': 0}
        
        self.file_types[file_type]['count'] += 1
        self.file_types[file_type]['total_size'] += size
    
    def visit_directory(self, dir_path: str, file_count: int, total_size: int):
        pass

# 使用示例
def file_system_example():
    print("=== 文件系统访问者模式演示 ===\n")
    
    # 创建测试目录结构（模拟）
    test_dir = "."  # 使用当前目录作为示例
    
    try:
        directory = DirectoryItem(test_dir)
        
        # 使用大小统计器访问
        print("1. 文件大小统计:")
        size_calculator = SizeCalculator()
        directory.accept(size_calculator)
        print(f"总大小: {size_calculator.total_size} 字节")
        print(f"最大文件: {size_calculator.largest_file[0]} ({size_calculator.largest_file[1]} 字节)")
        
        # 使用文件类型分析器访问
        print("\n2. 文件类型分析:")
        type_analyzer = FileTypeAnalyzer()
        directory.accept(type_analyzer)
        
        print("文件类型统计:")
        for file_type, stats in type_analyzer.file_types.items():
            print(f"  {file_type}: {stats['count']} 个文件, {stats['total_size']} 字节")
            
    except Exception as e:
        print(f"错误: {e}")

if __name__ == "__main__":
    file_system_example()
```

## 最佳实践

### 优点
- 增加新的操作很容易
- 将相关行为集中在一个访问者对象中
- 可以跨类层次结构操作
- 访问者可以积累状态

### 缺点
- 增加新的元素类很困难
- 破坏了元素的封装性
- 具体元素对访问者公布细节，违反了迪米特法则

### 适用场景
- 对象结构相对稳定，但经常需要在此对象结构上定义新的操作
- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作
- 需要跨多个类层次结构的操作

### 注意事项
- 访问者模式适用于数据结构相对稳定的系统
- 在访问者模式中，增加新的节点类困难
- 访问者模式的具体访问者角色实现对扩展开放，对修改关闭

## 扩展应用

访问者模式还可以应用于：
- 编译器设计
- 抽象语法树处理
- 文档处理系统
- 报表生成器
- 游戏引擎中的场景遍历