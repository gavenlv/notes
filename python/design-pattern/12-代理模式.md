# 第12章 代理模式 (Proxy Pattern)

## 1. 什么是代理模式？

代理模式是一种结构型设计模式，它为其他对象提供一种代理以控制对这个对象的访问。代理模式在客户端和目标对象之间起到中介作用，可以用于控制访问、延迟初始化、记录日志、缓存等。

### 1.1 核心概念

- **主题 (Subject)**: 定义了RealSubject和Proxy的共同接口
- **真实主题 (RealSubject)**: 定义代理所代表的真实对象
- **代理 (Proxy)**: 保存一个引用使得代理可以访问实体，提供一个与Subject的接口相同的接口

### 1.2 现实世界类比

想象一个银行账户：
- 真实账户是RealSubject，包含实际的资金操作
- 代理是ATM机或网上银行，控制对真实账户的访问
- 代理可以添加安全检查、日志记录、限制操作等功能
- 客户端通过代理与真实账户交互，不需要直接访问真实账户

## 2. 代理模式的结构

```python
Subject
    ↳ RealSubject
    ↳ Proxy
```

### 2.1 参与者角色

1. **Subject (主题)**: 定义了RealSubject和Proxy的共同接口
2. **RealSubject (真实主题)**: 定义代理所代表的真实对象
3. **Proxy (代理)**: 保存一个引用使得代理可以访问实体，控制对实体的存取，并可能负责创建和删除它

## 3. 代理模式的实现

### 3.1 基础实现示例

让我们通过一个图像查看器的例子来理解代理模式：

```python
from abc import ABC, abstractmethod
import time

# 主题接口
class Image(ABC):
    @abstractmethod
    def display(self):
        pass

# 真实主题 - 高分辨率图像
class RealImage(Image):
    def __init__(self, filename):
        self.filename = filename
        self._load_from_disk()
    
    def _load_from_disk(self):
        print(f"正在从磁盘加载图像: {self.filename}")
        # 模拟加载大文件的耗时操作
        time.sleep(2)
        print(f"图像 {self.filename} 加载完成")
    
    def display(self):
        print(f"显示图像: {self.filename}")

# 代理 - 图像代理
class ImageProxy(Image):
    def __init__(self, filename):
        self.filename = filename
        self._real_image = None
    
    def display(self):
        if self._real_image is None:
            self._real_image = RealImage(self.filename)
        self._real_image.display()

# 虚拟代理 - 延迟加载图像
class LazyImageProxy(Image):
    def __init__(self, filename):
        self.filename = filename
        self._real_image = None
        self._loaded = False
    
    def display(self):
        if not self._loaded:
            print("[虚拟代理] 图像尚未加载，显示占位符")
            self._show_placeholder()
            # 在实际应用中，可能在这里启动后台加载线程
        else:
            self._real_image.display()
    
    def _show_placeholder(self):
        print(f"[占位符] 图像: {self.filename}")
    
    def load_image(self):
        """手动触发图像加载"""
        if not self._loaded:
            print(f"[虚拟代理] 开始加载图像: {self.filename}")
            self._real_image = RealImage(self.filename)
            self._loaded = True
            print(f"[虚拟代理] 图像加载完成")
```

### 3.2 使用示例

```python
# 使用代理模式
print("=== 使用代理模式 ===")

# 创建图像代理
image1 = ImageProxy("photo1.jpg")
image2 = ImageProxy("photo2.png")

print("\n1. 第一次显示图像（会触发加载）:")
image1.display()

print("\n2. 第二次显示同一图像（不会重新加载）:")
image1.display()

print("\n3. 显示另一个图像:")
image2.display()

print("\n=== 使用虚拟代理 ===")

# 使用虚拟代理
lazy_image = LazyImageProxy("large_photo.jpg")

print("\n1. 显示虚拟代理（显示占位符）:")
lazy_image.display()

print("\n2. 加载真实图像:")
lazy_image.load_image()

print("\n3. 再次显示（显示真实图像）:")
lazy_image.display()
```

## 4. 代理模式的类型

### 4.1 虚拟代理 (Virtual Proxy)

延迟创建开销大的对象：

```python
class ExpensiveObject:
    def __init__(self):
        print("创建昂贵的对象...")
        time.sleep(3)  # 模拟创建耗时
        print("昂贵的对象创建完成")
    
    def process(self):
        print("处理昂贵的操作")

class VirtualProxy:
    def __init__(self):
        self._real_object = None
    
    def process(self):
        if self._real_object is None:
            self._real_object = ExpensiveObject()
        self._real_object.process()

# 使用虚拟代理
proxy = VirtualProxy()
print("虚拟代理已创建，但真实对象尚未创建")
print("调用process方法时才会创建真实对象:")
proxy.process()
```

### 4.2 保护代理 (Protection Proxy)

控制对对象的访问权限：

```python
class SensitiveDocument:
    def __init__(self, content, owner):
        self.content = content
        self.owner = owner
    
    def read(self):
        return self.content
    
    def modify(self, new_content):
        self.content = new_content
        print("文档已修改")

class DocumentProxy:
    def __init__(self, document, current_user):
        self._document = document
        self._current_user = current_user
    
    def read(self):
        if self._check_permission("read"):
            return self._document.read()
        else:
            raise PermissionError("无权读取此文档")
    
    def modify(self, new_content):
        if self._check_permission("modify"):
            self._document.modify(new_content)
        else:
            raise PermissionError("无权修改此文档")
    
    def _check_permission(self, operation):
        if operation == "read":
            return True  # 所有人都可以读
        elif operation == "modify":
            return self._current_user == self._document.owner
        return False

# 使用保护代理
doc = SensitiveDocument("机密内容", "alice")
proxy_alice = DocumentProxy(doc, "alice")
proxy_bob = DocumentProxy(doc, "bob")

print("Alice 读取文档:", proxy_alice.read())
print("Alice 修改文档:")
proxy_alice.modify("修改后的内容")

print("Bob 读取文档:", proxy_bob.read())
print("Bob 尝试修改文档:")
try:
    proxy_bob.modify("未经授权的修改")
except PermissionError as e:
    print("错误:", e)
```

### 4.3 远程代理 (Remote Proxy)

代表一个位于不同地址空间的对象：

```python
import json

# 模拟远程服务
class RemoteService:
    def get_user_info(self, user_id):
        # 模拟远程调用
        print(f"远程调用: 获取用户 {user_id} 的信息")
        time.sleep(1)  # 模拟网络延迟
        return {"id": user_id, "name": f"用户{user_id}", "email": f"user{user_id}@example.com"}
    
    def update_user(self, user_id, data):
        print(f"远程调用: 更新用户 {user_id}")
        time.sleep(1)
        return {"status": "success", "updated": data}

class RemoteProxy:
    def __init__(self):
        self._remote_service = RemoteService()
        self._cache = {}  # 本地缓存
    
    def get_user_info(self, user_id):
        # 检查缓存
        if user_id in self._cache:
            print(f"从缓存获取用户 {user_id} 的信息")
            return self._cache[user_id]
        
        # 远程调用
        result = self._remote_service.get_user_info(user_id)
        
        # 缓存结果
        self._cache[user_id] = result
        print(f"用户 {user_id} 的信息已缓存")
        
        return result
    
    def update_user(self, user_id, data):
        # 更新远程数据
        result = self._remote_service.update_user(user_id, data)
        
        # 清除缓存
        if user_id in self._cache:
            del self._cache[user_id]
            print(f"用户 {user_id} 的缓存已清除")
        
        return result

# 使用远程代理
proxy = RemoteProxy()

print("第一次获取用户信息（远程调用）:")
user1 = proxy.get_user_info(1)
print("用户信息:", user1)

print("\n第二次获取同一用户信息（从缓存）:")
user1_cached = proxy.get_user_info(1)
print("用户信息:", user1_cached)

print("\n更新用户信息:")
update_result = proxy.update_user(1, {"name": "新用户名"})
print("更新结果:", update_result)

print("\n再次获取用户信息（缓存已清除，需要远程调用）:")
user1_updated = proxy.get_user_info(1)
print("用户信息:", user1_updated)
```

## 5. 代理模式的优势

### 5.1 优点

1. **控制访问**: 可以在客户端和真实对象之间添加控制层
2. **延迟加载**: 可以延迟创建开销大的对象
3. **增强功能**: 可以在不修改真实对象的情况下添加额外功能
4. **保护真实对象**: 可以隐藏真实对象的复杂性

### 5.2 缺点

1. **增加复杂性**: 引入额外的抽象层
2. **性能开销**: 代理调用可能带来性能损失
3. **可能过度设计**: 如果不需要额外功能，可能过度设计

## 6. 实际应用场景

### 6.1 数据库连接池

```python
import sqlite3
from threading import Lock

class DatabaseConnection:
    def __init__(self, db_path):
        self.connection = sqlite3.connect(db_path)
        print("创建新的数据库连接")
    
    def execute(self, query):
        cursor = self.connection.cursor()
        cursor.execute(query)
        return cursor.fetchall()
    
    def close(self):
        self.connection.close()
        print("关闭数据库连接")

class ConnectionProxy:
    def __init__(self, db_path, max_connections=5):
        self.db_path = db_path
        self.max_connections = max_connections
        self.connections = []
        self.lock = Lock()
    
    def get_connection(self):
        with self.lock:
            # 检查是否有可用的连接
            for conn in self.connections:
                if not hasattr(conn, '_in_use') or not conn._in_use:
                    conn._in_use = True
                    print("重用现有连接")
                    return conn
            
            # 创建新连接（如果未达到上限）
            if len(self.connections) < self.max_connections:
                conn = DatabaseConnection(self.db_path)
                conn._in_use = True
                self.connections.append(conn)
                print("创建新连接")
                return conn
            else:
                raise Exception("连接池已满")
    
    def release_connection(self, conn):
        with self.lock:
            conn._in_use = False
            print("释放连接")

# 使用连接池
pool = ConnectionProxy(":memory:")

# 模拟多个客户端使用连接
for i in range(3):
    conn = pool.get_connection()
    result = conn.execute("SELECT 1")
    print(f"查询结果 {i+1}:", result)
    pool.release_connection(conn)

print(f"\n连接池中共有 {len(pool.connections)} 个连接")
```

### 6.2 智能引用代理

```python
class LargeObject:
    def __init__(self, data):
        self.data = data
        print(f"创建大对象，数据大小: {len(data)} bytes")
    
    def process(self):
        print(f"处理大对象，数据: {self.data[:50]}...")
    
    def __del__(self):
        print("大对象被销毁")

class SmartReferenceProxy:
    def __init__(self, data):
        self._data = data
        self._real_object = None
        self._reference_count = 0
    
    def acquire(self):
        """获取对象的引用"""
        if self._real_object is None:
            self._real_object = LargeObject(self._data)
        self._reference_count += 1
        print(f"引用计数: {self._reference_count}")
        return self._real_object
    
    def release(self):
        """释放对象的引用"""
        if self._reference_count > 0:
            self._reference_count -= 1
            print(f"引用计数: {self._reference_count}")
            
            # 如果没有引用，销毁对象
            if self._reference_count == 0 and self._real_object is not None:
                del self._real_object
                self._real_object = None
                print("对象已被销毁")

# 使用智能引用代理
proxy = SmartReferenceProxy("这是一个非常大的数据对象" * 1000)

print("=== 第一次使用 ===")
obj1 = proxy.acquire()
obj1.process()

print("\n=== 第二次使用 ===")
obj2 = proxy.acquire()
obj2.process()

print("\n=== 释放引用 ===")
proxy.release()
proxy.release()

print("\n=== 再次使用 ===")
obj3 = proxy.acquire()
obj3.process()
proxy.release()
```

## 7. 代理模式与相关模式的比较

### 7.1 代理模式 vs 装饰器模式

- **代理模式**: 控制访问，关注对象访问的管控
- **装饰器模式**: 添加功能，关注对象功能的扩展

### 7.2 代理模式 vs 适配器模式

- **代理模式**: 不改变接口，提供相同的接口
- **适配器模式**: 改变接口，使不兼容的接口能够协同工作

### 7.3 代理模式 vs 外观模式

- **代理模式**: 代表单个对象，控制对单个对象的访问
- **外观模式**: 代表子系统，提供简化的接口

## 8. 最佳实践

### 8.1 何时使用代理模式

1. **远程访问**: 需要代表远程对象时
2. **延迟加载**: 需要延迟创建开销大的对象时
3. **访问控制**: 需要控制对对象的访问权限时
4. **缓存**: 需要为开销大的操作提供缓存时
5. **日志记录**: 需要在访问对象时记录日志时

### 8.2 实现建议

1. **保持接口一致**: 代理应该与真实对象具有相同的接口
2. **考虑性能**: 代理可能引入性能开销，需要权衡
3. **处理异常**: 代理应该妥善处理真实对象可能抛出的异常
4. **线程安全**: 在多线程环境中确保代理的线程安全
5. **避免过度使用**: 只在确实需要时使用代理模式

## 9. 总结

代理模式是一种强大的结构型模式，它通过提供代理对象来控制对真实对象的访问。这种模式特别适用于以下情况：

- 需要控制对对象的访问
- 需要延迟创建开销大的对象
- 需要为远程对象提供本地代表
- 需要添加访问控制、缓存、日志记录等额外功能

通过合理使用代理模式，我们可以创建更加灵活、安全和高效的应用程序架构。