# 第16章：迭代器模式 (Iterator Pattern)

## 概念解析

### 什么是迭代器模式？
迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。它属于行为型模式，将遍历逻辑与聚合对象分离。

### 模式结构
- **Iterator（迭代器）**：定义访问和遍历元素的接口
- **ConcreteIterator（具体迭代器）**：实现迭代器接口，记录当前遍历位置
- **Aggregate（聚合）**：定义创建相应迭代器对象的接口
- **ConcreteAggregate（具体聚合）**：实现创建相应迭代器的接口

## 应用场景
- 需要访问聚合对象的内容而无需暴露其内部结构
- 需要为聚合对象提供多种遍历方式
- 需要为不同的聚合结构提供一个统一的遍历接口

## 代码示例

```python
from abc import ABC, abstractmethod
from typing import List, Any

# 迭代器接口
class Iterator(ABC):
    @abstractmethod
    def has_next(self) -> bool:
        pass
    
    @abstractmethod
    def next(self) -> Any:
        pass

# 具体迭代器
class ListIterator(Iterator):
    def __init__(self, items: List[Any]):
        self.items = items
        self.position = 0
    
    def has_next(self) -> bool:
        return self.position < len(self.items)
    
    def next(self) -> Any:
        if self.has_next():
            item = self.items[self.position]
            self.position += 1
            return item
        raise StopIteration("No more elements")

# 反向迭代器
class ReverseIterator(Iterator):
    def __init__(self, items: List[Any]):
        self.items = items
        self.position = len(items) - 1
    
    def has_next(self) -> bool:
        return self.position >= 0
    
    def next(self) -> Any:
        if self.has_next():
            item = self.items[self.position]
            self.position -= 1
            return item
        raise StopIteration("No more elements")

# 聚合接口
class Aggregate(ABC):
    @abstractmethod
    def create_iterator(self) -> Iterator:
        pass

# 具体聚合
class ListAggregate(Aggregate):
    def __init__(self):
        self.items: List[Any] = []
    
    def add(self, item: Any):
        self.items.append(item)
    
    def create_iterator(self) -> Iterator:
        return ListIterator(self.items)
    
    def create_reverse_iterator(self) -> Iterator:
        return ReverseIterator(self.items)

# 客户端代码
def main():
    # 创建聚合对象
    aggregate = ListAggregate()
    aggregate.add("Apple")
    aggregate.add("Banana")
    aggregate.add("Cherry")
    aggregate.add("Date")
    
    # 使用正向迭代器
    print("正向遍历：")
    iterator = aggregate.create_iterator()
    while iterator.has_next():
        print(iterator.next())
    
    # 使用反向迭代器
    print("\n反向遍历：")
    reverse_iterator = aggregate.create_reverse_iterator()
    while reverse_iterator.has_next():
        print(reverse_iterator.next())

if __name__ == "__main__":
    main()
```

## Python内置迭代器支持

Python内置了对迭代器模式的支持，我们可以利用Python的特性来实现更简洁的迭代器：

```python
# 使用Python内置迭代器协议
class BookCollection:
    def __init__(self):
        self.books = []
    
    def add_book(self, title: str, author: str):
        self.books.append({"title": title, "author": author})
    
    def __iter__(self):
        self.index = 0
        return self
    
    def __next__(self):
        if self.index < len(self.books):
            book = self.books[self.index]
            self.index += 1
            return book
        raise StopIteration
    
    # 生成器方式实现迭代器
    def filter_by_author(self, author: str):
        for book in self.books:
            if book["author"] == author:
                yield book

# 使用示例
def python_iterator_example():
    collection = BookCollection()
    collection.add_book("Python编程", "张三")
    collection.add_book("算法导论", "李四")
    collection.add_book("设计模式", "张三")
    collection.add_book("数据结构", "王五")
    
    print("所有书籍：")
    for book in collection:
        print(f"{book['title']} - {book['author']}")
    
    print("\n张三的书籍：")
    for book in collection.filter_by_author("张三"):
        print(f"{book['title']} - {book['author']}")

if __name__ == "__main__":
    python_iterator_example()
```

## 实际应用案例：文件系统遍历

```python
import os
from abc import ABC, abstractmethod
from typing import List

# 文件系统迭代器
class FileSystemIterator(Iterator):
    def __init__(self, path: str):
        self.path = path
        self.files = []
        self.position = 0
        self._collect_files()
    
    def _collect_files(self):
        """收集目录下的所有文件"""
        for root, dirs, files in os.walk(self.path):
            for file in files:
                self.files.append(os.path.join(root, file))
    
    def has_next(self) -> bool:
        return self.position < len(self.files)
    
    def next(self) -> str:
        if self.has_next():
            file_path = self.files[self.position]
            self.position += 1
            return file_path
        raise StopIteration("No more files")

# 文件类型过滤器迭代器
class FileTypeIterator(Iterator):
    def __init__(self, base_iterator: Iterator, file_extension: str):
        self.base_iterator = base_iterator
        self.file_extension = file_extension.lower()
        self.next_file = None
        self._find_next()
    
    def _find_next(self):
        """找到下一个符合条件的文件"""
        while self.base_iterator.has_next():
            file_path = self.base_iterator.next()
            if file_path.lower().endswith(self.file_extension):
                self.next_file = file_path
                return
        self.next_file = None
    
    def has_next(self) -> bool:
        return self.next_file is not None
    
    def next(self) -> str:
        if not self.has_next():
            raise StopIteration("No more files")
        
        current_file = self.next_file
        self._find_next()
        return current_file

# 文件系统聚合
class FileSystemAggregate(Aggregate):
    def __init__(self, path: str):
        self.path = path
    
    def create_iterator(self) -> Iterator:
        return FileSystemIterator(self.path)
    
    def create_file_type_iterator(self, extension: str) -> Iterator:
        return FileTypeIterator(self.create_iterator(), extension)

# 使用示例
def file_system_example():
    # 假设当前目录为测试目录
    test_dir = "."
    
    aggregate = FileSystemAggregate(test_dir)
    
    print("所有文件：")
    all_files_iterator = aggregate.create_iterator()
    while all_files_iterator.has_next():
        print(all_files_iterator.next())
    
    print("\nPython文件：")
    py_files_iterator = aggregate.create_file_type_iterator(".py")
    while py_files_iterator.has_next():
        print(py_files_iterator.next())

if __name__ == "__main__":
    file_system_example()
```

## 最佳实践

### 优点
- 支持多种遍历方式
- 简化了聚合类的接口
- 在同一个聚合上可以有多个遍历
- 封装了遍历算法

### 缺点
- 增加了系统的复杂性
- 对于简单的聚合，使用迭代器可能过于复杂

### 适用场景
- 需要遍历聚合对象而又不想暴露其内部结构
- 需要为聚合对象提供多种遍历方式
- 需要为不同的聚合结构提供统一的遍历接口

### 注意事项
- 在Python中，优先使用内置的迭代器协议
- 考虑使用生成器简化迭代器实现
- 注意迭代器的状态管理

## 扩展应用

迭代器模式还可以应用于：
- 数据库查询结果遍历
- 树形结构遍历（深度优先、广度优先）
- 图遍历算法
- 分页数据遍历
- 流式数据处理