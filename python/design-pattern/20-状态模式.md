# 第20章：状态模式 (State Pattern)

## 概念解析

### 什么是状态模式？
状态模式允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

### 模式结构
- **Context（上下文）**：维护一个具体状态对象的实例，定义当前状态
- **State（状态）**：定义一个接口以封装与Context的一个特定状态相关的行为
- **ConcreteState（具体状态）**：每一个具体状态类实现一个与Context的一个状态相关的行为

## 应用场景
- 一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为
- 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态
- 状态转换的逻辑比较复杂时

## 代码示例

```python
from abc import ABC, abstractmethod

# 状态接口
class State(ABC):
    @abstractmethod
    def insert_coin(self, vending_machine: 'VendingMachine'):
        pass
    
    @abstractmethod
    def eject_coin(self, vending_machine: 'VendingMachine'):
        pass
    
    @abstractmethod
    def select_product(self, vending_machine: 'VendingMachine', product: str):
        pass
    
    @abstractmethod
    def dispense(self, vending_machine: 'VendingMachine'):
        pass

# 具体状态 - 无币状态
class NoCoinState(State):
    def insert_coin(self, vending_machine: 'VendingMachine'):
        print("硬币已投入")
        vending_machine.set_state(vending_machine.has_coin_state)
    
    def eject_coin(self, vending_machine: 'VendingMachine'):
        print("没有硬币可退")
    
    def select_product(self, vending_machine: 'VendingMachine', product: str):
        print("请先投入硬币")
    
    def dispense(self, vending_machine: 'VendingMachine'):
        print("请先选择商品并投入硬币")

# 具体状态 - 有币状态
class HasCoinState(State):
    def insert_coin(self, vending_machine: 'VendingMachine'):
        print("已投入硬币，无需重复投入")
    
    def eject_coin(self, vending_machine: 'VendingMachine'):
        print("硬币已退回")
        vending_machine.set_state(vending_machine.no_coin_state)
    
    def select_product(self, vending_machine: 'VendingMachine', product: str):
        if product in vending_machine.products:
            if vending_machine.products[product] > 0:
                print(f"已选择商品: {product}")
                vending_machine.selected_product = product
                vending_machine.set_state(vending_machine.sold_state)
            else:
                print(f"商品 {product} 已售罄")
                vending_machine.set_state(vending_machine.no_coin_state)
        else:
            print("商品不存在")
    
    def dispense(self, vending_machine: 'VendingMachine'):
        print("请先选择商品")

# 具体状态 - 售出状态
class SoldState(State):
    def insert_coin(self, vending_machine: 'VendingMachine'):
        print("请等待商品发放")
    
    def eject_coin(self, vending_machine: 'VendingMachine'):
        print("商品已选择，无法退币")
    
    def select_product(self, vending_machine: 'VendingMachine', product: str):
        print("请等待商品发放")
    
    def dispense(self, vending_machine: 'VendingMachine'):
        if vending_machine.selected_product:
            print(f"发放商品: {vending_machine.selected_product}")
            vending_machine.products[vending_machine.selected_product] -= 1
            vending_machine.selected_product = None
            
            if vending_machine.products:
                vending_machine.set_state(vending_machine.no_coin_state)
            else:
                vending_machine.set_state(vending_machine.sold_out_state)

# 具体状态 - 售罄状态
class SoldOutState(State):
    def insert_coin(self, vending_machine: 'VendingMachine'):
        print("商品已售罄，无法投入硬币")
    
    def eject_coin(self, vending_machine: 'VendingMachine'):
        print("没有硬币可退")
    
    def select_product(self, vending_machine: 'VendingMachine', product: str):
        print("商品已售罄")
    
    def dispense(self, vending_machine: 'VendingMachine'):
        print("商品已售罄")

# 上下文 - 自动售货机
class VendingMachine:
    def __init__(self):
        # 初始化状态
        self.no_coin_state = NoCoinState()
        self.has_coin_state = HasCoinState()
        self.sold_state = SoldState()
        self.sold_out_state = SoldOutState()
        
        self.current_state = self.no_coin_state
        self.products = {
            "可乐": 3,
            "雪碧": 2,
            "矿泉水": 5
        }
        self.selected_product = None
    
    def set_state(self, state: State):
        self.current_state = state
    
    def insert_coin(self):
        self.current_state.insert_coin(self)
    
    def eject_coin(self):
        self.current_state.eject_coin(self)
    
    def select_product(self, product: str):
        self.current_state.select_product(self, product)
    
    def dispense(self):
        self.current_state.dispense(self)
    
    def display_status(self):
        print(f"当前状态: {type(self.current_state).__name__}")
        print("库存情况:")
        for product, count in self.products.items():
            print(f"  {product}: {count}个")
        print("-" * 30)

# 客户端代码
def main():
    vending_machine = VendingMachine()
    
    print("=== 自动售货机状态模式演示 ===\n")
    
    # 初始状态
    vending_machine.display_status()
    
    # 测试正常流程
    print("1. 正常购买流程:")
    vending_machine.select_product("可乐")  # 应该失败
    vending_machine.insert_coin()
    vending_machine.select_product("可乐")
    vending_machine.dispense()
    vending_machine.display_status()
    
    # 测试异常流程
    print("\n2. 异常流程测试:")
    vending_machine.insert_coin()
    vending_machine.eject_coin()
    vending_machine.select_product("雪碧")  # 应该失败
    
    # 测试售罄情况
    print("\n3. 售罄测试:")
    # 清空雪碧库存
    vending_machine.products["雪碧"] = 0
    vending_machine.insert_coin()
    vending_machine.select_product("雪碧")  # 应该显示售罄
    vending_machine.display_status()

if __name__ == "__main__":
    main()
```

## 实际应用案例：订单状态系统

```python
# 订单状态系统实现
class OrderState(ABC):
    @abstractmethod
    def pay(self, order: 'Order'):
        pass
    
    @abstractmethod
    def cancel(self, order: 'Order'):
        pass
    
    @abstractmethod
    def ship(self, order: 'Order'):
        pass
    
    @abstractmethod
    def deliver(self, order: 'Order'):
        pass
    
    @abstractmethod
    def complete(self, order: 'Order'):
        pass

class PendingState(OrderState):
    def pay(self, order: 'Order'):
        print("订单支付成功")
        order.set_state(order.paid_state)
    
    def cancel(self, order: 'Order'):
        print("订单已取消")
        order.set_state(order.cancelled_state)
    
    def ship(self, order: 'Order'):
        print("订单未支付，无法发货")
    
    def deliver(self, order: 'Order'):
        print("订单未支付，无法配送")
    
    def complete(self, order: 'Order'):
        print("订单未支付，无法完成")

class PaidState(OrderState):
    def pay(self, order: 'Order'):
        print("订单已支付，无需重复支付")
    
    def cancel(self, order: 'Order'):
        print("订单取消，退款处理中")
        order.set_state(order.cancelled_state)
    
    def ship(self, order: 'Order'):
        print("订单已发货")
        order.set_state(order.shipped_state)
    
    def deliver(self, order: 'Order'):
        print("订单尚未发货，无法配送")
    
    def complete(self, order: 'Order'):
        print("订单尚未发货，无法完成")

class ShippedState(OrderState):
    def pay(self, order: 'Order'):
        print("订单已支付")
    
    def cancel(self, order: 'Order'):
        print("订单已发货，无法取消")
    
    def ship(self, order: 'Order'):
        print("订单已发货，无需重复发货")
    
    def deliver(self, order: 'Order'):
        print("订单配送中")
        order.set_state(order.delivered_state)
    
    def complete(self, order: 'Order'):
        print("订单尚未配送，无法完成")

class DeliveredState(OrderState):
    def pay(self, order: 'Order'):
        print("订单已支付")
    
    def cancel(self, order: 'Order'):
        print("订单已配送，无法取消")
    
    def ship(self, order: 'Order'):
        print("订单已发货")
    
    def deliver(self, order: 'Order'):
        print("订单已配送，无需重复配送")
    
    def complete(self, order: 'Order'):
        print("订单已完成")
        order.set_state(order.completed_state)

class CompletedState(OrderState):
    def pay(self, order: 'Order'):
        print("订单已完成")
    
    def cancel(self, order: 'Order'):
        print("订单已完成，无法取消")
    
    def ship(self, order: 'Order'):
        print("订单已完成")
    
    def deliver(self, order: 'Order'):
        print("订单已完成")
    
    def complete(self, order: 'Order'):
        print("订单已完成，无需重复完成")

class CancelledState(OrderState):
    def pay(self, order: 'Order'):
        print("订单已取消，无法支付")
    
    def cancel(self, order: 'Order'):
        print("订单已取消，无需重复取消")
    
    def ship(self, order: 'Order'):
        print("订单已取消，无法发货")
    
    def deliver(self, order: 'Order'):
        print("订单已取消，无法配送")
    
    def complete(self, order: 'Order'):
        print("订单已取消，无法完成")

class Order:
    def __init__(self, order_id: str):
        self.order_id = order_id
        
        # 初始化所有状态
        self.pending_state = PendingState()
        self.paid_state = PaidState()
        self.shipped_state = ShippedState()
        self.delivered_state = DeliveredState()
        self.completed_state = CompletedState()
        self.cancelled_state = CancelledState()
        
        # 设置初始状态
        self.current_state = self.pending_state
    
    def set_state(self, state: OrderState):
        self.current_state = state
    
    def pay(self):
        self.current_state.pay(self)
    
    def cancel(self):
        self.current_state.cancel(self)
    
    def ship(self):
        self.current_state.ship(self)
    
    def deliver(self):
        self.current_state.deliver(self)
    
    def complete(self):
        self.current_state.complete(self)
    
    def get_status(self) -> str:
        return type(self.current_state).__name__.replace('State', '')

# 使用示例
def order_system_example():
    order = Order("ORD001")
    
    print("=== 订单状态系统演示 ===\n")
    
    print(f"订单 {order.order_id} 初始状态: {order.get_status()}")
    
    # 正常流程
    print("\n1. 正常订单流程:")
    order.pay()
    print(f"当前状态: {order.get_status()}")
    
    order.ship()
    print(f"当前状态: {order.get_status()}")
    
    order.deliver()
    print(f"当前状态: {order.get_status()}")
    
    order.complete()
    print(f"当前状态: {order.get_status()}")
    
    # 异常流程
    print("\n2. 异常流程测试:")
    order2 = Order("ORD002")
    print(f"订单 {order2.order_id} 初始状态: {order2.get_status()}")
    
    order2.ship()  # 应该失败
    order2.cancel()
    print(f"当前状态: {order2.get_status()}")
    
    order2.pay()  # 应该失败

if __name__ == "__main__":
    order_system_example()
```

## 最佳实践

### 优点
- 封装了转换规则
- 枚举可能的状态，在编译时检查状态转换的有效性
- 将所有与某个状态相关的行为放入一个对象中
- 让状态转换显式化

### 缺点
- 增加了系统类和对象的个数
- 结构相对复杂
- 对开闭原则的支持并不太好

### 适用场景
- 对象的行为依赖于它的状态，并且必须在运行时根据状态改变它的行为
- 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态
- 状态转换的逻辑比较复杂时

### 注意事项
- 状态对象通常被实现为单例
- 注意状态转换的完整性
- 考虑使用状态表来管理状态转换

## 扩展应用

状态模式还可以应用于：
- 工作流引擎
- 游戏角色状态管理
- 网络连接状态管理
- 文档审批流程
- 交通信号灯控制系统