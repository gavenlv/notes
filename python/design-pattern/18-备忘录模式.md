# 第18章：备忘录模式 (Memento Pattern)

## 概念解析

### 什么是备忘录模式？
备忘录模式在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

### 模式结构
- **Originator（原发器）**：创建一个备忘录，记录当前时刻的内部状态
- **Memento（备忘录）**：存储原发器对象的内部状态
- **Caretaker（管理者）**：负责保存备忘录，但不能对备忘录的内容进行操作或检查

## 应用场景
- 需要保存/恢复对象的状态
- 需要实现撤销操作
- 需要保存对象状态的快照
- 需要实现检查点功能

## 代码示例

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any
from datetime import datetime

# 备忘录接口
class Memento(ABC):
    @abstractmethod
    def get_state(self) -> Dict[str, Any]:
        pass
    
    @abstractmethod
    def get_name(self) -> str:
        pass
    
    @abstractmethod
    def get_date(self) -> str:
        pass

# 具体备忘录
class TextEditorMemento(Memento):
    def __init__(self, state: Dict[str, Any]):
        self.state = state
        self.date = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    def get_state(self) -> Dict[str, Any]:
        return self.state
    
    def get_name(self) -> str:
        return f"{self.date} / ({self.state['content'][:20]}...)"
    
    def get_date(self) -> str:
        return self.date

# 原发器 - 文本编辑器
class TextEditor:
    def __init__(self):
        self.content = ""
        self.cursor_position = 0
        self.font_size = 12
        self.font_family = "Arial"
    
    def type_text(self, text: str):
        """输入文本"""
        self.content += text
        self.cursor_position = len(self.content)
    
    def delete_text(self, length: int = 1):
        """删除文本"""
        if len(self.content) >= length:
            self.content = self.content[:-length]
            self.cursor_position = max(0, self.cursor_position - length)
    
    def set_font(self, size: int, family: str):
        """设置字体"""
        self.font_size = size
        self.font_family = family
    
    def save(self) -> Memento:
        """创建备忘录"""
        state = {
            "content": self.content,
            "cursor_position": self.cursor_position,
            "font_size": self.font_size,
            "font_family": self.font_family
        }
        return TextEditorMemento(state)
    
    def restore(self, memento: Memento):
        """从备忘录恢复状态"""
        state = memento.get_state()
        self.content = state["content"]
        self.cursor_position = state["cursor_position"]
        self.font_size = state["font_size"]
        self.font_family = state["font_family"]
    
    def display(self):
        """显示当前状态"""
        print(f"内容: {self.content}")
        print(f"光标位置: {self.cursor_position}")
        print(f"字体: {self.font_family} {self.font_size}pt")
        print("-" * 50)

# 管理者 - 历史记录管理器
class HistoryManager:
    def __init__(self):
        self.mementos: List[Memento] = []
        self.current_index = -1
    
    def push(self, memento: Memento):
        """保存备忘录"""
        # 如果当前不是最新状态，清除后面的历史
        if self.current_index < len(self.mementos) - 1:
            self.mementos = self.mementos[:self.current_index + 1]
        
        self.mementos.append(memento)
        self.current_index = len(self.mementos) - 1
    
    def undo(self) -> Memento:
        """撤销操作"""
        if self.current_index <= 0:
            raise IndexError("无法撤销，已经是最初状态")
        
        self.current_index -= 1
        return self.mementos[self.current_index]
    
    def redo(self) -> Memento:
        """重做操作"""
        if self.current_index >= len(self.mementos) - 1:
            raise IndexError("无法重做，已经是最新状态")
        
        self.current_index += 1
        return self.mementos[self.current_index]
    
    def show_history(self):
        """显示历史记录"""
        print("历史记录:")
        for i, memento in enumerate(self.mementos):
            marker = " <-- 当前" if i == self.current_index else ""
            print(f"{i}: {memento.get_name()}{marker}")

# 客户端代码
def main():
    # 创建文本编辑器和管理器
    editor = TextEditor()
    history = HistoryManager()
    
    print("=== 文本编辑器备忘录模式演示 ===\n")
    
    # 初始状态
    editor.type_text("Hello")
    history.push(editor.save())
    editor.display()
    
    # 继续编辑
    editor.type_text(", World!")
    editor.set_font(14, "Times New Roman")
    history.push(editor.save())
    editor.display()
    
    # 更多编辑
    editor.type_text(" This is a test.")
    history.push(editor.save())
    editor.display()
    
    # 显示历史
    history.show_history()
    
    # 测试撤销
    print("\n=== 执行撤销操作 ===")
    editor.restore(history.undo())
    editor.display()
    
    # 再次撤销
    print("\n=== 再次撤销 ===")
    editor.restore(history.undo())
    editor.display()
    
    # 测试重做
    print("\n=== 执行重做操作 ===")
    editor.restore(history.redo())
    editor.display()
    
    # 显示最终历史
    print("\n=== 最终历史记录 ===")
    history.show_history()

if __name__ == "__main__":
    main()
```

## 实际应用案例：游戏存档系统

```python
# 游戏存档系统中的备忘录模式
class GameStateMemento(Memento):
    def __init__(self, state: Dict[str, Any]):
        self.state = state
        self.timestamp = datetime.now()
    
    def get_state(self) -> Dict[str, Any]:
        return self.state
    
    def get_name(self) -> str:
        return f"存档 - {self.timestamp.strftime('%H:%M:%S')}"
    
    def get_date(self) -> str:
        return self.timestamp.strftime("%Y-%m-%d %H:%M:%S")

class GameCharacter:
    def __init__(self, name: str):
        self.name = name
        self.level = 1
        self.health = 100
        self.mana = 50
        self.experience = 0
        self.position = (0, 0)
        self.inventory = []
    
    def level_up(self):
        """升级"""
        self.level += 1
        self.health = 100 + (self.level - 1) * 20
        self.mana = 50 + (self.level - 1) * 10
        print(f"{self.name} 升级到 {self.level} 级！")
    
    def gain_experience(self, exp: int):
        """获得经验"""
        self.experience += exp
        if self.experience >= self.level * 100:
            self.level_up()
            self.experience = 0
    
    def move_to(self, x: int, y: int):
        """移动到指定位置"""
        self.position = (x, y)
    
    def add_item(self, item: str):
        """添加物品"""
        self.inventory.append(item)
    
    def save(self) -> Memento:
        """创建存档"""
        state = {
            "name": self.name,
            "level": self.level,
            "health": self.health,
            "mana": self.mana,
            "experience": self.experience,
            "position": self.position,
            "inventory": self.inventory.copy()
        }
        return GameStateMemento(state)
    
    def restore(self, memento: Memento):
        """从存档恢复"""
        state = memento.get_state()
        self.name = state["name"]
        self.level = state["level"]
        self.health = state["health"]
        self.mana = state["mana"]
        self.experience = state["experience"]
        self.position = state["position"]
        self.inventory = state["inventory"]
    
    def display_status(self):
        """显示状态"""
        print(f"角色: {self.name}")
        print(f"等级: {self.level}")
        print(f"生命值: {self.health}")
        print(f"魔法值: {self.mana}")
        print(f"经验值: {self.experience}/{self.level * 100}")
        print(f"位置: {self.position}")
        print(f"物品: {', '.join(self.inventory) if self.inventory else '无'}")
        print("-" * 50)

class SaveManager:
    def __init__(self):
        self.saves: List[Memento] = []
    
    def add_save(self, memento: Memento):
        """添加存档"""
        self.saves.append(memento)
    
    def get_save(self, index: int) -> Memento:
        """获取指定存档"""
        if 0 <= index < len(self.saves):
            return self.saves[index]
        raise IndexError("存档不存在")
    
    def list_saves(self):
        """列出所有存档"""
        print("存档列表:")
        for i, save in enumerate(self.saves):
            print(f"{i}: {save.get_name()}")

# 使用示例
def game_save_example():
    # 创建游戏角色和存档管理器
    player = GameCharacter("冒险者")
    save_manager = SaveManager()
    
    print("=== 游戏存档系统演示 ===\n")
    
    # 初始状态
    player.display_status()
    save_manager.add_save(player.save())
    
    # 游戏进程
    player.gain_experience(50)
    player.move_to(10, 5)
    player.add_item("木剑")
    player.display_status()
    save_manager.add_save(player.save())
    
    # 继续游戏
    player.gain_experience(80)  # 升级
    player.move_to(15, 8)
    player.add_item("治疗药水")
    player.display_status()
    save_manager.add_save(player.save())
    
    # 显示存档列表
    save_manager.list_saves()
    
    # 测试读取存档
    print("\n=== 读取第一个存档 ===")
    player.restore(save_manager.get_save(0))
    player.display_status()
    
    print("\n=== 读取最新存档 ===")
    player.restore(save_manager.get_save(2))
    player.display_status()

if __name__ == "__main__":
    game_save_example()
```

## 最佳实践

### 优点
- 提供了一种状态恢复机制
- 实现了信息的封装，原发器不需要暴露内部状态
- 简化了原发器类的职责

### 缺点
- 如果状态数据很大，会占用较多内存
- 管理者需要维护备忘录的生命周期
- 增加了系统的复杂性

### 适用场景
- 需要保存对象状态的快照
- 需要实现撤销操作
- 需要实现检查点功能
- 需要保存对象的历史状态

### 注意事项
- 考虑备忘录的存储大小和性能影响
- 合理设计备忘录的保存频率
- 注意备忘录的清理策略

## 扩展应用

备忘录模式还可以应用于：
- 数据库事务的回滚
- 文本编辑器的撤销/重做功能
- 图形编辑软件的历史记录
- 配置管理的版本控制
- 浏览器历史记录