# 第21章：策略模式 (Strategy Pattern)

## 概念解析

### 什么是策略模式？
策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换。策略模式让算法的变化独立于使用算法的客户。

### 模式结构
- **Strategy（策略）**：定义所有支持的算法的公共接口
- **ConcreteStrategy（具体策略）**：实现了策略接口的具体算法类
- **Context（上下文）**：用一个ConcreteStrategy对象来配置，维护一个对Strategy对象的引用

## 应用场景
- 许多相关的类仅仅是行为有异
- 需要使用一个算法的不同变体
- 算法使用客户不应该知道的数据
- 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现

## 代码示例

```python
from abc import ABC, abstractmethod
from typing import List

# 策略接口
class PaymentStrategy(ABC):
    @abstractmethod
    def pay(self, amount: float) -> bool:
        pass

# 具体策略 - 信用卡支付
class CreditCardPayment(PaymentStrategy):
    def __init__(self, card_number: str, expiry_date: str, cvv: str):
        self.card_number = card_number
        self.expiry_date = expiry_date
        self.cvv = cvv
    
    def pay(self, amount: float) -> bool:
        print(f"使用信用卡支付 {amount} 元")
        print(f"卡号: {self.card_number[-4:]}****")
        # 模拟支付处理
        print("信用卡支付处理中...")
        return True

# 具体策略 - PayPal支付
class PayPalPayment(PaymentStrategy):
    def __init__(self, email: str):
        self.email = email
    
    def pay(self, amount: float) -> bool:
        print(f"使用PayPal支付 {amount} 元")
        print(f"邮箱: {self.email}")
        # 模拟支付处理
        print("PayPal支付处理中...")
        return True

# 具体策略 - 比特币支付
class BitcoinPayment(PaymentStrategy):
    def __init__(self, wallet_address: str):
        self.wallet_address = wallet_address
    
    def pay(self, amount: float) -> bool:
        print(f"使用比特币支付 {amount} 元")
        print(f"钱包地址: {self.wallet_address}")
        # 模拟支付处理
        print("比特币交易处理中...")
        return True

# 具体策略 - 支付宝支付
class AlipayPayment(PaymentStrategy):
    def __init__(self, account: str):
        self.account = account
    
    def pay(self, amount: float) -> bool:
        print(f"使用支付宝支付 {amount} 元")
        print(f"账户: {self.account}")
        # 模拟支付处理
        print("支付宝支付处理中...")
        return True

# 上下文 - 支付处理器
class PaymentProcessor:
    def __init__(self):
        self.payment_strategy: PaymentStrategy = None
    
    def set_payment_strategy(self, strategy: PaymentStrategy):
        self.payment_strategy = strategy
    
    def process_payment(self, amount: float) -> bool:
        if self.payment_strategy is None:
            print("请先设置支付策略")
            return False
        
        print("=" * 40)
        result = self.payment_strategy.pay(amount)
        print("=" * 40)
        return result

# 客户端代码
def main():
    # 创建支付处理器
    processor = PaymentProcessor()
    
    # 创建不同的支付策略
    credit_card = CreditCardPayment("1234567812345678", "12/25", "123")
    paypal = PayPalPayment("user@example.com")
    bitcoin = BitcoinPayment("1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa")
    alipay = AlipayPayment("13800138000")
    
    amount = 100.0
    
    print("=== 策略模式支付演示 ===\n")
    
    # 测试不同的支付策略
    print("1. 信用卡支付:")
    processor.set_payment_strategy(credit_card)
    processor.process_payment(amount)
    
    print("\n2. PayPal支付:")
    processor.set_payment_strategy(paypal)
    processor.process_payment(amount)
    
    print("\n3. 比特币支付:")
    processor.set_payment_strategy(bitcoin)
    processor.process_payment(amount)
    
    print("\n4. 支付宝支付:")
    processor.set_payment_strategy(alipay)
    processor.process_payment(amount)

if __name__ == "__main__":
    main()
```

## 实际应用案例：排序算法策略

```python
# 排序算法策略模式实现
class SortStrategy(ABC):
    @abstractmethod
    def sort(self, data: List) -> List:
        pass

class BubbleSort(SortStrategy):
    def sort(self, data: List) -> List:
        print("使用冒泡排序")
        n = len(data)
        for i in range(n):
            for j in range(0, n - i - 1):
                if data[j] > data[j + 1]:
                    data[j], data[j + 1] = data[j + 1], data[j]
        return data

class QuickSort(SortStrategy):
    def sort(self, data: List) -> List:
        print("使用快速排序")
        if len(data) <= 1:
            return data
        
        pivot = data[len(data) // 2]
        left = [x for x in data if x < pivot]
        middle = [x for x in data if x == pivot]
        right = [x for x in data if x > pivot]
        
        return self.sort(left) + middle + self.sort(right)

class MergeSort(SortStrategy):
    def sort(self, data: List) -> List:
        print("使用归并排序")
        if len(data) <= 1:
            return data
        
        mid = len(data) // 2
        left = self.sort(data[:mid])
        right = self.sort(data[mid:])
        
        return self._merge(left, right)
    
    def _merge(self, left: List, right: List) -> List:
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result

class Sorter:
    def __init__(self):
        self.strategy: SortStrategy = None
    
    def set_strategy(self, strategy: SortStrategy):
        self.strategy = strategy
    
    def execute_sort(self, data: List) -> List:
        if self.strategy is None:
            print("请先设置排序策略")
            return data
        
        print(f"排序前: {data}")
        result = self.strategy.sort(data.copy())
        print(f"排序后: {result}")
        return result

# 使用示例
def sorting_example():
    sorter = Sorter()
    data = [64, 34, 25, 12, 22, 11, 90]
    
    print("=== 排序算法策略演示 ===\n")
    
    # 测试不同的排序策略
    print("1. 冒泡排序:")
    sorter.set_strategy(BubbleSort())
    sorter.execute_sort(data)
    
    print("\n2. 快速排序:")
    sorter.set_strategy(QuickSort())
    sorter.execute_sort(data)
    
    print("\n3. 归并排序:")
    sorter.set_strategy(MergeSort())
    sorter.execute_sort(data)

if __name__ == "__main__":
    sorting_example()
```

## 实际应用案例：压缩算法策略

```python
# 压缩算法策略模式实现
import zlib
import gzip
import bz2

class CompressionStrategy(ABC):
    @abstractmethod
    def compress(self, data: bytes) -> bytes:
        pass
    
    @abstractmethod
    def decompress(self, data: bytes) -> bytes:
        pass
    
    @abstractmethod
    def get_name(self) -> str:
        pass

class ZipCompression(CompressionStrategy):
    def compress(self, data: bytes) -> bytes:
        return zlib.compress(data)
    
    def decompress(self, data: bytes) -> bytes:
        return zlib.decompress(data)
    
    def get_name(self) -> str:
        return "ZIP"

class GzipCompression(CompressionStrategy):
    def compress(self, data: bytes) -> bytes:
        return gzip.compress(data)
    
    def decompress(self, data: bytes) -> bytes:
        return gzip.decompress(data)
    
    def get_name(self) -> str:
        return "GZIP"

class Bzip2Compression(CompressionStrategy):
    def compress(self, data: bytes) -> bytes:
        return bz2.compress(data)
    
    def decompress(self, data: bytes) -> bytes:
        return bz2.decompress(data)
    
    def get_name(self) -> str:
        return "BZIP2"

class CompressionContext:
    def __init__(self):
        self.strategy: CompressionStrategy = None
    
    def set_strategy(self, strategy: CompressionStrategy):
        self.strategy = strategy
    
    def compress_data(self, data: str) -> tuple:
        if self.strategy is None:
            raise ValueError("请先设置压缩策略")
        
        original_bytes = data.encode('utf-8')
        compressed_bytes = self.strategy.compress(original_bytes)
        
        original_size = len(original_bytes)
        compressed_size = len(compressed_bytes)
        compression_ratio = (compressed_size / original_size) * 100
        
        return compressed_bytes, original_size, compressed_size, compression_ratio
    
    def decompress_data(self, data: bytes) -> str:
        if self.strategy is None:
            raise ValueError("请先设置压缩策略")
        
        decompressed_bytes = self.strategy.decompress(data)
        return decompressed_bytes.decode('utf-8')

# 使用示例
def compression_example():
    context = CompressionContext()
    
    # 测试数据
    test_data = "Hello, World! " * 100  # 重复文本便于压缩
    
    print("=== 压缩算法策略演示 ===\n")
    print(f"原始数据大小: {len(test_data.encode('utf-8'))} 字节\n")
    
    # 测试不同的压缩策略
    strategies = [
        ZipCompression(),
        GzipCompression(),
        Bzip2Compression()
    ]
    
    for strategy in strategies:
        context.set_strategy(strategy)
        
        # 压缩
        compressed, original_size, compressed_size, ratio = context.compress_data(test_data)
        
        print(f"{strategy.get_name()} 压缩:")
        print(f"  原始大小: {original_size} 字节")
        print(f"  压缩大小: {compressed_size} 字节")
        print(f"  压缩率: {ratio:.2f}%")
        
        # 解压缩验证
        decompressed = context.decompress_data(compressed)
        assert decompressed == test_data, "解压缩数据不匹配"
        print(f"  解压缩验证: 成功\n")

if __name__ == "__main__":
    compression_example()
```

## 最佳实践

### 优点
- 算法可以自由切换
- 避免使用多重条件判断
- 扩展性良好
- 符合开闭原则

### 缺点
- 策略类会增多
- 所有策略类都需要对外暴露
- 客户端必须知道所有的策略类

### 适用场景
- 许多相关的类仅仅是行为有异
- 需要使用一个算法的不同变体
- 算法使用客户不应该知道的数据
- 一个类定义了多种行为

### 注意事项
- 如果策略对象没有状态，可以共享策略对象
- 考虑使用函数对象简化策略模式
- 注意策略选择的逻辑

## 扩展应用

策略模式还可以应用于：
- 验证规则系统
- 日志记录策略
- 缓存策略
- 数据分析算法
- 机器学习模型选择