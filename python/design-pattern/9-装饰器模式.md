# 第9章 装饰器模式 (Decorator Pattern)

## 1. 什么是装饰器模式？

装饰器模式是一种结构型设计模式，它允许你通过将对象放入包含行为的特殊封装对象中来为原对象添加新的行为。装饰器模式提供了比继承更有弹性的替代方案。

### 1.1 核心概念

- **组件 (Component)**: 定义对象的接口，可以动态地添加职责
- **具体组件 (ConcreteComponent)**: 定义一个对象，可以给这个对象添加一些职责
- **装饰器 (Decorator)**: 维持一个指向Component对象的引用，并定义一个与Component接口一致的接口
- **具体装饰器 (ConcreteDecorator)**: 向组件添加职责

### 1.2 现实世界类比

想象一杯咖啡：
- 基础咖啡是具体组件
- 你可以添加牛奶、糖、巧克力等装饰
- 每种装饰都改变了咖啡的味道和价格
- 你可以组合多种装饰，得到不同的咖啡

## 2. 装饰器模式的结构

```python
Component
    ↳ ConcreteComponent
    ↳ Decorator
        ↳ ConcreteDecoratorA
        ↳ ConcreteDecoratorB
```

### 2.1 参与者角色

1. **Component (组件)**: 定义一个对象接口，可以给这些对象动态地添加职责
2. **ConcreteComponent (具体组件)**: 定义一个对象，可以给这个对象添加一些职责
3. **Decorator (装饰器)**: 维持一个指向Component对象的引用，并定义一个与Component接口一致的接口
4. **ConcreteDecorator (具体装饰器)**: 向组件添加职责

## 3. 装饰器模式的实现

### 3.1 基础实现示例

让我们通过一个咖啡店的例子来理解装饰器模式：

```python
from abc import ABC, abstractmethod

# 组件接口 - 饮料
class Beverage(ABC):
    @abstractmethod
    def get_description(self):
        pass
    
    @abstractmethod
    def cost(self):
        pass

# 具体组件 - 浓缩咖啡
class Espresso(Beverage):
    def get_description(self):
        return "浓缩咖啡"
    
    def cost(self):
        return 1.99

# 具体组件 - 拿铁
class Latte(Beverage):
    def get_description(self):
        return "拿铁"
    
    def cost(self):
        return 2.49

# 装饰器基类
class CondimentDecorator(Beverage):
    def __init__(self, beverage):
        self.beverage = beverage
    
    @abstractmethod
    def get_description(self):
        pass

# 具体装饰器 - 牛奶
class Milk(CondimentDecorator):
    def get_description(self):
        return self.beverage.get_description() + ", 牛奶"
    
    def cost(self):
        return self.beverage.cost() + 0.10

# 具体装饰器 - 摩卡
class Mocha(CondimentDecorator):
    def get_description(self):
        return self.beverage.get_description() + ", 摩卡"
    
    def cost(self):
        return self.beverage.cost() + 0.20

# 具体装饰器 - 奶泡
class Whip(CondimentDecorator):
    def get_description(self):
        return self.beverage.get_description() + ", 奶泡"
    
    def cost(self):
        return self.beverage.cost() + 0.15

# 具体装饰器 - 豆浆
class Soy(CondimentDecorator):
    def get_description(self):
        return self.beverage.get_description() + ", 豆浆"
    
    def cost(self):
        return self.beverage.cost() + 0.15
```

### 3.2 使用示例

```python
# 创建基础饮料
espresso = Espresso()
print(f"{espresso.get_description()}: ${espresso.cost():.2f}")

# 添加装饰
espresso_with_mocha = Mocha(espresso)
print(f"{espresso_with_mocha.get_description()}: ${espresso_with_mocha.cost():.2f}")

# 组合多个装饰
espresso_with_mocha_and_whip = Whip(espresso_with_mocha)
print(f"{espresso_with_mocha_and_whip.get_description()}: ${espresso_with_mocha_and_whip.cost():.2f}")

# 另一个例子
latte = Latte()
latte_with_soy_and_whip = Whip(Soy(latte))
print(f"{latte_with_soy_and_whip.get_description()}: ${latte_with_soy_and_whip.cost():.2f}")
```

## 4. 装饰器模式的优势

### 4.1 优点

1. **比继承更灵活**: 装饰器模式提供了比继承更有弹性的扩展方式
2. **避免类爆炸**: 避免了使用继承带来的子类爆炸问题
3. **动态添加功能**: 可以在运行时动态地添加或删除功能
4. **符合开闭原则**: 对扩展开放，对修改关闭

### 4.2 缺点

1. **增加复杂性**: 会增加许多小对象，使系统更复杂
2. **调试困难**: 多层装饰可能使调试变得困难
3. **顺序依赖**: 装饰器的顺序可能影响最终结果

## 5. 实际应用场景

### 5.1 文本格式化系统

```python
from abc import ABC, abstractmethod

# 文本组件接口
class TextComponent(ABC):
    @abstractmethod
    def render(self):
        pass

# 具体组件 - 普通文本
class PlainText(TextComponent):
    def __init__(self, content):
        self.content = content
    
    def render(self):
        return self.content

# 文本装饰器基类
class TextDecorator(TextComponent):
    def __init__(self, text_component):
        self.text_component = text_component

# 具体装饰器 - 粗体
class BoldDecorator(TextDecorator):
    def render(self):
        return f"**{self.text_component.render()}**"

# 具体装饰器 - 斜体
class ItalicDecorator(TextDecorator):
    def render(self):
        return f"*{self.text_component.render()}*"

# 具体装饰器 - 下划线
class UnderlineDecorator(TextDecorator):
    def render(self):
        return f"__{self.text_component.render()}__"

# 具体装饰器 - 删除线
class StrikethroughDecorator(TextDecorator):
    def render(self):
        return f"~~{self.text_component.render()}~~"

# 使用示例
text = PlainText("Hello, World!")
print(f"原始文本: {text.render()}")

bold_text = BoldDecorator(text)
print(f"粗体文本: {bold_text.render()}")

italic_bold_text = ItalicDecorator(bold_text)
print(f"斜体粗体文本: {italic_bold_text.render()}")

underline_italic_bold_text = UnderlineDecorator(italic_bold_text)
print(f"下划线斜体粗体文本: {underline_italic_bold_text.render()}")

# 组合不同的装饰顺序
text2 = PlainText("装饰器模式")
styled_text = StrikethroughDecorator(UnderlineDecorator(ItalicDecorator(BoldDecorator(text2))))
print(f"多重装饰文本: {styled_text.render()}")
```

### 5.2 文件读写装饰器

```python
import gzip
import io
from abc import ABC, abstractmethod

# 数据源接口
class DataSource(ABC):
    @abstractmethod
    def write_data(self, data):
        pass
    
    @abstractmethod
    def read_data(self):
        pass

# 具体数据源 - 文件
class FileDataSource(DataSource):
    def __init__(self, filename):
        self.filename = filename
    
    def write_data(self, data):
        with open(self.filename, 'w', encoding='utf-8') as f:
            f.write(data)
        print(f"数据已写入文件: {self.filename}")
    
    def read_data(self):
        with open(self.filename, 'r', encoding='utf-8') as f:
            data = f.read()
        print(f"从文件读取数据: {self.filename}")
        return data

# 数据源装饰器基类
class DataSourceDecorator(DataSource):
    def __init__(self, source):
        self.wrappee = source

# 具体装饰器 - 加密装饰器
class EncryptionDecorator(DataSourceDecorator):
    def write_data(self, data):
        # 简单的加密（实际应用中应使用更安全的加密方法）
        encrypted_data = ''.join(chr(ord(c) + 1) for c in data)
        self.wrappee.write_data(encrypted_data)
    
    def read_data(self):
        encrypted_data = self.wrappee.read_data()
        # 解密
        decrypted_data = ''.join(chr(ord(c) - 1) for c in encrypted_data)
        return decrypted_data

# 具体装饰器 - 压缩装饰器
class CompressionDecorator(DataSourceDecorator):
    def write_data(self, data):
        # 使用gzip压缩
        compressed_data = gzip.compress(data.encode('utf-8'))
        # 将压缩数据转换为字符串（实际应用中应使用二进制文件）
        import base64
        compressed_str = base64.b64encode(compressed_data).decode('utf-8')
        self.wrappee.write_data(compressed_str)
    
    def read_data(self):
        compressed_str = self.wrappee.read_data()
        # 解压缩
        import base64
        compressed_data = base64.b64decode(compressed_str.encode('utf-8'))
        data = gzip.decompress(compressed_data).decode('utf-8')
        return data

# 使用示例
# 创建基础文件数据源
file_source = FileDataSource("example.txt")

# 添加加密装饰
encrypted_source = EncryptionDecorator(file_source)
encrypted_source.write_data("这是敏感数据")
print(f"读取加密数据: {encrypted_source.read_data()}")

# 添加压缩装饰
compressed_source = CompressionDecorator(file_source)
compressed_source.write_data("这是需要压缩的长文本数据" * 10)
print(f"读取压缩数据: {compressed_source.read_data()}")

# 组合加密和压缩
secure_source = EncryptionDecorator(CompressionDecorator(file_source))
secure_source.write_data("这是既需要加密又需要压缩的重要数据" * 5)
print(f"读取安全数据: {secure_source.read_data()}")
```

## 6. Python中的装饰器语法

Python内置支持装饰器语法，使得装饰器模式更加简洁：

### 6.1 函数装饰器

```python
# 简单的函数装饰器
def logger(func):
    def wrapper(*args, **kwargs):
        print(f"调用函数: {func.__name__}")
        result = func(*args, **kwargs)
        print(f"函数 {func.__name__} 执行完毕")
        return result
    return wrapper

@logger
def say_hello(name):
    print(f"Hello, {name}!")

@logger
def add_numbers(a, b):
    return a + b

# 使用装饰后的函数
say_hello("Alice")
result = add_numbers(5, 3)
print(f"计算结果: {result}")
```

### 6.2 带参数的装饰器

```python
# 带参数的装饰器
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for i in range(times):
                print(f"第 {i+1} 次执行:")
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    print(f"你好, {name}!")

greet("Bob")
```

### 6.3 类装饰器

```python
# 类装饰器
def singleton(cls):
    instances = {}
    def wrapper(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return wrapper

@singleton
class DatabaseConnection:
    def __init__(self):
        print("创建数据库连接")
    
    def query(self, sql):
        print(f"执行查询: {sql}")

# 测试单例模式
db1 = DatabaseConnection()
db2 = DatabaseConnection()
print(f"db1 is db2: {db1 is db2}")  # 应该输出 True
```

## 7. 装饰器模式与相关模式的比较

### 7.1 装饰器模式 vs 适配器模式

- **装饰器模式**: 改变对象的接口，但保持相同的接口
- **适配器模式**: 将一个接口转换成另一个接口

### 7.2 装饰器模式 vs 代理模式

- **装饰器模式**: 为对象添加功能
- **代理模式**: 控制对对象的访问

### 7.3 装饰器模式 vs 组合模式

- **装饰器模式**: 为单个对象添加功能
- **组合模式**: 处理对象集合

## 8. 最佳实践

### 8.1 何时使用装饰器模式

1. **动态添加功能**: 需要在运行时动态地给对象添加功能时
2. **避免子类爆炸**: 当使用继承会导致大量子类时
3. **功能组合**: 需要以各种方式组合功能时
4. **透明性要求**: 希望客户端代码不知道装饰器的存在时

### 8.2 实现建议

1. **保持接口一致性**: 装饰器应该与被装饰对象具有相同的接口
2. **避免过度装饰**: 过多的装饰层可能降低性能
3. **考虑装饰顺序**: 装饰器的顺序可能影响最终结果
4. **使用Python内置装饰器**: 在Python中优先使用语言内置的装饰器语法

## 9. 总结

装饰器模式是一种强大的结构型模式，它通过包装对象来动态地添加功能。这种模式特别适用于以下情况：

- 需要在运行时动态地给对象添加功能
- 避免使用继承导致的类爆炸问题
- 需要以灵活的方式组合功能
- 希望保持代码的开闭原则

在Python中，装饰器模式得到了语言层面的支持，使得实现更加简洁和优雅。通过合理使用装饰器模式，我们可以创建更加灵活和可扩展的系统。