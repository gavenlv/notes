# 第13章 责任链模式 (Chain of Responsibility Pattern)

## 1. 什么是责任链模式？

责任链模式是一种行为型设计模式，它允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。

### 1.1 核心概念

- **处理者 (Handler)**: 定义处理请求的接口，通常包含处理方法和设置下一个处理者的方法
- **具体处理者 (ConcreteHandler)**: 实现处理请求的具体逻辑，如果可以处理请求则处理，否则传递给下一个处理者
- **客户端 (Client)**: 创建处理链，并将请求发送到链的第一个处理者

### 1.2 现实世界类比

想象一个公司的审批流程：
- 员工提交报销申请
- 申请先由部门经理审批
- 如果金额超过部门经理权限，传递给财务总监
- 如果金额更大，传递给总经理
- 每个审批者都有明确的权限范围，形成一个审批链

## 2. 责任链模式的结构

```python
Handler
    ↳ ConcreteHandlerA
    ↳ ConcreteHandlerB
    ↳ ConcreteHandlerC
```

### 2.1 参与者角色

1. **Handler (处理者)**: 定义处理请求的接口
2. **ConcreteHandler (具体处理者)**: 处理它所负责的请求，可访问它的后继者
3. **Client (客户端)**: 向链上的具体处理者对象提交请求

## 3. 责任链模式的实现

### 3.1 基础实现示例

让我们通过一个日志系统的例子来理解责任链模式：

```python
from abc import ABC, abstractmethod
from enum import Enum

# 日志级别
class LogLevel(Enum):
    DEBUG = 1
    INFO = 2
    WARNING = 3
    ERROR = 4
    CRITICAL = 5

# 处理者抽象类
class Logger(ABC):
    def __init__(self, level):
        self.level = level
        self.next_logger = None
    
    def set_next(self, next_logger):
        self.next_logger = next_logger
        return next_logger  # 方便链式调用
    
    def log_message(self, level, message):
        if self.level.value <= level.value:
            self.write(message)
        
        if self.next_logger is not None:
            self.next_logger.log_message(level, message)
    
    @abstractmethod
    def write(self, message):
        pass

# 具体处理者 - 控制台日志
class ConsoleLogger(Logger):
    def write(self, message):
        print(f"控制台日志: {message}")

# 具体处理者 - 文件日志
class FileLogger(Logger):
    def __init__(self, level, filename):
        super().__init__(level)
        self.filename = filename
    
    def write(self, message):
        with open(self.filename, 'a') as f:
            f.write(f"文件日志: {message}\n")
        print(f"文件日志已写入: {message}")

# 具体处理者 - 错误日志（发送邮件）
class ErrorLogger(Logger):
    def write(self, message):
        # 模拟发送邮件
        print(f"错误邮件已发送: {message}")

# 具体处理者 - 数据库日志
class DatabaseLogger(Logger):
    def write(self, message):
        # 模拟写入数据库
        print(f"数据库日志已记录: {message}")
```

### 3.2 使用示例

```python
# 创建日志处理器链
console_logger = ConsoleLogger(LogLevel.DEBUG)
file_logger = FileLogger(LogLevel.INFO, "app.log")
error_logger = ErrorLogger(LogLevel.ERROR)
db_logger = DatabaseLogger(LogLevel.WARNING)

# 构建责任链
console_logger.set_next(file_logger).set_next(error_logger).set_next(db_logger)

print("=== 测试日志系统 ===")

# 测试不同级别的日志
console_logger.log_message(LogLevel.DEBUG, "这是一条调试信息")
print()

console_logger.log_message(LogLevel.INFO, "这是一条普通信息")
print()

console_logger.log_message(LogLevel.WARNING, "这是一条警告信息")
print()

console_logger.log_message(LogLevel.ERROR, "这是一条错误信息")
print()

console_logger.log_message(LogLevel.CRITICAL, "这是一条严重错误信息")
```

## 4. 责任链模式的优势

### 4.1 优点

1. **降低耦合度**: 请求发送者和接收者解耦
2. **增强灵活性**: 可以动态地改变链中的成员或调整次序
3. **简化对象**: 每个处理者只需关注自己的责任范围
4. **易于扩展**: 增加新的具体处理者很容易

### 4.2 缺点

1. **请求可能未被处理**: 如果链中没有合适的处理者，请求可能不会被处理
2. **性能影响**: 较长的链可能影响性能
3. **调试困难**: 请求的传递路径可能不明确

## 5. 实际应用场景

### 5.1 审批系统

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass

@dataclass
class PurchaseRequest:
    amount: float
    purpose: str
    requester: str

# 审批者抽象类
class Approver(ABC):
    def __init__(self, name, approval_limit):
        self.name = name
        self.approval_limit = approval_limit
        self.supervisor = None
    
    def set_supervisor(self, supervisor):
        self.supervisor = supervisor
    
    def process_request(self, request):
        if request.amount <= self.approval_limit:
            self.approve(request)
        elif self.supervisor is not None:
            print(f"{self.name} 无法审批 {request.amount} 元的请求，转交给 {self.supervisor.name}")
            self.supervisor.process_request(request)
        else:
            self.reject(request)
    
    def approve(self, request):
        print(f"{self.name} 批准了 {request.requester} 的 {request.amount} 元申请，用途: {request.purpose}")
    
    def reject(self, request):
        print(f"{self.name} 拒绝了 {request.requester} 的 {request.amount} 元申请，超出审批权限")

# 具体审批者
class Manager(Approver):
    def __init__(self, name):
        super().__init__(name, 1000)  # 经理审批限额1000元

class Director(Approver):
    def __init__(self, name):
        super().__init__(name, 5000)  # 总监审批限额5000元

class VP(Approver):
    def __init__(self, name):
        super().__init__(name, 10000)  # 副总裁审批限额10000元

class President(Approver):
    def __init__(self, name):
        super().__init__(name, float('inf'))  # 总裁无限制

# 使用审批系统
manager = Manager("张经理")
director = Director("李总监")
vp = VP("王副总裁")
president = President("陈总裁")

# 构建审批链
manager.set_supervisor(director)
director.set_supervisor(vp)
vp.set_supervisor(president)

print("=== 审批系统测试 ===")

# 测试不同金额的申请
requests = [
    PurchaseRequest(500, "购买办公用品", "员工A"),
    PurchaseRequest(2500, "团队建设", "员工B"),
    PurchaseRequest(7500, "设备采购", "员工C"),
    PurchaseRequest(20000, "项目投资", "员工D")
]

for request in requests:
    print(f"\n处理申请: {request.purpose}, 金额: {request.amount}元")
    manager.process_request(request)
```

### 5.2 输入验证系统

```python
from abc import ABC, abstractmethod

class ValidationError(Exception):
    def __init__(self, message):
        super().__init__(message)
        self.message = message

# 验证器抽象类
class Validator(ABC):
    def __init__(self):
        self.next_validator = None
    
    def set_next(self, validator):
        self.next_validator = validator
        return validator
    
    def validate(self, data):
        self._validate(data)
        if self.next_validator is not None:
            self.next_validator.validate(data)
    
    @abstractmethod
    def _validate(self, data):
        pass

# 具体验证器
class RequiredValidator(Validator):
    def _validate(self, data):
        if not data.get('username') or not data.get('password'):
            raise ValidationError("用户名和密码不能为空")
        print("✓ 必填字段验证通过")

class LengthValidator(Validator):
    def _validate(self, data):
        username = data.get('username', '')
        password = data.get('password', '')
        
        if len(username) < 3:
            raise ValidationError("用户名长度不能少于3个字符")
        if len(password) < 6:
            raise ValidationError("密码长度不能少于6个字符")
        
        print("✓ 长度验证通过")

class FormatValidator(Validator):
    def _validate(self, data):
        username = data.get('username', '')
        
        if not username.isalnum():
            raise ValidationError("用户名只能包含字母和数字")
        
        print("✓ 格式验证通过")

class SecurityValidator(Validator):
    def _validate(self, data):
        password = data.get('password', '')
        
        # 简单的密码强度检查
        has_upper = any(c.isupper() for c in password)
        has_lower = any(c.islower() for c in password)
        has_digit = any(c.isdigit() for c in password)
        
        if not (has_upper and has_lower and has_digit):
            raise ValidationError("密码必须包含大小写字母和数字")
        
        print("✓ 安全验证通过")

# 使用验证系统
required_validator = RequiredValidator()
length_validator = LengthValidator()
format_validator = FormatValidator()
security_validator = SecurityValidator()

# 构建验证链
required_validator.set_next(length_validator).set_next(format_validator).set_next(security_validator)

print("=== 用户注册验证系统 ===")

test_cases = [
    {"username": "", "password": ""},  # 空数据
    {"username": "ab", "password": "123"},  # 长度不足
    {"username": "user@123", "password": "Password123"},  # 格式错误
    {"username": "user123", "password": "password"},  # 安全性不足
    {"username": "user123", "password": "Password123"}  # 有效数据
]

for i, data in enumerate(test_cases, 1):
    print(f"\n测试案例 {i}: username='{data['username']}', password='{data['password']}'")
    try:
        required_validator.validate(data)
        print("✅ 所有验证通过！")
    except ValidationError as e:
        print(f"❌ 验证失败: {e}")
```

## 6. 责任链模式的变体

### 6.1 纯责任链模式

在纯责任链模式中，一个请求必须被某个处理者对象接收：

```python
class PureHandler(ABC):
    def __init__(self):
        self.next_handler = None
    
    def set_next(self, handler):
        self.next_handler = handler
    
    def handle(self, request):
        handled = self.process(request)
        if not handled and self.next_handler is not None:
            return self.next_handler.handle(request)
        return handled
    
    @abstractmethod
    def process(self, request):
        pass

class ConcreteHandlerA(PureHandler):
    def process(self, request):
        if request == "A":
            print("Handler A 处理了请求")
            return True
        return False

class ConcreteHandlerB(PureHandler):
    def process(self, request):
        if request == "B":
            print("Handler B 处理了请求")
            return True
        return False

class DefaultHandler(PureHandler):
    def process(self, request):
        print(f"默认处理器处理了请求: {request}")
        return True

# 使用纯责任链
handler_a = ConcreteHandlerA()
handler_b = ConcreteHandlerB()
default_handler = DefaultHandler()

handler_a.set_next(handler_b).set_next(default_handler)

requests = ["A", "B", "C", "D"]
for req in requests:
    print(f"\n处理请求: {req}")
    handler_a.handle(req)
```

### 6.2 功能链模式

每个处理者都处理请求，然后传递给下一个处理者：

```python
class FunctionalHandler:
    def __init__(self, name, process_func):
        self.name = name
        self.process_func = process_func
        self.next_handler = None
    
    def set_next(self, handler):
        self.next_handler = handler
    
    def handle(self, data):
        # 当前处理器处理数据
        result = self.process_func(data)
        print(f"{self.name} 处理结果: {result}")
        
        # 传递给下一个处理器
        if self.next_handler is not None:
            return self.next_handler.handle(result)
        return result

# 创建功能链
to_upper = FunctionalHandler("大写转换", lambda x: x.upper())
add_prefix = FunctionalHandler("添加前缀", lambda x: "前缀_" + x)
add_suffix = FunctionalHandler("添加后缀", lambda x: x + "_后缀")

# 构建链
to_upper.set_next(add_prefix).set_next(add_suffix)

# 处理数据
result = to_upper.handle("hello world")
print(f"最终结果: {result}")
```

## 7. 责任链模式与相关模式的比较

### 7.1 责任链模式 vs 命令模式

- **责任链模式**: 多个对象都有机会处理请求
- **命令模式**: 将请求封装为对象，支持撤销、排队等操作

### 7.2 责任链模式 vs 组合模式

- **责任链模式**: 处理请求的链式结构
- **组合模式**: 部分-整体的层次结构

### 7.3 责任链模式 vs 装饰器模式

- **责任链模式**: 多个处理器依次处理请求
- **装饰器模式**: 动态地为对象添加功能

## 8. 最佳实践

### 8.1 何时使用责任链模式

1. **多个对象可以处理请求**: 有多个对象可以处理请求，但具体由哪个对象处理在运行时确定
2. **不想明确指定接收者**: 不希望明确指定请求的接收者
3. **可动态指定处理者**: 需要动态指定一组对象处理请求
4. **处理流程需要灵活变化**: 处理流程可能需要动态调整

### 8.2 实现建议

1. **明确责任范围**: 每个处理者应该有明确的责任范围
2. **提供默认处理**: 考虑提供默认处理者来处理未被处理的请求
3. **控制链的长度**: 避免创建过长的处理链影响性能
4. **考虑异常处理**: 妥善处理处理链中的异常情况
5. **支持动态调整**: 支持动态添加、删除或重新排序处理者

## 9. 总结

责任链模式是一种灵活的行为型模式，它通过将多个处理者连接成一条链，让请求沿着链传递，直到被某个处理者处理。这种模式特别适用于以下情况：

- 有多个对象可以处理请求，但不确定具体由哪个对象处理
- 需要动态指定请求的处理流程
- 希望请求发送者与接收者解耦
- 处理流程需要灵活调整

通过合理使用责任链模式，我们可以创建灵活、可扩展的处理系统，同时保持代码的清晰和可维护性。