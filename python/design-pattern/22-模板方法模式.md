# 第22章：模板方法模式 (Template Method Pattern)

## 概念解析

### 什么是模板方法模式？
模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

### 模式结构
- **AbstractClass（抽象类）**：定义抽象的原语操作，具体的子类将重定义它们以实现一个算法的各步骤；实现一个模板方法，定义一个算法的骨架
- **ConcreteClass（具体类）**：实现原语操作以完成算法中与特定子类相关的步骤

## 应用场景
- 一次性实现一个算法的不变部分，并将可变的行为留给子类来实现
- 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复
- 控制子类扩展

## 代码示例

```python
from abc import ABC, abstractmethod

# 抽象类 - 数据处理器模板
class DataProcessor(ABC):
    """数据处理器模板类"""
    
    def process(self, data):
        """模板方法 - 定义处理流程"""
        print("=== 开始数据处理 ===")
        
        # 步骤1: 验证数据
        self._validate_data(data)
        
        # 步骤2: 预处理数据
        processed_data = self._preprocess_data(data)
        
        # 步骤3: 核心处理（由子类实现）
        result = self._process_core(processed_data)
        
        # 步骤4: 后处理
        final_result = self._postprocess_data(result)
        
        # 步骤5: 清理资源
        self._cleanup()
        
        print("=== 数据处理完成 ===")
        return final_result
    
    def _validate_data(self, data):
        """验证数据（通用实现）"""
        if data is None:
            raise ValueError("数据不能为空")
        print("✓ 数据验证通过")
    
    def _preprocess_data(self, data):
        """预处理数据（通用实现）"""
        print("✓ 数据预处理完成")
        return data
    
    @abstractmethod
    def _process_core(self, data):
        """核心处理逻辑（由子类实现）"""
        pass
    
    def _postprocess_data(self, result):
        """后处理数据（通用实现）"""
        print("✓ 数据后处理完成")
        return result
    
    def _cleanup(self):
        """清理资源（通用实现）"""
        print("✓ 资源清理完成")

# 具体类 - 数值数据处理器
class NumericalDataProcessor(DataProcessor):
    def _process_core(self, data):
        """数值数据的核心处理逻辑"""
        print("正在处理数值数据...")
        
        # 计算统计信息
        total = sum(data)
        average = total / len(data)
        maximum = max(data)
        minimum = min(data)
        
        result = {
            "total": total,
            "average": average,
            "maximum": maximum,
            "minimum": minimum,
            "count": len(data)
        }
        
        return result

# 具体类 - 文本数据处理器
class TextDataProcessor(DataProcessor):
    def _process_core(self, data):
        """文本数据的核心处理逻辑"""
        print("正在处理文本数据...")
        
        # 文本分析
        words = data.split()
        word_count = len(words)
        char_count = len(data)
        unique_words = len(set(words))
        
        # 找到最长的单词
        longest_word = max(words, key=len) if words else ""
        
        result = {
            "word_count": word_count,
            "char_count": char_count,
            "unique_words": unique_words,
            "longest_word": longest_word,
            "avg_word_length": char_count / word_count if word_count > 0 else 0
        }
        
        return result
    
    def _preprocess_data(self, data):
        """重写预处理方法 - 文本数据需要特殊处理"""
        print("✓ 文本数据预处理（转换为小写，去除标点）")
        # 简单的预处理：转换为小写，去除标点
        import re
        processed = data.lower()
        processed = re.sub(r'[^\w\s]', '', processed)
        return processed

# 具体类 - 图像数据处理器
class ImageDataProcessor(DataProcessor):
    def _process_core(self, data):
        """图像数据的核心处理逻辑"""
        print("正在处理图像数据...")
        
        # 模拟图像处理
        result = {
            "width": data.get("width", 0),
            "height": data.get("height", 0),
            "format": data.get("format", "unknown"),
            "size_kb": data.get("size", 0) / 1024,
            "processed_pixels": data.get("width", 0) * data.get("height", 0)
        }
        
        return result
    
    def _validate_data(self, data):
        """重写验证方法 - 图像数据需要特殊验证"""
        super()._validate_data(data)
        
        if not isinstance(data, dict):
            raise ValueError("图像数据必须是字典格式")
        
        if "width" not in data or "height" not in data:
            raise ValueError("图像数据必须包含宽度和高度信息")
        
        print("✓ 图像数据验证通过")

# 客户端代码
def main():
    print("=== 模板方法模式演示 ===\n")
    
    # 测试数值数据处理
    print("1. 数值数据处理:")
    numerical_data = [10, 20, 30, 40, 50]
    numerical_processor = NumericalDataProcessor()
    result1 = numerical_processor.process(numerical_data)
    print(f"处理结果: {result1}\n")
    
    # 测试文本数据处理
    print("2. 文本数据处理:")
    text_data = "Hello World! This is a test of template method pattern."
    text_processor = TextDataProcessor()
    result2 = text_processor.process(text_data)
    print(f"处理结果: {result2}\n")
    
    # 测试图像数据处理
    print("3. 图像数据处理:")
    image_data = {
        "width": 1920,
        "height": 1080,
        "format": "JPEG",
        "size": 2048000
    }
    image_processor = ImageDataProcessor()
    result3 = image_processor.process(image_data)
    print(f"处理结果: {result3}\n")

if __name__ == "__main__":
    main()
```

## 实际应用案例：游戏角色模板

```python
# 游戏角色模板模式实现
class GameCharacter(ABC):
    """游戏角色模板类"""
    
    def __init__(self, name: str, level: int = 1):
        self.name = name
        self.level = level
        self.health = 100
        self.mana = 50
    
    def perform_action_sequence(self):
        """模板方法 - 定义角色行动序列"""
        print(f"\n=== {self.name} 的行动序列 ===")
        
        # 步骤1: 准备阶段
        self._prepare()
        
        # 步骤2: 主要行动（由子类实现）
        self._main_action()
        
        # 步骤3: 特殊技能（由子类实现）
        self._special_skill()
        
        # 步骤4: 结束阶段
        self._conclude()
    
    def _prepare(self):
        """准备阶段（通用实现）"""
        print(f"{self.name} 准备行动...")
        print(f"  生命值: {self.health}")
        print(f"  魔法值: {self.mana}")
    
    @abstractmethod
    def _main_action(self):
        """主要行动（由子类实现）"""
        pass
    
    @abstractmethod
    def _special_skill(self):
        """特殊技能（由子类实现）"""
        pass
    
    def _conclude(self):
        """结束阶段（通用实现）"""
        print(f"{self.name} 行动结束")
        print("-" * 40)

class Warrior(GameCharacter):
    """战士角色"""
    
    def _main_action(self):
        """战士的主要行动 - 近战攻击"""
        damage = self.level * 10
        print(f"战士 {self.name} 使用近战攻击，造成 {damage} 点伤害")
    
    def _special_skill(self):
        """战士的特殊技能 - 狂暴"""
        if self.mana >= 20:
            self.mana -= 20
            print(f"战士 {self.name} 使用狂暴技能，攻击力提升!")
        else:
            print("魔法值不足，无法使用狂暴技能")

class Mage(GameCharacter):
    """法师角色"""
    
    def _main_action(self):
        """法师的主要行动 - 魔法攻击"""
        damage = self.level * 8
        mana_cost = 15
        
        if self.mana >= mana_cost:
            self.mana -= mana_cost
            print(f"法师 {self.name} 使用火球术，造成 {damage} 点魔法伤害")
        else:
            print("魔法值不足，使用普通攻击")
    
    def _special_skill(self):
        """法师的特殊技能 - 治疗"""
        if self.mana >= 30:
            self.mana -= 30
            heal_amount = 25
            self.health = min(100, self.health + heal_amount)
            print(f"法师 {self.name} 使用治疗术，恢复 {heal_amount} 点生命值")
        else:
            print("魔法值不足，无法使用治疗术")

class Archer(GameCharacter):
    """弓箭手角色"""
    
    def _main_action(self):
        """弓箭手的主要行动 - 远程攻击"""
        damage = self.level * 7
        print(f"弓箭手 {self.name} 使用弓箭射击，造成 {damage} 点远程伤害")
    
    def _special_skill(self):
        """弓箭手的特殊技能 - 精准射击"""
        if self.mana >= 25:
            self.mana -= 25
            critical_damage = self.level * 15
            print(f"弓箭手 {self.name} 使用精准射击，造成 {critical_damage} 点暴击伤害")
        else:
            print("魔法值不足，无法使用精准射击")

# 使用示例
def game_character_example():
    print("=== 游戏角色模板方法演示 ===\n")
    
    # 创建不同职业的角色
    warrior = Warrior("亚瑟", level=5)
    mage = Mage("梅林", level=3)
    archer = Archer("罗宾", level=4)
    
    # 执行行动序列
    warrior.perform_action_sequence()
    mage.perform_action_sequence()
    archer.perform_action_sequence()
    
    # 测试魔法值不足的情况
    print("\n=== 测试魔法值不足的情况 ===")
    low_mana_mage = Mage("学徒", level=1)
    low_mana_mage.mana = 10  # 设置低魔法值
    low_mana_mage.perform_action_sequence()

if __name__ == "__main__":
    game_character_example()
```

## 实际应用案例：构建工具模板

```python
# 构建工具模板模式实现
import os
import shutil
from abc import ABC, abstractmethod

class BuildTool(ABC):
    """构建工具模板类"""
    
    def build_project(self, project_path: str, output_dir: str):
        """模板方法 - 定义构建流程"""
        print(f"=== 开始构建项目: {project_path} ===")
        
        # 步骤1: 验证项目结构
        self._validate_project(project_path)
        
        # 步骤2: 安装依赖
        self._install_dependencies(project_path)
        
        # 步骤3: 运行测试
        self._run_tests(project_path)
        
        # 步骤4: 编译项目（由子类实现）
        self._compile_project(project_path)
        
        # 步骤5: 打包构建结果
        build_artifact = self._package_build(project_path, output_dir)
        
        # 步骤6: 生成构建报告
        self._generate_report(build_artifact)
        
        print("=== 项目构建完成 ===")
        return build_artifact
    
    def _validate_project(self, project_path: str):
        """验证项目结构（通用实现）"""
        if not os.path.exists(project_path):
            raise FileNotFoundError(f"项目路径不存在: {project_path}")
        
        required_files = self._get_required_files()
        for file in required_files:
            file_path = os.path.join(project_path, file)
            if not os.path.exists(file_path):
                raise FileNotFoundError(f"必需文件不存在: {file}")
        
        print("✓ 项目结构验证通过")
    
    @abstractmethod
    def _get_required_files(self) -> list:
        """获取项目必需文件列表（由子类实现）"""
        pass
    
    def _install_dependencies(self, project_path: str):
        """安装依赖（通用实现）"""
        print("✓ 安装项目依赖")
        # 模拟依赖安装
        # 实际实现会调用具体的包管理工具
    
    def _run_tests(self, project_path: str):
        """运行测试（通用实现）"""
        print("✓ 运行项目测试")
        # 模拟测试运行
        # 实际实现会调用测试框架
    
    @abstractmethod
    def _compile_project(self, project_path: str):
        """编译项目（由子类实现）"""
        pass
    
    def _package_build(self, project_path: str, output_dir: str) -> str:
        """打包构建结果（通用实现）"""
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        
        artifact_name = f"{os.path.basename(project_path)}_build.zip"
        artifact_path = os.path.join(output_dir, artifact_name)
        
        print(f"✓ 打包构建结果: {artifact_path}")
        return artifact_path
    
    def _generate_report(self, build_artifact: str):
        """生成构建报告（通用实现）"""
        print("✓ 生成构建报告")
        # 模拟报告生成

class PythonBuildTool(BuildTool):
    """Python项目构建工具"""
    
    def _get_required_files(self) -> list:
        return ["requirements.txt", "setup.py"]
    
    def _compile_project(self, project_path: str):
        """Python项目编译"""
        print("正在编译Python项目...")
        # Python通常是解释型语言，编译步骤可能包括代码检查、类型检查等
        print("✓ Python项目编译完成")

class JavaBuildTool(BuildTool):
    """Java项目构建工具"""
    
    def _get_required_files(self) -> list:
        return ["pom.xml", "src"]
    
    def _compile_project(self, project_path: str):
        """Java项目编译"""
        print("正在编译Java项目...")
        # 模拟Java编译过程
        print("✓ Java项目编译完成")
    
    def _run_tests(self, project_path: str):
        """重写测试方法 - Java项目需要特殊处理"""
        print("✓ 运行Java单元测试")
        # Java项目通常使用JUnit等测试框架

class WebBuildTool(BuildTool):
    """Web项目构建工具"""
    
    def _get_required_files(self) -> list:
        return ["package.json", "src"]
    
    def _compile_project(self, project_path: str):
        """Web项目构建"""
        print("正在构建Web项目...")
        # 模拟Web项目构建过程（打包、压缩、优化等）
        print("✓ Web项目构建完成")
    
    def _install_dependencies(self, project_path: str):
        """重写依赖安装 - Web项目使用npm/yarn"""
        print("✓ 使用npm安装依赖")
        # Web项目通常使用npm或yarn

# 使用示例
def build_tool_example():
    print("=== 构建工具模板方法演示 ===\n")
    
    # 模拟项目路径
    python_project = "/fake/path/python_project"
    java_project = "/fake/path/java_project"
    web_project = "/fake/path/web_project"
    output_dir = "/fake/output"
    
    # 测试Python项目构建
    print("1. Python项目构建:")
    python_tool = PythonBuildTool()
    try:
        python_tool.build_project(python_project, output_dir)
    except FileNotFoundError as e:
        print(f"构建失败: {e}")
    
    print("\n2. Java项目构建:")
    java_tool = JavaBuildTool()
    try:
        java_tool.build_project(java_project, output_dir)
    except FileNotFoundError as e:
        print(f"构建失败: {e}")
    
    print("\n3. Web项目构建:")
    web_tool = WebBuildTool()
    try:
        web_tool.build_project(web_project, output_dir)
    except FileNotFoundError as e:
        print(f"构建失败: {e}")

if __name__ == "__main__":
    build_tool_example()
```

## 最佳实践

### 优点
- 封装不变部分，扩展可变部分
- 行为由父类控制，子类实现
- 代码复用，提高开发效率
- 符合开闭原则

### 缺点
- 每一个不同的实现都需要一个子类，导致类的个数增加
- 父类与子类之间的协作需要良好的设计
- 模板方法中的步骤越多，其维护工作就可能会越困难

### 适用场景
- 有多个子类共有的方法，且逻辑基本相同
- 重要、复杂的算法，可以把核心算法设计为模板方法
- 需要通过子类来决定父类算法中某个步骤是否执行

### 注意事项
- 模板方法应该声明为final，防止子类重写
- 抽象方法应该声明为protected
- 合理设计钩子方法（hook methods）

## 扩展应用

模板方法模式还可以应用于：
- 框架设计
- 工作流引擎
- 测试框架
- 数据处理管道
- 游戏引擎