# 第6章 任务调度与监控

## 6.1 调度策略与配置

### 6.1.1 调度类型

#### 6.1.1.1 定时调度

定时调度是基于Cron表达式的调度方式，可以精确控制工作流的执行时间。

```java
// 定时调度管理
public class ScheduleManager {
    
    // 创建定时调度
    public Schedule createSchedule(ProcessDefinition processDefinition, String cronExpression) {
        Schedule schedule = new Schedule();
        schedule.setProcessDefinitionId(processDefinition.getId());
        schedule.setCronExpression(cronExpression);
        schedule.setStartTime(new Date());
        schedule.setEndTime(null); // 永久有效
        schedule.setTimezoneId("Asia/Shanghai");
        
        // 计算下次执行时间
        Date nextExecutionTime = calculateNextExecutionTime(cronExpression);
        schedule.setNextFireTime(nextExecutionTime);
        
        return scheduleDao.save(schedule);
    }
    
    // 计算下次执行时间
    private Date calculateNextExecutionTime(String cronExpression) {
        try {
            CronExpression cron = new CronExpression(cronExpression);
            return cron.getNextValidTimeAfter(new Date());
        } catch (ParseException e) {
            throw new RuntimeException("Invalid cron expression", e);
        }
    }
}
```

#### 6.1.1.2 手动触发

手动触发允许用户通过UI或API立即执行工作流。

```java
// 手动触发工作流
public class ManualTrigger {
    
    public ProcessInstance triggerWorkflow(int processDefinitionId, 
                                         Map<String, Object> parameters) {
        List<ProcessInstance> instances = new ArrayList<>();
        
        for (Integer processDefinitionId : processDefinitionIds) {
            try {
                ProcessInstance instance = triggerWorkflow(processDefinitionId, parameters);
                instances.add(instance);
            } catch (Exception e) {
                // 记录失败的工作流
                logger.error("Failed to trigger workflow: " + processDefinitionId, e);
            }
        }
        
        return instances;
    }
}
```

#### 6.1.1.3 依赖触发

依赖触发基于特定条件自动触发工作流执行。

```java
// 依赖触发管理
public class DependencyTriggerManager {
    
    // 创建依赖触发
    public DependencyTrigger createDependencyTrigger(int processDefinitionId, 
                                                   List<DependencyCondition> conditions) {
        DependencyTrigger trigger = new DependencyTrigger();
        trigger.setProcessDefinitionId(processDefinitionId);
        trigger.setConditions(conditions);
        trigger.setStatus(DependencyTriggerStatus.ACTIVE);
        trigger.setCreateTime(new Date());
        
        return dependencyTriggerDao.save(trigger);
    }
    
    // 检查依赖条件
    public boolean checkDependencyConditions(int triggerId) {
        DependencyTrigger trigger = dependencyTriggerDao.findById(triggerId);
        if (trigger == null || trigger.getStatus() != DependencyTriggerStatus.ACTIVE) {
            return false;
        }
        
        for (DependencyCondition condition : trigger.getConditions()) {
            if (!checkCondition(condition)) {
                return false;
            }
        }
        
        return true;
    }
    
    // 检查单个条件
    private boolean checkCondition(DependencyCondition condition) {
        switch (condition.getType()) {
            case DATA_READY:
                return checkDataReady(condition.getDataCondition());
            case TIME_REACHED:
                return checkTimeReached(condition.getTargetTime());
            default:
                return false;
        }
    }
}
```

### 6.1.2 优先级调度

DolphinScheduler支持基于优先级的任务调度，确保重要任务优先执行。

```java
// 优先级调度实现
public class PriorityScheduler {
    
    // 优先级队列
    private PriorityQueue<TaskInstance> highPriorityQueue = 
        new PriorityQueue<>(100, new TaskPriorityComparator(PriorityLevel.HIGH));
    private PriorityQueue<TaskInstance> mediumPriorityQueue = 
        new PriorityQueue<>(100, new TaskPriorityComparator(PriorityLevel.MEDIUM));
    private PriorityQueue<TaskInstance> lowPriorityQueue = 
        new PriorityQueue<>(100, new TaskPriorityComparator(PriorityLevel.LOW));
    
    // 添加任务到优先级队列
    public void addTask(TaskInstance task) {
        PriorityLevel priority = getTaskPriority(task);
        
        switch (priority) {
            case HIGH:
                highPriorityQueue.offer(task);
                break;
            case MEDIUM:
                mediumPriorityQueue.offer(task);
                break;
            case LOW:
                lowPriorityQueue.offer(task);
                break;
        }
    }
    
    // 获取任务优先级
    private PriorityLevel getTaskPriority(TaskInstance task) {
        // 1. 检查任务优先级
        TaskDefinition taskDefinition = taskDefinitionDao.findById(task.getTaskCode());
        if (taskDefinition != null) {
            return PriorityLevel.fromCode(taskDefinition.getPriority());
        }
        
        // 2. 检查工作流优先级
        ProcessInstance processInstance = processInstanceDao.findById(task.getProcessInstanceId());
        if (processInstance != null) {
            ProcessDefinition processDefinition = processDefinitionDao
                .findById(processInstance.getProcessDefinitionId());
            if (processDefinition != null) {
                return PriorityLevel.fromCode(processDefinition.getPriority());
            }
        }
        
        // 3. 默认中等优先级
        return PriorityLevel.MEDIUM;
    }
}

// 优先级枚举
public enum PriorityLevel {
    HIGH(10, "高优先级"),
    MEDIUM(5, "中等优先级"),
    LOW(1, "低优先级");
    
    private final int code;
    private final String description;
    
    PriorityLevel(int code, String description) {
        this.code = code;
        this.description = description;
    }
    
    public static PriorityLevel fromCode(int code) {
        for (PriorityLevel priority : values()) {
            if (priority.getCode() == code) {
                return priority;
            }
        }
        return PriorityLevel.MEDIUM;
    }
}
```

## 6.2 失败重试机制

### 6.2.1 重试策略

DolphinScheduler提供多种重试策略，确保任务在遇到临时故障时能够自动恢复。

```java
// 重试配置
public class RetryConfiguration {
    
    private int maxRetryTimes = 3;       // 最大重试次数
    private int retryInterval = 60;     // 重试间隔（秒）
    private RetryStrategy retryStrategy = RetryStrategy.FIXED_INTERVAL;
    private List<ExecutionStatus> retryableStatuses;
    
    // 重试策略枚举
    public enum RetryStrategy {
        FIXED_INTERVAL,    // 固定间隔重试
        EXPONENTIAL_BACKOFF, // 指数退避重试
        LINEAR_BACKOFF    // 线性退避重试
    }
    
    // 计算下次重试时间
    public Date calculateNextRetryTime(int currentRetryCount) {
        long intervalMs;
        
        switch (retryStrategy) {
            case FIXED_INTERVAL:
                intervalMs = retryInterval * 1000L;
                break;
                
            case EXPONENTIAL_BACKOFF:
                intervalMs = (long) (retryInterval * 1000 * Math.pow(2, currentRetryCount));
                intervalMs = Math.min(intervalMs, 60 * 60 * 1000L); // 最大1小时
                break;
                
            case LINEAR_BACKOFF:
                intervalMs = retryInterval * 1000L * (currentRetryCount + 1);
                break;
                
            default:
                intervalMs = retryInterval * 1000L;
        }
        
        return new Date(System.currentTimeMillis() + intervalMs);
    }
}

// 重试处理器
public class RetryHandler {
    
    // 处理任务重试
    public void handleTaskRetry(TaskInstance task) {
        // 1. 检查是否超过最大重试次数
        RetryConfiguration retryConfig = getRetryConfiguration(task);
        if (task.getRetryTimes() >= retryConfig.getMaxRetryTimes()) {
            markTaskAsFailed(task);
            return;
        }
        
        // 2. 计算下次重试时间
        Date nextRetryTime = retryConfig.calculateNextRetryTime(task.getRetryTimes());
        
        // 3. 更新任务状态
        task.setState(ExecutionStatus.RETRY_DELAY);
        task.setNextRetryTime(nextRetryTime);
        task.setRetryTimes(task.getRetryTimes() + 1);
        taskInstanceDao.update(task);
        
        // 4. 添加到重试队列
        retryQueueService.addRetryTask(task);
        
        // 5. 记录重试日志
        logRetryEvent(task);
    }
    
    // 获取重试配置
    private RetryConfiguration getRetryConfiguration(TaskInstance task) {
        // 1. 检查任务级重试配置
        TaskDefinition taskDefinition = taskDefinitionDao.findById(task.getTaskCode());
        if (taskDefinition != null && taskDefinition.getFailRetryInterval() > 0) {
            RetryConfiguration config = new RetryConfiguration();
            config.setMaxRetryTimes(taskDefinition.getMaxRetryTimes());
            config.setRetryInterval(taskDefinition.getFailRetryInterval());
            config.setRetryStrategy(RetryConfiguration.RetryStrategy.FIXED_INTERVAL);
            config.setRetryableStatuses(Arrays.asList(ExecutionStatus.FAILURE));
            return config;
        }
        
        // 2. 检查工作流级重试配置
        ProcessInstance processInstance = processInstanceDao.findById(task.getProcessInstanceId());
        if (processInstance != null) {
            ProcessDefinition processDefinition = processDefinitionDao
                .findById(processInstance.getProcessDefinitionId());
            if (processDefinition != null && processDefinition.getFailRetryInterval() > 0) {
                RetryConfiguration config = new RetryConfiguration();
                config.setMaxRetryTimes(processDefinition.getMaxRetryTimes());
                config.setRetryInterval(processDefinition.getFailRetryInterval());
                config.setRetryStrategy(RetryConfiguration.RetryStrategy.FIXED_INTERVAL);
                config.setRetryableStatuses(Arrays.asList(ExecutionStatus.FAILURE));
                return config;
            }
        }
        
        // 3. 使用默认重试配置
        RetryConfiguration defaultConfig = new RetryConfiguration();
        defaultConfig.setMaxRetryTimes(3);
        defaultConfig.setRetryInterval(60);
        defaultConfig.setRetryStrategy(RetryConfiguration.RetryStrategy.EXPONENTIAL_BACKOFF);
        defaultConfig.setRetryableStatuses(Arrays.asList(ExecutionStatus.FAILURE));
        
        return defaultConfig;
    }
    
    // 标记任务为失败
    private void markTaskAsFailed(TaskInstance task) {
        task.setState(ExecutionStatus.FAILURE);
        task.setEndTime(new Date());
        taskInstanceDao.update(task);
        
        // 检查工作流是否需要停止
        checkWorkflowFailure(task);
    }
    
    // 检查工作流失败
    private void checkWorkflowFailure(TaskInstance task) {
        ProcessInstance processInstance = processInstanceDao.findById(task.getProcessInstanceId());
        if (processInstance == null) {
            return;
        }
        
        // 获取工作流失败策略
        FailureStrategy failureStrategy = getFailureStrategy(processInstance);
        
        // 如果任务失败需要停止工作流
        if (failureStrategy == FailureStrategy.STOP_ON_FAILURE) {
            processInstance.setState(ExecutionStatus.FAILURE);
            processInstance.setEndTime(new Date());
            processInstanceDao.update(processInstance);
            
            // 取消其他正在运行的任务
            cancelRunningTasks(processInstance);
        }
    }
}
```

### 6.2.2 容错机制

#### 6.2.2.1 节点容错

```java
// 节点容错处理
public class NodeFailoverHandler {
    
    // 处理Worker节点故障
    public void handleWorkerFailover(String workerAddress) {
        // 1. 查找该Worker上运行的任务
        List<TaskInstance> runningTasks = findRunningTasksByWorker(workerAddress);
        
        // 2. 将任务状态标记为未知
        for (TaskInstance task : runningTasks) {
            task.setState(ExecutionStatus.UNKNOWN);
            task.setEndTime(new Date());
            taskInstanceDao.update(task);
        }
        
        // 3. 触发任务重新调度
        rescheduleTasks(runningTasks);
        
        // 4. 发送告警通知
        alertService.sendFailoverNotification(workerAddress, runningTasks);
    }
    
    // 重新调度任务
    private void rescheduleTasks(List<TaskInstance> tasks) {
        for (TaskInstance task : tasks) {
            // 检查是否可以重试
            if (task.getRetryTimes() < task.getMaxRetryTimes()) {
                // 重置任务状态
                task.setState(ExecutionStatus.WAITING_RUN);
                task.setRetryTimes(task.getRetryTimes() + 1);
                taskInstanceDao.update(task);
                
                // 添加到调度队列
                schedulerService.addTaskToQueue(task);
            }
        }
    }
}
```

#### 6.2.2.2 数据库容错

```java
// 数据库容错处理
public class DatabaseFailoverHandler {
    
    private List<DataSource> primaryDataSources;
    private List<DataSource> standbyDataSources;
    private DataSource currentDataSource;
    private boolean isFailoverMode = false;
    private int maxRetries = 3;
    private int retryInterval = 5000; // 5秒
    
    // 执行数据库操作
    public <T> T executeWithFailover(DatabaseOperation<T> operation) {
        int retryCount = 0;
        Exception lastException = null;
        
        while (retryCount < maxRetries) {
            try {
                return operation.execute(currentDataSource);
            } catch (Exception e) {
                lastException = e;
                retryCount++;
                
                logger.warn("Database operation failed, retry count: " + retryCount, e);
                
                // 等待后重试
                if (retryCount < maxRetries) {
                    try {
                        Thread.sleep(retryInterval);
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        throw new RuntimeException("Operation interrupted", ie);
                    }
                    
                    // 尝试切换到备用数据库
                    if (triggerFailover()) {
                        logger.info("Switched to standby database");
                    }
                }
            }
        }
        
        throw new RuntimeException("Database operation failed after maximum retries");
    }
    
    // 触发故障转移
    private boolean triggerFailover() {
        if (!isFailoverMode) {
            // 从主数据库切换到备用数据库
            if (!standbyDataSources.isEmpty()) {
                currentDataSource = standbyDataSources.get(0);
                isFailoverMode = true;
                return true;
            }
        } else {
            // 在备用数据库之间切换
            int currentIndex = standbyDataSources.indexOf(currentDataSource);
            int nextIndex = (currentIndex + 1) % standbyDataSources.size();
            currentDataSource = standbyDataSources.get(nextIndex);
            return true;
        }
        
        return false;
    }
    
    // 尝试恢复主数据库连接
    public void tryRecoverPrimaryDatabase() {
        if (isFailoverMode) {
            for (DataSource primaryDataSource : primaryDataSources) {
                if (testConnection(primaryDataSource)) {
                    // 主数据库恢复，切换回主数据库
                    currentDataSource = primaryDataSource;
                    isFailoverMode = false;
                    
                    // 发送恢复通知
                    sendRecoveryNotification();
                    break;
                }
            }
        }
    }
}
```

## 6.3 数据补数机制

### 6.3.1 补数概述

数据补数机制允许重新执行历史日期的工作流，用于修复历史数据错误或补充缺失的数据。

### 6.3.2 补数实现

```java
// 数据补数管理
public class DataMakeupManager {
    
    // 创建补数计划
    public DataMakeupPlan createMakeupPlan(MakeupRequest request) {
        // 1. 验证补数日期
        List<Date> makeupDates = generateMakeupDates(request.getStartDate(), 
                                                    request.getEndDate(), 
                                                    request.getDatePattern());
        
        // 2. 检查工作流定义
        ProcessDefinition processDefinition = processDefinitionDao
            .findById(request.getProcessDefinitionId());
        if (processDefinition == null) {
            throw new RuntimeException("Process definition not found");
        }
        
        // 3. 创建补数计划
        DataMakeupPlan plan = new DataMakeupPlan();
        plan.setProcessDefinitionId(request.getProcessDefinitionId());
        plan.setProcessDefinitionName(processDefinition.getName());
        plan.setMakeupDates(makeupDates);
        plan.setStatus(MakeupPlanStatus.PENDING);
        plan.setCreateTime(new Date());
        plan.setCreateUser(request.getCreateUser());
        
        // 4. 检查补数冲突
        checkMakeupConflicts(plan);
        
        return dataMakeupPlanDao.save(plan);
    }
    
    // 生成补数日期
    private List<Date> generateMakeupDates(Date startDate, Date endDate, String datePattern) {
        List<Date> dates = new ArrayList<>();
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(startDate);
        
        while (!calendar.getTime().after(endDate)) {
            Date currentDate = calendar.getTime();
            
            // 根据日期模式筛选日期
            if (matchDatePattern(currentDate, datePattern)) {
                dates.add((Date) currentDate.clone());
            }
            
            // 移动到下一天
            calendar.add(Calendar.DAY_OF_MONTH, 1);
        }
        
        return dates;
    }
    
    // 执行补数计划
    public void executeMakeupPlan(int planId) {
        DataMakeupPlan plan = dataMakeupPlanDao.findById(planId);
        if (plan == null || plan.getStatus() != MakeupPlanStatus.PENDING) {
            throw new RuntimeException("Makeup plan not found or not in pending status");
        }
        
        // 更新计划状态
        plan.setStatus(MakeupPlanStatus.RUNNING);
        plan.setStartTime(new Date());
        dataMakeupPlanDao.update(plan);
        
        // 为每个补数日期创建工作流实例
        for (Date makeupDate : plan.getMakeupDates()) {
            try {
                createMakeupInstance(plan, makeupDate);
            } catch (Exception e) {
                logger.error("Failed to create makeup instance for date: " + makeupDate, e);
            }
        }
        
        // 更新计划状态
        plan.setStatus(MakeupPlanStatus.COMPLETED);
        plan.setEndTime(new Date());
        dataMakeupPlanDao.update(plan);
    }
    
    // 创建补数实例
    private void createMakeupInstance(DataMakeupPlan plan, Date makeupDate) {
        // 1. 准备工作流参数
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("bizDate", formatDate(makeupDate));
        parameters.put("makeupFlag", "true");
        
        // 2. 创建工作流实例
        ProcessInstance instance = new ProcessInstance();
        instance.setProcessDefinitionId(plan.getProcessDefinitionId());
        instance.setParameters(JsonUtils.toJsonString(parameters));
        instance.setScheduleTime(makeupDate);
        instance.setFlag(YesNo.YES);
        instance.setState(ExecutionStatus.RUNNING_EXECUTION);
        instance.setStartTime(new Date());
        
        // 3. 保存工作流实例
        processInstanceDao.save(instance);
        
        // 4. 触发工作流执行
        triggerWorkflowExecution(instance);
    }
}
```

## 6.4 监控系统

### 6.4.1 任务监控

#### 6.4.1.1 任务状态监控

```java
// 任务状态监控
public class TaskStatusMonitor {
    
    // 监控任务状态变化
    public void monitorTaskStatusChange(TaskInstance task, ExecutionStatus oldStatus, 
                                       ExecutionStatus newStatus) {
        // 1. 记录状态变化
        logStatusChange(task, oldStatus, newStatus);
        
        // 2. 更新性能指标
        updatePerformanceMetrics(task, oldStatus, newStatus);
        
        // 3. 检查告警条件
        checkAlertConditions(task, newStatus);
        
        // 4. 更新统计信息
        updateStatistics(task, newStatus);
    }
    
    // 更新性能指标
    private void updatePerformanceMetrics(TaskInstance task, ExecutionStatus oldStatus, 
                                         ExecutionStatus newStatus) {
        if (newStatus == ExecutionStatus.SUCCESS || newStatus == ExecutionStatus.FAILURE) {
            // 计算执行时间
            long duration = task.getEndTime().getTime() - task.getStartTime().getTime();
            
            // 更新任务执行时间指标
            Metrics.gauge("task.execution.duration", duration, 
                         Tags.of("taskType", task.getTaskType()));
            
            // 更新任务成功/失败指标
            if (newStatus == ExecutionStatus.SUCCESS) {
                Metrics.counter("task.success", 
                               Tags.of("taskType", task.getTaskType())).increment();
            } else {
                Metrics.counter("task.failure", 
                               Tags.of("taskType", task.getTaskType())).increment();
            }
        }
    }
    
    // 检查告警条件
    private void checkAlertConditions(TaskInstance task, ExecutionStatus status) {
        // 1. 任务失败告警
        if (status == ExecutionStatus.FAILURE) {
            if (task.getRetryTimes() >= task.getMaxRetryTimes()) {
                alertService.sendTaskFailureAlert(task);
            }
        }
        
        // 2. 任务执行超时告警
        if (status == ExecutionStatus.RUNNING_EXECUTION) {
            long runningTime = System.currentTimeMillis() - task.getStartTime().getTime();
            if (runningTime > task.getMaxExecutionTime()) {
                alertService.sendTaskTimeoutAlert(task);
            }
        }
        
        // 3. 任务重试次数过多告警
        if (task.getRetryTimes() > 3) {
            alertService.sendTaskRetryAlert(task);
        }
    }
}
```

#### 6.4.1.2 性能监控

```java
// 性能监控
public class PerformanceMonitor {
    
    // 监控系统性能
    public SystemPerformanceStats collectSystemPerformance() {
        SystemPerformanceStats stats = new SystemPerformanceStats();
        
        // 1. CPU使用率
        double cpuUsage = getCpuUsage();
        stats.setCpuUsage(cpuUsage);
        
        // 2. 内存使用率
        double memoryUsage = getMemoryUsage();
        stats.setMemoryUsage(memoryUsage);
        
        // 3. 磁盘使用率
        double diskUsage = getDiskUsage();
        stats.setDiskUsage(diskUsage);
        
        // 4. 网络IO
        NetworkIOStats networkIO = getNetworkIOStats();
        stats.setNetworkIO(networkIO);
        
        // 5. JVM内存
        JVMMemoryStats jvmMemory = getJVMMemoryStats();
        stats.setJvmMemory(jvmMemory);
        
        // 6. 数据库连接池状态
        DBConnectionPoolStats dbPoolStats = getDBConnectionPoolStats();
        stats.setDbPoolStats(dbPoolStats);
        
        return stats;
    }
    
    // 监控队列状态
    public QueueStatusStats collectQueueStatus() {
        QueueStatusStats stats = new QueueStatusStats();
        
        // 1. 获取任务队列长度
        stats.setHighPriorityQueueSize(scheduler.getHighPriorityQueueSize());
        stats.setMediumPriorityQueueSize(scheduler.getMediumPriorityQueueSize());
        stats.setLowPriorityQueueSize(scheduler.getLowPriorityQueueSize());
        
        // 2. 获取等待中的任务数
        stats.setWaitingTasks(taskInstanceDao.countByStatus(ExecutionStatus.WAITING_RUN));
        
        // 3. 获取正在运行的任务数
        stats.setRunningTasks(taskInstanceDao.countByStatus(ExecutionStatus.RUNNING_EXECUTION));
        
        return stats;
    }
}
```

### 6.4.2 告警系统

#### 6.4.2.1 告警规则配置

```java
// 告警规则管理
public class AlertRuleManager {
    
    // 创建告警规则
    public AlertRule createAlertRule(AlertRuleCreateRequest request) {
        AlertRule rule = new AlertRule();
        rule.setName(request.getName());
        rule.setDescription(request.getDescription());
        rule.setRuleType(request.getRuleType());
        rule.setConditions(request.getConditions());
        rule.setActions(request.getActions());
        rule.setEnabled(request.isEnabled());
        rule.setCreateTime(new Date());
        rule.setCreateUser(request.getCreateUser());
        
        // 验证规则有效性
        validateRule(rule);
        
        return alertRuleDao.save(rule);
    }
    
    // 验证告警规则
    private void validateRule(AlertRule rule) {
        // 1. 检查规则名称唯一性
        if (alertRuleDao.existsByName(rule.getName())) {
            throw new RuntimeException("Alert rule name already exists");
        }
        
        // 2. 检查条件有效性
        if (rule.getConditions() == null || rule.getConditions().isEmpty()) {
            throw new RuntimeException("Alert rule must have at least one condition");
        }
        
        // 3. 检查动作有效性
        if (rule.getActions() == null || rule.getActions().isEmpty()) {
            throw new RuntimeException("Alert rule must have at least one action");
        }
    }
    
    // 评估告警规则
    public List<AlertEvent> evaluateRules(MonitoringData data) {
        List<AlertEvent> events = new ArrayList<>();
        
        // 获取所有启用的告警规则
        List<AlertRule> rules = alertRuleDao.findByEnabled(true);
        
        for (AlertRule rule : rules) {
            // 检查规则条件是否满足
            if (evaluateConditions(rule.getConditions(), data)) {
                // 创建告警事件
                AlertEvent event = new AlertEvent();
                event.setRuleId(rule.getId());
                event.setRuleName(rule.getName());
                event.setSeverity(rule.getSeverity());
                event.setMessage(formatAlertMessage(rule, data));
                event.setCreateTime(new Date());
                event.setStatus(AlertEventStatus.OPEN);
                
                events.add(event);
                
                // 执行告警动作
                executeAlertActions(rule.getActions(), event);
            }
        }
        
        return events;
    }
    
    // 评估条件
    private boolean evaluateConditions(List<AlertCondition> conditions, MonitoringData data) {
        for (AlertCondition condition : conditions) {
            if (!evaluateCondition(condition, data)) {
                return false;
            }
        }
        return true;
    }
}
```

#### 6.4.2.2 告警动作执行

```java
// 告警动作执行
public class AlertActionExecutor {
    
    // 执行告警动作
    public void executeAlertActions(List<AlertAction> actions, AlertEvent event) {
        for (AlertAction action : actions) {
            try {
                executeAction(action, event);
            } catch (Exception e) {
                logger.error("Failed to execute alert action: " + action.getType(), e);
            }
        }
    }
    
    // 执行单个动作
    private void executeAction(AlertAction action, AlertEvent event) {
        switch (action.getType()) {
            case EMAIL:
                sendEmailAlert(action, event);
                break;
            case SMS:
                sendSmsAlert(action, event);
                break;
            case WEBHOOK:
                sendWebhookAlert(action, event);
                break;
            case DINGTALK:
                sendDingTalkAlert(action, event);
                break;
            case SLACK:
                sendSlackAlert(action, event);
                break;
            default:
                logger.warn("Unknown alert action type: " + action.getType());
        }
    }
    
    // 发送邮件告警
    private void sendEmailAlert(AlertAction action, AlertEvent event) {
        EmailAlertConfig config = JsonUtils.parseObject(action.getConfiguration(), 
            EmailAlertConfig.class);
        
        EmailMessage message = new EmailMessage();
        message.setTo(config.getRecipients());
        message.setSubject(config.getSubjectPrefix() + event.getRuleName());
        message.setBody(formatEmailBody(event));
        
        emailService.send(message);
    }
    
    // 发送钉钉告警
    private void sendDingTalkAlert(AlertAction action, AlertEvent event) {
        DingTalkAlertConfig config = JsonUtils.parseObject(action.getConfiguration(), 
            DingTalkAlertConfig.class);
        
        DingTalkMessage message = new DingTalkMessage();
        message.setMsgtype("markdown");
        
        MarkdownContent content = new MarkdownContent();
        content.setTitle(event.getRuleName());
        content.setText(formatDingTalkMarkdown(event));
        message.setMarkdown(content);
        
        dingTalkService.sendMessage(config.getWebhookUrl(), message);
    }
}
```

## 6.5 实践案例

### 6.5.1 大规模数据处理监控

#### 6.5.1.1 场景描述

一个企业有大量数据处理工作流，需要建立完善的监控系统确保任务稳定运行。

#### 6.5.1.2 监控方案设计

```java
// 大规模数据处理监控系统
public class LargeScaleMonitoringSystem {
    
    // 设置多级监控
    public void setupMultiLevelMonitoring() {
        // 1. 设置任务级监控
        setupTaskLevelMonitoring();
        
        // 2. 设置工作流级监控
        setupWorkflowLevelMonitoring();
        
        // 3. 设置系统级监控
        setupSystemLevelMonitoring();
        
        // 4. 设置业务级监控
        setupBusinessLevelMonitoring();
    }
    
    // 设置任务级监控
    private void setupTaskLevelMonitoring() {
        // 1. 任务执行时间监控
        createTaskDurationAlert();
        
        // 2. 任务失败率监控
        createTaskFailureRateAlert();
        
        // 3. 任务重试次数监控
        createTaskRetryAlert();
        
        // 4. 任务资源使用监控
        createTaskResourceUsageAlert();
    }
    
    // 创建任务执行时间告警
    private void createTaskDurationAlert() {
        AlertRule rule = new AlertRule();
        rule.setName("任务执行时间过长");
        rule.setDescription("任务执行时间超过阈值时触发告警");
        rule.setSeverity(AlertSeverity.WARNING);
        
        List<AlertCondition> conditions = new ArrayList<>();
        AlertCondition condition = new AlertCondition();
        condition.setMetric("task.execution.duration");
        condition.setOperator(">");
        condition.setThreshold("3600000"); // 1小时
        condition.setEvaluationPeriods(1);
        conditions.add(condition);
        
        rule.setConditions(conditions);
        
        List<AlertAction> actions = new ArrayList<>();
        AlertAction emailAction = new AlertAction();
        emailAction.setType(AlertActionType.EMAIL);
        emailAction.setConfiguration("{\"recipients\":[\"admin@example.com\"]}");
        actions.add(emailAction);
        
        rule.setActions(actions);
        alertRuleManager.createAlertRule(rule);
    }
    
    // 设置工作流级监控
    private void setupWorkflowLevelMonitoring() {
        // 1. 工作流执行成功率监控
        createWorkflowSuccessRateAlert();
        
        // 2. 工作流完成时间监控
        createWorkflowCompletionTimeAlert();
        
        // 3. 工作流队列等待时间监控
        createWorkflowQueueTimeAlert();
    }
    
    // 设置系统级监控
    private void setupSystemLevelMonitoring() {
        // 1. Master/Worker节点状态监控
        createNodeStatusAlert();
        
        // 2. 系统资源使用监控
        createSystemResourceAlert();
        
        // 3. 数据库连接监控
        createDatabaseConnectionAlert();
    }
    
    // 设置业务级监控
    private void setupBusinessLevelMonitoring() {
        // 1. 数据质量监控
        createDataQualityAlert();
        
        // 2. SLA监控
        createSLAAlert();
        
        // 3. 数据延迟监控
        createDataDelayAlert();
    }
}
```

### 6.5.2 自动故障恢复系统

#### 6.5.2.1 场景描述

当系统出现故障时，需要自动进行故障检测和恢复，减少人工干预。

#### 6.5.2.2 故障恢复系统设计

```java
// 自动故障恢复系统
public class AutoFailureRecoverySystem {
    
    // 处理系统故障
    public void handleSystemFailure(FailureEvent event) {
        switch (event.getType()) {
            case WORKER_FAILURE:
                handleWorkerFailure(event);
                break;
            case DATABASE_CONNECTION_FAILURE:
                handleDatabaseFailure(event);
                break;
            case RESOURCE_EXHAUSTION:
                handleResourceExhaustion(event);
                break;
            case WORKFLOW_FAILURE:
                handleWorkflowFailure(event);
                break;
            default:
                logger.warn("Unknown failure type: " + event.getType());
        }
    }
    
    // 处理Worker故障
    private void handleWorkerFailure(FailureEvent event) {
        String workerAddress = event.getWorkerAddress();
        
        // 1. 检查Worker节点状态
        boolean isWorkerAlive = checkWorkerHealth(workerAddress);
        
        if (!isWorkerAlive) {
            // 2. 查找该Worker上运行的任务
            List<TaskInstance> runningTasks = taskInstanceDao
                .findByWorkerAndStatus(workerAddress, ExecutionStatus.RUNNING_EXECUTION);
            
            // 3. 将任务重新分配给其他Worker
            redistributeTasks(runningTasks);
            
            // 4. 从可用Worker列表中移除故障节点
            workerManager.removeWorker(workerAddress);
            
            // 5. 发送告警通知
            alertService.sendWorkerFailureNotification(workerAddress, runningTasks);
        }
    }
    
    // 处理数据库故障
    private void handleDatabaseFailure(FailureEvent event) {
        // 1. 尝试重新连接数据库
        boolean isDatabaseAvailable = databaseFailoverHandler.tryReconnect();
        
        if (!isDatabaseAvailable) {
            // 2. 触发故障转移
            boolean failoverSuccess = databaseFailoverHandler.triggerFailover();
            
            if (failoverSuccess) {
                // 3. 暂停任务调度
                schedulerService.pauseScheduling();
                
                // 4. 恢复数据库服务
                databaseFailoverHandler.attemptRecovery();
                
                // 5. 恢复任务调度
                schedulerService.resumeScheduling();
                
                // 6. 发送告警通知
                alertService.sendDatabaseFailoverNotification();
            }
        }
    }
    
    // 处理资源耗尽
    private void handleResourceExhaustion(FailureEvent event) {
        String resourceType = event.getResourceType();
        String nodeAddress = event.getNodeAddress();
        
        switch (resourceType) {
            case "CPU":
                handleCPUExhaustion(nodeAddress);
                break;
            case "MEMORY":
                handleMemoryExhaustion(nodeAddress);
                break;
            case "DISK":
                handleDiskExhaustion(nodeAddress);
                break;
        }
    }
    
    // 处理CPU耗尽
    private void handleCPUExhaustion(String nodeAddress) {
        // 1. 降低节点上任务的调度优先级
        schedulerService.lowerNodePriority(nodeAddress);
        
        // 2. 查找CPU密集型任务
        List<TaskInstance> cpuIntensiveTasks = findCPUIntensiveTasks(nodeAddress);
        
        // 3. 将部分任务迁移到其他节点
        migrateTasks(cpuIntensiveTasks);
        
        // 4. 发送告警通知
        alertService.sendCPUExhaustionNotification(nodeAddress);
    }
    
    // 处理工作流故障
    private void handleWorkflowFailure(FailureEvent event) {
        int workflowInstanceId = event.getWorkflowInstanceId();
        
        // 1. 分析工作流失败原因
        FailureAnalysis analysis = analyzeWorkflowFailure(workflowInstanceId);
        
        // 2. 根据失败原因选择恢复策略
        RecoveryStrategy strategy = selectRecoveryStrategy(analysis);
        
        // 3. 执行恢复策略
        executeRecoveryStrategy(workflowInstanceId, strategy);
    }
    
    // 分析工作流失败原因
    private FailureAnalysis analyzeWorkflowFailure(int workflowInstanceId) {
        ProcessInstance instance = processInstanceDao.findById(workflowInstanceId);
        if (instance == null) {
            return FailureAnalysis.notFound();
        }
        
        // 1. 检查失败的任务
        List<TaskInstance> failedTasks = taskInstanceDao
            .findByProcessIdAndStatus(workflowInstanceId, ExecutionStatus.FAILURE);
        
        // 2. 分析失败原因
        Map<String, Integer> failureReasons = new HashMap<>();
        for (TaskInstance task : failedTasks) {
            String reason = analyzeTaskFailure(task);
            failureReasons.put(reason, failureReasons.getOrDefault(reason, 0) + 1);
        }
        
        // 3. 确定主要失败原因
        String primaryReason = failureReasons.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse("unknown");
        
        return new FailureAnalysis(primaryReason, failureReasons, failedTasks.size());
    }
}
```

## 6.6 小结

本章详细介绍了DolphinScheduler的任务调度与监控系统：

1. **调度策略与配置**：定时调度、手动触发、依赖触发和优先级调度
2. **失败重试机制**：多种重试策略和容错处理
3. **数据补数机制**：历史数据补数和恢复
4. **监控系统**：任务监控、性能监控和告警系统
5. **实践案例**：大规模数据处理监控和自动故障恢复系统

通过本章的学习，您应该能够：

- 配置不同类型的调度策略
- 设置合理的重试机制
- 使用数据补数功能修复历史数据
- 建立完善的监控告警系统
- 设计自动故障恢复机制

在下一章中，我们将介绍DolphinScheduler的数据源管理与资源中心。