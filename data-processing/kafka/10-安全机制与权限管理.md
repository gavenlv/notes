# 第10章：安全机制与权限管理

## 目录
1. [Kafka安全概述](#kafka安全概述)
2. [SSL/TLS加密配置](#ssltls加密配置)
3. [SASL认证机制](#sasl认证机制)
4. [ACL权限控制](#acl权限控制)
5. [审计日志与监控](#审计日志与监控)
6. [网络安全配置](#网络安全配置)
7. [密钥管理](#密钥管理)
8. [安全最佳实践](#安全最佳实践)
9. [实战案例](#实战案例)

## Kafka安全概述

### 安全威胁模型

在分布式消息系统中，主要面临以下安全威胁：

- **数据窃听**：网络流量被恶意监听
- **身份冒充**：未授权用户访问系统
- **数据篡改**：消息在传输过程中被恶意修改
- **拒绝服务**：恶意攻击导致系统不可用
- **权限提升**：低权限用户获取更高权限

### Kafka安全架构

Kafka提供了多层安全机制：

1. **传输层安全**：SSL/TLS加密通信
2. **认证层安全**：SASL身份验证
3. **授权层安全**：ACL权限控制
4. **审计层安全**：操作日志记录

```java
/**
 * Kafka安全架构管理类
 */
public class KafkaSecurityManager {
    
    /**
     * 安全配置验证器
     */
    public static class SecurityConfigValidator {
        
        public enum SecurityLevel {
            NONE("无安全"),
            BASIC("基础安全"),
            STANDARD("标准安全"),
            HIGH("高安全"),
            ENTERPRISE("企业级安全");
            
            private final String description;
            
            SecurityLevel(String description) {
                this.description = description;
            }
            
            public String getDescription() { return description; }
        }
        
        public static class SecurityConfig {
            private final SecurityLevel level;
            private final boolean sslEnabled;
            private final boolean saslEnabled;
            private final boolean aclEnabled;
            private final boolean encryptionEnabled;
            private final boolean auditEnabled;
            private final List<String> enabledFeatures;
            
            public SecurityConfig(SecurityLevel level, boolean sslEnabled, 
                                boolean saslEnabled, boolean aclEnabled,
                                boolean encryptionEnabled, boolean auditEnabled) {
                this.level = level;
                this.sslEnabled = sslEnabled;
                this.saslEnabled = saslEnabled;
                this.aclEnabled = aclEnabled;
                this.encryptionEnabled = encryptionEnabled;
                this.auditEnabled = auditEnabled;
                this.enabledFeatures = computeEnabledFeatures();
            }
            
            private List<String> computeEnabledFeatures() {
                List<String> features = new ArrayList<>();
                if (sslEnabled) features.add("SSL/TLS");
                if (saslEnabled) features.add("SASL");
                if (aclEnabled) features.add("ACL");
                if (encryptionEnabled) features.add("数据加密");
                if (auditEnabled) features.add("审计日志");
                return features;
            }
            
            public SecurityLevel getLevel() { return level; }
            public boolean isSslEnabled() { return sslEnabled; }
            public boolean isSaslEnabled() { return saslEnabled; }
            public boolean isAclEnabled() { return aclEnabled; }
            public boolean isEncryptionEnabled() { return encryptionEnabled; }
            public boolean isAuditEnabled() { return auditEnabled; }
            public List<String> getEnabledFeatures() { return enabledFeatures; }
        }
        
        public static SecurityConfig validateSecurityConfiguration(Properties serverConfig) {
            SecurityLevel level = SecurityLevel.NONE;
            boolean sslEnabled = false;
            boolean saslEnabled = false;
            boolean aclEnabled = false;
            boolean encryptionEnabled = false;
            boolean auditEnabled = false;
            
            // 检查SSL配置
            String listeners = (String) serverConfig.get("listeners");
            if (listeners != null && listeners.contains("SSL")) {
                sslEnabled = true;
                level = SecurityLevel.BASIC;
            }
            
            // 检查SASL配置
            String securityInterBrokerProtocol = (String) serverConfig.get("security.inter.broker.protocol");
            if (securityInterBrokerProtocol != null && 
                (securityInterBrokerProtocol.contains("SASL") || securityInterBrokerProtocol.contains("SSL"))) {
                saslEnabled = true;
                sslEnabled = true;
                level = SecurityLevel.STANDARD;
            }
            
            // 检查ACL配置
            String authorizerClassName = (String) serverConfig.get("authorizer.class.name");
            if (authorizerClassName != null && !authorizerClassName.isEmpty()) {
                aclEnabled = true;
                level = level.ordinal() > SecurityLevel.STANDARD.ordinal() ? level : SecurityLevel.STANDARD;
            }
            
            // 检查加密配置
            String compressionType = (String) serverConfig.get("compression.type");
            if (compressionType != null && !compressionType.equals("none")) {
                encryptionEnabled = true;
                level = level.ordinal() > SecurityLevel.HIGH.ordinal() ? level : SecurityLevel.HIGH;
            }
            
            // 检查审计配置
            String auditConfig = (String) serverConfig.get("audit.log.level");
            if (auditConfig != null && !auditConfig.equals("NONE")) {
                auditEnabled = true;
                level = SecurityLevel.ENTERPRISE;
            }
            
            return new SecurityConfig(level, sslEnabled, saslEnabled, aclEnabled, 
                                    encryptionEnabled, auditEnabled);
        }
        
        public static void printSecurityAssessment(SecurityConfig config) {
            System.out.println("=== Kafka安全配置评估 ===");
            System.out.printf("安全级别: %s%n", config.getLevel().getDescription());
            System.out.printf("启用功能: %s%n", String.join(", ", config.getEnabledFeatures()));
            
            // 安全建议
            List<String> recommendations = generateSecurityRecommendations(config);
            if (!recommendations.isEmpty()) {
                System.out.println("\n安全建议:");
                recommendations.forEach(rec -> System.out.println("• " + rec));
            }
        }
        
        private static List<String> generateSecurityRecommendations(SecurityConfig config) {
            List<String> recommendations = new ArrayList<>();
            
            if (!config.isSslEnabled()) {
                recommendations.add("启用SSL/TLS加密以保护数据传输");
            }
            
            if (!config.isSaslEnabled()) {
                recommendations.add("配置SASL认证以验证用户身份");
            }
            
            if (!config.isAclEnabled()) {
                recommendations.add("启用ACL权限控制以限制访问权限");
            }
            
            if (!config.isEncryptionEnabled()) {
                recommendations.add("启用消息压缩以保护数据隐私");
            }
            
            if (!config.isAuditEnabled()) {
                recommendations.add("启用审计日志以记录安全事件");
            }
            
            return recommendations;
        }
    }
    
    /**
     * 安全策略管理器
     */
    public static class SecurityPolicyManager {
        
        public static class SecurityPolicy {
            private final String name;
            private final List<String> requirements;
            private final List<String> complianceChecks;
            private final SecurityLevel level;
            
            public SecurityPolicy(String name, SecurityLevel level, 
                                List<String> requirements, List<String> complianceChecks) {
                this.name = name;
                this.requirements = requirements;
                this.complianceChecks = complianceChecks;
                this.level = level;
            }
            
            // Getters
            public String getName() { return name; }
            public List<String> getRequirements() { return requirements; }
            public List<String> getComplianceChecks() { return complianceChecks; }
            public SecurityLevel getLevel() { return level; }
        }
        
        public static SecurityPolicy getPolicyForLevel(SecurityLevel level) {
            switch (level) {
                case BASIC:
                    return new SecurityPolicy(
                        "基础安全策略",
                        level,
                        Arrays.asList(
                            "启用SSL/TLS加密",
                            "配置SSL证书",
                            "设置安全监听端口"
                        ),
                        Arrays.asList(
                            "验证SSL握手成功",
                            "检查证书有效期",
                            "确认加密套件强度"
                        )
                    );
                    
                case STANDARD:
                    return new SecurityPolicy(
                        "标准安全策略",
                        level,
                        Arrays.asList(
                            "启用SASL认证",
                            "配置ACL权限",
                            "设置用户管理",
                            "启用SSL/TLS"
                        ),
                        Arrays.asList(
                            "验证用户认证",
                            "检查权限配置",
                            "确认访问控制有效",
                            "测试授权逻辑"
                        )
                    );
                    
                case HIGH:
                    return new SecurityPolicy(
                        "高安全策略",
                        level,
                        Arrays.asList(
                            "启用消息加密",
                            "配置细粒度权限",
                            "设置IP白名单",
                            "启用操作审计",
                            "配置密钥轮换"
                        ),
                        Arrays.asList(
                            "验证加密强度",
                            "检查权限粒度",
                            "确认审计完整性",
                            "测试异常处理"
                        )
                    );
                    
                case ENTERPRISE:
                    return new SecurityPolicy(
                        "企业级安全策略",
                        level,
                        Arrays.asList(
                            "多层次安全防护",
                            "实时威胁检测",
                            "自动安全响应",
                            "安全合规检查",
                            "灾难恢复计划"
                        ),
                        Arrays.asList(
                            "验证威胁检测",
                            "检查响应机制",
                            "确认合规性",
                            "测试恢复流程",
                            "评估安全态势"
                        )
                    );
                    
                default:
                    return new SecurityPolicy(
                        "无安全策略",
                        level,
                        Arrays.asList("无安全要求"),
                        Arrays.asList("无需检查")
                    );
            }
        }
        
        public static void printPolicyRequirements(SecurityPolicy policy) {
            System.out.println("=== " + policy.getName() + " ===");
            System.out.printf("安全级别: %s%n", policy.getLevel().getDescription());
            System.out.println("\n安全要求:");
            policy.getRequirements().forEach(req -> System.out.println("☐ " + req));
            System.out.println("\n合规检查:");
            policy.getComplianceChecks().forEach(check -> System.out.println("☐ " + check));
        }
    }
}
```

## SSL/TLS加密配置

### 证书管理

```java
/**
 * SSL/TLS证书管理
 */
public class SSLCertificateManager {
    
    /**
     * 证书生成器
     */
    public static class CertificateGenerator {
        
        /**
         * 生成自签名证书
         */
        public static CertificateInfo generateSelfSignedCertificate(String hostname, 
                                                                   int validityDays) {
            try {
                // 生成密钥对
                KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA");
                keyPairGen.initialize(2048);
                KeyPair keyPair = keyPairGen.generateKeyPair();
                
                // 创建证书
                X509Certificate certificate = createX509Certificate(hostname, keyPair, validityDays);
                
                return new CertificateInfo(
                    hostname,
                    certificate,
                    keyPair.getPrivate(),
                    keyPair.getPublic()
                );
                
            } catch (Exception e) {
                throw new RuntimeException("证书生成失败", e);
            }
        }
        
        private static X509Certificate createX509Certificate(String hostname, 
                                                           KeyPair keyPair, 
                                                           int validityDays) 
            throws Exception {
            
            X509V3CertificateGenerator certGen = new X509V3CertificateGenerator();
            
            // 设置证书基本信息
            certGen.setSerialNumber(BigInteger.valueOf(1));
            certGen.setSubjectDN(new X509Name("CN=" + hostname));
            certGen.setIssuerDN(new X509Name("CN=" + hostname));
            certGen.setNotBefore(new Date(System.currentTimeMillis()));
            certGen.setNotAfter(new Date(System.currentTimeMillis() + validityDays * 24 * 60 * 60 * 1000L));
            certGen.setPublicKey(keyPair.getPublic());
            certGen.setSignatureAlgorithm("SHA256WithRSAEncryption");
            
            // 添加扩展字段
            certGen.addExtension(X509Extensions.SubjectAlternativeName, false, 
                createSubjectAlternativeName(hostname));
            certGen.addExtension(X509Extensions.KeyUsage, false,
                new KeyUsage(KeyUsage.keyEncipherment | KeyUsage.digitalSignature));
            certGen.addExtension(X509Extensions.ExtendedKeyUsage, false,
                new ExtendedKeyUsage(ExtendedKeyUsage.serverAuth));
            
            return certGen.generate(keyPair.getPrivate(), "BC");
        }
        
        private static GeneralNames createSubjectAlternativeName(String hostname) {
            GeneralName name = new GeneralName(GeneralName.dNSName, hostname);
            return new GeneralNames(new GeneralName[]{name});
        }
        
        /**
         * 生成CA证书
         */
        public static CertificateInfo generateCACertificate(String caName, int validityDays) {
            return generateSelfSignedCertificate("CN=" + caName + ",O=CA", validityDays);
        }
        
        /**
         * 为Kafka生成完整证书链
         */
        public static CertificateChain generateKafkaCertificateChain(String kafkaHostname) {
            // 生成CA证书
            CertificateInfo caCert = generateCACertificate("KafkaCA", 3650);
            
            // 生成服务器证书
            CertificateInfo serverCert = generateServerCertificate(kafkaHostname, caCert);
            
            // 生成客户端证书（可选）
            CertificateInfo clientCert = generateClientCertificate("client", caCert);
            
            return new CertificateChain(
                kafkaHostname,
                caCert,
                serverCert,
                clientCert
            );
        }
        
        private static CertificateInfo generateServerCertificate(String hostname, CertificateInfo caCert) {
            try {
                KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA");
                keyPairGen.initialize(2048);
                KeyPair keyPair = keyPairGen.generateKeyPair();
                
                X509V3CertificateGenerator certGen = new X509V3CertificateGenerator();
                
                certGen.setSerialNumber(BigInteger.valueOf(2));
                certGen.setSubjectDN(new X509Name("CN=" + hostname));
                certGen.setIssuerDN(caCert.getCertificate().getSubjectDN());
                certGen.setNotBefore(new Date(System.currentTimeMillis()));
                certGen.setNotAfter(new Date(System.currentTimeMillis() + 365 * 24 * 60 * 60 * 1000L));
                certGen.setPublicKey(keyPair.getPublic());
                certGen.setSignatureAlgorithm("SHA256WithRSAEncryption");
                certGen.addExtension(X509Extensions.AuthorityKeyIdentifier, false,
                    new AuthorityKeyIdentifierStructure(caCert.getCertificate()));
                certGen.addExtension(X509Extensions.SubjectAlternativeName, false,
                    createSubjectAlternativeName(hostname));
                certGen.addExtension(X509Extensions.KeyUsage, false,
                    new KeyUsage(KeyUsage.keyEncipherment | KeyUsage.digitalSignature));
                
                return new CertificateInfo(hostname, certGen.generate(caCert.getPrivateKey()), 
                    keyPair.getPrivate(), keyPair.getPublic());
                    
            } catch (Exception e) {
                throw new RuntimeException("服务器证书生成失败", e);
            }
        }
        
        private static CertificateInfo generateClientCertificate(String clientName, CertificateInfo caCert) {
            return generateServerCertificate(clientName, caCert);
        }
    }
    
    /**
     * 证书信息类
     */
    public static class CertificateInfo {
        private final String hostname;
        private final X509Certificate certificate;
        private final PrivateKey privateKey;
        private final PublicKey publicKey;
        
        public CertificateInfo(String hostname, X509Certificate certificate,
                             PrivateKey privateKey, PublicKey publicKey) {
            this.hostname = hostname;
            this.certificate = certificate;
            this.privateKey = privateKey;
            this.publicKey = publicKey;
        }
        
        // Getters
        public String getHostname() { return hostname; }
        public X509Certificate getCertificate() { return certificate; }
        public PrivateKey getPrivateKey() { return privateKey; }
        public PublicKey getPublicKey() { return publicKey; }
    }
    
    /**
     * 证书链
     */
    public static class CertificateChain {
        private final String hostname;
        private final CertificateInfo caCertificate;
        private final CertificateInfo serverCertificate;
        private final CertificateInfo clientCertificate;
        
        public CertificateChain(String hostname, CertificateInfo caCertificate,
                              CertificateInfo serverCertificate, CertificateInfo clientCertificate) {
            this.hostname = hostname;
            this.caCertificate = caCertificate;
            this.serverCertificate = serverCertificate;
            this.clientCertificate = clientCertificate;
        }
        
        public String getHostname() { return hostname; }
        public CertificateInfo getCaCertificate() { return caCertificate; }
        public CertificateInfo getServerCertificate() { return serverCertificate; }
        public CertificateInfo getClientCertificate() { return clientCertificate; }
    }
    
    /**
     * 证书存储管理器
     */
    public static class CertificateStore {
        
        /**
         * 保存证书到PEM格式文件
         */
        public static void saveToPEMFile(CertificateInfo certInfo, String keyPath, String certPath) 
            throws Exception {
            
            // 保存私钥
            savePrivateKeyToPEM(certInfo.getPrivateKey(), keyPath);
            
            // 保存证书
            saveCertificateToPEM(certInfo.getCertificate(), certPath);
        }
        
        private static void savePrivateKeyToPEM(PrivateKey privateKey, String filePath) 
            throws Exception {
            StringWriter writer = new StringWriter();
            PEMWriter pemWriter = new PEMWriter(writer);
            pemWriter.writeObject(privateKey);
            pemWriter.close();
            
            Files.write(Paths.get(filePath), writer.toString().getBytes());
        }
        
        private static void saveCertificateToPEM(X509Certificate certificate, String filePath) 
            throws Exception {
            StringWriter writer = new StringWriter();
            PEMWriter pemWriter = new PEMWriter(writer);
            pemWriter.writeObject(certificate);
            pemWriter.close();
            
            Files.write(Paths.get(filePath), writer.toString().getBytes());
        }
        
        /**
         * 创建JKS密钥库
         */
        public static KeyStore createKeyStore(String password, CertificateInfo certInfo) 
            throws Exception {
            
            KeyStore keyStore = KeyStore.getInstance("JKS");
            keyStore.load(null, null);
            
            // 添加私钥和证书链
            keyStore.setKeyEntry(certInfo.getHostname(), certInfo.getPrivateKey(),
                password.toCharArray(), new X509Certificate[]{certInfo.getCertificate()});
            
            return keyStore;
        }
        
        /**
         * 创建TrustStore信任库
         */
        public static KeyStore createTrustStore(String password, List<CertificateInfo> trustedCerts) 
            throws Exception {
            
            KeyStore trustStore = KeyStore.getInstance("JKS");
            trustStore.load(null, null);
            
            // 添加受信任的CA证书
            for (int i = 0; i < trustedCerts.size(); i++) {
                CertificateInfo certInfo = trustedCerts.get(i);
                trustStore.setCertificateEntry("ca-cert-" + i, certInfo.getCertificate());
            }
            
            return trustStore;
        }
    }
}
```

### SSL配置管理

```java
/**
 * SSL配置管理器
 */
public class SSLConfigurationManager {
    
    /**
     * Kafka SSL配置构建器
     */
    public static class KafkaSSLConfigBuilder {
        
        private final Properties config = new Properties();
        private String keystorePath;
        private String keystorePassword;
        private String keyPassword;
        private String truststorePath;
        private String truststorePassword;
        private boolean clientAuthEnabled;
        private List<String> enabledProtocols;
        private List<String> enabledCipherSuites;
        
        public KafkaSSLConfigBuilder withKeystore(String path, String storePassword, String keyPassword) {
            this.keystorePath = path;
            this.keystorePassword = storePassword;
            this.keyPassword = keyPassword;
            return this;
        }
        
        public KafkaSSLConfigBuilder withTruststore(String path, String password) {
            this.truststorePath = path;
            this.truststorePassword = password;
            return this;
        }
        
        public KafkaSSLConfigBuilder enableClientAuth() {
            this.clientAuthEnabled = true;
            return this;
        }
        
        public KafkaSSLConfigBuilder withProtocols(List<String> protocols) {
            this.enabledProtocols = protocols;
            return this;
        }
        
        public KafkaSSLConfigBuilder withCipherSuites(List<String> cipherSuites) {
            this.enabledCipherSuites = cipherSuites;
            return this;
        }
        
        public Properties build() {
            if (keystorePath != null && !keystorePath.isEmpty()) {
                config.put("ssl.keystore.location", keystorePath);
                config.put("ssl.keystore.password", keystorePassword);
                config.put("ssl.key.password", keyPassword);
                config.put("ssl.keystore.type", "JKS");
            }
            
            if (truststorePath != null && !truststorePath.isEmpty()) {
                config.put("ssl.truststore.location", truststorePath);
                config.put("ssl.truststore.password", truststorePassword);
                config.put("ssl.truststore.type", "JKS");
            }
            
            if (clientAuthEnabled) {
                config.put("ssl.client.auth", "required");
                config.put("ssl.endpoint.identification.algorithm", "HTTPS");
            }
            
            if (enabledProtocols != null && !enabledProtocols.isEmpty()) {
                config.put("ssl.protocol", String.join(",", enabledProtocols));
            }
            
            if (enabledCipherSuites != null && !enabledCipherSuites.isEmpty()) {
                config.put("ssl.cipher.suites", String.join(",", enabledCipherSuites));
            }
            
            config.put("ssl.provider", "TLS");
            config.put("ssl.keystore.type", "JKS");
            config.put("ssl.truststore.type", "JKS");
            
            return config;
        }
    }
    
    /**
     * SSL连接测试器
     */
    public static class SSLConnectionTester {
        
        public static class SSLTestResult {
            private final boolean success;
            private final String message;
            private final List<String> details;
            private final long handshakeTime;
            private final String cipherSuite;
            private final String protocolVersion;
            
            public SSLTestResult(boolean success, String message, List<String> details,
                               long handshakeTime, String cipherSuite, String protocolVersion) {
                this.success = success;
                this.message = message;
                this.details = details;
                this.handshakeTime = handshakeTime;
                this.cipherSuite = cipherSuite;
                this.protocolVersion = protocolVersion;
            }
            
            // Getters
            public boolean isSuccess() { return success; }
            public String getMessage() { return message; }
            public List<String> getDetails() { return details; }
            public long getHandshakeTime() { return handshakeTime; }
            public String getCipherSuite() { return cipherSuite; }
            public String getProtocolVersion() { return protocolVersion; }
        }
        
        public static SSLTestResult testSSLConnection(String hostname, int port, 
                                                    Properties sslConfig) {
            List<String> details = new ArrayList<>();
            long startTime = System.currentTimeMillis();
            
            try {
                // 创建SSL上下文
                SSLContext sslContext = createSSLContext(sslConfig);
                
                // 创建SSL套接字
                SSLSocketFactory socketFactory = sslContext.getSocketFactory();
                SSLSocket socket = (SSLSocket) socketFactory.createSocket(hostname, port);
                
                // 设置SSL参数
                socket.setEnabledCipherSuites(socket.getSupportedCipherSuites());
                socket.setEnabledProtocols(new String[]{"TLSv1.2", "TLSv1.3"});
                
                // 开始握手
                socket.startHandshake();
                long handshakeTime = System.currentTimeMillis() - startTime;
                
                // 获取握手结果
                SSLSession session = socket.getSession();
                String cipherSuite = session.getCipherSuite();
                String protocolVersion = session.getProtocol();
                
                details.add("握手时间: " + handshakeTime + "ms");
                details.add("密码套件: " + cipherSuite);
                details.add("协议版本: " + protocolVersion);
                details.add("服务器: " + session.getPeerHost() + ":" + session.getPeerPort());
                
                socket.close();
                
                return new SSLTestResult(true, "SSL连接成功", details, handshakeTime, 
                                       cipherSuite, protocolVersion);
                                       
            } catch (Exception e) {
                long handshakeTime = System.currentTimeMillis() - startTime;
                details.add("错误: " + e.getMessage());
                
                return new SSLTestResult(false, "SSL连接失败", details, handshakeTime, 
                                       "未知", "未知");
            }
        }
        
        private static SSLContext createSSLContext(Properties sslConfig) throws Exception {
            // 加载信任库
            String truststorePath = sslConfig.getProperty("ssl.truststore.location");
            String truststorePassword = sslConfig.getProperty("ssl.truststore.password");
            
            KeyStore trustStore = KeyStore.getInstance("JKS");
            try (FileInputStream fis = new FileInputStream(truststorePath)) {
                trustStore.load(fis, truststorePassword.toCharArray());
            }
            
            TrustManagerFactory trustManagerFactory = 
                TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            trustManagerFactory.init(trustStore);
            
            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(null, trustManagerFactory.getTrustManagers(), null);
            
            return sslContext;
        }
        
        public static void printTestResult(SSLTestResult result) {
            System.out.println("=== SSL连接测试结果 ===");
            System.out.println("状态: " + (result.isSuccess() ? "✅ 成功" : "❌ 失败"));
            System.out.println("消息: " + result.getMessage());
            
            if (result.isSuccess()) {
                System.out.println("详细信息:");
                result.getDetails().forEach(detail -> System.out.println("  • " + detail));
            }
        }
    }
    
    /**
     * SSL证书验证器
     */
    public static class SSLCertificateValidator {
        
        public static class CertificateValidationResult {
            private final boolean valid;
            private final List<String> issues;
            private final List<String> warnings;
            private final Date expirationDate;
            private final String subject;
            private final String issuer;
            private final String san;
            
            public CertificateValidationResult(boolean valid, List<String> issues,
                                             List<String> warnings, Date expirationDate,
                                             String subject, String issuer, String san) {
                this.valid = valid;
                this.issues = issues;
                this.warnings = warnings;
                this.expirationDate = expirationDate;
                this.subject = subject;
                this.issuer = issuer;
                this.san = san;
            }
            
            // Getters
            public boolean isValid() { return valid; }
            public List<String> getIssues() { return issues; }
            public List<String> getWarnings() { return warnings; }
            public Date getExpirationDate() { return expirationDate; }
            public String getSubject() { return subject; }
            public String getIssuer() { return issuer; }
            public String getSan() { return san; }
        }
        
        public static CertificateValidationResult validateCertificate(X509Certificate certificate) {
            List<String> issues = new ArrayList<>();
            List<String> warnings = new ArrayList<>();
            
            try {
                // 检查证书有效期
                Date now = new Date();
                Date notBefore = certificate.getNotBefore();
                Date notAfter = certificate.getNotAfter();
                
                if (now.before(notBefore)) {
                    issues.add("证书尚未生效");
                }
                
                if (now.after(notAfter)) {
                    issues.add("证书已过期");
                } else {
                    long daysUntilExpiration = (notAfter.getTime() - now.getTime()) / (24 * 60 * 60 * 1000);
                    if (daysUntilExpiration < 30) {
                        warnings.add("证书即将过期 (" + daysUntilExpiration + " 天)");
                    }
                }
                
                // 检查证书链
                try {
                    certificate.verify(certificate.getPublicKey());
                    warnings.add("证书为自签名证书");
                } catch (Exception e) {
                    // 证书链验证失败
                }
                
                // 检查密钥用途
                boolean keyUsageValid = checkKeyUsage(certificate);
                if (!keyUsageValid) {
                    issues.add("证书密钥用途不符合要求");
                }
                
                // 检查扩展密钥用途
                boolean extendedKeyUsageValid = checkExtendedKeyUsage(certificate);
                if (!extendedKeyUsageValid) {
                    warnings.add("扩展密钥用途可能不符合服务器认证要求");
                }
                
                // 提取证书信息
                String subject = certificate.getSubjectDN().getName();
                String issuer = certificate.getIssuerDN().getName();
                String san = extractSAN(certificate);
                
                return new CertificateValidationResult(
                    issues.isEmpty(), issues, warnings, notAfter, subject, issuer, san);
                    
            } catch (Exception e) {
                issues.add("证书验证过程中发生错误: " + e.getMessage());
                return new CertificateValidationResult(false, issues, warnings, 
                    null, "", "", "");
            }
        }
        
        private static boolean checkKeyUsage(X509Certificate certificate) {
            try {
                boolean[] keyUsage = certificate.getKeyUsage();
                return keyUsage != null && 
                    (keyUsage[0] || keyUsage[1]); // digitalSignature, keyEncipherment
            } catch (CertificateParsingException e) {
                return false;
            }
        }
        
        private static boolean checkExtendedKeyUsage(X509Certificate certificate) {
            try {
                List<String> extendedKeyUsage = certificate.getExtendedKeyUsage();
                return extendedKeyUsage != null && 
                    extendedKeyUsage.contains("1.3.6.1.5.5.7.3.1"); // serverAuth OID
            } catch (CertificateParsingException e) {
                return true; // 如果无法解析ExtendedKeyUsage，则认为有效
            }
        }
        
        private static String extractSAN(X509Certificate certificate) {
            try {
                Collection<List<?>> altNames = certificate.getSubjectAlternativeNames();
                if (altNames != null) {
                    for (List<?> altName : altNames) {
                        if (altName.size() >= 2 && ((Integer) altName.get(0)) == 2) {
                            return (String) altName.get(1);
                        }
                    }
                }
            } catch (CertificateParsingException e) {
                // 忽略解析错误
            }
            return "";
        }
        
        public static void printValidationResult(CertificateValidationResult result) {
            System.out.println("=== 证书验证结果 ===");
            System.out.println("状态: " + (result.isValid() ? "✅ 有效" : "❌ 无效"));
            System.out.println("主题: " + result.getSubject());
            System.out.println("颁发者: " + result.getIssuer());
            if (result.getExpirationDate() != null) {
                System.out.println("到期时间: " + result.getExpirationDate());
            }
            
            if (!result.getWarnings().isEmpty()) {
                System.out.println("\n警告:");
                result.getWarnings().forEach(warning -> System.out.println("⚠️ " + warning));
            }
            
            if (!result.getIssues().isEmpty()) {
                System.out.println("\n问题:");
                result.getIssues().forEach(issue -> System.out.println("❌ " + issue));
            }
        }
    }
}
```

## SASL认证机制

### SASL配置管理器

```java
/**
 * SASLpublic class SASLA    
    /**
    认证管理器
 */
 * SASL机制配置
     */
uthenticationManager {
    public static class SASLMechanismConfig {
        
        public enum SASLMechanism {
            PLAIN("PLAIN", "明文密码认证", false, true),
            SCRAM_SHA_256("SCRAM-SHA-256", "SCRAM-SHA-256哈希认证", true, true),
            SCRAM_SHA_512("SCRAM-SHA-512", "SCRAM-SHA-512哈希认证", true, true),
            GSSAPI("GSSAPI", "Kerberos认证", false, false);
            
            private final String name;
            private final String description;
            private final boolean secure;
            private final boolean supported;
            
            SASLMechanism(String name, String description, boolean secure, boolean supported) {
                this.name = name;
                this.description = description;
                this.secure = secure;
                this.supported = supported;
            }
            
            public String getName() { return name; }
            public String getDescription() { return description; }
            public boolean isSecure() { return secure; }
            public boolean isSupported() { return supported; }
        }
        
        /**
         * 为特定场景推荐SASL机制
         */
        public static SASLMechanism recommendMechanism(String useCase) {
            switch (useCase.toLowerCase()) {
                case "development":
                case "测试环境":
                    return PLAIN;
                case "internal":
                case "内网":
                    return SCRAM_SHA_256;
                case "production":
                case "生产环境":
                case "high_security":
                case "高安全":
                    return SCRAM_SHA_512;
                case "enterprise":
                case "企业级":
                    return GSSAPI;
                default:
                    return SCRAM_SHA_256;
            }
        }
        
        /**
         * 检查机制兼容性
         */
        public static List<String> checkMechanismCompatibility(SASLMechanism mechanism, 
                                                              Properties config) {
            List<String> issues = new ArrayList<>();
            
            if (!mechanism.isSupported()) {
                issues.add("SASL机制 '" + mechanism.getName() + "' 当前环境不支持");
            }
            
            // 检查Java版本要求
            if (mechanism == SASLMechanism.SCRAM_SHA_256 || mechanism == SASLMechanism.SCRAM_SHA_512) {
                String javaVersion = System.getProperty("java.version");
                if (javaVersion.compareTo("1.8") < 0) {
                    issues.add("SCRAM机制需要Java 8或更高版本");
                }
            }
            
            // 检查所需依赖
            if (mechanism == SASLMechanism.GSSAPI) {
                String os = System.getProperty("os.name").toLowerCase();
                if (!os.contains("windows") && !os.contains("linux")) {
                    issues.add("Kerberos认证主要支持Windows和Linux系统");
                }
            }
            
            return issues;
        }
    }
    
    /**
     * 用户管理
     */
    public static class UserManager {
        
        /**
         * 用户信息
         */
        public static class User {
            private final String username;
            private final String password;
            private final Set<String> roles;
            private final Set<String> permissions;
            private final boolean enabled;
            private final Date createdDate;
            private final Date lastLoginDate;
            
            public User(String username, String password, Set<String> roles) {
                this.username = username;
                this.password = password;
                this.roles = roles;
                this.permissions = new HashSet<>();
                this.enabled = true;
                this.createdDate = new Date();
                this.lastLoginDate = null;
            }
            
            public User(String username, String password, Set<String> roles, 
                       Set<String> permissions, boolean enabled) {
                this.username = username;
                this.password = password;
                this.roles = roles;
                this.permissions = permissions;
                this.enabled = enabled;
                this.createdDate = new Date();
                this.lastLoginDate = null;
            }
            
            // Getters
            public String getUsername() { return username; }
            public String getPassword() { return password; }
            public Set<String> getRoles() { return roles; }
            public Set<String> getPermissions() { return permissions; }
            public boolean isEnabled() { return enabled; }
            public Date getCreatedDate() { return createdDate; }
            public Date getLastLoginDate() { return lastLoginDate; }
            
            public void updateLastLoginDate() {
                this.lastLoginDate = new Date();
            }
        }
        
        /**
         * 用户存储接口
         */
        public interface UserStore {
            void addUser(User user);
            User getUser(String username);
            void removeUser(String username);
            void updateUser(User user);
            List<User> listUsers();
            boolean authenticate(String username, String password);
        }
        
        /**
         * 文件基础用户存储
         */
        public static class FileBasedUserStore implements UserStore {
            private final String userFilePath;
            private final Map<String, User> users = new ConcurrentHashMap<>();
            
            public FileBasedUserStore(String userFilePath) {
                this.userFilePath = userFilePath;
                loadUsers();
            }
            
            @Override
            public void addUser(User user) {
                users.put(user.getUsername(), user);
                saveUsers();
            }
            
            @Override
            public User getUser(String username) {
                return users.get(username);
            }
            
            @Override
            public void removeUser(String username) {
                users.remove(username);
                saveUsers();
            }
            
            @Override
            public void updateUser(User user) {
                users.put(user.getUsername(), user);
                saveUsers();
            }
            
            @Override
            public List<User> listUsers() {
                return new ArrayList<>(users.values());
            }
            
            @Override
            public boolean authenticate(String username, String password) {
                User user = users.get(username);
                if (user == null || !user.isEnabled()) {
                    return false;
                }
                
                // 在实际应用中，应该使用哈希比较而不是直接比较
                if (user.getPassword().equals(password)) {
                    user.updateLastLoginDate();
                    return true;
                }
                
                return false;
            }
            
            private void loadUsers() {
                try {
                    File userFile = new File(userFilePath);
                    if (userFile.exists()) {
                        String content = new String(Files.readAllBytes(userFile.toPath()));
                        // 解析用户配置文件
                        parseUserFile(content);
                    }
                } catch (Exception e) {
                    System.err.println("加载用户文件失败: " + e.getMessage());
                }
            }
            
            private void saveUsers() {
                try {
                    StringBuilder sb = new StringBuilder();
                    for (User user : users.values()) {
                        sb.append(user.getUsername())
                          .append(":")
                          .append(user.getPassword())
                          .append(":")
                          .append(String.join(",", user.getRoles()))
                          .append(":")
                          .append(String.join(",", user.getPermissions()))
                          .append(":")
                          .append(user.isEnabled() ? "enabled" : "disabled")
                          .append("\n");
                    }
                    Files.write(Paths.get(userFilePath), sb.toString().getBytes());
                } catch (Exception e) {
                    System.err.println("保存用户文件失败: " + e.getMessage());
                }
            }
            
            private void parseUserFile(String content) {
                String[] lines = content.split("\n");
                for (String line : lines) {
                    line = line.trim();
                    if (line.isEmpty() || line.startsWith("#")) {
                        continue;
                    }
                    
                    String[] parts = line.split(":");
                    if (parts.length >= 3) {
                        String username = parts[0];
                        String password = parts[1];
                        Set<String> roles = new HashSet<>(Arrays.asList(parts[2].split(",")));
                        Set<String> permissions = new HashSet<>();
                        boolean enabled = true;
                        
                        if (parts.length > 3) {
                            permissions = new HashSet<>(Arrays.asList(parts[3].split(",")));
                        }
                        
                        if (parts.length > 4) {
                            enabled = !"disabled".equals(parts[4]);
                        }
                        
                        User user = new User(username, password, roles, permissions, enabled);
                        users.put(username, user);
                    }
                }
            }
        }
        
        /**
         * 用户管理器
         */
        public static class UserManagementSystem {
            private final UserStore userStore;
            
            public UserManagementSystem(UserStore userStore) {
                this.userStore = userStore;
            }
            
            /**
             * 创建用户
             */
            public void createUser(String username, String password, Set<String> roles) {
                if (userStore.getUser(username) != null) {
                    throw new IllegalArgumentException("用户已存在: " + username);
                }
                
                User user = new User(username, password, roles);
                userStore.addUser(user);
                
                System.out.println("用户创建成功: " + username);
            }
            
            /**
             * 创建管理员用户
             */
            public void createAdminUser(String username, String password) {
                Set<String> adminRoles = new HashSet<>(Arrays.asList("admin", "user"));
                Set<String> adminPermissions = new HashSet<>(Arrays.asList(
                    "all:read", "all:write", "all:delete", "user:manage"
                ));
                
                User adminUser = new User(username, password, adminRoles, adminPermissions, true);
                userStore.addUser(adminUser);
                
                System.out.println("管理员用户创建成功: " + username);
            }
            
            /**
             * 修改用户密码
             */
            public void changePassword(String username, String oldPassword, String newPassword) {
                User user = userStore.getUser(username);
                if (user == null) {
                    throw new IllegalArgumentException("用户不存在: " + username);
                }
                
                if (!userStore.authenticate(username, oldPassword)) {
                    throw new IllegalArgumentException("原密码验证失败");
                }
                
                user.setPassword(newPassword);
                userStore.updateUser(user);
                
                System.out.println("密码修改成功: " + username);
            }
            
            /**
             * 禁用用户
             */
            public void disableUser(String username) {
                User user = userStore.getUser(username);
                if (user == null) {
                    throw new IllegalArgumentException("用户不存在: " + username);
                }
                
                user = new User(user.getUsername(), user.getPassword(), user.getRoles(),
                    user.getPermissions(), false);
                userStore.updateUser(user);
                
                System.out.println("用户已禁用: " + username);
            }
            
            /**
             * 用户登录
             */
            public boolean login(String username, String password) {
                if (userStore.authenticate(username, password)) {
                    System.out.println("登录成功: " + username);
                    return true;
                } else {
                    System.out.println("登录失败: " + username);
                    return false;
                }
            }
            
            /**
             * 列出所有用户
             */
            public void listUsers() {
                System.out.println("=== 用户列表 ===");
                List<User> users = userStore.listUsers();
                for (User user : users) {
                    System.out.printf("用户名: %s, 角色: %s, 状态: %s%n",
                        user.getUsername(),
                        String.join(",", user.getRoles()),
                        user.isEnabled() ? "启用" : "禁用");
                }
            }
            
            /**
             * 生成SCRAM凭据
             */
            public String generateSCRAMCredentials(String username, String password, 
                                                 String mechanism) {
                try {
                    // 模拟SCRAM凭据生成（在实际应用中应使用真正的SCRAM实现）
                    String salt = generateRandomSalt();
                    String storedKey = generateSaltedPassword(password, salt, mechanism);
                    String serverKey = generateSaltedPassword(password, salt, mechanism);
                    
                    return String.format("%s:%s:%s:%s", mechanism, username, salt, storedKey);
                } catch (Exception e) {
                    throw new RuntimeException("SCRAM凭据生成失败", e);
                }
            }
            
            private String generateRandomSalt() {
                SecureRandom random = new SecureRandom();
                byte[] salt = new byte[16];
                random.nextBytes(salt);
                return Base64.getEncoder().encodeToString(salt);
            }
            
            private String generateSaltedPassword(String password, String salt, String mechanism) {
                // 模拟SCRAM盐化过程
                try {
                    MessageDigest digest = MessageDigest.getInstance("SHA-256");
                    String saltedPassword = password + salt + mechanism;
                    byte[] hashed = digest.digest(saltedPassword.getBytes());
                    return Base64.getEncoder().encodeToString(hashed);
                } catch (NoSuchAlgorithmException e) {
                    throw new RuntimeException("哈希算法不可用", e);
                }
            }
        }
    }
    
    /**
     * SASL配置生成器
     */
    public static class SASLConfigGenerator {
        
        /**
         * 生成SASL配置
         */
        public static Properties generateSASLConfig(SASLMechanismConfig.SASLMechanism mechanism,
                                                   String userFilePath) {
            Properties config = new Properties();
            
            // 配置SASL机制
            config.put("sasl.mechanism.inter.broker.protocol", mechanism.getName());
            config.put("sasl.enabled.mechanisms", mechanism.getName());
            
            // 配置SASL服务名称
            config.put("sasl.kerberos.service.name", "kafka");
            
            // 配置JAAS配置文件
            String jaasConfig = generateJAASConfig(mechanism, userFilePath);
            config.put("java.security.auth.login.config", jaasConfig);
            
            return config;
        }
        
        private static String generateJAASConfig(SASLMechanismConfig.SASLMechanism mechanism,
                                                String userFilePath) {
            switch (mechanism) {
                case PLAIN:
                    return String.format(
                        "KafkaServer {\n" +
                        "  org.apache.kafka.common.security.plain.PlainLoginModule required\n" +
                        "    username=\"admin\"\n" +
                        "    password=\"admin-secret\"\n" +
                        "    user_admin=\"admin-secret\"\n" +
                        "    user_producer=\"producer-secret\"\n" +
                        "    user_consumer=\"consumer-secret\";\n" +
                        "};"
                    );
                    
                case SCRAM_SHA_256:
                case SCRAM_SHA_512:
                    return String.format(
                        "KafkaServer {\n" +
                        "  org.apache.kafka.common.security.scram.ScramLoginModule required\n" +
                        "    username=\"admin\"\n" +
                        "    password=\"admin-secret\"\n" +
                        "    user_admin=\"admin-secret\"\n" +
                        "    user_producer=\"producer-secret\"\n" +
                        "    user_consumer=\"consumer-secret\";\n" +
                        "};"
                    );
                    
                case GSSAPI:
                    return String.format(
                        "KafkaServer {\n" +
                        "  com.sun.security.auth.module.Krb5LoginModule required\n" +
                        "    useKeyTab=true\n" +
                        "    keyTab=\"/etc/kafka/kafka.keytab\"\n" +
                        "    principal=\"kafka/kafka.example.com@EXAMPLE.COM\";\n" +
                        "};"
                    );
                    
                default:
                    throw new IllegalArgumentException("不支持的SASL机制: " + mechanism);
            }
        }
        
        /**
         * 生成客户端SASL配置
         */
        public static Properties generateClientSASLConfig(SASLMechanismConfig.SASLMechanism mechanism,
                                                        String username, String password) {
            Properties config = new Properties();
            
            // 启用SASL
            config.put("sasl.mechanism", mechanism.getName());
            config.put("security.protocol", "SASL_SSL");
            
            // 配置JAAS
            String jaasConfig = generateClientJAASConfig(mechanism, username, password);
            config.put("sasl.jaas.config", jaasConfig);
            
            return config;
        }
        
        private static String generateClientJAASConfig(SASLMechanismConfig.SASLMechanism mechanism,
                                                      String username, String password) {
            switch (mechanism) {
                case PLAIN:
                    return String.format(
                        "org.apache.kafka.common.security.plain.PlainLoginModule required\n" +
                        "username=\"%s\"\n" +
                        "password=\"%s\";", username, password
                    );
                    
                case SCRAM_SHA_256:
                case SCRAM_SHA_512:
                    return String.format(
                        "org.apache.kafka.common.security.scram.ScramLoginModule required\n" +
                        "username=\"%s\"\n" +
                        "password=\"%s\";", username, password
                    );
                    
                case GSSAPI:
                    return String.format(
                        "com.sun.security.auth.module.Krb5LoginModule required\n" +
                        "useKeyTab=true\n" +
                        "keyTab=\"/etc/kafka/client.keytab\"\n" +
                        "principal=\"%s@EXAMPLE.COM\";", username
                    );
                    
                default:
                    throw new IllegalArgumentException("不支持的SASL机制: " + mechanism);
            }
        }
    }
}
```

## ACL权限控制

### ACL管理

```java
/**
 * Kafka ACL权限管理
 */
public class KafkaACLManager {
    
    /**
     * ACL权限定义
     */
    public static class ACLPermissions {
        
        public enum Permission {
            READ("读取", "Read"),
            WRITE("写入", "Write"), 
            CREATE("创建", "Create"),
            DELETE("删除", "Delete"),
            ALTER("修改", "Alter"),
            ALTER_CONFIGS("修改配置", "AlterConfigs"),
            DESCRIBE("描述", "Describe"),
            DESCRIBE_CONFIGS("描述配置", "DescribeConfigs"),
            CLUSTER_ACTION("集群操作", "ClusterAction"),
            ALL("全部权限", "All");
            
            private final String chineseName;
            private final String englishName;
            
            Permission(String chineseName, String englishName) {
                this.chineseName = chineseName;
                this.englishName = englishName;
            }
            
            public String getChineseName() { return chineseName; }
            public String getEnglishName() { return englishName; }
            
            public static Permission fromString(String name) {
                for (Permission perm : Permission.values()) {
                    if (perm.getEnglishName().equalsIgnoreCase(name) ||
                        perm.getChineseName().equals(name)) {
                        return perm;
                    }
                }
                throw new IllegalArgumentException("未知的权限: " + name);
            }
        }
        
        /**
         * 权限集合
         */
        public static class PermissionSet {
            private final Set<Permission> permissions = new HashSet<>();
            
            public PermissionSet addPermission(Permission permission) {
                permissions.add(permission);
                return this;
            }
            
            public PermissionSet removePermission(Permission permission) {
                permissions.remove(permission);
                return this;
            }
            
            public boolean hasPermission(Permission permission) {
                return permissions.contains(permission) || permissions.contains(Permission.ALL);
            }
            
            public Set<Permission> getPermissions() {
                return new HashSet<>(permissions);
            }
            
            public String toString() {
                if (permissions.isEmpty()) {
                    return "无权限";
                }
                
                if (permissions.contains(Permission.ALL)) {
                    return "全部权限";
                }
                
                return permissions.stream()
                    .map(Permission::getChineseName)
                    .collect(Collectors.joining("、"));
            }
        }
    }
    
    /**
     * ACL规则
     */
    public static class ACLRule {
        private final String principal;        // 主体
        private final ACLPermissions.Permission permission;  // 权限
        private final String operation;        // 操作
        private final String resource;         // 资源
        private final String resourceType;     // 资源类型
        private final String host;             // 主机
        private final boolean allow;           // 是否允许
        
        public ACLRule(String principal, ACLPermissions.Permission permission,
                      String operation, String resource, String resourceType,
                      String host, boolean allow) {
            this.principal = principal;
            this.permission = permission;
            this.operation = operation;
            this.resource = resource;
            this.resourceType = resourceType;
            this.host = host;
            this.allow = allow;
        }
        
        // Getters
        public String getPrincipal() { return principal; }
        public ACLPermissions.Permission getPermission() { return permission; }
        public String getOperation() { return operation; }
        public String getResource() { return resource; }
        public String getResourceType() { return resourceType; }
        public String getHost() { return host; }
        public boolean isAllow() { return allow; }
        
        public boolean matches(String principal, String resource, String operation) {
            return this.principal.equals(principal) &&
                   (this.resource.equals("*") || this.resource.equals(resource)) &&
                   (this.operation.equals("*") || this.operation.equals(operation));
        }
        
        @Override
        public String toString() {
            return String.format("%s %s %s on %s:%s from %s %s",
                isAllow() ? "Allow" : "Deny",
                principal,
                permission.getEnglishName(),
                resourceType,
                resource,
                host,
                host.equals("*") ? "(any host)" : "");
        }
    }
    
    /**
     * ACL管理器
     */
    public static class ACLManagementSystem {
        
        private final List<ACLRule> rules = new ArrayList<>();
        private final Map<String, List<ACLRule>> cache = new ConcurrentHashMap<>();
        
        /**
         * 添加ACL规则
         */
        public void addACLRule(ACLRule rule) {
            rules.add(rule);
            clearCache();
            System.out.println("ACL规则已添加: " + rule);
        }
        
        /**
         * 删除ACL规则
         */
        public void removeACLRule(ACLRule rule) {
            boolean removed = rules.remove(rule);
            if (removed) {
                clearCache();
                System.out.println("ACL规则已删除: " + rule);
            } else {
                System.out.println("未找到要删除的ACL规则: " + rule);
            }
        }
        
        /**
         * 检查权限
         */
        public boolean checkPermission(String principal, String resource, 
                                     String operation) {
            String cacheKey = generateCacheKey(principal, resource, operation);
            
            List<ACLRule> cachedRules = cache.get(cacheKey);
            if (cachedRules != null) {
                return cachedRules.stream().anyMatch(ACLRule::isAllow);
            }
            
            List<ACLRule> matchingRules = findMatchingRules(principal, resource, operation);
            cache.put(cacheKey, matchingRules);
            
            return matchingRules.stream().anyMatch(ACLRule::isAllow);
        }
        
        private List<ACLRule> findMatchingRules(String principal, String resource, String operation) {
            return rules.stream()
                .filter(rule -> rule.matches(principal, resource, operation))
                .sorted((r1, r2) -> {
                    // 拒绝规则优先于允许规则
                    if (r1.isAllow() != r2.isAllow()) {
                        return r1.isAllow() ? 1 : -1;
                    }
                    // 更具体的资源规则优先
                    if (!r1.getResource().equals(r2.getResource())) {
                        return r1.getResource().equals("*") ? 1 : -1;
                    }
                    return 0;
                })
                .collect(Collectors.toList());
        }
        
        private String generateCacheKey(String principal, String resource, String operation) {
            return String.format("%s:%s:%s", principal, resource, operation);
        }
        
        private void clearCache() {
            cache.clear();
        }
        
        /**
         * 列出所有ACL规则
         */
        public void listACLRules() {
            System.out.println("=== ACL规则列表 ===");
            if (rules.isEmpty()) {
                System.out.println("没有配置ACL规则");
                return;
            }
            
            for (int i = 0; i < rules.size(); i++) {
                System.out.printf("%d. %s%n", i + 1, rules.get(i));
            }
        }
        
        /**
         * 根据主体列出规则
         */
        public void listRulesByPrincipal(String principal) {
            System.out.printf("=== %s 的ACL规则 ===%n", principal);
            rules.stream()
                .filter(rule -> rule.getPrincipal().equals(principal))
                .forEach(rule -> System.out.println("  " + rule));
        }
        
        /**
         * 根据资源列出规则
         */
        public void listRulesByResource(String resource) {
            System.out.printf("=== 资源 %s 的ACL规则 ===%n", resource);
            rules.stream()
                .filter(rule -> rule.getResource().equals(resource) || rule.getResource().equals("*"))
                .forEach(rule -> System.out.println("  " + rule));
        }
    }
    
    /**
     * ACL配置生成器
     */
    public static class ACLConfigGenerator {
        
        /**
         * 为用户生成完整的ACL配置
         */
        public static List<ACLRule> generateUserACLs(String username, 
                                                    Set<String> topics,
                                                    ACLPermissions.Permission... permissions) {
            List<ACLRule> rules = new ArrayList<>();
            
            for (String topic : topics) {
                for (ACLPermissions.Permission permission : permissions) {
                    // 生成主题权限
                    rules.add(new ACLRule(
                        "User:" + username,
                        permission,
                        permission.getEnglishName(),
                        topic,
                        "Topic",
                        "*",
                        true
                    ));
                }
            }
            
            return rules;
        }
        
        /**
         * 为生产环境生成安全配置
         */
        public static List<ACLRule> generateProductionSecurityRules(String adminUser) {
            List<ACLRule> rules = new ArrayList<>();
            
            // 管理员权限
            rules.add(new ACLRule(
                "User:" + adminUser,
                ACLPermissions.Permission.ALL,
                "All",
                "*",
                "Cluster",
                "*",
                true
            ));
            
            rules.add(new ACLRule(
                "User:" + adminUser,
                ACLPermissions.Permission.ALL,
                "All",
                "*",
                "Topic",
                "*",
                true
            ));
            
            // 生产者权限
            rules.add(new ACLRule(
                "User:producer",
                ACLPermissions.Permission.WRITE,
                "Write",
                "*",
                "Topic",
                "*",
                true
            ));
            
            // 消费者权限
            rules.add(new ACLRule(
                "User:consumer",
                ACLPermissions.Permission.READ,
                "Read",
                "*",
                "Topic",
                "*",
                true
            ));
            
            return rules;
        }
        
        /**
         * 生成最小权限配置
         */
        public static List<ACLRule> generateMinimumAccessRules(String username, String topic) {
            List<ACLRule> rules = new ArrayList<>();
            
            // 只读权限
            rules.add(new ACLRule(
                "User:" + username + "_reader",
                ACLPermissions.Permission.READ,
                "Read",
                topic,
                "Topic",
                "*",
                true
            ));
            
            // 只写权限
            rules.add(new ACLRule(
                "User:" + username + "_writer",
                ACLPermissions.Permission.WRITE,
                "Write",
                topic,
                "Topic",
                "*",
                true
            ));
            
            return rules;
        }
        
        /**
         * 生成安全审计配置
         */
        public static List<ACLRule> generateAuditRules(String auditUser) {
            List<ACLRule> rules = new ArrayList<>();
            
            // 审计用户权限
            rules.add(new ACLRule(
                "User:" + auditUser,
                ACLPermissions.Permission.DESCRIBE,
                "Describe",
                "*",
                "Topic",
                "*",
                true
            ));
            
            rules.add(new ACLRule(
                "User:" + auditUser,
                ACLPermissions.Permission.DESCRIBE_CONFIGS,
                "DescribeConfigs",
                "*",
                "Cluster",
                "*",
                true
            ));
            
            return rules;
        }
    }
}
```

## 审计日志与监控

### 审计日志系统

```java
/**
 * Kafka安全审计系统
 */
public class KafkaSecurityAuditSystem {
    
    /**
     * 审计事件类型
     */
    public static class AuditEvent {
        
        public enum EventType {
            AUTHENTICATION_SUCCESS("认证成功"),
            AUTHENTICATION_FAILURE("认证失败"),
            AUTHORIZATION_SUCCESS("授权成功"),
            AUTHORIZATION_FAILURE("授权失败"),
            DATA_ACCESS("数据访问"),
            CONFIGURATION_CHANGE("配置变更"),
            SYSTEM_ACCESS("系统访问"),
            ADMIN_ACTION("管理操作"),
            SECURITY_VIOLATION("安全违规");
            
            private final String description;
            
            EventType(String description) {
                this.description = description;
            }
            
            public String getDescription() { return description; }
        }
        
        private final EventType type;
        private final String user;
        private final String action;
        private final String resource;
        private final String ipAddress;
        private final String userAgent;
        private final long timestamp;
        private final String details;
        private final AuditLevel level;
        private final String source;
        
        public AuditEvent(EventType type, String user, String action, 
                         String resource, String ipAddress, String userAgent,
                         String details, AuditLevel level, String source) {
            this.type = type;
            this.user = user;
            this.action = action;
            this.resource = resource;
            this.ipAddress = ipAddress;
            this.userAgent = userAgent;
            this.timestamp = System.currentTimeMillis();
            this.details = details;
            this.level = level;
            this.source = source;
        }
        
        // Getters
        public EventType getType() { return type; }
        public String getUser() { return user; }
        public String getAction() { return action; }
        public String getResource() { return resource; }
        public String getIpAddress() { return ipAddress; }
        public String getUserAgent() { return userAgent; }
        public long getTimestamp() { return timestamp; }
        public String getDetails() { return details; }
        public AuditLevel getLevel() { return level; }
        public String getSource() { return source; }
        
        public String toLogFormat() {
            return String.format("[%s] %s | %s | %s | %s | %s | %s | %s | %s",
                new Date(timestamp),
                type.getDescription(),
                user,
                action,
                resource,
                ipAddress,
                details,
                level.name(),
                source
            );
        }
    }
    
    public enum AuditLevel {
        INFO, WARNING, ERROR, CRITICAL
    }
    
    /**
     * 审计日志管理器
     */
    public static class AuditLogManager {
        
        private final List<AuditEvent> events = new ArrayList<>();
        private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        private final String logFilePath;
        private final AuditLevel minimumLevel;
        
        public AuditLogManager(String logFilePath, AuditLevel minimumLevel) {
            this.logFilePath = logFilePath;
            this.minimumLevel = minimumLevel;
            startLogRotation();
        }
        
        /**
         * 记录审计事件
         */
        public void recordEvent(AuditEvent event) {
            if (shouldLog(event)) {
                events.add(event);
                writeToFile(event);
                
                // 检查是否需要告警
                if (shouldAlert(event)) {
                    sendAlert(event);
                }
            }
        }
        
        private boolean shouldLog(AuditEvent event) {
            return event.getLevel().ordinal() >= minimumLevel.ordinal();
        }
        
        private void writeToFile(AuditEvent event) {
            try (PrintWriter writer = new PrintWriter(
                new FileWriter(logFilePath, true))) {
                writer.println(event.toLogFormat());
            } catch (IOException e) {
                System.err.println("写入审计日志失败: " + e.getMessage());
            }
        }
        
        private boolean shouldAlert(AuditEvent event) {
            return event.getLevel() == AuditLevel.ERROR ||
                   event.getLevel() == AuditLevel.CRITICAL ||
                   event.getType() == AuditEvent.EventType.SECURITY_VIOLATION ||
                   event.getType() == AuditEvent.EventType.AUTHENTICATION_FAILURE;
        }
        
        private void sendAlert(AuditEvent event) {
            System.out.println("🚨 审计告警: " + event.toLogFormat());
            // 实际实现中，这里应该发送告警通知
        }
        
        private void startLogRotation() {
            scheduler.scheduleAtFixedRate(this::rotateLogFiles, 24, 24, TimeUnit.HOURS);
        }
        
        private void rotateLogFiles() {
            // 实现日志轮转逻辑
            try {
                File currentLog = new File(logFilePath);
                if (currentLog.exists() && currentLog.length() > 100 * 1024 * 1024) { // 100MB
                    String timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
                    File rotatedLog = new File(logFilePath + "." + timestamp);
                    currentLog.renameTo(rotatedLog);
                    
                    System.out.println("审计日志已轮转: " + rotatedLog.getName());
                }
            } catch (Exception e) {
                System.err.println("日志轮转失败: " + e.getMessage());
            }
        }
        
        /**
         * 查询审计日志
         */
        public List<AuditEvent> queryEvents(Date startTime, Date endTime, 
                                           AuditEvent.EventType type) {
            return events.stream()
                .filter(event -> event.getTimestamp() >= startTime.getTime())
                .filter(event -> event.getTimestamp() <= endTime.getTime())
                .filter(event -> type == null || event.getType() == type)
                .collect(Collectors.toList());
        }
        
        /**
         * 生成审计报告
         */
        public void generateReport(Date startTime, Date endTime) {
            List<AuditEvent> reportEvents = queryEvents(startTime, endTime, null);
            
            System.out.println("=== 审计报告 ===");
            System.out.printf("报告时间: %s - %s%n", startTime, endTime);
            System.out.printf("总事件数: %d%n", reportEvents.size());
            
            // 按事件类型统计
            Map<AuditEvent.EventType, Long> typeStats = reportEvents.stream()
                .collect(Collectors.groupingBy(AuditEvent::getType, 
                    Collectors.counting()));
            
            System.out.println("\n事件类型统计:");
            typeStats.forEach((type, count) -> 
                System.out.printf("  %s: %d%n", type.getDescription(), count));
            
            // 按用户统计
            Map<String, Long> userStats = reportEvents.stream()
                .collect(Collectors.groupingBy(AuditEvent::getUser, 
                    Collectors.counting()));
            
            System.out.println("\n用户活跃度统计:");
            userStats.forEach((user, count) -> 
                System.out.printf("  %s: %d%n", user, count));
            
            // 安全事件统计
            List<AuditEvent> securityEvents = reportEvents.stream()
                .filter(event -> event.getType() == AuditEvent.EventType.SECURITY_VIOLATION ||
                               event.getType() == AuditEvent.EventType.AUTHENTICATION_FAILURE)
                .collect(Collectors.toList());
            
            System.out.printf("\n安全事件: %d 个%n", securityEvents.size());
            if (!securityEvents.isEmpty()) {
                System.out.println("安全事件详情:");
                securityEvents.forEach(event -> 
                    System.out.println("  " + event.toLogFormat()));
            }
        }
    }
    
    /**
     * 安全监控器
     */
    public static class SecurityMonitor {
        
        private final AuditLogManager auditLog;
        private final Map<String, AuthenticationMetrics> authMetrics = new ConcurrentHashMap<>();
        private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        
        public SecurityMonitor(AuditLogManager auditLog) {
            this.auditLog = auditLog;
            startMonitoring();
        }
        
        private void startMonitoring() {
            scheduler.scheduleAtFixedRate(this::analyzeSecurityStatus, 0, 5, TimeUnit.MINUTES);
        }
        
        private void analyzeSecurityStatus() {
            long now = System.currentTimeMillis();
            long oneHourAgo = now - 60 * 60 * 1000;
            
            // 分析认证失败率
            analyzeAuthenticationFailures(oneHourAgo, now);
            
            // 分析异常访问模式
            analyzeAccessPatterns(oneHourAgo, now);
            
            // 分析系统负载异常
            analyzeSystemAnomalies(oneHourAgo, now);
        }
        
        private void analyzeAuthenticationFailures(long startTime, long endTime) {
            List<AuditEvent> authFailures = auditLog.queryEvents(
                new Date(startTime), new Date(endTime), 
                AuditEvent.EventType.AUTHENTICATION_FAILURE);
            
            if (authFailures.size() > 10) {
                System.out.println("⚠️ 检测到大量认证失败: " + authFailures.size() + " 次");
                auditLog.recordEvent(new AuditEvent(
                    AuditEvent.EventType.SECURITY_VIOLATION,
                    "system",
                    "BRUTE_FORCE_DETECTED",
                    "authentication",
                    "N/A",
                    "N/A",
                    "检测到 " + authFailures.size() + " 次认证失败",
                    AuditLevel.WARNING,
                    "SecurityMonitor"
                ));
            }
        }
        
        private void analyzeAccessPatterns(long startTime, long endTime) {
            List<AuditEvent> dataAccesses = auditLog.queryEvents(
                new Date(startTime), new Date(endTime),
                AuditEvent.EventType.DATA_ACCESS);
            
            // 分析异常访问频率
            Map<String, Long> userAccessCounts = dataAccesses.stream()
                .collect(Collectors.groupingBy(AuditEvent::getUser, 
                    Collectors.counting()));
            
            userAccessCounts.forEach((user, count) -> {
                if (count > 1000) { // 超过1000次访问
                    System.out.println("⚠️ 用户 " + user + " 访问频率异常: " + count);
                }
            });
        }
        
        private void analyzeSystemAnomalies(long startTime, long endTime) {
            // 分析系统负载相关事件
            List<AuditEvent> systemEvents = auditLog.queryEvents(
                new Date(startTime), new Date(endTime),
                AuditEvent.EventType.CONFIGURATION_CHANGE);
            
            if (systemEvents.size() > 50) {
                System.out.println("⚠️ 系统配置变更频繁: " + systemEvents.size() + " 次");
            }
        }
        
        /**
         * 认证指标
         */
        private static class AuthenticationMetrics {
            private long totalAttempts = 0;
            private long failedAttempts = 0;
            private long lastAttemptTime = 0;
            private final List<Long> attemptTimes = new ArrayList<>();
            
            public synchronized void recordAttempt(boolean success) {
                totalAttempts++;
                lastAttemptTime = System.currentTimeMillis();
                attemptTimes.add(lastAttemptTime);
                
                if (!success) {
                    failedAttempts++;
                }
                
                // 清理超过1小时的记录
                long oneHourAgo = System.currentTimeMillis() - 60 * 60 * 1000;
                attemptTimes.removeIf(time -> time < oneHourAgo);
            }
            
            public synchronized double getFailureRate() {
                return totalAttempts > 0 ? (double) failedAttempts / totalAttempts : 0;
            }
            
            public synchronized int getRecentAttempts() {
                return attemptTimes.size();
            }
        }
    }
}
```

## 网络安全配置

### 防火墙配置

```java
/**
 * 网络安全配置管理器
 */
public class NetworkSecurityConfigManager {
    
    /**
     * 网络安全策略
     */
    public static class NetworkSecurityPolicy {
        
        private final String name;
        private final Set<String> allowedIPs;
        private final Set<String> blockedIPs;
        private final Map<String, Integer> portRules;
        private final boolean enableTLS;
        private final boolean enableVPC;
        private final List<String> securityGroups;
        
        public NetworkSecurityPolicy(String name) {
            this.name = name;
            this.allowedIPs = new HashSet<>();
            this.blockedIPs = new HashSet<>();
            this.portRules = new HashMap<>();
            this.enableTLS = false;
            this.enableVPC = false;
            this.securityGroups = new ArrayList<>();
        }
        
        public NetworkSecurityPolicy addAllowedIP(String ip) {
            allowedIPs.add(ip);
            return this;
        }
        
        public NetworkSecurityPolicy addBlockedIP(String ip) {
            blockedIPs.add(ip);
            return this;
        }
        
        public NetworkSecurityPolicy addPortRule(int port, String protocol) {
            portRules.put(String.valueOf(port), getPortNumber(protocol));
            return this;
        }
        
        public NetworkSecurityPolicy enableTLSEncryption() {
            this.enableTLS = true;
            return this;
        }
        
        public NetworkSecurityPolicy enableVPC() {
            this.enableVPC = true;
            return this;
        }
        
        public NetworkSecurityPolicy addSecurityGroup(String group) {
            securityGroups.add(group);
            return this;
        }
        
        private int getPortNumber(String protocol) {
            switch (protocol.toUpperCase()) {
                case "KAFKA": return 9092;
                case "KAFKA_SSL": return 9093;
                case "JMX": return 9999;
                case "HTTP_METRICS": return 8080;
                default: throw new IllegalArgumentException("未知协议: " + protocol);
            }
        }
        
        // Getters
        public String getName() { return name; }
        public Set<String> getAllowedIPs() { return allowedIPs; }
        public Set<String> getBlockedIPs() { return blockedIPs; }
        public Map<String, Integer> getPortRules() { return portRules; }
        public boolean isTLSEnabled() { return enableTLS; }
        public boolean isVPCEnabled() { return enableVPC; }
        public List<String> getSecurityGroups() { return securityGroups; }
    }
    
    /**
     * 防火墙规则生成器
