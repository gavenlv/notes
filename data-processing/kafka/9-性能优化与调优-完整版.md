# ç¬¬9ç« ï¼šæ€§èƒ½ä¼˜åŒ–ä¸è°ƒä¼˜

## ç›®å½•
1. [æ€§èƒ½è°ƒä¼˜æ¦‚è¿°](#æ€§èƒ½è°ƒä¼˜æ¦‚è¿°)
2. [ç”Ÿäº§è€…æ€§èƒ½ä¼˜åŒ–](#ç”Ÿäº§è€…æ€§èƒ½ä¼˜åŒ–)
3. [æ¶ˆè´¹è€…æ€§èƒ½ä¼˜åŒ–](#æ¶ˆè´¹è€…æ€§èƒ½ä¼˜åŒ–)
4. [Brokeræ€§èƒ½è°ƒä¼˜](#brokeræ€§èƒ½è°ƒä¼˜)
5. [å­˜å‚¨æ€§èƒ½ä¼˜åŒ–](#å­˜å‚¨æ€§èƒ½ä¼˜åŒ–)
6. [ç½‘ç»œè°ƒä¼˜](#ç½‘ç»œè°ƒä¼˜)
7. [ç›‘æ§ä¸æŒ‡æ ‡åˆ†æ](#ç›‘æ§ä¸æŒ‡æ ‡åˆ†æ)
8. [æ€§èƒ½åŸºå‡†æµ‹è¯•](#æ€§èƒ½åŸºå‡†æµ‹è¯•)
9. [æ€§èƒ½è°ƒä¼˜æœ€ä½³å®è·µ](#æ€§èƒ½è°ƒä¼˜æœ€ä½³å®è·µ)
10. [å®æˆ˜æ¡ˆä¾‹](#å®æˆ˜æ¡ˆä¾‹)

## æ€§èƒ½è°ƒä¼˜æ¦‚è¿°

### æ€§èƒ½æŒ‡æ ‡ä½“ç³»

Kafkaæ€§èƒ½è°ƒä¼˜æ¶‰åŠå¤šä¸ªç»´åº¦çš„æŒ‡æ ‡ï¼š

- **ååé‡**ï¼šæ¯ç§’å¤„ç†çš„æ¶ˆæ¯æ•°
- **å»¶è¿Ÿ**ï¼šç«¯åˆ°ç«¯æ¶ˆæ¯ä¼ è¾“æ—¶é—´
- **å¹¶å‘æ€§**ï¼šåŒæ—¶å¤„ç†è¿æ¥å’Œè¯·æ±‚çš„èƒ½åŠ›
- **å¯ç”¨æ€§**ï¼šç³»ç»ŸæŒç»­æœåŠ¡çš„èƒ½åŠ›
- **èµ„æºåˆ©ç”¨ç‡**ï¼šCPUã€å†…å­˜ã€ç£ç›˜ã€ç½‘ç»œçš„ä½¿ç”¨æ•ˆç‡

### è°ƒä¼˜ç­–ç•¥

```java
/**
 * Kafkaæ€§èƒ½è°ƒä¼˜ç­–ç•¥ç±»
 */
public class KafkaTuningStrategy {
    
    /**
     * æ€§èƒ½ç“¶é¢ˆåˆ†æ
     */
    public static class PerformanceBottleneckAnalysis {
        
        public enum BottleneckType {
            PRODUCER_LATENCY,      // ç”Ÿäº§è€…å»¶è¿Ÿ
            CONSUMER_LAG,          // æ¶ˆè´¹è€…å»¶è¿Ÿ
            BROKER_CPU,           // Broker CPUç“¶é¢ˆ
            DISK_IO,              // ç£ç›˜I/Oç“¶é¢ˆ
            NETWORK_BANDWIDTH,    // ç½‘ç»œå¸¦å®½ç“¶é¢ˆ
            MEMORY_PRESSURE       // å†…å­˜å‹åŠ›
        }
        
        public static class BottleneckAnalysis {
            private final BottleneckType type;
            private final String description;
            private final double impact;
            private final List<String> recommendations;
            
            public BottleneckAnalysis(BottleneckType type, String description, 
                                    double impact, List<String> recommendations) {
                this.type = type;
                this.description = description;
                this.impact = impact;
                this.recommendations = recommendations;
            }
            
            // Getters
            public BottleneckType getType() { return type; }
            public String getDescription() { return description; }
            public double getImpact() { return impact; }
            public List<String> getRecommendations() { return recommendations; }
        }
        
        public static List<BottleneckAnalysis> analyzeBottlenecks(
                Map<String, Object> metrics) {
            List<BottleneckAnalysis> bottlenecks = new ArrayList<>();
            
            // åˆ†æç”Ÿäº§è€…å»¶è¿Ÿ
            if (metrics.containsKey("producer_avg_latency")) {
                double latency = (Double) metrics.get("producer_avg_latency");
                if (latency > 100) {
                    bottlenecks.add(new BottleneckAnalysis(
                        BottleneckType.PRODUCER_LATENCY,
                        String.format("ç”Ÿäº§è€…å¹³å‡å»¶è¿Ÿè¿‡é«˜: %.2fms", latency),
                        Math.min(latency / 100.0, 5.0),
                        Arrays.asList(
                            "å¢åŠ batch.sizeå‚æ•°",
                            "è°ƒæ•´linger.mså‚æ•°",
                            "ä¼˜åŒ–ç½‘ç»œé…ç½®",
                            "æ£€æŸ¥Brokerå“åº”æ—¶é—´"
                        )
                    ));
                }
            }
            
            // åˆ†ææ¶ˆè´¹è€…å»¶è¿Ÿ
            if (metrics.containsKey("consumer_lag")) {
                long lag = (Long) metrics.get("consumer_lag");
                if (lag > 10000) {
                    bottlenecks.add(new BottleneckAnalysis(
                        BottleneckType.CONSUMER_LAG,
                        String.format("æ¶ˆè´¹è€…å»¶è¿Ÿè¿‡é«˜: %dæ¡æ¶ˆæ¯", lag),
                        Math.min(lag / 10000.0, 5.0),
                        Arrays.asList(
                            "å¢åŠ æ¶ˆè´¹è€…å®ä¾‹æ•°é‡",
                            "ä¼˜åŒ–æ¶ˆè´¹è€…å¤„ç†é€»è¾‘",
                            "è°ƒæ•´åˆ†åŒºæ•°é‡",
                            "æ£€æŸ¥æ¶ˆæ¯å¤„ç†é€Ÿåº¦"
                        )
                    ));
                }
            }
            
            // åˆ†æCPUä½¿ç”¨ç‡
            if (metrics.containsKey("broker_cpu_usage")) {
                double cpuUsage = (Double) metrics.get("broker_cpu_usage");
                if (cpuUsage > 80) {
                    bottlenecks.add(new BottleneckAnalysis(
                        BottleneckType.BROKER_CPU,
                        String.format("Broker CPUä½¿ç”¨ç‡è¿‡é«˜: %.2f%%", cpuUsage),
                        Math.min(cpuUsage / 80.0, 5.0),
                        Arrays.asList(
                            "ä¼˜åŒ–JVMå‚æ•°",
                            "å¢åŠ Brokerå®ä¾‹",
                            "è°ƒæ•´num.io.threads",
                            "å‡å°‘ä¸å¿…è¦çš„åºåˆ—åŒ–/ååºåˆ—åŒ–"
                        )
                    ));
                }
            }
            
            // åˆ†æç£ç›˜I/O
            if (metrics.containsKey("disk_io_utilization")) {
                double diskUtil = (Double) metrics.get("disk_io_utilization");
                if (diskUtil > 90) {
                    bottlenecks.add(new BottleneckAnalysis(
                        BottleneckType.DISK_IO,
                        String.format("ç£ç›˜I/Oä½¿ç”¨ç‡è¿‡é«˜: %.2f%%", diskUtil),
                        Math.min(diskUtil / 90.0, 5.0),
                        Arrays.asList(
                            "ä½¿ç”¨SSDå­˜å‚¨",
                            "å¢åŠ ç£ç›˜å¹¶è¡Œåº¦",
                            "ä¼˜åŒ–æ—¥å¿—æ®µé…ç½®",
                            "è°ƒæ•´I/Oè°ƒåº¦å™¨"
                        )
                    ));
                }
            }
            
            // åˆ†æç½‘ç»œå¸¦å®½
            if (metrics.containsKey("network_bytes_in_per_sec")) {
                double networkIn = (Double) metrics.get("network_bytes_in_per_sec");
                if (networkIn > 100 * 1024 * 1024) { // 100MB/s
                    bottlenecks.add(new BottleneckAnalysis(
                        BottleneckType.NETWORK_BANDWIDTH,
                        String.format("ç½‘ç»œå¸¦å®½ä½¿ç”¨è¾ƒé«˜: %.2f MB/s", networkIn / (1024 * 1024)),
                        Math.min(networkIn / (100 * 1024 * 1024.0), 5.0),
                        Arrays.asList(
                            "å¯ç”¨æ¶ˆæ¯å‹ç¼©",
                            "ä¼˜åŒ–æ¶ˆæ¯å¤§å°",
                            "å¢åŠ ç½‘ç»œå¸¦å®½",
                            "ä½¿ç”¨æ›´é«˜æ•ˆçš„ç½‘ç»œåè®®"
                        )
                    ));
                }
            }
            
            return bottlenecks;
        }
        
        public static void printBottleneckAnalysis(List<BottleneckAnalysis> bottlenecks) {
            System.out.println("=== æ€§èƒ½ç“¶é¢ˆåˆ†æ ===");
            
            if (bottlenecks.isEmpty()) {
                System.out.println("âœ… æœªå‘ç°æ˜æ˜¾çš„æ€§èƒ½ç“¶é¢ˆ");
                return;
            }
            
            // æŒ‰å½±å“ç¨‹åº¦æ’åº
            bottlenecks.sort((a, b) -> Double.compare(b.getImpact(), a.getImpact()));
            
            System.out.printf("å‘ç° %d ä¸ªæ€§èƒ½ç“¶é¢ˆ:%n%n", bottlenecks.size());
            
            for (int i = 0; i < bottlenecks.size(); i++) {
                BottleneckAnalysis analysis = bottlenecks.get(i);
                System.out.println((i + 1) + ". " + analysis.getDescription());
                System.out.println("   å½±å“ç¨‹åº¦: " + String.format("%.2f/5.0", analysis.getImpact()));
                System.out.println("   è°ƒä¼˜å»ºè®®:");
                analysis.getRecommendations().forEach(rec -> 
                    System.out.println("     - " + rec));
                System.out.println();
            }
        }
    }
    
    /**
     * è°ƒä¼˜ç­–ç•¥åˆ¶å®š
     */
    public static class TuningStrategy {
        
        public static class StrategyConfig {
            private final String targetThroughput;
            private final String targetLatency;
            private final int maxProducers;
            private final int maxConsumers;
            private final List<String> optimizationAreas;
            
            public StrategyConfig(String targetThroughput, String targetLatency,
                                int maxProducers, int maxConsumers,
                                List<String> optimizationAreas) {
                this.targetThroughput = targetThroughput;
                this.targetLatency = targetLatency;
                this.maxProducers = maxProducers;
                this.maxConsumers = maxConsumers;
                this.optimizationAreas = optimizationAreas;
            }
            
            // Getters
            public String getTargetThroughput() { return targetThroughput; }
            public String getTargetLatency() { return targetLatency; }
            public int getMaxProducers() { return maxProducers; }
            public int getMaxConsumers() { return maxConsumers; }
            public List<String> getOptimizationAreas() { return optimizationAreas; }
        }
        
        public static StrategyConfig createHighThroughputStrategy() {
            return new StrategyConfig(
                "100,000 msg/sec",
                "< 50ms",
                20,
                100,
                Arrays.asList(
                    "batch.processing",
                    "compression",
                    "parallelism",
                    "io.optimization"
                )
            );
        }
        
        public static StrategyConfig createLowLatencyStrategy() {
            return new StrategyConfig(
                "50,000 msg/sec",
                "< 10ms",
                10,
                50,
                Arrays.asList(
                    "network.optimization",
                    "memory.buffer",
                    "direct.io",
                    "thread.pooling"
                )
            );
        }
        
        public static StrategyConfig createBalancedStrategy() {
            return new StrategyConfig(
                "75,000 msg/sec",
                "< 25ms",
                15,
                75,
                Arrays.asList(
                    "balanced.configuration",
                    "resource.allocation",
                    "monitoring.instrumentation"
                )
            );
        }
    }
}
```

## ç”Ÿäº§è€…æ€§èƒ½ä¼˜åŒ–

### æ‰¹é‡å¤„ç†ä¼˜åŒ–

```java
/**
 * æ‰¹é‡å¤„ç†ä¼˜åŒ–ç¤ºä¾‹
 */
public class ProducerBatchOptimization {
    
    /**
     * ä¼˜åŒ–çš„ç”Ÿäº§è€…é…ç½®
     */
    public static class OptimizedProducerConfig {
        
        public static Properties getHighThroughputConfig() {
            Properties props = new Properties();
            
            // åŸºç¡€é…ç½®
            props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
            props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
            props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");
            
            // æ‰¹é‡å¤„ç†ä¼˜åŒ–
            props.put(ProducerConfig.BATCH_SIZE_CONFIG, 32768); // 32KB
            props.put(ProducerConfig.LINGER_MS_CONFIG, 20); // 20msç­‰å¾…
            props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, 67108864); // 64MB
            
            // å‹ç¼©ä¼˜åŒ–
            props.put(ProducerConfig.COMPRESSION_TYPE_CONFIG, "lz4");
            
            // å†…å­˜ä¼˜åŒ–
            props.put("max.in.flight.requests.per.connection", 5);
            props.put("max.block.ms", 60000);
            
            // å¹‚ç­‰æ€§
            props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);
            props.put("retries", 3);
            
            // é‡è¯•é€€é¿
            props.put("request.timeout.ms", 30000);
            props.put("retry.backoff.ms", 100);
            
            return props;
        }
        
        public static Properties getLowLatencyConfig() {
            Properties props = new Properties();
            
            // åŸºç¡€é…ç½®
            props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
            props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
            props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");
            
            // ä½å»¶è¿Ÿé…ç½®
            props.put(ProducerConfig.BATCH_SIZE_CONFIG, 8192); // 8KB
            props.put(ProducerConfig.LINGER_MS_CONFIG, 0); // ç«‹å³å‘é€
            props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, 33554432); // 32MB
            
            // å‹ç¼©ï¼ˆè½»å¾®å½±å“å»¶è¿Ÿï¼‰
            props.put(ProducerConfig.COMPRESSION_TYPE_CONFIG, "snappy");
            
            // é«˜å¹¶å‘
            props.put("max.in.flight.requests.per.connection", 1);
            
            return props;
        }
    }
    
    /**
     * æ‰¹é‡å‘é€ç›‘æ§å™¨
     */
    public static class BatchMonitoring {
        
        private final Map<String, BatchMetrics> batchMetrics = new ConcurrentHashMap<>();
        
        public void recordBatchSend(String topic, int batchSize, long sendTimeMs) {
            BatchMetrics metrics = batchMetrics.computeIfAbsent(topic, 
                k -> new BatchMetrics());
            metrics.recordBatch(batchSize, sendTimeMs);
        }
        
        public BatchMetrics getBatchMetrics(String topic) {
            return batchMetrics.get(topic);
        }
        
        public static class BatchMetrics {
            private long totalBatches = 0;
            private long totalMessages = 0;
            private double avgBatchSize = 0;
            private double avgSendTime = 0;
            private final List<Integer> batchSizeHistory = new ArrayList<>();
            private final List<Long> sendTimeHistory = new ArrayList<>();
            
            public synchronized void recordBatch(int batchSize, long sendTime) {
                totalBatches++;
                totalMessages += batchSize;
                
                // ç»´æŠ¤å†å²è®°å½•ï¼ˆæœ€è¿‘1000æ¡ï¼‰
                batchSizeHistory.add(batchSize);
                sendTimeHistory.add(sendTime);
                
                if (batchSizeHistory.size() > 1000) {
                    batchSizeHistory.remove(0);
                    sendTimeHistory.remove(0);
                }
                
                // è®¡ç®—å¹³å‡å€¼
                avgBatchSize = batchSizeHistory.stream()
                    .mapToInt(Integer::intValue)
                    .average()
                    .orElse(0.0);
                    
                avgSendTime = sendTimeHistory.stream()
                    .mapToLong(Long::longValue)
                    .average()
                    .orElse(0.0);
            }
            
            public void printReport() {
                System.out.println("=== æ‰¹é‡å‘é€æŠ¥å‘Š ===");
                System.out.printf("æ€»æ‰¹æ¬¡æ•°: %d%n", totalBatches);
                System.out.printf("æ€»æ¶ˆæ¯æ•°: %d%n", totalMessages);
                System.out.printf("å¹³å‡æ‰¹é‡å¤§å°: %.2f%n", avgBatchSize);
                System.out.printf("å¹³å‡å‘é€æ—¶é—´: %.2f ms%n", avgSendTime);
                System.out.printf("ååé‡: %.2f msg/sec%n", 
                    totalMessages / (avgSendTime / 1000.0));
            }
        }
    }
    
    /**
     * åŠ¨æ€æ‰¹é‡è°ƒä¼˜
     */
    public static class DynamicBatchTuning {
        
        private final BatchMonitoring monitoring;
        private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        
        public DynamicBatchTuning(BatchMonitoring monitoring) {
            this.monitoring = monitoring;
        }
        
        public void startDynamicTuning(String topic) {
            scheduler.scheduleAtFixedRate(() -> {
                BatchMetrics metrics = monitoring.getBatchMetrics(topic);
                if (metrics != null) {
                    double avgBatchSize = metrics.avgBatchSize;
                    double avgSendTime = metrics.avgSendTime;
                    
                    // æ ¹æ®æŒ‡æ ‡è°ƒæ•´é…ç½®
                    if (avgBatchSize < 1000 && avgSendTime < 10) {
                        // å¯ä»¥å¢å¤§batch.size
                        System.out.println("å»ºè®®å¢å¤§batch.sizeä»¥æé«˜ååé‡");
                    } else if (avgSendTime > 50) {
                        // å‘é€æ—¶é—´è¿‡é•¿ï¼Œå‡å°batch.sizeæˆ–å¢å¤§linger.ms
                        System.out.println("å»ºè®®å‡å°batch.sizeä»¥é™ä½å»¶è¿Ÿ");
                    }
                }
            }, 60, 60, TimeUnit.SECONDS);
        }
        
        public void stopDynamicTuning() {
            scheduler.shutdown();
        }
    }
}
```

### å‹ç¼©ä¼˜åŒ–

```java
/**
 * æ¶ˆæ¯å‹ç¼©ä¼˜åŒ–
 */
public class CompressionOptimization {
    
    public enum CompressionType {
        NONE("none", 0, 0),
        GZIP("gzip", 60, 5),
        SNAPPY("snappy", 50, 2),
        LZ4("lz4", 40, 1),
        ZSTD("zstd", 70, 3);
        
        private final String name;
        private final int compressionRatio;
        private final int cpuCost;
        
        CompressionType(String name, int compressionRatio, int cpuCost) {
            this.name = name;
            this.compressionRatio = compressionRatio;
            this.cpuCost = cpuCost;
        }
        
        public String getName() { return name; }
        public int getCompressionRatio() { return compressionRatio; }
        public int getCpuCost() { return cpuCost; }
    }
    
    public static class CompressionBenchmark {
        
        public static CompressionResult benchmarkCompression(String testData, CompressionType type) {
            long startTime = System.nanoTime();
            byte[] originalData = testData.getBytes();
            
            byte[] compressedData;
            try {
                switch (type) {
                    case GZIP:
                        compressedData = gzipCompress(originalData);
                        break;
                    case SNAPPY:
                        compressedData = snappyCompress(originalData);
                        break;
                    case LZ4:
                        compressedData = lz4Compress(originalData);
                        break;
                    case ZSTD:
                        compressedData = zstdCompress(originalData);
                        break;
                    default:
                        compressedData = originalData;
                }
            } catch (Exception e) {
                throw new RuntimeException("å‹ç¼©å¤±è´¥: " + type.getName(), e);
            }
            
            long endTime = System.nanoTime();
            long compressionTime = (endTime - startTime) / 1000000; // ms
            
            return new CompressionResult(
                type,
                originalData.length,
                compressedData.length,
                compressionTime,
                (1.0 - (double) compressedData.length / originalData.length) * 100
            );
        }
        
        // æ¨¡æ‹Ÿå‹ç¼©ç®—æ³•å®ç°
        private static byte[] gzipCompress(byte[] data) {
            // å®é™…å®ç°ä¸­åº”ä½¿ç”¨GZIPOutputStream
            return java.util.zip.DeflaterOutputStream.class.getName().getBytes();
        }
        
        private static byte[] snappyCompress(byte[] data) {
            // å®é™…å®ç°ä¸­åº”ä½¿ç”¨SnappyOutputStream
            return new byte[data.length / 2]; // æ¨¡æ‹Ÿå‹ç¼©
        }
        
        private static byte[] lz4Compress(byte[] data) {
            // å®é™…å®ç°ä¸­åº”ä½¿ç”¨LZ4OutputStream
            return new byte[data.length / 3]; // æ¨¡æ‹Ÿå‹ç¼©
        }
        
        private static byte[] zstdCompress(byte[] data) {
            // å®é™…å®ç°ä¸­åº”ä½¿ç”¨ZstdOutputStream
            return new byte[data.length / 4]; // æ¨¡æ‹Ÿå‹ç¼©
        }
        
        public static class CompressionResult {
            private final CompressionType type;
            private final int originalSize;
            private final int compressedSize;
            private final long compressionTime;
            private final double compressionRatio;
            
            public CompressionResult(CompressionType type, int originalSize, 
                                   int compressedSize, long compressionTime, 
                                   double compressionRatio) {
                this.type = type;
                this.originalSize = originalSize;
                this.compressedSize = compressedSize;
                this.compressionTime = compressionTime;
                this.compressionRatio = compressionRatio;
            }
            
            // Getters
            public CompressionType getType() { return type; }
            public int getOriginalSize() { return originalSize; }
            public int getCompressedSize() { return compressedSize; }
            public long getCompressionTime() { return compressionTime; }
            public double getCompressionRatio() { return compressionRatio; }
        }
        
        public static void printComparisonReport(List<CompressionResult> results) {
            System.out.println("=== å‹ç¼©ç®—æ³•å¯¹æ¯” ===");
            System.out.printf("%-10s %-12s %-12s %-12s %-12s%n", 
                "ç®—æ³•", "åŸå§‹å¤§å°", "å‹ç¼©å¤§å°", "å‹ç¼©æ—¶é—´", "å‹ç¼©æ¯”");
            System.out.println("-".repeat(70));
            
            for (CompressionResult result : results) {
                System.out.printf("%-10s %-12d %-12d %-12d %-10.2f%%%n",
                    result.getType().getName(),
                    result.getOriginalSize(),
                    result.getCompressedSize(),
                    result.getCompressionTime(),
                    result.getCompressionRatio());
            }
        }
    }
    
    public static class CompressionRecommendation {
        
        public static CompressionType recommendCompression(String scenario, 
                                                         int messageSize, 
                                                         double throughput) {
            if (messageSize > 10000) {
                // å¤§æ¶ˆæ¯ä½¿ç”¨é«˜å‹ç¼©æ¯”ç®—æ³•
                if (throughput < 10000) {
                    return CompressionType.GZIP; // æœ€å¤§åŒ–å‹ç¼©æ¯”
                } else {
                    return CompressionType.LZ4; // å¹³è¡¡å‹ç¼©æ¯”å’Œé€Ÿåº¦
                }
            } else if (messageSize > 1000) {
                // ä¸­ç­‰æ¶ˆæ¯
                if (throughput > 50000) {
                    return CompressionType.SNAPPY; // ä½å»¶è¿Ÿ
                } else {
                    return CompressionType.LZ4; // å¹³è¡¡
                }
            } else {
                // å°æ¶ˆæ¯é¿å…å‹ç¼©
                return CompressionType.NONE;
            }
        }
        
        public static void printRecommendationGuide() {
            System.out.println("=== å‹ç¼©ç®—æ³•é€‰æ‹©æŒ‡å— ===");
            System.out.println();
            System.out.println("åœºæ™¯1: é«˜ååå°æ¶ˆæ¯ (< 1KB)");
            System.out.println("  æ¨è: æ— å‹ç¼©");
            System.out.println("  åŸå› : å‹ç¼©å¼€é”€è¶…è¿‡èŠ‚çœçš„å¸¦å®½");
            System.out.println();
            
            System.out.println("åœºæ™¯2: ä¸­ç­‰å¤§å°æ¶ˆæ¯ (1KB - 10KB)");
            System.out.println("  æ¨è: LZ4 æˆ– Snappy");
            System.out.println("  åŸå› : è¾ƒå¥½çš„å‹ç¼©æ¯”å’Œä½å»¶è¿Ÿ");
            System.out.println();
            
            System.out.println("åœºæ™¯3: å¤§æ¶ˆæ¯ (> 10KB)");
            System.out.println("  æ¨è: GZIP æˆ– ZSTD");
            System.out.println("  åŸå› : æœ€å¤§åŒ–å‹ç¼©æ¯”ï¼ŒèŠ‚çœå­˜å‚¨");
            System.out.println();
            
            System.out.println("åœºæ™¯4: å¸¦å®½å—é™");
            System.out.println("  æ¨è: ZSTD");
            System.out.println("  åŸå› : æœ€é«˜çš„å‹ç¼©æ¯”");
            System.out.println();
            
            System.out.println("åœºæ™¯5: CPUå—é™");
            System.out.println("  æ¨è: Snappy");
            System.out.println("  åŸå› : æœ€å¿«çš„å‹ç¼©é€Ÿåº¦");
        }
    }
}
```

## æ¶ˆè´¹è€…æ€§èƒ½ä¼˜åŒ–

### æ¶ˆè´¹æ¨¡å¼ä¼˜åŒ–

```java
/**
 * æ¶ˆè´¹è€…æ€§èƒ½ä¼˜åŒ–
 */
public class ConsumerPerformanceOptimization {
    
    /**
     * ä¼˜åŒ–çš„æ¶ˆè´¹è€…é…ç½®
     */
    public static class OptimizedConsumerConfig {
        
        public static Properties getHighThroughputConfig() {
            Properties props = new Properties();
            
            // åŸºç¡€é…ç½®
            props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
            props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
            props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
            
            // æ‰¹é‡æ¶ˆè´¹ä¼˜åŒ–
            props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 500);
            props.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, 300000);
            props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, 30000);
            props.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, 3000);
            
            // åˆ†åŒºåˆ†é…ç­–ç•¥
            props.put(ConsumerConfig.PARTITION_ASSIGNMENT_STRATEGY_CONFIG, 
                "org.apache.kafka.clients.consumer.RangeAssignor");
            
            // è‡ªåŠ¨æäº¤ä¼˜åŒ–
            props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);
            
            return props;
        }
        
        public static Properties getLowLatencyConfig() {
            Properties props = new Properties();
            
            // åŸºç¡€é…ç½®
            props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
            props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
            props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
            
            // ä½å»¶è¿Ÿé…ç½®
            props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 100);
            props.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, 60000);
            props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, 10000);
            props.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, 1000);
            
            // é¢‘ç¹æäº¤
            props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, true);
            props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, 100);
            
            return props;
        }
    }
    
    /**
     * æ‰¹é‡æ¶ˆè´¹å¤„ç†å™¨
     */
    public static class BatchConsumerProcessor {
        
        private final int batchSize;
        private final CountDownLatch latch;
        private final List<ConsumerRecord<String, String>> buffer = new ArrayList<>();
        
        public BatchConsumerProcessor(int batchSize, CountDownLatch latch) {
            this.batchSize = batchSize;
            this.latch = latch;
        }
        
        public void processRecords(ConsumerRecords<String, String> records) {
            for (ConsumerRecord<String, String> record : records) {
                buffer.add(record);
                
                // å½“ç¼“å†²åŒºè¾¾åˆ°æ‰¹é‡å¤§å°æ—¶å¤„ç†
                if (buffer.size() >= batchSize) {
                    processBatch();
                }
            }
        }
        
        private void processBatch() {
            // æ‰¹é‡å¤„ç†é€»è¾‘
            System.out.printf("å¤„ç† %d æ¡æ¶ˆæ¯%n", buffer.size());
            
            // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            buffer.clear();
        }
        
        public void flush() {
            if (!buffer.isEmpty()) {
                processBatch();
            }
        }
    }
    
    /**
     * æ¶ˆè´¹è€…æ€§èƒ½ç›‘æ§
     */
    public static class ConsumerPerformanceMonitor {
        
        private final Map<TopicPartition, PartitionMetrics> partitionMetrics = 
            new ConcurrentHashMap<>();
        
        public void recordConsumption(TopicPartition partition, ConsumerRecord<String, String> record) {
            PartitionMetrics metrics = partitionMetrics.computeIfAbsent(partition,
                k -> new PartitionMetrics());
            metrics.recordMessage(record);
        }
        
        public static class PartitionMetrics {
            private long totalMessages = 0;
            private long totalBytes = 0;
            private long startTime = System.currentTimeMillis();
            private final List<Long> processingTimes = new ArrayList<>();
            
            public synchronized void recordMessage(ConsumerRecord<String, String> record) {
                totalMessages++;
                totalBytes += record.serializedValueSize();
                
                processingTimes.add(record.timestamp());
                if (processingTimes.size() > 1000) {
                    processingTimes.remove(0);
                }
            }
            
            public synchronized double getThroughput() {
                long elapsedTime = System.currentTimeMillis() - startTime;
                return totalMessages / (elapsedTime / 1000.0);
            }
            
            public synchronized double getThroughputBytes() {
                long elapsedTime = System.currentTimeMillis() - startTime;
                return totalBytes / (elapsedTime / 1000.0);
            }
        }
        
        public void printPerformanceReport() {
            System.out.println("=== æ¶ˆè´¹è€…æ€§èƒ½æŠ¥å‘Š ===");
            partitionMetrics.forEach((partition, metrics) -> {
                System.out.println("åˆ†åŒº " + partition + ":");
                System.out.printf("  ååé‡: %.2f msg/sec%n", metrics.getThroughput());
                System.out.printf("  ååé‡: %.2f KB/sec%n", metrics.getThroughputBytes() / 1024);
            });
        }
    }
}
```

## Brokeræ€§èƒ½è°ƒä¼˜

### Brokerèµ„æºä¼˜åŒ–

```java
/**
 * Brokeræ€§èƒ½è°ƒä¼˜
 */
public class BrokerPerformanceTuning {
    
    /**
     * Brokeré…ç½®ä¼˜åŒ–
     */
    public static class BrokerConfigOptimization {
        
        public static class OptimizedBrokerConfig {
            private final Properties config;
            
            public OptimizedBrokerConfig() {
                config = new Properties();
                
                // ç½‘ç»œå’ŒI/Oé…ç½®
                config.put("num.network.threads", "8");
                config.put("num.io.threads", "16");
                config.put("socket.send.buffer.bytes", "102400");
                config.put("socket.receive.buffer.bytes", "102400");
                config.put("socket.request.max.bytes", "104857600");
                
                // æ—¥å¿—é…ç½®
                config.put("log.dirs", "/data/kafka-logs");
                config.put("log.segment.bytes", "1073741824"); // 1GB
                config.put("log.retention.hours", "168"); // 7å¤©
                config.put("log.retention.check.interval.ms", "300000");
                config.put("log.cleanup.policy", "delete");
                config.put("log.cleaner.threads", "2");
                
                // å‹ç¼©é…ç½®
                config.put("compression.type", "lz4");
                
                // æ§åˆ¶å™¨é…ç½®
                config.put("num.replica.fetchers", "4");
                config.put("replica.fetch.max.bytes", "1048576");
                config.put("replica.fetch.wait.max.ms", "500");
                config.put("min.insync.replicas", "2");
                
                // æ¶ˆè´¹é…ç½®
                config.put("offsets.topic.replication.factor", "3");
                config.put("offsets.topic.segment.bytes", "104857600");
                config.put("offsets.retention.minutes", "10080");
                
                // äº‹åŠ¡é…ç½®
                config.put("transaction.state.log.replication.factor", "3");
                config.put("transaction.state.log.min.isr", "2");
            }
            
            public Properties getConfig() { return config; }
            
            public OptimizedBrokerConfig withHighThroughput() {
                config.setProperty("num.io.threads", "32");
                config.setProperty("log.segment.bytes", "2147483648"); // 2GB
                config.put("compression.type", "gzip");
                return this;
            }
            
            public OptimizedBrokerConfig withLowLatency() {
                config.setProperty("num.network.threads", "16");
                config.setProperty("num.io.threads", "24");
                config.put("compression.type", "snappy");
                return this;
            }
        }
    }
    
    /**
     * Brokeræ€§èƒ½ç›‘æ§
     */
    public static class BrokerPerformanceMonitor {
        
        public static class BrokerMetrics {
            private final String brokerId;
            private final Map<String, Object> jmxMetrics = new ConcurrentHashMap<>();
            private final ScheduledExecutorService scheduler = 
                Executors.newScheduledThreadPool(1);
            
            public BrokerMetrics(String brokerId) {
                this.brokerId = brokerId;
            }
            
            public void startMonitoring() {
                scheduler.scheduleAtFixedRate(this::collectMetrics, 0, 30, TimeUnit.SECONDS);
            }
            
            public void stopMonitoring() {
                scheduler.shutdown();
            }
            
            private void collectMetrics() {
                // æ”¶é›†JMXæŒ‡æ ‡
                jmxMetrics.put("kafka.server.BrokerTopicMetrics.BytesInPerSec", 
                    Math.random() * 1000000);
                jmxMetrics.put("kafka.server.BrokerTopicMetrics.MessagesInPerSec", 
                    Math.random() * 10000);
                jmxMetrics.put("kafka.log.LogFlushRateAndTimeMs", 
                    Math.random() * 50);
                jmxMetrics.put("kafka.network.SocketServerStats.BytesReadPerSec", 
                    Math.random() * 500000);
            }
            
            public Map<String, Object> getMetrics() {
                return new HashMap<>(jmxMetrics);
            }
        }
        
        public static class ClusterPerformanceAnalyzer {
            
            public static void analyzeClusterPerformance(List<BrokerMetrics> brokerMetrics) {
                System.out.println("=== é›†ç¾¤æ€§èƒ½åˆ†æ ===");
                
                // è®¡ç®—é›†ç¾¤æ€»ååé‡
                double totalBytesIn = brokerMetrics.stream()
                    .mapToDouble(bm -> (Double) bm.getMetrics()
                        .getOrDefault("kafka.server.BrokerTopicMetrics.BytesInPerSec", 0.0))
                    .sum();
                    
                double totalMessagesIn = brokerMetrics.stream()
                    .mapToDouble(bm -> (Double) bm.getMetrics()
                        .getOrDefault("kafka.server.BrokerTopicMetrics.MessagesInPerSec", 0.0))
                    .sum();
                
                System.out.printf("é›†ç¾¤æ€»ååé‡: %.2f MB/s%n", totalBytesIn / (1024 * 1024));
                System.out.printf("é›†ç¾¤æ€»æ¶ˆæ¯æ•°: %.2f msg/s%n", totalMessagesIn);
                
                // åˆ†æè´Ÿè½½åˆ†å¸ƒ
                analyzeLoadDistribution(brokerMetrics);
                
                // è¯†åˆ«ç“¶é¢ˆ
                identifyBottlenecks(brokerMetrics);
            }
            
            private static void analyzeLoadDistribution(List<BrokerMetrics> brokerMetrics) {
                System.out.println("\n=== è´Ÿè½½åˆ†å¸ƒåˆ†æ ===");
                
                double maxThroughput = brokerMetrics.stream()
                    .mapToDouble(bm -> (Double) bm.getMetrics()
                        .getOrDefault("kafka.server.BrokerTopicMetrics.BytesInPerSec", 0.0))
                    .max()
                    .orElse(0.0);
                
                brokerMetrics.forEach(bm -> {
                    double throughput = (Double) bm.getMetrics()
                        .getOrDefault("kafka.server.BrokerTopicMetrics.BytesInPerSec", 0.0);
                    double loadPercent = (throughput / maxThroughput) * 100;
                    
                    System.out.printf("Broker %s: %.1f%% è´Ÿè½½%n", 
                        bm.brokerId, loadPercent);
                });
            }
            
            private static void identifyBottlenecks(List<BrokerMetrics> brokerMetrics) {
                System.out.println("\n=== ç“¶é¢ˆåˆ†æ ===");
                
                for (BrokerMetrics bm : brokerMetrics) {
                    Map<String, Object> metrics = bm.getMetrics();
                    
                    // æ£€æŸ¥ç£ç›˜I/O
                    double flushTime = (Double) metrics
                        .getOrDefault("kafka.log.LogFlushRateAndTimeMs", 0.0);
                    if (flushTime > 100) {
                        System.out.printf("Broker %s: ç£ç›˜I/Oç“¶é¢ˆ (åˆ·æ–°æ—¶é—´: %.2f ms)%n", 
                            bm.brokerId, flushTime);
                    }
                    
                    // æ£€æŸ¥ç½‘ç»œ
                    double networkRead = (Double) metrics
                        .getOrDefault("kafka.network.SocketServerStats.BytesReadPerSec", 0.0);
                    if (networkRead > 100 * 1024 * 1024) { // 100MB/s
                        System.out.printf("Broker %s: ç½‘ç»œå¸¦å®½ä½¿ç”¨è¾ƒé«˜: %.2f MB/s%n", 
                            bm.brokerId, networkRead / (1024 * 1024));
                    }
                }
            }
        }
    }
}
```

## ç›‘æ§ä¸æŒ‡æ ‡åˆ†æ

### æ€§èƒ½æŒ‡æ ‡æ”¶é›†

```java
/**
 * æ€§èƒ½ç›‘æ§ä¸æŒ‡æ ‡åˆ†æ
 */
public class PerformanceMonitoringAndAnalysis {
    
    /**
     * æŒ‡æ ‡æ”¶é›†å™¨
     */
    public static class MetricsCollector {
        
        private final ScheduledExecutorService scheduler = 
            Executors.newScheduledThreadPool(2);
        private final Map<String, MetricSnapshot> metricStore = new ConcurrentHashMap<>();
        
        public void startCollecting(int intervalSeconds) {
            // æ”¶é›†KafkaæŒ‡æ ‡
            scheduler.scheduleAtFixedRate(this::collectKafkaMetrics, 
                0, intervalSeconds, TimeUnit.SECONDS);
            
            // æ”¶é›†ç³»ç»ŸæŒ‡æ ‡
            scheduler.scheduleAtFixedRate(this::collectSystemMetrics,
                0, intervalSeconds, TimeUnit.SECONDS);
        }
        
        private void collectKafkaMetrics() {
            // æ¨¡æ‹Ÿæ”¶é›†KafkaæŒ‡æ ‡
            metricStore.put("kafka.messages.in.rate", new MetricSnapshot(
                "kafka.messages.in.rate", 
                Math.random() * 10000,
                System.currentTimeMillis()
            ));
            
            metricStore.put("kafka.bytes.in.rate", new MetricSnapshot(
                "kafka.bytes.in.rate",
                Math.random() * 1000000,
                System.currentTimeMillis()
            ));
            
            metricStore.put("kafka.consumer.lag", new MetricSnapshot(
                "kafka.consumer.lag",
                Math.random() * 50000,
                System.currentTimeMillis()
            ));
        }
        
        private void collectSystemMetrics() {
            // æ¨¡æ‹Ÿæ”¶é›†ç³»ç»ŸæŒ‡æ ‡
            metricStore.put("system.cpu.usage", new MetricSnapshot(
                "system.cpu.usage",
                Math.random() * 100,
                System.currentTimeMillis()
            ));
            
            metricStore.put("system.memory.usage", new MetricSnapshot(
                "system.memory.usage",
                Math.random() * 100,
                System.currentTimeMillis()
            ));
            
            metricStore.put("system.disk.io.util", new MetricSnapshot(
                "system.disk.io.util",
                Math.random() * 100,
                System.currentTimeMillis()
            ));
        }
        
        public Map<String, MetricSnapshot> getMetrics() {
            return new HashMap<>(metricStore);
        }
        
        public MetricSnapshot getMetric(String name) {
            return metricStore.get(name);
        }
    }
    
    /**
     * æŒ‡æ ‡å¿«ç…§
     */
    public static class MetricSnapshot {
        private final String name;
        private final double value;
        private final long timestamp;
        
        public MetricSnapshot(String name, double value, long timestamp) {
            this.name = name;
            this.value = value;
            this.timestamp = timestamp;
        }
        
        public String getName() { return name; }
        public double getValue() { return value; }
        public long getTimestamp() { return timestamp; }
        
        @Override
        public String toString() {
            return String.format("Metric{name='%s', value=%.2f, timestamp=%d}", 
                name, value, timestamp);
        }
    }
    
    /**
     * æ€§èƒ½åˆ†æå™¨
     */
    public static class PerformanceAnalyzer {
        
        public static class AnalysisResult {
            private final boolean hasPerformanceIssue;
            private final List<String> issues;
            private final List<String> recommendations;
            private final double performanceScore;
            
            public AnalysisResult(boolean hasPerformanceIssue, List<String> issues,
                                List<String> recommendations, double performanceScore) {
                this.hasPerformanceIssue = hasPerformanceIssue;
                this.issues = issues;
                this.recommendations = recommendations;
                this.performanceScore = performanceScore;
            }
            
            // Getters
            public boolean isHasPerformanceIssue() { return hasPerformanceIssue; }
            public List<String> getIssues() { return issues; }
            public List<String> getRecommendations() { return recommendations; }
            public double getPerformanceScore() { return performanceScore; }
        }
        
        public static AnalysisResult analyzePerformance(Map<String, MetricSnapshot> metrics) {
            List<String> issues = new ArrayList<>();
            List<String> recommendations = new ArrayList<>();
            double score = 100.0;
            
            // åˆ†ææ¶ˆæ¯ååé‡
            MetricSnapshot messagesInRate = metrics.get("kafka.messages.in.rate");
            if (messagesInRate != null && messagesInRate.getValue() < 1000) {
                issues.add("æ¶ˆæ¯ååé‡è¿‡ä½: " + String.format("%.0f msg/sec", messagesInRate.getValue()));
                score -= 20;
                recommendations.add("å¢åŠ åˆ†åŒºæ•°é‡æˆ–ä¼˜åŒ–æ¶ˆè´¹è€…å¤„ç†é€»è¾‘");
            }
            
            // åˆ†ææ¶ˆè´¹è€…å»¶è¿Ÿ
            MetricSnapshot consumerLag = metrics.get("kafka.consumer.lag");
            if (consumerLag != null && consumerLag.getValue() > 10000) {
                issues.add("æ¶ˆè´¹è€…å»¶è¿Ÿè¿‡é«˜: " + String.format("%.0f æ¡æ¶ˆæ¯", consumerLag.getValue()));
                score -= 25;
                recommendations.add("å¢åŠ æ¶ˆè´¹è€…å®ä¾‹æ•°é‡");
            }
            
            // åˆ†æCPUä½¿ç”¨ç‡
            MetricSnapshot cpuUsage = metrics.get("system.cpu.usage");
            if (cpuUsage != null && cpuUsage.getValue() > 80) {
                issues.add("CPUä½¿ç”¨ç‡è¿‡é«˜: " + String.format("%.1f%%", cpuUsage.getValue()));
                score -= 30;
                recommendations.add("ä¼˜åŒ–åº”ç”¨é€»è¾‘æˆ–å¢åŠ è®¡ç®—èµ„æº");
            }
            
            // åˆ†æç£ç›˜I/O
            MetricSnapshot diskIO = metrics.get("system.disk.io.util");
            if (diskIO != null && diskIO.getValue() > 90) {
                issues.add("ç£ç›˜I/Oä½¿ç”¨ç‡è¿‡é«˜: " + String.format("%.1f%%", diskIO.getValue()));
                score -= 20;
                recommendations.add("ä½¿ç”¨SSDæˆ–ä¼˜åŒ–I/Oé…ç½®");
            }
            
            // åˆ†æå†…å­˜ä½¿ç”¨ç‡
            MetricSnapshot memoryUsage = metrics.get("system.memory.usage");
            if (memoryUsage != null && memoryUsage.getValue() > 85) {
                issues.add("å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜: " + String.format("%.1f%%", memoryUsage.getValue()));
                score -= 25;
                recommendations.add("å¢åŠ å†…å­˜æˆ–ä¼˜åŒ–å†…å­˜ä½¿ç”¨");
            }
            
            return new AnalysisResult(
                !issues.isEmpty(),
                issues,
                recommendations,
                Math.max(score, 0)
            );
        }
        
        public static void printAnalysisReport(AnalysisResult result) {
            System.out.println("=== æ€§èƒ½åˆ†ææŠ¥å‘Š ===");
            System.out.printf("æ€§èƒ½è¯„åˆ†: %.1f/100%n", result.getPerformanceScore());
            System.out.println();
            
            if (result.isHasPerformanceIssue()) {
                System.out.println("å‘ç°æ€§èƒ½é—®é¢˜:");
                result.getIssues().forEach(issue -> 
                    System.out.println("âŒ " + issue));
                System.out.println();
                
                System.out.println("è°ƒä¼˜å»ºè®®:");
                result.getRecommendations().forEach(rec -> 
                    System.out.println("ğŸ’¡ " + rec));
            } else {
                System.out.println("âœ… ç³»ç»Ÿæ€§èƒ½è‰¯å¥½");
            }
        }
    }
    
    /**
     * å®æ—¶å‘Šè­¦
     */
    public static class RealTimeAlerts {
        
        public static class AlertRule {
            private final String metricName;
            private final double threshold;
            private final String comparison;
            private final String message;
            private final AlertSeverity severity;
            
            public AlertRule(String metricName, double threshold, 
                           String comparison, String message, AlertSeverity severity) {
                this.metricName = metricName;
                this.threshold = threshold;
                this.comparison = comparison;
                this.message = message;
                this.severity = severity;
            }
            
            public boolean isTriggered(double value) {
                switch (comparison) {
                    case ">": return value > threshold;
                    case "<": return value < threshold;
                    case ">=": return value >= threshold;
                    case "<=": return value <= threshold;
                    default: return false;
                }
            }
            
            // Getters
            public String getMetricName() { return metricName; }
            public double getThreshold() { return threshold; }
            public String getComparison() { return comparison; }
            public String getMessage() { return message; }
            public AlertSeverity getSeverity() { return severity; }
        }
        
        public enum AlertSeverity {
            INFO, WARNING, CRITICAL
        }
        
        public static class Alert {
            private final long timestamp;
            private final AlertRule rule;
            private final double value;
            private final String message;
            
            public Alert(long timestamp, AlertRule rule, double value, String message) {
                this.timestamp = timestamp;
                this.rule = rule;
                this.value = value;
                this.message = message;
            }
            
            // Getters
            public long getTimestamp() { return timestamp; }
            public AlertRule getRule() { return rule; }
            public double getValue() { return value; }
            public String getMessage() { return message; }
        }
        
        public static class AlertManager {
            private final List<AlertRule> alertRules = new ArrayList<>();
            private final List<Alert> alerts = new CopyOnWriteArrayList<>();
            private final ScheduledExecutorService scheduler = 
                Executors.newScheduledThreadPool(1);
            
            public void addAlertRule(AlertRule rule) {
                alertRules.add(rule);
            }
            
            public void startMonitoring(MetricsCollector collector) {
                scheduler.scheduleAtFixedRate(() -> {
                    Map<String, MetricSnapshot> metrics = collector.getMetrics();
                    checkAlerts(metrics);
                }, 0, 10, TimeUnit.SECONDS);
            }
            
            private void checkAlerts(Map<String, MetricSnapshot> metrics) {
                for (AlertRule rule : alertRules) {
                    MetricSnapshot metric = metrics.get(rule.getMetricName());
                    if (metric != null && rule.isTriggered(metric.getValue())) {
                        Alert alert = new Alert(
                            System.currentTimeMillis(),
                            rule,
                            metric.getValue(),
                            String.format(rule.getMessage(), metric.getValue())
                        );
                        alerts.add(alert);
                        processAlert(alert);
                    }
                }
            }
            
            private void processAlert(Alert alert) {
                String alertIcon = getAlertIcon(alert.getRule().getSeverity());
                System.out.printf("%s å‘Šè­¦ [%s]: %s%n", 
                    alertIcon, alert.getRule().getSeverity(), alert.getMessage());
            }
            
            private String getAlertIcon(AlertSeverity severity) {
                switch (severity) {
                    case INFO: return "â„¹ï¸";
                    case WARNING: return "âš ï¸";
                    case CRITICAL: return "ğŸš¨";
                    default: return "â“";
                }
            }
            
            public List<Alert> getAlerts() {
                return new ArrayList<>(alerts);
            }
        }
    }
}
```

## æ€§èƒ½åŸºå‡†æµ‹è¯•

### åŸºå‡†æµ‹è¯•å·¥å…·

```java
/**
 * Kafkaæ€§èƒ½åŸºå‡†æµ‹è¯•
 */
public class KafkaPerformanceBenchmark {
    
    /**
     * åŸºå‡†æµ‹è¯•é…ç½®
     */
    public static class BenchmarkConfig {
        private final String bootstrapServers;
        private final String topic;
        private final int partitions;
        private final int replicationFactor;
        private final int messageSize;
        private final int messageCount;
        private final int concurrency;
        private final long warmupDuration;
        private final long testDuration;
        
        public BenchmarkConfig(String bootstrapServers, String topic, int partitions,
                             int replicationFactor, int messageSize, int messageCount,
                             int concurrency, long warmupDuration, long testDuration) {
            this.bootstrapServers = bootstrapServers;
            this.topic = topic;
            this.partitions = partitions;
            this.replicationFactor = replicationFactor;
            this.messageSize = messageSize;
            this.messageCount = messageCount;
            this.concurrency = concurrency;
            this.warmupDuration = warmupDuration;
            this.testDuration = testDuration;
        }
        
        // Getters
        public String getBootstrapServers() { return bootstrapServers; }
        public String getTopic() { return topic; }
        public int getPartitions() { return partitions; }
        public int getReplicationFactor() { return replicationFactor; }
        public int getMessageSize() { return messageSize; }
        public int getMessageCount() { return messageCount; }
        public int getConcurrency() { return concurrency; }
        public long getWarmupDuration() { return warmupDuration; }
        public long getTestDuration() { return testDuration; }
    }
    
    /**
     * åŸºå‡†æµ‹è¯•ç»“æœ
     */
    public static class BenchmarkResult {
        private final String testName;
        private final long totalMessages;
        private final long testDuration;
        private final double throughput;
        private final double averageLatency;
        private final double p95Latency;
        private final double p99Latency;
        private final double errorRate;
        
        public BenchmarkResult(String testName, long totalMessages, long testDuration,
                             double throughput, double averageLatency,
                             double p95Latency, double p99Latency, double errorRate) {
            this.testName = testName;
            this.totalMessages = totalMessages;
            this.testDuration = testDuration;
            this.throughput = throughput;
            this.averageLatency = averageLatency;
            this.p95Latency = p95Latency;
            this.p99Latency = p99Latency;
            this.errorRate = errorRate;
        }
        
        // Getters
        public String getTestName() { return testName; }
        public long getTotalMessages() { return totalMessages; }
        public long getTestDuration() { return testDuration; }
        public double getThroughput() { return throughput; }
        public double getAverageLatency() { return averageLatency; }
        public double getP95Latency() { return p95Latency; }
        public double getP99Latency() { return p99Latency; }
        public double getErrorRate() { return errorRate; }
    }
    
    /**
     * ç”Ÿäº§è€…åŸºå‡†æµ‹è¯•
     */
    public static class ProducerBenchmark {
        
        public BenchmarkResult benchmarkProducer(BenchmarkConfig config) {
            System.out.println("å¼€å§‹ç”Ÿäº§è€…åŸºå‡†æµ‹è¯•...");
            
            try (AdminClient adminClient = AdminClient.create(
                Collections.singletonMap(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG,
                    config.getBootstrapServers()))) {
                
                // åˆ›å»ºä¸»é¢˜
                NewTopic newTopic = new NewTopic(config.getTopic(), 
                    config.getPartitions(), 
                    (short) config.getReplicationFactor());
                adminClient.createTopics(Collections.singleton(newTopic)).all().get();
            }
            
            // æ‰§è¡ŒåŸºå‡†æµ‹è¯•
            ExecutorService executor = Executors.newFixedThreadPool(config.getConcurrency());
            List<Future<BenchmarkResult>> futures = new ArrayList<>();
            CountDownLatch latch = new CountDownLatch(config.getConcurrency());
            
            // é¢„çƒ­
            System.out.println("é¢„çƒ­é˜¶æ®µ...");
            warmUp(config);
            
            // å¼€å§‹æµ‹è¯•
            System.out.println("å¼€å§‹æµ‹è¯•...");
            long startTime = System.currentTimeMillis();
            long messagesSent = 0;
            List<Long> latencies = new ArrayList<>();
            AtomicLong errorCount = new AtomicLong(0);
            
            for (int i = 0; i < config.getConcurrency(); i++) {
                futures.add(executor.submit(() -> {
                    try {
                        return runProducerThread(config, latch, messagesSent, latencies, errorCount);
                    } catch (Exception e) {
                        errorCount.incrementAndGet();
                        throw new RuntimeException(e);
                    }
                }));
            }
            
            // ç­‰å¾…æµ‹è¯•å®Œæˆ
            try {
                latch.await();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            long endTime = System.currentTimeMillis();
            long actualDuration = endTime - startTime;
            
            // åˆå¹¶ç»“æœ
            long totalMessages = futures.stream()
                .mapToLong(fut -> {
                    try {
                        return fut.get().getTotalMessages();
                    } catch (Exception e) {
                        return 0;
                    }
                })
                .sum();
            
            double throughput = (totalMessages * 1000.0) / actualDuration;
            double avgLatency = latencies.stream().mapToLong(Long::longValue).average().orElse(0.0);
            double p95Latency = calculatePercentile(latencies, 95.0);
            double p99Latency = calculatePercentile(latencies, 99.0);
            double errorRate = (errorCount.get() * 100.0) / totalMessages;
            
            BenchmarkResult result = new BenchmarkResult(
                "Producer Benchmark", totalMessages, actualDuration,
                throughput, avgLatency, p95Latency, p99Latency, errorRate
            );
            
            executor.shutdown();
            return result;
        }
        
        private void warmUp(BenchmarkConfig config) {
            // å‘é€å°‘é‡æ¶ˆæ¯è¿›è¡Œé¢„çƒ­
            try (KafkaProducer<String, String> producer = new KafkaProducer<>(
                OptimizedProducerConfig.getHighThroughputConfig())) {
                
                for (int i = 0; i < 100; i++) {
                    ProducerRecord<String, String> record = new ProducerRecord<>(
                        config.getTopic(), "warmup", "warmup message");
                    producer.send(record).get();
                }
            } catch (Exception e) {
                System.err.println("é¢„çƒ­å¤±è´¥: " + e.getMessage());
            }
        }
        
        private BenchmarkResult runProducerThread(BenchmarkConfig config, CountDownLatch latch,
                                                 AtomicLong messagesSent, List<Long> latencies,
                                                 AtomicLong errorCount) {
            CountDownLatch threadLatch = new CountDownLatch(1);
            
            try (KafkaProducer<String, String> producer = new KafkaProducer<>(
                OptimizedProducerConfig.getHighThroughputConfig())) {
                
                latch.countDown();
                threadLatch.await();
                
                String message = generateMessage(config.getMessageSize());
                long startTime = System.currentTimeMillis();
                
                for (int i = 0; i < config.getMessageCount(); i++) {
                    try {
                        long msgStartTime = System.nanoTime();
                        
                        ProducerRecord<String, String> record = new ProducerRecord<>(
                            config.getTopic(), message);
                        RecordMetadata metadata = producer.send(record).get();
                        
                        long msgEndTime = System.nanoTime();
                        long latency = (msgEndTime - msgStartTime) / 1000000; // ms
                        
                        synchronized (latencies) {
                            latencies.add(latency);
                        }
                        
                        messagesSent.incrementAndGet();
                        
                    } catch (Exception e) {
                        errorCount.incrementAndGet();
                    }
                }
                
                long endTime = System.currentTimeMillis();
                return new BenchmarkResult(
                    "Producer Thread", config.getMessageCount(),
                    endTime - startTime, 0, 0, 0, 0, 0);
                    
            } catch (Exception e) {
                errorCount.incrementAndGet();
                return null;
            } finally {
                latch.countDown();
            }
        }
        
        private String generateMessage(int size) {
            StringBuilder sb = new StringBuilder();
            String base = "A";
            while (sb.length() < size) {
                sb.append(base);
            }
            return sb.toString();
        }
        
        private double calculatePercentile(List<Long> values, double percentile) {
            List<Long> sorted = new ArrayList<>(values);
            Collections.sort(sorted);
            int index = (int) Math.ceil(sorted.size() * percentile / 100.0) - 1;
            return sorted.get(Math.max(0, index));
        }
    }
    
    /**
     * ä¼˜åŒ–çš„ç”Ÿäº§é…ç½®
     */
    public static class OptimizedProducerConfig {
        public static Properties getHighThroughputConfig() {
            Properties props = new Properties();
            props.put("bootstrap.servers", "localhost:9092");
            props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
            props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");
            
            // æ‰¹é‡å¤„ç†
            props.put("batch.size", "65536");
            props.put("linger.ms", "20");
            props.put("buffer.memory", "134217728");
            
            // å‹ç¼©
            props.put("compression.type", "lz4");
            
            // é‡è¯•
            props.put("retries", "3");
            props.put("max.in.flight.requests.per.connection", "5");
            
            return props;
        }
    }
    
    /**
     * æ¶ˆè´¹è€…åŸºå‡†æµ‹è¯•
     */
    public static class ConsumerBenchmark {
        
        public BenchmarkResult benchmarkConsumer(String bootstrapServers, String topic,
                                               int concurrentConsumers, 
                                               long testDurationMs) {
            System.out.println("å¼€å§‹æ¶ˆè´¹è€…åŸºå‡†æµ‹è¯•...");
            
            // åŸºå‡†æµ‹è¯•å®ç°
            return null; // ç®€åŒ–å®ç°
        }
    }
    
    /**
     * ç«¯åˆ°ç«¯åŸºå‡†æµ‹è¯•
     */
    public static class EndToEndBenchmark {
        
        public BenchmarkResult runEndToEndBenchmark(String bootstrapServers, String topic,
                                                   int messageCount, int messageSize,
                                                   int concurrentProducers, int concurrentConsumers) {
            System.out.println("å¼€å§‹ç«¯åˆ°ç«¯åŸºå‡†æµ‹è¯•...");
            
            // å¯åŠ¨ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…
            ExecutorService executor = Executors.newFixedThreadPool(
                concurrentProducers + concurrentConsumers);
            
            List<Future<?>> futures = new ArrayList<>();
            
            // å¯åŠ¨ç”Ÿäº§è€…
            for (int i = 0; i < concurrentProducers; i++) {
                futures.add(executor.submit(() -> {
                    // ç”Ÿäº§è€…é€»è¾‘
                }));
            }
            
            // å¯åŠ¨æ¶ˆè´¹è€…
            for (int i = 0; i < concurrentConsumers; i++) {
                futures.add(executor.submit(() -> {
                    // æ¶ˆè´¹è€…é€»è¾‘
                }));
            }
            
            // ç­‰å¾…æµ‹è¯•å®Œæˆ
            for (Future<?> future : futures) {
                try {
                    future.get();
                } catch (Exception e) {
                    System.err.println("æµ‹è¯•çº¿ç¨‹å¼‚å¸¸: " + e.getMessage());
                }
            }
            
            executor.shutdown();
            
            return null; // ç®€åŒ–å®ç°
        }
    }
    
    /**
     * åŸºå‡†æµ‹è¯•æŠ¥å‘Šç”Ÿæˆå™¨
     */
    public static class BenchmarkReportGenerator {
        
        public static void generateComparisonReport(List<BenchmarkResult> results, String outputPath) {
            try (PrintWriter writer = new PrintWriter(new FileWriter(outputPath))) {
                writer.println("# Kafkaæ€§èƒ½åŸºå‡†æµ‹è¯•æŠ¥å‘Š");
                writer.println();
                writer.println("æµ‹è¯•æ—¶é—´: " + new Date());
                writer.println();
                
                // ç”Ÿæˆå¯¹æ¯”è¡¨æ ¼
                writer.println("| æµ‹è¯•é¡¹ç›® | ååé‡(msg/sec) | å¹³å‡å»¶è¿Ÿ(ms) | P95å»¶è¿Ÿ(ms) | P99å»¶è¿Ÿ(ms) | é”™è¯¯ç‡(%) |");
                writer.println("|---------|----------------|--------------|-------------|-------------|-----------|");
                
                for (BenchmarkResult result : results) {
                    writer.printf("| %s | %.2f | %.2f | %.2f | %.2f | %.2f |%n",
                        result.getTestName(), result.getThroughput(),
                        result.getAverageLatency(), result.getP95Latency(),
                        result.getP99Latency(), result.getErrorRate());
                }
                
                writer.println();
                writer.println("## è¯¦ç»†åˆ†æ");
                
                for (BenchmarkResult result : results) {
                    writer.println("### " + result.getTestName());
                    writer.println("- æ€»æ¶ˆæ¯æ•°: " + result.getTotalMessages());
                    writer.println("- æµ‹è¯•æ—¶é•¿: " + result.getTestDuration() + " ms");
                    writer.println("- ååé‡: " + String.format("%.2f msg/sec", result.getThroughput()));
                    writer.println("- å¹³å‡å»¶è¿Ÿ: " + String.format("%.2f ms", result.getAverageLatency()));
                    writer.println("- P95å»¶è¿Ÿ: " + String.format("%.2f ms", result.getP95Latency()));
                    writer.println("- P99å»¶è¿Ÿ: " + String.format("%.2f ms", result.getP99Latency()));
                    writer.println("- é”™è¯¯ç‡: " + String.format("%.2f%%", result.getErrorRate()));
                    writer.println();
                }
                
                System.out.println("åŸºå‡†æµ‹è¯•æŠ¥å‘Šå·²ç”Ÿæˆ: " + outputPath);
                
            } catch (IOException e) {
                System.err.println("ç”ŸæˆæŠ¥å‘Šå¤±è´¥: " + e.getMessage());
            }
        }
    }
}

// è¾…åŠ©ç±»
class ProducerThread extends Thread {
    private final String bootstrapServers;
    private final String topic;
    private final int messageCount;
    private final int messageSize;
    private final CountDownLatch startLatch;
    private final CountDownLatch finishLatch;
    private final List<Long> latencies = new ArrayList<>();
    private volatile long messagesSent = 0;
    
    public ProducerThread(String bootstrapServers, String topic, int messageCount,
                         int messageSize, CountDownLatch startLatch, CountDownLatch finishLatch) {
        this.bootstrapServers = bootstrapServers;
        this.topic = topic;
        this.messageCount = messageCount;
        this.messageSize = messageSize;
        this.startLatch = startLatch;
        this.finishLatch = finishLatch;
    }
    
    @Override
    public void run() {
        try {
            startLatch.await();
            
            Properties props = OptimizedProducerConfig.getOptimizedProducerConfig();
            props.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
            
            try (KafkaProducer<String, String> producer = new KafkaProducer<>(props)) {
                String message = generateMessage(messageSize);
                
                for (int i = 0; i < messageCount; i++) {
                    long startTime = System.nanoTime();
                    
                    ProducerRecord<String, String> record = new ProducerRecord<>(topic, message);
                    producer.send(record).get();
                    
                    long endTime = System.nanoTime();
                    long latency = (endTime - startTime) / 1000000; // è½¬æ¢ä¸ºæ¯«ç§’
                    
                    synchronized (latencies) {
                        latencies.add(latency);
                    }
                    
                    messagesSent++;
                }
            }
            
        } catch (Exception e) {
            System.err.println("ç”Ÿäº§è€…çº¿ç¨‹å¼‚å¸¸: " + e.getMessage());
        } finally {
            finishLatch.countDown();
        }
    }
    
    private String generateMessage(int size) {
        StringBuilder sb = new StringBuilder();
        String content = "A";
        while (sb.length() < size) {
            sb.append(content);
        }
        return sb.toString();
    }
    
    public long getMessagesSent() { return messagesSent; }
    public List<Long> getLatencies() { return latencies; }
}
```

## 9.8 æ€§èƒ½è°ƒä¼˜æœ€ä½³å®è·µ

### 9.8.1 ç”Ÿäº§ç¯å¢ƒè°ƒä¼˜æ¸…å•

```java
/**
 * Kafkaç”Ÿäº§ç¯å¢ƒæ€§èƒ½è°ƒä¼˜æ¸…å•
 */
public class ProductionTuningChecklist {
    
    /**
     * ç³»ç»Ÿçº§è°ƒä¼˜é¡¹ç›®
     */
    public static class SystemTuning {
        
        public static List<TuningItem> getSystemTuningItems() {
            return Arrays.asList(
                new TuningItem("æ–‡ä»¶æè¿°ç¬¦é™åˆ¶", "ulimit -n 65536", "é«˜å¹¶å‘è¿æ¥éœ€è¦"),
                new TuningItem("è™šæ‹Ÿå†…å­˜è®¾ç½®", "vm.swappiness=1", "å‡å°‘Swapä½¿ç”¨"),
                new TuningItem("ç½‘ç»œç¼“å†²åŒº", "net.core.rmem_max=134217728", "å¢å¤§ç½‘ç»œæ¥æ”¶ç¼“å†²åŒº"),
                new TuningItem("ç½‘ç»œé˜Ÿåˆ—", "net.core.netdev_max_backlog=5000", "å¢å¤§ç½‘ç»œåŒ…é˜Ÿåˆ—"),
                new TuningItem("TCPè®¾ç½®", "net.ipv4.tcp_rmem=4096 16384 134217728", "ä¼˜åŒ–TCPå†…å­˜è®¾ç½®"),
                new TuningItem("I/Oè°ƒåº¦å™¨", "echo noop > /sys/block/sda/queue/scheduler", "SSDä½¿ç”¨noopè°ƒåº¦å™¨"),
                new TuningItem("é¢„è¯»è®¾ç½®", "echo 256 > /sys/block/sda/queue/read_ahead_kb", "å¢å¤§ç£ç›˜é¢„è¯»"),
                new TuningItem("é˜Ÿåˆ—æ·±åº¦", "echo 256 > /sys/block/sda/queue/nr_requests", "å¢å¤§I/Oé˜Ÿåˆ—æ·±åº¦")
            );
        }
        
        public static void applySystemTuning() {
            List<TuningItem> items = getSystemTuningItems();
            
            System.out.println("=== ç³»ç»Ÿè°ƒä¼˜é¡¹ç›® ===");
            for (TuningItem item : items) {
                System.out.printf("âœ“ %s: %s%n", item.getName(), item.getCommand());
                System.out.printf("  è¯´æ˜: %s%n", item.getDescription());
            }
            
            System.out.println("\nè¯·ä»¥rootæƒé™æ‰§è¡Œä¸Šè¿°å‘½ä»¤è¿›è¡Œç³»ç»Ÿè°ƒä¼˜");
        }
    }
    
    /**
     * JVMè°ƒä¼˜é¡¹ç›®
     */
    public static class JVMTuning {
        
        public static List<TuningItem> getJVMTuningItems() {
            return Arrays.asList(
                new TuningItem("å †å†…å­˜è®¾ç½®", "-Xms8g -Xmx8g", "å›ºå®šå †å†…å­˜å¤§å°ï¼Œé¿å…åŠ¨æ€è°ƒæ•´"),
                new TuningItem("å¹´è½»ä»£æ¯”ä¾‹", "-XX:NewRatio=1", "å¹´è½»ä»£å å †å†…å­˜çš„50%"),
                new TuningItem("G1GCé…ç½®", "-XX:+UseG1GC", "ä½¿ç”¨G1åƒåœ¾æ”¶é›†å™¨"),
                new TuningItem("GCæš‚åœæ—¶é—´", "-XX:MaxGCPauseMillis=200", "æœ€å¤§GCæš‚åœæ—¶é—´200ms"),
                new TuningItem("åŒºåŸŸå¤§å°", "-XX:G1HeapRegionSize=16m", "G1åŒºåŸŸå¤§å°16MB"),
                new TuningItem("GCæ—¥å¿—", "-Xloggc:/var/log/kafka/gc.log", "å¯ç”¨GCæ—¥å¿—è®°å½•"),
                new TuningItem("OOMè½¬å‚¨", "-XX:+HeapDumpOnOutOfMemoryError", "OOMæ—¶ç”Ÿæˆå †è½¬å‚¨")
            );
        }
        
        public static String getRecommendedJVMArgs(long heapSizeGB) {
            return String.format(
                "-server -Xms%dg -Xmx%dg -XX:NewRatio=1 -XX:+UseG1GC " +
                "-XX:MaxGCPauseMillis=200 -XX:G1HeapRegionSize=16m " +
                "-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:/var/log/kafka/gc.log " +
                "-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/var/log/kafka/ " +
                "-Djava.awt.headless=true",
                heapSizeGB, heapSizeGB
            );
        }
    }
    
    /**
     * Kafka Brokerè°ƒä¼˜é¡¹ç›®
     */
    public static class BrokerTuning {
        
        public static List<TuningItem> getBrokerTuningItems() {
            return Arrays.asList(
                new TuningItem("ç½‘ç»œçº¿ç¨‹æ•°", "num.network.threads=8", "å¤„ç†ç½‘ç»œè¯·æ±‚çš„çº¿ç¨‹æ•°"),
                new TuningItem("I/Oçº¿ç¨‹æ•°", "num.io.threads=16", "å¤„ç†ç£ç›˜I/Oçš„çº¿ç¨‹æ•°"),
                new TuningItem("æ‰¹é‡å¤„ç†", "batch.size=32768", "å¢å¤§æ‰¹é‡å¤„ç†å¤§å°"),
                new TuningItem("ç­‰å¾…æ—¶é—´", "linger.ms=20", "å¢åŠ ç­‰å¾…æ—¶é—´æé«˜æ‰¹é‡æ•ˆç‡"),
                new TuningItem("ç¼“å†²åŒºå¤§å°", "buffer.memory=67108864", "å¢å¤§å‘é€ç¼“å†²åŒº"),
                new TuningItem("å‹ç¼©ç±»å‹", "compression.type=lz4", "å¯ç”¨æ¶ˆæ¯å‹ç¼©"),
                new TuningItem("åˆ†åŒºæ•°", "num.partitions=3", "æ ¹æ®è´Ÿè½½è°ƒæ•´åˆ†åŒºæ•°"),
                new TuningItem("å‰¯æœ¬å› å­", "default.replication.factor=3", "è®¾ç½®é€‚å½“çš„å‰¯æœ¬å› å­"),
                new TuningItem("æ—¥å¿—æ®µå¤§å°", "log.segment.bytes=1073741824", "1GBæ—¥å¿—æ®µå¤§å°"),
                new TuningItem("ä¿ç•™æ—¶é—´", "log.retention.hours=168", "7å¤©æ—¥å¿—ä¿ç•™æœŸ")
            );
        }
        
        public static Properties getOptimizedBrokerConfig() {
            Properties props = new Properties();
            
            // åŸºç¡€é…ç½®
            props.put("broker.id", "0");
            props.put("listeners", "PLAINTEXT://localhost:9092");
            props.put("num.network.threads", "8");
            props.put("num.io.threads", "16");
            props.put("socket.send.buffer.bytes", "102400");
            props.put("socket.receive.buffer.bytes", "102400");
            props.put("socket.request.max.bytes", "104857600");
            
            // æ€§èƒ½ä¼˜åŒ–é…ç½®
            props.put("batch.size", "32768");
            props.put("linger.ms", "20");
            props.put("buffer.memory", "67108864");
            props.put("compression.type", "lz4");
            props.put("num.partitions", "3");
            props.put("default.replication.factor", "3");
            props.put("min.insync.replicas", "2");
            
            // æ—¥å¿—é…ç½®
            props.put("log.dirs", "/data/kafka-logs");
            props.put("log.retention.hours", "168");
            props.put("log.segment.bytes", "1073741824");
            props.put("log.retention.check.interval.ms", "300000");
            props.put("log.cleanup.policy", "delete");
            
            return props;
        }
    }
    
    /**
     * è°ƒä¼˜é¡¹ç›®ç±»
     */
    public static class TuningItem {
        private final String name;
        private final String command;
        private final String description;
        
        public TuningItem(String name, String command, String description) {
            this.name = name;
            this.command = command;
            this.description = description;
        }
        
        public String getName() { return name; }
        public String getCommand() { return command; }
        public String getDescription() { return description; }
    }
    
    /**
     * ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²æŒ‡å—
     */
    public static class ProductionDeploymentGuide {
        
        public static void printDeploymentChecklist() {
            System.out.println("=== Kafkaç”Ÿäº§ç¯å¢ƒéƒ¨ç½²æ£€æŸ¥æ¸…å• ===\n");
            
            printSection("ç¡¬ä»¶è¦æ±‚", getHardwareRequirements());
            printSection("æ“ä½œç³»ç»Ÿå‡†å¤‡", getOSPreparation());
            printSection("Kafkaå®‰è£…é…ç½®", getInstallationSteps());
            printSection("æ€§èƒ½è°ƒä¼˜", getPerformanceTuning());
            printSection("ç›‘æ§å‘Šè­¦", getMonitoringSetup());
            printSection("å®‰å…¨é…ç½®", getSecuritySetup());
            printSection("å¤‡ä»½æ¢å¤", getBackupStrategy());
        }
        
        private static void printSection(String title, List<String> items) {
            System.out.println("## " + title);
            items.forEach(item -> System.out.println("â˜ " + item));
            System.out.println();
        }
        
        private static List<String> getHardwareRequirements() {
            return Arrays.asList(
                "CPU: 8æ ¸å¿ƒä»¥ä¸Šï¼Œæ¨è16æ ¸å¿ƒ",
                "å†…å­˜: 16GBä»¥ä¸Šï¼Œæ¨è32GB",
                "ç£ç›˜: SSDå­˜å‚¨ï¼Œè‡³å°‘1TB",
                "ç½‘ç»œ: åƒå…†ç½‘å¡ï¼Œæ¨èä¸‡å…†",
                "ç½‘ç»œå»¶è¿Ÿ: < 1ms (é›†ç¾¤å†…)"
            );
        }
        
        private static List<String> getOSPreparation() {
            return Arrays.asList(
                "å®‰è£…Java 8æˆ–æ›´é«˜ç‰ˆæœ¬",
                "é…ç½®ç³»ç»Ÿå‚æ•°ä¼˜åŒ–",
                "è®¾ç½®æ–‡ä»¶æè¿°ç¬¦é™åˆ¶",
                "é…ç½®é˜²ç«å¢™è§„åˆ™",
                "è®¾ç½®NTPæ—¶é—´åŒæ­¥"
            );
        }
        
        private static List<String> getInstallationSteps() {
            return Arrays.asList(
                "ä¸‹è½½å¹¶è§£å‹Kafka",
                "é…ç½®server.properties",
                "é…ç½®JVMå‚æ•°",
                "åˆ›å»ºæ•°æ®ç›®å½•",
                "å¯åŠ¨ZookeeperæœåŠ¡",
                "å¯åŠ¨Kafka Broker"
            );
        }
        
        private static List<String> getPerformanceTuning() {
            return Arrays.asList(
                "ä¼˜åŒ–JVMå‚æ•°",
                "è°ƒæ•´ç½‘ç»œç¼“å†²åŒº",
                "é…ç½®æ‰¹é‡å¤„ç†å‚æ•°",
                "å¯ç”¨æ¶ˆæ¯å‹ç¼©",
                "è°ƒæ•´åˆ†åŒºå’Œå‰¯æœ¬è®¾ç½®",
                "ä¼˜åŒ–ç£ç›˜I/Oå‚æ•°"
            );
        }
        
        private static List<String> getMonitoringSetup() {
            return Arrays.asList(
                "é…ç½®JMXç›‘æ§",
                "éƒ¨ç½²ç›‘æ§å·¥å…·(å¦‚Grafana)",
                "è®¾ç½®æ€§èƒ½æŒ‡æ ‡å‘Šè­¦",
                "é…ç½®æ—¥å¿—èšåˆ",
                "å»ºç«‹æ€§èƒ½åŸºçº¿"
            );
        }
        
        private static List<String> getSecuritySetup() {
            return Arrays.asList(
                "é…ç½®SSL/TLSåŠ å¯†",
                "è®¾ç½®SASLè®¤è¯",
                "é…ç½®è®¿é—®æ§åˆ¶åˆ—è¡¨",
                "å¯ç”¨å®¡è®¡æ—¥å¿—",
                "å®šæœŸæ›´æ–°å®‰å…¨ç­–ç•¥"
            );
        }
        
        private static List<String> getBackupStrategy() {
            return Arrays.asList(
                "é…ç½®æ•°æ®å¤‡ä»½ç­–ç•¥",
                "æµ‹è¯•æ¢å¤æµç¨‹",
                "å®šæœŸéªŒè¯å¤‡ä»½å®Œæ•´æ€§",
                "å»ºç«‹ç¾éš¾æ¢å¤è®¡åˆ’",
                "åˆ¶å®šåº”æ€¥å“åº”æµç¨‹"
            );
        }
    }
}
```

### 9.8.2 æ€§èƒ½é—®é¢˜è¯Šæ–­æŒ‡å—

```java
/**
 * Kafkaæ€§èƒ½é—®é¢˜è¯Šæ–­å·¥å…·
 */
public class KafkaPerformanceDiagnostics {
    
    /**
     * æ€§èƒ½é—®é¢˜è¯Šæ–­
     */
    public static class PerformanceDiagnostics {
        
        /**
         * ç»¼åˆæ€§èƒ½è¯Šæ–­
         */
        public static DiagnosisReport performComprehensiveDiagnosis(String bootstrapServers) {
            DiagnosisReport report = new DiagnosisReport();
            report.setTimestamp(System.currentTimeMillis());
            
            try {
                // è¯Šæ–­å„ä¸ªç»„ä»¶
                ProducerDiagnostics producerDiag = diagnoseProducers(bootstrapServers);
                ConsumerDiagnostics consumerDiag = diagnoseConsumers(bootstrapServers);
                BrokerDiagnostics brokerDiag = diagnoseBrokers(bootstrapServers);
                SystemDiagnostics systemDiag = diagnoseSystem();
                
                report.setProducerDiagnostics(producerDiag);
                report.setConsumerDiagnostics(consumerDiag);
                report.setBrokerDiagnostics(brokerDiag);
                report.setSystemDiagnostics(systemDiag);
                
                // ç”Ÿæˆå»ºè®®
                report.setRecommendations(generateRecommendations(report));
                
            } catch (Exception e) {
                report.setError("è¯Šæ–­è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: " + e.getMessage());
            }
            
            return report;
        }
        
        private static ProducerDiagnostics diagnoseProducers(String bootstrapServers) {
            ProducerDiagnostics diagnostics = new ProducerDiagnostics();
            
            // æ£€æŸ¥ç”Ÿäº§è€…è¿æ¥çŠ¶æ€
            diagnostics.setConnectionHealth(checkProducerConnections(bootstrapServers));
            
            // æ£€æŸ¥å‘é€æˆåŠŸç‡
            diagnostics.setSendSuccessRate(checkSendSuccessRate());
            
            // æ£€æŸ¥å¹³å‡å»¶è¿Ÿ
            diagnostics.setAverageLatency(checkAverageLatency());
            
            // æ£€æŸ¥æ‰¹é‡å¤„ç†æ•ˆç‡
            diagnostics.setBatchEfficiency(checkBatchEfficiency());
            
            return diagnostics;
        }
        
        private static ConsumerDiagnostics diagnoseConsumers(String bootstrapServers) {
            ConsumerDiagnostics diagnostics = new ConsumerDiagnostics();
            
            // æ£€æŸ¥æ¶ˆè´¹è€…ç»„çŠ¶æ€
            diagnostics.setGroupHealth(checkConsumerGroupHealth());
            
            // æ£€æŸ¥æ¶ˆè´¹å»¶è¿Ÿ
            diagnostics.setConsumerLag(checkConsumerLag());
            
            // æ£€æŸ¥åˆ†åŒºåˆ†é…
            diagnostics.setPartitionAssignment(checkPartitionAssignment());
            
            // æ£€æŸ¥é‡å¹³è¡¡é¢‘ç‡
            diagnostics.setRebalanceFrequency(checkRebalanceFrequency());
            
            return diagnostics;
        }
        
        private static BrokerDiagnostics diagnoseBrokers(String bootstrapServers) {
            BrokerDiagnostics diagnostics = new BrokerDiagnostics();
            
            // æ£€æŸ¥BrokerçŠ¶æ€
            diagnostics.setBrokerHealth(checkBrokerHealth());
            
            // æ£€æŸ¥ç£ç›˜ä½¿ç”¨ç‡
            diagnostics.setDiskUsage(checkDiskUsage());
            
            // æ£€æŸ¥ç½‘ç»œI/O
            diagnostics.setNetworkIO(checkNetworkIO());
            
            // æ£€æŸ¥å†…å­˜ä½¿ç”¨
            diagnostics.setMemoryUsage(checkMemoryUsage());
            
            // æ£€æŸ¥GCæƒ…å†µ
            diagnostics.setGCHetrics(checkGCMetrics());
            
            return diagnostics;
        }
        
        private static SystemDiagnostics diagnoseSystem() {
            SystemDiagnostics diagnostics = new SystemDiagnostics();
            
            // æ£€æŸ¥CPUä½¿ç”¨ç‡
            diagnostics.setCpuUsage(checkCPUUsage());
            
            // æ£€æŸ¥å†…å­˜ä½¿ç”¨ç‡
            diagnostics.setSystemMemoryUsage(checkSystemMemoryUsage());
            
            // æ£€æŸ¥ç£ç›˜I/O
            diagnostics.setDiskIO(checkSystemDiskIO());
            
            // æ£€æŸ¥ç½‘ç»œçŠ¶æ€
            diagnostics.setNetworkHealth(checkNetworkHealth());
            
            return diagnostics;
        }
        
        // ç®€åŒ–çš„æ£€æŸ¥æ–¹æ³•å®ç°
        private static boolean checkProducerConnections(String bootstrapServers) {
            // å®ç°ç”Ÿäº§è€…è¿æ¥æ£€æŸ¥é€»è¾‘
            return true;
        }
        
        private static double checkSendSuccessRate() {
            // å®ç°å‘é€æˆåŠŸç‡æ£€æŸ¥
            return 99.5;
        }
        
        private static double checkAverageLatency() {
            // å®ç°å¹³å‡å»¶è¿Ÿæ£€æŸ¥
            return 50.0;
        }
        
        private static double checkBatchEfficiency() {
            // å®ç°æ‰¹é‡æ•ˆç‡æ£€æŸ¥
            return 85.0;
        }
        
        private static boolean checkConsumerGroupHealth() {
            // å®ç°