# 第2章 系统架构与核心概念

## 2.1 深入理解DolphinScheduler架构

### 2.1.1 分布式架构原理

DolphinScheduler采用分布式架构设计，主要解决以下问题：

1. **单点故障**：通过多节点部署避免单点故障
2. **性能瓶颈**：通过水平扩展提升处理能力
3. **资源隔离**：通过租户机制实现资源隔离
4. **高并发**：通过分布式协调解决并发问题

### 2.1.2 组件间通信机制

#### Master与Worker通信

Master和Worker之间通过Netty实现高效通信：

1. **心跳机制**：Worker定期向Master发送心跳，报告存活状态
2. **任务分发**：Master将任务分发给可用的Worker
3. **状态上报**：Worker定期上报任务执行状态
4. **日志收集**：Worker上报任务执行日志

#### ZooKeeper协调机制

ZooKeeper在整个系统中起到协调作用：

1. **Master选举**：通过ZooKeeper选举active Master
2. **服务发现**：Worker注册服务信息到ZooKeeper
3. **分布式锁**：实现任务调度的分布式锁
4. **配置同步**：同步系统配置信息

### 2.1.3 数据存储设计

#### 数据库存储

DolphinScheduler使用关系型数据库存储元数据：

- **工作流定义**：存储工作流的DAG结构
- **任务定义**：存储任务的详细配置
- **执行历史**：存储工作流和任务的执行记录
- **系统配置**：存储系统全局配置

#### 日志存储

- **任务执行日志**：存储在文件系统
- **系统日志**：存储在日志文件
- **审计日志**：存储在数据库

### 2.1.4 执行流程详解

```
用户创建工作流 → 解析DAG → 调度任务 → 执行任务 → 收集结果 → 更新状态
     ↓              ↓         ↓         ↓         ↓         ↓
   UI界面        Master    Master     Worker    Master     Master
                 Server    Server     Server    Server     Server
                                      ↓         ↓
                                   执行任务    收集日志
                                      ↓         ↓
                                   收集结果    更新状态
```

## 2.2 核心组件详解

### 2.2.1 Master Server深入解析

#### 2.2.1.1 Master的主要职责

1. **工作流调度**
   - 解析工作流定义
   - 构建任务执行图
   - 管理任务依赖
   - 处理任务分发

2. **状态管理**
   - 跟踪工作流实例状态
   - 跟踪任务实例状态
   - 处理失败重试
   - 管理任务优先级

3. **集群协调**
   - 参与Master选举
   - 管理Worker状态
   - 处理容错恢复
   - 负载均衡

#### 2.2.1.2 Master的选举机制

```java
// Master选举伪代码
public class MasterElection {
    public void electMaster() {
        // 1. 在ZooKeeper创建临时顺序节点
        String masterPath = zk.createEphemeralSequential("/dolphinscheduler/masters/", hostname);
        
        // 2. 获取所有Master节点
        List<String> masters = zk.getChildren("/dolphinscheduler/masters/");
        
        // 3. 排序并获取最小节点作为Active Master
        Collections.sort(masters);
        String activeMaster = masters.get(0);
        
        // 4. 如果当前节点是Active Master
        if (masterPath.equals(activeMaster)) {
            becomeActiveMaster();
        } else {
            becomeStandbyMaster();
        }
    }
}
```

#### 2.2.1.3 调度算法

DolphinScheduler采用以下调度策略：

1. **优先级调度**：根据任务优先级执行
2. **资源调度**：考虑Worker资源使用情况
3. **公平调度**：平衡各租户的任务执行
4. **依赖调度**：根据任务依赖关系调度

### 2.2.2 Worker Server深入解析

#### 2.2.2.1 Worker的主要职责

1. **任务执行**
   - 接收Master分发的任务
   - 解析任务参数
   - 执行具体任务
   - 收集执行结果

2. **资源管理**
   - 监控本地资源使用
   - 资源配额控制
   - 任务进程管理
   - 清理临时资源

3. **状态上报**
   - 定期发送心跳
   - 上报任务状态
   - 上报执行日志
   - 上报系统指标

#### 2.2.2.2 任务执行器

DolphinScheduler为不同类型的任务提供不同的执行器：

```java
public interface TaskExecutor {
    void execute(TaskExecutionContext context);
    TaskExecutionResult getResult();
    void cancel();
}

// Shell任务执行器
public class ShellTaskExecutor implements TaskExecutor {
    public void execute(TaskExecutionContext context) {
        String command = context.getTaskParams().getRawScript();
        Process process = Runtime.getRuntime().exec(command);
        // 执行并收集结果
    }
}

// SQL任务执行器
public class SQLTaskExecutor implements TaskExecutor {
    public void execute(TaskExecutionContext context) {
        String sql = context.getTaskParams().getSql();
        DataSource dataSource = getDataSource(context.getDataSourceId());
        // 执行SQL并收集结果
    }
}
```

### 2.2.3 API Server深入解析

#### 2.2.3.1 API设计原则

1. **RESTful风格**：遵循REST设计原则
2. **版本控制**：通过URL或Header控制版本
3. **统一响应**：标准化的响应格式
4. **错误处理**：统一的错误码和错误信息

#### 2.2.3.2 主要API模块

```java
// API模块划分
@RestController
@RequestMapping("/v1/projects")
public class ProjectController {
    // 项目管理API
    
    @PostMapping
    public Result createProject(@RequestBody ProjectCreateRequest request) {
        // 创建项目
    }
    
    @GetMapping
    public Result listProjects() {
        // 查询项目列表
    }
    
    @PutMapping("/{id}")
    public Result updateProject(@PathVariable Integer id, 
                              @RequestBody ProjectUpdateRequest request) {
        // 更新项目
    }
    
    @DeleteMapping("/{id}")
    public Result deleteProject(@PathVariable Integer id) {
        // 删除项目
    }
}

@RestController
@RequestMapping("/v1/workflows")
public class WorkflowController {
    // 工作流管理API
    
    @PostMapping("/definitions")
    public Result createWorkflowDefinition(@RequestBody WorkflowDefinition definition) {
        // 创建工作流定义
    }
    
    @PostMapping("/instances")
    public Result runWorkflow(@RequestBody WorkflowRunRequest request) {
        // 执行工作流
    }
}
```

## 2.3 核心概念深入理解

### 2.3.1 DAG工作流

#### 2.3.1.1 DAG原理

DAG（Directed Acyclic Graph，有向无环图）是一种常用的数据结构，用于表示任务间的依赖关系。

在DolphinScheduler中，每个工作流就是一个DAG，其中：
- 节点表示任务
- 边表示依赖关系
- 箭头方向表示执行顺序

#### 2.3.1.2 DAG验证算法

```java
public class DAGValidator {
    public boolean validate(DAG dag) {
        // 1. 检查是否有环
        if (hasCycle(dag)) {
            return false;
        }
        
        // 2. 检查孤立节点
        if (hasIsolatedNodes(dag)) {
            return false;
        }
        
        // 3. 检查多重依赖
        if (hasMultipleParents(dag)) {
            return false;
        }
        
        return true;
    }
    
    private boolean hasCycle(DAG dag) {
        // 使用DFS或拓扑排序检查是否有环
        Set<Node> visited = new HashSet<>();
        Set<Node> recursionStack = new HashSet<>();
        
        for (Node node : dag.getNodes()) {
            if (hasCycleUtil(node, visited, recursionStack)) {
                return true;
            }
        }
        return false;
    }
}
```

### 2.3.2 任务类型详解

#### 2.3.2.1 Shell任务

Shell任务是最基础的任务类型，用于执行Shell脚本：

```json
{
  "taskType": "SHELL",
  "taskParams": {
    "rawScript": "#!/bin/bash\necho 'Hello DolphinScheduler'\ndate\n",
    "localParams": [
      {
        "prop": "param1",
        "direct": "IN",
        "type": "VARCHAR",
        "value": "value1"
      }
    ]
  }
}
```

#### 2.3.2.2 SQL任务

SQL任务用于执行数据库查询：

```json
{
  "taskType": "SQL",
  "taskParams": {
    "type": "MYSQL",
    "datasource": 1,
    "sql": "SELECT COUNT(*) FROM orders WHERE create_date = '${bizDate}'",
    "udfs": "",
    "showType": "TABLE",
    "connParams": "",
    "preStatements": [],
    "postStatements": []
  }
}
```

#### 2.3.2.3 条件分支任务

条件分支任务用于实现条件判断：

```json
{
  "taskType": "CONDITIONS",
  "taskParams": {
    "conditionResult": {
      "successNode": [
        "task_A"
      ],
      "failedNode": [
        "task_B"
      ]
    },
    "dependence": {
      "relation": "AND",
      "dependTaskList": [
        {
          "relation": "AND",
          "dependItemList": [
            {
              "regx": "",
              "depTaskCode": 123456,
              "status": "SUCCESS"
            }
          ]
        }
      ]
    }
  }
}
```

#### 2.3.2.4 子工作流任务

子工作流任务用于嵌套执行其他工作流：

```json
{
  "taskType": "SUB_PROCESS",
  "taskParams": {
    "processDefinitionId": 456,
    "releaseState": "ONLINE",
    "globalParams": []
  }
}
```

### 2.3.3 参数传递机制

#### 2.3.3.1 参数类型

1. **全局参数**：工作流级别的参数
2. **局部参数**：任务级别的参数
3. **系统参数**：系统预定义参数
4. **时间参数**：与时间相关的参数

#### 2.3.3.2 参数传递规则

```java
public class ParameterProcessor {
    public Map<String, Object> processParameters(TaskInstance taskInstance) {
        Map<String, Object> parameters = new HashMap<>();
        
        // 1. 获取全局参数
        Map<String, Object> globalParams = getGlobalParameters(taskInstance.getProcessInstance());
        parameters.putAll(globalParams);
        
        // 2. 获取局部参数
        Map<String, Object> localParams = getLocalParameters(taskInstance);
        parameters.putAll(localParams);
        
        // 3. 添加系统参数
        parameters.putAll(getSystemParameters());
        
        // 4. 解析时间参数
        resolveTimeParameters(parameters);
        
        // 5. 参数值替换
        substituteParameterValues(parameters);
        
        return parameters;
    }
    
    private void resolveTimeParameters(Map<String, Object> parameters) {
        // 解析时间相关参数
        // 如：${bizDate} -> 20230101
        //     ${currentTime} -> 2023-01-01 12:00:00
    }
}
```

### 2.3.4 调度机制

#### 2.3.4.1 调度类型

1. **定时调度**：基于Cron表达式的定时执行
2. **手动触发**：用户手动触发执行
3. **依赖触发**：基于外部依赖触发
4. **API触发**：通过API调用触发

#### 2.3.4.2 调度队列

```java
public class TaskQueue {
    private PriorityBlockingQueue<TaskInstance> highPriorityQueue;
    private PriorityBlockingQueue<TaskInstance> mediumPriorityQueue;
    private PriorityBlockingQueue<TaskInstance> lowPriorityQueue;
    
    public TaskInstance pollTask() {
        // 1. 优先检查高优先级队列
        TaskInstance task = highPriorityQueue.poll();
        if (task != null) {
            return task;
        }
        
        // 2. 检查中优先级队列
        task = mediumPriorityQueue.poll();
        if (task != null) {
            return task;
        }
        
        // 3. 检查低优先级队列
        return lowPriorityQueue.poll();
    }
}
```

### 2.3.5 容错机制

#### 2.3.5.1 Master容错

当Active Master故障时：

1. ZooKeeper检测到Master节点失效
2. 触发Master选举，选出新的Active Master
3. 新Master从数据库恢复状态
4. 重新调度未完成的任务

#### 2.3.5.2 Worker容错

当Worker节点故障时：

1. Master检测到Worker心跳超时
2. Master将Worker标记为不可用
3. 重新分发该Worker上的任务
4. 更新任务执行状态

```java
public class FailoverProcessor {
    public void processWorkerFailover(String workerAddress) {
        // 1. 查找该Worker上运行的任务
        List<TaskInstance> runningTasks = findRunningTasksByWorker(workerAddress);
        
        // 2. 标记任务为失败
        for (TaskInstance task : runningTasks) {
            task.setState(ExecutionStatus.FAILURE);
            task.setEndTime(new Date());
            updateTaskInstance(task);
        }
        
        // 3. 触发重试机制
        for (TaskInstance task : runningTasks) {
            if (task.getRetryTimes() < task.getMaxRetryTimes()) {
                retryTask(task);
            }
        }
    }
}
```

## 2.4 高级特性

### 2.4.1 任务分组

DolphinScheduler支持任务分组功能，可以将相关的任务组织在一起：

```json
{
  "taskGroup": {
    "id": 1,
    "name": "数据抽取任务组",
    "description": "所有数据抽取相关的任务",
    "groupSize": 100,
    "status": "ENABLE"
  }
}
```

### 2.4.2 资源中心

资源中心用于管理任务执行过程中需要的文件：

1. **文件上传**：上传脚本、配置文件等
2. **文件版本**：管理文件版本历史
3. **文件下载**：Worker下载需要的文件
4. **权限控制**：控制文件访问权限

### 2.4.3 UDF函数

支持自定义UDF函数扩展SQL功能：

```java
public class CustomUDF {
    @UDF
    public static String formatDate(String dateStr) {
        // 自定义日期格式化函数
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        Date date = sdf.parse(dateStr);
        return sdf.format(date);
    }
    
    @UDF
    public static Double calculateTax(Double amount) {
        // 自定义税率计算函数
        return amount * 0.13;
    }
}
```

## 2.5 最佳实践

### 2.5.1 架构设计最佳实践

1. **Master节点**：至少部署3个，确保高可用
2. **Worker节点**：根据任务类型和负载合理分配
3. **ZooKeeper集群**：部署奇数个节点（3、5、7）
4. **数据库**：主从部署，定期备份

### 2.5.2 网络规划

1. **内部网络**：Master和Worker之间使用高速内网
2. **外部网络**：UI访问端口暴露到外网
3. **数据源网络**：Worker需要访问各种数据源
4. **安全组**：配置合理的防火墙规则

### 2.5.3 监控告警

1. **系统监控**：CPU、内存、磁盘、网络
2. **应用监控**：任务成功率、执行时间、队列长度
3. **业务监控**：工作流完成情况、数据质量
4. **告警配置**：合理设置告警阈值和通知方式

## 2.6 小结

本章深入介绍了DolphinScheduler的系统架构和核心概念，我们了解到：

1. **分布式架构**：Master-Worker架构实现高可用和水平扩展
2. **核心组件**：Master、Worker、API Server等组件各司其职
3. **DAG工作流**：有向无环图表示任务依赖关系
4. **任务类型**：丰富的任务类型满足不同需求
5. **参数传递**：灵活的参数传递机制
6. **调度机制**：多种调度方式和优先级控制
7. **容错机制**：完善的容错处理保证系统稳定

在下一章中，我们将详细介绍如何安装和部署DolphinScheduler，包括不同的部署方式和环境配置。